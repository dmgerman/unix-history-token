begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevxini.c */
end_comment

begin_comment
comment|/* X Windows driver initialization for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_comment
comment|/* for gx_bitmap; includes std.h */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"x_.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gdevx.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
argument_list|(
name|P1
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|atof
argument_list|(
name|P1
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define whether to use a backing pixmap to handle expose events. */
end_comment

begin_comment
comment|/* Note that this is a variable rather than a #define. */
end_comment

begin_comment
comment|/* Note also that it is consulted each time we open an X device. */
end_comment

begin_decl_stmt
name|private
name|int
name|use_backing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define default window parameters. */
end_comment

begin_comment
comment|/* Some of these can be set in the makefile. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PROGRAM_NAME
end_ifndef

begin_define
define|#
directive|define
name|PROGRAM_NAME
value|"Ghostscript"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARG_BORDER_WIDTH
value|"borderWidth"
end_define

begin_define
define|#
directive|define
name|DEFAULT_BORDER_WIDTH
value|1
end_define

begin_define
define|#
directive|define
name|ARG_BORDER_COLOR
value|"borderColor"
end_define

begin_define
define|#
directive|define
name|DEFAULT_BORDER_COLOR
value|pixel_black
end_define

begin_define
define|#
directive|define
name|ARG_GEOMETRY
value|"geometry"
end_define

begin_define
define|#
directive|define
name|DEFAULT_X_POSITION
value|0
end_define

begin_define
define|#
directive|define
name|DEFAULT_Y_POSITION
value|0
end_define

begin_define
define|#
directive|define
name|ARG_X_RESOLUTION
value|"xResolution"
end_define

begin_define
define|#
directive|define
name|ARG_Y_RESOLUTION
value|"yResolution"
end_define

begin_comment
comment|/* Define constants for orientation from ghostview */
end_comment

begin_comment
comment|/* Number represents clockwise rotation of the paper in degrees */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|Portrait
init|=
literal|0
block|,
comment|/* Normal portrait orientation */
name|Landscape
init|=
literal|90
block|,
comment|/* Normal landscape orientation */
name|Upsidedown
init|=
literal|180
block|,
comment|/* Don't think this will be used much */
name|Seascape
init|=
literal|270
comment|/* Landscape rotated the wrong way */
block|}
name|orientation
typedef|;
end_typedef

begin_comment
comment|/* Open the X device */
end_comment

begin_function
name|int
name|gdev_x_open
parameter_list|(
specifier|register
name|gx_device_X
modifier|*
name|xdev
parameter_list|)
block|{
name|XSizeHints
name|sizehints
decl_stmt|;
name|int
name|border_width
decl_stmt|;
name|char
modifier|*
name|border_width_str
decl_stmt|,
modifier|*
name|border_color_str
decl_stmt|;
name|unsigned
name|long
name|border_color
decl_stmt|;
name|char
modifier|*
name|geometry
decl_stmt|;
name|char
modifier|*
name|window_id
decl_stmt|;
name|XColor
name|screen_color
decl_stmt|,
name|exact_color
decl_stmt|;
name|XSetWindowAttributes
name|xswa
decl_stmt|;
name|XEvent
name|event
decl_stmt|;
name|XVisualInfo
name|xvinfo
decl_stmt|;
name|int
name|nitems
decl_stmt|;
if|#
directive|if
name|HaveStdCMap
name|XStandardColormap
modifier|*
name|scmap
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|Atom
name|prop
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'X'
index|]
condition|)
block|{
specifier|extern
name|int
name|_Xdebug
decl_stmt|;
name|_Xdebug
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|xdev
operator|->
name|dpy
operator|=
name|XOpenDisplay
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|dispname
init|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
decl_stmt|;
name|eprintf1
argument_list|(
literal|"gs: Cannot open X display `%s'.\n"
argument_list|,
operator|(
name|dispname
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|dispname
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|window_id
operator|=
name|getenv
argument_list|(
literal|"GHOSTVIEW"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xdev
operator|->
name|ghostview
operator|=
name|sscanf
argument_list|(
name|window_id
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|win
operator|)
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|dest
operator|)
argument_list|)
operator|)
condition|)
block|{
name|eprintf
argument_list|(
literal|"gs: Cannot get Window from ghostview.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xdev
operator|->
name|ghostview
condition|)
block|{
name|XWindowAttributes
name|attrib
decl_stmt|;
name|Atom
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
name|unsigned
name|long
name|nitems
decl_stmt|,
name|bytes_after
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|Atom
name|ghostview_atom
init|=
name|XInternAtom
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
literal|"GHOSTVIEW"
argument_list|,
name|False
argument_list|)
decl_stmt|;
if|if
condition|(
name|XGetWindowAttributes
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
operator|&
name|attrib
argument_list|)
condition|)
block|{
name|xdev
operator|->
name|scr
operator|=
name|attrib
operator|.
name|screen
expr_stmt|;
name|xvinfo
operator|.
name|visual
operator|=
name|attrib
operator|.
name|visual
expr_stmt|;
name|xdev
operator|->
name|cmap
operator|=
name|attrib
operator|.
name|colormap
expr_stmt|;
name|xdev
operator|->
name|width
operator|=
name|attrib
operator|.
name|width
expr_stmt|;
name|xdev
operator|->
name|height
operator|=
name|attrib
operator|.
name|height
expr_stmt|;
block|}
comment|/* Delete property if explicit dest is given */
if|if
condition|(
name|XGetWindowProperty
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|ghostview_atom
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|,
operator|(
name|xdev
operator|->
name|dest
operator|!=
literal|0
operator|)
argument_list|,
name|XA_STRING
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|nitems
argument_list|,
operator|&
name|bytes_after
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|llx
decl_stmt|,
name|lly
decl_stmt|,
name|urx
decl_stmt|,
name|ury
decl_stmt|;
name|int
name|left_margin
init|=
literal|0
decl_stmt|,
name|bottom_margin
init|=
literal|0
decl_stmt|;
name|int
name|right_margin
init|=
literal|0
decl_stmt|,
name|top_margin
init|=
literal|0
decl_stmt|;
comment|/* We declare page_orientation as an int so that we can */
comment|/* use an int * to reference it for sscanf; compilers */
comment|/* might be tempted to use less space to hold it if */
comment|/* it was declared as an orientation. */
name|int
comment|/*orientation*/
name|page_orientation
decl_stmt|;
name|float
name|xppp
decl_stmt|,
name|yppp
decl_stmt|;
comment|/* pixels per point */
name|nitems
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d %d %d %d %d %d %f %f %d %d %d %d %d %d"
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|bpixmap
operator|)
argument_list|,
operator|&
name|page_orientation
argument_list|,
operator|&
name|llx
argument_list|,
operator|&
name|lly
argument_list|,
operator|&
name|urx
argument_list|,
operator|&
name|ury
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|x_pixels_per_inch
operator|)
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|y_pixels_per_inch
operator|)
argument_list|,
operator|&
name|left_margin
argument_list|,
operator|&
name|bottom_margin
argument_list|,
operator|&
name|right_margin
argument_list|,
operator|&
name|top_margin
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|width
operator|)
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|height
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|xdev
operator|->
name|dest
operator|&&
operator|!
operator|(
name|nitems
operator|==
literal|8
operator|||
name|nitems
operator|==
literal|12
operator|)
operator|)
operator|||
operator|(
name|xdev
operator|->
name|dest
operator|&&
name|nitems
operator|!=
literal|14
operator|)
condition|)
block|{
name|eprintf
argument_list|(
literal|"gs: Cannot get ghostview property.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xdev
operator|->
name|dest
operator|&&
name|xdev
operator|->
name|bpixmap
condition|)
block|{
name|eprintf
argument_list|(
literal|"gs: Both destination and backing pixmap specified.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|xppp
operator|=
name|xdev
operator|->
name|x_pixels_per_inch
operator|/
literal|72.0
expr_stmt|;
name|yppp
operator|=
name|xdev
operator|->
name|y_pixels_per_inch
operator|/
literal|72.0
expr_stmt|;
switch|switch
condition|(
name|page_orientation
condition|)
block|{
case|case
name|Portrait
case|:
name|xdev
operator|->
name|initial_matrix
operator|.
name|xx
operator|=
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|xy
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yx
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yy
operator|=
operator|-
name|yppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|tx
operator|=
operator|-
name|llx
operator|*
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|ty
operator|=
name|ury
operator|*
name|yppp
expr_stmt|;
break|break;
case|case
name|Landscape
case|:
name|xdev
operator|->
name|initial_matrix
operator|.
name|xx
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|xy
operator|=
name|yppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yx
operator|=
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yy
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|tx
operator|=
operator|-
name|lly
operator|*
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|ty
operator|=
operator|-
name|llx
operator|*
name|yppp
expr_stmt|;
break|break;
case|case
name|Upsidedown
case|:
name|xdev
operator|->
name|initial_matrix
operator|.
name|xx
operator|=
operator|-
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|xy
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yx
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yy
operator|=
name|yppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|tx
operator|=
name|urx
operator|*
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|ty
operator|=
operator|-
name|lly
operator|*
name|yppp
expr_stmt|;
break|break;
case|case
name|Seascape
case|:
name|xdev
operator|->
name|initial_matrix
operator|.
name|xx
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|xy
operator|=
operator|-
name|yppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yx
operator|=
operator|-
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|yy
operator|=
literal|0.0
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|tx
operator|=
name|ury
operator|*
name|xppp
expr_stmt|;
name|xdev
operator|->
name|initial_matrix
operator|.
name|ty
operator|=
name|urx
operator|*
name|yppp
expr_stmt|;
break|break;
block|}
comment|/* The following sets the imageable area according to the */
comment|/* bounding box and margins sent by ghostview.            */
name|xdev
operator|->
name|l_margin
operator|=
operator|(
name|llx
operator|-
name|left_margin
operator|)
operator|/
literal|72.0
expr_stmt|;
name|xdev
operator|->
name|b_margin
operator|=
operator|(
name|lly
operator|-
name|bottom_margin
operator|)
operator|/
literal|72.0
expr_stmt|;
name|xdev
operator|->
name|r_margin
operator|=
name|xdev
operator|->
name|width
operator|/
name|xdev
operator|->
name|x_pixels_per_inch
operator|-
operator|(
name|urx
operator|+
name|right_margin
operator|)
operator|/
literal|72.0
expr_stmt|;
name|xdev
operator|->
name|t_margin
operator|=
name|xdev
operator|->
name|height
operator|/
name|xdev
operator|->
name|y_pixels_per_inch
operator|-
operator|(
name|ury
operator|+
name|top_margin
operator|)
operator|/
literal|72.0
expr_stmt|;
block|}
else|else
block|{
name|eprintf
argument_list|(
literal|"gs: Cannot get ghostview property.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Screen
modifier|*
name|scr
init|=
name|DefaultScreenOfDisplay
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|)
decl_stmt|;
name|xdev
operator|->
name|scr
operator|=
name|scr
expr_stmt|;
name|xvinfo
operator|.
name|visual
operator|=
name|DefaultVisualOfScreen
argument_list|(
name|scr
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|cmap
operator|=
name|DefaultColormapOfScreen
argument_list|(
name|scr
argument_list|)
expr_stmt|;
block|}
name|xvinfo
operator|.
name|visualid
operator|=
name|XVisualIDFromVisual
argument_list|(
name|xvinfo
operator|.
name|visual
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|vinfo
operator|=
name|XGetVisualInfo
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|VisualIDMask
argument_list|,
operator|&
name|xvinfo
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|vinfo
operator|==
name|NULL
condition|)
block|{
name|eprintf
argument_list|(
literal|"gs: Cannot get XVisualInfo.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|xdev
operator|->
name|color_info
operator|.
name|num_components
operator|=
operator|(
operator|(
name|xdev
operator|->
name|vinfo
operator|->
name|class
operator|!=
name|StaticGray
operator|)
operator|&&
operator|(
name|xdev
operator|->
name|vinfo
operator|->
name|class
operator|!=
name|GrayScale
operator|)
condition|?
literal|3
else|:
literal|1
operator|)
expr_stmt|;
if|#
directive|if
name|HaveStdCMap
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|xdev
argument_list|)
condition|)
block|{
if|if
condition|(
name|xvinfo
operator|.
name|visual
operator|==
name|DefaultVisualOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
condition|)
name|prop
operator|=
name|XA_RGB_DEFAULT_MAP
expr_stmt|;
else|else
name|prop
operator|=
name|XA_RGB_BEST_MAP
expr_stmt|;
block|}
else|else
name|prop
operator|=
name|XA_RGB_GRAY_MAP
expr_stmt|;
if|if
condition|(
name|XGetRGBColormaps
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|RootWindowOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
argument_list|,
operator|&
name|scmap
argument_list|,
operator|&
name|nitems
argument_list|,
name|prop
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|scmap
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|xdev
operator|->
name|ghostview
operator|&&
operator|(
name|xdev
operator|->
name|cmap
operator|==
name|sp
operator|->
name|colormap
operator|)
operator|)
operator|||
operator|(
operator|!
name|xdev
operator|->
name|ghostview
operator|&&
operator|(
name|xdev
operator|->
name|vinfo
operator|->
name|visualid
operator|==
name|sp
operator|->
name|visualid
operator|)
operator|)
condition|)
block|{
name|xdev
operator|->
name|std_cmap
operator|=
name|sp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|xdev
operator|->
name|std_cmap
condition|)
block|{
name|xdev
operator|->
name|cmap
operator|=
name|xdev
operator|->
name|std_cmap
operator|->
name|colormap
expr_stmt|;
comment|/* Acquire white and black pixel values. */
if|if
condition|(
name|xdev
operator|->
name|cmap
operator|==
name|DefaultColormapOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
condition|)
block|{
name|pixel_black
operator|=
name|BlackPixelOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
expr_stmt|;
name|pixel_white
operator|=
name|WhitePixelOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|pixv
parameter_list|(
name|v
parameter_list|)
define|\
value|color_index_to_pixel((*xdev->procs->map_rgb_color)((gx_device *)xdev,\ 						      v, v, v))
name|pixel_black
operator|=
name|pixv
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pixel_white
operator|=
name|pixv
argument_list|(
name|gx_max_color_value
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|pixv
block|}
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|xdev
argument_list|)
condition|)
block|{
comment|/* Set the color_info in the device structure. */
name|xdev
operator|->
name|color_info
operator|.
name|max_gray
operator|=
name|xdev
operator|->
name|color_info
operator|.
name|max_rgb
operator|=
name|min
argument_list|(
name|xdev
operator|->
name|std_cmap
operator|->
name|red_max
argument_list|,
name|min
argument_list|(
name|xdev
operator|->
name|std_cmap
operator|->
name|green_max
argument_list|,
name|xdev
operator|->
name|std_cmap
operator|->
name|blue_max
argument_list|)
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|color_info
operator|.
name|depth
operator|=
literal|8
expr_stmt|;
comment|/* arbitrary */
name|xdev
operator|->
name|color_info
operator|.
name|dither_gray
operator|=
name|xdev
operator|->
name|color_info
operator|.
name|dither_rgb
operator|=
name|xdev
operator|->
name|color_info
operator|.
name|max_rgb
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xdev
operator|->
name|color_info
operator|.
name|max_gray
operator|=
name|xdev
operator|->
name|std_cmap
operator|->
name|red_max
operator|+
name|xdev
operator|->
name|std_cmap
operator|->
name|green_max
operator|+
name|xdev
operator|->
name|std_cmap
operator|->
name|blue_max
expr_stmt|;
name|xdev
operator|->
name|color_info
operator|.
name|depth
operator|=
literal|8
expr_stmt|;
comment|/* arbitrary */
name|xdev
operator|->
name|color_info
operator|.
name|dither_gray
operator|=
name|xdev
operator|->
name|color_info
operator|.
name|max_gray
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|xdev
operator|->
name|cmap
operator|==
name|DefaultColormapOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
condition|)
block|{
name|pixel_black
operator|=
name|BlackPixelOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
expr_stmt|;
name|pixel_white
operator|=
name|WhitePixelOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XColor
name|xc
decl_stmt|;
name|xc
operator|.
name|red
operator|=
name|xc
operator|.
name|green
operator|=
name|xc
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|XAllocColor
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cmap
argument_list|,
operator|&
name|xc
argument_list|)
expr_stmt|;
name|pixel_black
operator|=
name|xc
operator|.
name|pixel
expr_stmt|;
name|xc
operator|.
name|red
operator|=
name|xc
operator|.
name|green
operator|=
name|xc
operator|.
name|blue
operator|=
operator|~
operator|(
name|ushort
operator|)
literal|0
expr_stmt|;
name|XAllocColor
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cmap
argument_list|,
operator|&
name|xc
argument_list|)
expr_stmt|;
name|pixel_white
operator|=
name|xc
operator|.
name|pixel
expr_stmt|;
block|}
comment|/* Figure out monochrome vs. color */
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|xdev
argument_list|)
condition|)
comment|/* Just do primary colors for now */
block|{
name|XColor
name|xc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|xc
operator|.
name|red
operator|=
operator|(
name|i
operator|&
literal|4
condition|?
operator|~
operator|(
name|ushort
operator|)
literal|0
else|:
literal|0
operator|)
expr_stmt|;
name|xc
operator|.
name|green
operator|=
operator|(
name|i
operator|&
literal|2
condition|?
operator|~
operator|(
name|ushort
operator|)
literal|0
else|:
literal|0
operator|)
expr_stmt|;
name|xc
operator|.
name|blue
operator|=
operator|(
name|i
operator|&
literal|1
condition|?
operator|~
operator|(
name|ushort
operator|)
literal|0
else|:
literal|0
operator|)
expr_stmt|;
name|XAllocColor
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cmap
argument_list|,
operator|&
name|xc
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|colors
index|[
name|i
index|]
operator|=
name|xc
operator|.
name|pixel
expr_stmt|;
block|}
name|xdev
operator|->
name|color_info
operator|.
name|max_rgb
operator|=
literal|1
expr_stmt|;
name|xdev
operator|->
name|color_info
operator|.
name|dither_rgb
operator|=
literal|2
expr_stmt|;
name|xdev
operator|->
name|color_info
operator|.
name|depth
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|xdev
operator|->
name|colors
index|[
name|i
index|]
operator|=
name|pixel_white
expr_stmt|;
block|}
block|}
comment|/* Check for a pixel value equal to gx_no_color_index. */
if|if
condition|(
if|#
directive|if
name|HaveStdCMap
operator|!
name|xdev
operator|->
name|std_cmap
operator|&&
endif|#
directive|endif
operator|(
name|pixel_black
operator|==
name|gx_no_color_index
operator|||
name|pixel_white
operator|==
name|gx_no_color_index
operator|)
condition|)
block|{
comment|/* Pick a non-zero value guaranteed not to map any primary */
comment|/* color to gx_no_color_index. */
name|xdev
operator|->
name|pixel_fix
operator|=
literal|0x100000ff
operator|^
operator|(
name|xdev
operator|->
name|colors
index|[
literal|1
index|]
operator|&
literal|2
operator|)
operator|^
operator|(
name|xdev
operator|->
name|colors
index|[
literal|2
index|]
operator|&
literal|4
operator|)
operator|^
operator|(
name|xdev
operator|->
name|colors
index|[
literal|3
index|]
operator|&
literal|8
operator|)
operator|^
operator|(
name|xdev
operator|->
name|colors
index|[
literal|4
index|]
operator|&
literal|16
operator|)
operator|^
operator|(
name|xdev
operator|->
name|colors
index|[
literal|5
index|]
operator|&
literal|32
operator|)
operator|^
operator|(
name|xdev
operator|->
name|colors
index|[
literal|6
index|]
operator|&
literal|64
operator|)
expr_stmt|;
block|}
else|else
block|{
name|xdev
operator|->
name|pixel_fix
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xdev
operator|->
name|ghostview
condition|)
block|{
comment|/* 	     * Figure out the resolution of our screen; 25.4 is the 	     * number of millimeters in an inch.  The only reason for 	     * allowing the user to specify the resolution is that 	     * X servers commonly lie about it (and about the screen size). 	     * We assume that the server is more likely to lie about 	     * the resolution than about the pixel size of the screen. 	     * Don't do any of this if the resolution was set from the 	     * command line (detected by resolution != FAKE_RES). 	     */
if|if
condition|(
name|xdev
operator|->
name|x_pixels_per_inch
operator|==
name|FAKE_RES
condition|)
block|{
name|char
modifier|*
name|x_res_str
init|=
name|XGetDefault
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|PROGRAM_NAME
argument_list|,
name|ARG_X_RESOLUTION
argument_list|)
decl_stmt|;
name|char
modifier|*
name|y_res_str
init|=
name|XGetDefault
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|PROGRAM_NAME
argument_list|,
name|ARG_Y_RESOLUTION
argument_list|)
decl_stmt|;
name|float
name|x_res
decl_stmt|,
name|y_res
decl_stmt|;
if|if
condition|(
name|x_res_str
operator|!=
name|NULL
operator|&&
name|y_res_str
operator|!=
name|NULL
condition|)
block|{
name|x_res
operator|=
name|atof
argument_list|(
name|x_res_str
argument_list|)
expr_stmt|;
name|y_res
operator|=
name|atof
argument_list|(
name|y_res_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|screen_width
init|=
name|WidthOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
decl_stmt|;
name|int
name|screen_height
init|=
name|HeightOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
decl_stmt|;
name|x_res
operator|=
literal|25.4
operator|*
name|screen_width
operator|/
name|WidthMMOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
expr_stmt|;
name|y_res
operator|=
literal|25.4
operator|*
name|screen_height
operator|/
name|HeightMMOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_res
operator|*
name|DEFAULT_WIDTH_INCHES
operator|>
name|screen_width
operator|||
name|y_res
operator|*
name|DEFAULT_HEIGHT_INCHES
operator|>
name|screen_height
condition|)
block|{
comment|/* Force a full page to fit on the screen */
comment|/* by adjusting the server's claimed resolution. */
name|x_res
operator|=
operator|(
name|screen_width
operator|-
literal|32
operator|)
operator|/
operator|(
name|float
operator|)
name|DEFAULT_WIDTH_INCHES
expr_stmt|;
name|y_res
operator|=
operator|(
name|screen_height
operator|-
literal|32
operator|)
operator|/
operator|(
name|float
operator|)
name|DEFAULT_HEIGHT_INCHES
expr_stmt|;
name|x_res
operator|=
name|y_res
operator|=
name|min
argument_list|(
name|x_res
argument_list|,
name|y_res
argument_list|)
expr_stmt|;
block|}
block|}
name|xdev
operator|->
name|x_pixels_per_inch
operator|=
name|x_res
expr_stmt|;
name|xdev
operator|->
name|y_pixels_per_inch
operator|=
name|y_res
expr_stmt|;
block|}
comment|/* Get defaults from the database. */
name|border_width_str
operator|=
name|XGetDefault
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|PROGRAM_NAME
argument_list|,
name|ARG_BORDER_WIDTH
argument_list|)
expr_stmt|;
name|border_width
operator|=
operator|(
name|border_width_str
operator|==
name|NULL
condition|?
name|DEFAULT_BORDER_WIDTH
else|:
name|atoi
argument_list|(
name|border_width_str
argument_list|)
operator|)
expr_stmt|;
name|border_color_str
operator|=
name|XGetDefault
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|PROGRAM_NAME
argument_list|,
name|ARG_BORDER_COLOR
argument_list|)
expr_stmt|;
name|border_color
operator|=
operator|(
name|border_color_str
operator|==
name|NULL
operator|||
operator|!
name|XAllocNamedColor
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cmap
argument_list|,
name|border_color_str
argument_list|,
operator|&
name|screen_color
argument_list|,
operator|&
name|exact_color
argument_list|)
condition|?
name|DEFAULT_BORDER_COLOR
else|:
name|screen_color
operator|.
name|pixel
operator|)
expr_stmt|;
name|sizehints
operator|.
name|x
operator|=
name|DEFAULT_X_POSITION
expr_stmt|;
name|sizehints
operator|.
name|y
operator|=
name|DEFAULT_Y_POSITION
expr_stmt|;
name|sizehints
operator|.
name|width
operator|=
call|(
name|int
call|)
argument_list|(
name|xdev
operator|->
name|x_pixels_per_inch
operator|*
name|DEFAULT_WIDTH_INCHES
argument_list|)
expr_stmt|;
name|sizehints
operator|.
name|height
operator|=
call|(
name|int
call|)
argument_list|(
name|xdev
operator|->
name|y_pixels_per_inch
operator|*
name|DEFAULT_HEIGHT_INCHES
argument_list|)
expr_stmt|;
name|sizehints
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|geometry
operator|=
name|XGetDefault
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|PROGRAM_NAME
argument_list|,
name|ARG_GEOMETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|geometry
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * Note that border_width must be set first.  We can't use 		     * scr, because that is a Screen*, and XGeometry wants 		     * the screen number. 		     */
name|char
name|gstr
index|[
literal|40
index|]
decl_stmt|;
name|int
name|bitmask
decl_stmt|;
name|sprintf
argument_list|(
name|gstr
argument_list|,
literal|"%dx%d+%d+%d"
argument_list|,
name|sizehints
operator|.
name|width
argument_list|,
name|sizehints
operator|.
name|height
argument_list|,
name|sizehints
operator|.
name|x
argument_list|,
name|sizehints
operator|.
name|y
argument_list|)
expr_stmt|;
name|bitmask
operator|=
name|XGeometry
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|DefaultScreen
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|)
argument_list|,
name|geometry
argument_list|,
name|gstr
argument_list|,
name|border_width
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
comment|/* ``Font'' width and height. */
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Interior padding. */
operator|&
name|sizehints
operator|.
name|x
argument_list|,
operator|&
name|sizehints
operator|.
name|y
argument_list|,
operator|&
name|sizehints
operator|.
name|width
argument_list|,
operator|&
name|sizehints
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmask
operator|&
operator|(
name|XValue
operator||
name|YValue
operator|)
condition|)
name|sizehints
operator|.
name|flags
operator||=
name|USPosition
expr_stmt|;
if|if
condition|(
name|bitmask
operator|&
operator|(
name|WidthValue
operator||
name|HeightValue
operator|)
condition|)
name|sizehints
operator|.
name|flags
operator||=
name|USSize
expr_stmt|;
block|}
if|if
condition|(
name|xdev
operator|->
name|width
operator|==
call|(
name|int
call|)
argument_list|(
name|FAKE_RES
operator|*
name|DEFAULT_WIDTH_INCHES
argument_list|)
condition|)
name|xdev
operator|->
name|width
operator|=
name|sizehints
operator|.
name|width
operator|,
name|xdev
operator|->
name|height
operator|=
name|sizehints
operator|.
name|height
expr_stmt|;
else|else
comment|/* set from command line */
name|sizehints
operator|.
name|width
operator|=
name|xdev
operator|->
name|width
operator|,
name|sizehints
operator|.
name|height
operator|=
name|xdev
operator|->
name|height
expr_stmt|;
name|gx_default_get_initial_matrix
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|xdev
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|initial_matrix
operator|)
argument_list|)
expr_stmt|;
name|xswa
operator|.
name|event_mask
operator|=
name|ExposureMask
expr_stmt|;
name|xswa
operator|.
name|background_pixel
operator|=
name|pixel_black
expr_stmt|;
name|xswa
operator|.
name|border_pixel
operator|=
name|border_color
expr_stmt|;
name|xswa
operator|.
name|colormap
operator|=
name|xdev
operator|->
name|cmap
expr_stmt|;
name|xdev
operator|->
name|win
operator|=
name|XCreateWindow
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|RootWindowOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
argument_list|,
name|sizehints
operator|.
name|x
argument_list|,
name|sizehints
operator|.
name|y
argument_list|,
comment|/* upper left */
name|sizehints
operator|.
name|width
argument_list|,
name|sizehints
operator|.
name|height
argument_list|,
name|border_width
argument_list|,
name|xdev
operator|->
name|vinfo
operator|->
name|depth
argument_list|,
name|InputOutput
argument_list|,
comment|/* class */
name|xdev
operator|->
name|vinfo
operator|->
name|visual
argument_list|,
comment|/* visual */
name|CWEventMask
operator||
name|CWBackPixel
operator||
name|CWBorderPixel
operator||
name|CWColormap
argument_list|,
operator|&
name|xswa
argument_list|)
expr_stmt|;
name|XChangeProperty
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|XA_WM_NAME
argument_list|,
name|XA_STRING
argument_list|,
literal|8
argument_list|,
name|PropModeReplace
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|PROGRAM_NAME
argument_list|,
name|strlen
argument_list|(
name|PROGRAM_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|XSetNormalHints
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
operator|&
name|sizehints
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_backing
condition|)
name|xdev
operator|->
name|bpixmap
operator|=
name|XCreatePixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|xdev
operator|->
name|width
argument_list|,
name|xdev
operator|->
name|height
argument_list|,
name|xdev
operator|->
name|vinfo
operator|->
name|depth
argument_list|)
expr_stmt|;
else|else
name|xdev
operator|->
name|bpixmap
operator|=
operator|(
name|Pixmap
operator|)
literal|0
expr_stmt|;
block|}
name|xdev
operator|->
name|ht
operator|.
name|pixmap
operator|=
operator|(
name|Pixmap
operator|)
literal|0
expr_stmt|;
name|xdev
operator|->
name|ht
operator|.
name|id
operator|=
name|gx_no_bitmap_id
expr_stmt|;
empty_stmt|;
name|xdev
operator|->
name|fill_style
operator|=
name|FillSolid
expr_stmt|;
name|xdev
operator|->
name|function
operator|=
name|GXcopy
expr_stmt|;
comment|/* Set up a graphics context */
name|xdev
operator|->
name|gc
operator|=
name|XCreateGC
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
literal|0
argument_list|,
operator|(
name|XGCValues
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|XSetFunction
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|XSetLineAttributes
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
name|LineSolid
argument_list|,
name|CapButt
argument_list|,
name|JoinMiter
argument_list|)
expr_stmt|;
comment|/* Clear the destination pixmap to avoid initializing with garbage. */
if|if
condition|(
name|xdev
operator|->
name|dest
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
name|XSetForeground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|pixel_white
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|dest
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xdev
operator|->
name|width
argument_list|,
name|xdev
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xdev
operator|->
name|dest
operator|=
operator|(
name|xdev
operator|->
name|bpixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|?
name|xdev
operator|->
name|bpixmap
else|:
operator|(
name|Pixmap
operator|)
name|xdev
operator|->
name|win
operator|)
expr_stmt|;
block|}
comment|/* Clear the background pixmap to avoid initializing with garbage. */
if|if
condition|(
name|xdev
operator|->
name|bpixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xdev
operator|->
name|ghostview
condition|)
name|XSetWindowBackgroundPixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|xdev
operator|->
name|bpixmap
argument_list|)
expr_stmt|;
name|XSetForeground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|pixel_white
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|bpixmap
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xdev
operator|->
name|width
argument_list|,
name|xdev
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize foreground and background colors */
name|xdev
operator|->
name|back_color
operator|=
name|pixel_white
expr_stmt|;
name|XSetBackground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|pixel_white
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|fore_color
operator|=
name|pixel_white
expr_stmt|;
name|XSetForeground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|pixel_white
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|colors_or
operator|=
name|xdev
operator|->
name|colors_and
operator|=
name|pixel_white
expr_stmt|;
if|if
condition|(
operator|!
name|xdev
operator|->
name|ghostview
condition|)
block|{
comment|/* Make the window appear. */
name|XMapWindow
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|)
expr_stmt|;
comment|/* Before anything else, do a flush and wait for */
comment|/* an exposure event. */
name|XFlush
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|)
expr_stmt|;
name|XNextEvent
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create an unmapped window, that the window manager will ignore. 	     * This invisble window will be used to receive "next page" 	     * events from ghostview */
name|XSetWindowAttributes
name|attributes
decl_stmt|;
name|attributes
operator|.
name|override_redirect
operator|=
name|True
expr_stmt|;
name|xdev
operator|->
name|mwin
operator|=
name|XCreateWindow
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|RootWindowOfScreen
argument_list|(
name|xdev
operator|->
name|scr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|CopyFromParent
argument_list|,
name|CopyFromParent
argument_list|,
name|CopyFromParent
argument_list|,
name|CWOverrideRedirect
argument_list|,
operator|&
name|attributes
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|next
operator|=
name|XInternAtom
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
literal|"NEXT"
argument_list|,
name|False
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|page
operator|=
name|XInternAtom
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
literal|"PAGE"
argument_list|,
name|False
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|done
operator|=
name|XInternAtom
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
literal|"DONE"
argument_list|,
name|False
argument_list|)
expr_stmt|;
block|}
name|xdev
operator|->
name|ht
operator|.
name|no_pixmap
operator|=
name|XCreatePixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|xdev
operator|->
name|vinfo
operator|->
name|depth
argument_list|)
expr_stmt|;
name|XSync
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

