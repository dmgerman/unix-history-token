begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevdjtc.c */
end_comment

begin_comment
comment|/* HP DeskJet 500C driver for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gdevpcl.h"
end_include

begin_comment
comment|/***  *** Note: this driver was contributed by a user, Alfred Kayser:  ***       please contact AKayser@et.tudelft.nl if you have questions.  ***/
end_comment

begin_define
define|#
directive|define
name|X_DPI
value|300
end_define

begin_define
define|#
directive|define
name|Y_DPI
value|300
end_define

begin_comment
comment|/* bytes per line for DeskJet Color */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE
value|((X_DPI * 85 / 10 + 63) / 64 * 8)
end_define

begin_comment
comment|/* The device descriptors */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|djet500c_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|djet500c_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|gdev_pcl_3bit_map_rgb_color
argument_list|,
name|gdev_pcl_3bit_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_djet500c_device
init|=
name|prn_device
argument_list|(
name|djet500c_procs
argument_list|,
literal|"djet500c"
argument_list|,
literal|85
argument_list|,
comment|/* width_10ths, 8.5" */
literal|120
argument_list|,
comment|/* height_10ths, 12" */
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0.25
argument_list|,
literal|0.25
argument_list|,
literal|0.25
argument_list|,
literal|0.25
argument_list|,
comment|/* margins */
literal|3
argument_list|,
name|djet500c_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|djet500c_print_page
argument_list|(
name|P2
argument_list|(
name|gx_device_printer
operator|*
argument_list|,
name|FILE
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The DeskJet 500C uses additive colors in separate planes. */
end_comment

begin_comment
comment|/* We only keep one bit of color, with 1 = R, 2 = G, 4 = B. */
end_comment

begin_comment
comment|/* Because the buffering routines assume 0 = white, */
end_comment

begin_comment
comment|/* we complement all the color components. */
end_comment

begin_define
define|#
directive|define
name|cv_shift
value|(sizeof(gx_color_value) * 8 - 1)
end_define

begin_comment
comment|/* Map an RGB color to a printer color. */
end_comment

begin_function
name|private
name|gx_color_index
name|djet500c_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|b
operator|>>
name|cv_shift
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|g
operator|>>
name|cv_shift
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
name|r
operator|>>
name|cv_shift
operator|)
operator|)
operator|^
literal|7
return|;
block|}
end_function

begin_comment
comment|/* Map the printer color back to RGB. */
end_comment

begin_function
name|private
name|int
name|djet500c_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|ushort
name|cc
init|=
operator|(
name|ushort
operator|)
name|color
operator|^
literal|7
decl_stmt|;
name|prgb
index|[
literal|0
index|]
operator|=
operator|-
operator|(
name|cc
operator|&
literal|1
operator|)
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|-
operator|(
operator|(
name|cc
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|cc
operator|>>
literal|2
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Send the page to the printer.  For speed, compress each scan line, */
end_comment

begin_comment
comment|/* since computer-to-printer communication time is often a bottleneck. */
end_comment

begin_comment
comment|/* The DeskJet Color can compress (mode 3) */
end_comment

begin_function
name|private
name|int
name|djet500c_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|fprn
parameter_list|)
block|{
define|#
directive|define
name|DATA_SIZE
value|(LINE_SIZE*8)
name|byte
name|data
index|[
name|DATA_SIZE
index|]
decl_stmt|;
name|byte
name|plane_data
index|[
name|DATA_SIZE
index|]
decl_stmt|;
comment|/* select the most compressed mode available& clear tmp storage */
comment|/* put printer in known state */
name|fputs
argument_list|(
literal|"\033E"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* ends raster graphics to set raster graphics resolution */
name|fputs
argument_list|(
literal|"\033*rbC"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/*  was \033*rB  */
comment|/* set raster graphics resolution -- 300 dpi */
name|fputs
argument_list|(
literal|"\033*t300R"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* move to top left of page& set current position */
name|fputs
argument_list|(
literal|"\033*p0x0Y"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* cursor pos: 0,0 */
name|fputs
argument_list|(
literal|"\033*r0A"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* start graf. left */
name|fputs
argument_list|(
literal|"\033*b2M"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/*  mode 3 compression for now  */
name|fputs
argument_list|(
literal|"\033*r3U"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* RGB Mode */
name|fputs
argument_list|(
literal|"\033&l26a0l1H"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* A4, skip perf, def. paper tray */
comment|/* Send each scan line in turn */
block|{
name|int
name|lnum
decl_stmt|;
name|int
name|line_size
init|=
name|gdev_mem_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|)
decl_stmt|;
name|int
name|num_blank_lines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|lnum
operator|<
name|pdev
operator|->
name|height
condition|;
name|lnum
operator|++
control|)
block|{
name|byte
name|_ss
modifier|*
name|end_data
init|=
name|data
operator|+
name|line_size
decl_stmt|;
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|data
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
comment|/* Remove trailing 0s. */
while|while
condition|(
name|end_data
operator|>
name|data
operator|&&
name|end_data
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|end_data
operator|--
expr_stmt|;
if|if
condition|(
name|end_data
operator|==
name|data
condition|)
name|num_blank_lines
operator|++
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|byte
name|_ss
modifier|*
name|odp
decl_stmt|;
name|byte
name|_ss
modifier|*
name|row
decl_stmt|;
comment|/* Pad with 0s to fill out the last */
comment|/* block of 8 bytes. */
name|memset
argument_list|(
name|end_data
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Transpose the data to get pixel planes. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|odp
operator|=
name|plane_data
init|;
name|i
operator|<
name|DATA_SIZE
condition|;
name|i
operator|+=
literal|8
operator|,
name|odp
operator|++
control|)
block|{
specifier|register
name|ushort
name|t
decl_stmt|,
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
for|for
control|(
name|r
operator|=
name|g
operator|=
name|b
operator|=
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|8
condition|;
name|t
operator|++
control|)
block|{
name|r
operator|=
operator|(
name|r
operator|<<
literal|1
operator|)
operator||
operator|(
name|data
index|[
name|t
operator|+
name|i
index|]
operator|&
literal|4
operator|)
expr_stmt|;
name|g
operator|=
operator|(
name|g
operator|<<
literal|1
operator|)
operator||
operator|(
name|data
index|[
name|t
operator|+
name|i
index|]
operator|&
literal|2
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|<<
literal|1
operator|)
operator||
operator|(
name|data
index|[
name|t
operator|+
name|i
index|]
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|odp
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|r
operator|^
literal|0xff
expr_stmt|;
name|odp
index|[
name|LINE_SIZE
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|g
operator|>>
literal|1
argument_list|)
operator|^
literal|0xff
expr_stmt|;
name|odp
index|[
name|LINE_SIZE
operator|*
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|b
operator|>>
literal|2
argument_list|)
operator|^
literal|0xff
expr_stmt|;
block|}
comment|/* Skip blank lines if any */
if|if
condition|(
name|num_blank_lines
operator|>
literal|0
condition|)
block|{
comment|/* move down from current position */
name|fprintf
argument_list|(
name|fprn
argument_list|,
literal|"\033*b%dY"
argument_list|,
name|num_blank_lines
argument_list|)
expr_stmt|;
name|num_blank_lines
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Transfer raster graphics */
comment|/* in the order R, G, B. */
name|row
operator|=
name|plane_data
operator|+
name|LINE_SIZE
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|row
operator|-=
name|LINE_SIZE
operator|,
name|i
operator|++
control|)
block|{
name|byte
name|temp
index|[
name|LINE_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|count
init|=
name|gdev_pcl_mode2compress
argument_list|(
operator|(
name|word
operator|*
operator|)
name|row
argument_list|,
operator|(
name|word
operator|*
operator|)
operator|(
name|row
operator|+
name|LINE_SIZE
operator|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fprn
argument_list|,
literal|"\033*b%d%c"
argument_list|,
name|count
argument_list|,
literal|"VVW"
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|,
name|count
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end raster graphics */
name|fputs
argument_list|(
literal|"\033*rbC"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/*  was \033*rB  */
name|fputs
argument_list|(
literal|"\033*r1U"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/*  back to 1 plane  */
comment|/* put printer in known state */
name|fputs
argument_list|(
literal|"\033E"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
comment|/* eject page */
name|fputs
argument_list|(
literal|"\033&l0H"
argument_list|,
name|fprn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

