begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxclist.c */
end_comment

begin_comment
comment|/* Command list 'device' for Ghostscript. */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* must precede gxclist.h */
end_comment

begin_include
include|#
directive|include
file|"gxclist.h"
end_include

begin_comment
comment|/* Patch a couple of things possibly missing from stdio.h. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_END
end_ifndef

begin_define
define|#
directive|define
name|SEEK_END
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|cdev
value|((gx_device_clist *)dev)
end_define

begin_comment
comment|/* Forward declarations of procedures */
end_comment

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|clist_open
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_initial_matrix
parameter_list|(
name|clist_get_initial_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_output_page
parameter_list|(
name|clist_output_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_rgb_color
parameter_list|(
name|clist_map_rgb_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_color_rgb
parameter_list|(
name|clist_map_color_rgb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|clist_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_tile_rectangle
parameter_list|(
name|clist_tile_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_mono
parameter_list|(
name|clist_copy_mono
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_color
parameter_list|(
name|clist_copy_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_bits
parameter_list|(
name|clist_get_bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_props
parameter_list|(
name|clist_get_props
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_put_props
parameter_list|(
name|clist_put_props
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The device descriptor */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|clist_procs
init|=
block|{
name|clist_open
block|,
name|clist_get_initial_matrix
block|,
name|gx_default_sync_output
block|,
name|clist_output_page
block|,
name|gx_default_close_device
block|,
name|clist_map_rgb_color
block|,
name|clist_map_color_rgb
block|,
name|clist_fill_rectangle
block|,
name|clist_tile_rectangle
block|,
name|clist_copy_mono
block|,
name|clist_copy_color
block|,
name|gx_default_draw_line
block|,
name|clist_get_bits
block|,
name|clist_get_props
block|,
name|clist_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_clist
name|gs_clist_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device_clist
argument_list|)
block|,
operator|&
name|clist_procs
block|,
literal|"command list"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|0
block|,
comment|/* generic */
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Define the command set and syntax ------ */
end_comment

begin_comment
comment|/* A command always consists of an operation followed by operands. */
end_comment

begin_comment
comment|/* The operands are implicit in the procedural code. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|cmd_op_misc
init|=
literal|0x00
block|,
comment|/* (see below) */
name|cmd_opv_end_run
init|=
literal|0x00
block|,
comment|/* (nothing) */
name|cmd_opv_set_tile_size
init|=
literal|0x01
block|,
comment|/* width, height */
name|cmd_opv_set_tile_phase
init|=
literal|0x02
block|,
comment|/* x, y */
name|cmd_op_set_color0
init|=
literal|0x10
block|,
comment|/* color+2 in op byte, [color] */
name|cmd_op_set_color1
init|=
literal|0x20
block|,
comment|/* color+2 in op byte, [color] */
name|cmd_op_set_tile_index
init|=
literal|0x30
block|,
comment|/* index */
name|cmd_op_fill_rect
init|=
literal|0x40
block|,
comment|/* rect */
name|cmd_op_fill_rect_short
init|=
literal|0x50
block|,
comment|/* dh in op byte,dx,dw | rect_short */
name|cmd_op_fill_rect_tiny
init|=
literal|0x60
block|,
comment|/* dw in op byte, rect_tiny */
name|cmd_op_tile_rect
init|=
literal|0x70
block|,
comment|/* rect */
name|cmd_op_tile_rect_short
init|=
literal|0x80
block|,
comment|/* dh in op byte,dx,dw | rect_short */
name|cmd_op_tile_rect_tiny
init|=
literal|0x90
block|,
comment|/* dw in op byte, rect_tiny */
name|cmd_op_copy_mono
init|=
literal|0xa0
block|,
comment|/* rect, data_x, raster | */
comment|/* d_x+1 in op byte, x, y, w, h */
name|cmd_op_copy_color
init|=
literal|0xb0
block|,
comment|/* rect, data_x, raster */
name|cmd_op_set_tile_bits
init|=
literal|0xc0
block|,
comment|/* index,<bits> */
name|cmd_op_delta_tile_bits
init|=
literal|0xd0
block|,
comment|/* n-1 in op byte, n x<offset, bits> */
name|cmd_op_end
block|}
name|gx_cmd_op
typedef|;
end_typedef

begin_comment
comment|/* Define the size of the largest command, */
end_comment

begin_comment
comment|/* not counting any bitmap. */
end_comment

begin_define
define|#
directive|define
name|w
value|sizeof(short)
end_define

begin_comment
comment|/* size of coordinate */
end_comment

begin_define
define|#
directive|define
name|d
value|3
end_define

begin_comment
comment|/* size of tile delta */
end_comment

begin_decl_stmt
name|private
name|uint
name|cmd_largest_size
init|=
name|max
argument_list|(
literal|1
operator|+
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
comment|/* copy_mono */
argument_list|,
literal|2
operator|+
literal|16
operator|*
name|d
comment|/* delta_tile 15 */
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|d
end_undef

begin_undef
undef|#
directive|undef
name|w
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|private
name|char
modifier|*
name|cmd_op_names
index|[
literal|16
index|]
init|=
block|{
literal|"misc"
block|,
literal|"set_color_0"
block|,
literal|"set_color_1"
block|,
literal|"set_tile"
block|,
literal|"fill_rect"
block|,
literal|"fill_rect_short"
block|,
literal|"fill_rect_tiny"
block|,
literal|"tile_rect"
block|,
literal|"tile_rect_short"
block|,
literal|"tile_rect_tiny"
block|,
literal|"copy_mono"
block|,
literal|"copy_color"
block|,
literal|"set_tile_bits"
block|,
literal|"delta_tile_bits"
block|,
literal|"?e0?"
block|,
literal|"?f0?"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|cmd_misc_op_names
index|[
literal|16
index|]
init|=
block|{
literal|"end_run"
block|,
literal|"set_tile_size"
block|,
literal|"set_tile_phase"
block|,
literal|"?03?"
block|,
literal|"?04?"
block|,
literal|"?05?"
block|,
literal|"?06?"
block|,
literal|"?07?"
block|,
literal|"?08?"
block|,
literal|"?09?"
block|,
literal|"?0a?"
block|,
literal|"?0b?"
block|,
literal|"?0c?"
block|,
literal|"?0d?"
block|,
literal|"?0e?"
block|,
literal|"?0f?"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ulong
name|cmd_op_counts
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ulong
name|cmd_tile_count
decl_stmt|,
name|cmd_copy_count
decl_stmt|,
name|cmd_delta_tile_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ulong
name|cmd_tile_reset
decl_stmt|,
name|cmd_tile_found
decl_stmt|,
name|cmd_tile_added
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|count_op
parameter_list|(
name|int
name|op
parameter_list|)
block|{
operator|++
name|cmd_op_counts
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf2
argument_list|(
literal|", %s %d\n"
argument_list|,
name|cmd_op_names
index|[
name|op
operator|>>
literal|4
index|]
argument_list|,
name|op
operator|&
literal|0xf
argument_list|)
operator|,
name|fflush
argument_list|(
name|dstderr
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_define
define|#
directive|define
name|count_add
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v += (n))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|count_op
parameter_list|(
name|store_op
parameter_list|)
value|store_op
end_define

begin_define
define|#
directive|define
name|count_add
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|count_add1
parameter_list|(
name|v
parameter_list|)
value|count_add(v, 1)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
block|}
name|gx_cmd_rect
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|byte
name|dx
decl_stmt|,
name|dwidth
decl_stmt|,
name|dy
decl_stmt|,
name|dheight
decl_stmt|;
comment|/* dy and dheight are optional */
block|}
name|gx_cmd_rect_short
typedef|;
end_typedef

begin_define
define|#
directive|define
name|cmd_min_short
value|(-128)
end_define

begin_define
define|#
directive|define
name|cmd_max_short
value|127
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|dx
range|:
literal|4
decl_stmt|;
name|unsigned
name|dy
range|:
literal|4
decl_stmt|;
block|}
name|gx_cmd_rect_tiny
typedef|;
end_typedef

begin_define
define|#
directive|define
name|cmd_min_tiny
value|(-8)
end_define

begin_define
define|#
directive|define
name|cmd_max_tiny
value|7
end_define

begin_comment
comment|/* Define the prefix on each command run in the writing buffer. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cmd_prefix_s
name|cmd_prefix
typedef|;
end_typedef

begin_struct
struct|struct
name|cmd_prefix_s
block|{
name|cmd_prefix
modifier|*
name|next
decl_stmt|;
name|uint
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Define the entries in the block file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cmd_block_s
block|{
name|int
name|band
decl_stmt|;
name|long
name|pos
decl_stmt|;
comment|/* starting position in cfile */
block|}
name|cmd_block
typedef|;
end_typedef

begin_comment
comment|/* Remember the current state of one band when writing or reading. */
end_comment

begin_struct
struct|struct
name|gx_clist_state_s
block|{
name|gx_color_index
name|color0
decl_stmt|,
name|color1
decl_stmt|;
comment|/* most recent colors */
name|tile_slot
modifier|*
name|tile
decl_stmt|;
comment|/* most recent tile */
name|gs_int_point
name|tile_phase
decl_stmt|;
comment|/* most recent tile phase */
name|gx_cmd_rect
name|rect
decl_stmt|;
comment|/* most recent rectangle */
comment|/* Following are only used when writing */
name|cmd_prefix
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
comment|/* list of commands for band */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|tile_slot
name|no_tile
init|=
block|{
operator|~
literal|0L
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The initial values for a band state */
end_comment

begin_decl_stmt
name|private
name|gx_clist_state
name|cls_initial
init|=
block|{
name|gx_no_color_index
block|,
name|gx_no_color_index
block|,
operator|&
name|no_tile
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the size of the command buffer used for reading. */
end_comment

begin_comment
comment|/* This is needed to split up very large copy_ operations. */
end_comment

begin_define
define|#
directive|define
name|cbuf_size
value|500
end_define

begin_comment
comment|/* Initialize the device state */
end_comment

begin_decl_stmt
name|private
name|void
name|clist_init_tiles
argument_list|(
name|P1
argument_list|(
name|gx_device_clist
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|clist_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* 	 * The buffer area (data, data_size) holds a tile cache and a 	 * set of block range bit masks when both writing and reading. 	 * The rest of the space is used for 	 * the command buffer and band state bookkeeping when writing, 	 * and for the rendering buffer (image device) when reading. 	 * For the moment, we divide the space up arbitrarily. 	 */
name|byte
modifier|*
name|data
init|=
name|cdev
operator|->
name|data
decl_stmt|;
name|uint
name|size
init|=
name|cdev
operator|->
name|data_size
decl_stmt|;
define|#
directive|define
name|alloc_data
parameter_list|(
name|n
parameter_list|)
value|data += (n), size -= (n)
name|gx_device
modifier|*
name|target
init|=
name|cdev
operator|->
name|target
decl_stmt|;
name|int
name|raster
decl_stmt|,
name|nbands
decl_stmt|,
name|band
decl_stmt|;
name|gx_clist_state
modifier|*
name|states
decl_stmt|;
name|uint
name|state_size
decl_stmt|;
name|cdev
operator|->
name|ymin
operator|=
name|cdev
operator|->
name|ymax
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* render_init not done yet */
name|cdev
operator|->
name|tile_data
operator|=
name|data
expr_stmt|;
name|cdev
operator|->
name|tile_data_size
operator|=
operator|(
name|size
operator|/
literal|5
operator|)
operator|&
operator|-
literal|4
expr_stmt|;
comment|/* arbitrary! */
name|alloc_data
argument_list|(
name|cdev
operator|->
name|tile_data_size
argument_list|)
expr_stmt|;
name|raster
operator|=
operator|(
operator|(
operator|(
name|target
operator|->
name|width
operator|*
name|target
operator|->
name|color_info
operator|.
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|byte
operator|*
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|band_height
operator|=
name|size
operator|/
operator|(
name|uint
operator|)
name|raster
expr_stmt|;
name|nbands
operator|=
name|target
operator|->
name|height
operator|/
name|cdev
operator|->
name|band_height
operator|+
literal|1
expr_stmt|;
name|cdev
operator|->
name|nbands
operator|=
name|nbands
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'l'
index|]
operator||
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[l]width=%d, raster=%d, band_height=%d, nbands=%d\n"
argument_list|,
name|target
operator|->
name|width
argument_list|,
name|raster
argument_list|,
name|cdev
operator|->
name|band_height
argument_list|,
name|cdev
operator|->
name|nbands
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state_size
operator|=
name|nbands
operator|*
sizeof|sizeof
argument_list|(
name|gx_clist_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_size
operator|>
name|size
operator|/
literal|2
condition|)
return|return
operator|-
literal|1
return|;
comment|/* not enough room */
name|cdev
operator|->
name|mdev
operator|.
name|base
operator|=
name|data
expr_stmt|;
name|cdev
operator|->
name|states
operator|=
name|states
operator|=
operator|(
name|gx_clist_state
operator|*
operator|)
name|data
expr_stmt|;
name|alloc_data
argument_list|(
name|state_size
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|cbuf
operator|=
name|data
expr_stmt|;
name|cdev
operator|->
name|cnext
operator|=
name|data
expr_stmt|;
name|cdev
operator|->
name|cend
operator|=
name|data
operator|+
name|size
expr_stmt|;
name|cdev
operator|->
name|ccls
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|band
operator|=
literal|0
init|;
name|band
operator|<
name|nbands
condition|;
name|band
operator|++
operator|,
name|states
operator|++
control|)
operator|*
name|states
operator|=
name|cls_initial
expr_stmt|;
undef|#
directive|undef
name|alloc_data
name|cdev
operator|->
name|tile_band_mask_size
operator|=
operator|(
name|nbands
operator|+
literal|31
operator|)
operator|/
literal|32
operator|*
literal|4
expr_stmt|;
name|cdev
operator|->
name|tile_max_size
operator|=
name|cdev
operator|->
name|tile_data_size
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|tile_hash
argument_list|)
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|tile_slot
argument_list|)
operator|+
name|cdev
operator|->
name|tile_band_mask_size
operator|)
expr_stmt|;
name|clist_init_tiles
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* (Re)initialize the tile cache. */
end_comment

begin_function
name|private
name|void
name|clist_init_tiles
parameter_list|(
specifier|register
name|gx_device_clist
modifier|*
name|cldev
parameter_list|)
block|{
name|gx_clist_state
modifier|*
name|pcls
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hc
decl_stmt|;
name|cldev
operator|->
name|tile_slot_size
operator|=
sizeof|sizeof
argument_list|(
name|tile_slot
argument_list|)
operator|+
name|cldev
operator|->
name|tile_band_mask_size
operator|+
name|cldev
operator|->
name|tile
operator|.
name|raster
operator|*
name|cldev
operator|->
name|tile
operator|.
name|size
operator|.
name|y
expr_stmt|;
name|cldev
operator|->
name|tile_max_count
operator|=
name|cldev
operator|->
name|tile_data_size
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|tile_hash
argument_list|)
operator|*
literal|3
comment|/*(worst case)*/
operator|+
name|cldev
operator|->
name|tile_slot_size
operator|)
expr_stmt|;
name|hc
operator|=
operator|(
name|cldev
operator|->
name|tile_max_count
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|hc
operator|+
literal|1
operator|)
operator|&
name|hc
condition|)
name|hc
operator||=
name|hc
operator|>>
literal|1
expr_stmt|;
comment|/* make mask */
if|if
condition|(
name|hc
operator|>=
name|cldev
operator|->
name|tile_max_count
operator|*
literal|3
condition|)
name|hc
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|hc
operator|>
literal|255
condition|)
comment|/* slot index in set_tile is only 1 byte */
block|{
name|hc
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|cldev
operator|->
name|tile_max_count
operator|>
literal|200
condition|)
name|cldev
operator|->
name|tile_max_count
operator|=
literal|200
expr_stmt|;
block|}
name|cldev
operator|->
name|tile_hash_mask
operator|=
name|hc
expr_stmt|;
name|hc
operator|++
expr_stmt|;
comment|/* make actual size */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'l'
index|]
operator||
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf5
argument_list|(
literal|"[l]tile.size=%dx%d, slot_size=%d, max_count=%d, hc=%d\n"
argument_list|,
name|cldev
operator|->
name|tile
operator|.
name|size
operator|.
name|x
argument_list|,
name|cldev
operator|->
name|tile
operator|.
name|size
operator|.
name|y
argument_list|,
name|cldev
operator|->
name|tile_slot_size
argument_list|,
name|cldev
operator|->
name|tile_max_count
argument_list|,
name|hc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cldev
operator|->
name|tile_hash_table
operator|=
operator|(
name|tile_hash
operator|*
operator|)
operator|(
name|cldev
operator|->
name|tile_data
operator|+
name|cldev
operator|->
name|tile_data_size
operator|)
operator|-
name|hc
expr_stmt|;
name|cldev
operator|->
name|tile_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|cldev
operator|->
name|tile_data
argument_list|,
literal|0
argument_list|,
name|cldev
operator|->
name|tile_data_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cldev
operator|->
name|tile_hash_table
argument_list|,
operator|-
literal|1
argument_list|,
name|hc
operator|*
sizeof|sizeof
argument_list|(
name|tile_hash
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pcls
operator|=
name|cldev
operator|->
name|states
init|;
name|i
operator|<
name|cldev
operator|->
name|nbands
condition|;
name|i
operator|++
operator|,
name|pcls
operator|++
control|)
name|pcls
operator|->
name|tile
operator|=
operator|&
name|no_tile
expr_stmt|;
name|count_add1
argument_list|(
name|cmd_tile_reset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forward the non-displaying operations to the target device. */
end_comment

begin_function
name|private
name|void
name|clist_get_initial_matrix
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
call|(
modifier|*
name|cdev
operator|->
name|target
operator|->
name|procs
operator|->
name|get_initial_matrix
call|)
argument_list|(
name|dev
argument_list|,
name|pmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|gx_color_index
name|clist_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|red
parameter_list|,
name|gx_color_value
name|green
parameter_list|,
name|gx_color_value
name|blue
parameter_list|)
block|{
return|return
call|(
modifier|*
name|cdev
operator|->
name|target
operator|->
name|procs
operator|->
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|clist_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|rgb
index|[
literal|3
index|]
parameter_list|)
block|{
return|return
call|(
modifier|*
name|cdev
operator|->
name|target
operator|->
name|procs
operator|->
name|map_color_rgb
call|)
argument_list|(
name|dev
argument_list|,
name|color
argument_list|,
name|rgb
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|clist_get_props
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|cdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|get_props
call|)
argument_list|(
name|tdev
argument_list|,
name|plist
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|clist_put_props
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|cdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|put_props
call|)
argument_list|(
name|tdev
argument_list|,
name|plist
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a bitmap for tracing */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|private
name|void
name|cmd_print_bits
parameter_list|(
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|raster
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|byte
modifier|*
name|row
init|=
name|data
operator|+
name|i
operator|*
name|raster
decl_stmt|;
name|dprintf
argument_list|(
literal|"[L]"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|raster
condition|;
name|j
operator|++
control|)
name|dprintf1
argument_list|(
literal|" %02x"
argument_list|,
name|row
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cmd_print_bits
parameter_list|(
name|data
parameter_list|,
name|height
parameter_list|,
name|raster
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------ Writing ------ */
end_comment

begin_comment
comment|/* Utilities */
end_comment

begin_define
define|#
directive|define
name|cmd_set_rect
parameter_list|(
name|rect
parameter_list|)
define|\
value|((rect).x = x, (rect).y = y,\    (rect).width = width, (rect).height = height)
end_define

begin_define
define|#
directive|define
name|clist_write
parameter_list|(
name|f
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
define|\
value|fwrite(str, 1, len, f)
end_define

begin_comment
comment|/* Write out the buffered commands, and reset the buffer. */
end_comment

begin_function
name|private
name|void
name|cmd_write_buffer
parameter_list|(
name|gx_device_clist
modifier|*
name|cldev
parameter_list|)
block|{
name|FILE
modifier|*
name|cfile
init|=
name|cldev
operator|->
name|cfile
decl_stmt|;
name|FILE
modifier|*
name|bfile
init|=
name|cldev
operator|->
name|bfile
decl_stmt|;
name|int
name|nbands
init|=
name|cldev
operator|->
name|nbands
decl_stmt|;
name|gx_clist_state
modifier|*
name|pcls
decl_stmt|;
name|int
name|band
decl_stmt|;
for|for
control|(
name|band
operator|=
literal|0
operator|,
name|pcls
operator|=
name|cldev
operator|->
name|states
init|;
name|band
operator|<
name|nbands
condition|;
name|band
operator|++
operator|,
name|pcls
operator|++
control|)
block|{
name|cmd_prefix
modifier|*
name|cp
init|=
name|pcls
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
condition|)
block|{
name|cmd_block
name|cb
decl_stmt|;
name|cb
operator|.
name|band
operator|=
name|band
expr_stmt|;
name|cb
operator|.
name|pos
operator|=
name|ftell
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'l'
index|]
operator||
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[l]writing for band %d at %ld\n"
argument_list|,
name|band
argument_list|,
name|cb
operator|.
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clist_write
argument_list|(
name|bfile
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|cb
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
name|clist_write
argument_list|(
name|cfile
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|(
name|cp
operator|+
literal|1
operator|)
argument_list|,
name|cp
operator|->
name|size
argument_list|)
expr_stmt|;
name|pcls
operator|->
name|head
operator|=
name|pcls
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|fputc
argument_list|(
name|cmd_opv_end_run
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
name|cldev
operator|->
name|cnext
operator|=
name|cldev
operator|->
name|cbuf
expr_stmt|;
name|cldev
operator|->
name|ccls
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a command to the appropriate band list, */
end_comment

begin_comment
comment|/* and allocate space for its data. */
end_comment

begin_comment
comment|/* Return the pointer to the data area. */
end_comment

begin_function
name|private
name|byte
modifier|*
name|cmd_put_op
parameter_list|(
name|gx_device_clist
modifier|*
name|cldev
parameter_list|,
name|gx_clist_state
modifier|*
name|pcls
parameter_list|,
name|uint
name|size
parameter_list|)
block|{
name|byte
modifier|*
name|dp
init|=
name|cldev
operator|->
name|cnext
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[L]band %d: size=%u, left=%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pcls
operator|-
name|cldev
operator|->
name|states
argument_list|)
argument_list|,
name|size
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cldev
operator|->
name|cend
operator|-
name|dp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cmd_prefix
argument_list|)
operator|+
literal|4
operator|)
operator|>
name|cldev
operator|->
name|cend
operator|-
name|dp
condition|)
block|{
name|cmd_write_buffer
argument_list|(
name|cldev
argument_list|)
expr_stmt|;
return|return
name|cmd_put_op
argument_list|(
name|cldev
argument_list|,
name|pcls
argument_list|,
name|size
argument_list|)
return|;
block|}
if|if
condition|(
name|cldev
operator|->
name|ccls
operator|==
name|pcls
condition|)
block|{
comment|/* We're adding another command for the same band. */
comment|/* Tack it onto the end of the previous one. */
name|pcls
operator|->
name|tail
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|cmd_prefix
modifier|*
name|cp
init|=
operator|(
name|cmd_prefix
operator|*
operator|)
operator|(
name|dp
operator|+
operator|(
operator|(
operator|(
name|byte
operator|*
operator|)
literal|0
operator|-
name|dp
operator|)
operator|&
literal|3
operator|)
operator|)
decl_stmt|;
name|dp
operator|=
operator|(
name|byte
operator|*
operator|)
operator|(
name|cp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pcls
operator|->
name|tail
operator|!=
literal|0
condition|)
name|pcls
operator|->
name|tail
operator|->
name|next
operator|=
name|cp
expr_stmt|;
else|else
name|pcls
operator|->
name|head
operator|=
name|cp
expr_stmt|;
name|pcls
operator|->
name|tail
operator|=
name|cp
expr_stmt|;
name|cldev
operator|->
name|ccls
operator|=
name|pcls
expr_stmt|;
name|cp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
name|cldev
operator|->
name|cnext
operator|=
name|dp
operator|+
name|size
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_comment
comment|/* We store all short quantities little-endian. */
end_comment

begin_comment
comment|/* This is OK, because we read them back little-endian explicitly. */
end_comment

begin_define
define|#
directive|define
name|cmd_putw
parameter_list|(
name|w
parameter_list|,
name|dp
parameter_list|)
define|\
value|(*dp = (w)& 0xff, dp[1] = (w)>> 8, dp += 2)
end_define

begin_comment
comment|/* Write a short bitmap.  1<= bwidth<= 3. */
end_comment

begin_function
name|private
name|void
name|cmd_put_short_bits
parameter_list|(
specifier|register
name|byte
modifier|*
name|dp
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|raster
parameter_list|,
specifier|register
name|int
name|bwidth
parameter_list|,
specifier|register
name|int
name|height
parameter_list|)
block|{
while|while
condition|(
operator|--
name|height
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|bwidth
condition|)
block|{
case|case
literal|3
case|:
name|dp
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
case|case
literal|2
case|:
name|dp
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|dp
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
block|}
name|dp
operator|+=
name|bwidth
operator|,
name|data
operator|+=
name|raster
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|int
name|cmd_write_rect_cmd
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_clist_state
modifier|*
name|pcls
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|dx
init|=
name|x
operator|-
name|pcls
operator|->
name|rect
operator|.
name|x
decl_stmt|;
name|int
name|dy
init|=
name|y
operator|-
name|pcls
operator|->
name|rect
operator|.
name|y
decl_stmt|;
name|int
name|dwidth
init|=
name|width
operator|-
name|pcls
operator|->
name|rect
operator|.
name|width
decl_stmt|;
name|int
name|dheight
init|=
name|height
operator|-
name|pcls
operator|->
name|rect
operator|.
name|height
decl_stmt|;
define|#
directive|define
name|check_ranges_1
parameter_list|()
define|\
value|((unsigned)(dx - rmin)<= (rmax - rmin)&&\    (unsigned)(dy - rmin)<= (rmax - rmin)&&\    (unsigned)(dwidth - rmin)<= (rmax - rmin))
define|#
directive|define
name|check_ranges
parameter_list|()
define|\
value|(check_ranges_1()&&\    (unsigned)(dheight - rmin)<= (rmax - rmin))
define|#
directive|define
name|rmin
value|cmd_min_tiny
define|#
directive|define
name|rmax
value|cmd_max_tiny
name|cmd_set_rect
argument_list|(
name|pcls
operator|->
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|dheight
operator|==
literal|0
operator|&&
name|check_ranges_1
argument_list|()
condition|)
block|{
name|byte
modifier|*
name|dp
init|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|=
name|op
operator|+
literal|0x20
operator|+
name|dwidth
operator|-
name|rmin
argument_list|)
expr_stmt|;
name|dp
index|[
literal|1
index|]
operator|=
operator|(
name|dx
operator|<<
literal|4
operator|)
operator|+
name|dy
operator|-
operator|(
name|rmin
operator|*
literal|0x11
operator|)
expr_stmt|;
block|}
undef|#
directive|undef
name|rmin
undef|#
directive|undef
name|rmax
define|#
directive|define
name|rmin
value|cmd_min_short
define|#
directive|define
name|rmax
value|cmd_max_short
elseif|else
if|if
condition|(
name|check_ranges
argument_list|()
condition|)
block|{
name|int
name|dh
init|=
name|dheight
operator|-
name|cmd_min_tiny
decl_stmt|;
name|byte
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|dh
operator|<=
name|cmd_max_tiny
operator|-
name|cmd_min_tiny
operator|&&
name|dh
operator|!=
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
block|{
name|op
operator|+=
name|dh
expr_stmt|;
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dp
index|[
literal|3
index|]
operator|=
name|dy
operator|-
name|rmin
expr_stmt|;
name|dp
index|[
literal|4
index|]
operator|=
name|dheight
operator|-
name|rmin
expr_stmt|;
block|}
name|count_op
argument_list|(
operator|*
name|dp
operator|=
name|op
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|dp
index|[
literal|1
index|]
operator|=
name|dx
operator|-
name|rmin
expr_stmt|;
name|dp
index|[
literal|2
index|]
operator|=
name|dwidth
operator|-
name|rmin
expr_stmt|;
block|}
else|else
block|{
name|byte
modifier|*
name|dp
init|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|pcls
operator|->
name|rect
argument_list|)
argument_list|)
decl_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|=
name|op
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
operator|&
name|pcls
operator|->
name|rect
argument_list|,
sizeof|sizeof
argument_list|(
name|pcls
operator|->
name|rect
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|void
name|cmd_put_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_clist_state
modifier|*
name|pcls
parameter_list|,
name|int
name|op
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|color
operator|>=
operator|-
literal|1
operator|&&
operator|(
name|long
operator|)
name|color
operator|<=
literal|13
condition|)
name|count_op
argument_list|(
operator|*
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
argument_list|)
operator|=
name|op
operator|+
operator|(
name|int
operator|)
name|color
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|byte
modifier|*
name|dp
init|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|color
argument_list|)
argument_list|)
decl_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|=
name|op
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
operator|&
name|color
argument_list|,
sizeof|sizeof
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|cmd_set_colors
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_clist_state
modifier|*
name|pcls
parameter_list|,
name|gx_color_index
name|color0
parameter_list|,
name|gx_color_index
name|color1
parameter_list|)
block|{
if|if
condition|(
name|color0
operator|!=
name|pcls
operator|->
name|color0
condition|)
block|{
name|cmd_put_color
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|cmd_op_set_color0
argument_list|,
name|color0
argument_list|)
expr_stmt|;
name|pcls
operator|->
name|color0
operator|=
name|color0
expr_stmt|;
block|}
if|if
condition|(
name|color1
operator|!=
name|pcls
operator|->
name|color1
condition|)
block|{
name|cmd_put_color
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|cmd_op_set_color1
argument_list|,
name|color1
argument_list|)
expr_stmt|;
name|pcls
operator|->
name|color1
operator|=
name|color1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Driver interface */
end_comment

begin_comment
comment|/* Macros for dividing up a single call into bands */
end_comment

begin_define
define|#
directive|define
name|BEGIN_RECT
define|\
value|{	int yend = y + height;\ 	int band_height = cdev->band_height;\ 	do\ 	   {	int band = y / band_height;\ 		gx_clist_state *pcls = cdev->states + band;\ 		height = band_height - y % band_height;\ 		if ( yend - y< height ) height = yend - y;\ 		   {
end_define

begin_define
define|#
directive|define
name|END_RECT
define|\
value|}\ 		y += height;\ 	   }\ 	while ( y< yend );\    }
end_define

begin_function
name|private
name|int
name|clist_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|BEGIN_RECT
if|if
condition|(
name|color
operator|!=
name|pcls
operator|->
name|color1
condition|)
name|cmd_set_colors
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|pcls
operator|->
name|color0
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|cmd_write_rect_cmd
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|cmd_op_fill_rect
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|END_RECT
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare unequal tiles.  Return -1 if unrelated, */
end_comment

begin_comment
comment|/* or 2<=N<=50 for the size of the delta encoding. */
end_comment

begin_function
name|private
name|int
name|tile_diff
parameter_list|(
name|byte
modifier|*
name|old_data
parameter_list|,
name|byte
modifier|*
name|new_data
parameter_list|,
name|uint
name|tsize
parameter_list|,
name|byte
name|_ss
modifier|*
name|delta
parameter_list|)
block|{
specifier|register
name|ushort
modifier|*
name|old2
decl_stmt|,
modifier|*
name|new2
decl_stmt|;
specifier|register
name|ushort
name|diff
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|byte
name|_ss
modifier|*
name|pd
decl_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|128
condition|)
return|return
operator|-
literal|1
return|;
name|old2
operator|=
operator|(
name|ushort
operator|*
operator|)
name|old_data
expr_stmt|;
name|new2
operator|=
operator|(
name|ushort
operator|*
operator|)
name|new_data
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|pd
operator|=
name|delta
operator|+
literal|2
expr_stmt|;
comment|/* skip slot index */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tsize
condition|;
name|i
operator|+=
literal|2
operator|,
name|old2
operator|++
operator|,
name|new2
operator|++
control|)
if|if
condition|(
operator|(
name|diff
operator|=
operator|*
name|new2
operator|^
operator|*
name|old2
operator|)
operator|!=
literal|0
condition|)
if|#
directive|if
name|arch_is_big_endian
define|#
directive|define
name|i_hi
value|0
define|#
directive|define
name|b_0
parameter_list|(
name|w
parameter_list|)
value|((w)>> 8)
define|#
directive|define
name|b_1
parameter_list|(
name|w
parameter_list|)
value|((byte)(w))
else|#
directive|else
define|#
directive|define
name|i_hi
value|1
define|#
directive|define
name|b_0
parameter_list|(
name|w
parameter_list|)
value|((byte)(w))
define|#
directive|define
name|b_1
parameter_list|(
name|w
parameter_list|)
value|((w)>> 8)
endif|#
directive|endif
block|{
if|if
condition|(
name|count
operator|==
literal|16
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|diff
operator|&
literal|0xff00
condition|)
block|{
if|if
condition|(
name|diff
operator|&
literal|0xff
condition|)
operator|*
name|pd
operator|++
operator|=
literal|0x80
operator|+
name|i
operator|,
operator|*
name|pd
operator|++
operator|=
name|b_0
argument_list|(
name|diff
argument_list|)
operator|,
operator|*
name|pd
operator|++
operator|=
name|b_1
argument_list|(
name|diff
argument_list|)
expr_stmt|;
else|else
operator|*
name|pd
operator|++
operator|=
name|i
operator|+
name|i_hi
operator|,
operator|*
name|pd
operator|++
operator|=
name|diff
operator|>>
literal|8
expr_stmt|;
block|}
else|else
comment|/* know diff != 0 */
operator|*
name|pd
operator|++
operator|=
name|i
operator|+
operator|(
literal|1
operator|-
name|i_hi
operator|)
operator|,
operator|*
name|pd
operator|++
operator|=
operator|(
name|byte
operator|)
name|diff
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|b_0
undef|#
directive|undef
name|b_1
undef|#
directive|undef
name|i_hi
name|delta
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|cmd_op_delta_tile_bits
operator|+
name|count
operator|-
literal|1
expr_stmt|;
return|return
name|pd
operator|-
name|delta
return|;
block|}
end_function

begin_comment
comment|/* Handle changing tiles for clist_tile_rectangle. */
end_comment

begin_comment
comment|/* We put this in a separate routine, even though it is called only once, */
end_comment

begin_comment
comment|/* to avoid cluttering up the main-line case of tile_rectangle. */
end_comment

begin_function
name|private
name|int
name|clist_change_tile
parameter_list|(
name|gx_device_clist
modifier|*
name|cldev
parameter_list|,
name|gx_clist_state
modifier|*
name|pcls
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|)
block|{
name|uint
name|tile_size
init|=
name|tile
operator|->
name|raster
operator|*
name|tile
operator|->
name|size
operator|.
name|y
decl_stmt|;
name|tile_slot
modifier|*
name|old_tile
decl_stmt|,
modifier|*
name|new_tile
decl_stmt|;
name|int
name|slot_index
decl_stmt|;
comment|/* Look up the tile in the cache. */
name|top
label|:
block|{
name|gx_bitmap_id
name|id
init|=
name|tile
operator|->
name|id
decl_stmt|;
name|uint
name|probe
init|=
call|(
name|uint
call|)
argument_list|(
name|id
operator|>>
literal|16
argument_list|)
operator|+
call|(
name|uint
call|)
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|old_tile
operator|=
name|pcls
operator|->
name|tile
expr_stmt|;
for|for
control|(
init|;
condition|;
name|probe
operator|+=
literal|25
comment|/* semi-random odd # */
control|)
block|{
name|tile_hash
modifier|*
name|hptr
init|=
name|cldev
operator|->
name|tile_hash_table
operator|+
operator|(
name|probe
operator|&
name|cldev
operator|->
name|tile_hash_mask
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|slot_index
operator|=
name|hptr
operator|->
name|slot_index
operator|)
operator|<
literal|0
condition|)
comment|/* empty entry */
block|{
comment|/* Must change tiles.  Check whether the */
comment|/* tile size has changed. */
if|if
condition|(
name|tile
operator|->
name|size
operator|.
name|x
operator|!=
name|cldev
operator|->
name|tile
operator|.
name|size
operator|.
name|x
operator|||
name|tile
operator|->
name|size
operator|.
name|y
operator|!=
name|cldev
operator|->
name|tile
operator|.
name|size
operator|.
name|y
condition|)
block|{
if|if
condition|(
name|tile
operator|->
name|raster
operator|!=
operator|(
operator|(
name|tile
operator|->
name|size
operator|.
name|x
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
operator|||
name|tile_size
operator|>
name|cldev
operator|->
name|tile_max_size
condition|)
return|return
operator|-
literal|1
return|;
name|cldev
operator|->
name|tile
operator|=
operator|*
name|tile
expr_stmt|;
comment|/* reset size, raster */
name|clist_init_tiles
argument_list|(
name|cldev
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|cldev
operator|->
name|tile_count
operator|==
name|cldev
operator|->
name|tile_max_count
condition|)
block|{
comment|/* Punt. */
name|clist_init_tiles
argument_list|(
name|cldev
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|hptr
operator|->
name|slot_index
operator|=
name|slot_index
operator|=
name|cldev
operator|->
name|tile_count
operator|++
expr_stmt|;
name|new_tile
operator|=
name|tile_slot_ptr
argument_list|(
name|cldev
argument_list|,
name|slot_index
argument_list|)
expr_stmt|;
name|new_tile
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|memcpy
argument_list|(
name|ts_bits
argument_list|(
name|cldev
argument_list|,
name|new_tile
argument_list|)
argument_list|,
name|tile
operator|->
name|data
argument_list|,
name|tile_size
argument_list|)
expr_stmt|;
name|count_add1
argument_list|(
name|cmd_tile_added
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[L]adding tile %d, hash=%d, id=%lx\n"
argument_list|,
name|slot_index
argument_list|,
call|(
name|int
call|)
argument_list|(
name|hptr
operator|-
name|cldev
operator|->
name|tile_hash_table
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|new_tile
operator|=
name|tile_slot_ptr
argument_list|(
name|cldev
argument_list|,
name|slot_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tile
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|count_add1
argument_list|(
name|cmd_tile_found
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf1
argument_list|(
literal|"[L]found tile %d\n"
argument_list|,
name|slot_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
comment|/* Check whether this band knows about this tile yet. */
block|{
name|int
name|band_index
init|=
name|pcls
operator|-
name|cldev
operator|->
name|states
decl_stmt|;
name|byte
name|pmask
init|=
literal|1
operator|<<
operator|(
name|band_index
operator|&
literal|7
operator|)
decl_stmt|;
name|byte
modifier|*
name|ppresent
init|=
name|ts_mask
argument_list|(
name|new_tile
argument_list|)
operator|+
operator|(
name|band_index
operator|>>
literal|3
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|ppresent
operator|&
name|pmask
condition|)
block|{
comment|/* Tile is known, just put out the index. */
name|byte
modifier|*
name|dp
init|=
name|cmd_put_op
argument_list|(
name|cldev
argument_list|,
name|pcls
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|=
name|cmd_op_set_tile_index
argument_list|)
expr_stmt|;
name|dp
index|[
literal|1
index|]
operator|=
name|slot_index
expr_stmt|;
block|}
else|else
block|{
comment|/* Tile is not known, put out the bits.  Use a */
comment|/* delta encoding or a short encoding if possible. */
name|byte
modifier|*
name|new_data
init|=
name|ts_bits
argument_list|(
name|cldev
argument_list|,
name|new_tile
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|dp
decl_stmt|;
name|byte
name|delta
index|[
literal|2
operator|+
literal|16
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|diff
decl_stmt|;
operator|*
name|ppresent
operator||=
name|pmask
expr_stmt|;
if|if
condition|(
name|old_tile
operator|!=
operator|&
name|no_tile
operator|&&
operator|(
name|diff
operator|=
name|tile_diff
argument_list|(
name|ts_bits
argument_list|(
name|cldev
argument_list|,
name|old_tile
argument_list|)
argument_list|,
name|new_data
argument_list|,
name|tile_size
argument_list|,
name|delta
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Use delta representation */
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cldev
argument_list|,
name|pcls
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|count_op
argument_list|(
name|delta
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|delta
index|[
literal|1
index|]
operator|=
name|slot_index
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|delta
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|count_add
argument_list|(
name|cmd_delta_tile_count
argument_list|,
name|diff
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|old_tile
operator|==
operator|&
name|no_tile
condition|)
block|{
name|byte
modifier|*
name|dp
init|=
name|cmd_put_op
argument_list|(
name|cldev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|cldev
operator|->
name|tile
operator|.
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|=
operator|(
name|byte
operator|)
name|cmd_opv_set_tile_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
operator|&
name|cldev
operator|->
name|tile
operator|.
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|cldev
operator|->
name|tile
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tile
operator|->
name|size
operator|.
name|x
operator|<=
literal|16
condition|)
block|{
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cldev
argument_list|,
name|pcls
argument_list|,
literal|2
operator|+
operator|(
name|tile_size
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cmd_put_short_bits
argument_list|(
name|dp
operator|+
literal|2
argument_list|,
name|new_data
argument_list|,
name|tile
operator|->
name|raster
argument_list|,
literal|2
argument_list|,
name|tile
operator|->
name|size
operator|.
name|y
argument_list|)
expr_stmt|;
name|count_add
argument_list|(
name|cmd_tile_count
argument_list|,
name|tile_size
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cldev
argument_list|,
name|pcls
argument_list|,
literal|2
operator|+
name|tile_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
literal|2
argument_list|,
name|new_data
argument_list|,
name|tile_size
argument_list|)
expr_stmt|;
name|count_add
argument_list|(
name|cmd_tile_count
argument_list|,
name|tile_size
argument_list|)
expr_stmt|;
block|}
name|count_op
argument_list|(
operator|*
name|dp
operator|=
operator|(
name|byte
operator|)
name|cmd_op_set_tile_bits
argument_list|)
expr_stmt|;
name|dp
index|[
literal|1
index|]
operator|=
name|slot_index
expr_stmt|;
block|}
block|}
block|}
name|pcls
operator|->
name|tile
operator|=
name|new_tile
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|clist_tile_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|gx_color_index
name|color0
parameter_list|,
name|gx_color_index
name|color1
parameter_list|,
name|int
name|px
parameter_list|,
name|int
name|py
parameter_list|)
block|{
name|BEGIN_RECT
if|if
condition|(
name|tile
operator|->
name|id
operator|!=
name|pcls
operator|->
name|tile
operator|->
name|id
condition|)
block|{
if|if
condition|(
name|clist_change_tile
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
name|tile
argument_list|)
operator|<
literal|0
condition|)
return|return
name|gx_default_tile_rectangle
argument_list|(
name|dev
argument_list|,
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|,
name|px
argument_list|,
name|py
argument_list|)
return|;
block|}
if|if
condition|(
name|color0
operator|!=
name|pcls
operator|->
name|color0
operator|||
name|color1
operator|!=
name|pcls
operator|->
name|color1
condition|)
name|cmd_set_colors
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
expr_stmt|;
if|if
condition|(
name|px
operator|!=
name|pcls
operator|->
name|tile_phase
operator|.
name|x
operator|||
name|py
operator|!=
name|pcls
operator|->
name|tile_phase
operator|.
name|y
condition|)
block|{
name|byte
modifier|*
name|dp
init|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|pcls
operator|->
name|tile_phase
argument_list|)
argument_list|)
decl_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|=
operator|(
name|byte
operator|)
name|cmd_opv_set_tile_phase
argument_list|)
expr_stmt|;
name|pcls
operator|->
name|tile_phase
operator|.
name|x
operator|=
name|px
expr_stmt|;
name|pcls
operator|->
name|tile_phase
operator|.
name|y
operator|=
name|py
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
operator|&
name|pcls
operator|->
name|tile_phase
argument_list|,
sizeof|sizeof
argument_list|(
name|pcls
operator|->
name|tile_phase
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cmd_write_rect_cmd
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|cmd_op_tile_rect
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|END_RECT
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|clist_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|data_x
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|gx_color_index
name|color0
parameter_list|,
name|gx_color_index
name|color1
parameter_list|)
block|{
name|int
name|y0
init|=
name|y
decl_stmt|;
name|BEGIN_RECT
name|gx_cmd_rect
name|rect
decl_stmt|;
name|uint
name|dsize
decl_stmt|;
name|int
name|bwidth
decl_stmt|;
name|byte
modifier|*
name|row
init|=
name|data
operator|+
operator|(
name|y
operator|-
name|y0
operator|)
operator|*
name|raster
decl_stmt|;
name|byte
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|color0
operator|!=
name|pcls
operator|->
name|color0
operator|||
name|color1
operator|!=
name|pcls
operator|->
name|color1
condition|)
name|cmd_set_colors
argument_list|(
name|dev
argument_list|,
name|pcls
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
expr_stmt|;
name|cmd_set_rect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
literal|2
operator|&&
operator|(
name|bwidth
operator|=
operator|(
name|width
operator|+
operator|(
name|data_x
operator|&
literal|7
operator|)
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|<=
literal|3
operator|&&
name|height
operator|<=
name|min
argument_list|(
literal|255
argument_list|,
operator|(
name|cbuf_size
operator|-
operator|(
literal|1
operator|+
literal|2
operator|*
literal|2
operator|+
literal|2
operator|)
operator|)
operator|/
name|bwidth
argument_list|)
condition|)
block|{
name|dsize
operator|=
name|height
operator|*
name|bwidth
expr_stmt|;
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
literal|2
operator|*
literal|2
operator|+
literal|2
operator|+
name|dsize
argument_list|)
expr_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|++
operator|=
operator|(
name|byte
operator|)
name|cmd_op_copy_mono
operator|+
operator|(
name|data_x
operator|&
literal|7
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cmd_putw
argument_list|(
name|x
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|cmd_putw
argument_list|(
name|y
argument_list|,
name|dp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|width
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|height
expr_stmt|;
name|row
operator|+=
name|data_x
operator|>>
literal|3
expr_stmt|;
name|cmd_put_short_bits
argument_list|(
name|dp
argument_list|,
name|row
argument_list|,
name|raster
argument_list|,
name|bwidth
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsize
operator|=
name|height
operator|*
name|raster
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|cbuf_size
condition|)
block|{
comment|/* We have to split it into pieces. */
if|if
condition|(
name|height
operator|>
literal|1
condition|)
block|{
name|int
name|h2
init|=
name|height
operator|>>
literal|1
decl_stmt|;
name|clist_copy_mono
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|h2
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
expr_stmt|;
return|return
name|clist_copy_mono
argument_list|(
name|dev
argument_list|,
name|data
operator|+
name|h2
operator|*
name|raster
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|h2
argument_list|,
name|width
argument_list|,
name|height
operator|-
name|h2
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
return|;
block|}
comment|/* Split a single (very long) row. */
block|{
name|int
name|w2
init|=
name|width
operator|>>
literal|1
decl_stmt|;
name|clist_copy_mono
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w2
argument_list|,
literal|1
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
expr_stmt|;
return|return
name|clist_copy_mono
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
operator|+
name|w2
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
operator|+
name|w2
argument_list|,
name|y
argument_list|,
name|width
operator|-
name|w2
argument_list|,
literal|1
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
return|;
block|}
block|}
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|rect
argument_list|)
operator|+
literal|4
operator|+
name|dsize
argument_list|)
expr_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|++
operator|=
operator|(
name|byte
operator|)
name|cmd_op_copy_mono
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|rect
argument_list|,
sizeof|sizeof
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
sizeof|sizeof
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|cmd_putw
argument_list|(
name|data_x
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|cmd_putw
argument_list|(
name|raster
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|row
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
name|pcls
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|count_add
argument_list|(
name|cmd_copy_count
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|END_RECT
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|clist_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|data_x
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|y0
init|=
name|y
decl_stmt|;
name|BEGIN_RECT
name|gx_cmd_rect
name|rect
decl_stmt|;
name|uint
name|dsize
init|=
name|height
operator|*
name|raster
decl_stmt|;
name|byte
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|dsize
operator|>
name|cbuf_size
condition|)
block|{
comment|/* We have to split it into pieces. */
if|if
condition|(
name|height
operator|>
literal|1
condition|)
block|{
name|int
name|h2
init|=
name|height
operator|>>
literal|1
decl_stmt|;
name|clist_copy_color
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|h2
argument_list|)
expr_stmt|;
return|return
name|clist_copy_color
argument_list|(
name|dev
argument_list|,
name|data
operator|+
name|h2
operator|*
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|h2
argument_list|,
name|width
argument_list|,
name|height
operator|-
name|h2
argument_list|)
return|;
block|}
comment|/* Split a single (very long) row. */
block|{
name|int
name|w2
init|=
name|width
operator|>>
literal|1
decl_stmt|;
name|clist_copy_color
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|clist_copy_color
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
operator|+
name|w2
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
operator|+
name|w2
argument_list|,
name|y
argument_list|,
name|width
operator|-
name|w2
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
name|cmd_set_rect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cmd_put_op
argument_list|(
name|cdev
argument_list|,
name|pcls
argument_list|,
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|rect
argument_list|)
operator|+
literal|4
operator|+
name|dsize
argument_list|)
expr_stmt|;
name|count_op
argument_list|(
operator|*
name|dp
operator|++
operator|=
operator|(
name|byte
operator|)
name|cmd_op_copy_color
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|rect
argument_list|,
sizeof|sizeof
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
name|pcls
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|dp
operator|+=
sizeof|sizeof
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|cmd_putw
argument_list|(
name|data_x
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|cmd_putw
argument_list|(
name|raster
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|data
operator|+
operator|(
name|y
operator|-
name|y0
operator|)
operator|*
name|raster
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|END_RECT
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Reading/rendering ------ */
end_comment

begin_comment
comment|/* Clean up after rendering a page. */
end_comment

begin_function
name|private
name|int
name|clist_output_page
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|num_copies
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
if|if
condition|(
name|flush
condition|)
block|{
name|rewind
argument_list|(
name|cdev
operator|->
name|cfile
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|cdev
operator|->
name|bfile
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|bfile_end_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fseek
argument_list|(
name|cdev
operator|->
name|cfile
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|cdev
operator|->
name|bfile
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
return|return
name|clist_open
argument_list|(
name|dev
argument_list|)
return|;
comment|/* reinitialize */
block|}
end_function

begin_decl_stmt
name|private
name|int
name|clist_render_init
argument_list|(
name|P1
argument_list|(
name|gx_device_clist
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|clist_render
argument_list|(
name|P3
argument_list|(
name|gx_device_clist
operator|*
argument_list|,
name|gx_device
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy scan lines to the client.  This is where rendering gets done. */
end_comment

begin_function
name|private
name|int
name|clist_get_bits
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|start_y
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
name|pad_to_word
parameter_list|)
block|{
name|int
name|y
init|=
name|start_y
decl_stmt|;
name|byte
modifier|*
name|dest
init|=
name|str
decl_stmt|;
name|gx_device_memory
modifier|*
name|mdev
init|=
operator|&
name|cdev
operator|->
name|mdev
decl_stmt|;
name|uint
name|bytes_per_line
decl_stmt|;
name|uint
name|count
decl_stmt|,
name|left
decl_stmt|;
comment|/* Initialize for rendering if we haven't done so yet. */
if|if
condition|(
name|cdev
operator|->
name|ymin
operator|<
literal|0
condition|)
name|clist_render_init
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
name|bytes_per_line
operator|=
name|gx_device_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|mdev
argument_list|,
name|pad_to_word
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|size
operator|/
name|bytes_per_line
argument_list|,
name|cdev
operator|->
name|target
operator|->
name|height
operator|-
name|start_y
argument_list|)
expr_stmt|;
comment|/* Render bands and copy them incrementally. */
for|for
control|(
name|left
operator|=
name|count
init|;
name|left
condition|;
control|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|y
operator|>=
name|cdev
operator|->
name|ymin
operator|&&
name|y
operator|<
name|cdev
operator|->
name|ymax
operator|)
condition|)
block|{
name|int
name|band
init|=
name|y
operator|/
name|mdev
operator|->
name|height
decl_stmt|;
name|int
name|code
decl_stmt|;
name|rewind
argument_list|(
name|cdev
operator|->
name|bfile
argument_list|)
expr_stmt|;
call|(
modifier|*
name|mdev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|mdev
argument_list|)
expr_stmt|;
comment|/* reinitialize */
name|code
operator|=
name|clist_render
argument_list|(
name|cdev
argument_list|,
operator|(
name|gx_device
operator|*
operator|)
name|mdev
argument_list|,
name|band
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|cdev
operator|->
name|ymin
operator|=
name|band
operator|*
name|mdev
operator|->
name|height
expr_stmt|;
name|cdev
operator|->
name|ymax
operator|=
name|cdev
operator|->
name|ymin
operator|+
name|mdev
operator|->
name|height
expr_stmt|;
block|}
name|n
operator|=
name|min
argument_list|(
name|cdev
operator|->
name|ymax
operator|-
name|y
argument_list|,
name|left
argument_list|)
expr_stmt|;
call|(
modifier|*
name|mdev
operator|->
name|procs
operator|->
name|get_bits
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|mdev
argument_list|,
name|y
operator|-
name|cdev
operator|->
name|ymin
argument_list|,
name|dest
argument_list|,
name|bytes_per_line
operator|*
name|n
argument_list|,
name|pad_to_word
argument_list|)
expr_stmt|;
name|y
operator|+=
name|n
operator|,
name|dest
operator|+=
name|bytes_per_line
operator|*
name|n
operator|,
name|left
operator|-=
name|n
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|cdev
end_undef

begin_comment
comment|/* Initialize for reading. */
end_comment

begin_function
name|private
name|int
name|clist_render_init
parameter_list|(
name|gx_device_clist
modifier|*
name|cdev
parameter_list|)
block|{
name|gx_device
modifier|*
name|target
init|=
name|cdev
operator|->
name|target
decl_stmt|;
name|byte
modifier|*
name|base
init|=
name|cdev
operator|->
name|mdev
operator|.
name|base
decl_stmt|;
comment|/* save */
name|int
name|depth
init|=
name|target
operator|->
name|color_info
operator|.
name|depth
decl_stmt|;
name|uint
name|raster
init|=
operator|(
operator|(
name|target
operator|->
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
name|gx_device_memory
modifier|*
name|mdev
init|=
name|gdev_mem_device_for_bits
argument_list|(
name|depth
argument_list|)
decl_stmt|;
if|if
condition|(
name|mdev
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
name|cmd_write_buffer
argument_list|(
name|cdev
argument_list|)
expr_stmt|;
comment|/* flush buffer */
comment|/* Write the terminating entry in the block file. */
comment|/* Note that because of copypage, there may be many such entries. */
block|{
name|cmd_block
name|cb
decl_stmt|;
name|cb
operator|.
name|band
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|.
name|pos
operator|=
name|ftell
argument_list|(
name|cdev
operator|->
name|cfile
argument_list|)
expr_stmt|;
name|clist_write
argument_list|(
name|cdev
operator|->
name|bfile
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|cb
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|bfile_end_pos
operator|=
name|ftell
argument_list|(
name|cdev
operator|->
name|bfile
argument_list|)
expr_stmt|;
block|}
name|cdev
operator|->
name|mdev
operator|=
operator|*
name|mdev
expr_stmt|;
name|cdev
operator|->
name|mdev
operator|.
name|base
operator|=
name|base
expr_stmt|;
comment|/* restore */
call|(
modifier|*
name|target
operator|->
name|procs
operator|->
name|get_initial_matrix
call|)
argument_list|(
name|target
argument_list|,
operator|&
name|cdev
operator|->
name|mdev
operator|.
name|initial_matrix
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|mdev
operator|.
name|width
operator|=
name|target
operator|->
name|width
expr_stmt|;
name|cdev
operator|->
name|mdev
operator|.
name|height
operator|=
name|cdev
operator|->
name|band_height
expr_stmt|;
name|cdev
operator|->
name|mdev
operator|.
name|raster
operator|=
name|raster
expr_stmt|;
name|cdev
operator|->
name|ymin
operator|=
name|cdev
operator|->
name|ymax
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'l'
index|]
operator||
name|gs_debug
index|[
literal|'L'
index|]
condition|)
block|{
name|int
name|ci
decl_stmt|,
name|cj
decl_stmt|;
name|dprintf3
argument_list|(
literal|"[l]counts: tile = %ld, copy = %ld, delta = %ld\n"
argument_list|,
name|cmd_tile_count
argument_list|,
name|cmd_copy_count
argument_list|,
name|cmd_delta_tile_count
argument_list|)
expr_stmt|;
name|dprintf3
argument_list|(
literal|"           reset = %ld, found = %ld, added = %ld\n"
argument_list|,
name|cmd_tile_reset
argument_list|,
name|cmd_tile_found
argument_list|,
name|cmd_tile_added
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
literal|0x100
condition|;
name|ci
operator|+=
literal|0x10
control|)
block|{
name|dprintf1
argument_list|(
literal|"[l]  %s ="
argument_list|,
name|cmd_op_names
index|[
name|ci
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|cj
operator|=
name|ci
init|;
name|cj
operator|<
name|ci
operator|+
literal|0x10
condition|;
name|cj
operator|++
control|)
name|dprintf1
argument_list|(
literal|" %ld"
argument_list|,
name|cmd_op_counts
index|[
name|cj
index|]
argument_list|)
expr_stmt|;
name|dputs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Render one band to a specified target device. */
end_comment

begin_define
define|#
directive|define
name|assign_getw
parameter_list|(
name|var
parameter_list|,
name|p
parameter_list|)
define|\
value|(var = *p + ((uint)p[1]<< 8), p += 2)
end_define

begin_typedef
typedef|typedef
name|byte
name|_ss
modifier|*
name|cb_ptr
typedef|;
end_typedef

begin_decl_stmt
name|private
name|void
name|clist_read
argument_list|(
name|P3
argument_list|(
name|FILE
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|cb_ptr
name|clist_read_short_bits
argument_list|(
name|P6
argument_list|(
name|FILE
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|cb_ptr
argument_list|,
name|cb_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|clist_render
parameter_list|(
name|gx_device_clist
modifier|*
name|cdev
parameter_list|,
name|gx_device
modifier|*
name|tdev
parameter_list|,
name|int
name|band
parameter_list|)
block|{
name|byte
name|cbuf
index|[
name|cbuf_size
index|]
decl_stmt|;
name|byte
name|bits
index|[
literal|4
operator|*
literal|255
index|]
decl_stmt|;
comment|/* for short copy_mono bits */
specifier|register
name|cb_ptr
name|cbp
decl_stmt|;
name|cb_ptr
name|cb_limit
decl_stmt|;
name|cb_ptr
name|cb_end
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
name|cdev
operator|->
name|cfile
decl_stmt|;
name|FILE
modifier|*
name|bfile
init|=
name|cdev
operator|->
name|bfile
decl_stmt|;
name|int
name|y0
init|=
name|band
operator|*
name|cdev
operator|->
name|band_height
decl_stmt|;
name|gx_clist_state
name|state
decl_stmt|;
name|gx_bitmap
name|state_tile
decl_stmt|;
name|uint
name|tile_bits_size
decl_stmt|;
comment|/* size of bits of each tile */
name|gs_int_point
name|tile_phase
decl_stmt|;
name|cmd_block
name|b_this
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|uint
name|left
decl_stmt|;
define|#
directive|define
name|cmd_read_var
parameter_list|(
name|ptr
parameter_list|,
name|cbp
parameter_list|)
define|\
value|memcpy(ptr, cbp, sizeof(*ptr)),\   cbp += sizeof(*ptr)
define|#
directive|define
name|cmd_read
parameter_list|(
name|ptr
parameter_list|,
name|vsize
parameter_list|,
name|cbp
parameter_list|)
define|\
value|if ( cb_end - cbp>= vsize )\     memcpy(ptr, cbp, vsize), cbp += vsize;\   else\    { uint cleft = cb_end - cbp;\      memcpy(ptr, cbp, cleft); vsize -= cleft;\      clist_read(file, ptr + cleft, vsize);\      cbp = cb_end;\    }
define|#
directive|define
name|cmd_read_short_bits
parameter_list|(
name|ptr
parameter_list|,
name|bw
parameter_list|,
name|ht
parameter_list|,
name|cbp
parameter_list|)
define|\
value|cbp = clist_read_short_bits(file, ptr, bw, ht, cbp, cb_end)
name|state
operator|=
name|cls_initial
expr_stmt|;
name|state_tile
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|tile_phase
operator|.
name|x
operator|=
name|tile_phase
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|trd
label|:
name|clist_read
argument_list|(
name|bfile
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|b_this
argument_list|,
sizeof|sizeof
argument_list|(
name|b_this
argument_list|)
argument_list|)
expr_stmt|;
name|top
label|:
comment|/* Find the next run of commands for this band. */
if|if
condition|(
name|b_this
operator|.
name|band
operator|<
literal|0
operator|&&
name|ftell
argument_list|(
name|bfile
argument_list|)
operator|==
name|cdev
operator|->
name|bfile_end_pos
condition|)
return|return
literal|0
return|;
comment|/* end of bfile */
if|if
condition|(
name|b_this
operator|.
name|band
operator|!=
name|band
condition|)
goto|goto
name|trd
goto|;
name|pos
operator|=
name|b_this
operator|.
name|pos
expr_stmt|;
name|clist_read
argument_list|(
name|bfile
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|b_this
argument_list|,
sizeof|sizeof
argument_list|(
name|b_this
argument_list|)
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|left
operator|=
call|(
name|uint
call|)
argument_list|(
name|b_this
operator|.
name|pos
operator|-
name|pos
argument_list|)
expr_stmt|;
name|cb_limit
operator|=
name|cbuf
operator|+
operator|(
name|cbuf_size
operator|-
name|cmd_largest_size
operator|)
expr_stmt|;
name|cb_end
operator|=
name|cbuf
operator|+
name|cbuf_size
expr_stmt|;
name|cbp
operator|=
name|cb_end
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|op
decl_stmt|;
name|uint
name|bytes
decl_stmt|;
name|int
name|data_x
decl_stmt|,
name|raster
decl_stmt|;
name|int
name|code
decl_stmt|;
name|cb_ptr
name|source
decl_stmt|;
name|gx_color_index
name|_ss
modifier|*
name|pcolor
decl_stmt|;
comment|/* Make sure the buffer contains a full command. */
if|if
condition|(
name|cbp
operator|>
name|cb_limit
condition|)
block|{
name|uint
name|nread
decl_stmt|;
name|memcpy
argument_list|(
name|cbuf
argument_list|,
name|cbp
argument_list|,
name|cb_end
operator|-
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|cbuf
operator|+
operator|(
name|cb_end
operator|-
name|cbp
operator|)
expr_stmt|;
name|nread
operator|=
name|cb_end
operator|-
name|cbp
expr_stmt|;
if|if
condition|(
name|nread
operator|>
name|left
condition|)
name|nread
operator|=
name|left
expr_stmt|;
name|clist_read
argument_list|(
name|file
argument_list|,
name|cbp
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|cb_end
operator|=
name|cbp
operator|+
name|nread
expr_stmt|;
name|cbp
operator|=
name|cbuf
expr_stmt|;
name|left
operator|-=
name|nread
expr_stmt|;
if|if
condition|(
name|cb_limit
operator|>
name|cb_end
condition|)
name|cb_limit
operator|=
name|cb_end
expr_stmt|;
block|}
name|op
operator|=
operator|*
name|cbp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[L]%s %d:\n"
argument_list|,
name|cmd_op_names
index|[
name|op
operator|>>
literal|4
index|]
argument_list|,
name|op
operator|&
literal|0xf
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|op
operator|>>
literal|4
condition|)
block|{
case|case
name|cmd_op_misc
operator|>>
literal|4
case|:
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|cmd_opv_end_run
case|:
goto|goto
name|top
goto|;
case|case
name|cmd_opv_set_tile_size
case|:
name|cmd_read_var
argument_list|(
operator|&
name|state_tile
operator|.
name|size
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|state_tile
operator|.
name|raster
operator|=
operator|(
operator|(
name|state_tile
operator|.
name|size
operator|.
name|x
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* We can't actually know the rep_size, */
comment|/* so we play it safe. */
name|state_tile
operator|.
name|rep_width
operator|=
name|state_tile
operator|.
name|size
operator|.
name|x
expr_stmt|;
name|state_tile
operator|.
name|rep_height
operator|=
name|state_tile
operator|.
name|size
operator|.
name|y
expr_stmt|;
name|cdev
operator|->
name|tile_slot_size
operator|=
name|tile_bits_size
operator|=
name|state_tile
operator|.
name|raster
operator|*
name|state_tile
operator|.
name|size
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|cmd_opv_set_tile_phase
case|:
name|cmd_read_var
argument_list|(
operator|&
name|state
operator|.
name|tile_phase
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_op
goto|;
block|}
name|tile_phase
operator|.
name|x
operator|=
name|state
operator|.
name|tile_phase
operator|.
name|x
operator|%
name|state_tile
operator|.
name|size
operator|.
name|x
expr_stmt|;
name|tile_phase
operator|.
name|y
operator|=
operator|(
name|state
operator|.
name|tile_phase
operator|.
name|y
operator|+
name|y0
operator|)
operator|%
name|state_tile
operator|.
name|size
operator|.
name|y
expr_stmt|;
continue|continue;
case|case
name|cmd_op_set_color0
operator|>>
literal|4
case|:
name|pcolor
operator|=
operator|&
name|state
operator|.
name|color0
expr_stmt|;
goto|goto
name|set_color
goto|;
case|case
name|cmd_op_set_color1
operator|>>
literal|4
case|:
name|pcolor
operator|=
operator|&
name|state
operator|.
name|color1
expr_stmt|;
name|set_color
label|:
if|if
condition|(
name|op
operator|&
literal|0xf
condition|)
operator|*
name|pcolor
operator|=
call|(
name|gx_color_index
call|)
argument_list|(
name|long
argument_list|)
argument_list|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|cmd_read_var
argument_list|(
name|pcolor
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|cmd_op_set_tile_index
operator|>>
literal|4
case|:
name|state_tile
operator|.
name|data
operator|=
operator|(
name|byte
operator|*
operator|)
name|tile_slot_ptr
argument_list|(
name|cdev
argument_list|,
operator|*
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|++
expr_stmt|;
continue|continue;
case|case
name|cmd_op_copy_mono
operator|>>
literal|4
case|:
if|if
condition|(
name|op
operator|&
literal|0xf
condition|)
block|{
name|assign_getw
argument_list|(
name|state
operator|.
name|rect
operator|.
name|x
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|assign_getw
argument_list|(
name|state
operator|.
name|rect
operator|.
name|y
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|state
operator|.
name|rect
operator|.
name|width
operator|=
operator|*
name|cbp
operator|++
expr_stmt|;
name|state
operator|.
name|rect
operator|.
name|height
operator|=
operator|*
name|cbp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* falls through */
case|case
name|cmd_op_fill_rect
operator|>>
literal|4
case|:
case|case
name|cmd_op_tile_rect
operator|>>
literal|4
case|:
case|case
name|cmd_op_copy_color
operator|>>
literal|4
case|:
name|cmd_read_var
argument_list|(
operator|&
name|state
operator|.
name|rect
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
break|break;
case|case
name|cmd_op_fill_rect_short
operator|>>
literal|4
case|:
case|case
name|cmd_op_tile_rect_short
operator|>>
literal|4
case|:
name|state
operator|.
name|rect
operator|.
name|x
operator|+=
operator|*
name|cbp
operator|+
name|cmd_min_short
expr_stmt|;
name|state
operator|.
name|rect
operator|.
name|width
operator|+=
name|cbp
index|[
literal|1
index|]
operator|+
name|cmd_min_short
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|0xf
condition|)
block|{
name|state
operator|.
name|rect
operator|.
name|height
operator|+=
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
name|cmd_min_tiny
expr_stmt|;
name|cbp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|state
operator|.
name|rect
operator|.
name|y
operator|+=
name|cbp
index|[
literal|2
index|]
operator|+
name|cmd_min_short
expr_stmt|;
name|state
operator|.
name|rect
operator|.
name|height
operator|+=
name|cbp
index|[
literal|3
index|]
operator|+
name|cmd_min_short
expr_stmt|;
name|cbp
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|cmd_op_fill_rect_tiny
operator|>>
literal|4
case|:
case|case
name|cmd_op_tile_rect_tiny
operator|>>
literal|4
case|:
block|{
name|int
name|txy
init|=
operator|*
name|cbp
operator|++
decl_stmt|;
name|state
operator|.
name|rect
operator|.
name|x
operator|+=
operator|(
name|txy
operator|>>
literal|4
operator|)
operator|+
name|cmd_min_tiny
expr_stmt|;
name|state
operator|.
name|rect
operator|.
name|y
operator|+=
operator|(
name|txy
operator|&
literal|0xf
operator|)
operator|+
name|cmd_min_tiny
expr_stmt|;
name|state
operator|.
name|rect
operator|.
name|width
operator|+=
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
name|cmd_min_tiny
expr_stmt|;
block|}
break|break;
case|case
name|cmd_op_set_tile_bits
operator|>>
literal|4
case|:
name|state_tile
operator|.
name|data
operator|=
operator|(
name|byte
operator|*
operator|)
name|tile_slot_ptr
argument_list|(
name|cdev
argument_list|,
operator|*
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|++
expr_stmt|;
if|if
condition|(
name|state_tile
operator|.
name|size
operator|.
name|x
operator|<=
literal|16
condition|)
block|{
name|cmd_read_short_bits
argument_list|(
name|state_tile
operator|.
name|data
argument_list|,
literal|2
argument_list|,
name|state_tile
operator|.
name|size
operator|.
name|y
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|=
name|tile_bits_size
expr_stmt|;
name|cmd_read
argument_list|(
name|state_tile
operator|.
name|data
argument_list|,
name|bytes
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|cmd_print_bits
argument_list|(
name|state_tile
operator|.
name|data
argument_list|,
name|state_tile
operator|.
name|size
operator|.
name|y
argument_list|,
name|state_tile
operator|.
name|raster
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
name|cmd_op_delta_tile_bits
operator|>>
literal|4
case|:
block|{
name|byte
modifier|*
name|new_data
init|=
operator|(
name|byte
operator|*
operator|)
name|tile_slot_ptr
argument_list|(
name|cdev
argument_list|,
operator|*
name|cbp
argument_list|)
decl_stmt|;
name|cbp
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|new_data
argument_list|,
name|state_tile
operator|.
name|data
argument_list|,
name|tile_bits_size
argument_list|)
expr_stmt|;
name|state_tile
operator|.
name|data
operator|=
name|new_data
expr_stmt|;
do|do
block|{
name|uint
name|offset
init|=
operator|*
name|cbp
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0x80
condition|)
name|new_data
index|[
name|offset
index|]
operator|^=
name|cbp
index|[
literal|1
index|]
operator|,
name|cbp
operator|+=
literal|2
expr_stmt|;
else|else
name|offset
operator|-=
literal|0x80
operator|,
name|new_data
index|[
name|offset
index|]
operator|^=
name|cbp
index|[
literal|1
index|]
operator|,
name|new_data
index|[
name|offset
operator|+
literal|1
index|]
operator|^=
name|cbp
index|[
literal|2
index|]
operator|,
name|cbp
operator|+=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|op
operator|--
operator|&
literal|0xf
condition|)
do|;
block|}
continue|continue;
default|default:
name|bad_op
label|:
name|printf
comment|/*lprintf5*/
argument_list|(
literal|"Bad op %02x band %d file pos %ld buf pos %d/%d\n"
argument_list|,
name|op
argument_list|,
name|band
argument_list|,
name|ftell
argument_list|(
name|file
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cbp
operator|-
name|cbuf
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cb_end
operator|-
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|cb_ptr
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|cbuf
init|;
name|pp
operator|<
name|cb_end
condition|;
name|pp
operator|+=
literal|10
control|)
name|printf
comment|/*lprintf10*/
argument_list|(
literal|" %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
argument_list|,
name|pp
index|[
literal|0
index|]
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|,
name|pp
index|[
literal|2
index|]
argument_list|,
name|pp
index|[
literal|3
index|]
argument_list|,
name|pp
index|[
literal|4
index|]
argument_list|,
name|pp
index|[
literal|5
index|]
argument_list|,
name|pp
index|[
literal|6
index|]
argument_list|,
name|pp
index|[
literal|7
index|]
argument_list|,
name|pp
index|[
literal|8
index|]
argument_list|,
name|pp
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
block|}
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[L]  x=%d y=%d w=%d h=%d\n"
argument_list|,
name|state
operator|.
name|rect
operator|.
name|x
argument_list|,
name|state
operator|.
name|rect
operator|.
name|y
argument_list|,
name|state
operator|.
name|rect
operator|.
name|width
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|op
operator|>>
literal|4
condition|)
block|{
case|case
name|cmd_op_fill_rect
operator|>>
literal|4
case|:
case|case
name|cmd_op_fill_rect_short
operator|>>
literal|4
case|:
case|case
name|cmd_op_fill_rect_tiny
operator|>>
literal|4
case|:
name|code
operator|=
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|fill_rectangle
call|)
argument_list|(
name|tdev
argument_list|,
name|state
operator|.
name|rect
operator|.
name|x
argument_list|,
name|state
operator|.
name|rect
operator|.
name|y
operator|-
name|y0
argument_list|,
name|state
operator|.
name|rect
operator|.
name|width
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|,
name|state
operator|.
name|color1
argument_list|)
expr_stmt|;
break|break;
case|case
name|cmd_op_tile_rect
operator|>>
literal|4
case|:
case|case
name|cmd_op_tile_rect_short
operator|>>
literal|4
case|:
case|case
name|cmd_op_tile_rect_tiny
operator|>>
literal|4
case|:
name|code
operator|=
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|tile_rectangle
call|)
argument_list|(
name|tdev
argument_list|,
operator|&
name|state_tile
argument_list|,
name|state
operator|.
name|rect
operator|.
name|x
argument_list|,
name|state
operator|.
name|rect
operator|.
name|y
operator|-
name|y0
argument_list|,
name|state
operator|.
name|rect
operator|.
name|width
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|,
name|state
operator|.
name|color0
argument_list|,
name|state
operator|.
name|color1
argument_list|,
name|tile_phase
operator|.
name|x
argument_list|,
name|tile_phase
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|cmd_op_copy_mono
operator|>>
literal|4
case|:
if|if
condition|(
name|op
operator|&
literal|0xf
condition|)
block|{
name|data_x
operator|=
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|-
literal|1
expr_stmt|;
name|raster
operator|=
literal|4
expr_stmt|;
name|cmd_read_short_bits
argument_list|(
name|bits
argument_list|,
operator|(
name|data_x
operator|+
name|state
operator|.
name|rect
operator|.
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|source
operator|=
name|bits
expr_stmt|;
goto|goto
name|copy
goto|;
block|}
comment|/* falls through */
case|case
name|cmd_op_copy_color
operator|>>
literal|4
case|:
name|assign_getw
argument_list|(
name|data_x
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|assign_getw
argument_list|(
name|raster
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|state
operator|.
name|rect
operator|.
name|height
operator|*
name|raster
expr_stmt|;
comment|/* copy_mono and copy_color have ensured that */
comment|/* the bits will fit in a single buffer. */
name|cmd_read
argument_list|(
name|cbuf
argument_list|,
name|bytes
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|source
operator|=
name|cbuf
expr_stmt|;
name|copy
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'L'
index|]
condition|)
block|{
name|dprintf2
argument_list|(
literal|"[L]  data_x=%d raster=%d\n"
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|)
expr_stmt|;
name|cmd_print_bits
argument_list|(
name|source
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|,
name|raster
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
operator|(
name|op
operator|>>
literal|4
operator|==
operator|(
name|byte
operator|)
name|cmd_op_copy_mono
operator|>>
literal|4
condition|?
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|copy_mono
call|)
argument_list|(
name|tdev
argument_list|,
name|source
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|state
operator|.
name|rect
operator|.
name|x
argument_list|,
name|state
operator|.
name|rect
operator|.
name|y
operator|-
name|y0
argument_list|,
name|state
operator|.
name|rect
operator|.
name|width
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|,
name|state
operator|.
name|color0
argument_list|,
name|state
operator|.
name|color1
argument_list|)
else|:
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|copy_color
call|)
argument_list|(
name|tdev
argument_list|,
name|source
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|state
operator|.
name|rect
operator|.
name|x
argument_list|,
name|state
operator|.
name|rect
operator|.
name|y
operator|-
name|y0
argument_list|,
name|state
operator|.
name|rect
operator|.
name|width
argument_list|,
name|state
operator|.
name|rect
operator|.
name|height
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The typical implementations of fread and fseek */
end_comment

begin_comment
comment|/* are extremely inefficient for small counts, */
end_comment

begin_comment
comment|/* so we use loops instead. */
end_comment

begin_function
name|private
name|void
name|clist_read
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
default|default:
name|fread
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|str
operator|++
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|str
operator|=
operator|(
name|byte
operator|)
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a short bitmap */
end_comment

begin_function
name|private
name|cb_ptr
name|clist_read_short_bits
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
specifier|register
name|int
name|bwidth
parameter_list|,
name|int
name|height
parameter_list|,
name|cb_ptr
name|cbp
parameter_list|,
name|cb_ptr
name|cb_end
parameter_list|)
block|{
name|uint
name|bytes
init|=
name|bwidth
operator|*
name|height
decl_stmt|;
name|byte
modifier|*
name|pdata
init|=
name|data
operator|+
name|bytes
decl_stmt|;
name|byte
modifier|*
name|udata
init|=
name|data
operator|+
operator|(
name|height
operator|<<
literal|2
operator|)
decl_stmt|;
name|cmd_read
argument_list|(
name|data
argument_list|,
name|bytes
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|height
operator|>
literal|0
condition|)
comment|/* first row is in place already */
block|{
name|udata
operator|-=
literal|4
operator|,
name|pdata
operator|-=
name|bwidth
expr_stmt|;
switch|switch
condition|(
name|bwidth
condition|)
block|{
case|case
literal|3
case|:
name|udata
index|[
literal|2
index|]
operator|=
name|pdata
index|[
literal|2
index|]
expr_stmt|;
case|case
literal|2
case|:
name|udata
index|[
literal|1
index|]
operator|=
name|pdata
index|[
literal|1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|udata
index|[
literal|0
index|]
operator|=
name|pdata
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
return|return
name|cbp
return|;
block|}
end_function

end_unit

