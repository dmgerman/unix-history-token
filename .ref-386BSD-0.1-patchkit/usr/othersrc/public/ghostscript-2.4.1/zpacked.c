begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zpacked.c */
end_comment

begin_comment
comment|/* Packed array operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_comment
comment|/* for alloc_refs */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Import the array packing flag */
end_comment

begin_decl_stmt
specifier|extern
name|ref
name|array_packing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* currentpacking */
end_comment

begin_function
name|int
name|zcurrentpacking
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
name|array_packing
operator|.
name|value
operator|.
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* packedarray */
end_comment

begin_function
name|int
name|zpackedarray
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|uint
name|size
decl_stmt|;
name|os_ptr
name|aop
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|<
literal|0
operator|||
name|op
operator|->
name|value
operator|.
name|intval
operator|>
name|max_uint
operator|/
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
operator|-
literal|1
condition|)
return|return
name|e_rangecheck
return|;
name|size
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|op
operator|-
name|osbot
condition|)
return|return
name|e_stackunderflow
return|;
name|aop
operator|=
name|op
operator|-
name|size
expr_stmt|;
name|code
operator|=
name|make_packed_array
argument_list|(
name|aop
argument_list|,
name|size
argument_list|,
name|aop
argument_list|,
literal|"packedarray"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|pop
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* setpacking */
end_comment

begin_function
name|int
name|zsetpacking
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
name|ref_save
argument_list|(
operator|&
name|array_packing
argument_list|,
literal|"setpacking"
argument_list|)
expr_stmt|;
name|array_packing
operator|.
name|value
operator|.
name|index
operator|=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Non-operator routines ------ */
end_comment

begin_comment
comment|/* Make a packed array.  See the comment in packed.h about */
end_comment

begin_comment
comment|/* ensuring that refs in mixed arrays are properly aligned. */
end_comment

begin_function
name|int
name|make_packed_array
parameter_list|(
name|ref
modifier|*
name|elts
parameter_list|,
name|uint
name|size
parameter_list|,
name|ref
modifier|*
name|paref
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
comment|/* Check whether we can make a packed array. */
name|ref
modifier|*
name|endp
init|=
name|elts
operator|+
name|size
decl_stmt|;
name|ref
modifier|*
name|pref
init|=
name|elts
decl_stmt|;
name|ushort
modifier|*
name|pbody
decl_stmt|,
modifier|*
name|pdest
decl_stmt|;
name|ushort
modifier|*
name|pshort
decl_stmt|;
comment|/* points to start of */
comment|/* last run of short elements */
name|int
name|atype
decl_stmt|;
comment|/* Allocate a maximum-size array first, */
comment|/* shorten later if needed. */
name|pbody
operator|=
operator|(
name|ushort
operator|*
operator|)
name|alloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbody
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|pshort
operator|=
name|pdest
operator|=
name|pbody
expr_stmt|;
for|for
control|(
init|;
name|pref
operator|<
name|endp
condition|;
name|pref
operator|++
control|)
block|{
switch|switch
condition|(
name|r_btype
argument_list|(
name|pref
argument_list|)
condition|)
comment|/* not r_type, opers are special */
block|{
case|case
name|t_name
case|:
if|if
condition|(
name|name_index
argument_list|(
name|pref
argument_list|)
operator|>=
name|packed_max_name_index
condition|)
break|break;
comment|/* can't pack */
operator|*
name|pdest
operator|=
name|name_index
argument_list|(
name|pref
argument_list|)
operator|+
operator|(
name|r_has_attr
argument_list|(
name|pref
argument_list|,
name|a_executable
argument_list|)
condition|?
name|pt_tag
argument_list|(
name|pt_executable_name
argument_list|)
else|:
name|pt_tag
argument_list|(
name|pt_literal_name
argument_list|)
operator|)
expr_stmt|;
name|pdest
operator|++
expr_stmt|;
continue|continue;
case|case
name|t_integer
case|:
if|if
condition|(
name|pref
operator|->
name|value
operator|.
name|intval
operator|<
name|packed_min_intval
operator|||
name|pref
operator|->
name|value
operator|.
name|intval
operator|>
name|packed_max_intval
condition|)
break|break;
operator|*
name|pdest
operator|=
name|pt_tag
argument_list|(
name|pt_integer
argument_list|)
operator|+
operator|(
operator|(
name|short
operator|)
name|pref
operator|->
name|value
operator|.
name|intval
operator|-
name|packed_min_intval
operator|)
expr_stmt|;
name|pdest
operator|++
expr_stmt|;
continue|continue;
case|case
name|t_oparray
case|:
case|case
name|t_operator
case|:
block|{
name|uint
name|oidx
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|pref
argument_list|,
name|a_executable
argument_list|)
condition|)
break|break;
name|oidx
operator|=
name|op_index
argument_list|(
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|oidx
operator|==
literal|0
operator|||
name|oidx
operator|>
name|packed_int_mask
condition|)
break|break;
operator|*
name|pdest
operator|=
name|pt_tag
argument_list|(
name|pt_executable_operator
argument_list|)
operator|+
name|oidx
expr_stmt|;
block|}
name|pdest
operator|++
expr_stmt|;
continue|continue;
default|default:
empty_stmt|;
block|}
comment|/* Can't pack this element, use a full ref. */
comment|/* We may have to unpack up to 3 preceding short elements. */
block|{
name|int
name|i
init|=
operator|(
name|pdest
operator|-
name|pshort
operator|)
operator|&
literal|3
decl_stmt|;
name|ref
modifier|*
name|pnext
init|=
operator|(
name|ref
operator|*
operator|)
operator|(
name|pdest
operator|+
operator|(
name|packed_per_ref
operator|-
literal|1
operator|)
operator|*
name|i
operator|)
decl_stmt|;
name|ref
modifier|*
name|pnext1
init|=
name|pnext
decl_stmt|;
name|ref
name|temp
decl_stmt|;
comment|/* source& dest might overlap */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|packed_get
argument_list|(
operator|--
name|pdest
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
operator|--
name|pnext
expr_stmt|;
name|ref_assign
argument_list|(
name|pnext
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|pdest
operator|=
operator|(
name|ushort
operator|*
operator|)
name|pnext1
expr_stmt|;
name|ref_assign
argument_list|(
operator|&
name|temp
argument_list|,
name|pref
argument_list|)
expr_stmt|;
name|ref_assign_new
argument_list|(
name|pnext1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|pdest
operator|+=
name|packed_per_ref
expr_stmt|;
name|pshort
operator|=
name|pdest
expr_stmt|;
block|}
name|atype
operator|=
operator|(
name|pdest
operator|==
name|pbody
operator|+
name|size
condition|?
name|t_shortarray
else|:
name|t_mixedarray
operator|)
expr_stmt|;
name|pbody
operator|=
operator|(
name|ushort
operator|*
operator|)
name|alloc_shrink
argument_list|(
operator|(
name|byte
operator|*
operator|)
name|pbody
argument_list|,
name|size
operator|*
name|packed_per_ref
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|pdest
operator|-
name|pbody
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|make_tasv_new
argument_list|(
name|paref
argument_list|,
name|atype
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|size
argument_list|,
name|packed
argument_list|,
name|pbody
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get an element from a packed array. */
end_comment

begin_comment
comment|/* (This works for ordinary arrays too.) */
end_comment

begin_function
name|void
name|packed_get
parameter_list|(
specifier|const
name|ushort
modifier|*
name|packed
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|ushort
name|elt
init|=
operator|*
name|packed
decl_stmt|;
switch|switch
condition|(
name|elt
operator|>>
name|packed_type_shift
condition|)
block|{
case|case
name|pt_executable_operator
case|:
name|op_index_ref
argument_list|(
name|elt
operator|&
name|packed_int_mask
argument_list|,
name|pref
argument_list|)
expr_stmt|;
break|break;
case|case
name|pt_integer
case|:
name|make_int
argument_list|(
name|pref
argument_list|,
operator|(
name|elt
operator|&
name|packed_int_mask
operator|)
operator|+
name|packed_min_intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|pt_literal_name
case|:
case|case
name|pt_literal_name
operator|+
literal|1
case|:
name|name_index_ref
argument_list|(
name|elt
operator|&
name|packed_max_name_index
argument_list|,
name|pref
argument_list|)
expr_stmt|;
break|break;
case|case
name|pt_executable_name
case|:
case|case
name|pt_executable_name
operator|+
literal|1
case|:
name|name_index_ref
argument_list|(
name|elt
operator|&
name|packed_max_name_index
argument_list|,
name|pref
argument_list|)
expr_stmt|;
name|r_set_attrs
argument_list|(
name|pref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* (shouldn't happen) */
case|case
name|pt_full_ref
case|:
name|ref_assign
argument_list|(
name|pref
argument_list|,
operator|(
specifier|const
name|ref
operator|*
operator|)
name|packed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip N elements in a packed array. */
end_comment

begin_comment
comment|/* (This works for ordinary arrays too.) */
end_comment

begin_function
name|void
name|packed_skip
parameter_list|(
name|ushort
modifier|*
modifier|*
name|pp
parameter_list|,
name|uint
name|count
parameter_list|)
block|{
name|ushort
modifier|*
name|packed
init|=
operator|*
name|pp
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|packed
operator|<=
name|packed_max_full_ref
condition|)
name|packed
operator|+=
name|packed_per_ref
expr_stmt|;
comment|/* full ref */
else|else
name|packed
operator|++
expr_stmt|;
operator|*
name|pp
operator|=
name|packed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zpacked_op_defs
index|[]
init|=
block|{
block|{
literal|"0currentpacking"
block|,
name|zcurrentpacking
block|}
block|,
block|{
literal|"1packedarray"
block|,
name|zpackedarray
block|}
block|,
block|{
literal|"1setpacking"
block|,
name|zsetpacking
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

