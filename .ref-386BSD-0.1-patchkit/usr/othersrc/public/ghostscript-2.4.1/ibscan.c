begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* ibscan.c */
end_comment

begin_comment
comment|/* Binary token scanner */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_comment
comment|/* for immediately evaluated names */
end_comment

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"ostack.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_comment
comment|/* for alloc_refs */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"btoken.h"
end_include

begin_include
include|#
directive|include
file|"bseq.h"
end_include

begin_include
include|#
directive|include
file|"bnum.h"
end_include

begin_comment
comment|/* Import the system and user name tables */
end_comment

begin_decl_stmt
specifier|extern
name|ref
name|system_names
decl_stmt|,
name|user_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|array_get
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|long
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|scan_binary_sequence
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan a binary token.  Called from the main scanner */
end_comment

begin_comment
comment|/* when it encounters an ASCII code 128-159, */
end_comment

begin_comment
comment|/* if binary tokens are being recognized (object format != 0). */
end_comment

begin_function
name|int
name|scan_binary_token
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|,
name|int
name|tcode
parameter_list|)
block|{
name|int
name|num_format
decl_stmt|,
name|code
decl_stmt|;
name|uint
name|arg
decl_stmt|;
name|long
name|nidx
decl_stmt|;
if|if
condition|(
name|seofp
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
switch|switch
condition|(
name|tcode
condition|)
block|{
case|case
name|bt_seq_IEEE_msb
case|:
name|s
operator|->
name|num_format
operator|=
name|num_msb
operator|+
name|num_float_IEEE
expr_stmt|;
goto|goto
name|bseq
goto|;
case|case
name|bt_seq_IEEE_lsb
case|:
name|s
operator|->
name|num_format
operator|=
name|num_lsb
operator|+
name|num_float_IEEE
expr_stmt|;
goto|goto
name|bseq
goto|;
case|case
name|bt_seq_native_msb
case|:
name|s
operator|->
name|num_format
operator|=
name|num_msb
operator|+
name|num_float_native
expr_stmt|;
goto|goto
name|bseq
goto|;
case|case
name|bt_seq_native_lsb
case|:
name|s
operator|->
name|num_format
operator|=
name|num_lsb
operator|+
name|num_float_native
expr_stmt|;
name|bseq
label|:
return|return
name|scan_binary_sequence
argument_list|(
name|s
argument_list|,
name|pref
argument_list|)
return|;
case|case
name|bt_int32_msb
case|:
name|num_format
operator|=
name|num_msb
operator|+
name|num_int32
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|bt_int32_lsb
case|:
name|num_format
operator|=
name|num_lsb
operator|+
name|num_int32
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|bt_int16_msb
case|:
name|num_format
operator|=
name|num_msb
operator|+
name|num_int16
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|bt_int16_lsb
case|:
name|num_format
operator|=
name|num_lsb
operator|+
name|num_int16
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|bt_int8
case|:
name|make_int
argument_list|(
name|pref
argument_list|,
operator|(
name|sgetc
argument_list|(
name|s
argument_list|)
operator|^
literal|128
operator|)
operator|-
literal|128
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|bt_fixed
case|:
name|num_format
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_is_valid
argument_list|(
name|num_format
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
goto|goto
name|num
goto|;
case|case
name|bt_float_IEEE_msb
case|:
name|num_format
operator|=
name|num_msb
operator|+
name|num_float_IEEE
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|bt_float_IEEE_lsb
case|:
name|num_format
operator|=
name|num_lsb
operator|+
name|num_float_IEEE
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|bt_float_native
case|:
name|num_format
operator|=
name|num_float_native
expr_stmt|;
name|num
label|:
name|s
operator|->
name|num_format
operator|=
name|num_format
expr_stmt|;
name|code
operator|=
name|sget_encoded_number
argument_list|(
name|s
argument_list|,
name|pref
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|t_integer
case|:
case|case
name|t_real
case|:
name|r_set_type
argument_list|(
name|pref
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_null
case|:
return|return
name|e_syntaxerror
return|;
default|default:
return|return
name|code
return|;
block|}
return|return
literal|0
return|;
case|case
name|bt_boolean
case|:
name|arg
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|&
operator|~
literal|1
condition|)
return|return
name|e_syntaxerror
return|;
name|make_bool
argument_list|(
name|pref
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|bt_string_256
case|:
name|arg
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|str
goto|;
case|case
name|bt_string_64k_msb
case|:
name|arg
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|seofp
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
name|arg
operator|+=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|str
goto|;
case|case
name|bt_string_64k_lsb
case|:
name|arg
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|seofp
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
name|arg
operator|+=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|str
label|:
block|{
name|byte
modifier|*
name|str
init|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
literal|"string token"
argument_list|)
decl_stmt|;
name|uint
name|rcnt
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|rcnt
operator|=
name|sgets
argument_list|(
name|s
argument_list|,
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcnt
operator|!=
name|arg
condition|)
return|return
name|e_syntaxerror
return|;
name|make_tasv
argument_list|(
name|pref
argument_list|,
name|t_string
argument_list|,
name|a_all
argument_list|,
name|arg
argument_list|,
name|bytes
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|bt_litname_system
case|:
name|nidx
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|array_get
argument_list|(
operator|&
name|system_names
argument_list|,
name|nidx
argument_list|,
name|pref
argument_list|)
return|;
case|case
name|bt_execname_system
case|:
name|nidx
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|code
operator|=
name|array_get
argument_list|(
operator|&
name|system_names
argument_list|,
name|nidx
argument_list|,
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|r_set_attrs
argument_list|(
name|pref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|bt_litname_user
case|:
name|nidx
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|code
operator|=
name|array_get
argument_list|(
operator|&
name|user_names
argument_list|,
name|nidx
argument_list|,
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pref
argument_list|,
name|t_name
argument_list|)
condition|)
return|return
name|e_undefined
return|;
return|return
literal|0
return|;
case|case
name|bt_execname_user
case|:
name|nidx
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|code
operator|=
name|array_get
argument_list|(
operator|&
name|user_names
argument_list|,
name|nidx
argument_list|,
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pref
argument_list|,
name|t_name
argument_list|)
condition|)
return|return
name|e_undefined
return|;
name|r_set_attrs
argument_list|(
name|pref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|bt_num_array
case|:
block|{
name|ref
modifier|*
name|nap
decl_stmt|;
name|uint
name|i
decl_stmt|;
name|num_format
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_is_valid
argument_list|(
name|num_format
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
name|s
operator|->
name|num_format
operator|=
name|num_format
expr_stmt|;
name|code
operator|=
name|sgetshort
argument_list|(
name|s
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|nap
operator|=
name|alloc_refs
argument_list|(
name|arg
argument_list|,
literal|"number array token"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arg
condition|;
name|i
operator|++
control|)
block|{
name|ref
modifier|*
name|np
init|=
name|nap
operator|+
name|i
decl_stmt|;
name|int
name|code
init|=
name|sget_encoded_number
argument_list|(
name|s
argument_list|,
name|np
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|t_integer
case|:
case|case
name|t_real
case|:
name|r_set_type
argument_list|(
name|np
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_null
case|:
return|return
name|e_syntaxerror
return|;
default|default:
return|return
name|code
return|;
block|}
block|}
name|make_tasv
argument_list|(
name|pref
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
name|arg
argument_list|,
name|refs
argument_list|,
name|nap
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|e_syntaxerror
return|;
block|}
end_function

begin_comment
comment|/* Scan a binary object sequence. */
end_comment

begin_function
name|private
name|int
name|scan_binary_sequence
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|ushort
name|top_size
init|=
name|sgetc
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ushort
name|size
decl_stmt|;
name|uint
name|max_array_index
decl_stmt|;
name|uint
name|min_string_index
decl_stmt|;
name|uint
name|index
decl_stmt|;
name|int
name|code
decl_stmt|;
specifier|register
name|os_ptr
name|op
init|=
name|osp
decl_stmt|;
if|#
directive|if
name|arch_is_big_endian
define|#
directive|define
name|must_swap_bytes
value|s_is_lsb(s)
else|#
directive|else
define|#
directive|define
name|must_swap_bytes
value|s_is_msb(s)
endif|#
directive|endif
if|if
condition|(
name|top_size
operator|==
literal|0
condition|)
block|{
comment|/* Extended header (2-byte array size, 4-byte length) */
name|ulong
name|lsize
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|sgetshort
argument_list|(
name|s
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|top_size
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|sgetlong
argument_list|(
name|s
argument_list|,
operator|(
name|long
operator|*
operator|)
operator|&
name|lsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|size
operator|=
operator|(
name|ushort
operator|)
name|lsize
operator|)
operator|!=
name|lsize
condition|)
return|return
name|e_limitcheck
return|;
if|if
condition|(
name|size
operator|<
literal|8
operator|+
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
name|size
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal header (1-byte array size, 2-byte length) */
if|if
condition|(
operator|(
name|code
operator|=
name|sgetshort
argument_list|(
name|s
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|size
operator|<
literal|4
operator|+
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
name|size
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* First pass: read objects, handle all but composite. */
name|max_array_index
operator|=
name|top_size
expr_stmt|;
name|min_string_index
operator|=
name|size
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|max_array_index
condition|;
name|index
operator|++
control|)
block|{
name|bin_seq_obj
name|ob
decl_stmt|;
name|byte
name|bt
decl_stmt|;
if|if
condition|(
name|sgets
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
condition|)
return|return
name|e_syntaxerror
return|;
if|if
condition|(
operator|++
name|op
operator|>
name|ostop
condition|)
return|return
name|e_limitcheck
return|;
define|#
directive|define
name|swap_size
parameter_list|()
define|\
value|if ( must_swap_bytes )\     bt = ob.size.b[0], ob.size.b[0] = ob.size.b[1], ob.size.b[1] = bt
define|#
directive|define
name|swap_value
parameter_list|()
define|\
value|if ( must_swap_bytes )\     bt = ob.value.b[0], ob.value.b[0] = ob.value.b[3], ob.value.b[3] = bt,\     bt = ob.value.b[1], ob.value.b[1] = ob.value.b[2], ob.value.b[2] = bt
switch|switch
condition|(
name|ob
operator|.
name|tx
operator|&
literal|0x7f
condition|)
block|{
case|case
name|bs_null
case|:
name|make_null
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_integer
case|:
name|swap_value
argument_list|()
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|ob
operator|.
name|value
operator|.
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_real
case|:
if|if
condition|(
name|ob
operator|.
name|size
operator|.
name|w
operator|!=
literal|0
condition|)
comment|/* fixed-point number */
block|{
name|swap_size
argument_list|()
expr_stmt|;
name|swap_value
argument_list|()
expr_stmt|;
name|ob
operator|.
name|value
operator|.
name|f
operator|=
operator|(
name|float
operator|)
name|ldexp
argument_list|(
operator|(
name|float
operator|)
name|ob
operator|.
name|value
operator|.
name|w
argument_list|,
operator|-
name|ob
operator|.
name|size
operator|.
name|w
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|->
name|num_format
operator|&
operator|~
operator|(
name|num_lsb
operator||
name|num_msb
operator|)
operator|)
operator|!=
name|num_float_native
condition|)
block|{
name|swap_value
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|arch_floats_are_IEEE
comment|/* Convert IEEE float to native float. */
block|{
name|int
name|expt
init|=
operator|(
name|ob
operator|.
name|value
operator|.
name|w
operator|>>
literal|23
operator|)
operator|&
literal|0xff
decl_stmt|;
name|long
name|mant
init|=
name|ob
operator|.
name|value
operator|.
name|w
operator|&
literal|0x7fffff
decl_stmt|;
if|if
condition|(
name|expt
operator|==
literal|0
operator|&&
name|mant
operator|==
literal|0
condition|)
name|ob
operator|.
name|value
operator|.
name|f
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|mant
operator|+=
literal|0x800000
expr_stmt|;
name|ob
operator|.
name|value
operator|.
name|f
operator|=
operator|(
name|float
operator|)
name|ldexp
argument_list|(
operator|(
name|float
operator|)
name|mant
argument_list|,
name|expt
operator|-
literal|127
operator|-
literal|24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ob
operator|.
name|value
operator|.
name|w
operator|<
literal|0
condition|)
name|ob
operator|.
name|value
operator|.
name|f
operator|=
operator|-
name|ob
operator|.
name|value
operator|.
name|f
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|make_real
argument_list|(
name|op
argument_list|,
name|ob
operator|.
name|value
operator|.
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_boolean
case|:
name|swap_value
argument_list|()
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
operator|(
name|ob
operator|.
name|value
operator|.
name|w
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_string
case|:
name|swap_size
argument_list|()
expr_stmt|;
name|swap_value
argument_list|()
expr_stmt|;
if|if
condition|(
name|ob
operator|.
name|value
operator|.
name|w
operator|<
name|max_array_index
operator|||
name|ob
operator|.
name|value
operator|.
name|w
operator|+
name|ob
operator|.
name|size
operator|.
name|w
operator|>
name|size
condition|)
return|return
name|e_syntaxerror
return|;
if|if
condition|(
name|ob
operator|.
name|value
operator|.
name|w
operator|<
name|min_string_index
condition|)
name|min_string_index
operator|=
operator|(
name|uint
operator|)
name|ob
operator|.
name|value
operator|.
name|w
expr_stmt|;
name|make_tasv
argument_list|(
name|op
argument_list|,
name|t_string
argument_list|,
operator|(
name|ob
operator|.
name|tx
operator|<
literal|128
condition|?
name|a_all
else|:
name|a_all
operator|+
name|a_executable
operator|)
argument_list|,
name|ob
operator|.
name|size
operator|.
name|w
argument_list|,
name|intval
argument_list|,
name|ob
operator|.
name|value
operator|.
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_name
case|:
case|case
name|bs_eval_name
case|:
name|swap_size
argument_list|()
expr_stmt|;
name|swap_value
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ob
operator|.
name|size
operator|.
name|w
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|0xffff
case|:
break|break;
default|default:
if|if
condition|(
name|ob
operator|.
name|value
operator|.
name|w
operator|<
name|max_array_index
operator|||
name|ob
operator|.
name|value
operator|.
name|w
operator|+
name|ob
operator|.
name|size
operator|.
name|w
operator|>
name|size
condition|)
return|return
name|e_syntaxerror
return|;
if|if
condition|(
name|ob
operator|.
name|value
operator|.
name|w
operator|<
name|min_string_index
condition|)
name|min_string_index
operator|=
operator|(
name|uint
operator|)
name|ob
operator|.
name|value
operator|.
name|w
expr_stmt|;
block|}
name|make_tasv
argument_list|(
name|op
argument_list|,
name|t_name
argument_list|,
operator|(
operator|(
name|ob
operator|.
name|tx
operator|&
literal|0x7f
operator|)
operator|==
name|bs_eval_name
condition|?
literal|0
else|:
name|ob
operator|.
name|tx
operator|&
literal|0x80
condition|?
name|a_all
operator|+
name|a_executable
else|:
name|a_all
operator|)
argument_list|,
name|ob
operator|.
name|size
operator|.
name|w
argument_list|,
name|intval
argument_list|,
name|ob
operator|.
name|value
operator|.
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_array
case|:
name|swap_size
argument_list|()
expr_stmt|;
name|swap_value
argument_list|()
expr_stmt|;
if|if
condition|(
name|ob
operator|.
name|value
operator|.
name|w
operator|+
name|ob
operator|.
name|size
operator|.
name|w
operator|>
name|min_string_index
operator|||
name|ob
operator|.
name|value
operator|.
name|w
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
operator|-
literal|1
operator|)
condition|)
return|return
name|e_syntaxerror
return|;
name|max_array_index
operator|=
name|max
argument_list|(
name|max_array_index
argument_list|,
name|ob
operator|.
name|value
operator|.
name|w
operator|/
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
operator|+
name|ob
operator|.
name|size
operator|.
name|w
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
name|op
argument_list|,
name|t_array
argument_list|,
operator|(
name|ob
operator|.
name|tx
operator|<
literal|128
condition|?
name|a_all
else|:
name|a_all
operator|+
name|a_executable
operator|)
argument_list|,
name|ob
operator|.
name|size
operator|.
name|w
argument_list|,
name|intval
argument_list|,
name|ob
operator|.
name|value
operator|.
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|bs_mark
case|:
name|make_mark
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|e_syntaxerror
return|;
block|}
block|}
comment|/* Allocate objects and strings. */
name|min_string_index
operator|=
name|min
argument_list|(
name|min_string_index
argument_list|,
name|max_array_index
operator|*
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|ref
modifier|*
name|rbase
init|=
name|alloc_refs
argument_list|(
name|max_array_index
argument_list|,
literal|"binary object sequence(objects)"
argument_list|)
decl_stmt|;
name|uint
name|str_size
init|=
name|size
operator|-
name|min_string_index
decl_stmt|;
name|byte
modifier|*
name|sbase
init|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|str_size
argument_list|,
literal|1
argument_list|,
literal|"binary object sequence(strings)"
argument_list|)
decl_stmt|;
name|os_ptr
name|op_top
init|=
name|op
decl_stmt|;
if|if
condition|(
name|rbase
operator|==
literal|0
operator|||
name|sbase
operator|==
literal|0
condition|)
block|{
comment|/* SHOULD FREE THEM */
return|return
name|e_VMerror
return|;
block|}
if|if
condition|(
name|sgets
argument_list|(
name|s
argument_list|,
name|sbase
argument_list|,
name|str_size
argument_list|)
operator|!=
name|str_size
condition|)
return|return
name|e_syntaxerror
return|;
comment|/* Fix up composites. */
for|for
control|(
name|op
operator|=
name|osp
init|;
name|op
operator|!=
name|op_top
condition|;
control|)
switch|switch
condition|(
name|r_type
argument_list|(
operator|++
name|op
argument_list|)
condition|)
block|{
case|case
name|t_string
case|:
name|op
operator|->
name|value
operator|.
name|bytes
operator|=
name|sbase
operator|+
operator|(
name|op
operator|->
name|value
operator|.
name|intval
operator|-
name|min_string_index
operator|)
expr_stmt|;
break|break;
case|case
name|t_array
case|:
name|op
operator|->
name|value
operator|.
name|refs
operator|=
name|rbase
operator|+
operator|(
name|op
operator|->
name|value
operator|.
name|intval
operator|/
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|t_name
case|:
block|{
name|ref
name|rname
decl_stmt|;
switch|switch
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|code
operator|=
name|array_get
argument_list|(
operator|&
name|user_names
argument_list|,
name|op
operator|->
name|value
operator|.
name|intval
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
goto|goto
name|usn
goto|;
case|case
literal|0xffff
case|:
name|code
operator|=
name|array_get
argument_list|(
operator|&
name|system_names
argument_list|,
name|op
operator|->
name|value
operator|.
name|intval
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
name|usn
label|:
if|if
condition|(
name|code
operator|>=
literal|0
operator|&&
operator|!
name|r_has_type
argument_list|(
operator|&
name|rname
argument_list|,
name|t_name
argument_list|)
condition|)
return|return
name|e_undefined
return|;
break|break;
default|default:
comment|/* ordinary name */
name|code
operator|=
name|name_ref
argument_list|(
name|sbase
operator|+
operator|(
name|op
operator|->
name|value
operator|.
name|intval
operator|-
name|min_string_index
operator|)
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|,
operator|&
name|rname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|op
argument_list|,
name|a_read
argument_list|)
condition|)
comment|/* bs_eval_name */
block|{
name|ref
modifier|*
name|defp
init|=
name|dict_find_name
argument_list|(
operator|&
name|rname
argument_list|)
decl_stmt|;
if|if
condition|(
name|defp
operator|==
literal|0
condition|)
return|return
name|e_undefined
return|;
name|rname
operator|=
operator|*
name|defp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_has_attr
argument_list|(
name|op
argument_list|,
name|a_executable
argument_list|)
condition|)
name|r_set_attrs
argument_list|(
operator|&
name|rname
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|refcpy_to_new
argument_list|(
name|rbase
argument_list|,
name|osp
operator|+
literal|1
argument_list|,
name|max_array_index
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
name|pref
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
name|top_size
argument_list|,
name|refs
argument_list|,
name|rbase
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

