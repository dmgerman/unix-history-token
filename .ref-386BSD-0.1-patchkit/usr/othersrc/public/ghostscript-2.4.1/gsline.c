begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsline.c */
end_comment

begin_comment
comment|/* Line parameter operators for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gzstate */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzline.h"
end_include

begin_comment
comment|/* setlinewidth */
end_comment

begin_function
name|int
name|gs_setlinewidth
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|width
parameter_list|)
block|{
name|pgs
operator|->
name|line_params
operator|->
name|width
operator|=
name|width
operator|/
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentlinewidth */
end_comment

begin_function
name|float
name|gs_currentlinewidth
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
call|(
name|float
call|)
argument_list|(
name|pgs
operator|->
name|line_params
operator|->
name|width
operator|*
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* setlinecap */
end_comment

begin_function
name|int
name|gs_setlinecap
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_line_cap
name|cap
parameter_list|)
block|{
name|pgs
operator|->
name|line_params
operator|->
name|cap
operator|=
name|cap
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentlinecap */
end_comment

begin_function
name|gs_line_cap
name|gs_currentlinecap
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|line_params
operator|->
name|cap
return|;
block|}
end_function

begin_comment
comment|/* setlinejoin */
end_comment

begin_function
name|int
name|gs_setlinejoin
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_line_join
name|join
parameter_list|)
block|{
name|pgs
operator|->
name|line_params
operator|->
name|join
operator|=
name|join
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentlinejoin */
end_comment

begin_function
name|gs_line_join
name|gs_currentlinejoin
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|line_params
operator|->
name|join
return|;
block|}
end_function

begin_comment
comment|/* setmiterlimit */
end_comment

begin_function
name|int
name|gs_setmiterlimit
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|<
literal|1.0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
name|pgs
operator|->
name|line_params
operator|->
name|miter_limit
operator|=
name|limit
expr_stmt|;
comment|/* The supplied miter limit is an upper bound on */
comment|/* 1/sin(phi/2).  We convert this to a lower bound on */
comment|/* tan(phi).  Note that if phi> pi/2, this is negative. */
comment|/* We use the half-angle and angle-sum formulas here */
comment|/* to avoid the trig functions.... */
block|{
name|double
name|limit_sq
init|=
name|limit
operator|*
name|limit
decl_stmt|;
comment|/* We need a special check for phi/2 close to pi/4. */
comment|/* Some C compilers can't handle the following as a */
comment|/* conditional expression.... */
if|if
condition|(
name|limit_sq
operator|<
literal|2.0001
operator|&&
name|limit_sq
operator|>
literal|1.9999
condition|)
name|pgs
operator|->
name|line_params
operator|->
name|miter_check
operator|=
literal|1.0e6
expr_stmt|;
else|else
name|pgs
operator|->
name|line_params
operator|->
name|miter_check
operator|=
name|sqrt
argument_list|(
name|limit_sq
operator|-
literal|1
argument_list|)
operator|*
literal|2
operator|/
operator|(
name|limit_sq
operator|-
literal|2
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentmiterlimit */
end_comment

begin_function
name|float
name|gs_currentmiterlimit
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|line_params
operator|->
name|miter_limit
return|;
block|}
end_function

begin_comment
comment|/* setdash */
end_comment

begin_function
name|int
name|gs_setdash
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
specifier|const
name|float
modifier|*
name|pattern
parameter_list|,
name|uint
name|length
parameter_list|,
name|floatp
name|offset
parameter_list|)
block|{
name|uint
name|n
init|=
name|length
decl_stmt|;
specifier|const
name|float
modifier|*
name|dfrom
init|=
name|pattern
decl_stmt|;
name|char
name|ink
init|=
literal|1
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|float
name|pattern_length
init|=
literal|0.0
decl_stmt|;
name|float
name|dist_left
decl_stmt|;
name|dash_params
modifier|*
name|dash
init|=
operator|&
name|pgs
operator|->
name|line_params
operator|->
name|dash
decl_stmt|;
name|float
modifier|*
name|ppat
decl_stmt|;
comment|/* Check the dash pattern */
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|float
name|elt
init|=
operator|*
name|dfrom
operator|++
decl_stmt|;
if|if
condition|(
name|elt
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
name|pattern_length
operator|+=
name|elt
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
comment|/* empty pattern */
block|{
name|dist_left
operator|=
literal|0.0
expr_stmt|;
name|ppat
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pattern_length
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
comment|/* Compute the initial index, ink_on, and distance left */
comment|/* in the pattern, according to the offset. */
define|#
directive|define
name|f_mod
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) - floor((a) / (b)) * (b))
name|dist_left
operator|=
name|f_mod
argument_list|(
name|offset
argument_list|,
name|pattern_length
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dist_left
operator|-=
name|pattern
index|[
name|index
index|]
operator|)
operator|>=
literal|0
condition|)
name|ink
operator|=
operator|!
name|ink
operator|,
name|index
operator|++
expr_stmt|;
name|ppat
operator|=
operator|(
name|float
operator|*
operator|)
name|gs_malloc
argument_list|(
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|,
literal|"dash pattern"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppat
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ppat
argument_list|,
name|pattern
argument_list|,
name|length
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dash
operator|->
name|pattern
operator|=
name|ppat
expr_stmt|;
name|dash
operator|->
name|pattern_size
operator|=
name|length
expr_stmt|;
name|dash
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|dash
operator|->
name|init_ink_on
operator|=
name|ink
expr_stmt|;
name|dash
operator|->
name|init_index
operator|=
name|index
expr_stmt|;
name|dash
operator|->
name|init_dist_left
operator|=
operator|-
name|dist_left
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentdash */
end_comment

begin_function
name|uint
name|gs_currentdash_length
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|line_params
operator|->
name|dash
operator|.
name|pattern_size
return|;
block|}
end_function

begin_function
name|int
name|gs_currentdash_pattern
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|float
modifier|*
name|pattern
parameter_list|)
block|{
name|memcpy
argument_list|(
name|pattern
argument_list|,
name|pgs
operator|->
name|line_params
operator|->
name|dash
operator|.
name|pattern
argument_list|,
name|pgs
operator|->
name|line_params
operator|->
name|dash
operator|.
name|pattern_size
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|float
name|gs_currentdash_offset
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|line_params
operator|->
name|dash
operator|.
name|offset
return|;
block|}
end_function

end_unit

