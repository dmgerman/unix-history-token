begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* iinit.c */
end_comment

begin_comment
comment|/* Initialize internally known objects for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_define
define|#
directive|define
name|INCLUDE_ERROR_NAMES
end_define

begin_comment
comment|/* see errors.h */
end_comment

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_comment
comment|/* for alloc_refs */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Implementation parameters. */
end_comment

begin_comment
comment|/* The size of systemdict can be set in the makefile. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSTEMDICT_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SYSTEMDICT_SIZE
value|449
end_define

begin_comment
comment|/* a nice prime (?) number */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|systemdict_size
value|SYSTEMDICT_SIZE
end_define

begin_define
define|#
directive|define
name|op_array_table_size
value|100
end_define

begin_comment
comment|/* arbitrary */
end_comment

begin_comment
comment|/* Standard dictionaries */
end_comment

begin_decl_stmt
name|ref
name|name_errordict
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error names */
end_comment

begin_decl_stmt
name|ref
name|name_ErrorNames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The operator tables */
end_comment

begin_decl_stmt
name|op_def_ptr
modifier|*
name|op_def_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint
name|op_def_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ref
name|op_array_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* t_array, definitions of `operator' procedures */
end_comment

begin_decl_stmt
name|ushort
modifier|*
name|op_array_nx_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name indices for same */
end_comment

begin_decl_stmt
name|uint
name|op_array_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enter a name and value into systemdict */
end_comment

begin_function
name|void
name|initial_enter_name
parameter_list|(
specifier|const
name|char
modifier|*
name|nstr
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|ref
name|nref
decl_stmt|;
name|name_enter
argument_list|(
name|nstr
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict_put
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|nref
argument_list|,
name|pref
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"dict_put failed!\n"
argument_list|)
operator|,
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize objects other than operators */
end_comment

begin_function
name|void
name|obj_init
parameter_list|()
block|{
comment|/* Initialize the standard objects */
name|ref
name|vmark
decl_stmt|,
name|vnull
decl_stmt|;
name|make_tv
argument_list|(
operator|&
name|vmark
argument_list|,
name|t_mark
argument_list|,
name|intval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_tv
argument_list|(
operator|&
name|vnull
argument_list|,
name|t_null
argument_list|,
name|intval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create the system dictionary */
name|dict_create
argument_list|(
name|systemdict_size
argument_list|,
operator|&
name|systemdict
argument_list|)
expr_stmt|;
name|dstack
index|[
literal|1
index|]
operator|=
name|dstack
index|[
literal|0
index|]
expr_stmt|;
comment|/* just during initialization */
comment|/* Initialize the predefined names other than operators */
name|initial_enter_name
argument_list|(
literal|"mark"
argument_list|,
operator|&
name|vmark
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"null"
argument_list|,
operator|&
name|vnull
argument_list|)
expr_stmt|;
comment|/* Create other system-known names */
name|name_enter
argument_list|(
literal|"errordict"
argument_list|,
operator|&
name|name_errordict
argument_list|)
expr_stmt|;
name|name_enter
argument_list|(
literal|"ErrorNames"
argument_list|,
operator|&
name|name_ErrorNames
argument_list|)
expr_stmt|;
comment|/* Create the error name table */
block|{
name|int
name|n
init|=
sizeof|sizeof
argument_list|(
name|gs_error_names
argument_list|)
operator|/
expr|sizeof
operator|(
name|char
name|_ds
operator|*
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ref
name|era
decl_stmt|;
name|make_tasv
argument_list|(
operator|&
name|era
argument_list|,
name|t_array
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|n
argument_list|,
name|refs
argument_list|,
name|alloc_refs
argument_list|(
name|n
argument_list|,
literal|"obj_init(ErrorNames)"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|name_enter
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gs_error_names
index|[
name|i
index|]
argument_list|,
name|era
operator|.
name|value
operator|.
name|refs
operator|+
name|i
argument_list|)
expr_stmt|;
name|dict_put
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|name_ErrorNames
argument_list|,
operator|&
name|era
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Optional devices and .ps files are handled in gconfig.c. */
end_comment

begin_define
define|#
directive|define
name|device_
parameter_list|(
name|dev
parameter_list|)
end_define

begin_define
define|#
directive|define
name|psfile_
parameter_list|(
name|fns
parameter_list|)
end_define

begin_comment
comment|/* Initialize the operators */
end_comment

begin_define
define|#
directive|define
name|oper_
parameter_list|(
name|defs
parameter_list|)
value|defs[],
end_define

begin_comment
comment|/* Non-graphics operators */
end_comment

begin_decl_stmt
specifier|extern
name|op_def
include|#
directive|include
file|"gconfig.h"
name|interp_op_defs
index|[]
decl_stmt|,
name|zarith_op_defs
index|[]
decl_stmt|,
name|zarray_op_defs
index|[]
decl_stmt|,
name|zcontrol_op_defs
index|[]
decl_stmt|,
name|zdict_op_defs
index|[]
decl_stmt|,
name|zfile_op_defs
index|[]
decl_stmt|,
name|zfileio_op_defs
index|[]
decl_stmt|,
name|zfilter_op_defs
index|[]
decl_stmt|,
name|zgeneric_op_defs
index|[]
decl_stmt|,
name|zmath_op_defs
index|[]
decl_stmt|,
name|zmisc_op_defs
index|[]
decl_stmt|,
name|zpacked_op_defs
index|[]
decl_stmt|,
name|zprops_op_defs
index|[]
decl_stmt|,
name|zrelbit_op_defs
index|[]
decl_stmt|,
name|zstack_op_defs
index|[]
decl_stmt|,
name|zstring_op_defs
index|[]
decl_stmt|,
name|ztype_op_defs
index|[]
decl_stmt|,
name|zvmem_op_defs
index|[]
decl_stmt|,
comment|/* Graphics operators */
name|zchar_op_defs
index|[]
decl_stmt|,
name|zcolor_op_defs
index|[]
decl_stmt|,
name|zdevice_op_defs
index|[]
decl_stmt|,
name|zfont_op_defs
index|[]
decl_stmt|,
name|zfont1_op_defs
index|[]
decl_stmt|,
name|zfont2_op_defs
index|[]
decl_stmt|,
name|zgstate_op_defs
index|[]
decl_stmt|,
name|zht_op_defs
index|[]
decl_stmt|,
name|zmatrix_op_defs
index|[]
decl_stmt|,
name|zpaint_op_defs
index|[]
decl_stmt|,
name|zpath_op_defs
index|[]
decl_stmt|,
name|zpath2_op_defs
index|[]
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|oper_
end_undef

begin_define
define|#
directive|define
name|oper_
parameter_list|(
name|defs
parameter_list|)
value|defs,
end_define

begin_decl_stmt
name|private
name|op_def_ptr
name|op_defs_all
index|[]
init|=
block|{
include|#
directive|include
file|"gconfig.h"
comment|/* Non-graphics operators */
name|interp_op_defs
block|,
name|zarith_op_defs
block|,
name|zarray_op_defs
block|,
name|zcontrol_op_defs
block|,
name|zdict_op_defs
block|,
name|zfile_op_defs
block|,
name|zfileio_op_defs
block|,
name|zfilter_op_defs
block|,
name|zgeneric_op_defs
block|,
name|zmath_op_defs
block|,
name|zmisc_op_defs
block|,
name|zpacked_op_defs
block|,
name|zprops_op_defs
block|,
name|zrelbit_op_defs
block|,
name|zstack_op_defs
block|,
name|zstring_op_defs
block|,
name|ztype_op_defs
block|,
name|zvmem_op_defs
block|,
comment|/* Graphics operators */
name|zchar_op_defs
block|,
name|zcolor_op_defs
block|,
name|zdevice_op_defs
block|,
name|zfont_op_defs
block|,
name|zfont1_op_defs
block|,
name|zfont2_op_defs
block|,
name|zgstate_op_defs
block|,
name|zht_op_defs
block|,
name|zmatrix_op_defs
block|,
name|zpaint_op_defs
block|,
name|zpath_op_defs
block|,
name|zpath2_op_defs
block|,
comment|/* end marker */
operator|(
name|op_def_ptr
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|oper_
end_undef

begin_undef
undef|#
directive|undef
name|device_
end_undef

begin_comment
comment|/* Run the initialization procedures of the individual operator files. */
end_comment

begin_function
name|void
name|zop_init
parameter_list|()
block|{
name|op_def_ptr
name|_ds
modifier|*
name|tptr
decl_stmt|;
name|op_def_ptr
name|def
decl_stmt|;
for|for
control|(
name|tptr
operator|=
name|op_defs_all
init|;
operator|*
name|tptr
operator|!=
literal|0
condition|;
name|tptr
operator|++
control|)
block|{
for|for
control|(
name|def
operator|=
operator|*
name|tptr
init|;
name|def
operator|->
name|oname
operator|!=
literal|0
condition|;
name|def
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|def
operator|->
name|proc
operator|!=
literal|0
condition|)
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P0
argument_list|()
argument_list|)
operator|)
operator|(
name|def
operator|->
name|proc
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the operator table. */
end_comment

begin_function
name|void
name|op_init
parameter_list|()
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
name|op_def_ptr
name|_ds
modifier|*
name|tptr
decl_stmt|;
name|op_def_ptr
name|def
decl_stmt|;
specifier|const
name|char
name|_ds
modifier|*
name|nstr
decl_stmt|;
comment|/* Do a first pass just to count the operators. */
for|for
control|(
name|tptr
operator|=
name|op_defs_all
init|;
operator|*
name|tptr
operator|!=
literal|0
condition|;
name|tptr
operator|++
control|)
for|for
control|(
name|def
operator|=
operator|*
name|tptr
init|;
name|def
operator|->
name|oname
operator|!=
literal|0
condition|;
name|count
operator|++
operator|,
name|def
operator|++
control|)
empty_stmt|;
comment|/* Do a second pass to construct the operator table, */
comment|/* and enter the operators in systemdict. */
name|op_def_table
operator|=
operator|(
name|op_def_ptr
operator|*
operator|)
name|alloc
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|op_def_ptr
argument_list|)
argument_list|,
literal|"op_init(op_def_table)"
argument_list|)
expr_stmt|;
name|op_def_count
operator|=
name|count
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|tptr
operator|=
name|op_defs_all
init|;
operator|*
name|tptr
operator|!=
literal|0
condition|;
name|tptr
operator|++
control|)
for|for
control|(
name|def
operator|=
operator|*
name|tptr
init|;
operator|(
name|nstr
operator|=
name|def
operator|->
name|oname
operator|)
operator|!=
literal|0
condition|;
name|count
operator|++
operator|,
name|def
operator|++
control|)
block|{
name|ref
name|nref
decl_stmt|,
name|oper
decl_stmt|;
name|make_oper
argument_list|(
operator|&
name|oper
argument_list|,
name|count
argument_list|,
call|(
name|dummy_op_proc_p
call|)
argument_list|(
name|def
operator|->
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|interp_fix_op
argument_list|(
operator|&
name|oper
argument_list|)
expr_stmt|;
comment|/* optimize if possible */
comment|/* The first character of the name is a digit */
comment|/* giving the minimum acceptable number of operands. */
comment|/* For now, we just skip over it. */
name|nstr
operator|++
expr_stmt|;
comment|/* Don't enter internal operators into systemdict. */
if|if
condition|(
operator|*
name|nstr
operator|==
literal|'%'
condition|)
name|name_enter
argument_list|(
name|nstr
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
else|else
name|initial_enter_name
argument_list|(
name|nstr
argument_list|,
operator|&
name|oper
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|oindex
operator|!=
literal|0
condition|)
operator|*
name|def
operator|->
name|oindex
operator|=
name|count
expr_stmt|;
name|op_def_table
index|[
name|count
index|]
operator|=
name|def
expr_stmt|;
block|}
comment|/* Allocate the table for `operator' procedures. */
block|{
name|ref
modifier|*
name|tbody
init|=
name|alloc_refs
argument_list|(
name|op_array_table_size
argument_list|,
literal|"op_array table"
argument_list|)
decl_stmt|;
name|make_tasv
argument_list|(
operator|&
name|op_array_table
argument_list|,
name|t_array
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|op_array_table_size
argument_list|,
name|refs
argument_list|,
name|tbody
argument_list|)
expr_stmt|;
name|refset_null
argument_list|(
name|tbody
argument_list|,
name|op_array_table_size
argument_list|)
expr_stmt|;
name|op_array_nx_table
operator|=
operator|(
name|ushort
operator|*
operator|)
name|alloc
argument_list|(
name|op_array_table_size
argument_list|,
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|,
literal|"op_array nx table"
argument_list|)
expr_stmt|;
name|op_array_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize variables that hold name constants. */
end_comment

begin_function
name|void
name|init_names
parameter_list|(
specifier|register
specifier|const
name|names_def
name|_ds
modifier|*
name|pnd
parameter_list|)
block|{
for|for
control|(
init|;
name|pnd
operator|->
name|vname
operator|!=
literal|0
condition|;
name|pnd
operator|++
control|)
name|name_enter
argument_list|(
name|pnd
operator|->
name|vname
argument_list|,
name|pnd
operator|->
name|pvref
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

