begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevbgi.c */
end_comment

begin_comment
comment|/* Ghostscript driver for Borland Graphics Interface (BGI) */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_include
include|#
directive|include
file|<graphics.h>
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BGI_LIB
end_ifndef

begin_comment
comment|/* may be set in makefile */
end_comment

begin_define
define|#
directive|define
name|BGI_LIB
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * BGI supports these video cards:  *   Hercules, CGA, MCGA, EGA, VGA, AT&T 400, IBM 8514, PC3270.  * Highest resolution mode is used with all these video cards.  * EGA and VGA display 16 colors, the rest are black-and-white only.  * In addition, the environment variable BGIUSER may be used  * to define a user-supplied Super VGA driver: see the use.doc file  * for details.  */
end_comment

begin_define
define|#
directive|define
name|SUPER_VGA
value|999
end_define

begin_comment
comment|/* bogus # for user-defined driver */
end_comment

begin_comment
comment|/* See gxdevice.h for the definitions of the procedures. */
end_comment

begin_expr_stmt
name|dev_proc_open_device
argument_list|(
name|bgi_open
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_close_device
argument_list|(
name|bgi_close
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_map_rgb_color
argument_list|(
name|bgi_map_rgb_color
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_map_color_rgb
argument_list|(
name|bgi_map_color_rgb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_fill_rectangle
argument_list|(
name|bgi_fill_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_tile_rectangle
argument_list|(
name|bgi_tile_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_copy_mono
argument_list|(
name|bgi_copy_mono
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_copy_color
argument_list|(
name|bgi_copy_color
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_draw_line
argument_list|(
name|bgi_draw_line
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The device descriptor */
end_comment

begin_typedef
typedef|typedef
name|struct
name|gx_device_bgi_s
name|gx_device_bgi
typedef|;
end_typedef

begin_struct
struct|struct
name|gx_device_bgi_s
block|{
name|gx_device_common
expr_stmt|;
name|int
name|display_mode
decl_stmt|;
name|struct
name|text_info
name|text_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|bgi_dev
value|((gx_device_bgi *)dev)
end_define

begin_decl_stmt
specifier|static
name|gx_device_procs
name|bgi_procs
init|=
block|{
name|bgi_open
block|,
name|gx_default_get_initial_matrix
block|,
name|gx_default_sync_output
block|,
name|gx_default_output_page
block|,
name|bgi_close
block|,
name|bgi_map_rgb_color
block|,
name|bgi_map_color_rgb
block|,
name|bgi_fill_rectangle
block|,
name|bgi_tile_rectangle
block|,
name|bgi_copy_mono
block|,
name|bgi_copy_color
block|,
name|bgi_draw_line
block|,
name|gx_default_get_bits
block|,
name|gx_default_get_props
block|,
name|gx_default_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_bgi
name|gs_bgi_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device_bgi
argument_list|)
block|,
operator|&
name|bgi_procs
block|,
literal|"bgi"
block|,
literal|0
block|,
literal|0
block|,
comment|/* width and height are set in bgi_open */
literal|0
block|,
literal|0
block|,
comment|/* density is set in bgi_open */
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|0
comment|/* not open yet */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Detection procedure for user-defined driver. */
end_comment

begin_function
name|private
name|int
name|huge
name|detectVGA
parameter_list|()
block|{
return|return
name|gs_bgi_device
operator|.
name|display_mode
return|;
block|}
end_function

begin_comment
comment|/* Open the BGI driver for graphics mode */
end_comment

begin_function
name|int
name|bgi_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|driver
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|bgi_user
init|=
name|getenv
argument_list|(
literal|"BGIUSER"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bgi_path
init|=
name|getenv
argument_list|(
literal|"BGIPATH"
argument_list|)
decl_stmt|;
name|gettextinfo
argument_list|(
operator|&
name|bgi_dev
operator|->
name|text_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgi_path
operator|==
name|NULL
condition|)
name|bgi_path
operator|=
name|BGI_LIB
expr_stmt|;
if|if
condition|(
name|bgi_user
operator|!=
name|NULL
condition|)
block|{
comment|/* A user-supplied driver is specified as "mode.dname", */
comment|/* where mode is a hex number and dname is the name */
comment|/* of the driver file. */
name|char
name|dname
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|bgi_user
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
operator|||
name|sscanf
argument_list|(
name|bgi_user
argument_list|,
literal|"%x.%s"
argument_list|,
operator|&
name|mode
argument_list|,
name|dname
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|eprintf
argument_list|(
literal|"BGIUSER not in form nn.dname.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gs_bgi_device
operator|.
name|display_mode
operator|=
name|mode
expr_stmt|;
comment|/* sigh.... */
name|installuserdriver
argument_list|(
name|dname
argument_list|,
name|detectVGA
argument_list|)
expr_stmt|;
name|driver
operator|=
name|DETECT
expr_stmt|;
name|initgraph
argument_list|(
operator|&
name|driver
argument_list|,
operator|&
name|mode
argument_list|,
name|bgi_path
argument_list|)
expr_stmt|;
name|driver
operator|=
name|SUPER_VGA
expr_stmt|;
block|}
else|else
comment|/* not user-defined driver */
block|{
comment|/* We include the CGA and Hercules drivers */
comment|/* in the Ghostscript executable, so end-users don't */
comment|/* have to have the BGI files. */
if|if
condition|(
name|registerbgidriver
argument_list|(
name|CGA_driver
argument_list|)
operator|<
literal|0
condition|)
block|{
name|eprintf
argument_list|(
literal|"BGI: Can't register CGA driver!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|registerbgidriver
argument_list|(
name|Herc_driver
argument_list|)
operator|<
literal|0
condition|)
block|{
name|eprintf
argument_list|(
literal|"BGI: Can't register Hercules driver!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|detectgraph
argument_list|(
operator|&
name|driver
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|driver
operator|<
literal|0
condition|)
block|{
name|eprintf
argument_list|(
literal|"BGI: No graphics hardware detected!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|driver
operator|==
name|EGA64
condition|)
block|{
comment|/* Select 16 color video mode if video card is EGA with 64 Kb of memory */
name|mode
operator|=
name|EGA64LO
expr_stmt|;
block|}
comment|/* Initialize graphics mode. */
comment|/* Following patch for AT&T 6300 is courtesy of */
comment|/* Allan Wax, Xerox Corp. */
if|if
condition|(
name|driver
operator|==
name|CGA
condition|)
block|{
comment|/* The actual hardware might be an AT&T 6300. */
comment|/* Try initializing it that way. */
name|int
name|save_mode
init|=
name|mode
decl_stmt|;
name|driver
operator|=
name|ATT400
operator|,
name|mode
operator|=
name|ATT400HI
expr_stmt|;
name|initgraph
argument_list|(
operator|&
name|driver
argument_list|,
operator|&
name|mode
argument_list|,
name|bgi_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|graphresult
argument_list|()
operator|!=
name|grOk
condition|)
block|{
comment|/* Nope, it was a real CGA. */
name|closegraph
argument_list|()
expr_stmt|;
name|driver
operator|=
name|CGA
operator|,
name|mode
operator|=
name|save_mode
expr_stmt|;
name|initgraph
argument_list|(
operator|&
name|driver
argument_list|,
operator|&
name|mode
argument_list|,
name|bgi_path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|initgraph
argument_list|(
operator|&
name|driver
argument_list|,
operator|&
name|mode
argument_list|,
name|bgi_path
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|code
init|=
name|graphresult
argument_list|()
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|grOk
condition|)
block|{
name|eprintf1
argument_list|(
literal|"Error initializing BGI driver: %s\n"
argument_list|,
name|grapherrormsg
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set parameters that were unknown before opening device */
comment|/* Size and nominal density of screen. */
comment|/* The following algorithm maps an appropriate fraction of */
comment|/* the display screen to an 8.5" x 11" coordinate space. */
comment|/* This may or may not be what is desired! */
name|dev
operator|->
name|width
operator|=
name|getmaxx
argument_list|()
operator|+
literal|1
expr_stmt|;
name|dev
operator|->
name|height
operator|=
name|getmaxy
argument_list|()
operator|+
literal|1
expr_stmt|;
name|dev
operator|->
name|y_pixels_per_inch
operator|=
name|dev
operator|->
name|height
operator|/
literal|11.0
expr_stmt|;
block|{
comment|/* Get the aspect ratio from the driver. */
name|int
name|arx
decl_stmt|,
name|ary
decl_stmt|;
name|getaspectratio
argument_list|(
operator|&
name|arx
argument_list|,
operator|&
name|ary
argument_list|)
expr_stmt|;
name|dev
operator|->
name|x_pixels_per_inch
operator|=
name|dev
operator|->
name|y_pixels_per_inch
operator|*
operator|(
operator|(
name|float
operator|)
name|ary
operator|/
name|arx
operator|)
expr_stmt|;
block|}
comment|/* Find out if the device supports color */
comment|/* (default initialization is monochrome). */
comment|/* We only recognize 16-color devices right now. */
if|if
condition|(
name|getmaxcolor
argument_list|()
operator|>
literal|1
condition|)
block|{
specifier|static
name|gx_device_color_info
name|bgi_16color
init|=
name|dci_color
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|dev
operator|->
name|color_info
operator|=
name|bgi_16color
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the BGI driver */
end_comment

begin_function
name|int
name|bgi_close
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|closegraph
argument_list|()
expr_stmt|;
name|textmode
argument_list|(
name|bgi_dev
operator|->
name|text_mode
operator|.
name|currmode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map a r-g-b color to the 16 colors available with an EGA/VGA video card. */
end_comment

begin_function
name|gx_color_index
name|bgi_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
return|return
call|(
name|gx_color_index
call|)
argument_list|(
operator|(
name|r
operator|>
name|gx_max_color_value
operator|/
literal|4
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|g
operator|>
name|gx_max_color_value
operator|/
literal|4
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|b
operator|>
name|gx_max_color_value
operator|/
literal|4
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|r
operator|>
name|gx_max_color_value
operator|/
literal|4
operator|*
literal|3
operator|||
name|g
operator|>
name|gx_max_color_value
operator|/
literal|4
operator|*
literal|3
condition|?
literal|8
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Map a color code to r-g-b.  Surprisingly enough, this is algorithmic. */
end_comment

begin_function
name|int
name|bgi_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
define|#
directive|define
name|icolor
value|(int)color
name|gx_color_value
name|one
init|=
operator|(
name|icolor
operator|&
literal|8
condition|?
name|gx_max_color_value
else|:
name|gx_max_color_value
operator|/
literal|3
operator|)
decl_stmt|;
name|prgb
index|[
literal|0
index|]
operator|=
operator|(
name|icolor
operator|&
literal|4
condition|?
name|one
else|:
literal|0
operator|)
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|(
name|icolor
operator|&
literal|2
condition|?
name|one
else|:
literal|0
operator|)
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|(
name|icolor
operator|&
literal|1
condition|?
name|one
else|:
literal|0
operator|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|icolor
block|}
end_function

begin_comment
comment|/* Copy a monochrome bitmap.  The colors are given explicitly. */
end_comment

begin_comment
comment|/* Color = gx_no_color_index means transparent (no effect on the image). */
end_comment

begin_function
name|int
name|bgi_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
block|{
name|byte
modifier|*
name|ptr_line
init|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|3
operator|)
decl_stmt|;
name|int
name|left_bit
init|=
literal|0x80
operator|>>
operator|(
name|sourcex
operator|&
literal|7
operator|)
decl_stmt|;
name|int
name|dest_y
init|=
name|y
decl_stmt|,
name|end_x
init|=
name|x
operator|+
name|w
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|int
name|color
decl_stmt|;
if|if
condition|(
name|zero
operator|==
name|gx_no_color_index
condition|)
block|{
if|if
condition|(
name|one
operator|==
name|gx_no_color_index
condition|)
return|return
literal|0
return|;
name|color
operator|=
operator|(
name|int
operator|)
name|one
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|one
operator|==
name|gx_no_color_index
condition|)
block|{
name|color
operator|=
operator|(
name|int
operator|)
name|zero
expr_stmt|;
name|invert
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Pre-clear the rectangle to zero */
name|setfillstyle
argument_list|(
name|SOLID_FILL
argument_list|,
operator|(
name|int
operator|)
name|zero
argument_list|)
expr_stmt|;
name|bar
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|w
operator|-
literal|1
argument_list|,
name|y
operator|+
name|h
operator|-
literal|1
argument_list|)
expr_stmt|;
name|color
operator|=
operator|(
name|int
operator|)
name|one
expr_stmt|;
block|}
block|}
while|while
condition|(
name|h
operator|--
condition|)
comment|/* for each line */
block|{
name|byte
modifier|*
name|ptr_source
init|=
name|ptr_line
decl_stmt|;
specifier|register
name|int
name|dest_x
init|=
name|x
decl_stmt|;
specifier|register
name|int
name|bit
init|=
name|left_bit
decl_stmt|;
while|while
condition|(
name|dest_x
operator|<
name|end_x
condition|)
comment|/* for each bit in the line */
block|{
if|if
condition|(
operator|(
operator|*
name|ptr_source
operator|^
name|invert
operator|)
operator|&
name|bit
condition|)
name|putpixel
argument_list|(
name|dest_x
argument_list|,
name|dest_y
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|dest_x
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bit
operator|>>=
literal|1
operator|)
operator|==
literal|0
condition|)
name|bit
operator|=
literal|0x80
operator|,
name|ptr_source
operator|++
expr_stmt|;
block|}
name|dest_y
operator|++
expr_stmt|;
name|ptr_line
operator|+=
name|raster
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a color pixel map.  This is just like a bitmap, except that */
end_comment

begin_comment
comment|/* each pixel takes 4 bits instead of 1 when device driver has color. */
end_comment

begin_function
name|int
name|bgi_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* color device, four bits per pixel */
name|byte
modifier|*
name|line
init|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|1
operator|)
decl_stmt|;
name|int
name|dest_y
init|=
name|y
decl_stmt|,
name|end_x
init|=
name|x
operator|+
name|w
decl_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|h
operator|--
condition|)
comment|/* for each line */
block|{
name|byte
modifier|*
name|source
init|=
name|line
decl_stmt|;
specifier|register
name|int
name|dest_x
init|=
name|x
decl_stmt|;
if|if
condition|(
name|sourcex
operator|&
literal|1
condition|)
comment|/* odd nibble first */
block|{
name|int
name|color
init|=
operator|*
name|source
operator|++
operator|&
literal|0xf
decl_stmt|;
name|putpixel
argument_list|(
name|dest_x
argument_list|,
name|dest_y
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|dest_x
operator|++
expr_stmt|;
block|}
comment|/* Now do full bytes */
while|while
condition|(
name|dest_x
operator|<
name|end_x
condition|)
block|{
name|int
name|color
init|=
operator|*
name|source
operator|>>
literal|4
decl_stmt|;
name|putpixel
argument_list|(
name|dest_x
argument_list|,
name|dest_y
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|dest_x
operator|++
expr_stmt|;
if|if
condition|(
name|dest_x
operator|<
name|end_x
condition|)
block|{
name|color
operator|=
operator|*
name|source
operator|++
operator|&
literal|0xf
expr_stmt|;
name|putpixel
argument_list|(
name|dest_x
argument_list|,
name|dest_y
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|dest_x
operator|++
expr_stmt|;
block|}
block|}
name|dest_y
operator|++
expr_stmt|;
name|line
operator|+=
name|raster
expr_stmt|;
block|}
block|}
else|else
comment|/* monochrome device: one bit per pixel */
block|{
comment|/* bitmap is the same as bgi_copy_mono: one bit per pixel */
name|bgi_copy_mono
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
operator|(
name|gx_color_index
operator|)
name|BLACK
argument_list|,
operator|(
name|gx_color_index
operator|)
name|WHITE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill a rectangle. */
end_comment

begin_function
name|int
name|bgi_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|setfillstyle
argument_list|(
name|SOLID_FILL
argument_list|,
operator|(
name|int
operator|)
name|color
argument_list|)
expr_stmt|;
name|bar
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|w
operator|-
literal|1
argument_list|,
name|y
operator|+
name|h
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tile a rectangle.  If neither color is transparent, */
end_comment

begin_comment
comment|/* pre-clear the rectangle to color0 and just tile with color1. */
end_comment

begin_comment
comment|/* This is faster because of how bgi_copy_mono is implemented. */
end_comment

begin_comment
comment|/* Note that this also does the right thing for colored tiles. */
end_comment

begin_function
name|int
name|bgi_tile_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|czero
parameter_list|,
name|gx_color_index
name|cone
parameter_list|,
name|int
name|px
parameter_list|,
name|int
name|py
parameter_list|)
block|{
if|if
condition|(
name|czero
operator|!=
name|gx_no_color_index
operator|&&
name|cone
operator|!=
name|gx_no_color_index
condition|)
block|{
name|bgi_fill_rectangle
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|czero
argument_list|)
expr_stmt|;
name|czero
operator|=
name|gx_no_color_index
expr_stmt|;
block|}
return|return
name|gx_default_tile_rectangle
argument_list|(
name|dev
argument_list|,
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|czero
argument_list|,
name|cone
argument_list|,
name|px
argument_list|,
name|py
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Draw a line */
end_comment

begin_function
name|int
name|bgi_draw_line
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|setcolor
argument_list|(
operator|(
name|int
operator|)
name|color
argument_list|)
expr_stmt|;
name|setlinestyle
argument_list|(
name|SOLID_LINE
argument_list|,
literal|0
argument_list|,
name|NORM_WIDTH
argument_list|)
expr_stmt|;
comment|/* solid, one pixel wide */
name|line
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

