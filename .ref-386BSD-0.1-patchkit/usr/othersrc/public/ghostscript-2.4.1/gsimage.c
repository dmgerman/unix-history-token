begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsimage.c */
end_comment

begin_comment
comment|/* Image procedures for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gspaint.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_comment
comment|/* requires gsstate.h */
end_comment

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_comment
comment|/* requires gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gxcpath.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_include
include|#
directive|include
file|"gximage.h"
end_include

begin_comment
comment|/* Exported size of enumerator */
end_comment

begin_decl_stmt
specifier|const
name|uint
name|gs_image_enum_sizeof
init|=
sizeof|sizeof
argument_list|(
name|gs_image_enum
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|int
name|image_init
argument_list|(
name|P9
argument_list|(
name|gs_image_enum
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|gs_matrix
operator|*
argument_list|,
name|gs_state
operator|*
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Procedures for unpacking the input data into 8 bits/sample. */
end_comment

begin_function_decl
name|private
name|void
name|image_unpack_1
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_1_spread
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_2
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_2_spread
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_4
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_8
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_8_spread
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|image_unpack_12
parameter_list|(
name|iunpack_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The image_render procedures work on fully expanded, complete rows. */
end_comment

begin_comment
comment|/* These take a height argument, which is an integer> 0; */
end_comment

begin_comment
comment|/* they return a negative code, or the number of */
end_comment

begin_comment
comment|/* rows actually processed (which may be less than the height). */
end_comment

begin_function_decl
name|private
name|int
name|image_render_skip
parameter_list|(
name|irender_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|int
name|image_render_direct
parameter_list|(
name|irender_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|int
name|image_render_mono
parameter_list|(
name|irender_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|int
name|image_render_color
parameter_list|(
name|irender_proc_args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set up a gs_color with a transfer-mapped gray sample. */
end_comment

begin_define
define|#
directive|define
name|image_set_rgb
parameter_list|(
name|rcolor
parameter_list|,
name|sample_value
parameter_list|)
define|\
value|rcolor.luminance = rcolor.red = rcolor.green = rcolor.blue =\     gx_map_color_param_byte(pgs, sample_value, gray)
end_define

begin_comment
comment|/* Mask tables for spreading input data. */
end_comment

begin_comment
comment|/* Note that the mask tables depend on the end-orientation of the CPU. */
end_comment

begin_comment
comment|/* We can't simply define them as byte arrays, because */
end_comment

begin_comment
comment|/* they might not wind up properly long- or short-aligned. */
end_comment

begin_define
define|#
directive|define
name|map4tox
parameter_list|(
name|z
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|z, z^a, z^b, z^(a+b),\ 	z^c, z^(a+c), z^(b+c), z^(a+b+c),\ 	z^d, z^(a+d), z^(b+d), z^(a+b+d),\ 	z^(c+d), z^(a+c+d), z^(b+c+d), z^(a+b+c+d)
end_define

begin_if
if|#
directive|if
name|arch_is_big_endian
end_if

begin_decl_stmt
name|private
name|unsigned
name|long
name|map_4_to_32
index|[
literal|16
index|]
init|=
block|{
name|map4tox
argument_list|(
literal|0L
argument_list|,
literal|0xffL
argument_list|,
literal|0xff00L
argument_list|,
literal|0xff0000L
argument_list|,
literal|0xff000000L
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|unsigned
name|long
name|map_4_to_32_invert
index|[
literal|16
index|]
init|=
block|{
name|map4tox
argument_list|(
literal|0xffffffffL
argument_list|,
literal|0xffL
argument_list|,
literal|0xff00L
argument_list|,
literal|0xff0000L
argument_list|,
literal|0xff000000L
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|unsigned
name|short
name|map_4_to_16
index|[
literal|16
index|]
init|=
block|{
name|map4tox
argument_list|(
literal|0
argument_list|,
literal|0x55
argument_list|,
literal|0xaa
argument_list|,
literal|0x5500
argument_list|,
literal|0xaa00
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !arch_is_big_endian */
end_comment

begin_decl_stmt
name|private
name|unsigned
name|long
name|map_4_to_32
index|[
literal|16
index|]
init|=
block|{
name|map4tox
argument_list|(
literal|0L
argument_list|,
literal|0xff000000L
argument_list|,
literal|0xff0000L
argument_list|,
literal|0xff00L
argument_list|,
literal|0xffL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|unsigned
name|long
name|map_4_to_32_invert
index|[
literal|16
index|]
init|=
block|{
name|map4tox
argument_list|(
literal|0xffffffffL
argument_list|,
literal|0xff000000L
argument_list|,
literal|0xff0000L
argument_list|,
literal|0xff00L
argument_list|,
literal|0xffL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|unsigned
name|short
name|map_4_to_16
index|[
literal|16
index|]
init|=
block|{
name|map4tox
argument_list|(
literal|0
argument_list|,
literal|0x5500
argument_list|,
literal|0xaa00
argument_list|,
literal|0x55
argument_list|,
literal|0xaa
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Start processing an image */
end_comment

begin_function
name|int
name|gs_image_init
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bps
parameter_list|,
name|int
name|spp
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
name|int
name|spread
decl_stmt|;
if|if
condition|(
name|pgs
operator|->
name|in_cachedevice
condition|)
name|return_error
argument_list|(
name|gs_error_undefined
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|spp
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
name|spread
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
literal|3
case|:
case|case
operator|-
literal|4
case|:
name|spp
operator|=
operator|-
name|spp
expr_stmt|;
name|spread
operator|=
name|spp
expr_stmt|;
break|break;
default|default:
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spp
operator|==
literal|1
condition|)
block|{
comment|/* Initialize the color table */
define|#
directive|define
name|chtl
parameter_list|(
name|i
parameter_list|)
define|\
value|penum->dev_colors[i].halftone_level
switch|switch
condition|(
name|bps
condition|)
block|{
default|default:
block|{
comment|/* Yes, clearing the entire table is slow, */
comment|/* but for 8 bit-per-sample images, it's worth it. */
specifier|register
name|gx_device_color
modifier|*
name|pcht
init|=
operator|&
name|penum
operator|->
name|dev_colors
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|64
decl_stmt|;
do|do
block|{
name|pcht
index|[
literal|0
index|]
operator|.
name|halftone_level
operator|=
name|pcht
index|[
literal|1
index|]
operator|.
name|halftone_level
operator|=
name|pcht
index|[
literal|2
index|]
operator|.
name|halftone_level
operator|=
name|pcht
index|[
literal|3
index|]
operator|.
name|halftone_level
operator|=
operator|-
literal|1
expr_stmt|;
name|pcht
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
do|;
break|break;
block|}
case|case
literal|4
case|:
name|chtl
argument_list|(
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|2
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|3
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|4
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|6
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|7
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|8
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|9
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|11
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|12
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|13
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|14
operator|*
literal|17
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* falls through */
case|case
literal|2
case|:
name|chtl
argument_list|(
literal|5
operator|*
literal|17
argument_list|)
operator|=
name|chtl
argument_list|(
literal|10
operator|*
literal|17
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
case|case
literal|1
case|:
empty_stmt|;
block|}
comment|/* Pre-map entries 0 and 255. */
block|{
name|gs_color
name|rcolor
decl_stmt|;
name|image_set_rgb
argument_list|(
name|rcolor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gx_color_render
argument_list|(
operator|&
name|rcolor
argument_list|,
operator|&
name|penum
operator|->
name|icolor0
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|image_set_rgb
argument_list|(
name|rcolor
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|gx_color_render
argument_list|(
operator|&
name|rcolor
argument_list|,
operator|&
name|penum
operator|->
name|icolor1
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|chtl
block|}
name|penum
operator|->
name|masked
operator|=
literal|0
expr_stmt|;
name|penum
operator|->
name|map4to32
operator|=
name|map_4_to_32
expr_stmt|;
return|return
name|image_init
argument_list|(
name|penum
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bps
argument_list|,
name|spp
argument_list|,
name|spread
argument_list|,
name|pmat
argument_list|,
name|pgs
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start processing a masked image */
end_comment

begin_function
name|int
name|gs_imagemask_init
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|invert
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|int
name|adjust
parameter_list|)
block|{
comment|/* Initialize color entries 0 and 255. */
name|penum
operator|->
name|icolor0
operator|.
name|halftone_level
operator|=
literal|0
expr_stmt|;
name|penum
operator|->
name|icolor0
operator|.
name|color1
operator|=
name|penum
operator|->
name|icolor0
operator|.
name|color2
operator|=
name|gx_no_color_index
expr_stmt|;
name|penum
operator|->
name|icolor1
operator|=
operator|*
name|pgs
operator|->
name|dev_color
expr_stmt|;
name|penum
operator|->
name|masked
operator|=
literal|1
expr_stmt|;
name|penum
operator|->
name|map4to32
operator|=
operator|(
name|invert
condition|?
name|map_4_to_32_invert
else|:
name|map_4_to_32
operator|)
expr_stmt|;
return|return
name|image_init
argument_list|(
name|penum
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pmat
argument_list|,
name|pgs
argument_list|,
operator|(
name|adjust
operator|&&
name|pgs
operator|->
name|in_cachedevice
condition|?
name|float2fixed
argument_list|(
literal|0.25
argument_list|)
else|:
operator|(
name|fixed
operator|)
literal|0
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Common setup for image and imagemask. */
end_comment

begin_comment
comment|/* Caller has set penum->masked, map4to32, dev_colors[]. */
end_comment

begin_function
name|private
name|int
name|image_init
parameter_list|(
specifier|register
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bps
parameter_list|,
name|int
name|spp
parameter_list|,
name|int
name|spread
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|fixed
name|adjust
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|int
name|index_bps
decl_stmt|;
name|gs_matrix
name|mat
decl_stmt|;
name|gs_fixed_rect
name|clip_box
decl_stmt|;
name|uint
name|bsize
init|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|*
name|spp
decl_stmt|;
comment|/* round up, +1 for end-of-run byte */
name|byte
modifier|*
name|buffer
decl_stmt|;
name|fixed
name|mtx
decl_stmt|,
name|mty
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bps
condition|)
block|{
case|case
literal|1
case|:
name|index_bps
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|index_bps
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|index_bps
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index_bps
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|index_bps
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* empty image */
if|if
condition|(
operator|(
name|code
operator|=
name|gs_matrix_invert
argument_list|(
name|pmat
argument_list|,
operator|&
name|mat
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_matrix_multiply
argument_list|(
operator|&
name|mat
argument_list|,
operator|&
name|ctm_only
argument_list|(
name|pgs
argument_list|)
argument_list|,
operator|&
name|mat
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|buffer
operator|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
literal|1
argument_list|,
name|bsize
argument_list|,
literal|"image buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|penum
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|penum
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|penum
operator|->
name|bps
operator|=
name|bps
expr_stmt|;
name|penum
operator|->
name|spp
operator|=
name|spp
expr_stmt|;
name|penum
operator|->
name|spread
operator|=
name|spread
expr_stmt|;
name|penum
operator|->
name|fxx
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|xx
argument_list|)
expr_stmt|;
name|penum
operator|->
name|fyy
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|yy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|penum
operator|->
name|skewed
operator|=
name|is_skewed
argument_list|(
operator|&
name|mat
argument_list|)
operator|)
condition|)
block|{
name|penum
operator|->
name|fxy
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|xy
argument_list|)
expr_stmt|;
name|penum
operator|->
name|fyx
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|yx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|penum
operator|->
name|fxy
operator|=
literal|0
expr_stmt|;
name|penum
operator|->
name|fyx
operator|=
literal|0
expr_stmt|;
block|}
name|penum
operator|->
name|xcur
operator|=
name|mtx
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|tx
argument_list|)
expr_stmt|;
name|penum
operator|->
name|ycur
operator|=
name|mty
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|ty
argument_list|)
expr_stmt|;
name|penum
operator|->
name|pgs
operator|=
name|pgs
expr_stmt|;
name|clip_box
operator|=
name|pgs
operator|->
name|clip_path
operator|->
name|path
operator|.
name|bbox
expr_stmt|;
comment|/* box is known to be up to date */
name|penum
operator|->
name|clip_box
operator|=
name|clip_box
expr_stmt|;
name|penum
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|penum
operator|->
name|buffer_size
operator|=
name|bsize
expr_stmt|;
name|penum
operator|->
name|bytes_per_row
operator|=
call|(
name|uint
call|)
argument_list|(
operator|(
operator|(
name|ulong
operator|)
name|width
operator|*
operator|(
name|bps
operator|*
name|spp
operator|)
operator|/
name|spread
operator|+
literal|7
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|penum
operator|->
name|slow_loop
operator|=
name|penum
operator|->
name|skewed
expr_stmt|;
comment|/* If all four extrema of the image fall within the clipping */
comment|/* rectangle, clipping is never required. */
block|{
name|gs_fixed_rect
name|cbox
decl_stmt|;
name|fixed
name|edx
init|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|xx
operator|*
name|width
argument_list|)
decl_stmt|;
name|fixed
name|edy
init|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|yy
operator|*
name|height
argument_list|)
decl_stmt|;
name|fixed
name|epx
decl_stmt|,
name|epy
decl_stmt|,
name|eqx
decl_stmt|,
name|eqy
decl_stmt|;
if|if
condition|(
name|edx
operator|<
literal|0
condition|)
name|epx
operator|=
name|edx
operator|,
name|eqx
operator|=
literal|0
expr_stmt|;
else|else
name|epx
operator|=
literal|0
operator|,
name|eqx
operator|=
name|edx
expr_stmt|;
if|if
condition|(
name|edy
operator|<
literal|0
condition|)
name|epy
operator|=
name|edy
operator|,
name|eqy
operator|=
literal|0
expr_stmt|;
else|else
name|epy
operator|=
literal|0
operator|,
name|eqy
operator|=
name|edy
expr_stmt|;
if|if
condition|(
name|penum
operator|->
name|skewed
condition|)
block|{
name|edx
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|yx
operator|*
name|height
argument_list|)
expr_stmt|;
name|edy
operator|=
name|float2fixed
argument_list|(
name|mat
operator|.
name|xy
operator|*
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|edx
operator|<
literal|0
condition|)
name|epx
operator|+=
name|edx
expr_stmt|;
else|else
name|eqx
operator|+=
name|edx
expr_stmt|;
if|if
condition|(
name|edy
operator|<
literal|0
condition|)
name|epy
operator|+=
name|edy
expr_stmt|;
else|else
name|eqy
operator|+=
name|edy
expr_stmt|;
block|}
name|gx_cpath_box_for_check
argument_list|(
name|pgs
operator|->
name|clip_path
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
name|penum
operator|->
name|never_clip
operator|=
name|mtx
operator|+
name|epx
operator|>=
name|cbox
operator|.
name|p
operator|.
name|x
operator|&&
name|mtx
operator|+
name|eqx
operator|<=
name|cbox
operator|.
name|q
operator|.
name|x
operator|&&
name|mty
operator|+
name|epy
operator|>=
name|cbox
operator|.
name|p
operator|.
name|y
operator|&&
name|mty
operator|+
name|eqy
operator|<=
name|cbox
operator|.
name|q
operator|.
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'b'
index|]
operator||
name|gs_debug
index|[
literal|'B'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[b]Image: cbox=(%g,%g),(%g,%g)\n"
argument_list|,
name|fixed2float
argument_list|(
name|cbox
operator|.
name|p
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|cbox
operator|.
name|p
operator|.
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|cbox
operator|.
name|q
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|cbox
operator|.
name|q
operator|.
name|y
argument_list|)
argument_list|)
operator|,
name|dprintf3
argument_list|(
literal|"     mt=(%g,%g) never_clip=%d\n"
argument_list|,
name|fixed2float
argument_list|(
name|mtx
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|mty
argument_list|)
argument_list|,
name|penum
operator|->
name|never_clip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|{
specifier|static
name|void
function_decl|(
modifier|*
name|procs
index|[
literal|5
index|]
function_decl|)
parameter_list|(
name|iunpack_proc_args
parameter_list|)
init|=
block|{
name|image_unpack_1
operator|,
function_decl|image_unpack_2
operator|,
function_decl|image_unpack_4
operator|,
function_decl|image_unpack_8
operator|,
function_decl|image_unpack_12
block|}
empty_stmt|;
specifier|static
name|void
function_decl|(
modifier|*
name|spread_procs
index|[
literal|5
index|]
function_decl|)
parameter_list|(
name|iunpack_proc_args
parameter_list|)
init|=
block|{
name|image_unpack_1_spread
operator|,
function_decl|image_unpack_2_spread
operator|,
function_decl|image_unpack_4
operator|,
function_decl|image_unpack_8_spread
operator|,
function_decl|image_unpack_12
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|penum
operator|->
name|slow_loop
operator||=
comment|/* Use slow loop for imagemask with a halftone */
operator|(
name|penum
operator|->
name|masked
operator|&&
operator|!
name|color_is_pure
argument_list|(
name|pgs
operator|->
name|dev_color
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pgs
operator|->
name|in_charpath
condition|)
name|penum
operator|->
name|render
operator|=
name|image_render_skip
expr_stmt|;
elseif|else
if|if
condition|(
name|spp
operator|==
literal|1
operator|&&
name|bps
operator|==
literal|1
operator|&&
operator|!
name|penum
operator|->
name|slow_loop
operator|&&
operator|(
name|fixed2long_rounded
argument_list|(
name|mtx
operator|+
name|width
operator|*
name|penum
operator|->
name|fxx
argument_list|)
operator|-
name|fixed2long_rounded
argument_list|(
name|mtx
argument_list|)
operator|==
name|width
operator|)
operator|&&
operator|(
name|penum
operator|->
name|masked
operator|||
name|color_is_pure
argument_list|(
operator|&
name|penum
operator|->
name|icolor0
argument_list|)
operator|)
condition|)
name|penum
operator|->
name|render
operator|=
name|image_render_direct
expr_stmt|;
else|else
name|penum
operator|->
name|render
operator|=
operator|(
name|spp
operator|==
literal|1
condition|?
name|image_render_mono
else|:
name|image_render_color
operator|)
expr_stmt|;
end_if

begin_comment
comment|/* The following should just be an assignment of */
end_comment

begin_comment
comment|/* a conditional expression, but the Ultrix C compiler */
end_comment

begin_comment
comment|/* can't handle it. */
end_comment

begin_if
if|if
condition|(
name|penum
operator|->
name|render
operator|==
name|image_render_direct
condition|)
block|{
name|penum
operator|->
name|unpack
operator|=
name|image_unpack_8
expr_stmt|;
comment|/* If the image is 1-for-1 with the device, */
comment|/* we don't want to spread the samples, */
comment|/* but we have to reset bps to prevent the buffer */
comment|/* pointer from being incremented by 8 bytes */
comment|/* per input byte. */
name|penum
operator|->
name|bps
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spread
operator|!=
literal|1
condition|)
name|penum
operator|->
name|unpack
operator|=
name|spread_procs
index|[
name|index_bps
index|]
expr_stmt|;
else|else
name|penum
operator|->
name|unpack
operator|=
name|procs
index|[
name|index_bps
index|]
expr_stmt|;
end_if

begin_expr_stmt
unit|} 	if
operator|(
operator|!
name|penum
operator|->
name|never_clip
operator|)
block|{
comment|/* Set up the clipping device. */
name|gx_device
operator|*
name|dev
operator|=
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|penum
operator|->
name|clip_dev
block|;
name|penum
operator|->
name|clip_dev
operator|=
name|gs_clip_device
block|;
name|penum
operator|->
name|clip_dev
operator|.
name|target
operator|=
name|gs_currentdevice
argument_list|(
name|pgs
argument_list|)
block|;
name|penum
operator|->
name|clip_dev
operator|.
name|list
operator|=
name|pgs
operator|->
name|clip_path
operator|->
name|list
block|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
name|dev
argument_list|)
block|; 	   }
name|penum
operator|->
name|adjust
operator|=
name|adjust
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|penum
operator|->
name|plane_index
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|penum
operator|->
name|byte_in_row
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|penum
operator|->
name|y
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|gs_debug
index|[
literal|'b'
index|]
operator||
name|gs_debug
index|[
literal|'B'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[b]Image: w=%d h=%d %s\n"
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
operator|(
name|penum
operator|->
name|never_clip
condition|?
literal|"no clip"
else|:
literal|"must clip"
operator|)
argument_list|)
operator|,
name|dprintf6
argument_list|(
literal|"   [%f %f %f %f %f %f]\n"
argument_list|,
name|mat
operator|.
name|xx
argument_list|,
name|mat
operator|.
name|xy
argument_list|,
name|mat
operator|.
name|yx
argument_list|,
name|mat
operator|.
name|yy
argument_list|,
name|mat
operator|.
name|tx
argument_list|,
name|mat
operator|.
name|ty
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
literal|0
return|;
end_return

begin_comment
unit|}
comment|/* Process the next piece of an image */
end_comment

begin_macro
unit|int
name|gs_image_next
argument_list|(
argument|register gs_image_enum *penum
argument_list|,
argument|byte *dbytes
argument_list|,
argument|uint dsize
argument_list|)
end_macro

begin_block
block|{
name|uint
name|rsize
init|=
name|penum
operator|->
name|bytes_per_row
decl_stmt|;
name|uint
name|pos
init|=
name|penum
operator|->
name|byte_in_row
decl_stmt|;
name|int
name|width
init|=
name|penum
operator|->
name|width
decl_stmt|;
name|uint
name|dleft
init|=
name|dsize
decl_stmt|;
name|uint
name|dpos
init|=
literal|0
decl_stmt|;
name|gs_state
modifier|*
name|pgs
init|=
name|penum
operator|->
name|pgs
decl_stmt|;
name|gx_device
modifier|*
name|save_dev
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Accumulate separated colors, if needed */
if|if
condition|(
name|penum
operator|->
name|plane_index
operator|==
literal|0
condition|)
name|penum
operator|->
name|plane_size
operator|=
name|dsize
expr_stmt|;
elseif|else
if|if
condition|(
name|dsize
operator|!=
name|penum
operator|->
name|plane_size
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
name|penum
operator|->
name|planes
index|[
name|penum
operator|->
name|plane_index
index|]
operator|=
name|dbytes
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|penum
operator|->
name|plane_index
operator|)
operator|!=
name|penum
operator|->
name|spread
condition|)
return|return
literal|0
return|;
name|penum
operator|->
name|plane_index
operator|=
literal|0
expr_stmt|;
comment|/* We've accumulated an entire set of planes. */
if|if
condition|(
operator|!
name|penum
operator|->
name|never_clip
condition|)
block|{
comment|/* Install the clipping device if needed. */
name|gx_device
modifier|*
name|dev
init|=
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|penum
operator|->
name|clip_dev
decl_stmt|;
name|save_dev
operator|=
name|gs_currentdevice
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
name|penum
operator|->
name|clip_dev
operator|.
name|target
operator|=
name|save_dev
expr_stmt|;
name|gx_set_device_only
argument_list|(
name|pgs
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|dleft
condition|)
block|{
comment|/* Fill up a row, then display it. */
name|uint
name|bcount
init|=
name|min
argument_list|(
name|dleft
argument_list|,
name|rsize
operator|-
name|pos
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|bptr
init|=
name|penum
operator|->
name|buffer
operator|+
operator|(
name|pos
operator|<<
literal|3
operator|)
operator|/
name|penum
operator|->
name|bps
operator|*
name|penum
operator|->
name|spread
decl_stmt|;
name|int
name|px
decl_stmt|;
for|for
control|(
name|px
operator|=
literal|0
init|;
name|px
operator|<
name|penum
operator|->
name|spread
condition|;
name|px
operator|++
control|)
call|(
modifier|*
name|penum
operator|->
name|unpack
call|)
argument_list|(
name|penum
argument_list|,
name|bptr
operator|+
name|px
argument_list|,
name|penum
operator|->
name|planes
index|[
name|px
index|]
operator|+
name|dpos
argument_list|,
name|bcount
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|bcount
expr_stmt|;
name|dpos
operator|+=
name|bcount
expr_stmt|;
name|dleft
operator|-=
name|bcount
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|rsize
condition|)
comment|/* filled an entire row */
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'B'
index|]
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|width
operator|*
name|penum
operator|->
name|spp
decl_stmt|;
name|dputs
argument_list|(
literal|"[B]row:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|dprintf1
argument_list|(
literal|" %02x"
argument_list|,
name|penum
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dputs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|penum
operator|->
name|skewed
condition|)
block|{
comment|/* Precompute integer y and height, */
comment|/* and check for clipping. */
name|fixed
name|yc
init|=
name|penum
operator|->
name|ycur
decl_stmt|,
name|yn
decl_stmt|;
name|fixed
name|dyy
init|=
name|penum
operator|->
name|fyy
decl_stmt|;
name|fixed
name|adjust
init|=
name|penum
operator|->
name|adjust
decl_stmt|;
if|if
condition|(
name|dyy
operator|>
literal|0
condition|)
name|dyy
operator|+=
name|adjust
operator|<<
literal|1
operator|,
name|yc
operator|-=
name|adjust
expr_stmt|;
else|else
name|dyy
operator|=
operator|(
name|adjust
operator|<<
literal|1
operator|)
operator|-
name|dyy
operator|,
name|yc
operator|-=
name|dyy
operator|-
name|adjust
expr_stmt|;
if|if
condition|(
name|yc
operator|>=
name|penum
operator|->
name|clip_box
operator|.
name|q
operator|.
name|y
condition|)
goto|goto
name|mt
goto|;
name|yn
operator|=
name|yc
operator|+
name|dyy
expr_stmt|;
if|if
condition|(
name|yn
operator|<=
name|penum
operator|->
name|clip_box
operator|.
name|p
operator|.
name|y
condition|)
goto|goto
name|mt
goto|;
name|penum
operator|->
name|yci
operator|=
name|fixed2int_var_rounded
argument_list|(
name|yc
argument_list|)
expr_stmt|;
name|penum
operator|->
name|hci
operator|=
name|fixed2int_var_rounded
argument_list|(
name|yn
argument_list|)
operator|-
name|penum
operator|->
name|yci
expr_stmt|;
if|if
condition|(
name|penum
operator|->
name|hci
operator|==
literal|0
condition|)
goto|goto
name|mt
goto|;
block|}
name|code
operator|=
call|(
modifier|*
name|penum
operator|->
name|render
call|)
argument_list|(
name|penum
argument_list|,
name|penum
operator|->
name|buffer
argument_list|,
name|width
operator|*
name|penum
operator|->
name|spp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|mt
label|:
if|if
condition|(
operator|++
operator|(
name|penum
operator|->
name|y
operator|)
operator|==
name|penum
operator|->
name|height
condition|)
goto|goto
name|end
goto|;
name|pos
operator|=
literal|0
expr_stmt|;
name|penum
operator|->
name|xcur
operator|+=
name|penum
operator|->
name|fyx
expr_stmt|;
name|penum
operator|->
name|ycur
operator|+=
name|penum
operator|->
name|fyy
expr_stmt|;
block|}
block|}
name|penum
operator|->
name|byte_in_row
operator|=
name|pos
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
name|end
label|:
comment|/* End of data */
name|code
operator|=
literal|1
expr_stmt|;
comment|/* falls through */
name|err
label|:
comment|/* Error, abort */
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
operator|->
name|buffer
argument_list|,
name|penum
operator|->
name|buffer_size
argument_list|,
literal|1
argument_list|,
literal|"image buffer"
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|save_dev
operator|!=
literal|0
condition|)
name|gx_set_device_only
argument_list|(
name|pgs
argument_list|,
name|save_dev
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_block

begin_comment
comment|/* ------ Unpacking procedures ------ */
end_comment

begin_function
name|private
name|void
name|image_unpack_1
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|bptr
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
modifier|*
name|bufp
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|bptr
decl_stmt|;
name|int
name|left
init|=
name|dsize
decl_stmt|;
specifier|register
name|unsigned
name|long
name|_ds
modifier|*
name|map
init|=
name|penum
operator|->
name|map4to32
decl_stmt|;
comment|/* may invert */
while|while
condition|(
name|left
operator|--
condition|)
block|{
specifier|register
name|unsigned
name|b
init|=
operator|*
name|data
operator|++
decl_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|map
index|[
name|b
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|map
index|[
name|b
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_1_spread
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
specifier|register
name|byte
modifier|*
name|bufp
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|int
name|spread
init|=
name|penum
operator|->
name|spread
decl_stmt|;
name|int
name|left
init|=
name|dsize
decl_stmt|;
while|while
condition|(
name|left
operator|--
condition|)
block|{
specifier|register
name|unsigned
name|b
init|=
operator|*
name|data
operator|++
decl_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
name|b
operator|>>
literal|7
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
operator|(
name|b
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
operator|(
name|b
operator|>>
literal|5
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
operator|(
name|b
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
operator|(
name|b
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
operator|(
name|b
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|-
operator|(
name|b
operator|&
literal|1
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_2
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|bptr
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|unsigned
name|short
modifier|*
name|bufp
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|bptr
decl_stmt|;
name|int
name|left
init|=
name|dsize
decl_stmt|;
specifier|register
name|unsigned
name|short
name|_ds
modifier|*
name|map
init|=
name|map_4_to_16
decl_stmt|;
while|while
condition|(
name|left
operator|--
condition|)
block|{
specifier|register
name|unsigned
name|b
init|=
operator|*
name|data
operator|++
decl_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|map
index|[
name|b
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|map
index|[
name|b
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_2_spread
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
specifier|register
name|byte
modifier|*
name|bufp
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|int
name|spread
init|=
name|penum
operator|->
name|spread
decl_stmt|;
name|int
name|left
init|=
name|dsize
decl_stmt|;
specifier|static
name|byte
name|map_2_to_8
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xff
block|}
decl_stmt|;
specifier|register
name|byte
name|_ds
modifier|*
name|map
init|=
name|map_2_to_8
decl_stmt|;
while|while
condition|(
name|left
operator|--
condition|)
block|{
specifier|register
name|unsigned
name|b
init|=
operator|*
name|data
operator|++
decl_stmt|;
operator|*
name|bufp
operator|=
name|map
index|[
name|b
operator|>>
literal|6
index|]
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
name|map
index|[
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
name|map
index|[
operator|(
name|b
operator|>>
literal|2
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
name|map
index|[
name|b
operator|&
literal|3
index|]
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_4
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
specifier|register
name|byte
modifier|*
name|bufp
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|int
name|spread
init|=
name|penum
operator|->
name|spread
decl_stmt|;
name|int
name|left
init|=
name|dsize
decl_stmt|;
while|while
condition|(
name|left
operator|--
condition|)
block|{
specifier|register
name|unsigned
name|b
init|=
operator|*
name|data
operator|++
decl_stmt|;
operator|*
name|bufp
operator|=
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|+
operator|(
name|b
operator|>>
literal|4
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
name|b
operator|&=
literal|0xf
expr_stmt|;
operator|*
name|bufp
operator|=
operator|(
name|b
operator|<<
literal|4
operator|)
operator|+
name|b
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_8
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|bufp
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
if|if
condition|(
name|data
operator|!=
name|bufp
condition|)
name|memcpy
argument_list|(
name|bufp
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_8_spread
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
specifier|register
name|byte
modifier|*
name|bufp
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|int
name|spread
init|=
name|penum
operator|->
name|spread
decl_stmt|;
specifier|register
name|int
name|left
init|=
name|dsize
decl_stmt|;
while|while
condition|(
name|left
operator|--
condition|)
block|{
operator|*
name|bufp
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|image_unpack_12
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
specifier|register
name|byte
modifier|*
name|bufp
parameter_list|,
specifier|register
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|dsize
parameter_list|,
name|uint
name|inpos
parameter_list|)
block|{
specifier|register
name|int
name|spread
init|=
name|penum
operator|->
name|spread
decl_stmt|;
specifier|register
name|int
name|left
init|=
name|dsize
decl_stmt|;
comment|/* We have to deal with the 3 cases of inpos % 3 separately. */
comment|/* (In fact, this is the only reason inpos is passed to */
comment|/* the unpacking procedures at all.) */
comment|/* Let N = inpos / 3. */
switch|switch
condition|(
name|inpos
operator|%
literal|3
condition|)
block|{
case|case
literal|1
case|:
comment|/* bufp points to byte 2N, which was already filled */
comment|/* with the leftover byte from the previous call. */
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|*
name|data
operator|++
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|left
condition|)
return|return;
case|case
literal|2
case|:
comment|/* bufp points to byte 2N+1, which was half-filled */
comment|/* with the second leftover byte from the previous call. */
operator|*
name|bufp
operator|+=
operator|*
name|data
operator|++
operator|>>
literal|4
expr_stmt|;
operator|--
name|left
expr_stmt|;
case|case
literal|0
case|:
comment|/* Nothing special to do. */
empty_stmt|;
block|}
comment|/* Just drop the low 4 bits of each 12. */
while|while
condition|(
name|left
operator|>=
literal|3
condition|)
block|{
operator|*
name|bufp
operator|=
operator|*
name|data
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
operator|*
name|bufp
operator|=
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|4
operator|)
operator|+
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
name|bufp
operator|+=
name|spread
expr_stmt|;
name|data
operator|+=
literal|3
expr_stmt|;
block|}
switch|switch
condition|(
name|left
condition|)
block|{
case|case
literal|2
case|:
comment|/* dddddddd xxxxdddd */
name|bufp
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|<<
literal|4
expr_stmt|;
case|case
literal|1
case|:
comment|/* dddddddd */
operator|*
name|bufp
operator|=
operator|*
name|data
expr_stmt|;
case|case
literal|0
case|:
comment|/* Nothing more to do. */
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Rendering procedures ------ */
end_comment

begin_comment
comment|/* Rendering procedure for ignoring an image.  We still need to iterate */
end_comment

begin_comment
comment|/* over the samples, because the procedure might have side effects. */
end_comment

begin_function
name|private
name|int
name|image_render_skip
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Rendering procedure for a 1-bit-per-pixel sampled image */
end_comment

begin_comment
comment|/* with no skewing/rotation or X scaling. */
end_comment

begin_comment
comment|/* In this case a direct BitBlt is possible. */
end_comment

begin_function
name|private
name|int
name|image_render_direct
parameter_list|(
specifier|register
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|ix
init|=
name|fixed2int_var_rounded
argument_list|(
name|penum
operator|->
name|xcur
argument_list|)
decl_stmt|,
name|iw
init|=
name|w
decl_stmt|;
name|int
name|iy
init|=
name|penum
operator|->
name|yci
decl_stmt|,
name|ih
init|=
name|penum
operator|->
name|hci
decl_stmt|;
name|uint
name|raster
init|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|gx_device
modifier|*
name|dev
init|=
name|penum
operator|->
name|pgs
operator|->
name|device
operator|->
name|info
decl_stmt|;
name|dev_proc_copy_mono
argument_list|(
operator|(
operator|*
name|copy_mono
operator|)
argument_list|)
operator|=
name|dev
operator|->
name|procs
operator|->
name|copy_mono
expr_stmt|;
name|gx_color_index
name|zero
init|=
name|penum
operator|->
name|icolor0
operator|.
name|color1
decl_stmt|,
name|one
init|=
name|penum
operator|->
name|icolor1
operator|.
name|color1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'b'
index|]
operator||
name|gs_debug
index|[
literal|'B'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[b]direct (%d,%d),(%d,%d)\n"
argument_list|,
name|ix
argument_list|,
name|iy
argument_list|,
name|iw
argument_list|,
name|ih
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for inverted imagemask */
if|if
condition|(
name|penum
operator|->
name|map4to32
operator|==
name|map_4_to_32_invert
condition|)
name|zero
operator|=
name|penum
operator|->
name|icolor1
operator|.
name|color1
operator|,
name|one
operator|=
name|penum
operator|->
name|icolor0
operator|.
name|color1
expr_stmt|;
if|if
condition|(
name|ih
operator|==
literal|1
operator|&&
name|h
operator|==
literal|1
operator|&&
name|penum
operator|->
name|fyy
operator|>=
literal|0
condition|)
block|{
comment|/* We can do the whole thing at once. */
call|(
modifier|*
name|copy_mono
call|)
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|ix
argument_list|,
name|iy
argument_list|,
name|iw
argument_list|,
name|ih
argument_list|,
name|zero
argument_list|,
name|one
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
else|else
block|{
comment|/* Do just one row, clipping if necessary. */
name|int
name|dy
decl_stmt|;
for|for
control|(
name|dy
operator|=
literal|0
init|;
name|dy
operator|<
name|ih
condition|;
name|dy
operator|++
control|)
call|(
modifier|*
name|copy_mono
call|)
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|ix
argument_list|,
name|iy
operator|+
name|dy
argument_list|,
name|iw
argument_list|,
literal|1
argument_list|,
name|zero
argument_list|,
name|one
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Rendering procedure for the general case of displaying a */
end_comment

begin_comment
comment|/* monochrome image, dealing with multiple bit-per-sample images, */
end_comment

begin_comment
comment|/* bits not 1-for-1 with the device, and general transformations. */
end_comment

begin_comment
comment|/* This procedure handles a single scan line. */
end_comment

begin_function
name|private
name|int
name|image_render_mono
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|buffer
parameter_list|,
name|uint
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|gs_state
modifier|*
name|pgs
init|=
name|penum
operator|->
name|pgs
decl_stmt|;
specifier|const
name|int
name|masked
init|=
name|penum
operator|->
name|masked
decl_stmt|;
specifier|const
name|fixed
name|dxx
init|=
name|penum
operator|->
name|fxx
decl_stmt|;
name|fixed
name|xt
init|=
name|penum
operator|->
name|xcur
decl_stmt|;
name|gs_color
name|rcolor
decl_stmt|;
name|gx_device_color
modifier|*
name|pdevc
init|=
name|pgs
operator|->
name|dev_color
decl_stmt|;
comment|/* Make sure the cache setup matches the graphics state. */
comment|/* Also determine whether all tiles fit in the cache. */
name|int
name|tiles_fit
init|=
name|gx_check_tile_cache
argument_list|(
name|pgs
argument_list|)
decl_stmt|;
define|#
directive|define
name|image_set_gray
parameter_list|(
name|sample_value
parameter_list|)
define|\
value|{ pdevc =&penum->dev_colors[sample_value];\      switch ( pdevc->halftone_level )\       { default:
comment|/* halftone */
value|\ 	  if ( !tiles_fit ) gx_color_load(pdevc, pgs); break;\         case -1:
comment|/* not computed yet */
value|\ 	  image_set_rgb(rcolor, sample_value);\ 	  gx_color_render(&rcolor, pdevc, pgs);\ 	case 0: ;
comment|/* pure color */
value|\       }\    }
name|fixed
name|xl
init|=
name|xt
decl_stmt|;
name|byte
modifier|*
name|psrc
init|=
name|buffer
decl_stmt|;
name|byte
modifier|*
name|endp
init|=
name|buffer
operator|+
name|w
decl_stmt|;
name|fixed
name|xrun
init|=
name|xt
decl_stmt|;
comment|/* x at start of run */
name|int
name|run
init|=
operator|*
name|psrc
decl_stmt|;
comment|/* run value */
name|int
name|htrun
init|=
comment|/* halftone run value */
operator|(
name|masked
condition|?
literal|255
else|:
operator|-
literal|2
operator|)
decl_stmt|;
operator|*
name|endp
operator|=
operator|~
name|endp
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* force end of run */
name|gx_set_gray_only
argument_list|(
operator|&
name|rcolor
argument_list|,
operator|(
name|color_param
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|penum
operator|->
name|slow_loop
condition|)
block|{
comment|/* Skewed, or imagemask with a halftone. */
specifier|const
name|fixed
name|dxy
init|=
name|penum
operator|->
name|fxy
decl_stmt|,
name|dyx
init|=
name|penum
operator|->
name|fyx
decl_stmt|,
name|dyy
init|=
name|penum
operator|->
name|fyy
decl_stmt|;
name|fixed
name|ytf
init|=
name|penum
operator|->
name|ycur
decl_stmt|;
name|fixed
name|yrun
init|=
name|ytf
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|psrc
operator|++
operator|!=
name|run
condition|)
block|{
comment|/* Fill the region between xrun and xl. */
if|if
condition|(
name|run
operator|!=
name|htrun
condition|)
block|{
if|if
condition|(
name|run
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|masked
condition|)
goto|goto
name|trans
goto|;
block|}
name|htrun
operator|=
name|run
expr_stmt|;
name|image_set_gray
argument_list|(
name|run
argument_list|)
expr_stmt|;
block|}
name|gz_fill_pgram_fixed
argument_list|(
name|xrun
argument_list|,
name|yrun
argument_list|,
name|xl
operator|-
name|xrun
argument_list|,
name|ytf
operator|-
name|yrun
argument_list|,
name|dyx
argument_list|,
name|dyy
argument_list|,
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|trans
label|:
if|if
condition|(
name|psrc
operator|>
name|endp
condition|)
break|break;
name|yrun
operator|=
name|ytf
expr_stmt|;
name|xrun
operator|=
name|xl
expr_stmt|;
name|run
operator|=
name|psrc
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|xl
operator|+=
name|dxx
expr_stmt|;
name|ytf
operator|+=
name|dxy
expr_stmt|;
comment|/* harmless if no skew */
block|}
block|}
else|else
comment|/* fast loop */
block|{
comment|/* No skew, and not imagemask with a halftone. */
specifier|const
name|fixed
name|adjust
init|=
name|penum
operator|->
name|adjust
decl_stmt|;
name|fixed
name|xa
init|=
operator|(
name|dxx
operator|>=
literal|0
condition|?
name|adjust
else|:
operator|-
name|adjust
operator|)
decl_stmt|;
specifier|const
name|int
name|yt
init|=
name|penum
operator|->
name|yci
decl_stmt|,
name|iht
init|=
name|penum
operator|->
name|hci
decl_stmt|;
name|gx_device
modifier|*
name|dev
init|=
name|pgs
operator|->
name|device
operator|->
name|info
decl_stmt|;
name|dev_proc_fill_rectangle
argument_list|(
operator|(
operator|*
name|fill_proc
operator|)
argument_list|)
operator|=
name|dev
operator|->
name|procs
operator|->
name|fill_rectangle
expr_stmt|;
name|dev_proc_tile_rectangle
argument_list|(
operator|(
operator|*
name|tile_proc
operator|)
argument_list|)
operator|=
name|dev
operator|->
name|procs
operator|->
name|tile_rectangle
expr_stmt|;
name|dev_proc_copy_mono
argument_list|(
operator|(
operator|*
name|copy_mono_proc
operator|)
argument_list|)
operator|=
name|dev
operator|->
name|procs
operator|->
name|copy_mono
expr_stmt|;
name|dev_proc_copy_color
argument_list|(
operator|(
operator|*
name|copy_color_proc
operator|)
argument_list|)
operator|=
name|dev
operator|->
name|procs
operator|->
name|copy_color
expr_stmt|;
comment|/* If each pixel is likely to fit in a single halftone tile, */
comment|/* determine that now (tile_offset = offset of row within tile). */
name|int
name|tile_offset
init|=
name|gx_check_tile_size
argument_list|(
name|pgs
argument_list|,
name|fixed2int_rounded
argument_list|(
name|any_abs
argument_list|(
name|dxx
argument_list|)
operator|+
operator|(
name|xa
operator|<<
literal|1
operator|)
argument_list|)
argument_list|,
name|yt
argument_list|,
name|iht
argument_list|)
decl_stmt|;
comment|/* Fold the adjustment into xrun and xl, */
comment|/* including the +0.5 for rounding. */
name|xrun
operator|=
name|xrun
operator|-
name|xa
operator|+
name|float2fixed
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|xl
operator|=
name|xl
operator|+
name|xa
operator|+
name|float2fixed
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|xa
operator|<<=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|psrc
operator|++
operator|!=
name|run
condition|)
block|{
comment|/* Fill the region between xrun and xl. */
name|int
name|xi
init|=
name|fixed2int_var
argument_list|(
name|xrun
argument_list|)
decl_stmt|;
name|int
name|wi
init|=
name|fixed2int_var
argument_list|(
name|xl
argument_list|)
operator|-
name|xi
decl_stmt|;
name|int
name|tsx
decl_stmt|,
name|code
decl_stmt|;
name|gx_bitmap
modifier|*
name|tile
decl_stmt|;
if|if
condition|(
name|wi
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|wi
operator|==
literal|0
condition|)
goto|goto
name|mt
goto|;
name|xi
operator|+=
name|wi
operator|,
name|wi
operator|=
operator|-
name|wi
expr_stmt|;
block|}
switch|switch
condition|(
name|run
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|masked
condition|)
goto|goto
name|mt
goto|;
if|if
condition|(
operator|!
name|color_is_pure
argument_list|(
operator|&
name|penum
operator|->
name|icolor0
argument_list|)
condition|)
goto|goto
name|ht
goto|;
name|code
operator|=
call|(
modifier|*
name|fill_proc
call|)
argument_list|(
name|dev
argument_list|,
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|,
name|penum
operator|->
name|icolor0
operator|.
name|color1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|255
case|:
comment|/* just for speed */
if|if
condition|(
operator|!
name|color_is_pure
argument_list|(
operator|&
name|penum
operator|->
name|icolor1
argument_list|)
condition|)
goto|goto
name|ht
goto|;
name|code
operator|=
call|(
modifier|*
name|fill_proc
call|)
argument_list|(
name|dev
argument_list|,
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|,
name|penum
operator|->
name|icolor1
operator|.
name|color1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ht
label|:
comment|/* Use halftone if needed */
if|if
condition|(
name|run
operator|!=
name|htrun
condition|)
block|{
name|image_set_gray
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|htrun
operator|=
name|run
expr_stmt|;
block|}
comment|/* We open-code gz_fill_rectangle_open, */
comment|/* because we've done some of the work for */
comment|/* halftone tiles in advance. */
if|if
condition|(
name|color_is_pure
argument_list|(
name|pdevc
argument_list|)
condition|)
block|{
name|code
operator|=
call|(
modifier|*
name|fill_proc
call|)
argument_list|(
name|dev
argument_list|,
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|,
name|pdevc
operator|->
name|color1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tile_offset
operator|>=
literal|0
operator|&&
operator|(
name|tile
operator|=
name|pdevc
operator|->
name|tile
operator|,
operator|(
name|tsx
operator|=
operator|(
name|xi
operator|+
name|pgs
operator|->
name|phase_mod
operator|.
name|x
operator|)
operator|%
name|tile
operator|->
name|rep_width
operator|)
operator|+
name|wi
operator|<=
name|tile
operator|->
name|size
operator|.
name|x
operator|)
condition|)
block|{
comment|/* The pixel(s) fit(s) in a single tile. */
name|byte
modifier|*
name|row
init|=
name|tile
operator|->
name|data
operator|+
name|tile_offset
decl_stmt|;
name|code
operator|=
operator|(
name|color_is_color_halftone
argument_list|(
name|pdevc
argument_list|)
condition|?
call|(
modifier|*
name|copy_color_proc
call|)
argument_list|(
name|dev
argument_list|,
name|row
argument_list|,
name|tsx
argument_list|,
name|tile
operator|->
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|)
else|:
call|(
modifier|*
name|copy_mono_proc
call|)
argument_list|(
name|dev
argument_list|,
name|row
argument_list|,
name|tsx
argument_list|,
name|tile
operator|->
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|,
name|pdevc
operator|->
name|color1
argument_list|,
name|pdevc
operator|->
name|color2
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
call|(
modifier|*
name|tile_proc
call|)
argument_list|(
name|dev
argument_list|,
name|pdevc
operator|->
name|tile
argument_list|,
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|,
name|pdevc
operator|->
name|color1
argument_list|,
name|pdevc
operator|->
name|color2
argument_list|,
name|pgs
operator|->
name|phase_mod
operator|.
name|x
argument_list|,
name|pgs
operator|->
name|phase_mod
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|mt
label|:
if|if
condition|(
name|psrc
operator|>
name|endp
condition|)
break|break;
name|xrun
operator|=
name|xl
operator|-
name|xa
expr_stmt|;
comment|/* original xa<< 1 */
name|run
operator|=
name|psrc
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|xl
operator|+=
name|dxx
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Rendering procedure for handling color images. */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
struct|struct
block|{
name|byte
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|skip
decl_stmt|;
block|}
name|v
struct|;
name|ulong
name|all
decl_stmt|;
block|}
name|color_sample
typedef|;
end_typedef

begin_function
name|private
name|int
name|image_render_color
parameter_list|(
name|gs_image_enum
modifier|*
name|penum
parameter_list|,
name|byte
modifier|*
name|buffer
parameter_list|,
name|uint
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|gs_state
modifier|*
name|pgs
init|=
name|penum
operator|->
name|pgs
decl_stmt|;
name|fixed
name|dxx
init|=
name|penum
operator|->
name|fxx
decl_stmt|,
name|dxy
init|=
name|penum
operator|->
name|fxy
decl_stmt|,
name|dyx
init|=
name|penum
operator|->
name|fyx
decl_stmt|,
name|dyy
init|=
name|penum
operator|->
name|fyy
decl_stmt|;
name|int
name|skew
init|=
name|penum
operator|->
name|skewed
decl_stmt|;
name|fixed
name|xt
init|=
name|penum
operator|->
name|xcur
decl_stmt|;
name|fixed
name|ytf
init|=
name|penum
operator|->
name|ycur
decl_stmt|;
name|int
name|yt
init|=
name|penum
operator|->
name|yci
decl_stmt|,
name|iht
init|=
name|penum
operator|->
name|hci
decl_stmt|;
name|gs_color
name|rcolor
decl_stmt|;
name|gx_device_color
name|devc1
decl_stmt|,
name|devc2
decl_stmt|;
name|gx_device_color
name|_ss
modifier|*
name|spdevc
init|=
operator|&
name|devc1
decl_stmt|;
name|gx_device_color
name|_ss
modifier|*
name|spdevc_next
init|=
operator|&
name|devc2
decl_stmt|;
define|#
directive|define
name|pdevc
value|(gx_device_color *)spdevc
define|#
directive|define
name|pdevc_next
value|(gx_device_color *)spdevc_next
name|int
name|spp
init|=
name|penum
operator|->
name|spp
decl_stmt|;
name|fixed
name|xl
init|=
name|xt
decl_stmt|;
name|byte
modifier|*
name|psrc
init|=
name|buffer
decl_stmt|;
name|fixed
name|xrun
init|=
name|xt
decl_stmt|;
comment|/* x at start of run */
name|int
name|irun
init|=
name|fixed2int_var_rounded
argument_list|(
name|xrun
argument_list|)
decl_stmt|;
comment|/* int xrun */
name|fixed
name|yrun
init|=
name|ytf
decl_stmt|;
comment|/* y ditto */
name|color_sample
name|run
decl_stmt|;
comment|/* run value */
name|color_sample
name|next
decl_stmt|;
comment|/* next sample value */
name|byte
modifier|*
name|bufend
init|=
name|buffer
operator|+
name|w
decl_stmt|;
name|bufend
index|[
literal|0
index|]
operator|=
operator|~
name|bufend
index|[
operator|-
name|spp
index|]
expr_stmt|;
comment|/* force end of run */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'b'
index|]
operator||
name|gs_debug
index|[
literal|'B'
index|]
condition|)
name|dprintf5
argument_list|(
literal|"[b]y=%d w=%d xt=%f yt=%f yb=%f\n"
argument_list|,
name|penum
operator|->
name|y
argument_list|,
name|w
argument_list|,
name|fixed2float
argument_list|(
name|xt
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ytf
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ytf
operator|+
name|dyy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|run
operator|.
name|all
operator|=
literal|0
expr_stmt|;
name|next
operator|.
name|all
operator|=
literal|0
expr_stmt|;
name|rcolor
operator|.
name|red
operator|=
name|rcolor
operator|.
name|green
operator|=
name|rcolor
operator|.
name|blue
operator|=
literal|0
expr_stmt|;
name|gx_color_from_rgb
argument_list|(
operator|&
name|rcolor
argument_list|)
expr_stmt|;
name|gx_color_render
argument_list|(
operator|&
name|rcolor
argument_list|,
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
while|while
condition|(
name|psrc
operator|<=
name|bufend
condition|)
comment|/* 1 extra iteration */
comment|/* to handle final run */
block|{
if|if
condition|(
name|spp
operator|==
literal|4
condition|)
comment|/* cmyk */
block|{
switch|switch
condition|(
name|psrc
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* no black */
name|next
operator|.
name|v
operator|.
name|r
operator|=
operator|~
name|psrc
index|[
literal|0
index|]
expr_stmt|;
name|next
operator|.
name|v
operator|.
name|g
operator|=
operator|~
name|psrc
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|.
name|v
operator|.
name|b
operator|=
operator|~
name|psrc
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
comment|/* all black */
name|next
operator|.
name|v
operator|.
name|r
operator|=
name|next
operator|.
name|v
operator|.
name|g
operator|=
name|next
operator|.
name|v
operator|.
name|b
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
block|{
name|uint
name|black
init|=
literal|0xff
operator|-
name|psrc
index|[
literal|3
index|]
decl_stmt|;
comment|/* The following is equivalent to */
comment|/* v * black / 0xff, without the divide. */
specifier|register
name|uint
name|temp
decl_stmt|;
define|#
directive|define
name|deduct_black
parameter_list|(
name|v
parameter_list|)
define|\
value|(temp = (v) * black, (temp + (temp>> 8) + 1)>> 8)
name|next
operator|.
name|v
operator|.
name|r
operator|=
name|deduct_black
argument_list|(
literal|0xff
operator|-
name|psrc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|next
operator|.
name|v
operator|.
name|g
operator|=
name|deduct_black
argument_list|(
literal|0xff
operator|-
name|psrc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|next
operator|.
name|v
operator|.
name|b
operator|=
name|deduct_black
argument_list|(
literal|0xff
operator|-
name|psrc
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|deduct_black
block|}
block|}
name|psrc
operator|+=
literal|4
expr_stmt|;
block|}
else|else
comment|/* rgb */
block|{
name|next
operator|.
name|v
operator|.
name|r
operator|=
name|psrc
index|[
literal|0
index|]
expr_stmt|;
name|next
operator|.
name|v
operator|.
name|g
operator|=
name|psrc
index|[
literal|1
index|]
expr_stmt|;
name|next
operator|.
name|v
operator|.
name|b
operator|=
name|psrc
index|[
literal|2
index|]
expr_stmt|;
name|psrc
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|.
name|all
operator|!=
name|run
operator|.
name|all
condition|)
block|{
name|rcolor
operator|.
name|red
operator|=
name|gx_map_color_param_byte
argument_list|(
name|pgs
argument_list|,
name|next
operator|.
name|v
operator|.
name|r
argument_list|,
name|red
argument_list|)
expr_stmt|;
name|rcolor
operator|.
name|green
operator|=
name|gx_map_color_param_byte
argument_list|(
name|pgs
argument_list|,
name|next
operator|.
name|v
operator|.
name|g
argument_list|,
name|green
argument_list|)
expr_stmt|;
name|rcolor
operator|.
name|blue
operator|=
name|gx_map_color_param_byte
argument_list|(
name|pgs
argument_list|,
name|next
operator|.
name|v
operator|.
name|b
argument_list|,
name|blue
argument_list|)
expr_stmt|;
name|gx_color_from_rgb
argument_list|(
operator|&
name|rcolor
argument_list|)
expr_stmt|;
name|gx_color_render
argument_list|(
operator|&
name|rcolor
argument_list|,
name|pdevc_next
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
comment|/* Even though the supplied colors don't match, */
comment|/* the device colors might. */
if|if
condition|(
name|devc1
operator|.
name|color1
operator|!=
name|devc2
operator|.
name|color1
operator|||
name|devc1
operator|.
name|halftone_level
operator|!=
name|devc2
operator|.
name|halftone_level
operator|||
operator|(
name|devc1
operator|.
name|halftone_level
operator|&&
name|devc1
operator|.
name|color2
operator|!=
name|devc2
operator|.
name|color2
operator|)
operator|||
name|psrc
operator|>
name|bufend
comment|/* force end of last run */
condition|)
block|{
comment|/* Fill the region between */
comment|/* xrun/irun and xl */
name|gx_device_color
name|_ss
modifier|*
name|sptemp
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|skew
condition|)
block|{
comment|/* Parallelogram */
name|code
operator|=
name|gz_fill_pgram_fixed
argument_list|(
name|xrun
argument_list|,
name|yrun
argument_list|,
name|xl
operator|-
name|xrun
argument_list|,
name|ytf
operator|-
name|yrun
argument_list|,
name|dyx
argument_list|,
name|dyy
argument_list|,
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|xrun
operator|=
name|xl
expr_stmt|;
name|yrun
operator|=
name|ytf
expr_stmt|;
block|}
else|else
block|{
comment|/* Rectangle */
name|int
name|xi
init|=
name|irun
decl_stmt|;
name|int
name|wi
init|=
operator|(
name|irun
operator|=
name|fixed2int_var_rounded
argument_list|(
name|xl
argument_list|)
operator|)
operator|-
name|xi
decl_stmt|;
if|if
condition|(
name|wi
operator|<
literal|0
condition|)
name|xi
operator|+=
name|wi
operator|,
name|wi
operator|=
operator|-
name|wi
expr_stmt|;
name|code
operator|=
name|gz_fill_rectangle
argument_list|(
name|xi
argument_list|,
name|yt
argument_list|,
name|wi
argument_list|,
name|iht
argument_list|,
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|sptemp
operator|=
name|spdevc
expr_stmt|;
name|spdevc
operator|=
name|spdevc_next
expr_stmt|;
name|spdevc_next
operator|=
name|sptemp
expr_stmt|;
block|}
name|run
operator|.
name|all
operator|=
name|next
operator|.
name|all
expr_stmt|;
block|}
name|xl
operator|+=
name|dxx
expr_stmt|;
name|ytf
operator|+=
name|dxy
expr_stmt|;
comment|/* harmless if no skew */
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

