begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zcontext.c */
end_comment

begin_comment
comment|/* Display PostScript context operators */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/****** THIS FILE IS NOT IN GOOD ENOUGH SHAPE TO USE YET. ******/
end_comment

begin_comment
comment|/* Procedure hooks in interp.c */
end_comment

begin_extern
extern|extern int (*gs_interp_reschedule_proc
end_extern

begin_expr_stmt
unit|)
operator|(
name|P0
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*gs_interp_time_slice_proc
end_extern

begin_expr_stmt
unit|)
operator|(
name|P0
argument_list|()
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Context structure */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|cs_invalid
block|,
name|cs_active
block|,
name|cs_done
block|}
name|ctx_status
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|gs_context_s
block|{
name|ctx_status
name|status
decl_stmt|;
name|long
name|index
decl_stmt|;
name|int
name|detach
decl_stmt|;
comment|/* true if a detach has been */
comment|/* executed for this context */
name|struct
name|gs_context_s
modifier|*
name|next
decl_stmt|;
comment|/* next context with same status */
comment|/* (active, waiting on same lock, */
comment|/* waiting on same condition) */
name|struct
name|gs_context_s
modifier|*
name|joiner
decl_stmt|;
comment|/* context waiting on a join */
comment|/* for this one */
name|struct
name|gs_context_s
modifier|*
name|table_next
decl_stmt|;
comment|/* hash table chain */
comment|/* Externally visible context state */
name|ref
modifier|*
name|stacks
decl_stmt|;
define|#
directive|define
name|default_stacksize
value|50
name|uint
name|stacksize
decl_stmt|;
name|uint
name|ossize
decl_stmt|;
name|uint
name|essize
decl_stmt|;
name|uint
name|dssize
decl_stmt|;
name|gs_state
modifier|*
name|pgs
decl_stmt|;
name|int_gstate
name|istate
decl_stmt|;
comment|/****** MORE STUFF HERE ******/
block|}
name|gs_context
typedef|;
end_typedef

begin_comment
comment|/* Context list structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ctx_list_s
block|{
name|gs_context
modifier|*
name|head
decl_stmt|;
name|gs_context
modifier|*
name|tail
decl_stmt|;
block|}
name|ctx_list
typedef|;
end_typedef

begin_comment
comment|/* Condition structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gs_condition_s
block|{
name|ctx_list
name|waiting
decl_stmt|;
comment|/* contexts waiting on this condition */
block|}
name|gs_condition
typedef|;
end_typedef

begin_comment
comment|/* Lock structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gs_lock_s
block|{
name|ctx_list
name|waiting
decl_stmt|;
comment|/* contexts waiting for this lock */
name|gs_context
modifier|*
name|holder
decl_stmt|;
comment|/* context holding the lock, if any */
block|}
name|gs_lock
typedef|;
end_typedef

begin_comment
comment|/* Global state */
end_comment

begin_decl_stmt
name|private
name|gs_context
modifier|*
name|ctx_current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ctx_list
name|active
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ctx_table_size
value|19
end_define

begin_decl_stmt
name|private
name|gs_context
modifier|*
name|ctx_table
index|[
name|ctx_table_size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|ctx_next_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|context_create
argument_list|(
name|P2
argument_list|(
name|uint
argument_list|,
name|gs_context
operator|*
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|context_param
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|gs_context
operator|*
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|check_context
parameter_list|(
name|op
parameter_list|,
name|vpc
parameter_list|)
define|\
value|if ( (code = context_param(op,&vpc))< 0 ) return code
end_define

begin_decl_stmt
name|private
name|void
name|context_destroy
argument_list|(
name|P1
argument_list|(
name|gs_context
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|lock_acquire
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|lock_release
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List manipulation macros */
end_comment

begin_define
define|#
directive|define
name|add_last
parameter_list|(
name|pl
parameter_list|,
name|pc
parameter_list|)
define|\
value|(((pl)->head == 0 ? ((pl)->head = pc) : ((pl)->tail->next = pc)),\    (pl)->tail = pc, (pc)->next = 0)
end_define

begin_define
define|#
directive|define
name|add_last_all
parameter_list|(
name|pl
parameter_list|,
name|pcl
parameter_list|)
comment|/* pcl->head != 0 */
define|\
value|(((pl)->head == 0 ? ((pl)->head = (pcl)->head) :\     ((pl)->tail->next = (pcl)->head)),\    (pl)->tail = (pcl)->tail, (pcl)->head = 0)
end_define

begin_comment
comment|/* ------ Initialization ------ */
end_comment

begin_decl_stmt
name|private
name|int
name|ctx_reschedule
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|ctx_time_slice
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|zcontext_init
parameter_list|()
block|{
name|ctx_current
operator|=
literal|0
expr_stmt|;
name|active
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|ctx_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx_table
argument_list|)
argument_list|)
expr_stmt|;
name|ctx_next_index
operator|=
literal|1
expr_stmt|;
comment|/* Create an initial context. */
name|context_create
argument_list|(
name|default_stacksize
argument_list|,
operator|&
name|ctx_current
argument_list|)
expr_stmt|;
comment|/* Hook into the interpreter. */
name|gs_interp_reschedule_proc
operator|=
name|ctx_reschedule
expr_stmt|;
name|gs_interp_time_slice_proc
operator|=
name|ctx_time_slice
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Interpreter interface to scheduler ------ */
end_comment

begin_comment
comment|/* When an operator decides it is time to run a new context, */
end_comment

begin_comment
comment|/* it returns o_reschedule.  The interpreter saves all its state in */
end_comment

begin_comment
comment|/* memory, calls ctx_reschedule, and then loads the state from memory. */
end_comment

begin_function
name|private
name|int
name|ctx_reschedule
parameter_list|()
block|{
specifier|register
name|gs_context
modifier|*
name|pctx
decl_stmt|;
name|ref
modifier|*
name|stkp
decl_stmt|;
name|uint
name|ossize
decl_stmt|,
name|essize
decl_stmt|,
name|dssize
decl_stmt|;
comment|/* Save the state of the current context in ctx_current, */
comment|/* if any context is current at all. */
name|pctx
operator|=
name|ctx_current
expr_stmt|;
if|if
condition|(
name|pctx
operator|!=
literal|0
condition|)
block|{
name|uint
name|stackneed
decl_stmt|;
name|ref
modifier|*
name|newstacks
decl_stmt|;
name|ossize
operator|=
name|osp
operator|-
name|osbot
operator|+
literal|1
expr_stmt|;
name|essize
operator|=
name|esp
operator|-
name|esbot
operator|+
literal|1
expr_stmt|;
name|dssize
operator|=
name|dsp
operator|-
name|dstack
operator|+
literal|1
expr_stmt|;
name|stackneed
operator|=
name|ossize
operator|+
name|essize
operator|+
name|dssize
expr_stmt|;
if|if
condition|(
name|stackneed
operator|>
name|pctx
operator|->
name|stacksize
condition|)
block|{
name|alloc_free_refs
argument_list|(
name|pctx
operator|->
name|stacks
argument_list|,
name|pctx
operator|->
name|stacksize
argument_list|,
literal|"ctx_reschedule"
argument_list|)
expr_stmt|;
name|newstacks
operator|=
name|alloc_refs
argument_list|(
name|stackneed
argument_list|,
literal|"ctx_reschedule"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstacks
operator|==
literal|0
condition|)
block|{
comment|/* Punt. */
name|lprintf
argument_list|(
literal|"Can't allocate stacks!"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pctx
operator|->
name|stacksize
operator|=
name|stackneed
expr_stmt|;
name|pctx
operator|->
name|stacks
operator|=
name|newstacks
expr_stmt|;
block|}
name|stkp
operator|=
name|pctx
operator|->
name|stacks
expr_stmt|;
define|#
directive|define
name|save_stack
parameter_list|(
name|sbot
parameter_list|,
name|ssize
parameter_list|)
define|\
value|memcpy(stkp, sbot, ssize * sizeof(ref));\   pctx->ssize = ssize;\   stkp += ssize
name|save_stack
argument_list|(
name|osbot
argument_list|,
name|ossize
argument_list|)
expr_stmt|;
name|save_stack
argument_list|(
name|esbot
argument_list|,
name|essize
argument_list|)
expr_stmt|;
name|save_stack
argument_list|(
name|dstack
argument_list|,
name|dssize
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|save_stack
name|pctx
operator|->
name|pgs
operator|=
name|igs
expr_stmt|;
name|pctx
operator|->
name|istate
operator|=
name|istate
expr_stmt|;
comment|/****** MORE TO DO HERE ******/
block|}
comment|/* Run the first ready context. */
if|if
condition|(
name|active
operator|.
name|head
operator|==
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"No context to run!"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ctx_current
operator|=
name|active
operator|.
name|head
expr_stmt|;
name|active
operator|.
name|head
operator|=
name|active
operator|.
name|head
operator|->
name|next
expr_stmt|;
comment|/* Load the state of the new current context. */
name|pctx
operator|=
name|ctx_current
expr_stmt|;
name|stkp
operator|=
name|pctx
operator|->
name|stacks
expr_stmt|;
define|#
directive|define
name|reload_stack
parameter_list|(
name|sbot
parameter_list|,
name|ssize
parameter_list|,
name|sp
parameter_list|)
define|\
value|ssize = pctx->ssize;\   memcpy(sbot, stkp, ssize * sizeof(ref));\   sp = sbot + (ssize - 1);\   stkp += ssize
name|reload_stack
argument_list|(
name|osbot
argument_list|,
name|ossize
argument_list|,
name|osp
argument_list|)
expr_stmt|;
name|reload_stack
argument_list|(
name|esbot
argument_list|,
name|essize
argument_list|,
name|esp
argument_list|)
expr_stmt|;
name|esfile
operator|=
literal|0
expr_stmt|;
name|reload_stack
argument_list|(
name|dstack
argument_list|,
name|dssize
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|reload_stack
name|igs
operator|=
name|pctx
operator|->
name|pgs
expr_stmt|;
name|istate
operator|=
name|pctx
operator|->
name|istate
expr_stmt|;
comment|/****** MORE TO DO HERE ******/
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the interpreter wants to time-slice, it saves its state, */
end_comment

begin_comment
comment|/* calls ctx_time_slice, and reloads its state. */
end_comment

begin_function
name|private
name|int
name|ctx_time_slice
parameter_list|()
block|{
if|if
condition|(
name|active
operator|.
name|head
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_last
argument_list|(
operator|&
name|active
argument_list|,
name|ctx_current
argument_list|)
expr_stmt|;
return|return
name|ctx_reschedule
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* ------ Context operators ------ */
end_comment

begin_decl_stmt
name|private
name|int
name|fork_done
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_fork_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* currentcontext */
end_comment

begin_function
name|int
name|zcurrentcontext
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|ctx_current
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* detach */
end_comment

begin_function
name|int
name|zdetach
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_context
modifier|*
name|pctx
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_context
argument_list|(
name|op
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|joiner
operator|!=
literal|0
operator|||
name|pctx
operator|->
name|detach
condition|)
return|return
name|e_invalidcontext
return|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pctx
operator|->
name|status
condition|)
block|{
case|case
name|cs_active
case|:
name|pctx
operator|->
name|detach
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|cs_done
case|:
name|context_destroy
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|==
name|ctx_current
condition|)
block|{
name|ctx_current
operator|=
literal|0
expr_stmt|;
return|return
name|o_reschedule
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* fork */
end_comment

begin_function
name|int
name|zfork
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|mp
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|gs_context
modifier|*
name|pctx
decl_stmt|;
name|uint
name|ossize
decl_stmt|,
name|essize
decl_stmt|,
name|dssize
decl_stmt|,
name|stacksize
decl_stmt|;
name|int
name|code
decl_stmt|;
name|ref
modifier|*
name|stkp
decl_stmt|;
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|r_has_type
argument_list|(
name|mp
argument_list|,
name|t_mark
argument_list|)
condition|)
block|{
if|if
condition|(
name|mp
operator|<=
name|osbot
condition|)
return|return
name|e_unmatchedmark
return|;
name|mp
operator|--
expr_stmt|;
block|}
name|ossize
operator|=
name|op
operator|-
name|mp
operator|-
literal|1
expr_stmt|;
name|essize
operator|=
literal|2
expr_stmt|;
name|dssize
operator|=
name|dsp
operator|-
name|dstack
operator|+
literal|1
expr_stmt|;
name|stacksize
operator|=
name|ossize
operator|+
name|essize
operator|+
name|dssize
operator|+
literal|10
expr_stmt|;
name|code
operator|=
name|context_create
argument_list|(
name|stacksize
argument_list|,
operator|&
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|stkp
operator|=
name|pctx
operator|->
name|stacks
expr_stmt|;
name|pctx
operator|->
name|ossize
operator|=
name|ossize
expr_stmt|;
name|memcpy
argument_list|(
name|stkp
argument_list|,
name|mp
operator|+
literal|1
argument_list|,
name|ossize
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|stkp
operator|+=
name|ossize
expr_stmt|;
name|pctx
operator|->
name|essize
operator|=
name|essize
expr_stmt|;
name|make_oper
argument_list|(
name|stkp
argument_list|,
name|i_fork_done
argument_list|,
name|fork_done
argument_list|)
expr_stmt|;
name|stkp
operator|++
expr_stmt|;
operator|*
name|stkp
operator|=
operator|*
name|op
expr_stmt|;
name|stkp
operator|++
expr_stmt|;
name|pctx
operator|->
name|dssize
operator|=
name|dssize
expr_stmt|;
name|memcpy
argument_list|(
name|stkp
argument_list|,
name|dstack
argument_list|,
name|dssize
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|pgs
operator|=
name|igs
expr_stmt|;
comment|/* ****** WRONG, MUST COPY ****** */
name|pctx
operator|->
name|istate
operator|=
name|istate
expr_stmt|;
comment|/****** MORE INIT HERE? ******/
name|add_last
argument_list|(
operator|&
name|active
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|osp
operator|=
name|mp
expr_stmt|;
name|make_int
argument_list|(
name|mp
argument_list|,
name|pctx
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This gets executed when a context terminates normally. */
end_comment

begin_comment
comment|/****** HOW TO GET IT EXECUTED ON ERROR TERMINATION? ******/
end_comment

begin_function
name|private
name|int
name|fork_done
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
if|if
condition|(
name|ctx_current
operator|->
name|detach
condition|)
block|{
name|context_destroy
argument_list|(
name|ctx_current
argument_list|)
expr_stmt|;
name|ctx_current
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|gs_context
modifier|*
name|pctx
init|=
name|ctx_current
operator|->
name|joiner
decl_stmt|;
name|ctx_current
operator|->
name|status
operator|=
name|cs_done
expr_stmt|;
comment|/* Schedule the context waiting to join this one, if any. */
if|if
condition|(
name|pctx
operator|!=
literal|0
condition|)
name|add_last
argument_list|(
operator|&
name|active
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
block|}
return|return
name|o_reschedule
return|;
block|}
end_function

begin_comment
comment|/* join */
end_comment

begin_function
name|int
name|zjoin
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_context
modifier|*
name|pctx
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_context
argument_list|(
name|op
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|joiner
operator|!=
literal|0
operator|||
name|pctx
operator|==
name|ctx_current
operator|||
name|pctx
operator|->
name|detach
condition|)
return|return
name|e_invalidcontext
return|;
switch|switch
condition|(
name|pctx
operator|->
name|status
condition|)
block|{
case|case
name|cs_active
case|:
name|pctx
operator|->
name|joiner
operator|=
name|ctx_current
expr_stmt|;
return|return
name|o_reschedule
return|;
case|case
name|cs_done
case|:
block|{
name|uint
name|count
init|=
name|pctx
operator|->
name|ossize
decl_stmt|;
name|os_ptr
name|mp
init|=
name|op
decl_stmt|;
name|push
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|make_mark
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|++
name|mp
argument_list|,
name|pctx
operator|->
name|stacks
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|context_destroy
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* yield */
end_comment

begin_function
name|int
name|zyield
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
if|if
condition|(
name|active
operator|.
name|head
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_last
argument_list|(
operator|&
name|active
argument_list|,
name|ctx_current
argument_list|)
expr_stmt|;
return|return
name|o_reschedule
return|;
block|}
end_function

begin_comment
comment|/* ------ Condition and lock operators ------ */
end_comment

begin_decl_stmt
name|private
name|int
name|i_monitor
decl_stmt|,
name|monitor_release
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_monitor_release
decl_stmt|,
name|await_lock
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_await_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* condition */
end_comment

begin_function
name|int
name|zcondition
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_condition
modifier|*
name|pcond
init|=
operator|(
name|gs_condition
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_condition
argument_list|)
argument_list|,
literal|"zcondition"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcond
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|pcond
operator|->
name|waiting
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_tv
argument_list|(
name|op
argument_list|,
name|t_condition
argument_list|,
name|pcond
argument_list|,
name|pcond
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* lock */
end_comment

begin_function
name|int
name|zlock
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_lock
modifier|*
name|plock
init|=
operator|(
name|gs_lock
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_lock
argument_list|)
argument_list|,
literal|"zlock"
argument_list|)
decl_stmt|;
if|if
condition|(
name|plock
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|plock
operator|->
name|holder
operator|=
literal|0
expr_stmt|;
name|plock
operator|->
name|waiting
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_tv
argument_list|(
name|op
argument_list|,
name|t_lock
argument_list|,
name|plock
argument_list|,
name|plock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* monitor */
end_comment

begin_function
name|int
name|zmonitor
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_lock
modifier|*
name|plock
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_lock
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|plock
operator|=
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|plock
expr_stmt|;
name|check_estack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|plock
operator|->
name|holder
operator|==
name|ctx_current
condition|)
return|return
name|e_invalidcontext
return|;
name|code
operator|=
name|lock_acquire
argument_list|(
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/****** HOW TO GUARANTEE RELEASE IF CONTEXT DIES? ******/
name|push_op_estack
argument_list|(
name|monitor_release
argument_list|,
name|i_monitor_release
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Release the monitor lock when the procedure completes. */
end_comment

begin_function
name|private
name|int
name|monitor_release
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|ep
init|=
name|esp
operator|--
decl_stmt|;
return|return
name|lock_release
argument_list|(
name|ep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* notify */
end_comment

begin_function
name|int
name|znotify
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_condition
modifier|*
name|pcond
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_condition
argument_list|)
expr_stmt|;
name|pcond
operator|=
name|op
operator|->
name|value
operator|.
name|pcond
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|op
operator|--
expr_stmt|;
if|if
condition|(
name|pcond
operator|->
name|waiting
operator|.
name|head
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* nothing to do */
name|add_last_all
argument_list|(
operator|&
name|active
argument_list|,
operator|&
name|pcond
operator|->
name|waiting
argument_list|)
expr_stmt|;
return|return
name|zyield
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* wait */
end_comment

begin_function
name|int
name|zwait
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_condition
modifier|*
name|pcond
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_lock
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_condition
argument_list|)
expr_stmt|;
name|pcond
operator|=
name|op
operator|->
name|value
operator|.
name|pcond
expr_stmt|;
name|check_estack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lock_release
argument_list|(
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|add_last
argument_list|(
operator|&
name|pcond
operator|->
name|waiting
argument_list|,
name|ctx_current
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|await_lock
argument_list|,
name|i_await_lock
argument_list|)
expr_stmt|;
return|return
name|o_reschedule
return|;
block|}
end_function

begin_comment
comment|/* When the condition is signaled, wait for acquiring the lock. */
end_comment

begin_function
name|private
name|int
name|await_lock
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|lock_acquire
argument_list|(
name|op
operator|-
literal|1
argument_list|)
decl_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Create a context. */
end_comment

begin_function
name|private
name|int
name|context_create
parameter_list|(
name|uint
name|stacksize
parameter_list|,
name|gs_context
modifier|*
modifier|*
name|ppctx
parameter_list|)
block|{
name|gs_context
modifier|*
name|pctx
decl_stmt|;
name|ref
modifier|*
name|stkp
decl_stmt|;
name|long
name|ctx_index
decl_stmt|;
name|gs_context
modifier|*
modifier|*
name|pte
decl_stmt|;
name|pctx
operator|=
operator|(
name|gs_context
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_context
argument_list|)
argument_list|,
literal|"context"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stacksize
operator|<
name|default_stacksize
condition|)
name|stacksize
operator|=
name|default_stacksize
expr_stmt|;
name|stkp
operator|=
name|alloc_refs
argument_list|(
name|stacksize
argument_list|,
literal|"context(stacks)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|==
literal|0
operator|||
name|stkp
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|ctx_index
operator|=
name|ctx_next_index
operator|++
expr_stmt|;
name|pctx
operator|->
name|stacks
operator|=
name|stkp
expr_stmt|;
name|pctx
operator|->
name|stacksize
operator|=
name|stacksize
expr_stmt|;
name|pctx
operator|->
name|status
operator|=
name|cs_active
expr_stmt|;
name|pctx
operator|->
name|index
operator|=
name|ctx_index
expr_stmt|;
name|pctx
operator|->
name|detach
operator|=
literal|0
expr_stmt|;
name|pctx
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|pctx
operator|->
name|joiner
operator|=
literal|0
expr_stmt|;
name|pte
operator|=
operator|&
name|ctx_table
index|[
name|ctx_index
operator|%
name|ctx_table_size
index|]
expr_stmt|;
name|pctx
operator|->
name|table_next
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
name|pctx
expr_stmt|;
operator|*
name|ppctx
operator|=
name|pctx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check a context ID.  Note that we do not check for context validity. */
end_comment

begin_function
name|private
name|int
name|context_param
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|gs_context
modifier|*
modifier|*
name|ppctx
parameter_list|)
block|{
name|gs_context
modifier|*
name|pctx
decl_stmt|;
name|long
name|index
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|index
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|e_invalidcontext
return|;
name|pctx
operator|=
name|ctx_table
index|[
name|index
operator|%
name|ctx_table_size
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
name|pctx
operator|=
name|pctx
operator|->
name|table_next
control|)
block|{
if|if
condition|(
name|pctx
operator|==
literal|0
condition|)
return|return
name|e_invalidcontext
return|;
if|if
condition|(
name|pctx
operator|->
name|index
operator|==
name|index
condition|)
break|break;
block|}
operator|*
name|ppctx
operator|=
name|pctx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Destroy a context. */
end_comment

begin_function
name|private
name|void
name|context_destroy
parameter_list|(
name|gs_context
modifier|*
name|pctx
parameter_list|)
block|{
name|gs_context
modifier|*
modifier|*
name|ppctx
init|=
operator|&
name|ctx_table
index|[
name|pctx
operator|->
name|index
operator|%
name|ctx_table_size
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|ppctx
operator|!=
name|pctx
condition|)
name|ppctx
operator|=
operator|&
operator|(
operator|*
name|ppctx
operator|)
operator|->
name|table_next
expr_stmt|;
operator|*
name|ppctx
operator|=
operator|(
operator|*
name|ppctx
operator|)
operator|->
name|table_next
expr_stmt|;
name|alloc_free_refs
argument_list|(
name|pctx
operator|->
name|stacks
argument_list|,
name|pctx
operator|->
name|stacksize
argument_list|,
literal|"context_destroy"
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pctx
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_context
argument_list|)
argument_list|,
literal|"context_destroy"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Acquire a lock.  Return 0 if acquired, o_reschedule if not. */
end_comment

begin_function
name|private
name|int
name|lock_acquire
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_lock
modifier|*
name|plock
init|=
name|op
operator|->
name|value
operator|.
name|plock
decl_stmt|;
if|if
condition|(
name|plock
operator|->
name|holder
operator|==
literal|0
condition|)
block|{
name|plock
operator|->
name|holder
operator|=
name|ctx_current
expr_stmt|;
return|return
literal|0
return|;
block|}
name|add_last
argument_list|(
operator|&
name|plock
operator|->
name|waiting
argument_list|,
name|ctx_current
argument_list|)
expr_stmt|;
return|return
name|o_reschedule
return|;
block|}
end_function

begin_comment
comment|/* Release a lock.  Return 0 if OK, e_invalidcontext if not. */
end_comment

begin_function
name|private
name|int
name|lock_release
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_lock
modifier|*
name|plock
init|=
name|op
operator|->
name|value
operator|.
name|plock
decl_stmt|;
if|if
condition|(
name|plock
operator|->
name|holder
operator|==
name|ctx_current
condition|)
block|{
name|plock
operator|->
name|holder
operator|=
literal|0
expr_stmt|;
name|add_last_all
argument_list|(
operator|&
name|active
argument_list|,
operator|&
name|plock
operator|->
name|waiting
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|e_invalidcontext
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zcontext_op_defs
index|[]
init|=
block|{
block|{
literal|"0condition"
block|,
name|zcondition
block|}
block|,
block|{
literal|"0currentcontext"
block|,
name|zcurrentcontext
block|}
block|,
block|{
literal|"1detach"
block|,
name|zdetach
block|}
block|,
block|{
literal|"2fork"
block|,
name|zfork
block|}
block|,
block|{
literal|"1join"
block|,
name|zjoin
block|}
block|,
block|{
literal|"0lock"
block|,
name|zlock
block|}
block|,
block|{
literal|"2monitor"
block|,
name|zmonitor
block|,
operator|&
name|i_monitor
block|}
block|,
block|{
literal|"1notify"
block|,
name|znotify
block|}
block|,
block|{
literal|"2wait"
block|,
name|zwait
block|}
block|,
block|{
literal|"0yield"
block|,
name|zyield
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%fork_done"
block|,
name|fork_done
block|,
operator|&
name|i_fork_done
block|}
block|,
block|{
literal|"2%monitor_release"
block|,
name|monitor_release
block|,
operator|&
name|i_monitor_release
block|}
block|,
block|{
literal|"2%await_lock"
block|,
name|await_lock
block|,
operator|&
name|i_await_lock
block|}
block|,
name|op_def_end
argument_list|(
argument|zcontext_init
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

