begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1991  *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)  *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)  * Copyright (c) 1987 Oliver Laumann  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 1, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program (see the file COPYING); if not, write to the  * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Noteworthy contributors to screen's design and implementation:  *	Wayne Davison (davison@borland.com)  *	Patrick Wolfe (pat@kai.com, kailand!pat)  *	Bart Schaefer (schaefer@cse.ogi.edu)  *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)  *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)  *	Howard Chu (hyc@hanauma.jpl.nasa.gov)  *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)  *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)  *	Marc Boucher (marc@CAM.ORG)  *  ****************************************************************  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcs_id
index|[]
init|=
literal|"$Id: socket.c,v 1.2 92/02/03 02:28:17 jnweiger Exp $ FAU"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MIPS
argument_list|)
operator|||
name|defined
argument_list|(
name|GOULD_NP1
argument_list|)
operator|||
name|defined
argument_list|(
name|B43
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|sgi
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAMEDPIPE
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NAMEDPIPE
end_ifndef

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|M_XENIX
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* M_XENIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIRENT
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|dirent
value|direct
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USEVARARGS
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NAMEDPIPE
argument_list|)
end_if

begin_define
define|#
directive|define
name|connect
value|sconnect
end_define

begin_comment
comment|/* _SEQUENT_ has braindamaged connect */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RcFileName
decl_stmt|,
modifier|*
name|extra_incap
decl_stmt|,
modifier|*
name|extra_outcap
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern WinList
operator|,
extern|Detached
operator|,
extern|ServerSocket
operator|,
extern|real_uid
operator|,
extern|real_gid
operator|,
extern|eff_uid
operator|,
extern|eff_gid;
end_extern

begin_ifdef
ifdef|#
directive|ifdef
name|BSDJOBS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|Suspended
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern AttacherPid
operator|,
extern|dflag
operator|,
extern|rflag
operator|,
extern|lsflag
operator|,
extern|quietflag
operator|,
extern|wipeflag;
end_extern

begin_decl_stmt
specifier|extern
name|char
name|HostName
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mode
name|OldMode
decl_stmt|,
name|NewMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|display_tty
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|win
modifier|*
name|wtab
index|[]
decl_stmt|,
modifier|*
name|fore
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETHACK
end_ifdef

begin_extern
extern|extern nethackflag;
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASSWORD
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|CheckPassword
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|Password
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSDJOBS
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|)
end_if

begin_extern
extern|extern DevTty;
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|SockPath
index|[
name|MAXPATH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|SockNamePtr
decl_stmt|,
modifier|*
name|SockName
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|Msg_nomem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ret
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|RecoverSocket
parameter_list|()
block|{
name|int
name|s
init|=
literal|0
decl_stmt|,
name|d
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SockPath
argument_list|)
expr_stmt|;
name|s
operator|=
name|MakeServerSocket
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|ServerSocket
condition|)
block|{
name|debug2
argument_list|(
literal|"Oh, Serversocket was %d, now %d, let's dup!\n"
argument_list|,
name|ServerSocket
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
name|dup2
argument_list|(
name|s
argument_list|,
name|ServerSocket
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|ServerSocket
condition|)
block|{
name|debug2
argument_list|(
literal|"Hmm, dup2() failed, Serversocket was %d, now %d, bye\n"
argument_list|,
name|ServerSocket
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|Detached
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|SockPath
argument_list|,
comment|/* S_IFSOCK | */
literal|0600
argument_list|)
expr_stmt|;
comment|/* Flag detached-ness */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Socket mode 700 means we are Attached. 600 is detached.  * We return how many sockets we found. If it was exactly one, we come  * back with a SockPath set to it and open it in a fd pointed to by fdp.  * If fdp == 0 we simply produce a list if all sockets.  */
end_comment

begin_function
name|int
name|FindSocket
parameter_list|(
name|how
parameter_list|,
name|fdp
parameter_list|)
name|int
name|how
decl_stmt|;
name|int
modifier|*
name|fdp
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|lasts
init|=
literal|0
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|,
name|deadcount
init|=
literal|0
decl_stmt|,
name|wipecount
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|l
init|=
literal|0
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|Name
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
struct|struct
name|foundsock
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|}
name|foundsock
index|[
literal|100
index|]
struct|;
comment|/* 100 is hopefully enough. */
name|int
name|foundsockcount
init|=
literal|0
decl_stmt|;
comment|/* User may or may not give us a (prefix) SockName. We want to search. */
name|debug
argument_list|(
literal|"FindSocket:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SockName
condition|)
block|{
name|debug1
argument_list|(
literal|"We want to match '%s'\n"
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|SockName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NAME_MAX
if|if
condition|(
name|l
operator|>
name|NAME_MAX
condition|)
name|l
operator|=
name|NAME_MAX
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|NFS_HACK
name|setreuid
argument_list|(
name|eff_uid
argument_list|,
name|real_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug1
argument_list|(
literal|"FindSock searching... '%s'\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
comment|/*    * this is a hack: SockName may point to Filename(Sockpath)...    */
name|found
operator|=
operator|*
name|SockNamePtr
expr_stmt|;
operator|*
name|SockNamePtr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|SockPath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Cannot opendir %s"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
operator|*
name|SockNamePtr
operator|=
name|found
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Name
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
comment|/*         * there may be a file ".termcap" here.         * Ignore it just like "." and "..".         */
if|if
condition|(
name|Name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
name|debug2
argument_list|(
literal|"Attach found: '%s', needed '%s'\n"
argument_list|,
name|Name
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
if|if
condition|(
name|SockName
operator|&&
name|l
condition|)
block|{
specifier|register
name|char
modifier|*
name|n
init|=
name|Name
decl_stmt|;
comment|/* 	   * The SockNames "hf", "ttyhf", "1", "12345.tty", "12345.ttyhf.medusa" 	   * all match the Name "12345.ttyhf.medusa". 	   */
if|if
condition|(
operator|(
operator|*
name|SockName
operator|<=
literal|'0'
operator|||
operator|*
name|SockName
operator|>
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|n
operator|>
literal|'0'
operator|&&
operator|*
name|n
operator|<=
literal|'9'
operator|)
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|n
condition|)
if|if
condition|(
operator|*
name|n
operator|==
literal|'.'
condition|)
block|{
name|n
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"tty"
argument_list|,
name|SockName
argument_list|,
literal|3
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
literal|"tty"
argument_list|,
name|n
argument_list|,
literal|3
argument_list|)
condition|)
name|n
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|n
argument_list|,
name|SockName
argument_list|,
name|l
argument_list|)
condition|)
block|{
name|debug3
argument_list|(
literal|"strncmp('%s', '%s', %d)\n"
argument_list|,
name|n
argument_list|,
name|SockName
argument_list|,
name|l
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/*        * ATTENTION! MakeClientSocket adds SockName to SockPath!         * Anyway, we need it earlier.        */
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|st
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|real_uid
condition|)
continue|continue;
name|foundsock
index|[
name|foundsockcount
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|foundsock
index|[
name|foundsockcount
index|]
operator|.
name|mode
operator|=
name|s
operator|=
name|st
operator|.
name|st_mode
operator|&
literal|0777
expr_stmt|;
name|debug2
argument_list|(
literal|"FindSocket: %s has mode %04o...\n"
argument_list|,
name|Name
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0700
operator|||
name|s
operator|==
literal|0600
condition|)
block|{
comment|/* 	   * We try to connect through the socket. If successfull,  	   * thats o.k. Otherwise we record that mode as -1. 	   * MakeClientSocket() must be careful not to block forever. 	   */
if|if
condition|(
operator|(
name|s
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|Name
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|foundsock
index|[
name|foundsockcount
index|]
operator|.
name|mode
operator|=
operator|-
literal|1
expr_stmt|;
name|deadcount
operator|++
expr_stmt|;
block|}
else|else
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|foundsockcount
operator|>=
literal|100
condition|)
break|break;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NFS_HACK
name|setreuid
argument_list|(
name|real_uid
argument_list|,
name|eff_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wipeflag
condition|)
block|{
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|foundsockcount
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|foundsock
index|[
name|s
index|]
operator|.
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"wiping '%d'\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|SockPath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|foundsock
index|[
name|s
index|]
operator|.
name|mode
operator|=
operator|-
literal|2
expr_stmt|;
name|wipecount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|foundsockcount
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
name|foundsock
index|[
name|s
index|]
operator|.
name|mode
operator|)
operator|==
operator|(
name|dflag
condition|?
literal|0700
else|:
literal|0600
operator|)
condition|)
block|{
name|found
operator|++
expr_stmt|;
name|lasts
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|quietflag
operator|&&
operator|(
name|lsflag
operator|||
operator|(
name|found
operator|!=
literal|1
operator|&&
name|rflag
operator|!=
literal|2
operator|)
operator|)
condition|)
name|eexit
argument_list|(
literal|10
operator|+
name|found
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"attach: found=%d, foundsockcount=%d\n"
argument_list|,
name|found
argument_list|,
name|foundsockcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|1
operator|&&
name|lsflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lasts
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|SockName
operator|=
name|foundsock
index|[
name|lasts
index|]
operator|.
name|name
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quietflag
operator|&&
name|foundsockcount
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|found
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|lsflag
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|printf
argument_list|(
literal|"Your inventory:\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
operator|(
name|foundsockcount
operator|>
literal|1
operator|)
condition|?
literal|"There are screens on:\n"
else|:
literal|"There is a screen on:\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|printf
argument_list|(
literal|"Nothing fitting exists in the game:\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
operator|(
name|foundsockcount
operator|>
literal|1
operator|)
condition|?
literal|"There are screens on:\n"
else|:
literal|"There is a screen on:\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|printf
argument_list|(
operator|(
name|foundsockcount
operator|>
literal|1
operator|)
condition|?
literal|"Prove thyself worthy or perish:\n"
else|:
literal|"You see here a good looking screen:\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
operator|(
name|foundsockcount
operator|>
literal|1
operator|)
condition|?
literal|"There are several screens on:\n"
else|:
literal|"There is a possible screen on:\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|printf
argument_list|(
operator|(
name|foundsockcount
operator|>
literal|1
operator|)
condition|?
literal|"You may whish for a screen, what do you want?\n"
else|:
literal|"You see here a screen:\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
operator|(
name|foundsockcount
operator|>
literal|1
operator|)
condition|?
literal|"There are several screens on:\n"
else|:
literal|"There is a screen on:\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|foundsockcount
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
name|foundsock
index|[
name|s
index|]
operator|.
name|mode
condition|)
block|{
case|case
literal|0700
case|:
name|printf
argument_list|(
literal|"\t%s\t(Attached)\n"
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0600
case|:
name|printf
argument_list|(
literal|"\t%s\t(Detached)\n"
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX
argument_list|)
name|printf
argument_list|(
literal|"\t%s\t(Dead ??\?)\n"
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\t%s\t(Dead ???)\n"
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
operator|-
literal|2
case|:
name|printf
argument_list|(
literal|"\t%s\t(Removed)\n"
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\t%s\t(Wrong mode)\n"
argument_list|,
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|deadcount
operator|&&
operator|!
name|quietflag
condition|)
block|{
if|if
condition|(
name|wipeflag
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|printf
argument_list|(
literal|"You hear%s distant explosion%s.\n"
argument_list|,
operator|(
name|deadcount
operator|>
literal|1
operator|)
condition|?
literal|""
else|:
literal|" a"
argument_list|,
operator|(
name|deadcount
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
literal|"%d Socket%s wiped out.\n"
argument_list|,
name|deadcount
argument_list|,
operator|(
name|deadcount
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|printf
argument_list|(
literal|"The dead screen%s touch%s you. Try 'screen -wipe'.\n"
argument_list|,
operator|(
name|deadcount
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
operator|(
name|deadcount
operator|>
literal|1
operator|)
condition|?
literal|""
else|:
literal|"es"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|printf
argument_list|(
literal|"Remove dead Sockets with 'screen -wipe'.\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|foundsockcount
condition|;
name|s
operator|++
control|)
name|Free
argument_list|(
name|foundsock
index|[
name|s
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|1
operator|&&
name|fdp
condition|)
operator|*
name|fdp
operator|=
name|lasts
expr_stmt|;
if|if
condition|(
name|fdp
condition|)
return|return
name|found
return|;
return|return
name|foundsockcount
operator|-
name|wipecount
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NAMEDPIPE
end_ifdef

begin_function
name|int
name|MakeServerSocket
parameter_list|()
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NAME_MAX
if|if
condition|(
name|strlen
argument_list|(
name|SockNamePtr
argument_list|)
operator|>
name|NAME_MAX
condition|)
block|{
name|debug2
argument_list|(
literal|"MakeClientSocket: '%s' truncated to %d chars\n"
argument_list|,
name|SockNamePtr
argument_list|,
name|NAME_MAX
argument_list|)
expr_stmt|;
name|SockNamePtr
index|[
name|NAME_MAX
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|s
operator|=
name|open
argument_list|(
name|SockPath
argument_list|,
name|O_WRONLY
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"huii, my fifo already exists??\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quietflag
condition|)
block|{
name|Kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"There is already a screen running on %s.\n"
argument_list|,
name|Filename
argument_list|(
name|SockPath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"stat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|real_uid
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Unfortunatelly you are not its owner."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0700
operator|)
operator|==
literal|0600
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"To resume it, use \"screen -r\""
argument_list|)
expr_stmt|;
else|else
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"It is not detached."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserContext
argument_list|()
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC
argument_list|)
if|if
condition|(
name|mknod
argument_list|(
name|SockPath
argument_list|,
literal|0010700
argument_list|,
literal|0
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|mknod
argument_list|(
name|SockPath
argument_list|,
name|S_IFIFO
operator||
name|S_IEXEC
operator||
name|S_IWRITE
operator||
name|S_IREAD
argument_list|,
literal|0
argument_list|)
condition|)
endif|#
directive|endif
name|UserReturn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|UserReturn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|UserStatus
argument_list|()
operator|<=
literal|0
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"mknod fifo %s failed"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
comment|/*    * MUST be RDWR because otherwise we will get EOF's if    * nobody has opened the pipe for writing    */
if|if
condition|(
operator|(
name|s
operator|=
name|secopen
argument_list|(
name|SockPath
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"open fifo %s"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|MakeClientSocket
parameter_list|(
name|err
parameter_list|,
name|name
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NAME_MAX
if|if
condition|(
name|strlen
argument_list|(
name|SockNamePtr
argument_list|)
operator|>
name|NAME_MAX
condition|)
block|{
name|debug2
argument_list|(
literal|"MakeClientSocket: '%s' truncated to %d chars\n"
argument_list|,
name|SockNamePtr
argument_list|,
name|NAME_MAX
argument_list|)
expr_stmt|;
name|SockNamePtr
index|[
name|NAME_MAX
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|s
operator|=
name|secopen
argument_list|(
name|SockPath
argument_list|,
name|O_WRONLY
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|s
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"open: %s (but continuing...)"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"MakeClientSocket() open %s failed\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug1
argument_list|(
literal|"MakeClientSocket() open %s failed\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NAMEDPIPE */
end_comment

begin_function
name|int
name|MakeServerSocket
parameter_list|()
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_un
name|a
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|a
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NAME_MAX
if|if
condition|(
name|strlen
argument_list|(
name|SockNamePtr
argument_list|)
operator|>
name|NAME_MAX
condition|)
block|{
name|debug2
argument_list|(
literal|"MakeServerSocket: '%s' truncated to %d chars\n"
argument_list|,
name|SockNamePtr
argument_list|,
name|NAME_MAX
argument_list|)
expr_stmt|;
name|SockNamePtr
index|[
name|NAME_MAX
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|a
operator|.
name|sun_path
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|a
argument_list|,
name|strlen
argument_list|(
name|SockPath
argument_list|)
operator|+
literal|2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"oooooh! socket already is alive!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quietflag
condition|)
block|{
name|Kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
comment|/*  	   * oh, well. nobody receives that return code. papa  	   * dies by signal. 	   */
name|eexit
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"There is already a screen running on %s.\n"
argument_list|,
name|Filename
argument_list|(
name|SockPath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"stat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|real_uid
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Unfortunatelly you are not its owner."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0700
operator|)
operator|==
literal|0600
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"To resume it, use \"screen -r\""
argument_list|)
expr_stmt|;
else|else
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"It is not detached."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SockPath
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOREUID
name|setreuid
argument_list|(
name|eff_uid
argument_list|,
name|real_uid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|eff_gid
argument_list|,
name|real_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|a
argument_list|,
name|strlen
argument_list|(
name|SockPath
argument_list|)
operator|+
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|SockPath
argument_list|,
comment|/* S_IFSOCK | */
literal|0700
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOREUID
name|chown
argument_list|(
name|SockPath
argument_list|,
name|real_uid
argument_list|,
name|real_gid
argument_list|)
expr_stmt|;
else|#
directive|else
name|setreuid
argument_list|(
name|real_uid
argument_list|,
name|eff_uid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|real_gid
argument_list|,
name|eff_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"listen"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_SETOWN
name|fcntl
argument_list|(
name|s
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"Serversocket owned by %d\n"
argument_list|,
name|fcntl
argument_list|(
name|s
argument_list|,
name|F_GETOWN
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* F_SETOWN */
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|MakeClientSocket
parameter_list|(
name|err
parameter_list|,
name|name
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_un
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|a
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NAME_MAX
if|if
condition|(
name|strlen
argument_list|(
name|SockNamePtr
argument_list|)
operator|>
name|NAME_MAX
condition|)
block|{
name|debug2
argument_list|(
literal|"MakeClientSocket: '%s' truncated to %d chars\n"
argument_list|,
name|SockNamePtr
argument_list|,
name|NAME_MAX
argument_list|)
expr_stmt|;
name|SockNamePtr
index|[
name|NAME_MAX
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|a
operator|.
name|sun_path
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOREUID
name|setreuid
argument_list|(
name|eff_uid
argument_list|,
name|real_uid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|eff_gid
argument_list|,
name|real_gid
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|access
argument_list|(
name|SockPath
argument_list|,
name|W_OK
argument_list|)
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
else|else
name|debug2
argument_list|(
literal|"MakeClientSocket: access(%s): %d.\n"
argument_list|,
name|SockPath
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|a
argument_list|,
name|strlen
argument_list|(
name|SockPath
argument_list|)
operator|+
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"%s: connect"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"MakeClientSocket: connect failed.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NOREUID
name|setreuid
argument_list|(
name|real_uid
argument_list|,
name|eff_uid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|real_gid
argument_list|,
name|eff_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|SendCreateMsg
parameter_list|(
name|s
parameter_list|,
name|ac
parameter_list|,
name|av
parameter_list|,
name|aflag
parameter_list|,
name|flowflag
parameter_list|,
name|lflag
parameter_list|,
name|histheight
parameter_list|,
name|sterm
parameter_list|)
name|int
name|s
decl_stmt|,
name|ac
decl_stmt|,
name|aflag
decl_stmt|,
name|flowflag
decl_stmt|,
name|lflag
decl_stmt|,
name|histheight
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|sterm
decl_stmt|;
block|{
name|struct
name|msg
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|n
decl_stmt|;
name|debug1
argument_list|(
literal|"SendCreateMsg() to '%s'\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
name|m
operator|.
name|type
operator|=
name|MSG_CREATE
expr_stmt|;
name|p
operator|=
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|line
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|ac
operator|>
literal|0
operator|&&
name|n
operator|<
name|MAXARGS
operator|-
literal|1
condition|;
operator|++
name|av
operator|,
operator|--
name|ac
operator|,
operator|++
name|n
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|>=
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|line
operator|+
name|MAXPATH
operator|-
literal|1
condition|)
break|break;
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ac
operator|&&
operator|*
name|av
operator|&&
name|p
operator|+
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|+
literal|1
operator|<
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|line
operator|+
name|MAXPATH
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|nargs
operator|=
name|n
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|aflag
operator|=
name|aflag
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|flowflag
operator|=
name|flowflag
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|lflag
operator|=
name|lflag
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|hheight
operator|=
name|histheight
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
if|if
condition|(
name|getcwd
argument_list|(
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|dir
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|getwd
argument_list|(
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|dir
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|dir
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|screenterm
argument_list|,
name|sterm
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|screenterm
index|[
literal|19
index|]
operator|=
literal|'\0'
expr_stmt|;
name|debug1
argument_list|(
literal|"SendCreateMsg writing '%s'\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|create
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|)
operator|!=
sizeof|sizeof
name|m
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|USEVARARGS
comment|/*VARARGS1*/
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|SendErrorMsg
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|SendErrorMsg
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
comment|/* } */
specifier|static
name|va_list
name|ap
init|=
literal|0
decl_stmt|;
else|#
directive|else
comment|/*VARARGS1*/
name|SendErrorMsg
argument_list|(
argument|fmt
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|,
argument|p4
argument_list|,
argument|p5
argument_list|,
argument|p6
argument_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|unsigned
name|long
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|p4
decl_stmt|,
name|p5
decl_stmt|,
name|p6
decl_stmt|;
block|{
endif|#
directive|endif
specifier|register
name|int
name|s
decl_stmt|;
name|struct
name|msg
name|m
decl_stmt|;
name|s
operator|=
name|MakeClientSocket
argument_list|(
literal|1
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"SendErrorMsg() to '%s'\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
name|m
operator|.
name|type
operator|=
name|MSG_ERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|USEVARARGS
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|m
operator|.
name|m
operator|.
name|message
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|m
operator|.
name|m
operator|.
name|message
argument_list|,
name|fmt
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|,
name|p5
argument_list|,
name|p6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug1
argument_list|(
literal|"SendErrorMsg writing '%s'\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PASSWORD
specifier|static
name|int
name|CheckPasswd
parameter_list|(
name|pwd
parameter_list|,
name|pid
parameter_list|,
name|tty
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|pwd
decl_stmt|,
decl|*
name|tty
decl_stmt|;
block|{
if|if
condition|(
name|CheckPassword
operator|&&
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|pwd
argument_list|,
operator|(
name|strlen
argument_list|(
name|Password
argument_list|)
operator|>
literal|1
operator|)
condition|?
name|Password
else|:
literal|"JW"
argument_list|)
argument_list|,
name|Password
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|pwd
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"'%s' tries to explode in the sky, but fails. (%s)"
argument_list|,
name|tty
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Illegal reattach attempt from terminal %s, \"%s\""
argument_list|,
name|tty
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
block|}
name|debug1
argument_list|(
literal|"CheckPass() wrong password kill(%d, SIG_PW_FAIL)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|Kill
argument_list|(
name|pid
argument_list|,
name|SIG_PW_FAIL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|debug1
argument_list|(
literal|"CheckPass() from %d happy\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|Kill
argument_list|(
name|pid
argument_list|,
name|SIG_PW_OK
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* PASSWORD */
specifier|static
name|void
name|ExecCreate
parameter_list|(
name|mp
parameter_list|)
name|struct
name|msg
modifier|*
name|mp
decl_stmt|;
block|{
name|char
modifier|*
name|args
index|[
name|MAXARGS
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
init|=
name|args
decl_stmt|,
modifier|*
name|p
init|=
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|line
decl_stmt|;
for|for
control|(
name|n
operator|=
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|nargs
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|p
operator|=
literal|0
expr_stmt|;
name|MakeWindow
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|aflag
argument_list|,
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|flowflag
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|dir
argument_list|,
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|lflag
argument_list|,
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|hheight
argument_list|,
name|mp
operator|->
name|m
operator|.
name|create
operator|.
name|screenterm
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|CheckPid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
name|pid
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|eff_uid
operator|==
name|real_uid
condition|)
return|return
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|UserContext
argument_list|()
operator|==
literal|1
condition|)
block|{
name|UserReturn
argument_list|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|UserStatus
argument_list|()
return|;
block|}
name|void
name|ReceiveMsg
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|int
name|left
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|struct
name|msg
name|m
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|lbuf
index|[
literal|20
index|]
decl_stmt|,
name|cbuf
index|[
literal|20
index|]
decl_stmt|;
comment|/* static for later putenv()'s */
ifdef|#
directive|ifdef
name|NAMEDPIPE
comment|/*    * we may be called if there are no pending messages, so we will have to    * block on first read.    */
name|debug
argument_list|(
literal|"Ha, there was someone knocking on my fifo??\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|s
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"fcntl no O_NDELAY"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|m
expr_stmt|;
name|left
operator|=
sizeof|sizeof
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
operator|&&
operator|(
name|len
operator|=
name|read
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|left
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/*		if (p == (char *)&m)        *		{	if (fcntl(s, F_SETFL, O_NDELAY) == -1)        *			{	Msg(errno, "fcntl O_NDELAY !");        *				return;        *			}        *		}        */
name|p
operator|+=
name|len
expr_stmt|;
name|left
operator|-=
name|len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|debug
argument_list|(
literal|"ReceiveMsg: Yucc! Got an EOF !!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
specifier|register
name|int
name|ns
decl_stmt|;
name|struct
name|sockaddr_un
name|a
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Ha, there was someone knocking on my socket??\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ns
operator|=
name|accept
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|a
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"accept"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|m
expr_stmt|;
name|left
operator|=
sizeof|sizeof
name|m
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
operator|&&
operator|(
name|len
operator|=
name|read
argument_list|(
name|ns
argument_list|,
name|p
argument_list|,
name|left
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|+=
name|len
expr_stmt|;
name|left
operator|-=
name|len
expr_stmt|;
block|}
name|close
argument_list|(
name|ns
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMEDPIPE */
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|>
literal|0
condition|)
return|return;
name|debug1
argument_list|(
literal|"RecMsg: type %d !, "
argument_list|,
name|m
operator|.
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m
operator|.
name|type
condition|)
block|{
case|case
name|MSG_WINCH
case|:
comment|/* Already processed in screen.c */
ifdef|#
directive|ifdef
name|notdef
name|CheckScreenSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Change fore */
endif|#
directive|endif
break|break;
case|case
name|MSG_CREATE
case|:
if|if
condition|(
operator|!
name|Detached
condition|)
name|ExecCreate
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_CONT
case|:
name|debug3
argument_list|(
literal|"RecMsg: apid=%d,was %d, Detached=%d\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|,
name|AttacherPid
argument_list|,
name|Detached
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SECURE_MSG_CONT
if|if
condition|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
operator|!=
name|AttacherPid
operator|||
operator|!
name|Detached
condition|)
comment|/* 	 * now we realize, that there is something strange happening. 	 * First, there was some idiot who said "CONT" and thought 	 * "ATTACH". This is, when we have (AttacherPid == 0). Harmless. 	 * Let him in. Second, we are waiting for a certain AttacherPid, 	 * and not for "any" attacher. This is when (AttacherPid != 0). 	 * But Darwin's rule says "survival of the fittest", thus: Look 	 * weather "our" AttacherPid is still alive and well, and let the 	 * new one only in, if the old Attacher has been killed. jw. 	 */
if|if
condition|(
name|AttacherPid
operator|!=
literal|0
operator|&&
name|kill
argument_list|(
name|AttacherPid
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Intruder Alert */
else|else
endif|#
directive|endif
comment|/* SECURE_MSG_CONT */
name|AttacherPid
operator|=
literal|0
expr_stmt|;
comment|/* we dont want to kill ourselves 				 * later. jw. */
comment|/* FALLTHROUGH */
case|case
name|MSG_ATTACH
case|:
if|if
condition|(
name|CheckPid
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|)
condition|)
block|{
name|debug1
argument_list|(
literal|"Attach attempt with bad pid(%d)\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|)
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Attach attempt with bad pid(%d) !"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PASSWORD
if|if
condition|(
operator|!
name|CheckPasswd
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|password
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
condition|)
block|{
name|debug3
argument_list|(
literal|"RcvMsg:Checkpass(%s,%d,%s) failed\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|password
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* PASSWORD */
if|if
condition|(
operator|!
name|Detached
condition|)
block|{
name|debug
argument_list|(
literal|"RecMsg: hey, why you disturb, we are not detached. hangup!\n"
argument_list|)
expr_stmt|;
name|Kill
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Attach msg ignored: We are not detached."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|secopen
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug1
argument_list|(
literal|"ALERT: Cannot open %s!\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"You can't open (%s). Perhaps there's a Monster behind it."
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Attach: Could not open %s"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
expr_stmt|;
name|Kill
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
break|break;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|debug
argument_list|(
literal|"PANIC: open did not return fd 0!\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|debug2
argument_list|(
literal|"RecMsg: apid %d is o.k. and we just opened '%s'\n"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|hpux_and_it_still_does_not_work
block|{
name|int
name|pgrp
decl_stmt|,
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|debug1
argument_list|(
literal|"tcgetpgrp: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* save old pgrp from tty */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|zero
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|debug1
argument_list|(
literal|"tcsetpgrp: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* detach tty from proc grp */
ifdef|#
directive|ifdef
name|hpux
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|debug1
argument_list|(
literal|"setpgrp: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* make me proc group leader */
endif|#
directive|endif
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* reopen tty, now we should get it as our tty */
operator|(
name|void
operator|)
name|secopen
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* */
ifdef|#
directive|ifdef
name|hpux
name|setpgrp2
argument_list|(
literal|0
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
else|#
directive|else
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* hpux_and_it_still_does_not_work */
operator|(
name|void
operator|)
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|GetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSDJOBS
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|)
if|if
condition|(
operator|(
name|DevTty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug1
argument_list|(
literal|"DevTty not opened: %d.\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"/dev/tty"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SigHup
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
if|if
condition|(
name|Suspended
operator|&&
name|m
operator|.
name|type
operator|==
name|MSG_ATTACH
condition|)
if|if
condition|(
name|kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIG_BYE
argument_list|)
operator|==
literal|0
condition|)
name|kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AttacherPid
operator|=
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
expr_stmt|;
name|strcpy
argument_list|(
name|display_tty
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
comment|/*        * we set the Utmp slots again, if we were detached normally        * and if we were detached by ^Z.        */
name|ReInitUtmp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|WinList
init|;
name|i
operator|!=
operator|-
literal|1
condition|;
name|i
operator|=
name|wtab
index|[
name|i
index|]
operator|->
name|WinLink
control|)
if|if
condition|(
name|wtab
index|[
name|i
index|]
operator|->
name|slot
operator|!=
operator|(
name|slot_t
operator|)
operator|-
literal|1
condition|)
name|SetUtmp
argument_list|(
name|wtab
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|SockPath
argument_list|,
comment|/* S_IFSOCK | */
literal|0700
argument_list|)
expr_stmt|;
name|Detached
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
name|Suspended
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*        * we like to have always the valid termcap, even if we are        * reattached from a different tty type. thus attacher had to        * tell us, what TERM we have. The attacher has correct env        * setting. we (the backend may be wrong).        */
if|if
condition|(
operator|*
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|envterm
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|pyr
argument_list|)
operator|||
name|defined
argument_list|(
name|xelos
argument_list|)
operator|||
name|defined
argument_list|(
name|sequent
argument_list|)
comment|/* 	   * Kludge for systems with braindamaged termcap routines, 	   * which evaluate $TERMCAP, regardless weather it describes 	   * the correct terminal type or not. 	   */
if|if
condition|(
name|strcmp
argument_list|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|envterm
operator|+
literal|5
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"a different terminal, so unsetenv(TERMCAP)"
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
literal|"TERMCAP"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sequent
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MIPS
argument_list|)
name|putenv
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|envterm
argument_list|)
expr_stmt|;
else|#
directive|else
name|setenv
argument_list|(
literal|"TERM"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|envterm
operator|+
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sequent
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MIPS
argument_list|)
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"LINES=%d"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|lines
operator|>
literal|0
operator|||
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
condition|)
name|putenv
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"COLUMNS=%d"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|columns
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|columns
operator|>
literal|0
operator|||
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
condition|)
name|putenv
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"%d"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|lines
operator|>
literal|0
operator|||
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
condition|)
name|setenv
argument_list|(
literal|"LINES"
argument_list|,
name|lbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"%d"
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|columns
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|columns
operator|>
literal|0
operator|||
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
condition|)
name|setenv
argument_list|(
literal|"COLUMNS"
argument_list|,
name|cbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*        * We reboot our Terminal Emulator. Forget all we knew about        * the old terminal, reread the termcap entries in .screenrc        * (and nothing more from .screenrc is read. Mainly because        * I did not check, weather a full reinit is save. jw)         * and /etc/screenrc, and initialise anew.        */
if|if
condition|(
name|extra_outcap
condition|)
name|Free
argument_list|(
name|extra_outcap
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_incap
condition|)
name|Free
argument_list|(
name|extra_incap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ETCSCREENRC
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"SYSSCREENRC"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|StartRc
argument_list|(
name|ETCSCREENRC
argument_list|)
expr_stmt|;
else|else
name|StartRc
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|StartRc
argument_list|(
name|RcFileName
argument_list|)
expr_stmt|;
name|InitTermcap
argument_list|()
expr_stmt|;
name|InitTerm
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|adaptflag
argument_list|)
expr_stmt|;
name|SetMode
argument_list|(
operator|&
name|OldMode
argument_list|,
operator|&
name|NewMode
argument_list|)
expr_stmt|;
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|NewMode
argument_list|)
expr_stmt|;
name|fore
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|Activate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"activated...\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_ERROR
case|:
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|m
operator|.
name|m
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_HANGUP
case|:
ifdef|#
directive|ifdef
name|REMOTE_DETACH
case|case
name|MSG_DETACH
case|:
ifdef|#
directive|ifdef
name|POW_DETACH
case|case
name|MSG_POW_DETACH
case|:
endif|#
directive|endif
comment|/* POW_DETACH */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REMOTE_DETACH
ifdef|#
directive|ifdef
name|POW_DETACH
if|if
condition|(
name|m
operator|.
name|type
operator|==
name|MSG_POW_DETACH
condition|)
name|Detach
argument_list|(
name|D_REMOTE_POWER
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* POW_DETACH */
if|if
condition|(
name|m
operator|.
name|type
operator|==
name|MSG_DETACH
condition|)
name|Detach
argument_list|(
name|D_REMOTE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|SigHup
argument_list|(
name|SIGARG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Invalid message (type %d)."
argument_list|,
name|m
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NAMEDPIPE
argument_list|)
undef|#
directive|undef
name|connect
name|sconnect
argument_list|(
argument|s
argument_list|,
argument|sapp
argument_list|,
argument|len
argument_list|)
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sapp
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_un
modifier|*
name|sap
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|x
decl_stmt|;
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sapp
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sap
operator|->
name|sun_path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|chmod
argument_list|(
name|sap
operator|->
name|sun_path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|sap
operator|->
name|sun_path
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

