begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1991  *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)  *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)  * Copyright (c) 1987 Oliver Laumann  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 1, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program (see the file COPYING); if not, write to the  * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Noteworthy contributors to screen's design and implementation:  *	Wayne Davison (davison@borland.com)  *	Patrick Wolfe (pat@kai.com, kailand!pat)  *	Bart Schaefer (schaefer@cse.ogi.edu)  *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)  *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)  *	Howard Chu (hyc@hanauma.jpl.nasa.gov)  *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)  *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)  *	Marc Boucher (marc@CAM.ORG)  *  ****************************************************************  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcs_id
index|[]
init|=
literal|"$Id: screen.c,v 1.2 92/02/03 02:28:05 jnweiger Exp $ FAU"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* #include<signal.h> */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|B43
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ISC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Gee!! We should reverse that #if!   */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|sysV68
argument_list|)
operator|||
name|defined
argument_list|(
name|MIPS
argument_list|)
operator|||
name|defined
argument_list|(
name|GOULD_NP1
argument_list|)
operator|||
name|defined
argument_list|(
name|B43
argument_list|)
operator|||
name|defined
argument_list|(
name|ISC
argument_list|)
operator|||
name|defined
argument_list|(
name|apollo
argument_list|)
operator|||
name|defined
argument_list|(
name|BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|sgi
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|M_XENIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_comment
comment|/* for timeval */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISC
end_ifdef

begin_include
include|#
directive|include
file|<sys/bsdtypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sysV68
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|sgi
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SHADOWPW
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHADOWPW */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
end_if

begin_comment
comment|/* for the FD.. stuff */
end_comment

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sequent
argument_list|)
operator|||
name|defined
argument_list|(
name|SVR4
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sequent || SVR4 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC
end_ifdef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/sioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/pty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|xelos
argument_list|)
operator|||
name|defined
argument_list|(
name|sysV68
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwuid
name|__P
argument_list|(
operator|(
name|uid_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwnam
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USEVARARGS
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|FILE
modifier|*
name|dfp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COPY_PASTE
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|copybuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* def in mark.c jw. */
end_comment

begin_extern
extern|extern copylen;
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COPY_PASTE */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|blank
decl_stmt|,
modifier|*
name|null
decl_stmt|,
name|Term
index|[]
decl_stmt|,
name|screenterm
index|[]
decl_stmt|,
modifier|*
modifier|*
name|environ
decl_stmt|,
modifier|*
name|Termcap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|force_vt
init|=
literal|1
decl_stmt|,
name|assume_LP
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|in_ovl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ovl_blockfore
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ovl_process
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|help_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screenwidth
decl_stmt|,
name|screenheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|display_tty
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|default_width
decl_stmt|,
name|default_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Z0width
decl_stmt|,
name|Z1width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ISO2022
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|status
decl_stmt|,
name|HS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Z0
decl_stmt|,
modifier|*
name|WS
decl_stmt|,
modifier|*
name|LastMsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|TimeDisplayed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BellDisplayed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|VBellWait
decl_stmt|,
name|MsgWait
decl_stmt|,
name|MsgMinWait
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tputs uses that: jw */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flow
decl_stmt|,
name|default_flow
decl_stmt|,
name|wrap
decl_stmt|,
name|visual_bell
decl_stmt|,
name|default_monitor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern sys_nerr;
end_extern

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|mark_key_tab
index|[]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCSWINSZ
argument_list|)
operator|||
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|struct
name|winsize
name|glwz
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|MakeWinMsg
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|MakeNewEnv
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Attach
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Attacher
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SigHandler
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|SIGTYPE
name|AttacherSigInt
name|__P
parameter_list|(
name|SIGPROTOARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|SIGTYPE
name|SigChld
name|__P
parameter_list|(
name|SIGPROTOARG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|SIGTYPE
name|SigInt
name|__P
parameter_list|(
name|SIGPROTOARG
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|SIGTYPE
name|CoreDump
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DoWait
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGTYPE
name|Finit
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitKeytab
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SetForeWindow
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|NextWindow
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PreviousWindow
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MoreWindows
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|FreeWindow
name|__P
argument_list|(
operator|(
expr|struct
name|win
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|execvpe
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|LogToggle
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ShowWindows
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ShowTime
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ShowInfo
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|OpenPTY
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PASSWORD
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|trysend
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|msg
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
end_if

begin_function_decl
specifier|static
name|SIGTYPE
name|SigAttWinch
name|__P
parameter_list|(
name|SIGPROTOARG
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|fgtty
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freetty
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|brktty
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOCK
argument_list|)
end_if

begin_function_decl
specifier|static
name|SIGTYPE
name|DoLock
name|__P
parameter_list|(
name|SIGPROTOARG
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|LockTerminal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COPY_PASTE
end_ifdef

begin_expr_stmt
specifier|static
name|pastelen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pastebuffer
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASSWORD
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|Password
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|passwd
modifier|*
name|ppp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for opening a new pty-pair: */
end_comment

begin_decl_stmt
specifier|static
name|char
name|PtyName
index|[
literal|32
index|]
decl_stmt|,
name|TtyName
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for the attacher's tty: */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|attach_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ShellProg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ShellArgs
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|inbuf
index|[
name|MAXWIN
index|]
index|[
name|IOSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|inlen
index|[
name|MAXWIN
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|inbuf_ct
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|ESCseen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GotSignal
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|DefaultShell
index|[]
init|=
literal|"/bin/sh"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|DefaultPath
index|[]
init|=
literal|":/usr/ucb:/bin:/usr/bin"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_decl_stmt
name|char
name|PtyProto
index|[]
init|=
literal|"/dev/ptym/ptyXY"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|TtyProto
index|[]
init|=
literal|"/dev/pty/ttyXY"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|sequent
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
operator|||
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|static
name|char
name|PtyProto
index|[]
init|=
literal|"/dev/ptyXY"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|TtyProto
index|[]
init|=
literal|"/dev/ttyXY"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hpux */
end_comment

begin_decl_stmt
name|int
name|TtyMode
init|=
literal|0622
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOCKDIR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|SockDir
init|=
name|SOCKDIR
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|SockDir
init|=
literal|".iscreen"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
name|SockPath
index|[]
decl_stmt|,
modifier|*
name|SockNamePtr
decl_stmt|,
modifier|*
name|SockName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ServerSocket
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|NewEnv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RcFileName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Esc
init|=
name|Ctrl
argument_list|(
literal|'a'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|MetaEsc
init|=
literal|'a'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|home
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|HasWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|LoginName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BellString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|VisualBellString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ActivityString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BufferFile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|PowDetachString
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|auto_detach
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iflag
decl_stmt|,
name|rflag
decl_stmt|,
name|dflag
decl_stmt|,
name|lsflag
decl_stmt|,
name|quietflag
decl_stmt|,
name|wipeflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|adaptflag
decl_stmt|,
name|loginflag
init|=
operator|-
literal|1
decl_stmt|,
name|allflag
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|intrc
operator|,
name|startc
operator|,
name|stopc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|HostName
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Detached
decl_stmt|,
name|Suspended
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DeadlyMsg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|AttacherPid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-Zero in child if we have an attacher */
end_comment

begin_decl_stmt
name|int
name|MasterPid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|real_uid
decl_stmt|,
name|real_gid
decl_stmt|,
name|eff_uid
decl_stmt|,
name|eff_gid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_histheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_startup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slowpaste
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSDJOBS
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|)
end_if

begin_decl_stmt
name|int
name|DevTty
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NETHACK
end_ifdef

begin_decl_stmt
name|int
name|nethackflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|mode
name|OldMode
decl_stmt|,
name|NewMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|win
modifier|*
name|fore
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|WinList
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ForeNum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|win
modifier|*
name|wtab
index|[
name|MAXWIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key
name|ktab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SET
end_ifndef

begin_typedef
typedef|typedef
struct|struct
name|fd_set
block|{
name|int
name|fd_bits
index|[
literal|1
index|]
decl_stmt|;
block|}
name|fd_set
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|fd
parameter_list|)
value|((fd)->fd_bits[0] = 0)
end_define

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|b
parameter_list|,
name|fd
parameter_list|)
value|((fd)->fd_bits[0] |= 1<< (b))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|b
parameter_list|,
name|fd
parameter_list|)
value|((fd)->fd_bits[0]& 1<< (b))
end_define

begin_define
define|#
directive|define
name|FD_SETSIZE
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSDWAIT
end_ifndef

begin_comment
comment|/* if wait is NOT a union: */
end_comment

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|status
parameter_list|)
value|(status& 0177)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|status
parameter_list|)
value|status.w_T.w_Termsig
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFCORESIG
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSDWAIT
end_ifndef

begin_comment
comment|/* if wait is NOT a union: */
end_comment

begin_define
define|#
directive|define
name|WIFCORESIG
parameter_list|(
name|status
parameter_list|)
value|(status& 0200)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WIFCORESIG
parameter_list|(
name|status
parameter_list|)
value|status.w_T.w_Coredump
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSDWAIT
end_ifndef

begin_comment
comment|/* if wait is NOT a union: */
end_comment

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|status
parameter_list|)
value|((status>> 8)& 0377)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|status
parameter_list|)
value|status.w_T.w_Retcode
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|shellaka
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Do this last  */
end_comment

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * XXX: Missing system header files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USEVARARGS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|VPRNT_DECLARED
end_ifndef

begin_decl_stmt
name|int
name|vsprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VPRNT_DECLARED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|select
name|__P
argument_list|(
operator|(
name|int
operator|,
name|fd_set
operator|*
operator|,
name|fd_set
operator|*
operator|,
name|fd_set
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|brktty
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|POSIX
name|setsid
argument_list|()
expr_stmt|;
comment|/* will break terminal affiliation */
ifdef|#
directive|ifdef
name|BSD
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
else|#
directive|else
ifdef|#
directive|ifdef
name|SYSV
name|setpgrp
argument_list|()
expr_stmt|;
comment|/* will break terminal affiliation */
else|#
directive|else
ifdef|#
directive|ifdef
name|BSDJOBS
if|if
condition|(
name|DevTty
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|DevTty
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|debug2
argument_list|(
literal|"brktty: ioctl(DevTty=%d, TIOCNOTTY, 0) = %d\n"
argument_list|,
name|DevTty
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|freetty
parameter_list|()
block|{
name|brktty
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSDJOBS
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|)
if|if
condition|(
name|DevTty
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|DevTty
argument_list|)
expr_stmt|;
name|DevTty
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"did freetty\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fgtty
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BSDJOBS
name|int
name|mypid
decl_stmt|;
name|mypid
operator|=
name|getpid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDI
name|setsid
argument_list|()
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSDI */
ifdef|#
directive|ifdef
name|POSIX
if|if
condition|(
name|tcsetpgrp
argument_list|(
literal|0
argument_list|,
name|mypid
argument_list|)
condition|)
block|{
name|debug1
argument_list|(
literal|"fgtty: tcsetpgrp: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* error is likely to have side-effects -- better to warn our user */
name|SendErrorMsg
argument_list|(
literal|"fgtty: Could not set process group id in tty"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|mypid
argument_list|)
operator|!=
literal|0
condition|)
name|debug1
argument_list|(
literal|"fgtty: TIOSETPGRP: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* posix setsid() in brktty() from freetty() already made us leader */
if|if
condition|(
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|mypid
argument_list|)
condition|)
name|debug1
argument_list|(
literal|"fgtty: setpgrp: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POSIX */
endif|#
directive|endif
comment|/* BSDJOBS */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_comment
comment|/*  * hpux has berkeley signal semantics if we use sigvector,  * but not, if we use signal, so we define our own signal() routine.  * (jw)  */
end_comment

begin_macro
name|void
argument_list|(
argument|*signal(sig, func)
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
name|int
name|sig
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|sigvec
name|osv
decl_stmt|,
name|sv
decl_stmt|;
name|sv
operator|.
name|sv_handler
operator|=
name|func
expr_stmt|;
name|sv
operator|.
name|sv_mask
operator|=
name|sigmask
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sv_flags
operator|=
name|SV_BSDSIG
expr_stmt|;
if|if
condition|(
name|sigvector
argument_list|(
name|sig
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|BADSIG
operator|)
return|;
return|return
operator|(
name|osv
operator|.
name|sv_handler
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hpux */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USEBCOPY
end_ifndef

begin_function
name|void
name|bcopy
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|s1
operator|<
name|s2
operator|&&
name|s2
operator|<
name|s1
operator|+
name|len
condition|)
block|{
name|s1
operator|+=
name|len
expr_stmt|;
name|s2
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
operator|--
name|s2
operator|=
operator|*
operator|--
name|s1
expr_stmt|;
block|}
else|else
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USEBCOPY */
end_comment

begin_function
name|void
name|bclear
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|blank
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|closeallfiles
parameter_list|()
block|{
name|int
name|f
decl_stmt|;
ifdef|#
directive|ifdef
name|SVR4
name|struct
name|rlimit
name|rl
decl_stmt|;
if|if
condition|(
operator|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|rl
operator|.
name|rlim_max
operator|!=
name|RLIM_INFINITY
condition|)
name|f
operator|=
name|rl
operator|.
name|rlim_max
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* SVR4 */
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ISC
argument_list|)
name|f
operator|=
name|NOFILE
expr_stmt|;
else|#
directive|else
comment|/* SYSV&& !ISC */
name|f
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV&& !ISC */
while|while
condition|(
operator|--
name|f
operator|>
literal|2
condition|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|InterruptPlease
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|struct
name|win
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|aka
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|av0
decl_stmt|;
name|char
name|socknamebuf
index|[
literal|2
operator|*
name|MAXSTR
index|]
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|fd_set
name|r
decl_stmt|,
name|w
decl_stmt|,
name|e
decl_stmt|;
name|int
name|mflag
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|nsel
decl_stmt|;
name|char
name|buf
index|[
name|IOSIZE
index|]
decl_stmt|,
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|myname
init|=
operator|(
name|ac
operator|==
literal|0
operator|)
condition|?
literal|"screen"
else|:
name|av
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|_MODE_T
comment|/* (jw) */
name|mode_t
name|oumask
decl_stmt|;
else|#
directive|else
name|int
name|oumask
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSV
name|struct
name|utsname
name|utsnam
decl_stmt|;
endif|#
directive|endif
comment|/*    *  First, close all unused descriptors    *  (otherwise, we might have problems with the select() call)    */
name|closeallfiles
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|mkdir
argument_list|(
literal|"/tmp/debug"
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dfp
operator|=
name|fopen
argument_list|(
literal|"/tmp/debug/screen.front"
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dfp
operator|=
name|stderr
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
literal|"/tmp/debug/screen.front"
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug1
argument_list|(
literal|"-- screen debug started %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX
name|debug
argument_list|(
literal|"POSIX\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIO
name|debug
argument_list|(
literal|"TERMIO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSV
name|debug
argument_list|(
literal|"SYSV\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NAMEDPIPE
name|debug
argument_list|(
literal|"NAMEDPIPE\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
name|debug
argument_list|(
literal|"Window changing enabled\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NOREUID
name|debug
argument_list|(
literal|"NOREUID\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hpux
name|debug
argument_list|(
literal|"hpux\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USEBCOPY
name|debug
argument_list|(
literal|"USEBCOPY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UTMPOK
name|debug
argument_list|(
literal|"UTMPOK\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADAV
name|debug
argument_list|(
literal|"LOADAV\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NETHACK
name|debug
argument_list|(
literal|"NETHACK\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMINFO
name|debug
argument_list|(
literal|"TERMINFO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NAME_MAX
name|debug1
argument_list|(
literal|"NAME_MAX = %d\n"
argument_list|,
name|NAME_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BellString
operator|=
name|SaveStr
argument_list|(
literal|"Bell in window %"
argument_list|)
expr_stmt|;
name|VisualBellString
operator|=
name|SaveStr
argument_list|(
literal|"   Wuff,  Wuff!!  "
argument_list|)
expr_stmt|;
name|ActivityString
operator|=
name|SaveStr
argument_list|(
literal|"Activity in window %"
argument_list|)
expr_stmt|;
name|BufferFile
operator|=
name|SaveStr
argument_list|(
literal|"/tmp/screen-exchange"
argument_list|)
expr_stmt|;
name|PowDetachString
operator|=
literal|0
expr_stmt|;
name|default_histheight
operator|=
name|DEFAULTHISTHEIGHT
expr_stmt|;
name|default_startup
operator|=
operator|(
name|ac
operator|>
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|adaptflag
operator|=
literal|0
expr_stmt|;
name|slowpaste
operator|=
literal|0
expr_stmt|;
name|VBellWait
operator|=
name|VBELLWAIT
expr_stmt|;
name|MsgWait
operator|=
name|MSGWAIT
expr_stmt|;
name|MsgMinWait
operator|=
name|MSGMINWAIT
expr_stmt|;
name|CompileKeys
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|mark_key_tab
argument_list|)
expr_stmt|;
name|av0
operator|=
operator|*
name|av
expr_stmt|;
while|while
condition|(
name|ac
operator|>
literal|0
condition|)
block|{
name|ap
operator|=
operator|*
operator|++
name|av
expr_stmt|;
if|if
condition|(
operator|--
name|ac
operator|>
literal|0
operator|&&
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|ap
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|allflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|adaptflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
name|RcFileName
operator|=
name|ap
operator|+
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|--
name|ac
operator|==
literal|0
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|RcFileName
operator|=
operator|*
operator|++
name|av
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
name|ap
operator|+=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|--
name|ac
operator|==
literal|0
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|*
operator|++
name|av
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ParseEscape
argument_list|(
name|ap
argument_list|)
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Two characters are required with -e option."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
switch|switch
condition|(
name|ap
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'n'
case|:
case|case
literal|'0'
case|:
name|default_flow
operator|=
name|FLOW_NOW
operator|*
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'1'
case|:
case|case
literal|'\0'
case|:
name|default_flow
operator|=
name|FLOW_NOW
operator|*
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|default_flow
operator|=
name|FLOW_AUTOFLAG
expr_stmt|;
break|break;
default|default:
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
name|default_histheight
operator|=
name|atoi
argument_list|(
name|ap
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|--
name|ac
operator|==
literal|0
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|default_histheight
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|av
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|default_histheight
operator|<
literal|0
condition|)
name|default_histheight
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|iflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* title is a synonym for AkA */
case|case
literal|'k'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
name|aka
operator|=
name|ap
operator|+
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|--
name|ac
operator|==
literal|0
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|aka
operator|=
operator|*
operator|++
name|av
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
switch|switch
condition|(
name|ap
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'n'
case|:
case|case
literal|'0'
case|:
name|loginflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'1'
case|:
case|case
literal|'\0'
case|:
name|loginflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
name|lsflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|lsflag
operator|=
literal|1
expr_stmt|;
name|wipeflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|assume_LP
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|force_vt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ap
operator|+
literal|2
argument_list|)
operator|<
literal|20
condition|)
name|strcpy
argument_list|(
name|screenterm
argument_list|,
name|ap
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|--
name|ac
operator|==
literal|0
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
operator|++
name|av
argument_list|)
operator|<
literal|20
condition|)
name|strcpy
argument_list|(
name|screenterm
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
block|{
name|SockName
operator|=
name|ap
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|1
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
operator|*
name|av
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
name|SockName
operator|=
operator|*
operator|++
name|av
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
name|rflag
operator|=
operator|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REMOTE_DETACH
case|case
literal|'d'
case|:
name|dflag
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|dflag
condition|)
name|dflag
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
name|SockName
operator|=
name|ap
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|av
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
name|SockName
operator|=
operator|*
operator|++
name|av
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
if|if
condition|(
name|ap
index|[
literal|2
index|]
condition|)
name|ShellProg
operator|=
name|ap
operator|+
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|--
name|ac
operator|==
literal|0
condition|)
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|ShellProg
operator|=
operator|*
operator|++
name|av
expr_stmt|;
block|}
break|break;
default|default:
name|exit_with_usage
argument_list|(
name|myname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|real_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|real_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|eff_uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|eff_gid
operator|=
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|eff_uid
operator|!=
name|real_uid
condition|)
block|{
comment|/* if running with s-bit, we must install a special signal        * handler routine that resets the s-bit, so that we get a        * core file anyway.        */
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|CoreDump
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|CoreDump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ShellProg
operator|&&
operator|(
name|ShellProg
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ShellProg
operator|=
name|DefaultShell
expr_stmt|;
name|ShellArgs
index|[
literal|0
index|]
operator|=
name|ShellProg
expr_stmt|;
ifdef|#
directive|ifdef
name|NETHACK
name|nethackflag
operator|=
operator|(
name|getenv
argument_list|(
literal|"NETHACKOPTIONS"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
endif|#
directive|endif
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
comment|/* may or may not return a result. jw. */
if|if
condition|(
operator|(
name|LoginName
operator|=
name|getlogin
argument_list|()
operator|)
operator|&&
name|LoginName
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|ppp
operator|=
name|getpwnam
argument_list|(
name|LoginName
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|passwd
operator|*
operator|)
literal|0
condition|)
if|if
condition|(
name|ppp
operator|->
name|pw_uid
operator|!=
name|real_uid
condition|)
name|ppp
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ppp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ppp
operator|=
name|getpwuid
argument_list|(
name|real_uid
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"An alarm sounds through the dungeon...\nWarning, the kops are coming."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"getpwuid() can't identify your account!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|LoginName
operator|=
name|ppp
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|home
operator|==
literal|0
operator|||
operator|*
name|home
operator|==
literal|'\0'
condition|)
name|home
operator|=
name|ppp
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|LoginName
argument_list|)
operator|>
literal|20
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"LoginName too long - sorry."
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|home
argument_list|)
operator|>
name|MAXPATH
operator|-
literal|25
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"$HOME too long - sorry."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PASSWORD
name|strcpy
argument_list|(
name|Password
argument_list|,
name|ppp
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ttyname implies isatty */
if|if
condition|(
operator|!
operator|(
name|attach_tty
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"You must play from a terminal."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Must be connected to a terminal."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|attach_tty
argument_list|)
operator|>=
name|MAXPATH
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"TtyName too long - sorry."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|secopen
argument_list|(
name|attach_tty
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Cannot open '%s' - please check."
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"attach_tty is %s\n"
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_MODE_T
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* well, unsigned never fails? jw. */
else|#
directive|else
if|if
condition|(
operator|(
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Cannot change umask to zero"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|SockDir
operator|=
name|getenv
argument_list|(
literal|"ISCREENDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|SockDir
operator|=
name|getenv
argument_list|(
literal|"SCREENDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SockDir
operator|&&
name|strlen
argument_list|(
name|SockDir
argument_list|)
operator|>=
name|MAXPATH
operator|-
literal|1
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"ridiculous long $(I)SCREENDIR - try again."
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SOCKDIR
if|if
condition|(
name|SockDir
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|SockPath
argument_list|,
literal|"%s/.iscreen"
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|SockDir
operator|=
name|SockPath
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|SockDir
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|SockDir
argument_list|,
name|F_OK
argument_list|)
condition|)
block|{
if|if
condition|(
name|UserContext
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|SockDir
argument_list|,
literal|0700
argument_list|)
condition|)
name|UserReturn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|UserReturn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|UserStatus
argument_list|()
operator|<=
literal|0
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Cannot make directory '%s'"
argument_list|,
name|SockDir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SockDir
operator|!=
name|SockPath
condition|)
name|strcpy
argument_list|(
name|SockPath
argument_list|,
name|SockDir
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOCKDIR
else|else
block|{
name|SockDir
operator|=
name|SOCKDIR
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|SockDir
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|SockDir
argument_list|,
name|eff_uid
condition|?
literal|0777
else|:
literal|0755
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Cannot make directory '%s'"
argument_list|,
name|SockDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|eff_uid
condition|?
literal|0777
else|:
literal|0755
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
operator|)
operator|!=
name|n
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Directory '%s' must have mode %03o."
argument_list|,
name|SockDir
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|SockPath
argument_list|,
literal|"%s/S-%s"
argument_list|,
name|SockDir
argument_list|,
name|LoginName
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|SockPath
argument_list|,
name|F_OK
argument_list|)
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|SockPath
argument_list|,
literal|0700
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Cannot make directory '%s'"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|SockPath
argument_list|,
name|real_uid
argument_list|,
name|real_gid
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Cannot access %s"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s is not a directory."
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|real_uid
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"You are not the owner of %s."
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
operator|)
operator|!=
literal|0700
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Directory %s must have mode 700."
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|SockPath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|SockNamePtr
operator|=
name|SockPath
operator|+
name|strlen
argument_list|(
name|SockPath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ISC
argument_list|)
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsnam
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"uname() failed, errno = %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|HostName
argument_list|,
name|utsnam
operator|.
name|nodename
argument_list|,
name|MAXSTR
argument_list|)
expr_stmt|;
name|HostName
index|[
operator|(
sizeof|sizeof
argument_list|(
name|utsnam
operator|.
name|nodename
argument_list|)
operator|<=
name|MAXSTR
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|utsnam
operator|.
name|nodename
argument_list|)
else|:
name|MAXSTR
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|HostName
argument_list|,
name|MAXSTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HostName
index|[
name|MAXSTR
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|=
name|index
argument_list|(
name|HostName
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|=
literal|'\0'
expr_stmt|;
name|GetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX
name|ospeed
operator|=
operator|(
name|short
operator|)
name|cfgetospeed
argument_list|(
operator|&
name|OldMode
operator|.
name|tio
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|TERMIO
name|ospeed
operator|=
operator|(
name|short
operator|)
name|OldMode
operator|.
name|m_ttyb
operator|.
name|sg_ospeed
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|debug1
argument_list|(
literal|"...setting extern short ospeed = %d\n"
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsflag
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|FindSocket
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* MakeClientSocket appended the last (Sock)Name there: */
operator|*
name|SockNamePtr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"This room is empty (%s)\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* NETHACK */
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"No Sockets found in %s\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
block|}
else|else
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%d Socket%s in %s.\n"
argument_list|,
name|i
argument_list|,
name|i
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|rflag
condition|)
block|{
name|debug
argument_list|(
literal|"screen -r: - is there anybody out there?\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHADOWPW
name|setspent
argument_list|()
expr_stmt|;
comment|/* open shadow file while we are still root */
endif|#
directive|endif
comment|/* SHADOWPW */
if|if
condition|(
name|Attach
argument_list|(
name|MSG_ATTACH
argument_list|)
condition|)
block|{
name|Attacher
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|debug
argument_list|(
literal|"screen -r: backend not responding -- still crying\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dflag
condition|)
block|{
operator|(
name|void
operator|)
name|Attach
argument_list|(
name|MSG_DETACH
argument_list|)
expr_stmt|;
name|DeadlyMsg
operator|=
literal|0
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"[%s %sdetached.]\n"
argument_list|,
name|SockName
argument_list|,
operator|(
name|dflag
operator|>
literal|1
condition|?
literal|"power "
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|mflag
operator|&&
operator|(
name|SockName
operator|=
name|getenv
argument_list|(
literal|"STY"
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|SockName
operator|!=
literal|'\0'
condition|)
block|{
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
name|s
operator|=
name|MakeClientSocket
argument_list|(
literal|1
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
literal|1
expr_stmt|;
name|av
operator|=
name|ShellArgs
expr_stmt|;
block|}
name|av
index|[
name|ac
index|]
operator|=
name|aka
expr_stmt|;
name|SendCreateMsg
argument_list|(
name|s
argument_list|,
name|ac
argument_list|,
name|av
argument_list|,
name|allflag
argument_list|,
name|default_flow
argument_list|,
name|loginflag
argument_list|,
name|default_histheight
argument_list|,
name|screenterm
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|BSDJOBS
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|)
if|if
condition|(
operator|(
name|DevTty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"/dev/tty"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|MasterPid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
break|break;
default|default:
name|sprintf
argument_list|(
name|socknamebuf
argument_list|,
literal|"%d.%s.%s"
argument_list|,
name|MasterPid
argument_list|,
name|stripdev
argument_list|(
name|attach_tty
argument_list|)
argument_list|,
name|HostName
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|socknamebuf
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
operator|*
name|ap
operator|==
literal|'/'
condition|)
operator|*
name|ap
operator|=
literal|'-'
expr_stmt|;
name|SockName
operator|=
name|socknamebuf
expr_stmt|;
ifdef|#
directive|ifdef
name|SHADOWPW
name|setspent
argument_list|()
expr_stmt|;
comment|/* open shadow file while we are still root */
endif|#
directive|endif
comment|/* SHADOWPW */
name|Attacher
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dfp
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dfp
operator|=
name|fopen
argument_list|(
literal|"/tmp/debug/screen.back"
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dfp
operator|=
name|stderr
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
literal|"/tmp/debug/screen.back"
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug
argument_list|(
literal|"-- screen.back debug started\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|av0
operator|+
name|strlen
argument_list|(
name|av0
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ap
operator|>=
name|av0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"screen"
argument_list|,
name|ap
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|ap
argument_list|,
literal|"SCREEN"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* name this process "SCREEN-BACKEND" */
break|break;
block|}
name|ap
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|<
name|av0
condition|)
operator|*
name|av0
operator|=
literal|'S'
expr_stmt|;
name|AttacherPid
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|socknamebuf
argument_list|,
literal|"%d.%s.%s"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|stripdev
argument_list|(
name|attach_tty
argument_list|)
argument_list|,
name|HostName
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|socknamebuf
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
operator|*
name|ap
operator|==
literal|'/'
condition|)
operator|*
name|ap
operator|=
literal|'-'
expr_stmt|;
name|SockName
operator|=
name|socknamebuf
expr_stmt|;
name|ServerSocket
operator|=
name|s
operator|=
name|MakeServerSocket
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ETCSCREENRC
if|if
condition|(
operator|(
name|ap
operator|=
name|getenv
argument_list|(
literal|"SYSSCREENRC"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|StartRc
argument_list|(
name|ETCSCREENRC
argument_list|)
expr_stmt|;
else|else
name|StartRc
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|StartRc
argument_list|(
name|RcFileName
argument_list|)
expr_stmt|;
name|InitTermcap
argument_list|()
expr_stmt|;
name|InitTerm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MakeNewEnv
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|display_tty
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
ifdef|#
directive|ifdef
name|apollo
name|ReInitUtmp
argument_list|()
expr_stmt|;
else|#
directive|else
name|InitUtmp
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOADAV
ifdef|#
directive|ifdef
name|NeXT
name|InitNeXTLoadAvg
argument_list|()
expr_stmt|;
comment|/* NeXT load average */
else|#
directive|else
name|InitKmem
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !NeXT */
endif|#
directive|endif
comment|/* LOADAV */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SigHup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|Finit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|Finit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|Finit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|InitKeytab
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ETCSCREENRC
if|if
condition|(
operator|(
name|ap
operator|=
name|getenv
argument_list|(
literal|"SYSSCREENRC"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FinishRc
argument_list|(
name|ETCSCREENRC
argument_list|)
expr_stmt|;
else|else
name|FinishRc
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FinishRc
argument_list|(
name|RcFileName
argument_list|)
expr_stmt|;
comment|/* Note: SetMode must be called _after_ FinishRc (flow is set there).    */
name|SetMode
argument_list|(
operator|&
name|OldMode
argument_list|,
operator|&
name|NewMode
argument_list|)
expr_stmt|;
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|NewMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginflag
operator|==
operator|-
literal|1
condition|)
name|loginflag
operator|=
name|LOGINDEFAULT
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
literal|1
expr_stmt|;
name|av
operator|=
name|ShellArgs
expr_stmt|;
if|if
condition|(
operator|!
name|aka
condition|)
name|aka
operator|=
name|shellaka
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HasWindow
condition|)
block|{
name|debug
argument_list|(
literal|"We open one default window, as screenrc did not specify one.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MakeWindow
argument_list|(
name|aka
argument_list|,
name|av
argument_list|,
name|allflag
argument_list|,
name|default_flow
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|loginflag
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Finit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|default_startup
condition|)
name|display_copyright
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SigChld
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SigChld
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SigInt
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rflag
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"I can't seem to find a... Hey, wait a minute!  Here comes a screen now."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"New screen..."
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
block|}
name|brktty
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/*        * check to see if message line should be removed        */
if|if
condition|(
name|status
condition|)
block|{
name|int
name|time_left
decl_stmt|;
name|debug
argument_list|(
literal|"checking status...\n"
argument_list|)
expr_stmt|;
name|time_left
operator|=
name|TimeDisplayed
operator|+
operator|(
name|BellDisplayed
condition|?
name|VBellWait
else|:
name|MsgWait
operator|)
operator|-
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_left
operator|>
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|time_left
expr_stmt|;
name|debug
argument_list|(
literal|" not yet.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|" removing now.\n"
argument_list|)
expr_stmt|;
name|RemoveStatus
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*        * check for I/O on all available I/O descriptors        */
name|FD_ZERO
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuf_ct
operator|>
literal|0
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAXWIN
condition|;
name|n
operator|++
control|)
ifdef|#
directive|ifdef
name|COPY_PASTE
comment|/* wrong here? jw. */
if|if
condition|(
name|inlen
index|[
name|n
index|]
operator|>
literal|0
operator|||
operator|(
name|pastelen
operator|>
literal|0
operator|&&
name|n
operator|==
name|ForeNum
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|inlen
index|[
name|n
index|]
operator|>
literal|0
condition|)
endif|#
directive|endif
name|FD_SET
argument_list|(
name|wtab
index|[
name|n
index|]
operator|->
name|ptyfd
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Detached
condition|)
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|WinList
init|;
name|n
operator|!=
operator|-
literal|1
condition|;
name|n
operator|=
name|p
operator|->
name|WinLink
control|)
block|{
name|p
operator|=
name|wtab
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|active
operator|&&
name|status
operator|&&
operator|!
name|BellDisplayed
operator|&&
operator|!
name|HS
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|outlen
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|in_ovl
operator|&&
name|ovl_blockfore
operator|&&
name|n
operator|==
name|ForeNum
condition|)
continue|continue;
name|FD_SET
argument_list|(
name|p
operator|->
name|ptyfd
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|GotSignal
operator|&&
operator|!
name|status
condition|)
block|{
name|SigHandler
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|nsel
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|e
argument_list|,
operator|(
name|status
operator|)
condition|?
operator|&
name|tv
else|:
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug1
argument_list|(
literal|"Bad select - errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|Finit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|GotSignal
operator|||
name|status
operator|)
operator|&&
operator|!
name|InterruptPlease
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
name|InterruptPlease
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"Backend received interrupt\n"
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|intrc
expr_stmt|;
name|write
argument_list|(
name|wtab
index|[
name|ForeNum
index|]
operator|->
name|ptyfd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"Backend wrote interrupt to %d\n"
argument_list|,
name|ForeNum
argument_list|)
expr_stmt|;
name|InterruptPlease
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GotSignal
operator|&&
operator|!
name|status
condition|)
block|{
name|SigHandler
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Process a client connect attempt and message */
if|if
condition|(
name|nsel
operator|&&
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|nsel
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|HS
condition|)
name|RemoveStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_ovl
condition|)
block|{
name|SetOvlCurr
argument_list|()
expr_stmt|;
call|(
modifier|*
name|ovl_process
call|)
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We have to abort first!! */
name|CheckScreenSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Change fore */
name|DeadlyMsg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"KAABLAMM!!!  You triggered a land mine!"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Aborted because of window change or message."
argument_list|)
expr_stmt|;
block|}
else|else
name|CheckScreenSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Change fore */
name|ReceiveMsg
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*        * Write the stored user input to the window descriptors first.        * We do not want to choke, if he types fast.        */
if|if
condition|(
name|nsel
operator|&&
name|inbuf_ct
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAXWIN
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|inlen
index|[
name|n
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|tmp
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|ptyfd
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tmp
argument_list|,
operator|&
name|w
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|write
argument_list|(
name|tmp
argument_list|,
name|inbuf
index|[
name|n
index|]
argument_list|,
name|inlen
index|[
name|n
index|]
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|inlen
index|[
name|n
index|]
operator|-=
name|len
operator|)
operator|==
literal|0
condition|)
name|inbuf_ct
operator|--
expr_stmt|;
name|bcopy
argument_list|(
name|inbuf
index|[
name|n
index|]
operator|+
name|len
argument_list|,
name|inbuf
index|[
name|n
index|]
argument_list|,
name|inlen
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|nsel
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
comment|/* Read, process, and store the user input */
if|if
condition|(
name|nsel
operator|&&
name|FD_ISSET
argument_list|(
literal|0
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|nsel
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|HS
condition|)
name|RemoveStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|ESCseen
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|Esc
expr_stmt|;
name|buflen
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|IOSIZE
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ESCseen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|buflen
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|IOSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
block|{
name|debug1
argument_list|(
literal|"Read error: %d - SigHup()ing!\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|SigHup
argument_list|(
name|SIGARG
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"Found EOF - SigHup()ing!\n"
argument_list|)
expr_stmt|;
name|SigHup
argument_list|(
name|SIGARG
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|in_ovl
condition|)
block|{
name|SetOvlCurr
argument_list|()
expr_stmt|;
call|(
modifier|*
name|ovl_process
call|)
argument_list|(
operator|&
name|bufp
argument_list|,
operator|&
name|buflen
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|ForeNum
expr_stmt|;
name|len
operator|=
name|inlen
index|[
name|n
index|]
expr_stmt|;
name|bufp
operator|=
name|ProcessInput
argument_list|(
name|bufp
argument_list|,
operator|&
name|buflen
argument_list|,
name|inbuf
index|[
name|n
index|]
argument_list|,
operator|&
name|inlen
index|[
name|n
index|]
argument_list|,
sizeof|sizeof
expr|*
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlen
index|[
name|n
index|]
operator|>
literal|0
operator|&&
name|len
operator|==
literal|0
condition|)
name|inbuf_ct
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|inbuf_ct
operator|>
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|GotSignal
operator|&&
operator|!
name|status
condition|)
block|{
name|SigHandler
argument_list|()
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|COPY_PASTE
comment|/* Write the copybuffer contents first, if any. jw. */
if|if
condition|(
name|pastelen
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|ForeNum
expr_stmt|;
name|debug1
argument_list|(
literal|"writing pastebuffer (%d)\n"
argument_list|,
name|pastelen
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|ptyfd
expr_stmt|;
if|if
condition|(
comment|/* FD_ISSET(tmp,&w)&& */
operator|(
name|len
operator|=
name|write
argument_list|(
name|tmp
argument_list|,
name|pastebuffer
argument_list|,
name|pastelen
operator|>
name|IOSIZE
condition|?
name|IOSIZE
else|:
name|pastelen
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|pastebuffer
operator|+=
name|len
expr_stmt|;
name|pastelen
operator|-=
name|len
expr_stmt|;
name|debug1
argument_list|(
literal|"%d bytes pasted\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|slowpaste
operator|>
literal|0
condition|)
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|debug1
argument_list|(
literal|"slowpaste %d\n"
argument_list|,
name|slowpaste
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|slowpaste
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
block|}
comment|/*  	   * We could not paste? Let's see if the pty did echo the lot. 	   * Then continue by processing some pty output. 	   */
block|}
endif|#
directive|endif
if|if
condition|(
name|GotSignal
operator|&&
operator|!
name|status
condition|)
block|{
name|SigHandler
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Read and process the output from the window descriptors */
for|for
control|(
name|n
operator|=
name|WinList
init|;
name|n
operator|!=
operator|-
literal|1
condition|;
name|n
operator|=
name|p
operator|->
name|WinLink
control|)
block|{
name|p
operator|=
name|wtab
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|in_ovl
operator|&&
name|ovl_blockfore
operator|&&
name|n
operator|==
name|ForeNum
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|outlen
condition|)
name|WriteString
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|outbuf
argument_list|,
name|p
operator|->
name|outlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nsel
operator|&&
name|FD_ISSET
argument_list|(
name|p
operator|->
name|ptyfd
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|nsel
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|p
operator|->
name|ptyfd
argument_list|,
name|buf
argument_list|,
name|IOSIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EWOULDBLOCK
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|len
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|TIOCPKT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
name|debug1
argument_list|(
literal|"PAKET %x\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|&
name|TIOCPKT_NOSTOP
condition|)
block|{
name|NewAutoFlow
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|&
name|TIOCPKT_DOSTOP
condition|)
block|{
name|NewAutoFlow
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|WriteString
argument_list|(
name|p
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TIOCPKT&& !sgi */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|WriteString
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCPKT&& !sgi */
block|}
if|if
condition|(
name|p
operator|->
name|bell
operator|==
name|BELL_ON
condition|)
block|{
name|p
operator|->
name|bell
operator|=
name|BELL_DONE
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
name|MakeWinMsg
argument_list|(
name|BellString
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|monitor
operator|==
name|MON_FOUND
condition|)
name|p
operator|->
name|monitor
operator|=
name|MON_DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|bell
operator|==
name|BELL_VISUAL
condition|)
block|{
if|if
condition|(
operator|!
name|BellDisplayed
condition|)
block|{
name|p
operator|->
name|bell
operator|=
name|BELL_DONE
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
name|VisualBellString
argument_list|)
expr_stmt|;
name|BellDisplayed
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|monitor
operator|==
name|MON_FOUND
condition|)
block|{
name|p
operator|->
name|monitor
operator|=
name|MON_DONE
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
name|MakeWinMsg
argument_list|(
name|ActivityString
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GotSignal
operator|&&
operator|!
name|status
condition|)
name|SigHandler
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|nsel
condition|)
name|debug1
argument_list|(
literal|"Left over nsel: %d\n"
argument_list|,
name|nsel
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|SigHandler
parameter_list|()
block|{
name|struct
name|stat
name|st
decl_stmt|;
while|while
condition|(
name|GotSignal
condition|)
block|{
name|GotSignal
operator|=
literal|0
expr_stmt|;
name|DoWait
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SigChld
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug1
argument_list|(
literal|"SigHandler: Yuck! cannot stat '%s'\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RecoverSocket
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"SCREEN cannot recover from corrupt Socket, bye\n"
argument_list|)
expr_stmt|;
name|Finit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|debug1
argument_list|(
literal|"'%s' reconstructed\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
block|}
else|else
name|debug2
argument_list|(
literal|"SigHandler: stat '%s' o.k. (%03o)\n"
argument_list|,
name|SockPath
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|FEpanic
decl_stmt|;
end_decl_stmt

begin_function
name|SIGTYPE
name|FEChld
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|FEpanic
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|SIGTYPE
name|SigChld
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|debug
argument_list|(
literal|"SigChld()\n"
argument_list|)
expr_stmt|;
name|GotSignal
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|SIGTYPE
name|SigHup
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|debug
argument_list|(
literal|"SigHup()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_detach
condition|)
name|Detach
argument_list|(
name|D_DETACH
argument_list|)
expr_stmt|;
else|else
name|Finit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * the frontend's Interrupt handler  * we forward SIGINT to the backend  */
end_comment

begin_function
specifier|static
name|SIGTYPE
name|AttacherSigInt
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|Kill
argument_list|(
name|MasterPid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|AttacherSigInt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
name|SIGTYPE
operator|)
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*   * the backend's Interrupt handler  * we cannot insert the intrc directly, as we never know  * if fore and ForeNum are valid.  */
end_comment

begin_function
specifier|static
name|SIGTYPE
name|SigInt
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
if|#
directive|if
name|HAZARDOUS
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"SigInt()\n"
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|char
operator|)
name|intrc
expr_stmt|;
name|inlen
index|[
name|ForeNum
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fore
operator|&&
operator|!
name|in_ovl
condition|)
name|write
argument_list|(
name|fore
operator|->
name|ptyfd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|debug
argument_list|(
literal|"SigInt() careful\n"
argument_list|)
expr_stmt|;
name|InterruptPlease
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SigInt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|SIGTYPE
name|CoreDump
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
literal|"core"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n[screen caught signal %d.%s]\r\n"
argument_list|,
name|sig
argument_list|,
ifdef|#
directive|ifdef
name|SHADOWPW
literal|""
else|#
directive|else
comment|/* SHADOWPW */
literal|" (core dumped)"
endif|#
directive|endif
comment|/* SHADOWPW */
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|Kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHADOWPW
name|eexit
argument_list|(
name|sig
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SHADOWPW */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SHADOWPW */
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|DoWait
parameter_list|()
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|next
decl_stmt|,
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDWAIT
name|union
name|wait
name|wstat
decl_stmt|;
else|#
directive|else
name|int
name|wstat
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSDJOBS
ifndef|#
directive|ifndef
name|BSDWAIT
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|wstat
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|)
operator|)
operator|>
literal|0
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|wstat
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
endif|#
directive|endif
else|#
directive|else
comment|/* BSDJOBS */
while|while
condition|(
operator|(
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|wstat
argument_list|)
operator|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
break|break;
if|if
condition|(
name|pid
operator|>=
literal|0
condition|)
endif|#
directive|endif
comment|/* BSDJOBS */
block|{
for|for
control|(
name|n
operator|=
name|WinList
init|;
name|n
operator|!=
operator|-
literal|1
condition|;
name|n
operator|=
name|next
control|)
block|{
name|next
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|wtab
index|[
name|n
index|]
operator|->
name|wpid
condition|)
block|{
ifdef|#
directive|ifdef
name|BSDJOBS
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"You regain consciousness."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* NETHACK */
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Child has been stopped, restarting."
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"WIFSTOPPED: %d SIGCONT\n"
argument_list|,
name|wtab
index|[
name|n
index|]
operator|->
name|wpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|killpg
argument_list|(
name|wtab
index|[
name|n
index|]
operator|->
name|wpid
argument_list|,
name|SIGCONT
argument_list|)
condition|)
name|kill
argument_list|(
name|wtab
index|[
name|n
index|]
operator|->
name|wpid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|KillWindow
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|KillWindow
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Remove window from linked list.    */
if|if
condition|(
name|n
operator|==
name|WinList
condition|)
comment|/* WinList = ForeNum */
block|{
name|RemoveStatus
argument_list|()
expr_stmt|;
name|WinList
operator|=
name|fore
operator|->
name|WinLink
expr_stmt|;
name|fore
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|WinList
expr_stmt|;
while|while
condition|(
name|wtab
index|[
name|i
index|]
operator|->
name|WinLink
operator|!=
name|n
condition|)
name|i
operator|=
name|wtab
index|[
name|i
index|]
operator|->
name|WinLink
expr_stmt|;
name|wtab
index|[
name|i
index|]
operator|->
name|WinLink
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
expr_stmt|;
block|}
name|FreeWindow
argument_list|(
name|wtab
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|wtab
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inlen
index|[
name|n
index|]
operator|>
literal|0
condition|)
block|{
name|inlen
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|inbuf_ct
operator|--
expr_stmt|;
block|}
comment|/*    * If the foreground window disappeared check the head of the linked list    * of windows for the most recently used window. If no window is alive at    * all, exit.    */
if|if
condition|(
name|WinList
operator|==
operator|-
literal|1
condition|)
name|Finit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fore
condition|)
name|SwitchWindow
argument_list|(
name|WinList
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SIGTYPE
name|Finit
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"Finit(%d);\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|WinList
init|;
name|n
operator|!=
operator|-
literal|1
condition|;
name|n
operator|=
name|next
control|)
block|{
name|next
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
expr_stmt|;
name|FreeWindow
argument_list|(
name|wtab
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|FinitTerm
argument_list|()
expr_stmt|;
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
name|RestoreLoginSlot
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n[screen is terminating]\n"
argument_list|)
expr_stmt|;
name|freetty
argument_list|()
expr_stmt|;
if|if
condition|(
name|ServerSocket
operator|!=
operator|-
literal|1
condition|)
block|{
name|debug1
argument_list|(
literal|"we unlink(%s)\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SockPath
argument_list|)
expr_stmt|;
block|}
name|Kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|eexit
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
if|if
condition|(
name|ServerSocket
operator|!=
operator|-
literal|1
condition|)
block|{
name|debug1
argument_list|(
literal|"we unlink(%s)\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SockPath
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|InitKeytab
parameter_list|()
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ktab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ktab
argument_list|)
condition|;
name|i
operator|++
control|)
name|ktab
index|[
name|i
index|]
operator|.
name|type
operator|=
name|KEY_IGNORE
expr_stmt|;
name|ktab
index|[
literal|'h'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'h'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_HARDCOPY
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
name|ktab
index|[
literal|'z'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'z'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_SUSPEND
expr_stmt|;
endif|#
directive|endif
name|ktab
index|[
literal|'c'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'c'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_SHELL
expr_stmt|;
name|ktab
index|[
literal|' '
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|' '
argument_list|)
index|]
operator|.
name|type
operator|=
name|ktab
index|[
literal|'n'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'n'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_NEXT
expr_stmt|;
name|ktab
index|[
literal|'-'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
literal|'p'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'p'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_PREV
expr_stmt|;
name|ktab
index|[
literal|'k'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'k'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_KILL
expr_stmt|;
name|ktab
index|[
literal|'l'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'l'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_REDISPLAY
expr_stmt|;
name|ktab
index|[
literal|'w'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'w'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_WINDOWS
expr_stmt|;
name|ktab
index|[
literal|'v'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'v'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_VERSION
expr_stmt|;
name|ktab
index|[
literal|'q'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'q'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_XON
expr_stmt|;
name|ktab
index|[
literal|'s'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'s'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_XOFF
expr_stmt|;
name|ktab
index|[
literal|'t'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'t'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_TIME
expr_stmt|;
name|ktab
index|[
literal|'i'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'i'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_INFO
expr_stmt|;
name|ktab
index|[
literal|'m'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'m'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_LASTMSG
expr_stmt|;
name|ktab
index|[
literal|'A'
index|]
operator|.
name|type
operator|=
name|KEY_AKA
operator|,
name|ktab
index|[
literal|'A'
index|]
operator|.
name|args
operator|=
name|NULL
expr_stmt|;
name|ktab
index|[
literal|'L'
index|]
operator|.
name|type
operator|=
name|KEY_LOGIN
expr_stmt|;
name|ktab
index|[
literal|','
index|]
operator|.
name|type
operator|=
name|KEY_LICENSE
expr_stmt|;
name|ktab
index|[
literal|'W'
index|]
operator|.
name|type
operator|=
name|KEY_WIDTH
expr_stmt|;
name|ktab
index|[
literal|'.'
index|]
operator|.
name|type
operator|=
name|KEY_TERMCAP
expr_stmt|;
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'\\'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_QUIT
expr_stmt|;
name|ktab
index|[
literal|'d'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'d'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_DETACH
expr_stmt|;
name|ktab
index|[
literal|'r'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'r'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_WRAP
expr_stmt|;
name|ktab
index|[
literal|'f'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'f'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_FLOW
expr_stmt|;
name|ktab
index|[
literal|'C'
index|]
operator|.
name|type
operator|=
name|KEY_CLEAR
expr_stmt|;
name|ktab
index|[
literal|'Z'
index|]
operator|.
name|type
operator|=
name|KEY_RESET
expr_stmt|;
name|ktab
index|[
literal|'H'
index|]
operator|.
name|type
operator|=
name|KEY_LOGTOGGLE
expr_stmt|;
if|if
condition|(
name|Esc
operator|!=
name|MetaEsc
condition|)
name|ktab
index|[
name|Esc
index|]
operator|.
name|type
operator|=
name|KEY_OTHER
expr_stmt|;
else|else
name|ktab
index|[
name|Esc
index|]
operator|.
name|type
operator|=
name|KEY_IGNORE
expr_stmt|;
name|ktab
index|[
literal|'M'
index|]
operator|.
name|type
operator|=
name|KEY_MONITOR
expr_stmt|;
name|ktab
index|[
literal|'?'
index|]
operator|.
name|type
operator|=
name|KEY_HELP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
name|ktab
index|[
literal|'0'
operator|+
name|i
index|]
operator|.
name|type
operator|=
operator|(
expr|enum
name|keytype
operator|)
operator|(
name|i
operator|+
operator|(
name|int
operator|)
name|KEY_0
operator|)
expr_stmt|;
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'G'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_VBELL
expr_stmt|;
name|ktab
index|[
literal|':'
index|]
operator|.
name|type
operator|=
name|KEY_COLON
expr_stmt|;
ifdef|#
directive|ifdef
name|COPY_PASTE
name|ktab
index|[
literal|'['
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'['
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_COPY
expr_stmt|;
name|ktab
index|[
literal|']'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|']'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_PASTE
expr_stmt|;
name|ktab
index|[
literal|'{'
index|]
operator|.
name|type
operator|=
name|KEY_HISTORY
expr_stmt|;
name|ktab
index|[
literal|'}'
index|]
operator|.
name|type
operator|=
name|KEY_HISTNEXT
expr_stmt|;
name|ktab
index|[
literal|'>'
index|]
operator|.
name|type
operator|=
name|KEY_WRITE_BUFFER
expr_stmt|;
name|ktab
index|[
literal|'<'
index|]
operator|.
name|type
operator|=
name|KEY_READ_BUFFER
expr_stmt|;
name|ktab
index|[
literal|'='
index|]
operator|.
name|type
operator|=
name|KEY_REMOVE_BUFFERS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POW_DETACH
name|ktab
index|[
literal|'D'
index|]
operator|.
name|type
operator|=
name|KEY_POW_DETACH
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCK
name|ktab
index|[
literal|'x'
index|]
operator|.
name|type
operator|=
name|ktab
index|[
name|Ctrl
argument_list|(
literal|'x'
argument_list|)
index|]
operator|.
name|type
operator|=
name|KEY_LOCK
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * this is a braindamaged hack: if (obuf == NULL) then we provided  * a key_type as a second char in ibuf. not a key.  */
end_comment

begin_function
name|char
modifier|*
name|ProcessInput
parameter_list|(
name|ibuf
parameter_list|,
name|pilen
parameter_list|,
name|obuf
parameter_list|,
name|polen
parameter_list|,
name|obuf_size
parameter_list|)
name|char
modifier|*
name|ibuf
decl_stmt|,
decl|*
name|obuf
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
modifier|*
name|pilen
decl_stmt|,
modifier|*
name|polen
decl_stmt|,
name|obuf_size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|enum
name|keytype
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|newwidth
decl_stmt|;
if|if
condition|(
operator|!
name|obuf
condition|)
name|obuf_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ibuf
operator|,
name|p
operator|=
name|obuf
operator|+
operator|*
name|polen
init|;
operator|*
name|pilen
operator|>
literal|0
condition|;
operator|--
operator|*
name|pilen
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|Esc
condition|)
block|{
name|debug2
argument_list|(
literal|"'%c %c "
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"%c %c' "
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pilen
operator|>
literal|1
condition|)
block|{
operator|--
operator|*
name|pilen
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GOULD_NP1
argument_list|)
name|k
operator|=
operator|(
name|obuf
operator|)
condition|?
operator|(
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|type
operator|)
else|:
operator|(
expr|enum
name|keytype
operator|)
call|(
name|int
call|)
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|k
operator|=
operator|(
name|obuf
operator|)
condition|?
operator|(
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|type
operator|)
else|:
operator|(
expr|enum
name|keytype
operator|)
operator|(
operator|*
name|s
operator|)
expr_stmt|;
endif|#
directive|endif
name|debug2
argument_list|(
literal|"Processinput C-A %02x '%c' "
argument_list|,
name|k
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|obuf
operator|)
condition|?
literal|"std"
else|:
literal|"NOOBUF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|MetaEsc
condition|)
block|{
if|if
condition|(
operator|*
name|polen
operator|<
name|obuf_size
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|Esc
expr_stmt|;
operator|++
operator|*
name|polen
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|k
operator|>=
operator|(
name|int
operator|)
name|KEY_0
operator|&&
operator|(
name|int
operator|)
name|k
operator|<=
operator|(
name|int
operator|)
name|KEY_9
condition|)
name|SwitchWindow
argument_list|(
operator|(
name|int
operator|)
name|k
operator|-
operator|(
name|int
operator|)
name|KEY_0
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|KEY_TERMCAP
case|:
name|WriteFile
argument_list|(
name|DUMP_TERMCAP
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_HARDCOPY
case|:
name|WriteFile
argument_list|(
name|DUMP_HARDCOPY
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_LOGTOGGLE
case|:
name|LogToggle
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BSDJOBS
case|case
name|KEY_SUSPEND
case|:
operator|*
name|pilen
operator|=
literal|0
expr_stmt|;
name|Detach
argument_list|(
name|D_STOP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|KEY_SHELL
case|:
name|debug
argument_list|(
literal|"calling MakeWindow with shell\n"
argument_list|)
expr_stmt|;
name|MakeWindow
argument_list|(
name|shellaka
argument_list|,
name|ShellArgs
argument_list|,
name|allflag
argument_list|,
name|default_flow
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|loginflag
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_NEXT
case|:
if|if
condition|(
name|MoreWindows
argument_list|()
condition|)
name|SwitchWindow
argument_list|(
name|NextWindow
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_PREV
case|:
if|if
condition|(
name|MoreWindows
argument_list|()
condition|)
name|SwitchWindow
argument_list|(
name|PreviousWindow
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_KILL
case|:
name|KillWindow
argument_list|(
name|n
operator|=
name|ForeNum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"You destroy poor window %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|KEY_QUIT
case|:
name|Finit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|KEY_DETACH
case|:
operator|*
name|pilen
operator|=
literal|0
expr_stmt|;
name|Detach
argument_list|(
name|D_DETACH
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|POW_DETACH
case|case
name|KEY_POW_DETACH
case|:
operator|*
name|pilen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|obuf
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
operator|*
name|s
condition|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
literal|"\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RemoveStatus
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"The blast of disintegration whizzes by you!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|Detach
argument_list|(
name|D_POWER
argument_list|)
expr_stmt|;
comment|/* detach and kill Attacher's 				      * parent	 */
break|break;
endif|#
directive|endif
case|case
name|KEY_REDISPLAY
case|:
name|Activate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_WINDOWS
case|:
name|ShowWindows
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_VERSION
case|:
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"screen %d.%.2d.%.2d%s (%s) %s"
argument_list|,
name|REV
argument_list|,
name|VERS
argument_list|,
name|PATCHLEVEL
argument_list|,
name|STATE
argument_list|,
name|ORIGIN
argument_list|,
name|DATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_TIME
case|:
name|ShowTime
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_INFO
case|:
name|ShowInfo
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_OTHER
case|:
if|if
condition|(
name|MoreWindows
argument_list|()
condition|)
name|SwitchWindow
argument_list|(
name|fore
operator|->
name|WinLink
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_XON
case|:
if|if
condition|(
operator|*
name|polen
operator|<
name|obuf_size
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|Ctrl
argument_list|(
literal|'q'
argument_list|)
expr_stmt|;
operator|++
operator|*
name|polen
expr_stmt|;
block|}
break|break;
case|case
name|KEY_XOFF
case|:
if|if
condition|(
operator|*
name|polen
operator|<
name|obuf_size
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|Ctrl
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
operator|++
operator|*
name|polen
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|LOCK
case|case
name|KEY_LOCK
case|:
name|Detach
argument_list|(
name|D_LOCK
argument_list|)
expr_stmt|;
comment|/* do it micha's way */
break|break;
endif|#
directive|endif
case|case
name|KEY_WIDTH
case|:
if|if
condition|(
name|Z0
operator|||
name|WS
condition|)
block|{
if|if
condition|(
name|fore
operator|->
name|width
operator|==
name|Z0width
condition|)
name|newwidth
operator|=
name|Z1width
expr_stmt|;
elseif|else
if|if
condition|(
name|fore
operator|->
name|width
operator|==
name|Z1width
condition|)
name|newwidth
operator|=
name|Z0width
expr_stmt|;
elseif|else
if|if
condition|(
name|fore
operator|->
name|width
operator|>
operator|(
name|Z0width
operator|+
name|Z1width
operator|)
operator|/
literal|2
condition|)
name|newwidth
operator|=
name|Z0width
expr_stmt|;
else|else
name|newwidth
operator|=
name|Z1width
expr_stmt|;
name|ChangeWindowSize
argument_list|(
name|fore
argument_list|,
name|newwidth
argument_list|,
name|fore
operator|->
name|height
argument_list|)
expr_stmt|;
name|Activate
argument_list|(
name|fore
operator|->
name|norefresh
argument_list|)
expr_stmt|;
block|}
else|else
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Your termcap does not specify how to change the terminal's width."
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_LOGIN
case|:
name|SlotToggle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_AKA
case|:
if|if
condition|(
operator|!
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
condition|)
name|InputAKA
argument_list|()
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|fore
operator|->
name|cmd
operator|+
name|fore
operator|->
name|akapos
argument_list|,
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
index|[
literal|0
index|]
argument_list|,
literal|20
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_COLON
case|:
name|InputColon
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_LASTMSG
case|:
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|LastMsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_SET
case|:
name|DoSet
argument_list|(
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_SCREEN
case|:
name|debug3
argument_list|(
literal|"KEY_SCREEN DoSc(, ktab[%d].args(='%s','%s')...)\n"
argument_list|,
operator|*
name|s
argument_list|,
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
index|[
literal|0
index|]
argument_list|,
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DoScreen
argument_list|(
literal|"key"
argument_list|,
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_CREATE
case|:
name|debug2
argument_list|(
literal|"KEY_CREATE MaWi(0, ktab[%d].args(='%s')...)\n"
argument_list|,
operator|*
name|s
argument_list|,
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|MakeWindow
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ktab
index|[
operator|*
name|s
index|]
operator|.
name|args
argument_list|,
name|allflag
argument_list|,
name|default_flow
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|loginflag
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_WRAP
case|:
name|fore
operator|->
name|wrap
operator|=
operator|!
name|fore
operator|->
name|wrap
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%cwrap"
argument_list|,
name|fore
operator|->
name|wrap
condition|?
literal|'+'
else|:
literal|'-'
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_FLOW
case|:
if|if
condition|(
name|fore
operator|->
name|flow
operator|&
name|FLOW_AUTOFLAG
condition|)
name|fore
operator|->
name|flow
operator|=
operator|(
name|fore
operator|->
name|flow
operator|&
name|FLOW_AUTO
operator|)
operator||
name|FLOW_NOW
expr_stmt|;
elseif|else
if|if
condition|(
name|fore
operator|->
name|flow
operator|&
name|FLOW_NOW
condition|)
name|fore
operator|->
name|flow
operator|&=
operator|~
name|FLOW_NOW
expr_stmt|;
else|else
name|fore
operator|->
name|flow
operator|=
name|fore
operator|->
name|flow
condition|?
name|FLOW_AUTOFLAG
operator||
name|FLOW_AUTO
operator||
name|FLOW_NOW
else|:
name|FLOW_AUTOFLAG
expr_stmt|;
name|SetFlow
argument_list|(
name|fore
operator|->
name|flow
operator|&
name|FLOW_NOW
argument_list|)
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%cflow%s"
argument_list|,
operator|(
name|fore
operator|->
name|flow
operator|&
name|FLOW_NOW
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
operator|(
name|fore
operator|->
name|flow
operator|&
name|FLOW_AUTOFLAG
operator|)
condition|?
literal|"(auto)"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_CLEAR
case|:
if|if
condition|(
name|fore
operator|->
name|state
operator|==
name|LIT
condition|)
name|WriteString
argument_list|(
name|fore
argument_list|,
literal|"\033[H\033[J"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_RESET
case|:
if|if
condition|(
name|fore
operator|->
name|state
operator|==
name|LIT
condition|)
name|WriteString
argument_list|(
name|fore
argument_list|,
literal|"\033c"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_MONITOR
case|:
if|if
condition|(
name|fore
operator|->
name|monitor
operator|==
name|MON_OFF
condition|)
block|{
name|fore
operator|->
name|monitor
operator|=
name|MON_ON
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Window %d is now being monitored for all activity."
argument_list|,
name|ForeNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fore
operator|->
name|monitor
operator|=
name|MON_OFF
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Window %d is no longer being monitored for activity."
argument_list|,
name|ForeNum
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_HELP
case|:
name|display_help
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_LICENSE
case|:
name|display_copyright
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|COPY_PASTE
case|case
name|KEY_COPY
case|:
operator|(
name|void
operator|)
name|MarkRoutine
argument_list|(
name|PLAIN
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_HISTNEXT
case|:
if|if
condition|(
name|MarkRoutine
argument_list|(
name|CRAZY
argument_list|)
condition|)
if|if
condition|(
name|copybuffer
operator|!=
name|NULL
condition|)
block|{
name|pastelen
operator|=
name|copylen
expr_stmt|;
name|pastebuffer
operator|=
name|copybuffer
expr_stmt|;
name|debug
argument_list|(
literal|"histnext\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_HISTORY
case|:
if|if
condition|(
name|MarkRoutine
argument_list|(
name|TRICKY
argument_list|)
condition|)
if|if
condition|(
name|copybuffer
operator|!=
name|NULL
condition|)
block|{
name|pastelen
operator|=
name|copylen
expr_stmt|;
name|pastebuffer
operator|=
name|copybuffer
expr_stmt|;
name|debug1
argument_list|(
literal|"history new copylen: %d\n"
argument_list|,
name|pastelen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_PASTE
case|:
if|if
condition|(
name|copybuffer
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Nothing happens."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"empty buffer"
argument_list|)
expr_stmt|;
name|copylen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pastelen
operator|=
name|copylen
expr_stmt|;
name|pastebuffer
operator|=
name|copybuffer
expr_stmt|;
break|break;
case|case
name|KEY_WRITE_BUFFER
case|:
if|if
condition|(
name|copybuffer
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Nothing happens."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"empty buffer"
argument_list|)
expr_stmt|;
name|copylen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|WriteFile
argument_list|(
name|DUMP_EXCHANGE
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_READ_BUFFER
case|:
name|ReadFile
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_REMOVE_BUFFERS
case|:
name|KillBuffers
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* COPY_PASTE */
case|case
name|KEY_VBELL
case|:
if|if
condition|(
name|visual_bell
condition|)
block|{
name|visual_bell
operator|=
literal|0
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"switched to audible bell"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|visual_bell
operator|=
literal|1
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"switched to visual bell"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
else|else
name|ESCseen
operator|=
literal|1
expr_stmt|;
operator|--
operator|*
name|pilen
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|polen
operator|<
name|obuf_size
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|++
operator|*
name|polen
expr_stmt|;
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Send a terminal report as if it were typed. */
end_comment

begin_function
name|void
name|Report
parameter_list|(
name|wp
parameter_list|,
name|fmt
parameter_list|,
name|n1
parameter_list|,
name|n2
parameter_list|)
name|struct
name|win
modifier|*
name|wp
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
name|char
name|rbuf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|rbuf
argument_list|,
name|fmt
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAXWIN
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|wp
operator|==
name|wtab
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|inlen
index|[
name|n
index|]
operator|+
name|len
argument_list|)
operator|<=
sizeof|sizeof
expr|*
name|inbuf
condition|)
block|{
name|bcopy
argument_list|(
name|rbuf
argument_list|,
name|inbuf
index|[
name|n
index|]
operator|+
name|inlen
index|[
name|n
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlen
index|[
name|n
index|]
operator|==
literal|0
condition|)
name|inbuf_ct
operator|++
expr_stmt|;
name|inlen
index|[
name|n
index|]
operator|+=
name|len
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* for */
block|}
end_function

begin_function
name|void
name|SwitchWindow
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|debug1
argument_list|(
literal|"SwitchWindow %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtab
index|[
name|n
index|]
condition|)
block|{
name|ShowWindows
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wtab
index|[
name|n
index|]
operator|==
name|fore
condition|)
block|{
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"This IS window %d."
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|SetForeWindow
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Detached
operator|&&
operator|!
name|in_ovl
condition|)
name|Activate
argument_list|(
name|fore
operator|->
name|norefresh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetForeWindow
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/*    * If we come from another window, make it inactive.    */
if|if
condition|(
name|fore
condition|)
name|fore
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|ForeNum
operator|=
name|n
expr_stmt|;
name|fore
operator|=
name|wtab
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Detached
operator|&&
operator|!
name|in_ovl
condition|)
name|fore
operator|->
name|active
operator|=
literal|1
expr_stmt|;
comment|/*    * Place the window at the head of the most-recently-used list.    */
if|if
condition|(
operator|(
name|n
operator|=
name|WinList
operator|)
operator|!=
name|ForeNum
condition|)
block|{
comment|/*        * we had a bug here. we sometimes ran into n = -1; and crashed.        * (this is not the perfect fix. "if (...) break;" inserted. jw.)        */
while|while
condition|(
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
operator|!=
name|ForeNum
condition|)
block|{
if|if
condition|(
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
operator|==
operator|-
literal|1
condition|)
break|break;
name|n
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
expr_stmt|;
block|}
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
operator|=
name|fore
operator|->
name|WinLink
expr_stmt|;
name|fore
operator|->
name|WinLink
operator|=
name|WinList
expr_stmt|;
name|WinList
operator|=
name|ForeNum
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|NextWindow
parameter_list|()
block|{
specifier|register
name|struct
name|win
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|wtab
operator|+
name|ForeNum
operator|+
literal|1
init|;
name|pp
operator|!=
name|wtab
operator|+
name|ForeNum
condition|;
operator|++
name|pp
control|)
block|{
if|if
condition|(
name|pp
operator|==
name|wtab
operator|+
name|MAXWIN
condition|)
name|pp
operator|=
name|wtab
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
break|break;
block|}
return|return
name|pp
operator|-
name|wtab
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PreviousWindow
parameter_list|()
block|{
specifier|register
name|struct
name|win
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|wtab
operator|+
name|ForeNum
operator|-
literal|1
init|;
name|pp
operator|!=
name|wtab
operator|+
name|ForeNum
condition|;
operator|--
name|pp
control|)
block|{
if|if
condition|(
name|pp
operator|<
name|wtab
condition|)
name|pp
operator|=
name|wtab
operator|+
name|MAXWIN
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
break|break;
block|}
return|return
name|pp
operator|-
name|wtab
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MoreWindows
parameter_list|()
block|{
if|if
condition|(
name|fore
operator|->
name|WinLink
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"You cannot escape from window %d!"
argument_list|,
name|ForeNum
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"No other window."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeWindow
parameter_list|(
name|wp
parameter_list|)
name|struct
name|win
modifier|*
name|wp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UTMPOK
name|RemoveUtmp
argument_list|(
name|wp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUIDROOT
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|wp
operator|->
name|tty
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|wp
operator|->
name|tty
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|wp
operator|->
name|ptyfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|logfp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|wp
operator|->
name|logfp
argument_list|)
expr_stmt|;
name|ChangeWindowSize
argument_list|(
name|wp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|wp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|MakeWindow
parameter_list|(
name|prog
parameter_list|,
name|args
parameter_list|,
name|aflag
parameter_list|,
name|flowflag
parameter_list|,
name|StartAt
parameter_list|,
name|dir
parameter_list|,
name|lflag
parameter_list|,
name|histheight
parameter_list|,
name|term
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|,
decl|*
modifier|*
name|args
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|aflag
decl_stmt|,
name|flowflag
decl_stmt|,
name|StartAt
decl_stmt|,
name|lflag
decl_stmt|,
name|histheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if term is nonzero we assume it "vt100" or the like.. */
end_comment

begin_block
block|{
specifier|register
name|struct
name|win
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|f
decl_stmt|;
name|int
name|tf
decl_stmt|,
name|tlflag
decl_stmt|;
name|char
name|ebuf
index|[
literal|10
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|TIOCSWINSZ
name|char
name|libuf
index|[
literal|20
index|]
decl_stmt|,
name|cobuf
index|[
literal|20
index|]
decl_stmt|;
endif|#
directive|endif
name|char
name|tebuf
index|[
literal|25
index|]
decl_stmt|;
name|pp
operator|=
name|wtab
operator|+
name|StartAt
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|pp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|pp
operator|==
name|wtab
operator|+
name|MAXWIN
condition|)
name|pp
operator|=
name|wtab
expr_stmt|;
block|}
do|while
condition|(
name|pp
operator|!=
name|wtab
operator|+
name|StartAt
condition|)
do|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"No more windows."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|tlflag
operator|=
name|lflag
operator|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|tlflag
operator|=
name|loginflag
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|tlflag
operator|=
name|LOGINDEFAULT
expr_stmt|;
ifdef|#
directive|ifdef
name|USRLIMIT
comment|/*    * Count current number of users, if logging windows in.    */
if|if
condition|(
name|tlflag
operator|==
literal|1
operator|&&
name|CountUsers
argument_list|()
operator|>=
name|USRLIMIT
condition|)
block|{
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"User limit reached.  Window will not be logged in."
argument_list|)
expr_stmt|;
name|tlflag
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|n
operator|=
name|pp
operator|-
name|wtab
expr_stmt|;
name|debug1
argument_list|(
literal|"Makewin creating %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|OpenPTY
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"No more PTYs."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|SYSV
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|f
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|f
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCPKT
block|{
ifdef|#
directive|ifdef
name|sgi
comment|/*        * on IRIX 3.3, regardless of stream head's read mode (RNORM/RMSGN/RMSGD)        * we loose data in TIOCPKT mode if our buffer is too small (IOSIZE)        * to hold the whole packet at first read().        * (Marc Boucher)        */
name|int
name|flag
init|=
literal|0
decl_stmt|;
else|#
directive|else
comment|/* sgi */
name|int
name|flag
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* sgi */
if|if
condition|(
name|ioctl
argument_list|(
name|f
argument_list|,
name|TIOCPKT
argument_list|,
operator|&
name|flag
argument_list|)
condition|)
block|{
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"TIOCPKT ioctl"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|win
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|win
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|Msg_nomem
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|win
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ptyfd
operator|=
name|f
expr_stmt|;
name|p
operator|->
name|aflag
operator|=
name|aflag
expr_stmt|;
if|if
condition|(
name|flowflag
operator|<
literal|0
condition|)
name|flowflag
operator|=
name|default_flow
expr_stmt|;
name|p
operator|->
name|flow
operator|=
name|flowflag
operator||
operator|(
operator|(
name|flowflag
operator|&
name|FLOW_AUTOFLAG
operator|)
condition|?
operator|(
name|FLOW_AUTO
operator||
name|FLOW_NOW
operator|)
else|:
name|FLOW_AUTO
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|prog
condition|)
name|prog
operator|=
name|Filename
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|cmd
argument_list|,
name|prog
argument_list|,
name|MAXSTR
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prog
operator|=
name|rindex
argument_list|(
name|p
operator|->
name|cmd
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|prog
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|prog
operator|+=
name|strlen
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|p
operator|->
name|akapos
operator|=
name|prog
operator|-
name|p
operator|->
name|cmd
expr_stmt|;
name|p
operator|->
name|autoaka
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|p
operator|->
name|akapos
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|monitor
operator|=
name|default_monitor
expr_stmt|;
name|p
operator|->
name|norefresh
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|tty
argument_list|,
name|TtyName
argument_list|,
name|MAXSTR
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUIDROOT
operator|(
name|void
operator|)
name|chown
argument_list|(
name|TtyName
argument_list|,
name|real_uid
argument_list|,
name|real_gid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|TtyName
argument_list|,
name|tlflag
condition|?
name|TtyMode
else|:
operator|(
name|TtyMode
operator|&
operator|~
literal|022
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|TtyName
argument_list|,
name|TtyMode
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|histheight
operator|<
literal|0
condition|)
name|histheight
operator|=
name|default_histheight
expr_stmt|;
if|if
condition|(
name|ChangeWindowSize
argument_list|(
name|p
argument_list|,
name|default_width
argument_list|,
name|default_height
argument_list|)
condition|)
block|{
name|FreeWindow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ChangeScrollback
argument_list|(
name|p
argument_list|,
name|histheight
argument_list|,
name|default_width
argument_list|)
expr_stmt|;
name|ResetScreen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"forking...\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|wpid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
name|FreeWindow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|&&
name|chdir
argument_list|(
name|dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SendErrorMsg
argument_list|(
literal|"Cannot chdir to %s: %s"
argument_list|,
name|dir
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|freetty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|=
name|open
argument_list|(
name|TtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SendErrorMsg
argument_list|(
literal|"Cannot open %s: %s"
argument_list|,
name|TtyName
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SVR4
if|if
condition|(
name|ioctl
argument_list|(
name|tf
argument_list|,
name|I_PUSH
argument_list|,
literal|"ptem"
argument_list|)
condition|)
block|{
name|SendErrorMsg
argument_list|(
literal|"Cannot I_PUSH ptem %s %s"
argument_list|,
name|TtyName
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|tf
argument_list|,
name|I_PUSH
argument_list|,
literal|"ldterm"
argument_list|)
condition|)
block|{
name|SendErrorMsg
argument_list|(
literal|"Cannot I_PUSH ldterm %s %s"
argument_list|,
name|TtyName
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|tf
argument_list|,
name|I_PUSH
argument_list|,
literal|"ttcompat"
argument_list|)
condition|)
block|{
name|SendErrorMsg
argument_list|(
literal|"Cannot I_PUSH ttcompat %s %s"
argument_list|,
name|TtyName
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|tf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|tf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|tf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dfp
operator|=
name|stderr
expr_stmt|;
endif|#
directive|endif
name|closeallfiles
argument_list|()
expr_stmt|;
name|fgtty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
name|glwz
operator|.
name|ws_col
operator|=
name|p
operator|->
name|width
expr_stmt|;
name|glwz
operator|.
name|ws_row
operator|=
name|p
operator|->
name|height
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|glwz
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|libuf
argument_list|,
literal|"LINES=%d"
argument_list|,
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cobuf
argument_list|,
literal|"COLUMNS=%d"
argument_list|,
name|p
operator|->
name|width
argument_list|)
expr_stmt|;
name|NewEnv
index|[
literal|4
index|]
operator|=
name|libuf
expr_stmt|;
name|NewEnv
index|[
literal|5
index|]
operator|=
name|cobuf
expr_stmt|;
endif|#
directive|endif
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|NewEnv
index|[
literal|2
index|]
operator|=
name|MakeTermcap
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|NewEnv
index|[
literal|2
index|]
operator|=
name|Termcap
expr_stmt|;
if|if
condition|(
name|term
operator|&&
operator|*
name|term
operator|&&
name|strcmp
argument_list|(
name|screenterm
argument_list|,
name|term
argument_list|)
operator|&&
operator|(
name|strlen
argument_list|(
name|term
argument_list|)
operator|<
literal|20
operator|)
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
name|tl
decl_stmt|;
name|sprintf
argument_list|(
name|tebuf
argument_list|,
literal|"TERM=%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"Makewindow %d with %s\n"
argument_list|,
name|n
argument_list|,
name|tebuf
argument_list|)
expr_stmt|;
name|tl
operator|=
name|strlen
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|NewEnv
index|[
literal|1
index|]
operator|=
name|tebuf
expr_stmt|;
if|if
condition|(
name|s1
operator|=
name|index
argument_list|(
name|Termcap
argument_list|,
literal|'|'
argument_list|)
condition|)
block|{
if|if
condition|(
name|s2
operator|=
name|index
argument_list|(
operator|++
name|s1
argument_list|,
literal|'|'
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|Termcap
argument_list|)
operator|-
operator|(
name|s2
operator|-
name|s1
operator|)
operator|+
name|tl
operator|<
literal|1024
condition|)
block|{
name|bcopy
argument_list|(
name|s2
argument_list|,
name|s1
operator|+
name|tl
argument_list|,
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|term
argument_list|,
name|s1
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"WINDOW=%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|NewEnv
index|[
literal|3
index|]
operator|=
name|ebuf
expr_stmt|;
name|execvpe
argument_list|(
operator|*
name|args
argument_list|,
name|args
argument_list|,
name|NewEnv
argument_list|)
expr_stmt|;
name|SendErrorMsg
argument_list|(
literal|"Cannot exec %s: %s"
argument_list|,
operator|*
name|args
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* end fork switch */
comment|/*    * Place the newly created window at the head of the most-recently-used list.    */
operator|*
name|pp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|WinLink
operator|=
name|WinList
expr_stmt|;
name|WinList
operator|=
name|n
expr_stmt|;
name|HasWindow
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
name|debug1
argument_list|(
literal|"MakeWindow will %slog in.\n"
argument_list|,
name|tlflag
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlflag
operator|==
literal|1
condition|)
name|SetUtmp
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|slot
operator|=
operator|(
name|slot_t
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|SetForeWindow
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|Activate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|execvpe
parameter_list|(
name|prog
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|,
decl|*
modifier|*
name|args
decl_stmt|,
modifier|*
modifier|*
name|env
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|shargs
index|[
name|MAXARGS
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|eaccess
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|prog
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|path
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|path
operator|=
name|DefaultPath
expr_stmt|;
do|do
block|{
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|path
condition|)
operator|++
name|path
expr_stmt|;
name|execve
argument_list|(
name|buf
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOEXEC
case|:
name|shargs
index|[
literal|0
index|]
operator|=
name|DefaultShell
expr_stmt|;
name|shargs
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|shargs
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|args
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|execve
argument_list|(
name|DefaultShell
argument_list|,
name|shargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return;
case|case
name|EACCES
case|:
name|eaccess
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENOMEM
case|:
case|case
name|E2BIG
case|:
case|case
name|ETXTBSY
case|:
return|return;
block|}
block|}
do|while
condition|(
operator|*
name|path
condition|)
do|;
if|if
condition|(
name|eaccess
condition|)
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|LogToggle
parameter_list|()
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"screenlog.%d"
argument_list|,
name|ForeNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|fore
operator|->
name|logfp
operator|!=
name|NULL
condition|)
block|{
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Logfile \"%s\" closed."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fore
operator|->
name|logfp
argument_list|)
expr_stmt|;
name|fore
operator|->
name|logfp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|fore
operator|->
name|logfp
operator|=
name|secfopen
argument_list|(
name|buf
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Error opening logfile \"%s\""
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s logfile \"%s\""
argument_list|,
name|ftell
argument_list|(
name|fore
operator|->
name|logfp
argument_list|)
condition|?
literal|"Appending to"
else|:
literal|"Creating"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOREUID
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|UserPID
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SIGTYPE
argument_list|(
argument|*Usersigcld
argument_list|)
name|__P
argument_list|(
name|SIGPROTOARG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|UserSTAT
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|UserContext
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|NOREUID
if|if
condition|(
name|eff_uid
operator|==
name|real_uid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|SYSV
name|Usersigcld
operator|=
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|#
directive|else
name|Usersigcld
operator|=
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug
argument_list|(
literal|"UserContext: forking.\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|UserPID
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
else|#
directive|else
name|setreuid
argument_list|(
name|eff_uid
argument_list|,
name|real_uid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|eff_gid
argument_list|,
name|real_gid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|UserReturn
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|NOREUID
argument_list|)
if|if
condition|(
name|eff_uid
operator|==
name|real_uid
condition|)
name|UserSTAT
operator|=
name|val
expr_stmt|;
else|else
name|exit
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|#
directive|else
name|setreuid
argument_list|(
name|real_uid
argument_list|,
name|eff_uid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|real_gid
argument_list|,
name|eff_gid
argument_list|)
expr_stmt|;
name|UserSTAT
operator|=
name|val
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|UserStatus
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|NOREUID
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDWAIT
name|union
name|wait
name|wstat
decl_stmt|;
else|#
directive|else
name|int
name|wstat
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|eff_uid
operator|==
name|real_uid
condition|)
return|return
name|UserSTAT
return|;
if|if
condition|(
name|UserPID
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|errno
operator|=
literal|0
operator|,
name|i
operator|=
name|wait
argument_list|(
operator|&
name|wstat
argument_list|)
operator|)
operator|!=
name|UserPID
condition|)
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
ifdef|#
directive|ifdef
name|SYSV
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|Usersigcld
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|Usersigcld
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|WEXITSTATUS
argument_list|(
name|wstat
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
name|UserSTAT
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ShowWindows
parameter_list|()
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|win
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|OtherNum
init|=
name|fore
operator|->
name|WinLink
decl_stmt|;
specifier|register
name|char
modifier|*
name|cmd
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
name|buf
operator|,
name|pp
operator|=
name|wtab
init|;
name|pp
operator|<
name|wtab
operator|+
name|MAXWIN
condition|;
operator|++
name|i
operator|,
operator|++
name|pp
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|akapos
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|->
name|cmd
operator|+
name|p
operator|->
name|akapos
operator|)
operator|&&
operator|*
operator|(
name|p
operator|->
name|cmd
operator|+
name|p
operator|->
name|akapos
operator|-
literal|1
operator|)
operator|!=
literal|':'
condition|)
name|cmd
operator|=
name|p
operator|->
name|cmd
operator|+
name|p
operator|->
name|akapos
expr_stmt|;
else|else
name|cmd
operator|=
name|p
operator|->
name|cmd
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|cmd
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cmd
operator|=
name|p
operator|->
name|cmd
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|buf
operator|+
literal|5
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|>
name|fore
operator|->
name|width
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|s
operator|>
name|buf
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
name|i
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ForeNum
condition|)
operator|*
name|s
operator|++
operator|=
literal|'*'
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|OtherNum
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|monitor
operator|==
name|MON_DONE
condition|)
operator|*
name|s
operator|++
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bell
operator|==
name|BELL_DONE
condition|)
operator|*
name|s
operator|++
operator|=
literal|'!'
expr_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
if|if
condition|(
name|p
operator|->
name|slot
operator|!=
operator|(
name|slot_t
operator|)
literal|0
operator|&&
name|p
operator|->
name|slot
operator|!=
operator|(
name|slot_t
operator|)
operator|-
literal|1
condition|)
operator|*
name|s
operator|++
operator|=
literal|'$'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|logfp
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"(L)"
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ForeNum
condition|)
block|{
comment|/*  	   * this is usually done by Activate(), but when looking 	   * on your current window, you may get annoyed, as there is still 	   * that temporal '!' and '@' displayed. 	   * So we remove that after displaying it once. 	   */
name|p
operator|->
name|bell
operator|=
name|BELL_OFF
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|monitor
operator|!=
name|MON_OFF
condition|)
name|p
operator|->
name|monitor
operator|=
name|MON_ON
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOADAV_3LONGS
end_ifdef

begin_decl_stmt
specifier|extern
name|long
name|loadav
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|LOADAV_4LONGS
end_ifdef

begin_decl_stmt
specifier|extern
name|long
name|loadav
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|LOADAV_NEXT
end_ifdef

begin_decl_stmt
specifier|extern
name|float
name|loadav
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|double
name|loadav
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern avenrun;
end_extern

begin_function
specifier|static
name|void
name|ShowTime
parameter_list|()
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|LOADAV
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%2d:%02.2d:%02.2d %s"
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|,
name|tp
operator|->
name|tm_sec
argument_list|,
name|HostName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADAV
if|if
condition|(
name|avenrun
operator|&&
name|GetAvenrun
argument_list|()
condition|)
block|{
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADAV_3LONGS
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %2.2f %2.2f %2.2f"
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|0
index|]
operator|/
name|FSCALE
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|1
index|]
operator|/
name|FSCALE
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|2
index|]
operator|/
name|FSCALE
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|LOADAV_4LONGS
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %2.2f %2.2f %2.2f %2.2f"
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|0
index|]
operator|/
literal|100
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|1
index|]
operator|/
literal|100
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|2
index|]
operator|/
literal|100
argument_list|,
operator|(
name|double
operator|)
name|loadav
index|[
literal|3
index|]
operator|/
literal|100
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|LOADAV_NEXT
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %2.2f"
argument_list|,
name|loadav
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|apollo
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %2.2f %2.2f %2.2f"
argument_list|,
name|loadav
index|[
literal|0
index|]
operator|/
literal|65536.0
argument_list|,
name|loadav
index|[
literal|1
index|]
operator|/
literal|65536.0
argument_list|,
name|loadav
index|[
literal|2
index|]
operator|/
literal|65536.0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %2.2f %2.2f %2.2f"
argument_list|,
name|loadav
index|[
literal|0
index|]
argument_list|,
name|loadav
index|[
literal|1
index|]
argument_list|,
name|loadav
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
endif|#
directive|endif
comment|/* LOADAV_NEXT */
endif|#
directive|endif
comment|/* LOADAV_4LONGS */
endif|#
directive|endif
comment|/* LOADAV_3LONGS */
block|}
endif|#
directive|endif
comment|/* LOADAV */
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ShowInfo
parameter_list|()
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|win
modifier|*
name|wp
init|=
name|fore
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d,%d)/(%d,%d)+%d %c%sflow %cins %corg %cwrap %capp %clog %cmon %cr"
argument_list|,
name|wp
operator|->
name|x
operator|+
literal|1
argument_list|,
name|wp
operator|->
name|y
operator|+
literal|1
argument_list|,
name|wp
operator|->
name|width
argument_list|,
name|wp
operator|->
name|height
argument_list|,
name|wp
operator|->
name|histheight
argument_list|,
operator|(
name|wp
operator|->
name|flow
operator|&
name|FLOW_NOW
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
operator|(
name|wp
operator|->
name|flow
operator|&
name|FLOW_AUTOFLAG
operator|)
condition|?
literal|""
else|:
operator|(
operator|(
name|wp
operator|->
name|flow
operator|&
name|FLOW_AUTO
operator|)
condition|?
literal|"(+)"
else|:
literal|"(-)"
operator|)
argument_list|,
name|wp
operator|->
name|insert
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|wp
operator|->
name|origin
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|wp
operator|->
name|wrap
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|wp
operator|->
name|keypad
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
operator|(
name|wp
operator|->
name|logfp
operator|!=
name|NULL
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
operator|(
name|wp
operator|->
name|monitor
operator|!=
name|MON_OFF
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|wp
operator|->
name|norefresh
condition|?
literal|'-'
else|:
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISO2022
condition|)
block|{
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" G%1d ["
argument_list|,
name|wp
operator|->
name|LocalCharset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
operator|+
literal|5
index|]
operator|=
name|wp
operator|->
name|charsets
index|[
name|i
index|]
condition|?
name|wp
operator|->
name|charsets
index|[
name|i
index|]
else|:
literal|'B'
expr_stmt|;
name|p
index|[
literal|9
index|]
operator|=
literal|']'
expr_stmt|;
name|p
index|[
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sequent
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
operator|||
name|defined
argument_list|(
name|SVR4
argument_list|)
end_if

begin_function
specifier|static
name|int
name|OpenPTY
parameter_list|()
block|{
name|char
modifier|*
name|m
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
ifdef|#
directive|ifdef
name|SVR4
name|char
modifier|*
name|ptsname
parameter_list|()
function_decl|;
name|SIGTYPE
function_decl|(
modifier|*
name|sigcld
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
literal|"/dev/ptmx"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*    * SIGCLD set to SIG_DFL for grantpt() because it fork()s and    * exec()s pt_chmod    */
name|sigcld
operator|=
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ptsname
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|unlockpt
argument_list|(
name|f
argument_list|)
operator|||
name|grantpt
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|sigcld
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|sigcld
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|TtyName
argument_list|,
name|m
argument_list|,
sizeof|sizeof
name|TtyName
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SVR4 */
if|if
condition|(
operator|(
name|f
operator|=
name|getpseudotty
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strncpy
argument_list|(
name|PtyName
argument_list|,
name|m
argument_list|,
sizeof|sizeof
name|PtyName
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|TtyName
argument_list|,
name|s
argument_list|,
sizeof|sizeof
name|TtyName
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVR4 */
ifdef|#
directive|ifdef
name|POSIX
name|tcflush
argument_list|(
name|f
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|f
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCKPTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|f
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(sequent) || defined(_SEQUENT_) || defined(SVR4) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MIPS
end_ifdef

begin_function
specifier|static
name|int
name|OpenPTY
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|f
operator|,
name|tf
expr_stmt|;
specifier|register
name|my_minor
expr_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|strcpy
argument_list|(
name|PtyName
argument_list|,
name|PtyProto
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|PtyName
init|;
operator|*
name|p
operator|!=
literal|'X'
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
name|l
operator|=
literal|"zyxwvutsrqp"
init|;
operator|*
name|p
operator|=
operator|*
name|l
condition|;
operator|++
name|l
control|)
block|{
for|for
control|(
name|d
operator|=
literal|"0123456789abcdef"
init|;
name|p
index|[
literal|1
index|]
operator|=
operator|*
name|d
condition|;
operator|++
name|d
control|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|PtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|my_minor
operator|=
name|minor
argument_list|(
name|buf
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|TtyName
argument_list|,
literal|"/dev/ttyq%d"
argument_list|,
name|my_minor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|=
name|open
argument_list|(
name|TtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|tf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKPTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|f
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|f
return|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MIPS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_function
specifier|static
name|int
name|OpenPTY
parameter_list|()
block|{
specifier|register
name|f
expr_stmt|;
specifier|register
name|my_minor
expr_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|strcpy
argument_list|(
name|PtyName
argument_list|,
literal|"/dev/ptc"
argument_list|)
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|PtyName
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|my_minor
operator|=
name|minor
argument_list|(
name|buf
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|TtyName
argument_list|,
literal|"/dev/ttyq%d"
argument_list|,
name|my_minor
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* sgi */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_comment
comment|/* RS6000 */
end_comment

begin_function
specifier|static
name|int
name|OpenPTY
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|f
decl_stmt|,
name|tf
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|PtyName
argument_list|,
literal|"/dev/ptc/%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|PtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|TtyName
argument_list|,
literal|"/dev/pts/%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|=
name|open
argument_list|(
name|TtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|tf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKPTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|f
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|f
return|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _AIX, RS6000 */
end_comment

begin_function
specifier|static
name|int
name|OpenPTY
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|tf
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|hpux
argument_list|)
name|debug
argument_list|(
literal|"Hello, You are none of: sequent, _SEQUENT_, SVR4, MIPS, sgi, AIX\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"       This OpenPTY() is for hpux, ... and for you?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|PtyName
argument_list|,
name|PtyProto
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|TtyName
argument_list|,
name|TtyProto
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|PtyName
init|;
operator|*
name|p
operator|!=
literal|'X'
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
name|q
operator|=
name|TtyName
init|;
operator|*
name|q
operator|!=
literal|'X'
condition|;
operator|++
name|q
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|sequent
comment|/* why ask for sequent in #else (not sequent) section? jw. */
for|for
control|(
name|l
operator|=
literal|"p"
init|;
operator|(
operator|*
name|p
operator|=
operator|*
name|l
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|l
control|)
block|{
comment|/* } */
for|for
control|(
name|d
operator|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
init|;
operator|(
name|p
index|[
literal|1
index|]
operator|=
operator|*
name|d
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|d
control|)
block|{
comment|/* } */
else|#
directive|else
ifdef|#
directive|ifdef
name|hpux
for|for
control|(
name|l
operator|=
literal|"pqrstuvw"
init|;
operator|(
operator|*
name|p
operator|=
operator|*
name|l
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|l
control|)
else|#
directive|else
for|for
control|(
name|l
operator|=
literal|"qpr"
init|;
operator|(
operator|*
name|p
operator|=
operator|*
name|l
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|l
control|)
endif|#
directive|endif
block|{
for|for
control|(
name|d
operator|=
literal|"0123456789abcdef"
init|;
operator|(
name|p
index|[
literal|1
index|]
operator|=
operator|*
name|d
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|d
control|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|PtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|q
index|[
literal|0
index|]
operator|=
operator|*
name|l
expr_stmt|;
name|q
index|[
literal|1
index|]
operator|=
operator|*
name|d
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|=
name|open
argument_list|(
name|TtyName
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* close tf, thus we also get rid of an unwanted 		   * controlling terminal!  		   */
name|close
argument_list|(
name|tf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKPTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|f
argument_list|,
name|TIOCEXCL
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|f
return|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* _AIX, RS6000 */
endif|#
directive|endif
comment|/* sgi */
endif|#
directive|endif
comment|/* MIPS */
endif|#
directive|endif
name|void
name|SetTTY
parameter_list|(
name|fd
parameter_list|,
name|mp
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|mode
modifier|*
name|mp
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|mp
operator|->
name|tio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|hpux
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|mp
operator|->
name|m_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|TERMIO
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|mp
operator|->
name|tio
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ioctl(fd, TIOCSETP,&mp->m_ttyb); */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|mp
operator|->
name|m_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|mp
operator|->
name|m_ltchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|mp
operator|->
name|m_lmode
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|mp
operator|->
name|m_ldisc
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|mp
operator|->
name|m_ttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|errno
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"SetTTY: ioctl failed"
argument_list|)
expr_stmt|;
block|}
name|void
name|GetTTY
parameter_list|(
name|fd
parameter_list|,
name|mp
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|mode
modifier|*
name|mp
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|mp
operator|->
name|tio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|hpux
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|mp
operator|->
name|m_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|TERMIO
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|mp
operator|->
name|tio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|mp
operator|->
name|m_ttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|mp
operator|->
name|m_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|mp
operator|->
name|m_ltchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|mp
operator|->
name|m_lmode
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|mp
operator|->
name|m_ldisc
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|errno
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"GetTTY: ioctl failed"
argument_list|)
expr_stmt|;
block|}
name|void
name|SetMode
parameter_list|(
name|op
parameter_list|,
name|np
parameter_list|)
name|struct
name|mode
modifier|*
name|op
decl_stmt|,
decl|*
name|np
decl_stmt|;
block|{
operator|*
name|np
operator|=
operator|*
name|op
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TERMIO
argument_list|)
operator|||
name|defined
argument_list|(
name|POSIX
argument_list|)
name|np
operator|->
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
ifdef|#
directive|ifdef
name|ONLCR
name|np
operator|->
name|tio
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
endif|#
directive|endif
name|np
operator|->
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
comment|/*    * Unfortunately, the master process never will get SIGINT if the real    * terminal is different from the one on which it was originaly started    * (process group membership has not been restored or the new tty could not    * be made controlling again). In my solution, it is the attacher who    * receives SIGINT (because it is always correctly associated with the real    * tty) and forwards it to the master [kill(MasterPid, SIGINT)].     * Marc Boucher (marc@CAM.ORG)    */
name|np
operator|->
name|tio
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
comment|/*     * careful, careful catche monkey..    * never set VMIN and VTIME to zero, if you want blocking io.    */
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VSTART
name|startc
operator|=
name|op
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSTOP
name|stopc
operator|=
name|op
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
condition|)
name|intrc
operator|=
name|op
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
else|else
name|intrc
operator|=
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
literal|0377
expr_stmt|;
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
literal|0377
expr_stmt|;
if|if
condition|(
name|flow
operator|==
literal|0
condition|)
block|{
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
literal|0377
expr_stmt|;
ifdef|#
directive|ifdef
name|VSTART
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSTOP
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
name|np
operator|->
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
name|IXON
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VDISCARD
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSUSP
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hpux
name|np
operator|->
name|m_ltchars
operator|.
name|t_suspc
operator|=
literal|0377
expr_stmt|;
name|np
operator|->
name|m_ltchars
operator|.
name|t_dsuspc
operator|=
literal|0377
expr_stmt|;
name|np
operator|->
name|m_ltchars
operator|.
name|t_flushc
operator|=
literal|0377
expr_stmt|;
name|np
operator|->
name|m_ltchars
operator|.
name|t_lnextc
operator|=
literal|0377
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VDSUSP
name|np
operator|->
name|tio
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
name|startc
operator|=
name|op
operator|->
name|m_tchars
operator|.
name|t_startc
expr_stmt|;
name|stopc
operator|=
name|op
operator|->
name|m_tchars
operator|.
name|t_stopc
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
name|intrc
operator|=
name|op
operator|->
name|m_tchars
operator|.
name|t_intrc
expr_stmt|;
else|else
name|intrc
operator|=
name|np
operator|->
name|m_tchars
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|m_ttyb
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|CRMOD
operator||
name|ECHO
operator|)
expr_stmt|;
name|np
operator|->
name|m_ttyb
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|np
operator|->
name|m_tchars
operator|.
name|t_quitc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|flow
operator|==
literal|0
condition|)
block|{
name|np
operator|->
name|m_tchars
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|m_tchars
operator|.
name|t_startc
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|m_tchars
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|np
operator|->
name|m_ltchars
operator|.
name|t_suspc
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|m_ltchars
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|m_ltchars
operator|.
name|t_flushc
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|m_ltchars
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(TERMIO) || defined(POSIX) */
block|}
name|void
name|SetFlow
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
if|if
condition|(
name|flow
operator|==
name|on
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|TERMIO
argument_list|)
operator|||
name|defined
argument_list|(
name|POSIX
argument_list|)
if|if
condition|(
name|on
condition|)
block|{
name|NewMode
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|intrc
expr_stmt|;
ifdef|#
directive|ifdef
name|VSTART
name|NewMode
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
name|startc
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSTOP
name|NewMode
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
name|stopc
expr_stmt|;
endif|#
directive|endif
name|NewMode
operator|.
name|tio
operator|.
name|c_iflag
operator||=
name|IXON
expr_stmt|;
block|}
else|else
block|{
name|NewMode
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
literal|0377
expr_stmt|;
ifdef|#
directive|ifdef
name|VSTART
name|NewMode
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSTOP
name|NewMode
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
name|NewMode
operator|.
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
name|IXON
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POSIX
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|NewMode
operator|.
name|tio
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|NewMode
operator|.
name|tio
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|debug1
argument_list|(
literal|"SetFlow: ioctl errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|on
condition|)
block|{
name|NewMode
operator|.
name|m_tchars
operator|.
name|t_intrc
operator|=
name|intrc
expr_stmt|;
name|NewMode
operator|.
name|m_tchars
operator|.
name|t_startc
operator|=
name|startc
expr_stmt|;
name|NewMode
operator|.
name|m_tchars
operator|.
name|t_stopc
operator|=
name|stopc
expr_stmt|;
block|}
else|else
block|{
name|NewMode
operator|.
name|m_tchars
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
name|NewMode
operator|.
name|m_tchars
operator|.
name|t_startc
operator|=
operator|-
literal|1
expr_stmt|;
name|NewMode
operator|.
name|m_tchars
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|NewMode
operator|.
name|m_tchars
argument_list|)
operator|!=
literal|0
condition|)
name|debug1
argument_list|(
literal|"SetFlow: ioctl errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(TERMIO) || defined(POSIX) */
name|flow
operator|=
name|on
expr_stmt|;
block|}
comment|/* we return 1 if we could attach one, or 0 if none */
specifier|static
name|int
name|Attach
parameter_list|(
name|how
parameter_list|)
name|int
name|how
decl_stmt|;
block|{
name|int
name|lasts
decl_stmt|;
name|struct
name|msg
name|m
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|how
operator|==
name|MSG_WINCH
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|type
operator|=
name|how
expr_stmt|;
if|if
condition|(
operator|(
name|lasts
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|SockName
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|lasts
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|lasts
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|how
operator|==
name|MSG_CONT
condition|)
block|{
if|if
condition|(
operator|(
name|lasts
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|SockName
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, cannot contact session \"%s\" again\r\n"
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|how
operator|=
name|MSG_ATTACH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|how
operator|!=
name|MSG_CONT
condition|)
block|{
switch|switch
condition|(
name|FindSocket
argument_list|(
name|how
argument_list|,
operator|&
name|lasts
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|rflag
operator|==
literal|2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|quietflag
condition|)
name|eexit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|SockName
operator|&&
operator|*
name|SockName
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"There is no screen to be %sed matching %s."
argument_list|,
name|dflag
condition|?
literal|"detach"
else|:
literal|"resum"
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
else|else
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"There is no screen to be %sed."
argument_list|,
name|dflag
condition|?
literal|"detach"
else|:
literal|"resum"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
break|break;
default|default:
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Type \"screen [-d] -r [pid.]tty.host\" to resume one of them."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/*        * Go in UserContext. Advantage is, you can kill your attacher        * when things go wrong. Any disadvantages? jw.        */
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
name|SockName
operator|=
name|SockNamePtr
expr_stmt|;
name|MasterPid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|SockName
condition|)
block|{
if|if
condition|(
operator|*
name|SockName
operator|>
literal|'9'
operator|||
operator|*
name|SockName
operator|<
literal|'0'
condition|)
break|break;
name|MasterPid
operator|=
literal|10
operator|*
name|MasterPid
operator|+
operator|*
name|SockName
operator|-
literal|'0'
expr_stmt|;
name|SockName
operator|++
expr_stmt|;
block|}
name|SockName
operator|=
name|SockNamePtr
expr_stmt|;
name|debug1
argument_list|(
literal|"Attach decided, it is '%s'\n"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"Attach found MasterPid == %d\n"
argument_list|,
name|MasterPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"stat %s"
argument_list|,
name|SockPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0700
operator|)
operator|!=
operator|(
name|dflag
condition|?
literal|0700
else|:
literal|0600
operator|)
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"That screen is %sdetached."
argument_list|,
name|dflag
condition|?
literal|"already "
else|:
literal|"not "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_DETACH
if|if
condition|(
name|dflag
operator|&&
operator|(
name|how
operator|==
name|MSG_ATTACH
operator|||
name|how
operator|==
name|MSG_DETACH
operator|||
name|how
operator|==
name|MSG_POW_DETACH
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|m
operator|.
name|m
operator|.
name|detach
operator|.
name|tty
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"attach_tty is %s\n"
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|detach
operator|.
name|dpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|POW_DETACH
if|if
condition|(
name|dflag
operator|==
literal|2
condition|)
name|m
operator|.
name|type
operator|=
name|MSG_POW_DETACH
expr_stmt|;
else|else
endif|#
directive|endif
name|m
operator|.
name|type
operator|=
name|MSG_DETACH
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|lasts
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|lasts
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|!=
name|MSG_ATTACH
condition|)
return|return
literal|0
return|;
comment|/* we detached it. jw. */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* we dont want to overrun our poor backend. jw. */
if|if
condition|(
operator|(
name|lasts
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|SockName
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Cannot contact screen again. Shit."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|m
operator|.
name|type
operator|=
name|how
expr_stmt|;
name|strcpy
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|tty
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"attach_tty is %s\n"
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|s
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
name|MAXPATH
operator|-
literal|5
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"$TERM too long - sorry."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|envterm
argument_list|,
literal|"TERM=%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|envterm
operator|=
literal|'\0'
expr_stmt|;
name|debug1
argument_list|(
literal|"attach: sending %d bytes... "
argument_list|,
sizeof|sizeof
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|apid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|adaptflag
operator|=
name|adaptflag
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|lines
operator|=
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|columns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
condition|)
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|lines
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
condition|)
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|columns
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PASSWORD
if|if
condition|(
name|how
operator|==
name|MSG_ATTACH
operator|||
name|how
operator|==
name|MSG_CONT
condition|)
name|trysend
argument_list|(
name|lasts
argument_list|,
operator|&
name|m
argument_list|,
name|m
operator|.
name|m
operator|.
name|attach
operator|.
name|password
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|write
argument_list|(
name|lasts
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|lasts
argument_list|)
expr_stmt|;
block|}
name|debug1
argument_list|(
literal|"Attach(%d): sent\n"
argument_list|,
name|m
operator|.
name|type
argument_list|)
expr_stmt|;
name|Suspended
operator|=
literal|0
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|PASSWORD
specifier|static
name|trysendstat
expr_stmt|;
specifier|static
name|SIGTYPE
name|trysendok
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|trysendstat
operator|=
literal|1
expr_stmt|;
block|}
specifier|static
name|SIGTYPE
name|trysendfail
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|trysendstat
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIG_PW_FAIL
argument_list|,
name|trysendfail
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
block|}
specifier|static
name|char
name|screenpw
index|[
literal|9
index|]
decl_stmt|;
specifier|static
name|void
name|trysend
parameter_list|(
name|fd
parameter_list|,
name|m
parameter_list|,
name|pwto
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|msg
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|pwto
decl_stmt|;
block|{
name|char
modifier|*
name|npw
init|=
name|NULL
decl_stmt|;
name|SIGTYPE
function_decl|(
modifier|*
name|sighup
function_decl|)
parameter_list|()
function_decl|;
name|SIGTYPE
function_decl|(
modifier|*
name|sigusr1
function_decl|)
parameter_list|()
function_decl|;
name|int
name|tries
decl_stmt|;
name|sigusr1
operator|=
name|signal
argument_list|(
name|SIG_PW_OK
argument_list|,
name|trysendok
argument_list|)
expr_stmt|;
name|sighup
operator|=
name|signal
argument_list|(
name|SIG_PW_FAIL
argument_list|,
name|trysendfail
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|strcpy
argument_list|(
name|pwto
argument_list|,
name|screenpw
argument_list|)
expr_stmt|;
name|trysendstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|trysendstat
operator|==
literal|0
condition|)
name|pause
argument_list|()
expr_stmt|;
if|if
condition|(
name|trysendstat
operator|>
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIG_PW_OK
argument_list|,
name|sigusr1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIG_PW_FAIL
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|++
name|tries
operator|>
literal|1
operator|||
operator|(
name|npw
operator|=
name|getpass
argument_list|(
literal|"Screen Password:"
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|*
name|npw
operator|==
literal|0
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Password incorrect"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|screenpw
argument_list|,
name|npw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|SockName
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Msg
argument_list|(
literal|0
argument_list|,
literal|"Cannot contact screen again. Shit."
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PASSWORD */
comment|/*  * Unfortunatelly this is also the SIGHUP handler, so we have to  * check, if the backend is already detached.  */
specifier|static
name|SIGTYPE
name|AttacherFinit
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|struct
name|msg
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|debug
argument_list|(
literal|"AttacherFinit();\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Check if signal comes from backend */
if|if
condition|(
name|SockName
condition|)
block|{
name|strcpy
argument_list|(
name|SockNamePtr
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|SockPath
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|statb
operator|.
name|st_mode
operator|&
literal|0777
operator|)
operator|!=
literal|0600
condition|)
block|{
name|debug
argument_list|(
literal|"Detaching backend!\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|m
operator|.
name|m
operator|.
name|detach
operator|.
name|tty
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"attach_tty is %s\n"
argument_list|,
name|attach_tty
argument_list|)
expr_stmt|;
name|m
operator|.
name|m
operator|.
name|detach
operator|.
name|dpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|m
operator|.
name|type
operator|=
name|MSG_HANGUP
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|MakeClientSocket
argument_list|(
literal|0
argument_list|,
name|SockName
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|s
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POW_DETACH
specifier|static
name|SIGTYPE
name|AttacherFinitBye
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|int
name|ppid
decl_stmt|;
name|debug
argument_list|(
literal|"AttacherFintBye()\n"
argument_list|)
expr_stmt|;
name|freetty
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
comment|/* we don't want to disturb init (even if we were root), eh? jw */
if|if
condition|(
operator|(
name|ppid
operator|=
name|getppid
argument_list|()
operator|)
operator|>
literal|1
condition|)
name|Kill
argument_list|(
name|ppid
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
comment|/* carefully say good bye. jw. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
specifier|static
name|SuspendPlease
expr_stmt|;
specifier|static
name|SIGTYPE
name|SigStop
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|debug
argument_list|(
literal|"SigStop()\n"
argument_list|)
expr_stmt|;
name|SuspendPlease
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|LOCK
specifier|static
name|LockPlease
expr_stmt|;
specifier|static
name|SIGTYPE
name|DoLock
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|debug
argument_list|(
literal|"DoLock()\n"
argument_list|)
expr_stmt|;
name|LockPlease
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIG_LOCK
argument_list|,
name|DoLock
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
specifier|static
name|SigWinchPlease
expr_stmt|;
specifier|static
name|SIGTYPE
name|SigAttWinch
parameter_list|(
name|SIGDEFARG
parameter_list|)
block|{
name|debug
argument_list|(
literal|"SigAttWinch()\n"
argument_list|)
expr_stmt|;
name|SigWinchPlease
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
operator|(
name|SIGTYPE
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
specifier|static
name|void
name|Attacher
parameter_list|()
block|{
comment|/*    * permanent in UserContext. Advantage is, you can kill your attacher    * when things go wrong. Any disadvantages? jw.    */
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
comment|/* XXX: already done in Attach() */
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
comment|/* XXX: already done in Attach() */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|AttacherFinit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIG_BYE
argument_list|,
name|AttacherFinit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POW_DETACH
name|signal
argument_list|(
name|SIG_POWER_BYE
argument_list|,
name|AttacherFinitBye
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCK
name|signal
argument_list|(
name|SIG_LOCK
argument_list|,
name|DoLock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|AttacherSigInt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
name|signal
argument_list|(
name|SIG_STOP
argument_list|,
name|SigStop
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SigAttWinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|FEChld
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|FEChld
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|debug
argument_list|(
literal|"attacher: going for a nap.\n"
argument_list|)
expr_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pause
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"attacher: huh! a signal!\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|FEpanic
condition|)
block|{
name|printf
argument_list|(
literal|"\n\rSuddenly the Dungeon collapses!! - You die...\n\r"
argument_list|)
expr_stmt|;
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSDJOBS
if|if
condition|(
name|SuspendPlease
condition|)
block|{
name|SuspendPlease
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"attacher: killing myself SIGTSTP\n"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|debug1
argument_list|(
literal|"attacher: continuing from stop(%d)\n"
argument_list|,
name|Suspended
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIG_STOP
argument_list|,
name|SigStop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Attach
argument_list|(
name|MSG_CONT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCK
if|if
condition|(
name|LockPlease
condition|)
block|{
name|LockPlease
operator|=
literal|0
expr_stmt|;
name|LockTerminal
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIG_LOCK
argument_list|,
name|DoLock
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|Attach
argument_list|(
name|MSG_CONT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCK */
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
if|if
condition|(
name|SigWinchPlease
condition|)
block|{
name|SigWinchPlease
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SigAttWinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|Attach
argument_list|(
name|MSG_WINCH
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SIGWINCH */
block|}
block|}
ifdef|#
directive|ifdef
name|LOCK
comment|/* ADDED by Rainer Pruy 10/15/87 */
comment|/* POLISHED by mls. 03/10/91 */
specifier|static
name|char
name|LockEnd
index|[]
init|=
literal|"Welcome back to screen !!\n"
decl_stmt|;
specifier|static
name|void
name|LockTerminal
parameter_list|()
block|{
name|char
modifier|*
name|prg
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|pid
decl_stmt|;
name|SIGTYPE
argument_list|(
argument|*sigs[NSIG]
argument_list|)
name|__P
argument_list|(
name|SIGPROTOARG
argument_list|)
expr_stmt|;
for|for
control|(
name|sig
operator|=
literal|1
init|;
name|sig
operator|<
name|NSIG
condition|;
name|sig
operator|++
control|)
block|{
name|sigs
index|[
name|sig
index|]
operator|=
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|prg
operator|=
name|getenv
argument_list|(
literal|"LOCKPRG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prg
operator|&&
name|strcmp
argument_list|(
name|prg
argument_list|,
literal|"builtin"
argument_list|)
operator|&&
operator|!
name|access
argument_list|(
name|prg
argument_list|,
name|X_OK
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYSV */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|debug1
argument_list|(
literal|"lockterminal: '%s' seems executable, execl it!\n"
argument_list|,
name|prg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Child */
name|setuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
comment|/* this should be done already */
name|setgid
argument_list|(
name|real_gid
argument_list|)
expr_stmt|;
name|closeallfiles
argument_list|()
expr_stmt|;
comment|/* important: /etc/shadow may be open */
name|execl
argument_list|(
name|prg
argument_list|,
literal|"SCREEN-LOCK"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|NETHACK
if|if
condition|(
name|nethackflag
condition|)
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Cannot fork terminal - lock failed"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|Msg
argument_list|(
name|errno
argument_list|,
literal|"Cannot lock terminal - fork failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BSDWAIT
name|union
name|wait
name|wstat
decl_stmt|;
else|#
directive|else
name|int
name|wstat
decl_stmt|;
endif|#
directive|endif
name|int
name|wret
decl_stmt|;
ifdef|#
directive|ifdef
name|hpux
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|wret
operator|=
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|wstat
argument_list|)
operator|)
operator|!=
name|pid
operator|)
operator|||
operator|(
operator|(
name|wret
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
operator|)
condition|)
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"Lock"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WTERMSIG
argument_list|(
name|wstat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Lock: %s: Killed by signal: %d%s\n"
argument_list|,
name|prg
argument_list|,
name|WTERMSIG
argument_list|(
name|wstat
argument_list|)
argument_list|,
name|WIFCORESIG
argument_list|(
name|wstat
argument_list|)
condition|?
literal|" (Core dumped)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wstat
argument_list|)
condition|)
block|{
name|debug2
argument_list|(
literal|"Lock: %s: return code %d\n"
argument_list|,
name|prg
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wstat
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|LockEnd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|prg
condition|)
block|{
name|debug1
argument_list|(
literal|"lockterminal: '%s' seems NOT executable, we use our builtin\n"
argument_list|,
name|prg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"lockterminal: using buitin.\n"
argument_list|)
expr_stmt|;
block|}
name|screen_builtin_lck
argument_list|()
expr_stmt|;
block|}
comment|/* reset signals */
for|for
control|(
name|sig
operator|=
literal|1
init|;
name|sig
operator|<
name|NSIG
condition|;
name|sig
operator|++
control|)
block|{
if|if
condition|(
name|sigs
index|[
name|sig
index|]
operator|!=
operator|(
name|SIGTYPE
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|-
literal|1
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|sigs
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* LockTerminal */
comment|/* -- original copyright by Luigi Cannelloni 1985 (luigi@faui70.UUCP) -- */
name|void
name|screen_builtin_lck
parameter_list|()
block|{
name|char
name|fullname
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
name|message
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|pass
decl_stmt|,
name|mypass
index|[
literal|9
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SHADOWPW
name|struct
name|spwd
modifier|*
name|sss
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|int
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|undef
comment|/* get password entry */
if|if
condition|(
operator|(
name|ppp
operator|=
name|getpwuid
argument_list|(
name|real_uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"screen_builtin_lck: No passwd entry.\007\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"screen_builtin_lck: Not a tty.\007\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|pass
operator|=
name|ppp
operator|->
name|pw_passwd
expr_stmt|;
ifdef|#
directive|ifdef
name|SHADOWPW
name|realpw
label|:
endif|#
directive|endif
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|13
condition|;
name|t
operator|++
control|)
block|{
name|c
operator|=
name|pass
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'/'
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|t
operator|<
literal|13
condition|)
block|{
name|debug
argument_list|(
literal|"builtin_lock: ppp->pw_passwd bad, has it a shadow?\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHADOWPW
name|setspent
argument_list|()
expr_stmt|;
comment|/* rewind shadow file */
if|if
condition|(
operator|(
name|sss
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sss
operator|=
name|getspnam
argument_list|(
name|ppp
operator|->
name|pw_name
argument_list|)
operator|)
condition|)
block|{
name|pass
operator|=
name|sss
operator|->
name|sp_pwdp
expr_stmt|;
goto|goto
name|realpw
goto|;
block|}
endif|#
directive|endif
comment|/* SHADOWPW */
if|if
condition|(
name|pass
operator|=
name|getpass
argument_list|(
literal|"Key:   "
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|mypass
argument_list|,
name|pass
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|mypass
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|mypass
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pass
operator|=
name|getpass
argument_list|(
literal|"Again: "
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|mypass
argument_list|,
name|pass
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Passwords don't match.\007\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Getpass error.\007\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
operator|=
literal|0
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"screen_builtin_lck looking in gcos field\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|ppp
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp1
operator|=
name|index
argument_list|(
name|fullname
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cp1
operator|=
name|index
argument_list|(
name|fullname
argument_list|,
literal|'&'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cp1
argument_list|,
literal|"%s"
argument_list|,
name|ppp
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
name|islower
argument_list|(
operator|*
name|cp1
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|cp1
argument_list|)
else|:
operator|*
name|cp1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Screen used by %s<%s>.\nPassword:\007"
argument_list|,
name|fullname
argument_list|,
name|ppp
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* loop here to wait for correct password */
for|for
control|(
init|;
condition|;
control|)
block|{
name|debug
argument_list|(
literal|"screen_builtin_lck awaiting password\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp1
operator|=
name|getpass
argument_list|(
name|message
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|AttacherFinit
argument_list|(
name|SIGARG
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|pass
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|cp1
argument_list|,
name|pass
argument_list|)
argument_list|,
name|pass
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp1
argument_list|,
name|mypass
argument_list|)
condition|)
break|break;
block|}
name|debug
argument_list|(
literal|"screen_builtin_lck: NO!!!!!\n"
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"password ok.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCK */
comment|/*  * Detach now has the following modes:  *	D_DETACH	SIG_BYE		detach backend and exit attacher  *	D_STOP		SIG_STOP	stop attacher (and detach backend)  *	D_REMOTE	SIG_BYE		remote detach -- reattach to new attacher  *	D_POWER 	SIG_POWER_BYE 	power detach -- attacher kills his parent  *	D_REMOTE_POWER	SIG_POWER_BYE	remote power detach -- both  *	D_LOCK		SIG_LOCK	lock the attacher  * (jw)  * we always remove our utmp slots. (even when "lock" or "stop")  * Note: Take extra care here, we may be called by unterrupt!  */
name|void
name|Detach
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|int
name|sign
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|UTMPOK
specifier|register
name|int
name|n
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Detached
condition|)
return|return;
name|debug1
argument_list|(
literal|"Detach(%d)\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fore
operator|&&
name|status
condition|)
name|RemoveStatus
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|SetTTY
argument_list|(
literal|0
argument_list|,
operator|&
name|OldMode
argument_list|)
expr_stmt|;
name|FinitTerm
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|D_DETACH
case|:
name|printf
argument_list|(
literal|"\n[detached]\n"
argument_list|)
expr_stmt|;
name|sign
operator|=
name|SIG_BYE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BSDJOBS
case|case
name|D_STOP
case|:
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sign
operator|=
name|SIG_STOP
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REMOTE_DETACH
case|case
name|D_REMOTE
case|:
name|printf
argument_list|(
literal|"\n[remote detached]\n"
argument_list|)
expr_stmt|;
name|sign
operator|=
name|SIG_BYE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POW_DETACH
case|case
name|D_POWER
case|:
name|printf
argument_list|(
literal|"\n[power detached]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PowDetachString
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|PowDetachString
argument_list|)
expr_stmt|;
name|sign
operator|=
name|SIG_POWER_BYE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REMOTE_DETACH
case|case
name|D_REMOTE_POWER
case|:
name|printf
argument_list|(
literal|"\n[remote power detached]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PowDetachString
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|PowDetachString
argument_list|)
expr_stmt|;
name|sign
operator|=
name|SIG_POWER_BYE
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|D_LOCK
case|:
name|ClearDisplay
argument_list|()
expr_stmt|;
name|sign
operator|=
name|SIG_LOCK
expr_stmt|;
comment|/* tell attacher to lock terminal with a lockprg. */
break|break;
block|}
ifdef|#
directive|ifdef
name|UTMPOK
for|for
control|(
name|n
operator|=
name|WinList
init|;
name|n
operator|!=
operator|-
literal|1
condition|;
name|n
operator|=
name|wtab
index|[
name|n
index|]
operator|->
name|WinLink
control|)
if|if
condition|(
name|wtab
index|[
name|n
index|]
operator|->
name|slot
operator|!=
operator|(
name|slot_t
operator|)
operator|-
literal|1
condition|)
block|{
name|RemoveUtmp
argument_list|(
name|wtab
index|[
name|n
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set the slot to 0 to get the window          * logged in again. 	 */
name|wtab
index|[
name|n
index|]
operator|->
name|slot
operator|=
operator|(
name|slot_t
operator|)
literal|0
expr_stmt|;
block|}
name|RestoreLoginSlot
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|freetty
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|SockPath
argument_list|,
comment|/* S_IFSOCK | */
literal|0600
argument_list|)
expr_stmt|;
comment|/* Flag detached-ness */
comment|/*      * tell father to father what to do. We do that after we      * freed the tty, thus getty feels more comfortable on hpux      * if it was a power detach.      */
name|Kill
argument_list|(
name|AttacherPid
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|debug2
argument_list|(
literal|"Detach: Signal %d to Attacher(%d)!\n"
argument_list|,
name|sign
argument_list|,
name|AttacherPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|D_LOCK
operator|&&
name|mode
operator|!=
name|D_STOP
condition|)
name|AttacherPid
operator|=
literal|0
expr_stmt|;
name|Detached
operator|=
literal|1
expr_stmt|;
name|Suspended
operator|=
operator|(
name|mode
operator|==
name|D_STOP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|fore
condition|)
name|fore
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|"Detach returns, we are successfully detached.\n"
argument_list|)
expr_stmt|;
block|}
name|void
name|Kill
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|pid
operator|<
literal|2
condition|)
return|return;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|IsSymbol
parameter_list|(
name|e
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|e
decl_stmt|,
decl|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|p
operator|=
name|e
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|strcmp
argument_list|(
name|e
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'='
expr_stmt|;
return|return
name|n
operator|==
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|MakeNewEnv
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|op
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
for|for
control|(
name|op
operator|=
name|environ
init|;
operator|*
name|op
condition|;
operator|++
name|op
control|)
empty_stmt|;
name|NewEnv
operator|=
name|np
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|op
operator|-
name|environ
operator|+
literal|6
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewEnv
condition|)
name|Msg_nomem
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|SockName
argument_list|)
operator|>
name|MAXSTR
operator|-
literal|5
condition|)
name|SockName
operator|=
literal|"?"
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"STY=%s"
argument_list|,
name|SockName
argument_list|)
expr_stmt|;
operator|*
name|np
operator|++
operator|=
name|buf
expr_stmt|;
comment|/* NewEnv[0] */
operator|*
name|np
operator|++
operator|=
name|Term
expr_stmt|;
comment|/* NewEnv[1] */
ifdef|#
directive|ifdef
name|TIOCSWINSZ
name|np
operator|+=
literal|2
expr_stmt|;
comment|/* room for TERMCAP and WINDOW */
else|#
directive|else
name|np
operator|+=
literal|4
expr_stmt|;
comment|/* room for TERMCAP WINDOW LINES COLUMNS */
endif|#
directive|endif
for|for
control|(
name|op
operator|=
name|environ
init|;
operator|*
name|op
condition|;
operator|++
name|op
control|)
block|{
if|if
condition|(
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"TERM"
argument_list|)
operator|&&
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"TERMCAP"
argument_list|)
operator|&&
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"STY"
argument_list|)
operator|&&
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"WINDOW"
argument_list|)
operator|&&
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"SCREENCAP"
argument_list|)
ifndef|#
directive|ifndef
name|TIOCGWINSZ
operator|&&
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"LINES"
argument_list|)
operator|&&
operator|!
name|IsSymbol
argument_list|(
operator|*
name|op
argument_list|,
literal|"COLUMNS"
argument_list|)
endif|#
directive|endif
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|op
expr_stmt|;
block|}
operator|*
name|np
operator|=
literal|0
expr_stmt|;
block|}
name|void
ifdef|#
directive|ifdef
name|USEVARARGS
comment|/*VARARGS2*/
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|Msg
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|Msg
parameter_list|(
name|err
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
specifier|static
name|va_list
name|ap
init|=
literal|0
decl_stmt|;
else|#
directive|else
comment|/*VARARGS2*/
name|Msg
argument_list|(
argument|err
argument_list|,
argument|fmt
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|,
argument|p4
argument_list|,
argument|p5
argument_list|,
argument|p6
argument_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|unsigned
name|long
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|p4
decl_stmt|,
name|p5
decl_stmt|,
name|p6
decl_stmt|;
block|{
endif|#
directive|endif
name|char
name|buf
index|[
name|MAXPATH
operator|*
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|Detached
condition|)
return|return;
ifdef|#
directive|ifdef
name|USEVARARGS
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|,
name|p5
argument_list|,
name|p6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|>
literal|0
operator|&&
name|err
operator|<
name|sys_nerr
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|": %s"
argument_list|,
name|sys_errlist
index|[
name|err
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|": Error %d"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HasWindow
condition|)
block|{
name|debug1
argument_list|(
literal|"Msg('%s');\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|MakeStatus
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\r\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|DeadlyMsg
condition|)
block|{
name|debug1
argument_list|(
literal|"Msg('%s') screen is not up, exiting..\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Kill
argument_list|(
name|AttacherPid
argument_list|,
name|SIG_BYE
argument_list|)
expr_stmt|;
name|eexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|debug1
argument_list|(
literal|"Harmless; Msg('%s');\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|DeadlyMsg
operator|=
literal|1
expr_stmt|;
block|}
name|char
modifier|*
name|Filename
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|s
return|;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>=
name|s
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
return|return
operator|++
name|p
return|;
block|}
comment|/*  * '^' is allowed as an escape mechanism for control characters. jw.  */
specifier|static
name|char
modifier|*
name|MakeWinMsg
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|ctrl
decl_stmt|;
name|ctrl
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|&&
name|p
operator|<
name|buf
operator|+
name|MAXSTR
operator|-
literal|1
condition|;
name|s
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|ctrl
condition|)
block|{
name|ctrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'^'
operator|||
operator|*
name|s
operator|<
literal|64
condition|)
operator|*
name|p
operator|=
operator|*
name|s
expr_stmt|;
else|else
operator|*
name|p
operator|=
operator|*
name|s
operator|-
literal|64
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'%'
case|:
operator|*
name|p
operator|=
name|n
operator|+
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
operator|*
name|p
operator|=
name|BELL
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|ctrl
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|--
operator|=
literal|'^'
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|=
operator|*
name|s
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

