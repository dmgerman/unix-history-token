begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Free Software Foundation, Inc. This file is part of the GNU C Library.  The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with the GNU C Library; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"maxpath.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_PATH_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|PATH_MAX
value|_POSIX_PATH_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAXPATHLEN
argument_list|)
end_if

begin_define
define|#
directive|define
name|PATH_MAX
value|MAXPATHLEN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PATH_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the pathname of the current working directory,    and put it in SIZE bytes of BUF.  Returns NULL if the    directory couldn't be determined or SIZE was too small.    If successful, returns BUF.  In GNU, if BUF is NULL,    an array is allocated with `malloc'; the array is SIZE    bytes long, unless SIZE<= 0, in which case it is as    big as necessary.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|char
modifier|*
name|getcwd
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
comment|/* from<sys/unistd.h> */
else|#
directive|else
function|char * getcwd
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
endif|#
directive|endif
block|{
name|dev_t
name|rootdev
decl_stmt|,
name|thisdev
decl_stmt|;
name|ino_t
name|rootino
decl_stmt|,
name|thisino
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|pathp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|pathp
operator|=
operator|&
name|path
index|[
sizeof|sizeof
argument_list|(
name|path
argument_list|)
index|]
expr_stmt|;
operator|*
operator|--
name|pathp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|thisdev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|thisino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rootdev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|rootino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|thisdev
operator|==
name|rootdev
operator|&&
name|thisino
operator|==
name|rootino
operator|)
condition|)
block|{
specifier|register
name|DIR
modifier|*
name|dirstream
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|dev_t
name|dotdev
decl_stmt|;
name|ino_t
name|dotino
decl_stmt|;
name|char
name|mount_point
decl_stmt|;
comment|/* Move up a directory.  */
if|if
condition|(
name|chdir
argument_list|(
literal|".."
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|pathp
operator|!=
operator|&
name|path
index|[
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
comment|/* Try to get back to the original directory. 		 This is the only place where this is possible.  */
name|int
name|save
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|pathp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Figure out if this directory is a mount point.  */
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dotdev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|dotino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
name|mount_point
operator|=
operator|(
name|dotdev
operator|!=
name|thisdev
operator|)
expr_stmt|;
comment|/* Search for the last directory.  */
name|dirstream
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirstream
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dirstream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|d
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|0
operator|||
operator|(
name|d
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|d
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
continue|continue;
comment|/* if (mount_point || d->d_fileno == thisino) */
if|if
condition|(
name|mount_point
operator|||
name|d
operator|->
name|d_ino
operator|==
name|thisino
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirstream
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_dev
operator|==
name|thisdev
operator|&&
name|st
operator|.
name|st_ino
operator|==
name|thisino
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirstream
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|int
name|d_namlen
init|=
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
decl_stmt|;
comment|/* new line */
name|pathp
operator|-=
name|d_namlen
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|pathp
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|d_namlen
argument_list|)
expr_stmt|;
operator|*
operator|--
name|pathp
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirstream
argument_list|)
expr_stmt|;
block|}
name|thisdev
operator|=
name|dotdev
expr_stmt|;
name|thisino
operator|=
name|dotino
expr_stmt|;
block|}
if|if
condition|(
name|pathp
operator|==
operator|&
name|path
index|[
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
condition|)
operator|*
operator|--
name|pathp
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pathp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|{
name|size_t
name|len
init|=
operator|&
name|path
index|[
sizeof|sizeof
argument_list|(
name|path
argument_list|)
index|]
operator|-
name|pathp
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|size
condition|)
name|len
operator|=
name|size
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|size
operator|<
name|len
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pathp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

