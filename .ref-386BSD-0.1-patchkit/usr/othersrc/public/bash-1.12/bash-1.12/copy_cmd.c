begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* copy_command.c -- copy a COMMAND structure.  This is needed    primarily for making function definitions, but I'm not sure    that anyone else will need it.  */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_comment
comment|/* Forward declaration. */
end_comment

begin_function_decl
specifier|extern
name|COMMAND
modifier|*
name|copy_command
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|WORD_DESC
modifier|*
name|copy_word
parameter_list|(
name|word
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
block|{
name|WORD_DESC
modifier|*
name|new_word
init|=
operator|(
name|WORD_DESC
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_DESC
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|word
argument_list|,
name|new_word
argument_list|,
sizeof|sizeof
argument_list|(
name|WORD_DESC
argument_list|)
argument_list|)
expr_stmt|;
name|new_word
operator|->
name|word
operator|=
name|savestring
argument_list|(
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_word
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the chain of words in LIST.  Return a pointer to     the new chain. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|copy_word_list
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|new_list
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|WORD_LIST
modifier|*
name|temp
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|temp
expr_stmt|;
name|new_list
operator|->
name|word
operator|=
name|copy_word
argument_list|(
name|list
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|new_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PATTERN_LIST
modifier|*
name|copy_case_clause
parameter_list|(
name|clause
parameter_list|)
name|PATTERN_LIST
modifier|*
name|clause
decl_stmt|;
block|{
name|PATTERN_LIST
modifier|*
name|new_clause
init|=
operator|(
name|PATTERN_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PATTERN_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|new_clause
operator|->
name|patterns
operator|=
name|copy_word_list
argument_list|(
name|clause
operator|->
name|patterns
argument_list|)
expr_stmt|;
name|new_clause
operator|->
name|action
operator|=
name|copy_command
argument_list|(
name|clause
operator|->
name|action
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_clause
operator|)
return|;
block|}
end_function

begin_function
name|PATTERN_LIST
modifier|*
name|copy_case_clauses
parameter_list|(
name|clauses
parameter_list|)
name|PATTERN_LIST
modifier|*
name|clauses
decl_stmt|;
block|{
name|PATTERN_LIST
modifier|*
name|new_list
init|=
operator|(
name|PATTERN_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|clauses
condition|)
block|{
name|PATTERN_LIST
modifier|*
name|new_clause
init|=
name|copy_case_clause
argument_list|(
name|clauses
argument_list|)
decl_stmt|;
name|new_clause
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|new_clause
expr_stmt|;
name|clauses
operator|=
name|clauses
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|PATTERN_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|new_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy a single redirect. */
end_comment

begin_function
name|REDIRECT
modifier|*
name|copy_redirect
parameter_list|(
name|redirect
parameter_list|)
name|REDIRECT
modifier|*
name|redirect
decl_stmt|;
block|{
name|REDIRECT
modifier|*
name|new_redirect
init|=
operator|(
name|REDIRECT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REDIRECT
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|redirect
argument_list|,
name|new_redirect
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|REDIRECT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|redirect
operator|->
name|instruction
condition|)
block|{
case|case
name|r_reading_until
case|:
case|case
name|r_deblank_reading_until
case|:
name|new_redirect
operator|->
name|here_doc_eof
operator|=
name|savestring
argument_list|(
name|redirect
operator|->
name|here_doc_eof
argument_list|)
expr_stmt|;
comment|/* There is NO BREAK HERE ON PURPOSE!!!! */
case|case
name|r_appending_to
case|:
case|case
name|r_output_direction
case|:
case|case
name|r_input_direction
case|:
case|case
name|r_inputa_direction
case|:
case|case
name|r_err_and_out
case|:
case|case
name|r_input_output
case|:
case|case
name|r_output_force
case|:
case|case
name|r_duplicating_input_word
case|:
case|case
name|r_duplicating_output_word
case|:
name|new_redirect
operator|->
name|redirectee
operator|.
name|filename
operator|=
name|copy_word
argument_list|(
name|redirect
operator|->
name|redirectee
operator|.
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|new_redirect
operator|)
return|;
block|}
end_function

begin_function
name|REDIRECT
modifier|*
name|copy_redirects
parameter_list|(
name|list
parameter_list|)
name|REDIRECT
modifier|*
name|list
decl_stmt|;
block|{
name|REDIRECT
modifier|*
name|new_list
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|REDIRECT
modifier|*
name|temp
init|=
name|copy_redirect
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|temp
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|REDIRECT
operator|*
operator|)
name|reverse_list
argument_list|(
name|new_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|FOR_COM
modifier|*
name|copy_for_command
parameter_list|(
name|com
parameter_list|)
name|FOR_COM
modifier|*
name|com
decl_stmt|;
block|{
name|FOR_COM
modifier|*
name|new_for
init|=
operator|(
name|FOR_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FOR_COM
argument_list|)
argument_list|)
decl_stmt|;
name|new_for
operator|->
name|flags
operator|=
name|com
operator|->
name|flags
expr_stmt|;
name|new_for
operator|->
name|name
operator|=
name|copy_word
argument_list|(
name|com
operator|->
name|name
argument_list|)
expr_stmt|;
name|new_for
operator|->
name|map_list
operator|=
name|copy_word_list
argument_list|(
name|com
operator|->
name|map_list
argument_list|)
expr_stmt|;
name|new_for
operator|->
name|action
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|action
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_for
operator|)
return|;
block|}
end_function

begin_function
name|GROUP_COM
modifier|*
name|copy_group_command
parameter_list|(
name|com
parameter_list|)
name|GROUP_COM
modifier|*
name|com
decl_stmt|;
block|{
name|GROUP_COM
modifier|*
name|new_group
init|=
operator|(
name|GROUP_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GROUP_COM
argument_list|)
argument_list|)
decl_stmt|;
name|new_group
operator|->
name|command
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_group
operator|)
return|;
block|}
end_function

begin_function
name|CASE_COM
modifier|*
name|copy_case_command
parameter_list|(
name|com
parameter_list|)
name|CASE_COM
modifier|*
name|com
decl_stmt|;
block|{
name|CASE_COM
modifier|*
name|new_case
init|=
operator|(
name|CASE_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CASE_COM
argument_list|)
argument_list|)
decl_stmt|;
name|new_case
operator|->
name|flags
operator|=
name|com
operator|->
name|flags
expr_stmt|;
name|new_case
operator|->
name|word
operator|=
name|copy_word
argument_list|(
name|com
operator|->
name|word
argument_list|)
expr_stmt|;
name|new_case
operator|->
name|clauses
operator|=
name|copy_case_clauses
argument_list|(
name|com
operator|->
name|clauses
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_case
operator|)
return|;
block|}
end_function

begin_function
name|WHILE_COM
modifier|*
name|copy_while_command
parameter_list|(
name|com
parameter_list|)
name|WHILE_COM
modifier|*
name|com
decl_stmt|;
block|{
name|WHILE_COM
modifier|*
name|new_while
init|=
operator|(
name|WHILE_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WHILE_COM
argument_list|)
argument_list|)
decl_stmt|;
name|new_while
operator|->
name|flags
operator|=
name|com
operator|->
name|flags
expr_stmt|;
name|new_while
operator|->
name|test
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|test
argument_list|)
expr_stmt|;
name|new_while
operator|->
name|action
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|action
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_while
operator|)
return|;
block|}
end_function

begin_function
name|IF_COM
modifier|*
name|copy_if_command
parameter_list|(
name|com
parameter_list|)
name|IF_COM
modifier|*
name|com
decl_stmt|;
block|{
name|IF_COM
modifier|*
name|new_if
init|=
operator|(
name|IF_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IF_COM
argument_list|)
argument_list|)
decl_stmt|;
name|new_if
operator|->
name|flags
operator|=
name|com
operator|->
name|flags
expr_stmt|;
name|new_if
operator|->
name|test
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|test
argument_list|)
expr_stmt|;
name|new_if
operator|->
name|true_case
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|true_case
argument_list|)
expr_stmt|;
name|new_if
operator|->
name|false_case
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|false_case
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_if
operator|)
return|;
block|}
end_function

begin_function
name|SIMPLE_COM
modifier|*
name|copy_simple_command
parameter_list|(
name|com
parameter_list|)
name|SIMPLE_COM
modifier|*
name|com
decl_stmt|;
block|{
name|SIMPLE_COM
modifier|*
name|new_simple
init|=
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SIMPLE_COM
argument_list|)
argument_list|)
decl_stmt|;
name|new_simple
operator|->
name|flags
operator|=
name|com
operator|->
name|flags
expr_stmt|;
name|new_simple
operator|->
name|words
operator|=
name|copy_word_list
argument_list|(
name|com
operator|->
name|words
argument_list|)
expr_stmt|;
name|new_simple
operator|->
name|redirects
operator|=
name|copy_redirects
argument_list|(
name|com
operator|->
name|redirects
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_simple
operator|)
return|;
block|}
end_function

begin_function
name|FUNCTION_DEF
modifier|*
name|copy_function_def
parameter_list|(
name|com
parameter_list|)
name|FUNCTION_DEF
modifier|*
name|com
decl_stmt|;
block|{
name|FUNCTION_DEF
modifier|*
name|new_def
init|=
operator|(
name|FUNCTION_DEF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FUNCTION_DEF
argument_list|)
argument_list|)
decl_stmt|;
name|new_def
operator|->
name|name
operator|=
name|copy_word
argument_list|(
name|com
operator|->
name|name
argument_list|)
expr_stmt|;
name|new_def
operator|->
name|command
operator|=
name|copy_command
argument_list|(
name|com
operator|->
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_def
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the command structure in COMMAND.  Return a pointer to the    copy.  Don't you forget to dispose_command () on this pointer    later! */
end_comment

begin_function
name|COMMAND
modifier|*
name|copy_command
parameter_list|(
name|command
parameter_list|)
name|COMMAND
modifier|*
name|command
decl_stmt|;
block|{
name|COMMAND
modifier|*
name|new_command
init|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|command
condition|)
block|{
name|new_command
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|command
argument_list|,
name|new_command
argument_list|,
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|new_command
operator|->
name|flags
operator|=
name|command
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|redirects
condition|)
name|new_command
operator|->
name|redirects
operator|=
name|copy_redirects
argument_list|(
name|command
operator|->
name|redirects
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
operator|->
name|type
condition|)
block|{
case|case
name|cm_for
case|:
name|new_command
operator|->
name|value
operator|.
name|For
operator|=
name|copy_for_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|For
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_group
case|:
name|new_command
operator|->
name|value
operator|.
name|Group
operator|=
name|copy_group_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Group
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_case
case|:
name|new_command
operator|->
name|value
operator|.
name|Case
operator|=
name|copy_case_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Case
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_until
case|:
case|case
name|cm_while
case|:
name|new_command
operator|->
name|value
operator|.
name|While
operator|=
name|copy_while_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|While
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_if
case|:
name|new_command
operator|->
name|value
operator|.
name|If
operator|=
name|copy_if_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|If
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_simple
case|:
name|new_command
operator|->
name|value
operator|.
name|Simple
operator|=
name|copy_simple_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Simple
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_connection
case|:
block|{
name|CONNECTION
modifier|*
name|new_connection
decl_stmt|;
name|new_connection
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CONNECTION
argument_list|)
argument_list|)
expr_stmt|;
name|new_connection
operator|->
name|connector
operator|=
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
expr_stmt|;
name|new_connection
operator|->
name|first
operator|=
name|copy_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
argument_list|)
expr_stmt|;
name|new_connection
operator|->
name|second
operator|=
name|copy_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
argument_list|)
expr_stmt|;
name|new_command
operator|->
name|value
operator|.
name|Connection
operator|=
name|new_connection
expr_stmt|;
break|break;
block|}
comment|/* Pathological case.  I'm not even sure that you can have a 	     function definition as part of a function definition. */
case|case
name|cm_function_def
case|:
name|new_command
operator|->
name|value
operator|.
name|Function_def
operator|=
name|copy_function_def
argument_list|(
name|command
operator|->
name|value
operator|.
name|Function_def
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|new_command
operator|)
return|;
block|}
end_function

end_unit

