begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hash.c -- Where hashing for bash is done. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* There appears to be library functions for this stuff, but it seems like    a lot of overhead, so I just implemented this hashing stuff on my own. */
end_comment

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|hashed_filenames
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FILENAME_HASH_BUCKETS
value|107
end_define

begin_comment
comment|/* Create the hash table for filenames that we use in the shell. */
end_comment

begin_macro
name|initialize_hashed_filenames
argument_list|()
end_macro

begin_block
block|{
name|hashed_filenames
operator|=
name|make_hash_table
argument_list|(
name|FILENAME_HASH_BUCKETS
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make a new hash table with BUCKETS number of buckets.  Initialize    each slot in the table to NULL. */
end_comment

begin_function
name|HASH_TABLE
modifier|*
name|make_hash_table
parameter_list|(
name|buckets
parameter_list|)
name|int
name|buckets
decl_stmt|;
block|{
name|HASH_TABLE
modifier|*
name|new_table
init|=
operator|(
name|HASH_TABLE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HASH_TABLE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buckets
condition|)
name|buckets
operator|=
name|DEFAULT_HASH_BUCKETS
expr_stmt|;
name|new_table
operator|->
name|bucket_array
operator|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|BUCKET_CONTENTS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_table
operator|->
name|nbuckets
operator|=
name|buckets
expr_stmt|;
name|new_table
operator|->
name|nentries
operator|=
literal|0
expr_stmt|;
name|initialize_hash_table
argument_list|(
name|new_table
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_table
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Zero the buckets in TABLE. */
end_comment

begin_macro
name|initialize_hash_table
argument_list|(
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
name|table
operator|->
name|bucket_array
index|[
name|i
index|]
operator|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the location of the bucket which should contain the data    for STRING.  TABLE is a pointer to a HASH_TABLE. */
end_comment

begin_macro
name|hash_string
argument_list|(
argument|string
argument_list|,
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
name|i
operator|+=
operator|*
name|string
operator|++
expr_stmt|;
name|i
operator|%=
name|table
operator|->
name|nbuckets
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return a pointer to the hashed item, or NULL if the item    can't be found. */
end_comment

begin_function
name|BUCKET_CONTENTS
modifier|*
name|find_hash_item
parameter_list|(
name|string
parameter_list|,
name|table
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
block|{
name|BUCKET_CONTENTS
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|table
operator|->
name|bucket_array
index|[
name|hash_string
argument_list|(
name|string
argument_list|,
name|table
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|list
operator|->
name|key
argument_list|,
name|string
argument_list|)
condition|)
block|{
name|list
operator|->
name|times_found
operator|++
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
else|else
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Remove the item specified by STRING from the hash table TABLE.    The item removed is returned, so you can free its contents.  If    the item isn't in this table NULL is returned. */
end_comment

begin_function
name|BUCKET_CONTENTS
modifier|*
name|remove_hash_item
parameter_list|(
name|string
parameter_list|,
name|table
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|the_bucket
init|=
name|hash_string
argument_list|(
name|string
argument_list|,
name|table
argument_list|)
decl_stmt|;
name|BUCKET_CONTENTS
modifier|*
name|prev
init|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
decl_stmt|;
name|BUCKET_CONTENTS
modifier|*
name|temp
init|=
name|table
operator|->
name|bucket_array
index|[
name|the_bucket
index|]
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|key
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
name|table
operator|->
name|bucket_array
index|[
name|the_bucket
index|]
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|table
operator|->
name|nentries
operator|--
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create an entry for STRING, in TABLE.  If the entry already    exists, then return it. */
end_comment

begin_function
name|BUCKET_CONTENTS
modifier|*
name|add_hash_item
parameter_list|(
name|string
parameter_list|,
name|table
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
block|{
name|BUCKET_CONTENTS
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|item
operator|=
name|find_hash_item
argument_list|(
name|string
argument_list|,
name|table
argument_list|)
operator|)
condition|)
block|{
name|int
name|bucket
init|=
name|hash_string
argument_list|(
name|string
argument_list|,
name|table
argument_list|)
decl_stmt|;
name|item
operator|=
name|table
operator|->
name|bucket_array
index|[
name|bucket
index|]
expr_stmt|;
while|while
condition|(
name|item
operator|&&
name|item
operator|->
name|next
condition|)
name|item
operator|=
name|item
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
name|item
operator|->
name|next
operator|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BUCKET_CONTENTS
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|bucket_array
index|[
name|bucket
index|]
operator|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BUCKET_CONTENTS
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|table
operator|->
name|bucket_array
index|[
name|bucket
index|]
expr_stmt|;
block|}
name|item
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|item
operator|->
name|next
operator|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
expr_stmt|;
name|item
operator|->
name|key
operator|=
name|string
expr_stmt|;
name|table
operator|->
name|nentries
operator|++
expr_stmt|;
name|item
operator|->
name|times_found
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the bucket_contents list of bucket BUCKET in TABLE.  If    TABLE doesn't have BUCKET buckets, return NULL. */
end_comment

begin_function
name|BUCKET_CONTENTS
modifier|*
name|get_hash_bucket
parameter_list|(
name|bucket
parameter_list|,
name|table
parameter_list|)
name|int
name|bucket
decl_stmt|;
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
block|{
if|if
condition|(
name|bucket
operator|<
name|table
operator|->
name|nbuckets
condition|)
return|return
operator|(
name|table
operator|->
name|bucket_array
index|[
name|bucket
index|]
operator|)
return|;
else|else
return|return
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_HASHING
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NBUCKETS
value|107
end_define

begin_macro
name|xmalloc
argument_list|(
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|int
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|result
operator|)
return|;
block|}
end_block

begin_function
name|main
parameter_list|()
block|{
name|char
name|string
index|[
literal|256
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|BUCKET_CONTENTS
modifier|*
name|tt
decl_stmt|;
name|table
operator|=
name|make_hash_table
argument_list|(
name|NBUCKETS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Enter some data to be hashed, a word at a time.\n\ Type a blank line when done:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|temp_string
init|=
name|savestring
argument_list|(
name|gets
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|string
condition|)
break|break;
name|tt
operator|=
name|add_hash_item
argument_list|(
name|temp_string
argument_list|,
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|times_found
condition|)
block|{
name|printf
argument_list|(
literal|"\nYou have already added that item\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\nYou have entered %d (%d) items.  The items are:\n\n"
argument_list|,
name|table
operator|->
name|nentries
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|table
operator|->
name|nbuckets
condition|;
name|count
operator|++
control|)
block|{
specifier|register
name|BUCKET_CONTENTS
modifier|*
name|list
init|=
name|get_hash_bucket
argument_list|(
name|count
argument_list|,
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|printf
argument_list|(
literal|"%3d slot: "
argument_list|,
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n	     "
argument_list|,
name|list
operator|->
name|key
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_HASHING */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Local variables:  * compile-command: "gcc -g -DTEST_HASHING -o hash hash.c"  * end:  */
end_comment

end_unit

