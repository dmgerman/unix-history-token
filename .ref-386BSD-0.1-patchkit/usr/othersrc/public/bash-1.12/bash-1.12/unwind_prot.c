begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* I can't stand it anymore!  Please can't we just write the    whole Unix system in lisp or something? */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		      Unwind Protection Scheme for Bash		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"unwind_prot.h"
end_include

begin_comment
comment|/* If CLEANUP is null, then ARG contains a tag to throw back to. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_uwp
block|{
name|struct
name|_uwp
modifier|*
name|next
decl_stmt|;
name|Function
modifier|*
name|cleanup
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|}
name|UNWIND_ELT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|unwind_frame_discard_internal
argument_list|()
decl_stmt|,
name|unwind_frame_run_internal
argument_list|()
decl_stmt|,
name|add_unwind_protect_internal
argument_list|()
decl_stmt|,
name|remove_unwind_protect_internal
argument_list|()
decl_stmt|,
name|run_unwind_protects_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNWIND_ELT
modifier|*
name|unwind_protect_list
init|=
operator|(
name|UNWIND_ELT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Run a function without interrupts. */
end_comment

begin_function
name|void
name|without_interrupts
parameter_list|(
name|function
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|VFunction
modifier|*
name|function
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|oset
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
name|SigHandler
modifier|*
name|old_int
decl_stmt|;
name|old_int
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|oldmask
init|=
name|sigblock
argument_list|(
name|SIGINT
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
call|(
modifier|*
name|function
call|)
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_int
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Start the beginning of a region. */
end_comment

begin_function
name|void
name|begin_unwind_frame
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|add_unwind_protect
argument_list|(
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard the unwind protects back to TAG. */
end_comment

begin_function
name|void
name|discard_unwind_frame
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|without_interrupts
argument_list|(
name|unwind_frame_discard_internal
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run the unwind protects back to TAG. */
end_comment

begin_function
name|void
name|run_unwind_frame
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|without_interrupts
argument_list|(
name|unwind_frame_run_internal
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the function CLEANUP with ARG to the list of unwindable things. */
end_comment

begin_function
name|void
name|add_unwind_protect
parameter_list|(
name|cleanup
parameter_list|,
name|arg
parameter_list|)
name|Function
modifier|*
name|cleanup
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|without_interrupts
argument_list|(
name|add_unwind_protect_internal
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cleanup
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the top unwind protect from the list. */
end_comment

begin_function
name|void
name|remove_unwind_protect
parameter_list|()
block|{
name|without_interrupts
argument_list|(
name|remove_unwind_protect_internal
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run the list of cleanup functions in unwind_protect_list. */
end_comment

begin_function
name|void
name|run_unwind_protects
parameter_list|()
block|{
name|without_interrupts
argument_list|(
name|run_unwind_protects_internal
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*                        The Actual Functions                 	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|add_unwind_protect_internal
parameter_list|(
name|cleanup
parameter_list|,
name|arg
parameter_list|)
name|Function
modifier|*
name|cleanup
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|UNWIND_ELT
modifier|*
name|elt
decl_stmt|;
name|elt
operator|=
operator|(
name|UNWIND_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|UNWIND_ELT
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|cleanup
operator|=
name|cleanup
expr_stmt|;
name|elt
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|elt
operator|->
name|next
operator|=
name|unwind_protect_list
expr_stmt|;
name|unwind_protect_list
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_unwind_protect_internal
parameter_list|()
block|{
name|UNWIND_ELT
modifier|*
name|elt
init|=
name|unwind_protect_list
decl_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
name|unwind_protect_list
operator|=
name|unwind_protect_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|run_unwind_protects_internal
parameter_list|()
block|{
name|UNWIND_ELT
modifier|*
name|t
decl_stmt|,
modifier|*
name|elt
init|=
name|unwind_protect_list
decl_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
comment|/* This function can be run at strange times, like when unwinding 	the entire world of unwind protects.  Thus, we may come across 	 an element which is simply a label for a catch frame.  Don't call 	 the non-existant function. */
if|if
condition|(
name|elt
operator|->
name|cleanup
condition|)
operator|(
operator|*
operator|(
name|elt
operator|->
name|cleanup
operator|)
operator|)
operator|(
name|elt
operator|->
name|arg
operator|)
expr_stmt|;
name|t
operator|=
name|elt
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|unwind_protect_list
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unwind_frame_discard_internal
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|UNWIND_ELT
modifier|*
name|elt
decl_stmt|;
while|while
condition|(
name|elt
operator|=
name|unwind_protect_list
condition|)
block|{
name|unwind_protect_list
operator|=
name|unwind_protect_list
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|elt
operator|->
name|cleanup
operator|&&
operator|(
name|STREQ
argument_list|(
name|elt
operator|->
name|arg
argument_list|,
name|tag
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unwind_frame_run_internal
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|UNWIND_ELT
modifier|*
name|elt
decl_stmt|;
while|while
condition|(
name|elt
operator|=
name|unwind_protect_list
condition|)
block|{
name|unwind_protect_list
operator|=
name|elt
operator|->
name|next
expr_stmt|;
comment|/* If tag, then compare. */
if|if
condition|(
operator|!
name|elt
operator|->
name|cleanup
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|elt
operator|->
name|arg
argument_list|,
name|tag
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|(
operator|*
operator|(
name|elt
operator|->
name|cleanup
operator|)
operator|)
operator|(
name|elt
operator|->
name|arg
operator|)
expr_stmt|;
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Structure describing a saved variable and the value to restore it to. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
modifier|*
name|variable
decl_stmt|;
name|char
modifier|*
name|desired_setting
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
name|SAVED_VAR
typedef|;
end_typedef

begin_comment
comment|/* Restore the value of a variable, based on the contents of SV.  If    sv->size is greater than sizeof (char *), sv->desired_setting points to    a block of memory SIZE bytes long holding the value, rather than the    value itself.  This block of memory is copied back into the variable. */
end_comment

begin_function
specifier|static
name|void
name|restore_variable
parameter_list|(
name|sv
parameter_list|)
name|SAVED_VAR
modifier|*
name|sv
decl_stmt|;
block|{
comment|/* I wrote this switch statement not realizing how silly some compilers      can be.  Since we expect both cases to be the same size, it really      makes no difference (today), but it irks me that I cannot express the      thought clearly. */
switch|switch
condition|(
name|sv
operator|->
name|size
condition|)
block|{
comment|/* case sizeof (char *): */
case|case
sizeof|sizeof
argument_list|(
name|int
argument_list|)
case|:
operator|*
operator|(
name|sv
operator|->
name|variable
operator|)
operator|=
operator|(
name|int
operator|)
name|sv
operator|->
name|desired_setting
expr_stmt|;
break|break;
default|default:
name|bcopy
argument_list|(
name|sv
operator|->
name|desired_setting
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sv
operator|->
name|variable
argument_list|,
name|sv
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sv
operator|->
name|desired_setting
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the value of a variable so it will be restored when unwind-protects    are run.  VAR is a pointer to the variable.  VALUE is the value to be    saved.  SIZE is the size in bytes of VALUE.  If SIZE is bigger than what    can be saved in a char *, memory will be allocated and the value saved    into that using bcopy (). */
end_comment

begin_function
name|void
name|unwind_protect_var
parameter_list|(
name|var
parameter_list|,
name|value
parameter_list|,
name|size
parameter_list|)
name|int
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|SAVED_VAR
modifier|*
name|s
init|=
operator|(
name|SAVED_VAR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SAVED_VAR
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|variable
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
block|{
name|s
operator|->
name|desired_setting
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|value
argument_list|,
name|s
operator|->
name|desired_setting
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|->
name|desired_setting
operator|=
name|value
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|add_unwind_protect
argument_list|(
operator|(
name|Function
operator|*
operator|)
name|restore_variable
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

