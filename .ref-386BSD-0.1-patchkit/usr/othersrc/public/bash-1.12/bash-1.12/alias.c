begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* alias.c -- Not a full alias, but just the kind that we use in the    shell.  Csh style alias is somewhere else (`over there, in a box'). */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_comment
comment|/* The number of slots to allocate when we need new slots. */
end_comment

begin_define
define|#
directive|define
name|alias_list_grow_amount
value|50
end_define

begin_comment
comment|/* Non-zero means expand all words on the line.  Otherwise, expand    after first expansion if the expansion ends in a space. */
end_comment

begin_decl_stmt
name|int
name|alias_expand_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of aliases that we have. */
end_comment

begin_decl_stmt
name|ASSOC
modifier|*
modifier|*
name|aliases
init|=
operator|(
name|ASSOC
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots in the above list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aliases_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of aliases that are in existence. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aliases_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last alias index found with find_alias (). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_alias_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan the list of aliases looking for one with NAME.  Return NULL    if the alias doesn't exist, else a pointer to the assoc. */
end_comment

begin_function
name|ASSOC
modifier|*
name|find_alias
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliases_length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|aliases
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|aliases
index|[
name|last_alias_index
operator|=
name|i
index|]
operator|)
return|;
return|return
operator|(
operator|(
name|ASSOC
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the alias for NAME, or NULL if there is none. */
end_comment

begin_function
name|char
modifier|*
name|get_alias_value
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ASSOC
modifier|*
name|alias
init|=
name|find_alias
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
condition|)
return|return
operator|(
name|alias
operator|->
name|value
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a new alias from NAME and VALUE.  If NAME can be found,    then replace its value. */
end_comment

begin_function
name|void
name|add_alias
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|ASSOC
modifier|*
name|temp
init|=
name|find_alias
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|ASSOC
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASSOC
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aliases_length
operator|+
literal|1
operator|)
operator|>=
name|aliases_size
condition|)
block|{
name|aliases
operator|=
operator|(
name|ASSOC
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|aliases
argument_list|,
operator|(
name|aliases_size
operator|+=
name|alias_list_grow_amount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ASSOC
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aliases
index|[
name|aliases_length
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|aliases
index|[
name|aliases_length
index|]
operator|=
operator|(
name|ASSOC
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Remove the alias with name NAME from the alias list.  Returns    the index of the removed alias, or -1 if the alias didn't exist. */
end_comment

begin_function
name|int
name|remove_alias
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|find_alias
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|=
name|last_alias_index
expr_stmt|;
name|free
argument_list|(
name|aliases
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aliases
index|[
name|i
index|]
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aliases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|aliases_length
condition|;
name|i
operator|++
control|)
name|aliases
index|[
name|i
index|]
operator|=
name|aliases
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|aliases_length
operator|--
expr_stmt|;
name|aliases
index|[
name|aliases_length
index|]
operator|=
operator|(
name|ASSOC
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|last_alias_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all aliases. */
end_comment

begin_macro
name|delete_all_aliases
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aliases_length
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|aliases
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aliases
index|[
name|i
index|]
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aliases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|aliases
index|[
name|i
index|]
operator|=
operator|(
name|ASSOC
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|aliases_length
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return non-zero if CHARACTER is a member of the class of characters    that are self-delimiting in the shell (this really means that these    characters delimit tokens). */
end_comment

begin_define
define|#
directive|define
name|self_delimiting
parameter_list|(
name|character
parameter_list|)
value|(member ((character), " \t\n\r;|&()"))
end_define

begin_comment
comment|/* Return non-zero if CHARACTER is a member of the class of characters    that delimit commands in the shell. */
end_comment

begin_define
define|#
directive|define
name|command_separator
parameter_list|(
name|character
parameter_list|)
value|(member ((character), "\r\n;|&("))
end_define

begin_comment
comment|/* If this is 1, we are checking the next token read for alias expansion    because it is the first word in a command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_word
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is for skipping quoted strings in alias expansions. */
end_comment

begin_define
define|#
directive|define
name|quote_char
parameter_list|(
name|c
parameter_list|)
value|(((c) == '\'') || ((c) == '"'))
end_define

begin_comment
comment|/* Consume a quoted string from STRING, starting at string[START] (so    string[START] is the opening quote character), and return the index    of the closing quote character matching the opening quote character.    This handles single matching pairs of unquoted quotes; it could afford    to be a little smarter... This skips words between balanced pairs of    quotes, words where the first character is quoted with a `\', and other    backslash-escaped characters. */
end_comment

begin_function
specifier|static
name|int
name|skipquotes
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|delimiter
init|=
name|string
index|[
name|start
index|]
decl_stmt|;
comment|/* i starts at START + 1 because string[START] is the opening quote      character. */
for|for
control|(
name|i
operator|=
name|start
operator|+
literal|1
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* skip backslash-quoted quote characters, too */
continue|continue;
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
return|return
name|i
return|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip the white space and any quoted characters in STRING, starting at    START.  Return the new index into STRING, after zero or more characters    have been skipped. */
end_comment

begin_function
specifier|static
name|int
name|skipws
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|pass_next
decl_stmt|,
name|backslash_quoted_word
decl_stmt|,
name|peekc
decl_stmt|;
comment|/* skip quoted strings, in ' or ", and words in which a character is quoted      with a `\'. */
name|backslash_quoted_word
operator|=
name|pass_next
operator|=
literal|0
expr_stmt|;
comment|/* Skip leading whitespace (or separator characters), and quoted words.      But save it in the output.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pass_next
condition|)
block|{
name|pass_next
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|backslash_quoted_word
operator|=
literal|0
expr_stmt|;
comment|/* we are no longer in a backslash-quoted word */
continue|continue;
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|peekc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|isletter
argument_list|(
name|peekc
argument_list|)
condition|)
name|backslash_quoted_word
operator|++
expr_stmt|;
comment|/* this is a backslash-quoted word */
else|else
name|pass_next
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* This only handles single pairs of non-escaped quotes.  This 	 overloads backslash_quoted_word to also mean that a word like 	 ""f is being scanned, so that the quotes will inhibit any expansion 	 of the word. */
if|if
condition|(
name|quote_char
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|skipquotes
argument_list|(
name|string
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* This could be a line that contains a single quote character, 	     in which case skipquotes () terminates with string[i] == '\0' 	     (the end of the string).  Check for that here. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|peekc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|isletter
argument_list|(
name|peekc
argument_list|)
condition|)
name|backslash_quoted_word
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* If we're in the middle of some kind of quoted word, let it 	 pass through. */
if|if
condition|(
name|backslash_quoted_word
condition|)
continue|continue;
comment|/* If this character is a shell command separator, then set a hint for 	 alias_expand that the next token is the first word in a command. */
if|if
condition|(
name|command_separator
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|command_word
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Characters that may appear in a token.  Basically, anything except white    space and a token separator. */
end_comment

begin_define
define|#
directive|define
name|token_char
parameter_list|(
name|c
parameter_list|)
value|(!((whitespace (string[i]) || self_delimiting (string[i]))))
end_define

begin_comment
comment|/* Read from START in STRING until the next separator character, and return    the index of that separator.  Skip backslash-quoted characters.  Call    skipquotes () for quoted strings in the middle or at the end of tokens,    so all characters show up (e.g. foo'' and foo""bar) */
end_comment

begin_function
specifier|static
name|int
name|rd_token
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* From here to next separator character is a token. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|string
index|[
name|i
index|]
operator|&&
name|token_char
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* skip backslash-escaped character */
continue|continue;
block|}
comment|/* If this character is a quote character, we want to call skipquotes 	 to get the whole quoted portion as part of this word.  That word 	 will not generally match an alias, even if te unquoted word would 	 have.  The presence of the quotes in the token serves then to  	 inhibit expansion. */
if|if
condition|(
name|quote_char
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|skipquotes
argument_list|(
name|string
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Now string[i] is the matching quote character, and the 	     quoted portion of the token has been scanned. */
continue|continue;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new line, with any aliases substituted. */
end_comment

begin_function
name|char
modifier|*
name|alias_expand
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|line_len
init|=
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|line
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_len
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|start
decl_stmt|;
name|char
modifier|*
name|token
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|line_len
argument_list|)
decl_stmt|;
name|int
name|tl
decl_stmt|,
name|real_start
decl_stmt|,
name|expand_next
decl_stmt|,
name|expand_this_token
decl_stmt|;
name|ASSOC
modifier|*
name|alias
decl_stmt|;
name|line
index|[
literal|0
index|]
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|expand_next
operator|=
literal|0
expr_stmt|;
name|command_word
operator|=
literal|1
expr_stmt|;
comment|/* initialized to expand the first word on the line */
comment|/* Each time through the loop we find the next word in line.  If it      has an alias, substitute      the alias value.  If the value ends in ` ', then try again      with the next word.  Else, if there is no value, or if      the value does not end in space, we are done. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
comment|/* Skip white space and quoted characters */
name|i
operator|=
name|skipws
argument_list|(
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|i
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|line
operator|)
return|;
comment|/* copy the just-skipped characters into the output string, 	 expanding it if there is not enough room. */
name|j
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|tl
operator|=
name|i
operator|-
name|start
expr_stmt|;
comment|/* number of characters just skipped */
if|if
condition|(
literal|1
operator|+
name|j
operator|+
name|tl
operator|>=
name|line_len
condition|)
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_len
operator|+=
operator|(
literal|50
operator|+
name|tl
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|line
operator|+
name|j
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|line
index|[
name|j
operator|+
name|tl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|real_start
operator|=
name|i
expr_stmt|;
name|command_word
operator|=
name|command_word
operator|||
operator|(
name|command_separator
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
name|expand_this_token
operator|=
operator|(
name|command_word
operator|||
name|expand_next
operator|)
expr_stmt|;
name|expand_next
operator|=
literal|0
expr_stmt|;
comment|/* Read the next token, and copy it into TOKEN. */
name|start
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|rd_token
argument_list|(
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|tl
operator|=
name|i
operator|-
name|start
expr_stmt|;
comment|/* token length */
comment|/* If tl == 0, but we're not at the end of the string, then we have a 	 single-character token, probably a delimiter */
if|if
condition|(
name|tl
operator|==
literal|0
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|tl
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* move past it */
block|}
name|strncpy
argument_list|(
name|token
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|token
index|[
name|tl
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If there is a backslash-escaped character quoted in TOKEN, 	 then we don't do alias expansion.  This should check for all 	 other quoting characters, too. */
if|if
condition|(
name|index
argument_list|(
name|token
argument_list|,
literal|'\\'
argument_list|)
condition|)
name|expand_this_token
operator|=
literal|0
expr_stmt|;
comment|/* If we should be expanding here, if we are expanding all words, or if 	 we are in a location in the string where an expansion is supposed to 	 take place, see if this word has a substitution.  If it does, then do 	 the expansion.  Note that we defer the alias value lookup until we 	 are sure we are expanding this token. */
if|if
condition|(
operator|(
name|token
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|expand_this_token
operator|||
name|alias_expand_all
operator|)
operator|&&
operator|(
name|alias
operator|=
name|find_alias
argument_list|(
name|token
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|v
init|=
name|alias
operator|->
name|value
decl_stmt|;
name|int
name|l
init|=
name|strlen
argument_list|(
name|v
argument_list|)
decl_stmt|;
comment|/* +3 because we possibly add one more character below. */
if|if
condition|(
operator|(
name|l
operator|+
literal|3
operator|)
operator|>
name|line_len
operator|-
name|strlen
argument_list|(
name|line
argument_list|)
condition|)
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_len
operator|+=
operator|(
literal|50
operator|+
name|l
operator|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|line
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|expand_this_token
operator|&&
name|l
operator|&&
name|whitespace
argument_list|(
name|v
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|||
name|alias_expand_all
condition|)
name|expand_next
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|ll
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|int
name|tl
init|=
name|i
operator|-
name|real_start
decl_stmt|;
comment|/* tl == strlen(token) */
if|if
condition|(
name|ll
operator|+
name|tl
operator|+
literal|2
operator|>
name|line_len
condition|)
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_len
operator|+=
literal|50
operator|+
name|ll
operator|+
name|tl
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|line
operator|+
name|ll
argument_list|,
name|string
operator|+
name|real_start
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|line
index|[
name|ll
operator|+
name|tl
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|command_word
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|alias_expand_word
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|ASSOC
modifier|*
name|r
init|=
name|find_alias
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|r
operator|->
name|value
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

end_unit

