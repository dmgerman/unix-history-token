begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* variables.c -- Functions for hacking shell variables. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1989 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|isc386
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
end_if

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwuid
argument_list|()
decl_stmt|,
modifier|*
name|getpwent
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The list of shell variables that the user has created, or that came from    the environment. */
end_comment

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|shell_variables
init|=
operator|(
name|HASH_TABLE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of shell functions that the user has created, or that came from    the environment. */
end_comment

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|shell_functions
init|=
operator|(
name|HASH_TABLE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current variable context.  This is really a count of how deep into    executing functions we are. */
end_comment

begin_decl_stmt
name|int
name|variable_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of shell assignments which are made only in the environment    for a single command. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|temporary_env
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some funky variables which are known about specially.  Here is where    "$*", "$1", and all the cruft is kept. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dollar_vars
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WORD_LIST
modifier|*
name|rest_of_args
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of $$. */
end_comment

begin_decl_stmt
name|int
name|dollar_dollar_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array which is passed to commands as their environment.  It is    manufactured from the overlap of the initial environment and the    shell variables that are marked for export. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|export_env
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have to remake EXPORT_ENV. */
end_comment

begin_decl_stmt
name|int
name|array_needs_making
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of variables that may not be unset in this shell. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|non_unsettable_vars
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFAULT_MAIL_PATH
value|"/usr/mail/"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_MAIL_PATH
value|"/usr/spool/mail/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some forward declarations. */
end_comment

begin_function_decl
name|SHELL_VAR
modifier|*
name|set_if_not
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* returns new or existing entry */
end_comment

begin_function_decl
specifier|static
name|void
name|sbrand
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* set bash random number generator */
end_comment

begin_comment
comment|/* Make VAR be auto-exported.  VAR is a pointer to a SHELL_VAR. */
end_comment

begin_define
define|#
directive|define
name|set_auto_export
parameter_list|(
name|var
parameter_list|)
define|\
value|{ var->attributes |= att_exported; array_needs_making = 1; }
end_define

begin_comment
comment|/* Initialize the shell variables from the current environment. */
end_comment

begin_macro
name|initialize_shell_variables
argument_list|(
argument|env
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|env
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|primary_prompt
decl_stmt|,
modifier|*
name|secondary_prompt
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|int
name|c
decl_stmt|,
name|char_index
decl_stmt|;
name|int
name|string_index
init|=
literal|0
decl_stmt|;
name|SHELL_VAR
modifier|*
name|temp_var
decl_stmt|;
if|if
condition|(
operator|!
name|shell_variables
condition|)
name|shell_variables
operator|=
name|make_hash_table
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shell_functions
condition|)
name|shell_functions
operator|=
name|make_hash_table
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up $PWD. */
block|{
name|char
modifier|*
name|get_working_directory
argument_list|()
decl_stmt|,
modifier|*
name|cd
decl_stmt|;
name|cd
operator|=
name|get_working_directory
argument_list|(
literal|"shell-init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
condition|)
block|{
name|bind_variable
argument_list|(
literal|"PWD"
argument_list|,
name|cd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|string
operator|=
name|env
index|[
name|string_index
operator|++
index|]
condition|)
block|{
name|char_index
operator|=
literal|0
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|'='
condition|)
name|name
index|[
name|char_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|name
index|[
name|char_index
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If exported function, define it now. */
comment|/* Posix.2 style exported function: name()=value */
if|if
condition|(
name|strncmp
argument_list|(
literal|"() {"
argument_list|,
name|string
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|name
index|[
name|char_index
operator|-
literal|1
index|]
operator|==
literal|')'
operator|&&
name|name
index|[
name|char_index
operator|-
literal|2
index|]
operator|==
literal|'('
operator|&&
name|string
index|[
literal|0
index|]
operator|==
literal|'{'
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|eval_string
decl_stmt|;
name|eval_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|eval_string
argument_list|,
literal|"%s %s"
argument_list|,
name|name
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|parse_and_execute
argument_list|(
name|eval_string
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|char_index
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
name|name
index|[
name|char_index
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|set_func_auto_export
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHELL_VAR
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
name|name
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|set_auto_export
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remember this pid. */
name|dollar_dollar_pid
operator|=
operator|(
name|int
operator|)
name|getpid
argument_list|()
expr_stmt|;
comment|/* Now make our own defaults in case the vars that we think are      important are missing. */
name|temp_var
operator|=
name|set_if_not
argument_list|(
literal|"PATH"
argument_list|,
name|DEFAULT_PATH_VALUE
argument_list|)
expr_stmt|;
name|set_auto_export
argument_list|(
name|temp_var
argument_list|)
expr_stmt|;
name|temp_var
operator|=
name|set_if_not
argument_list|(
literal|"TERM"
argument_list|,
literal|"dumb"
argument_list|)
expr_stmt|;
name|set_auto_export
argument_list|(
name|temp_var
argument_list|)
expr_stmt|;
name|set_if_not
argument_list|(
literal|"PS1"
argument_list|,
name|primary_prompt
argument_list|)
expr_stmt|;
name|set_if_not
argument_list|(
literal|"PS2"
argument_list|,
name|secondary_prompt
argument_list|)
expr_stmt|;
name|set_if_not
argument_list|(
literal|"IFS"
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
comment|/* Magic machine types.  Pretty convenient. */
name|temp_var
operator|=
name|set_if_not
argument_list|(
literal|"HOSTTYPE"
argument_list|,
name|HOSTTYPE
argument_list|)
expr_stmt|;
name|set_auto_export
argument_list|(
name|temp_var
argument_list|)
expr_stmt|;
comment|/* Default MAILPATH, and MAILCHECK. */
name|set_if_not
argument_list|(
literal|"MAILCHECK"
argument_list|,
literal|"60"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|get_string_value
argument_list|(
literal|"MAIL"
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|get_string_value
argument_list|(
literal|"MAILPATH"
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|current_user_name
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|DEFAULT_MAIL_PATH
argument_list|)
operator|+
name|strlen
argument_list|(
name|current_user_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tem
argument_list|,
name|DEFAULT_MAIL_PATH
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
name|current_user_name
argument_list|)
expr_stmt|;
name|bind_variable
argument_list|(
literal|"MAILPATH"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* Do some things with shell level. */
name|temp_var
operator|=
name|set_if_not
argument_list|(
literal|"SHLVL"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|set_auto_export
argument_list|(
name|temp_var
argument_list|)
expr_stmt|;
name|adjust_shell_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Make a variable $PPID, which holds the pid of the shell's parent.  */
block|{
name|char
modifier|*
name|ppid
decl_stmt|;
name|SHELL_VAR
modifier|*
name|v
decl_stmt|;
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
name|ppid
operator|=
name|itos
argument_list|(
operator|(
name|int
operator|)
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|find_variable
argument_list|(
literal|"PPID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|v
operator|->
name|attributes
operator|&=
operator|~
name|att_readonly
expr_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
literal|"PPID"
argument_list|,
name|ppid
argument_list|)
expr_stmt|;
name|v
operator|->
name|attributes
operator||=
operator|(
name|att_readonly
operator||
name|att_integer
operator|)
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"PPID"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppid
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|GETOPTS_BUILTIN
argument_list|)
comment|/* Initialize the `getopts' stuff. */
name|bind_variable
argument_list|(
literal|"OPTIND"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|bind_variable
argument_list|(
literal|"OPTERR"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GETOPTS_BUILTIN */
comment|/* Get the full pathname to THIS shell, and set the BASH variable      to it. */
block|{
specifier|extern
name|char
modifier|*
name|shell_name
decl_stmt|,
modifier|*
name|find_user_command
argument_list|()
decl_stmt|,
modifier|*
name|full_pathname
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|login_shell
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|find_user_command
argument_list|(
name|shell_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|login_shell
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|shell_name
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|struct
name|passwd
modifier|*
name|entry
init|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
comment|/* If HOME doesn't exist, set it. */
name|temp_var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|find_variable
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_var
condition|)
block|{
name|temp_var
operator|=
name|bind_variable
argument_list|(
literal|"HOME"
argument_list|,
name|entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|temp_var
operator|->
name|attributes
operator||=
name|att_exported
expr_stmt|;
block|}
name|name
operator|=
name|savestring
argument_list|(
name|entry
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|savestring
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|tname
condition|)
block|{
name|char
modifier|*
name|make_absolute
parameter_list|()
function_decl|;
name|name
operator|=
name|make_absolute
argument_list|(
name|shell_name
argument_list|,
name|get_string_value
argument_list|(
literal|"PWD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|full_pathname
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make the exported environment variable SHELL be whatever the name of        this shell is.  Note that the `tset' command looks at this variable        to determine what style of commands to output; if it ends in "csh",        then C-shell commands are output, else Bourne shell commands. */
name|temp_var
operator|=
name|set_if_not
argument_list|(
literal|"SHELL"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|set_auto_export
argument_list|(
name|temp_var
argument_list|)
expr_stmt|;
comment|/* Make a variable called BASH, which is the name of THIS shell. */
name|temp_var
operator|=
name|bind_variable
argument_list|(
literal|"BASH"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|temp_var
operator|->
name|attributes
operator||=
name|att_exported
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Make a variable called BASH_VERSION which contains the version info. */
block|{
name|char
name|tt
index|[
literal|12
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|dist_version
decl_stmt|;
specifier|extern
name|int
name|build_version
decl_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"%s.%d"
argument_list|,
name|dist_version
argument_list|,
name|build_version
argument_list|)
expr_stmt|;
name|bind_variable
argument_list|(
literal|"BASH_VERSION"
argument_list|,
name|tt
argument_list|)
expr_stmt|;
block|}
comment|/* Set history variables to defaults, and then do whatever we would      do if the variable had just been set. */
block|{
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
name|char
modifier|*
name|tem
init|=
name|tilde_expand
argument_list|(
literal|"~/.bash_history"
argument_list|)
decl_stmt|;
name|set_if_not
argument_list|(
literal|"HISTFILE"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|set_if_not
argument_list|(
literal|"HISTSIZE"
argument_list|,
literal|"500"
argument_list|)
expr_stmt|;
name|sv_histsize
argument_list|(
literal|"HISTSIZE"
argument_list|)
expr_stmt|;
block|}
comment|/* seed the random number generator */
name|sbrand
argument_list|(
name|dollar_dollar_pid
argument_list|)
expr_stmt|;
comment|/* If we have inherited `noclobber' from a previous shell, then set      noclobbering on. */
block|{
specifier|extern
name|int
name|noclobber
decl_stmt|;
name|noclobber
operator|=
name|find_variable
argument_list|(
literal|"noclobber"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
block|}
comment|/* Initialize the dynamic variables, and seed their values */
name|initialize_dynamic_variables
argument_list|()
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"PS1"
argument_list|)
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"PS2"
argument_list|)
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"IFS"
argument_list|)
expr_stmt|;
comment|/* Get the users real user id, and save that in an readonly variable.      To make the variable *really* readonly, we have added it to a special      list of vars. */
name|sv_uids
argument_list|()
expr_stmt|;
name|set_var_read_only
argument_list|(
literal|"UID"
argument_list|)
expr_stmt|;
name|set_var_read_only
argument_list|(
literal|"EUID"
argument_list|)
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"EUID"
argument_list|)
expr_stmt|;
name|non_unsettable
argument_list|(
literal|"UID"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|adjust_shell_level
argument_list|(
argument|change
argument_list|)
end_macro

begin_decl_stmt
name|int
name|change
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|shell_level
decl_stmt|;
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
name|char
modifier|*
name|new_level
decl_stmt|;
name|int
name|old_level
decl_stmt|;
name|old_level
operator|=
name|atoi
argument_list|(
name|get_string_value
argument_list|(
literal|"SHLVL"
argument_list|)
argument_list|)
expr_stmt|;
name|shell_level
operator|=
name|old_level
operator|+
name|change
expr_stmt|;
name|new_level
operator|=
name|itos
argument_list|(
name|shell_level
argument_list|)
expr_stmt|;
name|bind_variable
argument_list|(
literal|"SHLVL"
argument_list|,
name|new_level
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_level
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add NAME to the list of variables that cannot be unset    if it isn't already there. */
end_comment

begin_macro
name|non_unsettable
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|non_unsettable_vars
condition|)
block|{
name|non_unsettable_vars
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|non_unsettable_vars
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|non_unsettable_vars
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|non_unsettable_vars
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|non_unsettable_vars
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|non_unsettable_vars
argument_list|,
operator|(
literal|2
operator|+
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|non_unsettable_vars
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|non_unsettable_vars
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Set NAME to VALUE if NAME has no value. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|set_if_not
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|SHELL_VAR
modifier|*
name|v
init|=
name|find_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
name|v
operator|=
name|bind_variable
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Map FUNCTION over the variables in VARIABLES.  Return an array of the    variables that satisfy FUNCTION.  Satisfy means that FUNCTION returns    a non-zero value for.  A NULL value for FUNCTION means to use all    variables. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
modifier|*
name|map_over
parameter_list|(
name|function
parameter_list|,
name|var_hash_table
parameter_list|)
name|Function
modifier|*
name|function
decl_stmt|;
name|HASH_TABLE
modifier|*
name|var_hash_table
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BUCKET_CONTENTS
modifier|*
name|tlist
decl_stmt|;
name|SHELL_VAR
modifier|*
name|var
decl_stmt|,
modifier|*
modifier|*
name|list
init|=
operator|(
name|SHELL_VAR
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|list_index
init|=
literal|0
decl_stmt|,
name|list_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var_hash_table
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|tlist
operator|=
name|get_hash_bucket
argument_list|(
name|i
argument_list|,
name|var_hash_table
argument_list|)
expr_stmt|;
while|while
condition|(
name|tlist
condition|)
block|{
name|var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|tlist
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|function
operator|||
call|(
modifier|*
name|function
call|)
argument_list|(
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
name|list_index
operator|+
literal|1
operator|>=
name|list_size
condition|)
name|list
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|list
argument_list|,
operator|(
name|list_size
operator|+=
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SHELL_VAR
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|list
index|[
name|list_index
operator|++
index|]
operator|=
name|var
expr_stmt|;
name|list
index|[
name|list_index
index|]
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_function
name|int
name|qsort_var_comp
parameter_list|(
name|var1
parameter_list|,
name|var2
parameter_list|)
name|SHELL_VAR
modifier|*
modifier|*
name|var1
decl_stmt|,
decl|*
modifier|*
name|var2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|var1
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|var2
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|sort_variables
argument_list|(
argument|array
argument_list|)
end_macro

begin_decl_stmt
name|SHELL_VAR
modifier|*
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|qsort
argument_list|(
name|array
argument_list|,
name|array_len
argument_list|(
name|array
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|SHELL_VAR
operator|*
argument_list|)
argument_list|,
name|qsort_var_comp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Create a NULL terminated array of all the shell variables in TABLE. */
end_comment

begin_function
specifier|static
name|SHELL_VAR
modifier|*
modifier|*
name|all_vars
parameter_list|(
name|table
parameter_list|)
name|HASH_TABLE
modifier|*
name|table
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|map_over
argument_list|(
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|,
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|sort_variables
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a NULL terminated array of all the shell variables. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
modifier|*
name|all_shell_variables
parameter_list|()
block|{
return|return
operator|(
name|all_vars
argument_list|(
name|shell_variables
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a NULL terminated array of all the shell functions. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
modifier|*
name|all_shell_functions
parameter_list|()
block|{
return|return
operator|(
name|all_vars
argument_list|(
name|shell_functions
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print VARS to stdout in such a way that they can be read back in. */
end_comment

begin_expr_stmt
name|print_var_list
argument_list|(
name|list
argument_list|)
specifier|register
name|SHELL_VAR
operator|*
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list
operator|&&
operator|(
name|var
operator|=
name|list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
condition|)
name|print_assignment
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
end_if

begin_comment
comment|/* Print LIST (a linked list of shell variables) to stdout    by printing the names, without the values.  Used to support the    `set +' command. */
end_comment

begin_expr_stmt
name|print_vars_no_values
argument_list|(
name|list
argument_list|)
specifier|register
name|SHELL_VAR
operator|*
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list
operator|&&
operator|(
name|var
operator|=
name|list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print the value of a single SHELL_VAR.  No newline is    output, but the variable is printed in such a way that    it can be read back in. */
end_comment

begin_macro
name|print_assignment
argument_list|(
argument|var
argument_list|)
end_macro

begin_decl_stmt
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|function_p
argument_list|(
name|var
argument_list|)
operator|&&
name|var
operator|->
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_var_function
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var
operator|->
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_var_value
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Print the value cell of VAR, a shell variable.  Do not print    the name, nor leading/trailing newline. */
end_comment

begin_macro
name|print_var_value
argument_list|(
argument|var
argument_list|)
end_macro

begin_decl_stmt
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|var
operator|->
name|value
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the function cell of VAR, a shell variable.  Do not    print the name, nor leading/trailing newline. */
end_comment

begin_macro
name|print_var_function
argument_list|(
argument|var
argument_list|)
end_macro

begin_decl_stmt
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|named_function_string
parameter_list|()
function_decl|;
if|if
condition|(
name|function_p
argument_list|(
name|var
argument_list|)
operator|&&
name|var
operator|->
name|value
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|named_function_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|var
operator|->
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                 Dynamic Variable Extension                       */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* DYNAMIC VARIABLES        These are variables whose values are generated anew each time they are    referenced.  These are implemented using a pair of function pointers    in the struct variable: assign_func, which is called from bind_variable,    and dynamic_value, which is called from find_variable.        assign_func is called from bind_variable, if bind_variable discovers    that the variable being assigned to has such a function.  The function    is called as   	SHELL_VAR *temp = (*(entry->assign_func)) (entry, value)    and the (SHELL_VAR *)temp is returned as the value of bind_variable.  It    is usually ENTRY (self).        dynamic_value is called from find_variable to return a `new' value for    the specified dynamic varible.  If this function is NULL, the variable    is treated as a `normal' shell variable.  If it is not, however, then    this function is called like this:   	tempvar = (*(var->dynamic_value)) (var);        Sometimes `tempvar' will replace the value of `var'.  Other times, the    shell will simply use the string value.  Pretty object-oriented, huh?        Be warned, though: if you `unset' a special variable, it loses its    special meaning, even if you subsequently set it.        The special assignment code would probably have been better put in    subst.c: do_assignment, in the same style as    stupidly_hack_special_variables, but I wanted the changes as    localized as possible.  */
end_comment

begin_comment
comment|/* The value of $SECONDS.  This is the number of seconds since shell    invocation, or, the number of seconds since the last assignment + the    value of the last assignment. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|seconds_value_assigned
init|=
operator|(
name|long
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Originally defined in shell.c */
end_comment

begin_decl_stmt
specifier|extern
name|time_t
name|shell_start_time
decl_stmt|;
end_decl_stmt

begin_function
name|SHELL_VAR
modifier|*
name|assign_seconds
parameter_list|(
name|self
parameter_list|,
name|value
parameter_list|)
name|SHELL_VAR
modifier|*
name|self
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|seconds_value_assigned
operator|=
name|atol
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|shell_start_time
operator|=
name|NOW
expr_stmt|;
return|return
operator|(
name|self
operator|)
return|;
block|}
end_function

begin_function
name|SHELL_VAR
modifier|*
name|get_seconds
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
name|time_t
name|time_since_start
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|time_since_start
operator|=
name|NOW
operator|-
name|shell_start_time
expr_stmt|;
name|p
operator|=
name|itos
argument_list|(
operator|(
name|int
operator|)
name|seconds_value_assigned
operator|+
name|time_since_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|value
condition|)
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|attributes
operator||=
name|att_integer
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|var
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The random number seed.  You can change this by setting RANDOM. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|rseed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A linear congruential random number generator based on the ANSI    C standard.  A more complicated one is overkill.  */
end_comment

begin_comment
comment|/* Returns a pseudo-random number between 0 and 32767. */
end_comment

begin_function
specifier|static
name|int
name|brand
parameter_list|()
block|{
name|rseed
operator|=
name|rseed
operator|*
literal|1103515245
operator|+
literal|12345
expr_stmt|;
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|rseed
operator|/
literal|65536
argument_list|)
operator|%
literal|32768
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the random number generator seed to SEED. */
end_comment

begin_function
specifier|static
name|void
name|sbrand
parameter_list|(
name|seed
parameter_list|)
name|int
name|seed
decl_stmt|;
block|{
name|rseed
operator|=
name|seed
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SHELL_VAR
modifier|*
name|assign_random
parameter_list|(
name|self
parameter_list|,
name|value
parameter_list|)
name|SHELL_VAR
modifier|*
name|self
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|s
init|=
name|atoi
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|sbrand
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|self
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|SHELL_VAR
modifier|*
name|get_random
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
name|int
name|rv
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
name|rv
operator|=
name|brand
argument_list|()
expr_stmt|;
name|p
operator|=
name|itos
argument_list|(
operator|(
name|int
operator|)
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|value
condition|)
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|attributes
operator||=
name|att_integer
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|var
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function which returns the current line number. */
end_comment

begin_function
specifier|static
name|SHELL_VAR
modifier|*
name|get_lineno
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
specifier|extern
name|int
name|line_number
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
name|p
operator|=
name|itos
argument_list|(
name|line_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|value
condition|)
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|var
operator|)
return|;
block|}
end_function

begin_macro
name|initialize_dynamic_variables
argument_list|()
end_macro

begin_block
block|{
name|SHELL_VAR
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
literal|"SECONDS"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|->
name|dynamic_value
operator|=
name|get_seconds
expr_stmt|;
name|v
operator|->
name|assign_func
operator|=
name|assign_seconds
expr_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
literal|"RANDOM"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|->
name|dynamic_value
operator|=
name|get_random
expr_stmt|;
name|v
operator|->
name|assign_func
operator|=
name|assign_random
expr_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
literal|"LINENO"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|->
name|dynamic_value
operator|=
name|get_lineno
expr_stmt|;
name|v
operator|->
name|assign_func
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to get a pointer to the shell variable or function named NAME.    HASHED_VARS is a pointer to the hash table containing the list    of interest (either variables or functions). */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|var_lookup
parameter_list|(
name|name
parameter_list|,
name|hashed_vars
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|HASH_TABLE
modifier|*
name|hashed_vars
decl_stmt|;
block|{
name|BUCKET_CONTENTS
modifier|*
name|bucket
decl_stmt|;
name|bucket
operator|=
name|find_hash_item
argument_list|(
name|name
argument_list|,
name|hashed_vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
return|return
operator|(
operator|(
name|SHELL_VAR
operator|*
operator|)
name|bucket
operator|->
name|data
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up the variable entry whose name matches STRING.    Returns the entry or NULL. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|find_variable
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|int
name|variable_context
decl_stmt|;
specifier|extern
name|Function
modifier|*
name|this_shell_builtin
decl_stmt|;
name|SHELL_VAR
modifier|*
name|find_tempenv_variable
parameter_list|()
function_decl|;
name|SHELL_VAR
modifier|*
name|var
init|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If we are executing a function or builtin, first look in the      temporary environment for the variable.  This allows constructs      such as "foo=x eval 'echo $foo'" to get the `exported' value      of $foo. */
if|if
condition|(
name|variable_context
operator|||
name|this_shell_builtin
condition|)
name|var
operator|=
name|find_tempenv_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
name|var
operator|=
name|var_lookup
argument_list|(
name|name
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
return|return
operator|(
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|var
operator|->
name|dynamic_value
condition|)
return|return
operator|(
operator|(
operator|*
operator|(
name|var
operator|->
name|dynamic_value
operator|)
operator|)
operator|(
name|var
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|var
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up the function entry whose name matches STRING.    Returns the entry or NULL. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|find_function
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|var_lookup
argument_list|(
name|name
argument_list|,
name|shell_functions
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the string value of a variable.  Return NULL if the variable    doesn't exist, or only has a function as a value.  Don't cons a new    string. */
end_comment

begin_function
name|char
modifier|*
name|get_string_value
parameter_list|(
name|var_name
parameter_list|)
name|char
modifier|*
name|var_name
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|var
init|=
name|find_variable
argument_list|(
name|var_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
else|else
return|return
operator|(
name|var
operator|->
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a local variable referenced by NAME. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|make_local_variable
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|new_var
decl_stmt|,
modifier|*
name|old_var
decl_stmt|,
modifier|*
name|bind_variable
argument_list|()
decl_stmt|;
name|BUCKET_CONTENTS
modifier|*
name|elt
decl_stmt|;
comment|/* local foo; local foo;  is a no-op. */
name|old_var
operator|=
name|find_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_var
operator|&&
name|old_var
operator|->
name|context
operator|==
name|variable_context
condition|)
return|return
operator|(
name|old_var
operator|)
return|;
name|elt
operator|=
name|remove_hash_item
argument_list|(
name|name
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
name|old_var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|elt
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|elt
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
else|else
name|old_var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* If a variable does not already exist with this name, then      just make a new one. */
if|if
condition|(
operator|!
name|old_var
condition|)
block|{
name|new_var
operator|=
name|bind_variable
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SHELL_VAR
argument_list|)
argument_list|)
expr_stmt|;
name|new_var
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new_var
operator|->
name|value
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|new_var
operator|->
name|dynamic_value
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
name|new_var
operator|->
name|assign_func
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
name|new_var
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exported_p
argument_list|(
name|old_var
argument_list|)
condition|)
name|new_var
operator|->
name|attributes
operator||=
name|att_exported
expr_stmt|;
name|new_var
operator|->
name|prev_context
operator|=
name|old_var
expr_stmt|;
name|elt
operator|=
name|add_hash_item
argument_list|(
name|savestring
argument_list|(
name|name
argument_list|)
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
name|elt
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|new_var
expr_stmt|;
block|}
name|new_var
operator|->
name|context
operator|=
name|variable_context
expr_stmt|;
return|return
operator|(
name|new_var
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind a variable NAME to VALUE.  This conses up the name    and value strings. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|bind_variable
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|SHELL_VAR
modifier|*
name|entry
init|=
name|var_lookup
argument_list|(
name|name
argument_list|,
name|shell_variables
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
comment|/* Make a new entry for this variable.  Then do the binding. */
name|entry
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SHELL_VAR
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|entry
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|dynamic_value
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|assign_func
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Always assume variables are to be made at toplevel! 	 make_local_variable has the responsibilty of changing the 	 variable context. */
name|entry
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|prev_context
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
expr_stmt|;
block|{
name|BUCKET_CONTENTS
modifier|*
name|elt
decl_stmt|;
name|elt
operator|=
name|add_hash_item
argument_list|(
name|savestring
argument_list|(
name|name
argument_list|)
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
name|elt
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|entry
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|assign_func
condition|)
return|return
operator|(
operator|(
operator|*
operator|(
name|entry
operator|->
name|assign_func
operator|)
operator|)
operator|(
name|entry
operator|,
name|value
operator|)
operator|)
return|;
else|else
block|{
if|if
condition|(
name|readonly_p
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: read-only variable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
comment|/* If this variable has had its type set to integer (via `declare -i'), 	 then do expression evaluation on it and store the result.  The 	 functions in expr.c (evalexp and bind_int_variable) are responsible 	 for turning off the integer flag if they don't want further 	 evaluation done. */
if|if
condition|(
name|integer_p
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|long
name|val
decl_stmt|,
name|evalexp
argument_list|()
decl_stmt|;
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
name|val
operator|=
name|evalexp
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* We cannot free () entry->value before this; what if the string 	     we are working is `even=even+2'?  We need the original value 	     around while we are doing the evaluation to handle any possible 	     recursion. */
if|if
condition|(
name|entry
operator|->
name|value
condition|)
name|free
argument_list|(
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|entry
operator|->
name|value
operator|=
name|itos
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|value
condition|)
name|free
argument_list|(
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|entry
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mark_modified_vars
condition|)
name|entry
operator|->
name|attributes
operator||=
name|att_exported
expr_stmt|;
if|if
condition|(
name|exported_p
argument_list|(
name|entry
argument_list|)
condition|)
name|array_needs_making
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Dispose of the information attached to VAR. */
end_comment

begin_macro
name|dispose_variable
argument_list|(
argument|var
argument_list|)
end_macro

begin_decl_stmt
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|var
condition|)
return|return;
if|if
condition|(
name|function_p
argument_list|(
name|var
argument_list|)
condition|)
name|dispose_command
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|value
condition|)
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|exported_p
argument_list|(
name|var
argument_list|)
condition|)
name|array_needs_making
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Unset the variable referenced by NAME. */
end_comment

begin_macro
name|unbind_variable
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|var
init|=
name|find_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|var
operator|->
name|value
condition|)
block|{
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|makunbound
argument_list|(
name|name
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Make the variable associated with NAME go away.  HASH_LIST is the    hash table from which this variable should be deleted (either    shell_variables or shell_functions).    Returns non-zero if the variable couldn't be found. */
end_comment

begin_macro
name|makunbound
argument_list|(
argument|name
argument_list|,
argument|hash_list
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|hash_list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BUCKET_CONTENTS
modifier|*
name|elt
decl_stmt|;
name|SHELL_VAR
modifier|*
name|old_var
decl_stmt|,
modifier|*
name|new_var
decl_stmt|;
name|elt
operator|=
name|remove_hash_item
argument_list|(
name|name
argument_list|,
name|hash_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|elt
operator|->
name|data
expr_stmt|;
name|new_var
operator|=
name|old_var
operator|->
name|prev_context
expr_stmt|;
if|if
condition|(
name|old_var
operator|&&
name|exported_p
argument_list|(
name|old_var
argument_list|)
condition|)
name|array_needs_making
operator|++
expr_stmt|;
if|if
condition|(
name|new_var
condition|)
block|{
comment|/* Has to be a variable, functions don't have previous contexts. */
name|BUCKET_CONTENTS
modifier|*
name|new_elt
decl_stmt|;
name|new_elt
operator|=
name|add_hash_item
argument_list|(
name|savestring
argument_list|(
name|new_var
operator|->
name|name
argument_list|)
argument_list|,
name|hash_list
argument_list|)
expr_stmt|;
name|new_elt
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|new_var
expr_stmt|;
if|if
condition|(
name|exported_p
argument_list|(
name|new_var
argument_list|)
condition|)
name|set_var_auto_export
argument_list|(
name|new_var
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|elt
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|dispose_variable
argument_list|(
name|old_var
argument_list|)
expr_stmt|;
name|stupidly_hack_special_variables
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Remove the variable with NAME if it is a local variable in the    current context. */
end_comment

begin_macro
name|kill_local_variable
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|temp
init|=
name|find_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|(
name|temp
operator|->
name|context
operator|==
name|variable_context
operator|)
condition|)
block|{
name|makunbound
argument_list|(
name|name
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Get rid of all of the variables in the current context. */
end_comment

begin_function
name|int
name|variable_in_context
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
return|return
operator|(
name|var
operator|&&
name|var
operator|->
name|context
operator|==
name|variable_context
operator|)
return|;
block|}
end_function

begin_macro
name|kill_all_local_variables
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|;
specifier|register
name|SHELL_VAR
modifier|*
name|var
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|HASH_TABLE
modifier|*
name|varlist
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|varlist
operator|=
name|pass
condition|?
name|shell_functions
else|:
name|shell_variables
expr_stmt|;
name|list
operator|=
name|map_over
argument_list|(
name|variable_in_context
argument_list|,
name|varlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|var
operator|=
name|list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|makunbound
argument_list|(
name|var
operator|->
name|name
argument_list|,
name|varlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Delete the entire contents of the hash table. */
end_comment

begin_macro
name|delete_all_variables
argument_list|(
argument|hashed_vars
argument_list|)
end_macro

begin_decl_stmt
name|HASH_TABLE
modifier|*
name|hashed_vars
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BUCKET_CONTENTS
modifier|*
name|bucket
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hashed_vars
operator|->
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|bucket
operator|=
name|hashed_vars
operator|->
name|bucket_array
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
name|BUCKET_CONTENTS
modifier|*
name|temp
init|=
name|bucket
decl_stmt|;
name|SHELL_VAR
modifier|*
name|var
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
name|var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|var
condition|)
block|{
name|prev
operator|=
name|var
operator|->
name|prev_context
expr_stmt|;
name|dispose_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|var
operator|=
name|prev
expr_stmt|;
block|}
name|free
argument_list|(
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|hashed_vars
operator|->
name|bucket_array
index|[
name|i
index|]
operator|=
operator|(
name|BUCKET_CONTENTS
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_function
name|SHELL_VAR
modifier|*
name|new_shell_variable
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
name|var
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SHELL_VAR
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|var
argument_list|,
sizeof|sizeof
argument_list|(
name|SHELL_VAR
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|var
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a function binding to a variable.  You pass the name and    the command to bind to.  This conses the name and command. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|bind_function
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|COMMAND
modifier|*
name|value
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|entry
init|=
name|find_function
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|BUCKET_CONTENTS
modifier|*
name|elt
decl_stmt|;
name|elt
operator|=
name|add_hash_item
argument_list|(
name|savestring
argument_list|(
name|name
argument_list|)
argument_list|,
name|shell_functions
argument_list|)
expr_stmt|;
name|elt
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|new_shell_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|elt
operator|->
name|data
expr_stmt|;
name|entry
operator|->
name|dynamic_value
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|assign_func
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Functions are always made at the top level.  This allows a 	 function to define another function (like autoload). */
name|entry
operator|->
name|context
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|value
condition|)
name|dispose_command
argument_list|(
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
comment|/* I don't think this can happen anymore */
name|entry
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|copy_command
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|attributes
operator||=
name|att_function
expr_stmt|;
if|if
condition|(
name|mark_modified_vars
condition|)
name|entry
operator|->
name|attributes
operator||=
name|att_exported
expr_stmt|;
name|entry
operator|->
name|attributes
operator|&=
operator|~
name|att_invisible
expr_stmt|;
comment|/* Just to be sure */
name|array_needs_making
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy VAR to a new data structure and return that structure. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|copy_variable
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|copy
init|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|var
condition|)
block|{
name|copy
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SHELL_VAR
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|attributes
operator|=
name|var
operator|->
name|attributes
expr_stmt|;
name|copy
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_p
argument_list|(
name|var
argument_list|)
condition|)
name|copy
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|copy_command
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|value
condition|)
name|copy
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
name|copy
operator|->
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|copy
operator|->
name|dynamic_value
operator|=
name|var
operator|->
name|dynamic_value
expr_stmt|;
name|copy
operator|->
name|assign_func
operator|=
name|var
operator|->
name|assign_func
expr_stmt|;
name|copy
operator|->
name|context
operator|=
name|var
operator|->
name|context
expr_stmt|;
comment|/* Don't bother copying previous contexts along with this variable. */
name|copy
operator|->
name|prev_context
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make the variable associated with NAME be read-only.    If NAME does not exist yet, create it. */
end_comment

begin_macro
name|set_var_read_only
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|entry
init|=
name|find_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|entry
operator|=
name|bind_variable
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_invisible_vars
condition|)
name|entry
operator|->
name|attributes
operator||=
name|att_invisible
expr_stmt|;
block|}
name|entry
operator|->
name|attributes
operator||=
name|att_readonly
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the function associated with NAME be read-only.    If NAME does not exist, we just punt, like auto_export code below. */
end_comment

begin_macro
name|set_func_read_only
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|entry
init|=
name|find_function
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry
operator|->
name|attributes
operator||=
name|att_readonly
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the variable associated with NAME be auto-exported.    If NAME does not exist yet, create it. */
end_comment

begin_macro
name|set_var_auto_export
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|entry
init|=
name|find_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|entry
operator|=
name|bind_variable
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_invisible_vars
condition|)
name|entry
operator|->
name|attributes
operator||=
name|att_invisible
expr_stmt|;
block|}
name|set_auto_export
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the function associated with NAME be auto-exported. */
end_comment

begin_macro
name|set_func_auto_export
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|entry
init|=
name|find_function
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|entry
operator|->
name|attributes
operator||=
name|att_exported
expr_stmt|;
name|array_needs_making
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Returns non-zero if STRING is an assignment statement.  The returned value    is the index of the `=' sign. */
end_comment

begin_macro
name|assignment
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|string
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isletter
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|c
operator|=
name|string
index|[
name|index
index|]
condition|)
block|{
comment|/* The following is safe.  Note that '=' at the start of a word 	 is not an assignment statement. */
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
return|return
operator|(
name|index
operator|)
return|;
if|if
condition|(
operator|!
name|isletter
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|visible_var
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|SHELL_VAR
modifier|*
modifier|*
name|all_visible_variables
parameter_list|()
block|{
name|SHELL_VAR
modifier|*
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|map_over
argument_list|(
name|visible_var
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|sort_variables
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_function
name|SHELL_VAR
modifier|*
modifier|*
name|all_visible_functions
parameter_list|()
block|{
name|SHELL_VAR
modifier|*
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|map_over
argument_list|(
name|visible_var
argument_list|,
name|shell_functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|sort_variables
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the variable VAR is visible and exported. */
end_comment

begin_function
name|int
name|visible_and_exported
parameter_list|(
name|var
parameter_list|)
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
operator|&&
name|exported_p
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make an array of assignment statements from the hash table    HASHED_VARS which contains SHELL_VARs.  Only visible, exported    variables are eligible. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_var_array
parameter_list|(
name|hashed_vars
parameter_list|)
name|HASH_TABLE
modifier|*
name|hashed_vars
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|list_index
decl_stmt|;
specifier|register
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|SHELL_VAR
modifier|*
modifier|*
name|vars
decl_stmt|;
name|vars
operator|=
name|map_over
argument_list|(
name|visible_and_exported
argument_list|,
name|hashed_vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vars
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
return|;
name|list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|array_len
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|vars
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|list_index
operator|=
literal|0
init|;
name|var
operator|=
name|vars
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|named_function_string
argument_list|()
decl_stmt|;
if|if
condition|(
name|function_p
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|value
operator|=
name|named_function_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|COMMAND
operator|*
operator|)
name|function_cell
argument_list|(
name|var
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|value_cell
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
if|#
directive|if
literal|0
block|list[list_index] = 	    (char *)xmalloc (2 + strlen (var->name) + strlen (value));  	  sprintf (list[list_index], "%s=%s", var->name, value);
else|#
directive|else
comment|/* Let's see if this makes any kind of performance difference. */
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|var
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|value_len
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|list
index|[
name|list_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|name_len
operator|+
name|value_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
index|[
name|name_len
index|]
operator|=
literal|'='
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|p
index|[
name|name_len
operator|+
literal|1
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|list_index
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|list
index|[
name|list_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add STRING to the array of foo=bar strings that we already    have to add to the environment.  */
end_comment

begin_macro
name|assign_in_env
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|size
decl_stmt|;
name|int
name|offset
init|=
name|assignment
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|savestring
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|name
index|[
name|offset
index|]
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|tilde_expand
argument_list|()
decl_stmt|,
modifier|*
name|string_list
argument_list|()
decl_stmt|;
name|WORD_LIST
modifier|*
name|list
decl_stmt|,
modifier|*
name|expand_string_unsplit
argument_list|()
decl_stmt|;
name|name
index|[
name|offset
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|name
operator|+
name|offset
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
name|tilde_expand
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|list
operator|=
name|expand_string_unsplit
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|string_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|value
condition|)
name|value
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s=%s"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temporary_env
condition|)
block|{
name|temporary_env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|temporary_env
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|size
operator|=
name|array_len
argument_list|(
name|temporary_env
argument_list|)
expr_stmt|;
name|temporary_env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|temporary_env
argument_list|,
operator|(
name|size
operator|+
literal|2
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|temporary_env
index|[
name|size
index|]
operator|=
operator|(
name|temp
operator|)
expr_stmt|;
name|temporary_env
index|[
name|size
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|array_needs_making
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|echo_command_at_execute
condition|)
block|{
comment|/* The K*rn shell prints the `+ ' in front of assignment statements, 	 so we do too. */
specifier|extern
name|char
modifier|*
name|indirection_level_string
parameter_list|()
function_decl|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s\n"
argument_list|,
name|indirection_level_string
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Find a variable in the temporary environment that is named NAME.    Return a consed variable, or NULL if not found. */
end_comment

begin_function
name|SHELL_VAR
modifier|*
name|find_tempenv_variable
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temporary_env
condition|)
return|return
operator|(
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|temporary_env
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|temporary_env
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
name|temporary_env
index|[
name|i
index|]
index|[
name|l
index|]
operator|==
literal|'='
condition|)
block|{
name|SHELL_VAR
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|new_shell_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary_env
index|[
name|i
index|]
index|[
name|l
operator|+
literal|1
index|]
condition|)
name|temp
operator|->
name|value
operator|=
name|savestring
argument_list|(
operator|&
name|temporary_env
index|[
name|i
index|]
index|[
name|l
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|temp
operator|->
name|value
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|temp
operator|->
name|attributes
operator|=
name|att_exported
expr_stmt|;
name|temp
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|prev_context
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
expr_stmt|;
name|temp
operator|->
name|dynamic_value
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
name|temp
operator|->
name|assign_func
operator|=
operator|(
name|DYNAMIC_FUNC
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free the storage used in the variable array for temporary    environment variables. */
end_comment

begin_macro
name|dispose_used_env_vars
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|temporary_env
condition|)
return|return;
name|free_array
argument_list|(
name|temporary_env
argument_list|)
expr_stmt|;
name|temporary_env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|array_needs_making
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Stupid comparison routine for qsort () ing strings. */
end_comment

begin_function
name|int
name|qsort_string_compare
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Sort ARRAY, a null terminated array of pointers to strings. */
end_comment

begin_macro
name|sort_char_array
argument_list|(
argument|array
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|qsort
argument_list|(
name|array
argument_list|,
name|array_len
argument_list|(
name|array
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|qsort_string_compare
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|ISFUNC
parameter_list|(
name|s
parameter_list|,
name|o
parameter_list|)
value|((s[o + 1] == '(')&& (s[o + 2] == ')'))
end_define

begin_comment
comment|/* Add ASSIGN to ARRAY, or supercede a previous assignment in the    array with the same left-hand side.  Return the new array. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|add_or_supercede
parameter_list|(
name|assign
parameter_list|,
name|array
parameter_list|)
name|char
modifier|*
name|assign
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|equal_offset
init|=
name|assignment
argument_list|(
name|assign
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|equal_offset
condition|)
return|return
operator|(
name|array
operator|)
return|;
comment|/* If this is a function, then only supercede the function definition.      We do this by including the `=(' in the comparison.  */
if|if
condition|(
name|assign
index|[
name|equal_offset
operator|+
literal|1
index|]
operator|==
literal|'('
condition|)
name|equal_offset
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|assign
argument_list|,
name|array
index|[
name|i
index|]
argument_list|,
name|equal_offset
operator|+
literal|1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|assign
argument_list|)
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
block|}
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|array
argument_list|,
operator|(
operator|(
literal|2
operator|+
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|array
index|[
name|i
operator|++
index|]
operator|=
name|savestring
argument_list|(
name|assign
argument_list|)
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make the environment array for the command about to be executed.  If the    array needs making.  Otherwise, do nothing.  If a shell action could    change the array that commands receive for their environment, then the    code should `array_needs_making++'. */
end_comment

begin_macro
name|maybe_make_export_env
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|temp_array
decl_stmt|;
if|if
condition|(
name|array_needs_making
condition|)
block|{
if|if
condition|(
name|export_env
condition|)
name|free_array
argument_list|(
name|export_env
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHADOWED_ENV
name|export_env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|array_len
argument_list|(
name|shell_environment
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|shell_environment
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|export_env
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|shell_environment
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|export_env
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* !SHADOWED_ENV */
name|export_env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|export_env
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* SHADOWED_ENV */
name|temp_array
operator|=
name|make_var_array
argument_list|(
name|shell_variables
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|temp_array
operator|&&
name|temp_array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|export_env
operator|=
name|add_or_supercede
argument_list|(
name|temp_array
index|[
name|i
index|]
argument_list|,
name|export_env
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|temp_array
argument_list|)
expr_stmt|;
name|temp_array
operator|=
name|make_var_array
argument_list|(
name|shell_functions
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|temp_array
operator|&&
name|temp_array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|export_env
operator|=
name|add_or_supercede
argument_list|(
name|temp_array
index|[
name|i
index|]
argument_list|,
name|export_env
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|temp_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary_env
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|temporary_env
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|export_env
operator|=
name|add_or_supercede
argument_list|(
name|temporary_env
index|[
name|i
index|]
argument_list|,
name|export_env
argument_list|)
expr_stmt|;
comment|/* Sort the array alphabetically. */
name|sort_char_array
argument_list|(
name|export_env
argument_list|)
expr_stmt|;
block|}
name|array_needs_making
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* We always put _ in the environment as the name of this command. */
end_comment

begin_macro
name|put_command_name_into_env
argument_list|(
argument|command_name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|command_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|dummy
decl_stmt|;
name|dummy
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
operator|+
name|strlen
argument_list|(
name|command_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These three statements replace a call to sprintf */
name|dummy
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|dummy
index|[
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|dummy
index|[
literal|2
index|]
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|export_env
operator|=
name|add_or_supercede
argument_list|(
name|dummy
argument_list|,
name|export_env
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* We supply our own version of getenv () because we want library    routines to get the changed values of exported variables. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|last_tempenv_value
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The NeXT C library has getenv () defined and used in the same file.    This screws our scheme.  However, Bash will run on the NeXT using    the C library getenv (), since right now the only environment variable    that we care about is HOME, and that is already defined.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_CONST_HACK
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_CONST_HACK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__STDC__ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NeXT
argument_list|)
end_if

begin_function
name|char
modifier|*
name|getenv
parameter_list|(
name|name
parameter_list|)
name|char
name|_CONST_HACK
modifier|*
name|name
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|var
init|=
name|find_tempenv_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
condition|)
block|{
if|if
condition|(
name|last_tempenv_value
condition|)
name|free
argument_list|(
name|last_tempenv_value
argument_list|)
expr_stmt|;
name|last_tempenv_value
operator|=
name|savestring
argument_list|(
name|value_cell
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|dispose_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_tempenv_value
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|shell_variables
condition|)
block|{
name|var
operator|=
name|find_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|&&
name|exported_p
argument_list|(
name|var
argument_list|)
condition|)
return|return
operator|(
name|value_cell
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
comment|/* In some cases, s5r3 invokes getenv() before main(); BSD systems          using gprof also exhibit this behavior.  This means that          shell_variables will be 0 when this is invoked.  We look up the 	 variable in the real environment in that case. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|environ
index|[
name|i
index|]
index|[
name|len
index|]
operator|==
literal|'='
operator|)
condition|)
return|return
operator|(
name|environ
index|[
name|i
index|]
operator|+
name|len
operator|+
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NeXT */
end_comment

end_unit

