begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Portable vfprintf and vprintf by Robert A. Larson<blarson@skat.usc.edu> */
end_comment

begin_comment
comment|/* Copyright 1989 Robert A. Larson.  * Distribution in any form is allowed as long as the author  * retains credit, changes are noted by their author and the  * copyright message remains intact.  This program comes as-is  * with no warentee of fitness for any purpouse.  *  * Thanks to Doug Gwen, Chris Torek, and others who helped clarify  * the ansi printf specs.  *  * Please send any bug fixes and improvments to blarson@skat.usc.edu .  * The use of goto is NOT a bug.  */
end_comment

begin_comment
comment|/* Feb	9, 1989		blarson		First usenet release */
end_comment

begin_comment
comment|/* This code implements the vfprintf function, without relying on  * the existance of _doprint or other system specific code.  *  * Define NOVOID if void * is not a supported type.  *  * Two compile options are available for efficency:  *	INTSPRINTF	should be defined if sprintf is int and returns  *			the number of chacters formated.  *	LONGINT		should be defined if sizeof(long) == sizeof(int)  *  *	They only make the code smaller and faster, they need not be  *	defined.  *  * UNSIGNEDSPECIAL should be defined if unsigned is treated differently  * than int in argument passing.  If this is definded, and LONGINT is not,  * the compiler must support the type unsingned long.  *  * Most quirks and bugs of the available fprintf fuction are duplicated,  * however * in the width and precision fields will work correctly  * even if fprintf does not support this.  The %n format and the return  * count will only work if fprintf returns the number of characters  * formatted.  *  * Bad format strings, or those with very long width and precision  * fields (including expanded * fields) will cause undesired results.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSK
end_ifdef

begin_comment
comment|/* os9/68k can take advantage of both */
end_comment

begin_define
define|#
directive|define
name|INTSPRINTF
end_define

begin_define
define|#
directive|define
name|LONGINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This must be a typedef not a #define! */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOVOID
end_ifdef

begin_typedef
typedef|typedef
name|char
modifier|*
name|pointer
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|void
modifier|*
name|pointer
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INTSPRINTF
end_ifdef

begin_define
define|#
directive|define
name|Sprintf
parameter_list|(
name|string
parameter_list|,
name|format
parameter_list|,
name|arg
parameter_list|)
value|(sprintf((string),(format),(arg)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Sprintf
parameter_list|(
name|string
parameter_list|,
name|format
parameter_list|,
name|arg
parameter_list|)
value|(\ 	sprintf((string),(format),(arg)),\ 	strlen(string)\ )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|int
modifier|*
name|intp
typedef|;
end_typedef

begin_function
name|int
name|vfprintf
parameter_list|(
name|dest
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|dest
decl_stmt|;
specifier|register
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
name|tempfmt
index|[
literal|64
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|LONGINT
name|int
name|longflag
decl_stmt|;
endif|#
directive|endif
name|tempfmt
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|format
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|tp
operator|=
operator|&
name|tempfmt
index|[
literal|1
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|LONGINT
name|longflag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|continue_format
label|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|format
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'o'
case|:
case|case
literal|'X'
case|:
ifdef|#
directive|ifdef
name|UNSIGNEDSPECIAL
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|LONGINT
if|if
condition|(
name|longflag
condition|)
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
case|case
literal|'c'
case|:
case|case
literal|'i'
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|LONGINT
if|if
condition|(
name|longflag
condition|)
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|+=
name|fprintf
argument_list|(
name|dest
argument_list|,
name|tempfmt
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|pointer
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
case|case
literal|' '
case|:
case|case
literal|'#'
case|:
case|case
literal|'h'
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
goto|goto
name|continue_format
goto|;
case|case
literal|'l'
case|:
ifndef|#
directive|ifndef
name|LONGINT
name|longflag
operator|=
literal|1
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
goto|goto
name|continue_format
goto|;
case|case
literal|'*'
case|:
name|tp
operator|+=
name|Sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|continue_format
goto|;
case|case
literal|'n'
case|:
operator|*
name|va_arg
argument_list|(
name|args
argument_list|,
name|intp
argument_list|)
operator|=
name|count
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_macro
name|vprintf
argument_list|(
argument|format
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|va_list
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

end_unit

