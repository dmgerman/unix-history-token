begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      COMM.C  *      UTREE common tree and file commands.  *      3.01-um klin, Tue Jun  4 14:16:30 1991  *              klin, Mon Oct  7 15:16:22 1991, File size patterns added  *              klin, Sat Oct 26 15:07:06 1991, Sorting and zooming filelists changed  *      3.02-um klin, Fri Nov  1 13:42:28 1991, Minor changes  *              klin, Sun Nov 24 19:30:43 1991, Cd to current directory before  *                                              executing some commands  *      3.03-um klin, Tue Feb 11 19:40:06 1992, Status screen into stat.c  *                                              getline() changed  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03-um (klin) Feb 11 1992 comm.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- Local variables and definitions ------------------------------- */
end_comment

begin_define
define|#
directive|define
name|CCOLUMN
value|-8
end_define

begin_comment
comment|/* Column for clock                     */
end_comment

begin_comment
comment|/* Tokens for file pattern and time pattern matching                    */
end_comment

begin_define
define|#
directive|define
name|TK_ERR
value|'F'
end_define

begin_comment
comment|/* Error                                */
end_comment

begin_define
define|#
directive|define
name|TK_END
value|'E'
end_define

begin_comment
comment|/* End of pattern                       */
end_comment

begin_define
define|#
directive|define
name|TK_WORD
value|'W'
end_define

begin_comment
comment|/* Word or file pattern matching        */
end_comment

begin_define
define|#
directive|define
name|TK_OR
value|'|'
end_define

begin_comment
comment|/* ORing patterns                       */
end_comment

begin_define
define|#
directive|define
name|TK_AND
value|'&'
end_define

begin_comment
comment|/* ANDing pattern                       */
end_comment

begin_define
define|#
directive|define
name|TK_SEQ
value|'='
end_define

begin_comment
comment|/* Filesize equate                      */
end_comment

begin_define
define|#
directive|define
name|TK_SNE
value|'!'
end_define

begin_comment
comment|/* Filesize unequate                    */
end_comment

begin_define
define|#
directive|define
name|TK_SGT
value|'>'
end_define

begin_comment
comment|/* Filesize bigger                      */
end_comment

begin_define
define|#
directive|define
name|TK_SLT
value|'<'
end_define

begin_comment
comment|/* Filesize smaller                     */
end_comment

begin_define
define|#
directive|define
name|TK_MNE
value|')'
end_define

begin_comment
comment|/* File     modified within (newer)     */
end_comment

begin_define
define|#
directive|define
name|TK_MOL
value|'('
end_define

begin_comment
comment|/* File not modified within (older)     */
end_comment

begin_comment
comment|/* States from token()                                                  */
end_comment

begin_define
define|#
directive|define
name|ST_NORM
value|0
end_define

begin_comment
comment|/* Normal state                         */
end_comment

begin_define
define|#
directive|define
name|ST_WORD
value|1
end_define

begin_comment
comment|/* In word                              */
end_comment

begin_define
define|#
directive|define
name|ST_QUOT
value|2
end_define

begin_comment
comment|/* In quotes                            */
end_comment

begin_define
define|#
directive|define
name|ST_BRCK
value|3
end_define

begin_comment
comment|/* In brackets                          */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|patpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position in pattern          */
end_comment

begin_decl_stmt
name|LOCAL
name|char
name|patbuf
index|[
name|PATLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pattern buffer for internal use      */
end_comment

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_function_decl
name|EXTRN
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Functions and procedures -------------------------------------- */
end_comment

begin_comment
comment|/*  *      COMMON COMMANDS  */
end_comment

begin_comment
comment|/* Display current date and time in echo line */
end_comment

begin_function
name|GLOBL
name|int
name|printdate
parameter_list|()
block|{
name|time_t
name|tloc
decl_stmt|;
name|tloc
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"DATE: Current date and time %s"
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|tloc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* printdate() */
end_comment

begin_comment
comment|/* Display current directory in echo line */
end_comment

begin_function
name|GLOBL
name|int
name|printcwd
parameter_list|()
block|{
name|puthelp
argument_list|(
literal|"WHERE: Pathname of current directory %s"
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%s"
argument_list|,
name|CPNAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* printcwd() */
end_comment

begin_comment
comment|/*  *      CLOCK ROUTINES  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTCLOCK
end_ifdef

begin_comment
comment|/* Turn on clock in echo line, update every second */
end_comment

begin_function
name|GLOBL
name|int
name|clockon
parameter_list|()
block|{
name|time_t
name|tloc
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
comment|/* Get and display current time in echo line */
name|tloc
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|tloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursorcap
operator|&
name|CF_SAVE
condition|)
empty_stmt|;
name|cursorset
argument_list|(
name|CF_SAVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|CCOLUMN
argument_list|,
name|echoline
argument_list|,
literal|0
argument_list|,
literal|"%02d:%02d:%02d"
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursorcap
operator|&
name|CF_RESTORE
condition|)
empty_stmt|;
name|cursorset
argument_list|(
name|CF_RESTORE
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
comment|/* Set alarm for the next second and catch signal SIGALRM */
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
operator|(
name|SIGNL
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|clockon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clockon() */
end_comment

begin_comment
comment|/* Turn off clock in echo line */
end_comment

begin_function
name|GLOBL
name|VOID
name|clockoff
parameter_list|()
block|{
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Suppress alarm */
block|}
end_function

begin_comment
comment|/* clockoff() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTCLOCK */
end_comment

begin_comment
comment|/*  *      FILE AND TIME STAMP PATTERN MATCHING ROUTINES  */
end_comment

begin_comment
comment|/* Get and return next token. If a word is found copy it to wp */
end_comment

begin_function
name|LOCAL
name|int
name|token
parameter_list|(
name|wp
parameter_list|)
specifier|register
name|char
modifier|*
name|wp
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|w
decl_stmt|;
name|s
operator|=
name|ST_NORM
expr_stmt|;
name|w
operator|=
name|wp
expr_stmt|;
comment|/* Get token loop */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|patbuf
index|[
name|patpos
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|ST_NORM
case|:
comment|/* Normal state */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\0'
case|:
name|c
operator|=
name|TK_END
expr_stmt|;
comment|/*Fall thru*/
case|case
name|TK_END
case|:
case|case
name|TK_AND
case|:
case|case
name|TK_OR
case|:
case|case
name|TK_SEQ
case|:
case|case
name|TK_SNE
case|:
case|case
name|TK_SGT
case|:
case|case
name|TK_SLT
case|:
case|case
name|TK_MNE
case|:
case|case
name|TK_MOL
case|:
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|s
operator|=
name|ST_QUOT
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
name|s
operator|=
name|ST_BRCK
expr_stmt|;
operator|*
name|w
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|patbuf
index|[
name|patpos
operator|++
index|]
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
comment|/*Fall thru*/
default|default:
name|s
operator|=
name|ST_WORD
expr_stmt|;
operator|*
name|w
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
case|case
name|ST_BRCK
case|:
comment|/* In brackets */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\0'
case|:
return|return
operator|(
name|TK_ERR
operator|)
return|;
case|case
literal|']'
case|:
name|s
operator|=
name|ST_WORD
expr_stmt|;
comment|/*Fall thru*/
default|default:
operator|*
name|w
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
case|case
name|ST_QUOT
case|:
comment|/* In quotes */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
operator|*
name|w
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|TK_WORD
operator|)
return|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|patbuf
index|[
name|patpos
operator|++
index|]
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
comment|/*Fall thru*/
default|default:
operator|*
name|w
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
case|case
name|ST_WORD
case|:
comment|/* In word */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TK_AND
case|:
case|case
name|TK_OR
case|:
case|case
name|TK_SEQ
case|:
case|case
name|TK_SNE
case|:
case|case
name|TK_SGT
case|:
case|case
name|TK_SLT
case|:
case|case
name|TK_MNE
case|:
case|case
name|TK_MOL
case|:
case|case
literal|'\n'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\0'
case|:
operator|--
name|patpos
expr_stmt|;
operator|*
name|w
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|TK_WORD
operator|)
return|;
case|case
literal|'['
case|:
name|s
operator|=
name|ST_BRCK
expr_stmt|;
operator|*
name|w
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|patbuf
index|[
name|patpos
operator|++
index|]
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
comment|/*Fall thru*/
default|default:
operator|*
name|w
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* token() */
end_comment

begin_comment
comment|/* Token parsing and file/size/time pattern matching */
end_comment

begin_function
name|LOCAL
name|int
name|imatch
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|static
name|int
name|lt
decl_stmt|;
name|char
name|w
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|time_t
name|ct
decl_stmt|;
specifier|register
name|off_t
name|fs
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|,
name|i
decl_stmt|;
comment|/* Inner matching loop */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|t
operator|=
name|token
argument_list|(
name|w
argument_list|)
condition|)
block|{
comment|/* Get next token */
default|default:
comment|/* Unknown */
name|t
operator|=
name|TK_ERR
expr_stmt|;
comment|/*Fall thru*/
case|case
name|TK_ERR
case|:
comment|/* Return as it is */
return|return
operator|(
name|t
operator|)
return|;
case|case
name|TK_END
case|:
comment|/* End of pattern */
case|case
name|TK_OR
case|:
comment|/* ORing patterns */
case|case
name|TK_AND
case|:
comment|/* ANDing patterns */
if|if
condition|(
name|lt
operator|!=
name|TK_WORD
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
return|return
operator|(
name|lt
operator|=
name|t
operator|)
return|;
case|case
name|TK_WORD
case|:
comment|/* File pattern matching */
name|lt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|dp
condition|)
return|return
operator|(
name|match
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|w
argument_list|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TK_SEQ
case|:
comment|/* Filesize equate   */
case|case
name|TK_SNE
case|:
comment|/* Filesize unequate */
case|case
name|TK_SGT
case|:
comment|/* Filesize bigger   */
case|case
name|TK_SLT
case|:
comment|/* Filesize smaller  */
if|if
condition|(
operator|(
name|lt
operator|=
name|token
argument_list|(
name|w
argument_list|)
operator|)
operator|!=
name|TK_WORD
operator|||
operator|!
name|isdigit
argument_list|(
name|w
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
name|fs
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|w
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
name|w
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|fs
operator|=
name|fs
operator|*
operator|(
name|off_t
operator|)
literal|10
operator|+
call|(
name|off_t
call|)
argument_list|(
name|w
index|[
name|i
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|w
index|[
name|i
index|]
condition|)
block|{
default|default:
comment|/* Error */
return|return
operator|(
name|TK_ERR
operator|)
return|;
case|case
literal|'m'
case|:
comment|/* Megabytes */
name|fs
operator|*=
operator|(
name|off_t
operator|)
literal|1024
expr_stmt|;
comment|/*Fall thru*/
case|case
literal|'k'
case|:
comment|/* Kilobytes */
name|fs
operator|*=
operator|(
name|off_t
operator|)
literal|1024
expr_stmt|;
comment|/*Fall thru*/
case|case
literal|'b'
case|:
comment|/* Bytes (default) */
case|case
literal|'\0'
case|:
break|break;
block|}
if|if
condition|(
name|dp
condition|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TK_SEQ
case|:
return|return
operator|(
name|FSIZE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|==
name|fs
operator|)
return|;
case|case
name|TK_SNE
case|:
return|return
operator|(
name|FSIZE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|!=
name|fs
operator|)
return|;
case|case
name|TK_SGT
case|:
return|return
operator|(
name|FSIZE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|>
name|fs
operator|)
return|;
case|case
name|TK_SLT
case|:
return|return
operator|(
name|FSIZE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|<
name|fs
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TK_MNE
case|:
comment|/* Modified within     days/hours/minutes */
case|case
name|TK_MOL
case|:
comment|/* Not modified within days/hours/minutes */
if|if
condition|(
operator|(
name|lt
operator|=
name|token
argument_list|(
name|w
argument_list|)
operator|)
operator|!=
name|TK_WORD
operator|||
operator|!
name|isdigit
argument_list|(
name|w
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
name|ct
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|w
index|[
name|i
index|]
operator|&&
name|isdigit
argument_list|(
name|w
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|ct
operator|=
name|ct
operator|*
operator|(
name|time_t
operator|)
literal|10
operator|+
call|(
name|time_t
call|)
argument_list|(
name|w
index|[
name|i
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|w
index|[
name|i
index|]
condition|)
block|{
default|default:
comment|/* Error */
return|return
operator|(
name|TK_ERR
operator|)
return|;
case|case
literal|'w'
case|:
comment|/* Weeks */
name|ct
operator|*=
operator|(
name|time_t
operator|)
literal|7
expr_stmt|;
comment|/*Fall thru*/
case|case
literal|'d'
case|:
comment|/* Days */
name|ct
operator|*=
operator|(
name|time_t
operator|)
literal|24
expr_stmt|;
comment|/*Fall thru*/
case|case
literal|'h'
case|:
comment|/* Hours (default) */
case|case
literal|'\0'
case|:
name|ct
operator|*=
operator|(
name|time_t
operator|)
literal|60
expr_stmt|;
comment|/*Fall thru*/
case|case
literal|'m'
case|:
comment|/* Minutes */
name|ct
operator|*=
operator|(
name|time_t
operator|)
literal|60
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ct
operator|==
operator|(
name|time_t
operator|)
literal|0
condition|)
return|return
operator|(
name|TK_ERR
operator|)
return|;
elseif|else
if|if
condition|(
name|dp
condition|)
block|{
name|ct
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
operator|-
name|ct
expr_stmt|;
return|return
operator|(
name|t
operator|==
name|TK_MNE
condition|?
name|FMTIM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|>
name|ct
else|:
name|FMTIM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|<=
name|ct
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/*NOT REACHED*/
block|}
end_function

begin_comment
comment|/* imatch() */
end_comment

begin_comment
comment|/* Do/combine file/size/time pattern matching */
end_comment

begin_function
name|GLOBL
name|int
name|umatch
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|,
name|p
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|patbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|patpos
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Outer matching loop */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|imatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
condition|)
block|{
case|case
name|TK_END
case|:
comment|/* End */
return|return
operator|(
name|rv
operator|<=
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
return|;
case|case
literal|1
case|:
comment|/* Match */
name|rv
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* No match */
name|rv
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TK_OR
case|:
comment|/* ORing */
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
else|else
name|rv
operator|=
operator|(
name|rv
operator|||
name|imatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|&&
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
break|break;
case|case
name|TK_AND
case|:
comment|/* ANDing */
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
else|else
name|rv
operator|=
operator|(
name|rv
operator|&&
name|imatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|&&
name|rv
operator|==
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
break|break;
default|default:
case|case
name|TK_ERR
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/*NOT REACHED*/
block|}
end_function

begin_comment
comment|/* umatch() */
end_comment

begin_comment
comment|/* Get file/size/time pattern and test it */
end_comment

begin_function
name|GLOBL
name|int
name|getpattern
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|m
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Get/test pattern loop */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|putecho
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|c
operator|=
name|getline
argument_list|(
name|p
argument_list|,
name|PATLEN
argument_list|,
name|c
argument_list|,
literal|'p'
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|RV_OK
operator|&&
name|umatch
argument_list|(
name|DNULL
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|errequest
argument_list|(
name|p
argument_list|,
literal|"Bad file pattern"
argument_list|)
operator|)
operator|>=
name|RV_NUL
condition|)
continue|continue;
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/* getpattern() */
end_comment

begin_comment
comment|/*  *      COMMON DIRECTORY AND FILE ROUTINES  */
end_comment

begin_comment
comment|/* Change current working directory to directory list entry dp */
end_comment

begin_function
name|GLOBL
name|int
name|changelist
parameter_list|(
name|dp
parameter_list|,
name|who
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
block|{
if|if
condition|(
name|cwlist
operator|==
name|dp
condition|)
comment|/* Is already cwd */
return|return
operator|(
name|RV_OK
operator|)
return|;
elseif|else
if|if
condition|(
name|DCANC
argument_list|(
name|dp
argument_list|)
operator|&&
name|chdir
argument_list|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cwlist
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|who
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|CFNAM
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Cannot change"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* changelist() */
end_comment

begin_comment
comment|/* Check if operation for file fn with mode m is allowed */
end_comment

begin_function
name|GLOBL
name|int
name|isallowed
parameter_list|(
name|fn
parameter_list|,
name|m
parameter_list|)
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
name|struct
name|stat
name|st
decl_stmt|;
endif|#
directive|endif
comment|/* S_IFLNK */
specifier|register
name|char
modifier|*
name|err
decl_stmt|;
switch|switch
condition|(
name|m
condition|)
block|{
default|default:
comment|/* Others */
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|FF_SLNK
case|:
comment|/* Check symbolic link */
if|if
condition|(
operator|!
name|ISDIR
argument_list|(
name|fn
argument_list|,
name|st
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Fall thru */
endif|#
directive|endif
comment|/* S_IFLNK */
case|case
name|FF_DIR
case|:
comment|/* Is directory */
name|err
operator|=
literal|"Is a directory"
expr_stmt|;
break|break;
case|case
name|FF_ERR
case|:
comment|/* Error in stat */
name|err
operator|=
literal|"Cannot stat"
expr_stmt|;
break|break;
block|}
name|setvideo
argument_list|(
name|DA_ERROR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"!! %s: %s"
argument_list|,
name|fn
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|setvideo
argument_list|(
name|DA_NORMAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* isallowed() */
end_comment

begin_comment
comment|/* Set sort flag to f and sort/resort filelist */
end_comment

begin_function
name|GLOBL
name|int
name|sortlist
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|DSORT
argument_list|(
name|dp
argument_list|)
operator|!=
name|f
condition|)
block|{
name|DSORT
argument_list|(
name|dp
argument_list|)
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|DFCUR
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|sortflist
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|=
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|n
operator|!=
operator|*
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|DFCUR
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|||
name|CMP
argument_list|(
name|n
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|DFCUR
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|?
name|RV_OK
else|:
name|RV_NUL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sortlist() */
end_comment

begin_comment
comment|/* Rebuild file list with new zoom pattern pat */
end_comment

begin_function
name|GLOBL
name|int
name|zoomlist
parameter_list|(
name|dp
parameter_list|,
name|pat
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|DZOOM
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* Free old pattern */
name|ufree
argument_list|(
name|DZOOM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|DZOOM
argument_list|(
name|dp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pat
operator|&&
name|pat
index|[
literal|0
index|]
condition|)
comment|/* Save new pattern */
name|DZOOM
argument_list|(
name|dp
argument_list|)
operator|=
name|strsav
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|n
operator|=
name|DNFIL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_NUL
condition|)
block|{
comment|/* Rebuild filelist */
operator|(
name|void
operator|)
name|newflist
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* zoomlist() */
end_comment

begin_comment
comment|/* Search for pattern in file f from directory dp */
end_comment

begin_function
name|GLOBL
name|int
name|grepfile
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
name|char
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s \"%s\" %s"
argument_list|,
name|GRFILE
argument_list|,
name|GROPTS
argument_list|,
name|gpattern
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|RV_INT
condition|)
return|return
operator|(
name|errequest
argument_list|(
literal|"Grep"
argument_list|,
literal|"Interrupted"
argument_list|)
operator|)
return|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* grepfile() */
end_comment

begin_comment
comment|/* Find file f in directory dp */
end_comment

begin_function
name|GLOBL
name|int
name|findfile
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|&&
name|umatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|,
name|fpattern
argument_list|)
condition|)
return|return
operator|(
name|RV_OK
operator|)
return|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* findfile() */
end_comment

begin_comment
comment|/* Remove file f from directory dp */
end_comment

begin_function
name|GLOBL
name|int
name|removefile
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|,
name|req
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|req
decl_stmt|;
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Check if file can be removed */
if|if
condition|(
operator|!
name|isallowed
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Remove %s ?"
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Removing %s"
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|RMFILE
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Cannot remove"
argument_list|)
operator|)
return|;
comment|/* Preserve current file, delete flist and set flags */
if|if
condition|(
name|f
operator|<
name|DFCUR
argument_list|(
name|dp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|dp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|deleteflist
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|buildflag
expr_stmt|;
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_CHG
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* removefile() */
end_comment

begin_comment
comment|/* Copy file f from directory dp to directory/file to */
end_comment

begin_function
name|GLOBL
name|int
name|copyfile
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|,
name|to
parameter_list|,
name|req
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|req
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|char
name|from
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Check if copying is allowed */
if|if
condition|(
operator|!
name|isallowed
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|from
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Copy %s ?"
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Copying %s to %s"
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s"
argument_list|,
name|CPFILE
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Error in copying"
argument_list|)
operator|)
return|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copyfile() */
end_comment

begin_comment
comment|/* Move file f from directory dp to directory/file to */
end_comment

begin_function
name|GLOBL
name|int
name|movefile
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|,
name|to
parameter_list|,
name|req
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|req
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|char
name|from
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Check if moving is allowed */
if|if
condition|(
operator|!
name|isallowed
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|from
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Move %s to %s ?"
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Moving %s to %s"
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s"
argument_list|,
name|MVFILE
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Error in moving"
argument_list|)
operator|)
return|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* movefile() */
end_comment

end_unit

