begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      FILE.C  *      UTREE file menu routines.  *      3.01-um klin, Tue Jun  4 14:20:31 1991  *              klin, Tue Oct 15 14:02:37 1991, Handling of symlinks changed  *              klin, Sat Oct 26 15:07:06 1991, Copying and moving changed  *                                              Sorting and zooming changed  *                                              Select directories added  *      3.02-um klin, Fri Nov  1 10:46:14 1991, Screen layout changed  *                                              Marking files changed  *                                              Bug in edit() deleted  *              klin, Sun Nov 24 19:30:43 1991, Cd to current directory before  *                                              executing some commands  *                                              Video attributes changed  *      3.03-um klin, Tue Feb 11 19:39:09 1992, Screen layout changed,  *                                              Variables and filetype commands  *                                              changed  *              klin, Sun Feb 23 17:32:31 1992, Key handling and key bindings  *                                              changed  *              klin, Fri Mar  6 08:18:38 1992, Minor changes in execute()  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03-um (klin) Mar  6 1992 file.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- Local variables and definitions ------------------------------- */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|flast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last current file                    */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|fmark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Marked file                          */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|nscroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines to scroll                      */
end_comment

begin_comment
comment|/* Default file menu commands in help line                              */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|fmline
init|=
literal|" Help Copy Edit Find Grep Move List Print Remove Stat Tag Untag View Quit"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|menuline
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CUR
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'a')
end_define

begin_comment
comment|/* Command works on current file only   */
end_comment

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_function_decl
name|EXTRN
name|char
modifier|*
name|selectdir
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Local/global functions and procedures ------------------------- */
end_comment

begin_comment
comment|/*  *      FILE SCREEN UPDATE AND REFRESH  */
end_comment

begin_comment
comment|/* Show file list from file f to file t */
end_comment

begin_function
name|LOCAL
name|VOID
name|showfiles
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|c
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|t
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
condition|)
block|{
comment|/* Clear file window */
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|firstline
argument_list|)
expr_stmt|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|f
operator|<
name|CNFIL
operator|&&
name|f
operator|<
name|t
operator|&&
name|FFROW
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|<=
name|lastline
condition|)
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|f
operator|++
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* showfiles() */
end_comment

begin_comment
comment|/* Update file screen */
end_comment

begin_function
name|LOCAL
name|VOID
name|updatefiles
parameter_list|()
block|{
if|if
condition|(
name|fileflag
operator|==
name|SF_FULL
condition|)
comment|/* Full update */
name|clearscreen
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileflag
operator|&
name|SF_ECHO
condition|)
comment|/* Echo line */
if|if
condition|(
name|CZOOM
condition|)
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%s/%s: %d file(s)"
argument_list|,
name|CPNAM
argument_list|,
name|CZOOM
argument_list|,
name|CNFIL
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%s/*: %d file(s) %d dir(s)"
argument_list|,
name|CPNAM
argument_list|,
name|CNFIL
argument_list|,
name|CNDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileflag
operator|&
name|SF_HELP
condition|)
comment|/* Help line */
name|putmenu
argument_list|(
literal|"FILE:"
argument_list|,
name|menuline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileflag
operator|&
name|SF_TREE
condition|)
block|{
comment|/* File window */
if|if
condition|(
name|CANSCROLL
operator|&&
name|nscroll
operator|<
literal|0
operator|&&
name|nscroll
operator|>
operator|(
name|firstline
operator|-
name|lastline
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|windowup
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|,
operator|-
name|nscroll
argument_list|)
expr_stmt|;
name|showfiles
argument_list|(
name|CFTOP
operator|+
name|fperpage
operator|-
name|fperline
operator|+
operator|(
name|nscroll
operator|*
name|fperline
operator|)
argument_list|,
name|CFTOP
operator|+
name|fperpage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flast
operator|>=
literal|0
condition|)
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|flast
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CANSCROLL
operator|&&
name|nscroll
operator|>
literal|0
operator|&&
name|nscroll
operator|<
operator|(
name|lastline
operator|-
name|firstline
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|windowdown
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|,
name|nscroll
argument_list|)
expr_stmt|;
name|showfiles
argument_list|(
name|CFTOP
argument_list|,
name|CFTOP
operator|+
operator|(
name|nscroll
operator|*
name|fperline
operator|)
operator|+
name|fperline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flast
operator|>=
literal|0
condition|)
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|flast
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
block|}
else|else
name|showfiles
argument_list|(
name|CFTOP
argument_list|,
name|CNFIL
argument_list|,
name|fileflag
operator|!=
name|SF_FULL
argument_list|)
expr_stmt|;
name|nscroll
operator|=
literal|0
expr_stmt|;
name|fileflag
operator||=
name|SF_LIST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileflag
operator|&
name|SF_LAST
operator|&&
name|flast
operator|>=
literal|0
condition|)
comment|/* Last file */
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|flast
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fileflag
operator|&
name|SF_LIST
operator|)
operator|&&
name|CNFIL
operator|>
literal|0
condition|)
block|{
comment|/* Current file */
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
name|flast
operator|=
name|CFCUR
expr_stmt|;
block|}
if|if
condition|(
name|CNFIL
operator|>
literal|0
condition|)
comment|/* Position to current file */
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
name|FFCOL
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|,
name|FFROW
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|firstline
argument_list|)
expr_stmt|;
name|fileflag
operator|=
literal|0
expr_stmt|;
comment|/* Reset fileflag */
block|}
end_function

begin_comment
comment|/* updatefiles() */
end_comment

begin_comment
comment|/*  *      MARK/TAG FILE  */
end_comment

begin_comment
comment|/* Set mark w on file f */
end_comment

begin_function
name|LOCAL
name|VOID
name|setmark
parameter_list|(
name|f
parameter_list|,
name|w
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|w
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|>=
name|CFTOP
operator|&&
name|f
operator|<
operator|(
name|CFTOP
operator|+
name|fperpage
operator|)
condition|)
block|{
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|w
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
name|FFCOL
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|FFROW
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* setmark() */
end_comment

begin_comment
comment|/* Reset mark on file f */
end_comment

begin_function
name|LOCAL
name|VOID
name|unsetmark
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|>=
name|CFTOP
operator|&&
name|f
operator|<
operator|(
name|CFTOP
operator|+
name|fperpage
operator|)
condition|)
block|{
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
name|FFCOL
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|FFROW
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* unsetmark() */
end_comment

begin_comment
comment|/* Tag single file f */
end_comment

begin_function
name|LOCAL
name|VOID
name|tagfile
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_TAG
expr_stmt|;
operator|++
name|CNTAG
expr_stmt|;
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_TAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tagfile() */
end_comment

begin_comment
comment|/* Untag single file f */
end_comment

begin_function
name|LOCAL
name|VOID
name|untagfile
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
operator|--
name|CNTAG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* untagfile() */
end_comment

begin_comment
comment|/*  *      MOVE IN FILELIST  */
end_comment

begin_comment
comment|/* Go forward or backward in file list */
end_comment

begin_function
name|GLOBL
name|int
name|gofile
parameter_list|(
name|dp
parameter_list|,
name|dir
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
operator|(
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* Next file */
operator|++
name|DFCUR
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|fileflag
operator||=
name|SF_LIST
expr_stmt|;
comment|/* Out of bounds: Search for new top file */
if|if
condition|(
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|>=
operator|(
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|+
name|fperpage
operator|)
operator|&&
operator|(
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|+
name|fperpage
operator|)
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|l
operator|=
operator|(
name|lastline
operator|-
name|firstline
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|l
operator|--
operator|>
literal|0
operator|&&
operator|(
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|+
name|fperpage
operator|)
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|+=
name|fperline
expr_stmt|;
operator|--
name|nscroll
expr_stmt|;
block|}
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
block|}
else|else
name|fileflag
operator||=
name|SF_LAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Previous file */
operator|--
name|DFCUR
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|fileflag
operator||=
name|SF_LIST
expr_stmt|;
comment|/* Out of bounds: Search for new top file */
if|if
condition|(
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|<
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|&&
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|l
operator|=
operator|(
name|lastline
operator|-
name|firstline
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|l
operator|--
operator|>
literal|0
operator|&&
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|-=
name|fperline
expr_stmt|;
operator|++
name|nscroll
expr_stmt|;
block|}
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
block|}
else|else
name|fileflag
operator||=
name|SF_LAST
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gofile() */
end_comment

begin_comment
comment|/*  *      SCROLL FILE LIST  */
end_comment

begin_comment
comment|/* Scroll up or down file list */
end_comment

begin_function
name|LOCAL
name|int
name|scrollfile
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
operator|(
name|CFTOP
operator|+
name|fperpage
operator|)
operator|<
name|CNFIL
condition|)
block|{
comment|/* Scroll up */
name|CFTOP
operator|+=
name|fperline
expr_stmt|;
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowup
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showfiles
argument_list|(
name|CFTOP
operator|+
name|fperpage
operator|-
name|fperline
argument_list|,
name|CFTOP
operator|+
name|fperpage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fileflag
operator||=
name|SF_MOVE
expr_stmt|;
block|}
else|else
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
if|if
condition|(
name|CFCUR
operator|<
name|CFTOP
condition|)
block|{
name|CFCUR
operator|+=
name|fperline
expr_stmt|;
name|fileflag
operator||=
name|SF_LIST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
name|CFTOP
operator|>
literal|0
condition|)
block|{
comment|/* Scroll down */
name|CFTOP
operator|-=
name|fperline
expr_stmt|;
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowdown
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showfiles
argument_list|(
name|CFTOP
argument_list|,
name|CFTOP
operator|+
name|fperline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fileflag
operator||=
name|SF_MOVE
expr_stmt|;
block|}
else|else
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
if|if
condition|(
name|CFCUR
operator|>=
operator|(
name|CFTOP
operator|+
name|fperpage
operator|)
condition|)
block|{
name|CFCUR
operator|-=
name|fperline
expr_stmt|;
name|fileflag
operator||=
name|SF_LIST
expr_stmt|;
block|}
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scrollfile() */
end_comment

begin_comment
comment|/*  *      SELECT DIRECTORY  */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|doselect
parameter_list|(
name|what
parameter_list|)
specifier|register
name|char
modifier|*
name|what
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dn
decl_stmt|;
name|dn
operator|=
name|selectdir
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
name|fileflag
operator|&=
operator|~
operator|(
name|SF_HELP
operator||
name|SF_ECHO
operator|)
expr_stmt|;
name|updatefiles
argument_list|()
expr_stmt|;
return|return
operator|(
name|dn
operator|)
return|;
block|}
end_function

begin_comment
comment|/* doselect() */
end_comment

begin_comment
comment|/*  *      LIST FILE(S)  */
end_comment

begin_comment
comment|/* List file(s) in current file list */
end_comment

begin_function
name|LOCAL
name|int
name|list
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|pat
index|[
name|PATLEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|char
modifier|*
name|ct
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|ff
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to list */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"LIST FILE"
expr_stmt|;
if|if
condition|(
name|t
operator|||
name|CNTAG
operator|<=
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|pat
argument_list|,
literal|"List which files:"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pat
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|t
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Show all matching files */
name|l
operator|=
name|firstline
expr_stmt|;
name|ff
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|t
operator|&&
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|)
operator|||
name|umatch
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|pat
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|l
operator|==
name|firstline
condition|)
block|{
if|if
condition|(
name|ff
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s (CR:continue  ELSE:quit)"
argument_list|,
name|who
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Continue listing ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|' '
operator|)
condition|)
break|break;
block|}
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
block|}
operator|++
name|ff
expr_stmt|;
name|ct
operator|=
name|ctime
argument_list|(
operator|&
name|st
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|ct
index|[
name|strlen
argument_list|(
name|ct
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s  %8ld  %s  %s"
argument_list|,
name|fileaccess
argument_list|(
operator|&
name|st
argument_list|)
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|ct
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|l
operator|>
name|lastline
condition|)
name|l
operator|=
name|firstline
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|>=
name|RV_NUL
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Listed %d file(s) matching %s"
argument_list|,
name|ff
argument_list|,
name|pat
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Listed %d tagged file(s)"
argument_list|,
name|ff
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* list() */
end_comment

begin_comment
comment|/*  *      SEARCH IN FILE(S)  */
end_comment

begin_comment
comment|/* Search for pattern in file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|grep
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to search */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"GREP FILE"
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give pattern (CR:%s)"
argument_list|,
name|who
argument_list|,
name|gpattern
index|[
literal|0
index|]
condition|?
name|gpattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Search for pattern in file:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|input
argument_list|,
sizeof|sizeof
argument_list|(
name|input
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|gpattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
operator|(
name|c
operator|==
name|RV_NUL
operator|&&
name|gpattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
name|c
operator|=
name|RV_NUL
expr_stmt|;
name|f
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
operator|++
name|f
expr_stmt|;
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
comment|/* File tagged */
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Searching in %s"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|grepfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s (CR:next  SP:select  M:mark  T:tag  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Found \'%s\' -> %s:"
argument_list|,
name|gpattern
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|tagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
name|fmark
operator|=
name|f
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
while|while
condition|(
name|f
operator|!=
name|CFCUR
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|cdlist
argument_list|,
name|f
operator|>
name|CFCUR
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|f
operator|<
name|CNFIL
operator|&&
operator|(
name|c
operator|==
name|RV_NUL
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|grepfile
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
block|{
comment|/* Current file */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Found \'%s\'"
argument_list|,
name|gpattern
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|gpattern
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|gpattern
argument_list|,
literal|"Not found"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* grep() */
end_comment

begin_comment
comment|/*  *      FIND FILE(S)  */
end_comment

begin_comment
comment|/* Find file(s) in current file list */
end_comment

begin_function
name|LOCAL
name|int
name|find
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to find */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"FIND FILE"
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:%s)"
argument_list|,
name|who
argument_list|,
name|fpattern
index|[
literal|0
index|]
condition|?
name|fpattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|input
argument_list|,
literal|"Find which file:"
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fpattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
operator|(
name|c
operator|==
name|RV_NUL
operator|&&
name|fpattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|f
operator|=
name|one
condition|?
name|CFCUR
else|:
operator|-
literal|1
expr_stmt|;
do|do
block|{
operator|++
name|f
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|findfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
block|{
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (CR:next  SP:select  M:mark  T:tag  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Found %s:"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|tagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
name|fmark
operator|=
name|f
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
while|while
condition|(
name|f
operator|!=
name|CFCUR
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|cdlist
argument_list|,
name|f
operator|>
name|CFCUR
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|f
operator|<
name|CNFIL
operator|&&
operator|(
name|c
operator|==
name|RV_NUL
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
do|;
if|if
condition|(
name|c
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|fpattern
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|fpattern
argument_list|,
literal|"Not found"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* find() */
end_comment

begin_comment
comment|/*  *      FILE STATUS AND CHANGES  */
end_comment

begin_comment
comment|/* Status information(s)/change(s) for current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|status
parameter_list|(
name|one
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|,
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* No need for status of nothing */
return|return
operator|(
name|RV_OK
operator|)
return|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|c
operator|=
name|statusfile
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|c
operator|=
name|infofile
argument_list|(
name|f
argument_list|,
name|CNTAG
operator|>
literal|0
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|c
operator|==
name|RV_NUL
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|' '
operator|)
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
condition|)
name|c
operator|=
name|statusfile
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Current files */
else|else
name|c
operator|=
name|infofile
argument_list|(
name|CFCUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buildflag
condition|)
comment|/* Rebuilding needed */
name|CFLAG
operator|=
name|FL_CHG
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* status() */
end_comment

begin_comment
comment|/* Display size and modification time of file f */
end_comment

begin_function
name|LOCAL
name|int
name|infofile
parameter_list|(
name|f
parameter_list|,
name|h
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|h
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|who
operator|=
literal|"INFO FILE"
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Cannot stat"
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|h
condition|)
name|puthelp
argument_list|(
literal|"%s %s (CR:continue  ELSE:quit)"
argument_list|,
name|who
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s %s %s"
argument_list|,
name|who
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Access:%s Size:%ld Date:%s"
argument_list|,
name|fileaccess
argument_list|(
operator|&
name|st
argument_list|)
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|ctime
argument_list|(
operator|&
name|st
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* infofile() */
end_comment

begin_comment
comment|/*  *      MOVE OR RENAME FILE(S)  */
end_comment

begin_comment
comment|/* Move current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|move
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|req
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to move */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"MOVE FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
name|puthelp
argument_list|(
literal|"%s: Give destination directory (CR:select one)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Move tagged files to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
name|to
operator|=
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|to
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Cannot stat"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STFMT
argument_list|(
operator|&
name|st
argument_list|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Is not a directory"
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|to
operator|=
name|doselect
argument_list|(
literal|"moving files"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s (N:don't request  Q:quit  ELSE:request)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Request before moving to %s ?"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|req
operator|=
operator|(
name|c
operator|!=
literal|'n'
operator|)
condition|)
name|puthelp
argument_list|(
literal|"%s (Y:move  Q:quit  ELSE:don't move)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|c
operator|=
name|movefile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|to
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* Current file */
name|puthelp
argument_list|(
literal|"%s: Give destination (CR:select directory)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Move file to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
name|to
operator|=
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|to
operator|=
name|doselect
argument_list|(
literal|"moving file"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
name|c
operator|=
name|movefile
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|checkdlist
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Directory needs checking */
operator|++
name|buildflag
expr_stmt|;
comment|/* Set rebuild flags */
name|CFLAG
operator|=
name|FL_CHG
expr_stmt|;
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* move() */
end_comment

begin_comment
comment|/*  *      VIEW FILE(S)  */
end_comment

begin_comment
comment|/* View current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|view
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to view */
return|return
operator|(
name|RV_OK
operator|)
return|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|viewfile
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|'n'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
else|else
comment|/* Current file */
name|c
operator|=
name|viewfile
argument_list|(
name|CFCUR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* view() */
end_comment

begin_comment
comment|/* View single file f */
end_comment

begin_function
name|LOCAL
name|int
name|viewfile
parameter_list|(
name|f
parameter_list|,
name|one
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|one
decl_stmt|;
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
comment|/* Check if viewing is allowed */
if|if
condition|(
operator|!
name|isallowed
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
name|who
operator|=
literal|"VIEW FILE"
expr_stmt|;
comment|/* Simple check for text or binary file. May fail! */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|4
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Cannot open"
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
comment|/* File is empty */
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Is empty"
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|istextfile
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
condition|)
block|{
comment|/* Text file */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s"
argument_list|,
name|VARVAL
argument_list|(
name|V_PG
argument_list|)
argument_list|,
name|VARVAL
argument_list|(
name|V_PGO
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Binary file */
name|puthelp
argument_list|(
literal|"%s (Y:hex dump  ELSE:don't view)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"File %s is not a text file, hex dump ?"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s|%s %s"
argument_list|,
name|VARVAL
argument_list|(
name|V_XD
argument_list|)
argument_list|,
name|VARVAL
argument_list|(
name|V_XDO
argument_list|)
argument_list|,
name|name
argument_list|,
name|VARVAL
argument_list|(
name|V_PG
argument_list|)
argument_list|,
name|VARVAL
argument_list|(
name|V_PGO
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|one
operator|||
name|CNTAG
operator|<
literal|1
condition|)
return|return
operator|(
name|hitakey
argument_list|(
literal|"Viewing done (Hit a key)"
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|DA_REVERSE
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|hitakey
argument_list|(
literal|"Continue (N:no  ELSE:yes) ?"
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|DA_REVERSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* viewfile() */
end_comment

begin_comment
comment|/* Simple check if a file is a text file */
end_comment

begin_function
name|LOCAL
name|int
name|istextfile
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
comment|/* Simple check if all n chars */
if|if
condition|(
operator|!
operator|(
name|isprint
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
comment|/* are printable or whitespace */
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* istextfile() */
end_comment

begin_comment
comment|/*  *      PRINT FILE(S)  */
end_comment

begin_comment
comment|/* Print current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|print
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to print */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"PRINT FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (Y:print  Q:quit  ELSE:don't print)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|printfile
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
else|else
comment|/* Current file */
name|c
operator|=
name|printfile
argument_list|(
name|CFCUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
name|one
operator|||
operator|!
name|CNTAG
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
literal|"Printing done"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* print() */
end_comment

begin_comment
comment|/* Print single file f with request if req is set */
end_comment

begin_function
name|LOCAL
name|int
name|printfile
parameter_list|(
name|f
parameter_list|,
name|req
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|req
decl_stmt|;
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Print %s ?"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Printing %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s"
argument_list|,
name|VARVAL
argument_list|(
name|V_LP
argument_list|)
argument_list|,
name|VARVAL
argument_list|(
name|V_LPO
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Error in printing"
argument_list|)
operator|)
return|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* printfile() */
end_comment

begin_comment
comment|/*  *      REMOVE FILE(S)  */
end_comment

begin_comment
comment|/* Remove current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|Remove
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|req
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to remove */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"REMOVE FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
if|if
condition|(
name|CNTAG
operator|>
literal|1
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s (N:don't request  Q:quit  ELSE:request)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Request before removing ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|req
operator|=
operator|(
name|c
operator|!=
literal|'n'
operator|)
condition|)
name|puthelp
argument_list|(
literal|"%s (Y:remove  Q:quit  ELSE:don't remove)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
block|}
else|else
name|req
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|f
operator|=
name|CNFIL
operator|-
literal|1
init|;
name|f
operator|>=
literal|0
condition|;
name|f
operator|--
control|)
block|{
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|removefile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|req
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Current file */
name|puthelp
argument_list|(
literal|"%s (Y:remove  ELSE:don't remove)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|removefile
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* remove() */
end_comment

begin_comment
comment|/*  *      EDIT FILE(S)  */
end_comment

begin_comment
comment|/* Edit current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|edit
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|char
name|name
index|[
name|FILELEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|mode
decl_stmt|,
name|req
decl_stmt|;
name|who
operator|=
literal|"EDIT FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
if|if
condition|(
name|CNTAG
operator|>
literal|1
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s (N:don't request  Q:quit  ELSE:request)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Request before edit ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|req
operator|=
operator|(
name|c
operator|!=
literal|'n'
operator|)
condition|)
name|puthelp
argument_list|(
literal|"%s (Y:edit  Q:quit  ELSE:don't edit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
block|}
else|else
name|req
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|editfile
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* Current or no files */
if|if
condition|(
name|CNFIL
operator|>
literal|0
condition|)
block|{
name|setmark
argument_list|(
name|CFCUR
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give file name (CR:%s)"
argument_list|,
name|who
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Edit file:"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|CFCUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
else|else
block|{
comment|/* Directory is empty */
name|puthelp
argument_list|(
literal|"%s: Give file name (CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Edit which file:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
name|fname
operator|=
name|c
operator|==
name|RV_NUL
condition|?
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
else|:
name|name
expr_stmt|;
name|mode
operator|=
name|c
operator|==
name|RV_NUL
condition|?
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
else|:
name|FF_NONE
expr_stmt|;
name|c
operator|=
name|editfile
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* edit() */
end_comment

begin_comment
comment|/* Edit single file name (mode mode) with request if req is set */
end_comment

begin_function
name|LOCAL
name|int
name|editfile
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|,
name|req
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|mode
decl_stmt|,
name|req
decl_stmt|;
block|{
name|char
name|pname
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Check if editing is allowed */
if|if
condition|(
operator|!
name|isallowed
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pname
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Edit %s ?"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s"
argument_list|,
name|VARVAL
argument_list|(
name|V_ED
argument_list|)
argument_list|,
name|VARVAL
argument_list|(
name|V_EDO
argument_list|)
argument_list|,
name|pname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkdlist
argument_list|(
name|CPNAM
argument_list|)
expr_stmt|;
comment|/* Directory needs checking */
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* editfile() */
end_comment

begin_comment
comment|/*  *      COPY FILE(S)  */
end_comment

begin_comment
comment|/* Copy current or tagged file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|copy
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|req
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to copy */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"COPY FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
name|puthelp
argument_list|(
literal|"%s: Give destination directory (CR:select one)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Copy tagged files to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
name|to
operator|=
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|to
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Cannot stat"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STFMT
argument_list|(
operator|&
name|st
argument_list|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Is not a directory"
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|to
operator|=
name|doselect
argument_list|(
literal|"copying files"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s (N:don't request  Q:quit  ELSE:request)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Request before copying to %s ?"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|req
operator|=
operator|(
name|c
operator|!=
literal|'n'
operator|)
condition|)
name|puthelp
argument_list|(
literal|"%s (Y:copy  Q:quit  ELSE:don't copy)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|c
operator|=
name|copyfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|to
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* Current file */
name|puthelp
argument_list|(
literal|"%s: Give destination (CR:select directory)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Copy file to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
name|to
operator|=
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|to
operator|=
name|doselect
argument_list|(
literal|"copying file"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
name|c
operator|=
name|copyfile
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|checkdlist
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Directory needs checking */
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copy() */
end_comment

begin_comment
comment|/*  *      ZOOM FILES  */
end_comment

begin_comment
comment|/* Get zoom pattern and rebuild filelist */
end_comment

begin_function
name|LOCAL
name|int
name|zoomfile
parameter_list|()
block|{
name|char
name|pat
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|who
operator|=
literal|"ZOOM FILE"
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|pat
argument_list|,
literal|"Zoom which files:"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|zoomlist
argument_list|(
name|cdlist
argument_list|,
name|pat
argument_list|)
condition|)
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* zoomfile() */
end_comment

begin_comment
comment|/*  *      GOTO DIRECTORY / PARENT DIRECTORY  */
end_comment

begin_comment
comment|/* Goto directory */
end_comment

begin_function
name|LOCAL
name|int
name|gotodirectory
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
name|struct
name|stat
name|st
decl_stmt|;
endif|#
directive|endif
comment|/* S_IFLNK */
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|lev
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to change to */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"GOTO DIRECTORY"
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: %s"
argument_list|,
name|who
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
operator|!=
name|FF_DIR
condition|)
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
operator|!
operator|(
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
operator|==
name|FF_SLNK
operator|&&
name|ISDIR
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|,
name|st
argument_list|)
operator|)
condition|)
endif|#
directive|endif
comment|/* S_IFLNK */
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|,
literal|"Is not a directory"
argument_list|)
operator|)
return|;
block|}
comment|/* Search directory in directory tree */
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
operator|,
name|lev
operator|=
name|CLEVL
operator|+
literal|1
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|==
name|lev
operator|&&
name|EQU
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|,
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Directory is not yet in directory tree */
if|if
condition|(
name|dp
operator|==
name|DNULL
operator|||
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|!=
name|lev
condition|)
name|dp
operator|=
name|newdlist
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|,
name|FL_NUL
argument_list|)
expr_stmt|;
comment|/* Directory file list must be read in */
if|if
condition|(
operator|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
operator|||
name|changedlist
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|"Cannot change"
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: %s (y:change  ELSE:don't change)"
argument_list|,
name|who
argument_list|,
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|errequest
argument_list|(
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|"Is empty, change anyway ?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
comment|/* Position to directory in directory tree and return */
while|while
condition|(
name|cdlist
operator|!=
name|dp
condition|)
operator|(
name|void
operator|)
name|gotree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|RV_DIR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gotodirectory() */
end_comment

begin_comment
comment|/* Goto parent directory */
end_comment

begin_function
name|LOCAL
name|int
name|gotoparent
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|lev
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|cdlist
operator|==
name|droot
condition|)
comment|/* Root has no parent */
return|return
operator|(
name|RV_RET
operator|)
return|;
comment|/* Position to parent directory in directory tree */
name|name
operator|=
name|CFNAM
expr_stmt|;
name|lev
operator|=
name|CLEVL
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|CLEVL
operator|!=
name|lev
condition|)
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Parent directory needs rebuilding */
if|if
condition|(
operator|(
name|CFLAG
operator|!=
name|FL_FIL
operator|||
name|changedlist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|&&
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Position to where we came from in parent directory file list */
name|CFCUR
operator|=
name|CFTOP
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|CMP
argument_list|(
name|name
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|)
operator|&&
name|CFCUR
operator|<
name|CNFIL
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|RV_DIR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gotoparent() */
end_comment

begin_comment
comment|/*  *      TAG / UNTAG FILE(S)  */
end_comment

begin_comment
comment|/* Tag current or selected file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|tag
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to tag */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"TAG FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
condition|)
block|{
comment|/* Multiple files */
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:%s)"
argument_list|,
name|who
argument_list|,
name|tpattern
index|[
literal|0
index|]
condition|?
name|tpattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|input
argument_list|,
literal|"Tag which file:"
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tpattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
operator|(
name|c
operator|==
name|RV_NUL
operator|&&
name|tpattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|one
condition|)
comment|/* Currrent file */
name|tagfile
argument_list|(
name|CFCUR
argument_list|)
expr_stmt|;
else|else
comment|/* Matching files */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|umatch
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|tpattern
argument_list|)
operator|>
literal|0
condition|)
name|tagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tag() */
end_comment

begin_comment
comment|/* Untag current or selected file(s) */
end_comment

begin_function
name|LOCAL
name|int
name|untag
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
name|char
name|pattern
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to untag */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"UNTAG FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
condition|)
block|{
comment|/* Multiple files */
name|setmark
argument_list|(
name|CFCUR
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|getpattern
argument_list|(
name|pattern
argument_list|,
literal|"Untag which file:"
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|CFCUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pattern
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|one
operator|&&
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
condition|)
block|{
comment|/* Current file */
name|untagfile
argument_list|(
name|CFCUR
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|CFCUR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Matching files */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|umatch
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|pattern
argument_list|)
operator|>
literal|0
operator|&&
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* untag() */
end_comment

begin_comment
comment|/*  *      EXECUTE CURRENT FILE  */
end_comment

begin_comment
comment|/* Check if current file is given in command */
end_comment

begin_function
name|LOCAL
name|int
name|filemissing
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
comment|/* Leadin found */
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
operator|||
operator|*
name|s
operator|==
literal|'F'
operator|||
operator|*
name|s
operator|==
literal|'p'
operator|||
operator|*
name|s
operator|==
literal|'P'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Found */
block|}
else|else
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* filemissing() */
end_comment

begin_comment
comment|/* Execute or execute on file f */
end_comment

begin_function
name|LOCAL
name|int
name|execfile
parameter_list|(
name|f
parameter_list|,
name|m
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|m
decl_stmt|;
block|{
name|char
name|cmd
index|[
name|EXECLEN
index|]
decl_stmt|,
name|buf
index|[
literal|2
operator|*
name|INPLEN
index|]
decl_stmt|,
name|par
index|[
name|INPLEN
index|]
decl_stmt|;
specifier|register
name|xlist
modifier|*
name|xp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|setmark
argument_list|(
name|f
argument_list|,
name|FF_MARK
argument_list|)
expr_stmt|;
comment|/* Check if a command is defined for filetype */
for|for
control|(
name|xp
operator|=
name|xroot
init|;
name|xp
condition|;
name|xp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
control|)
if|if
condition|(
name|umatch
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|XTYPE
argument_list|(
name|xp
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Execute filetype dependent command if defined */
if|if
condition|(
name|xp
operator|&&
name|XCOMD
argument_list|(
name|xp
argument_list|)
condition|)
block|{
if|if
condition|(
name|XCOMM
argument_list|(
name|xp
argument_list|)
condition|)
name|puthelp
argument_list|(
literal|"%s: %s #%s"
argument_list|,
name|who
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|XCOMM
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s: %s"
argument_list|,
name|who
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Execute:"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getline
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'l'
argument_list|,
name|XCOMD
argument_list|(
name|xp
argument_list|)
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|filemissing
argument_list|(
name|buf
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %%F"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* File is executable */
elseif|else
if|if
condition|(
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|==
name|FF_EXEC
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: Give parameter(s) or a command"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Execute %s:"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|getline
argument_list|(
name|par
argument_list|,
sizeof|sizeof
argument_list|(
name|par
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'l'
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"./%F"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|filemissing
argument_list|(
name|par
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%%F %s"
argument_list|,
name|par
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|par
argument_list|)
expr_stmt|;
block|}
comment|/* Execute command on current file */
else|else
block|{
name|puthelp
argument_list|(
literal|"%s: Give a command and parameter(s)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Execute on %s:"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|getline
argument_list|(
name|par
argument_list|,
sizeof|sizeof
argument_list|(
name|par
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'l'
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|unsetmark
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|filemissing
argument_list|(
name|par
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %%F"
argument_list|,
name|par
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|par
argument_list|)
expr_stmt|;
block|}
comment|/* Format command line and execute */
name|c
operator|=
name|userformat
argument_list|(
name|cmd
argument_list|,
name|buf
argument_list|,
name|V_FC1
argument_list|,
literal|"EXECUTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Bad format"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: %s"
argument_list|,
name|who
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|c
operator|=
name|callsystem
argument_list|(
name|cmd
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|RV_OK
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|cmd
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
literal|"Error in executing"
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|hitakey
argument_list|(
literal|"Return from execute (Hit a key)"
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|DA_REVERSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* execfile() */
end_comment

begin_comment
comment|/* Execute or execute on files */
end_comment

begin_function
name|LOCAL
name|int
name|execute
parameter_list|(
name|one
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
comment|/* Nothing to execute */
return|return
operator|(
name|RV_OK
operator|)
return|;
name|who
operator|=
literal|"EXECUTE FILE"
expr_stmt|;
if|if
condition|(
operator|!
name|one
operator|&&
name|CNTAG
condition|)
block|{
comment|/* Tagged files */
name|m
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|untagfile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|execfile
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
break|break;
block|}
block|}
else|else
comment|/* Current file */
name|c
operator|=
name|execfile
argument_list|(
name|CFCUR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkdlist
argument_list|(
name|CPNAM
argument_list|)
expr_stmt|;
comment|/* Directory needs checking */
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* execute() */
end_comment

begin_comment
comment|/*  *      FILE MENU LOOP  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
end_if

begin_comment
comment|/* Refresh file screen after screen size changes */
end_comment

begin_function
name|GLOBL
name|int
name|refreshfile
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
condition|)
operator|(
name|void
operator|)
name|refreshtree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|f
operator|=
name|CFCUR
expr_stmt|;
name|CFTOP
operator|=
name|CFCUR
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|CFCUR
operator|!=
name|f
operator|&&
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
name|flast
operator|=
operator|-
literal|1
expr_stmt|;
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* refreshfile() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGWINCH&& TIOCGWINSZ */
end_comment

begin_comment
comment|/* File menu */
end_comment

begin_function
name|GLOBL
name|int
name|filemenu
parameter_list|(
name|f
parameter_list|,
name|r
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|r
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|who
operator|=
literal|"FILE MENU"
expr_stmt|;
comment|/* Change to directory and check if it is empty */
if|if
condition|(
operator|(
name|c
operator|=
name|changelist
argument_list|(
name|cdlist
argument_list|,
name|who
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|RV_DIR
operator|&&
name|CNFIL
operator|==
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: %s (Y:change  ELSE:don't change)"
argument_list|,
name|who
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Is empty, change anyway ?"
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
comment|/* Position to current file on screen */
if|if
condition|(
name|f
operator|>=
literal|0
operator|&&
name|f
operator|<
name|CNFIL
condition|)
while|while
condition|(
name|CFCUR
operator|!=
name|f
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
operator|<
name|f
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Init file variables */
if|if
condition|(
name|menuline
operator|==
name|NULL
condition|)
name|menuline
operator|=
name|fmline
expr_stmt|;
name|buildflag
operator|=
literal|0
expr_stmt|;
name|nscroll
operator|=
literal|0
expr_stmt|;
name|flast
operator|=
operator|-
literal|1
expr_stmt|;
name|fmark
operator|=
operator|-
literal|1
expr_stmt|;
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
comment|/* File menu loop */
do|do
block|{
comment|/* Update file screen if needed and clock */
if|if
condition|(
name|fileflag
operator|&&
operator|!
name|keypressed
argument_list|()
condition|)
name|updatefiles
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UTCLOCK
if|if
condition|(
name|VARSET
argument_list|(
name|V_CL
argument_list|)
condition|)
name|clockon
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* UTCLOCK */
name|flushout
argument_list|()
expr_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UTCLOCK
if|if
condition|(
name|VARSET
argument_list|(
name|V_CL
argument_list|)
condition|)
name|clockoff
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* UTCLOCK */
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
comment|/* Unknown: ring the bell */
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_BACK
case|:
comment|/* Previous file */
case|case
literal|'k'
case|:
comment|/* For vi fans */
if|if
condition|(
operator|!
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_FORW
case|:
comment|/* Next file */
case|case
literal|'j'
case|:
comment|/* For vi fans */
if|if
condition|(
operator|!
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_PREV
case|:
comment|/* Up file */
if|if
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fperline
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_NEXT
case|:
comment|/* Down file */
if|if
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fperline
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_PPAG
case|:
comment|/* Previous page */
if|if
condition|(
name|CFTOP
operator|>
literal|0
operator|&&
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fperpage
operator|&&
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
else|else
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_NPAG
case|:
comment|/* Next page */
if|if
condition|(
operator|(
name|CFTOP
operator|+
name|fperpage
operator|)
operator|<
name|CNFIL
operator|&&
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fperpage
operator|&&
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
else|else
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_HOME
case|:
comment|/* First file */
name|i
operator|=
name|CFCUR
expr_stmt|;
if|if
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fmark
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_END
case|:
comment|/* Last file */
name|i
operator|=
name|CFCUR
expr_stmt|;
if|if
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fmark
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Mark current file */
case|case
name|K_MARK
case|:
name|fmark
operator|=
name|CFCUR
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Goto previously marked file */
case|case
name|K_GOTO
case|:
name|j
operator|=
name|fmark
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CFCUR
init|;
name|i
operator|<
name|CNFIL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmark
operator|==
name|i
condition|)
block|{
while|while
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
operator|&&
name|CFCUR
operator|!=
name|fmark
condition|)
empty_stmt|;
name|fmark
operator|=
name|j
expr_stmt|;
goto|goto
name|MDONE
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CFCUR
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmark
operator|==
name|i
condition|)
block|{
while|while
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
operator|&&
name|CFCUR
operator|!=
name|fmark
condition|)
empty_stmt|;
name|fmark
operator|=
name|j
expr_stmt|;
goto|goto
name|MDONE
goto|;
block|}
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
name|MDONE
label|:
break|break;
case|case
name|K_TAG
case|:
comment|/* Next tagged file */
for|for
control|(
name|i
operator|=
name|CFCUR
operator|+
literal|1
init|;
name|i
operator|<
name|CNFIL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|)
condition|)
block|{
while|while
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
operator|&&
name|CFCUR
operator|!=
name|i
condition|)
empty_stmt|;
goto|goto
name|TDONE
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CFCUR
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|)
condition|)
block|{
while|while
condition|(
name|gofile
argument_list|(
name|cdlist
argument_list|,
operator|-
literal|1
argument_list|)
operator|&&
name|CFCUR
operator|!=
name|i
condition|)
empty_stmt|;
goto|goto
name|TDONE
goto|;
block|}
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
name|TDONE
label|:
break|break;
case|case
name|K_UP
case|:
comment|/* Scroll up */
if|if
condition|(
operator|!
name|scrollfile
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_DOWN
case|:
comment|/* Scroll down */
if|if
condition|(
operator|!
name|scrollfile
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* Change to directory */
case|case
name|K_INS
case|:
name|c
operator|=
name|gotodirectory
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/* Back to parent directory */
case|case
name|K_DEL
case|:
name|c
operator|=
name|gotoparent
argument_list|()
expr_stmt|;
break|break;
case|case
name|K_SIZE
case|:
comment|/* Screen size changed */
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
name|c
operator|=
name|RV_SIZ
expr_stmt|;
else|#
directive|else
comment|/* !SIGWINCH || !TIOCGWINSZ */
name|c
operator|=
name|RV_OK
expr_stmt|;
endif|#
directive|endif
comment|/* SIGWINCH&& TIOCGWINSZ */
comment|/*Fall thru*/
case|case
name|K_REFR
case|:
comment|/* Refresh */
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* New sort file list */
case|case
literal|'N'
case|:
name|fmark
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|sortlist
argument_list|(
name|cdlist
argument_list|,
name|CSORT
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Date */
case|case
literal|'D'
case|:
name|c
operator|=
name|printdate
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Current directory */
case|case
literal|'W'
case|:
name|c
operator|=
name|printcwd
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Help */
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
case|case
name|K_HELP
case|:
name|c
operator|=
name|showhelp
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Tag current or tagged file(s) */
case|case
literal|'T'
case|:
name|c
operator|=
name|tag
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Untag current or tagged file(s) */
case|case
literal|'U'
case|:
name|c
operator|=
name|untag
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Search string in file */
case|case
literal|'G'
case|:
name|c
operator|=
name|grep
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Find file */
case|case
literal|'F'
case|:
name|c
operator|=
name|find
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Copy current or tagged file(s) */
case|case
literal|'C'
case|:
name|c
operator|=
name|copy
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Edit current or tagged file(s) */
case|case
literal|'E'
case|:
name|c
operator|=
name|edit
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Status of current or tagged file(s) */
case|case
literal|'S'
case|:
name|c
operator|=
name|status
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Short info of current or tagged file(s) */
case|case
literal|'I'
case|:
name|c
operator|=
name|status
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Print current or tagged file(s) */
case|case
literal|'P'
case|:
name|c
operator|=
name|print
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* View current or tagged file(s) */
case|case
literal|'V'
case|:
name|c
operator|=
name|view
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Move current or tagged file(s) */
case|case
literal|'M'
case|:
name|c
operator|=
name|move
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Remove current or tagged file(s) */
case|case
literal|'R'
case|:
name|c
operator|=
name|Remove
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* List files */
case|case
literal|'L'
case|:
name|c
operator|=
name|list
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Execute current file */
case|case
literal|'X'
case|:
name|c
operator|=
name|execute
argument_list|(
name|CUR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* Switch menu line */
name|menuline
operator|=
name|menuline
operator|==
name|ufilemenu
condition|?
name|fmline
else|:
name|ufilemenu
expr_stmt|;
name|fileflag
operator||=
name|SF_HELP
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* User defined file commands 1..9 */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|c
operator|=
name|usercommand
argument_list|(
name|c
operator|-
literal|'0'
operator|+
name|V_FC0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
comment|/* Shell escape */
case|case
literal|'$'
case|:
name|c
operator|=
name|history
argument_list|(
name|c
argument_list|,
name|V_FC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VARSET
argument_list|(
name|V_ST
argument_list|)
condition|)
operator|(
name|void
operator|)
name|scandlist
argument_list|(
name|droot
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* Show/set variables */
name|c
operator|=
name|variables
argument_list|()
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* Show/set file type commands */
name|c
operator|=
name|commands
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* Show key bindings */
name|c
operator|=
name|bindings
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* Rebuild file list */
name|fmark
operator|=
operator|-
literal|1
expr_stmt|;
name|CFLAG
operator|=
name|FL_CHG
expr_stmt|;
operator|++
name|buildflag
expr_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Zoom file list */
case|case
literal|'Z'
case|:
name|c
operator|=
name|zoomfile
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Display version string */
case|case
literal|'A'
case|:
name|c
operator|=
name|putversion
argument_list|(
name|echoline
argument_list|,
literal|"ABOUT: Utree version"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Return to tree screen */
case|case
literal|'Q'
case|:
case|case
literal|' '
case|:
case|case
name|K_SEL
case|:
case|case
name|K_BRK
case|:
name|c
operator|=
name|RV_RET
expr_stmt|;
break|break;
case|case
name|K_EOF
case|:
comment|/* Exit */
name|c
operator|=
name|RV_END
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
comment|/* Refresh screen after screen resize */
if|if
condition|(
name|c
operator|==
name|RV_SIZ
condition|)
name|c
operator|=
name|refreshfile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGWINCH&& TIOCGWINSZ */
comment|/* Rebuilding needed */
if|if
condition|(
name|buildflag
operator|&&
name|updatedlist
argument_list|()
operator|!=
name|RV_OK
condition|)
name|c
operator|=
name|RV_ERR
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>=
name|RV_INT
condition|)
do|;
comment|/* Set treeflag and return */
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* filemenu() */
end_comment

end_unit

