begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      BIND.C  *      UTREE key binding routines.  *      3.03-um klin, Sun Feb 23 18:45:19 1992  *              klin, Fri Mar  6 07:24:23 1992, Minor changes  *            a klin, Sun Mar 15 19:08:25 1992, Bug fixes in bindings()  *                                              and insertbinding()  *            b klin, Sun Mar 22 10:41:52 1992, Minor fixes  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03b-um (klin) Mar 22 1992 bind.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- Local variables and definitions ------------------------------- */
end_comment

begin_comment
comment|/*  *      All default keys and some function keys are defined in static  *      arrays of type struct _ktable. The default keys are hold in the  *      array defkeys[] and bound at startup to the defined utree keys.  *      The function keys whose termcap names are stored in the array  *      are extracted from terminfo/termcap and bound to the default  *      utree keys if they are defined in the database.  */
end_comment

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
block|{
comment|/* Default key bindings                 */
name|char
modifier|*
name|string
decl_stmt|;
comment|/*   Key string                         */
name|ksym
name|symbol
decl_stmt|;
comment|/*   Key symbol known by utree          */
block|}
name|defkeys
index|[]
init|=
block|{
block|{
literal|"\200"
block|,
name|K_MARK
block|}
block|,
comment|/*   C-@: Set mark                      */
block|{
literal|"\001"
block|,
name|K_HOME
block|}
block|,
comment|/*   C-a: Beginning                     */
block|{
literal|"\002"
block|,
name|K_BACK
block|}
block|,
comment|/*   C-b: Backward                      */
block|{
literal|"\003"
block|,
name|K_BRK
block|}
block|,
comment|/*   C-c: Break                         */
block|{
literal|"\004"
block|,
name|K_DOWN
block|}
block|,
comment|/*   C-d: Scroll down/delete char       */
block|{
literal|"\005"
block|,
name|K_END
block|}
block|,
comment|/*   C-e: End                           */
block|{
literal|"\006"
block|,
name|K_FORW
block|}
block|,
comment|/*   C-f: Forward                       */
block|{
literal|"\007"
block|,
name|K_GOTO
block|}
block|,
comment|/*   C-g: Goto mark                     */
block|{
literal|"\010"
block|,
name|K_DEL
block|}
block|,
comment|/*   C-h: Goto parent/delete char back  */
block|{
literal|"\011"
block|,
name|K_TAG
block|}
block|,
comment|/*   C-i: Goto tag/transpose chars      */
block|{
literal|"\012"
block|,
name|K_SEL
block|}
block|,
comment|/*   C-j: Select/accept line            */
block|{
literal|"\013"
block|,
name|K_KILL
block|}
block|,
comment|/*   C-k: Kill line                     */
block|{
literal|"\014"
block|,
name|K_REFR
block|}
block|,
comment|/*   C-l: Refresh screen/line           */
block|{
literal|"\015"
block|,
name|K_SEL
block|}
block|,
comment|/*   C-m: Select/accept line            */
block|{
literal|"\016"
block|,
name|K_NEXT
block|}
block|,
comment|/*   C-n: Next                          */
block|{
literal|"\017"
block|,
name|K_INS
block|}
block|,
comment|/*   C-o: Change to/toggle insert mode  */
block|{
literal|"\020"
block|,
name|K_PREV
block|}
block|,
comment|/*   C-p: Previous                      */
block|{
literal|"\022"
block|,
name|K_HELP
block|}
block|,
comment|/*   C-r: Help                          */
block|{
literal|"\024"
block|,
name|K_TAG
block|}
block|,
comment|/*   C-t: Goto tag/transpose characters */
block|{
literal|"\025"
block|,
name|K_UP
block|}
block|,
comment|/*   C-u: Scroll up                     */
block|{
literal|"\026"
block|,
name|K_NPAG
block|}
block|,
comment|/*   C-v: Next page/scroll forw line    */
block|{
literal|"\027"
block|,
name|K_PPAG
block|}
block|,
comment|/*   C-w: Prev page/scroll back line    */
block|{
literal|"\030"
block|,
name|K_CANC
block|}
block|,
comment|/*   C-x: Delete input line             */
block|{
literal|"\031"
block|,
name|K_BRK
block|}
block|,
comment|/*   C-y: Break                         */
block|{
literal|"\032"
block|,
name|K_EOF
block|}
block|,
comment|/*   C-z: Exit                          */
block|{
literal|"\177"
block|,
name|K_DEL
block|}
block|,
comment|/*   C-?: Delete                        */
block|{
name|NULL
block|,
name|K_INV
block|}
block|,
comment|/* End of default key table             */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DTSTR
parameter_list|(
name|n
parameter_list|)
value|(defkeys[n].string)
end_define

begin_define
define|#
directive|define
name|DTSYM
parameter_list|(
name|n
parameter_list|)
value|(defkeys[n].symbol)
end_define

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
block|{
comment|/* Function key table                   */
name|char
modifier|*
name|string
decl_stmt|;
comment|/*   Termcap name                       */
name|ksym
name|symbol
decl_stmt|;
comment|/*   Key symbol known by utree          */
name|char
modifier|*
name|name
decl_stmt|;
comment|/*   Key name                           */
block|}
name|funkeys
index|[]
init|=
block|{
block|{
literal|"ku"
block|,
name|K_PREV
block|,
literal|"CursorUp-Key"
block|}
block|,
block|{
literal|"kd"
block|,
name|K_NEXT
block|,
literal|"CursorDown-Key"
block|}
block|,
block|{
literal|"kl"
block|,
name|K_BACK
block|,
literal|"CursorBackward-Key"
block|}
block|,
block|{
literal|"kr"
block|,
name|K_FORW
block|,
literal|"CursorForward-Key"
block|}
block|,
block|{
literal|"kh"
block|,
name|K_HOME
block|,
literal|"Home-Key"
block|}
block|,
ifdef|#
directive|ifdef
name|XENIX
comment|/* RG 11/22/91 */
block|{
literal|"HM"
block|,
name|K_HOME
block|,
literal|"Begin-Key"
block|}
block|,
block|{
literal|"EN"
block|,
name|K_END
block|,
literal|"End-Key"
block|}
block|,
block|{
literal|"PD"
block|,
name|K_NPAG
block|,
literal|"NextPage-Key"
block|}
block|,
block|{
literal|"PU"
block|,
name|K_PPAG
block|,
literal|"PrevPage-Key"
block|}
block|,
else|#
directive|else
comment|/* !XENIX */
block|{
literal|"@1"
block|,
name|K_HOME
block|,
literal|"Begin-Key"
block|}
block|,
block|{
literal|"@7"
block|,
name|K_END
block|,
literal|"End-Key"
block|}
block|,
block|{
literal|"kN"
block|,
name|K_NPAG
block|,
literal|"NextPage-Key"
block|}
block|,
block|{
literal|"kP"
block|,
name|K_PPAG
block|,
literal|"PrevPage-Key"
block|}
block|,
endif|#
directive|endif
comment|/* XENIX */
block|{
literal|"kR"
block|,
name|K_UP
block|,
literal|"ScrollUp-Key"
block|}
block|,
block|{
literal|"kF"
block|,
name|K_DOWN
block|,
literal|"ScrollDown-Key"
block|}
block|,
block|{
literal|"kI"
block|,
name|K_INS
block|,
literal|"Insert-Key"
block|}
block|,
block|{
literal|"kD"
block|,
name|K_DOWN
block|,
literal|"Delete-Key"
block|}
block|,
block|{
literal|"kC"
block|,
name|K_REFR
block|,
literal|"Clear-Key"
block|}
block|,
block|{
literal|"%1"
block|,
name|K_HELP
block|,
literal|"Help-Key"
block|}
block|,
block|{
literal|"*6"
block|,
name|K_SEL
block|,
literal|"Select-Key"
block|}
block|,
block|{
literal|"@4"
block|,
name|K_SEL
block|,
literal|"Do/Command-Key"
block|}
block|,
block|{
literal|"%2"
block|,
name|K_MARK
block|,
literal|"Mark-Key"
block|}
block|,
block|{
literal|"@8"
block|,
name|K_SEL
block|,
literal|"Enter-Key"
block|}
block|,
block|{
name|NULL
block|,
name|K_INV
block|,
name|NULL
block|}
block|,
comment|/*   End function key table             */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FTSTR
parameter_list|(
name|n
parameter_list|)
value|(funkeys[n].string)
end_define

begin_define
define|#
directive|define
name|FTSYM
parameter_list|(
name|n
parameter_list|)
value|(funkeys[n].symbol)
end_define

begin_define
define|#
directive|define
name|FTNAM
parameter_list|(
name|n
parameter_list|)
value|(funkeys[n].name)
end_define

begin_define
define|#
directive|define
name|KEYLEN
value|32
end_define

begin_comment
comment|/* Max length of key strings            */
end_comment

begin_define
define|#
directive|define
name|KCOL
value|12
end_define

begin_define
define|#
directive|define
name|EOL
parameter_list|(
name|c
parameter_list|)
value|(c==' ' || c=='\t' || c=='#' || c=='\n' || c=='\0')
end_define

begin_decl_stmt
name|LOCAL
name|int
name|klchg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changes in key bindings list         */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|unknown
init|=
literal|"UNKNOWN"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_function_decl
name|EXTRN
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|getversion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|strclean
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Functions and procedures -------------------------------------- */
end_comment

begin_comment
comment|/*  *      INTERNAL USED ROUTINES  */
end_comment

begin_comment
comment|/* Insert keybinding from string str to symbol sym into binding list */
end_comment

begin_function
name|LOCAL
name|int
name|insertbinding
parameter_list|(
name|str
parameter_list|,
name|sym
parameter_list|,
name|nam
parameter_list|,
name|ins
parameter_list|,
name|usr
parameter_list|)
specifier|register
name|kchar
modifier|*
name|str
decl_stmt|;
specifier|register
name|ksym
name|sym
decl_stmt|;
specifier|register
name|char
modifier|*
name|nam
decl_stmt|,
decl|*
name|ins
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|usr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|klist
modifier|*
name|kp
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|UNULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Search for string in key binding list */
for|for
control|(
name|kp
operator|=
name|kroot
init|;
name|kp
condition|;
name|kp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|kp
argument_list|)
control|)
if|if
condition|(
name|EQU
argument_list|(
name|str
argument_list|,
name|KBSTR
argument_list|(
name|kp
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Replace an existing key binding */
if|if
condition|(
name|kp
condition|)
block|{
if|if
condition|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
operator|==
name|K_STR
operator|&&
name|KBINS
argument_list|(
name|kp
argument_list|)
condition|)
name|ufree
argument_list|(
name|KBINS
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|K_STR
operator|&&
name|ins
condition|)
name|KBINS
argument_list|(
name|kp
argument_list|)
operator|=
name|strsav
argument_list|(
name|ins
argument_list|)
expr_stmt|;
else|else
name|KBINS
argument_list|(
name|kp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|KBSYM
argument_list|(
name|kp
argument_list|)
operator|=
name|sym
expr_stmt|;
name|KBUSR
argument_list|(
name|kp
argument_list|)
operator|=
name|usr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Create a new binding */
name|kp
operator|=
operator|(
name|klist
operator|*
operator|)
name|ualloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|klist
argument_list|)
argument_list|)
expr_stmt|;
name|KBSTR
argument_list|(
name|kp
argument_list|)
operator|=
operator|(
name|kchar
operator|*
operator|)
name|strsav
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|KBINS
argument_list|(
name|kp
argument_list|)
operator|=
name|sym
operator|==
name|K_STR
operator|&&
name|ins
condition|?
name|strsav
argument_list|(
name|ins
argument_list|)
else|:
name|NULL
expr_stmt|;
name|KBNAM
argument_list|(
name|kp
argument_list|)
operator|=
name|nam
condition|?
name|strsav
argument_list|(
name|nam
argument_list|)
else|:
name|NULL
expr_stmt|;
name|KBSYM
argument_list|(
name|kp
argument_list|)
operator|=
name|sym
expr_stmt|;
name|KBUSR
argument_list|(
name|kp
argument_list|)
operator|=
name|usr
expr_stmt|;
comment|/* Insert the binding into key binding list in reverse lexical order */
if|if
condition|(
name|kroot
operator|&&
name|CMP
argument_list|(
name|str
argument_list|,
name|KBSTR
argument_list|(
name|kroot
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|kroot
init|;
name|KBNXT
argument_list|(
name|pp
argument_list|)
condition|;
name|pp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|pp
argument_list|)
control|)
block|{
name|p
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|CMP
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
name|KBSTR
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
name|KBPRV
argument_list|(
name|kp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|pp
expr_stmt|;
name|KBNXT
argument_list|(
name|kp
argument_list|)
operator|=
name|KBNXT
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|pp
argument_list|)
condition|)
name|KBPRV
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|kp
expr_stmt|;
name|KBNXT
argument_list|(
name|pp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|kp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kroot
condition|)
name|KBPRV
argument_list|(
name|kroot
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|kp
expr_stmt|;
name|KBPRV
argument_list|(
name|kp
argument_list|)
operator|=
name|GNULL
expr_stmt|;
name|KBNXT
argument_list|(
name|kp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|kroot
expr_stmt|;
name|kroot
operator|=
name|kp
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* insertbinding() */
end_comment

begin_comment
comment|/* Compare key name and return symbol */
end_comment

begin_function
name|LOCAL
name|ksym
name|getkeysymbol
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\"'
condition|)
block|{
comment|/* Bind key to string to insert */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\"'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\"'
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|K_STR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Bind key to utree key */
name|strupper
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|KNNAM
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EQU
argument_list|(
name|s
argument_list|,
name|KNNAM
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|KNSYM
argument_list|(
name|i
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|K_INV
operator|)
return|;
block|}
end_function

begin_comment
comment|/* getkeysymbol() */
end_comment

begin_comment
comment|/* Create a key string from ascii string s */
end_comment

begin_function
name|LOCAL
name|kchar
modifier|*
name|getkeystring
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|kchar
name|st
index|[
name|KEYLEN
operator|+
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|o
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|EOL
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|i
operator|<
name|KEYLEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|EOL
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
name|UNULL
operator|)
return|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
comment|/* As it is */
name|st
index|[
name|i
index|]
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Escape */
case|case
literal|'E'
case|:
name|st
index|[
name|i
index|]
operator|=
literal|0x1b
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Newline */
name|st
index|[
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Carriage return */
name|st
index|[
name|i
index|]
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Tab */
name|st
index|[
name|i
index|]
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Space */
name|st
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Formfeed */
name|st
index|[
name|i
index|]
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Backspace */
name|st
index|[
name|i
index|]
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* Octal given value */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|o
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|o
operator|<
literal|0377
condition|)
block|{
name|o
operator|<<=
literal|3
expr_stmt|;
name|o
operator||=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
do|;
name|st
index|[
name|i
index|]
operator|=
operator|(
name|kchar
operator|)
name|o
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'^'
condition|)
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|EOL
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
name|UNULL
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'?'
condition|)
comment|/* DEL */
name|st
index|[
name|i
index|]
operator|=
literal|0x7f
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'@'
condition|)
comment|/* NUL */
name|st
index|[
name|i
index|]
operator|=
literal|0x80
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'A'
operator|&&
operator|*
name|s
operator|<=
literal|'_'
condition|)
comment|/* SOH .. US */
name|st
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|-
literal|'@'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'a'
operator|&&
operator|*
name|s
operator|<=
literal|'z'
condition|)
comment|/* SOH .. SUB */
name|st
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|-
literal|'`'
expr_stmt|;
else|else
return|return
operator|(
name|UNULL
operator|)
return|;
block|}
else|else
name|st
index|[
name|i
index|]
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|++
name|s
expr_stmt|;
block|}
name|st
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|i
operator|>
literal|0
condition|?
name|st
else|:
name|UNULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* getkeystring() */
end_comment

begin_comment
comment|/* Get and return ascii readable string from key string s */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|keystring
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|kchar
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|"INVALID"
operator|)
return|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|0x80
case|:
comment|/* Terminfo: ASCII-NUL */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"^@"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/* ESC */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\e"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
comment|/* BS */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f
case|:
comment|/* DEL */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"^?"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
comment|/* SP */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* NL */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* CR */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
comment|/* TAB */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
comment|/* FF */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Others */
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
comment|/* Control character */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s^%c"
argument_list|,
name|buf
argument_list|,
operator|*
name|s
operator|+
literal|'@'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>
literal|0x80
condition|)
comment|/* Most significant bit set */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\\%03o"
argument_list|,
name|buf
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
comment|/* Printable character */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%c"
argument_list|,
name|buf
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* keystring() */
end_comment

begin_comment
comment|/* Get and return name of symbol k */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|keysymbol
parameter_list|(
name|k
parameter_list|)
specifier|register
name|ksym
name|k
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|KNNAM
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|KNSYM
argument_list|(
name|i
argument_list|)
operator|==
name|k
condition|)
return|return
operator|(
name|KNNAM
argument_list|(
name|i
argument_list|)
operator|)
return|;
return|return
operator|(
name|unknown
operator|)
return|;
block|}
end_function

begin_comment
comment|/* keysymbol() */
end_comment

begin_comment
comment|/* Get and return meaning of symbol k */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|keymeaning
parameter_list|(
name|k
parameter_list|)
specifier|register
name|ksym
name|k
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|KNNAM
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|KNSYM
argument_list|(
name|i
argument_list|)
operator|==
name|k
condition|)
return|return
operator|(
name|KNCOM
argument_list|(
name|i
argument_list|)
operator|)
return|;
return|return
operator|(
name|unknown
operator|)
return|;
block|}
end_function

begin_comment
comment|/* keymeaning() */
end_comment

begin_comment
comment|/* Show all key bindings */
end_comment

begin_function
name|LOCAL
name|int
name|showbindings
parameter_list|()
block|{
name|char
name|str
index|[
name|INPLEN
index|]
decl_stmt|;
specifier|register
name|klist
modifier|*
name|kp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ks
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|,
name|c
decl_stmt|,
name|kl
decl_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
for|for
control|(
name|kp
operator|=
name|kroot
init|;
name|KBNXT
argument_list|(
name|kp
argument_list|)
condition|;
name|kp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|kp
argument_list|)
control|)
empty_stmt|;
for|for
control|(
name|l
operator|=
name|firstline
init|;
name|kp
condition|;
name|kp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBPRV
argument_list|(
name|kp
argument_list|)
control|)
block|{
name|ks
operator|=
name|keystring
argument_list|(
operator|(
name|kchar
operator|*
operator|)
name|KBSTR
argument_list|(
name|kp
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|kl
operator|=
name|strlen
argument_list|(
name|ks
argument_list|)
expr_stmt|;
if|if
condition|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
operator|==
name|K_STR
operator|&&
name|KBINS
argument_list|(
name|kp
argument_list|)
condition|)
name|c
operator|=
name|putfxy
argument_list|(
name|kl
operator|<
name|KCOL
condition|?
name|KCOL
operator|-
name|kl
else|:
literal|0
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s=\"%s\""
argument_list|,
name|ks
argument_list|,
name|KBINS
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|putfxy
argument_list|(
name|kl
operator|<
name|KCOL
condition|?
name|KCOL
operator|-
name|kl
else|:
literal|0
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s=%s"
argument_list|,
name|ks
argument_list|,
name|keysymbol
argument_list|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KBNAM
argument_list|(
name|kp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|c
operator|>
name|columns
operator|/
literal|2
condition|?
name|c
else|:
name|columns
operator|/
literal|2
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"#%s"
argument_list|,
name|KBNAM
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|c
operator|>
name|columns
operator|/
literal|2
condition|?
name|c
else|:
name|columns
operator|/
literal|2
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"#%s"
argument_list|,
name|keymeaning
argument_list|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|l
operator|>
name|lastline
operator|&&
name|KBPRV
argument_list|(
name|kp
argument_list|)
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s (CR:continue  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"More key bindings ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* showbindings() */
end_comment

begin_comment
comment|/* Insert a key binding from a startup file line s. Ingore errors */
end_comment

begin_function
name|LOCAL
name|int
name|setbinding
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|kchar
modifier|*
name|str
decl_stmt|;
specifier|register
name|ksym
name|sym
decl_stmt|;
comment|/* First scan and clean keystring and keyname/string to insert */
if|if
condition|(
operator|(
name|sp
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|strclean
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Get additional comment and clean binding/comment */
if|if
condition|(
name|cp
operator|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|strclean
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|strclean
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Get key string from s and key symbol from sp */
if|if
condition|(
operator|(
name|str
operator|=
name|getkeystring
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|UNULL
operator|||
operator|(
name|sym
operator|=
name|getkeysymbol
argument_list|(
name|sp
argument_list|)
operator|)
operator|==
name|K_INV
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|insertbinding
argument_list|(
name|str
argument_list|,
name|sym
argument_list|,
name|cp
operator|&&
operator|*
name|cp
condition|?
name|cp
else|:
name|NULL
argument_list|,
name|sym
operator|==
name|K_STR
condition|?
operator|++
name|sp
else|:
name|NULL
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setbinding() */
end_comment

begin_comment
comment|/*  *      KEY BINDING ROUTINES  */
end_comment

begin_comment
comment|/* Initialize key bindings */
end_comment

begin_function
name|GLOBL
name|VOID
name|initbindings
parameter_list|(
name|term
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|term
decl_stmt|,
decl|*
modifier|*
name|cp
decl_stmt|;
end_function

begin_block
block|{
name|char
name|buf
index|[
name|NAMELEN
index|]
decl_stmt|,
name|bind
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|kchar
modifier|*
name|k
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* First: Initialize and link keyname list */
name|KNNXT
argument_list|(
literal|0
argument_list|)
operator|=
name|KNLST
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|KNNAM
argument_list|(
name|i
operator|+
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|KNNXT
argument_list|(
name|i
argument_list|)
operator|=
name|KNLST
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|KNPRV
argument_list|(
name|i
argument_list|)
operator|=
name|KNLST
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|KNPRV
argument_list|(
name|i
argument_list|)
operator|=
name|KNLST
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Second: Get default keys and insert into list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|DTSTR
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|insertbinding
argument_list|(
operator|(
name|kchar
operator|*
operator|)
name|DTSTR
argument_list|(
name|i
argument_list|)
argument_list|,
name|DTSYM
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Third: Get default function keys from database and insert into list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|FTSTR
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|k
operator|=
operator|(
name|kchar
operator|*
operator|)
name|tgetstr
argument_list|(
name|FTSTR
argument_list|(
name|i
argument_list|)
argument_list|,
name|cp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|insertbinding
argument_list|(
name|k
argument_list|,
name|FTSYM
argument_list|(
name|i
argument_list|)
argument_list|,
name|FTNAM
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTSTART
comment|/* Last: Get global or user defined key bindings and insert into list */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bind
argument_list|,
literal|"%s-%s"
argument_list|,
name|UTSTART
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|startup
argument_list|(
name|buf
argument_list|,
name|bind
argument_list|)
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
if|if
condition|(
name|VALID
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
operator|(
name|void
operator|)
name|setbinding
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UTSTART */
block|}
end_block

begin_comment
comment|/* initbindings() */
end_comment

begin_comment
comment|/* Save user defined key bindings */
end_comment

begin_function
name|GLOBL
name|VOID
name|savebindings
parameter_list|(
name|term
parameter_list|)
specifier|register
name|char
modifier|*
name|term
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UTSTART
name|char
name|buf
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|klist
modifier|*
name|kp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|VARVAL
argument_list|(
name|V_AS
argument_list|)
operator|&&
name|klchg
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s-%s"
argument_list|,
name|UTSTART
argument_list|,
name|term
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pathname
argument_list|(
name|buf
argument_list|,
name|home
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|t
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s: ~/.%s-%s, %s"
argument_list|,
name|getversion
argument_list|()
argument_list|,
name|UTSTART
argument_list|,
name|term
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|kp
operator|=
name|kroot
init|;
name|kp
condition|;
name|kp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|kp
argument_list|)
control|)
if|if
condition|(
name|KBUSR
argument_list|(
name|kp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s="
argument_list|,
name|keystring
argument_list|(
operator|(
name|kchar
operator|*
operator|)
name|KBSTR
argument_list|(
name|kp
argument_list|)
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
operator|==
name|K_STR
operator|&&
name|KBINS
argument_list|(
name|kp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\"%s\""
argument_list|,
name|KBINS
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|keysymbol
argument_list|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|KBNAM
argument_list|(
name|kp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t#%s\n"
argument_list|,
name|KBNAM
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* UTSTART */
block|}
end_function

begin_comment
comment|/* savebindings() */
end_comment

begin_comment
comment|/* Show all key bindings */
end_comment

begin_function
name|GLOBL
name|int
name|bindings
parameter_list|()
block|{
name|char
name|buf
index|[
name|INPLEN
index|]
decl_stmt|,
name|key
index|[
name|KEYLEN
index|]
decl_stmt|,
name|com
index|[
name|INPLEN
index|]
decl_stmt|,
name|k
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|klist
modifier|*
name|kp
decl_stmt|;
specifier|register
name|char
modifier|*
name|kb
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|;
name|who
operator|=
literal|"KEY BINDINGS"
expr_stmt|;
comment|/* Key bindings loop */
name|f
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|f
operator|&&
operator|(
operator|(
name|c
operator|=
name|showbindings
argument_list|()
operator|)
operator|<
name|RV_NUL
operator|||
name|c
operator|==
literal|'q'
operator|)
condition|)
break|break;
name|buf
index|[
literal|0
index|]
operator|=
name|com
index|[
literal|0
index|]
operator|=
name|k
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get key sequence terminated with CR */
name|puthelp
argument_list|(
literal|"%s: Enter key to bind (NO EDIT! CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Bind:"
argument_list|)
expr_stmt|;
name|cursorset
argument_list|(
name|CF_VISIBLE
argument_list|)
expr_stmt|;
name|k
index|[
literal|0
index|]
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|k
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|k
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|)
break|break;
elseif|else
if|if
condition|(
name|k
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|k
index|[
literal|0
index|]
operator|=
literal|'\200'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|keystring
argument_list|(
operator|(
name|kchar
operator|*
operator|)
name|k
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Enter key to bind (NO EDIT! CR:terminate string)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Bind: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|k
index|[
literal|0
index|]
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|k
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|k
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|)
break|break;
elseif|else
if|if
condition|(
name|k
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|k
index|[
literal|0
index|]
operator|=
literal|'\200'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|keystring
argument_list|(
operator|(
name|kchar
operator|*
operator|)
name|k
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get utree key to bind to */
for|for
control|(
name|kp
operator|=
name|kroot
init|;
name|kp
condition|;
name|kp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|kp
argument_list|)
control|)
if|if
condition|(
name|EQU
argument_list|(
name|KBSTR
argument_list|(
name|kp
argument_list|)
argument_list|,
name|getkeystring
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|kp
condition|)
block|{
if|if
condition|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
operator|==
name|K_STR
operator|&&
name|KBINS
argument_list|(
name|kp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|key
argument_list|,
literal|"\"%s\""
argument_list|,
name|KBINS
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
name|kb
operator|=
name|key
expr_stmt|;
block|}
else|else
name|kb
operator|=
name|keysymbol
argument_list|(
name|KBSYM
argument_list|(
name|kp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|kb
operator|=
name|NULL
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give utree keyname for binding (CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Bind %s to:"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'k'
argument_list|,
name|kb
argument_list|,
name|KNLST
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
name|RV_NUL
condition|)
break|break;
comment|/* Get additional comment */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|buf
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkeysymbol
argument_list|(
name|key
argument_list|)
operator|!=
name|K_INV
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: Give comment for binding"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Comment for key binding:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|com
argument_list|,
sizeof|sizeof
argument_list|(
name|com
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
if|if
condition|(
name|com
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s #%s"
argument_list|,
name|buf
argument_list|,
name|com
argument_list|)
expr_stmt|;
comment|/* Do the binding */
if|if
condition|(
name|setbinding
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|f
operator|=
literal|1
expr_stmt|;
name|klchg
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|f
operator|=
literal|0
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|errequest
argument_list|(
name|buf
argument_list|,
literal|"Error in setting"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
block|}
name|cursorset
argument_list|(
name|CF_INVISIBLE
argument_list|)
expr_stmt|;
name|treeflag
operator|=
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* bindings() */
end_comment

end_unit

