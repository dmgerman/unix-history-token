begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      LIST.C  *      UTREE directory and file list handling routines.  *      3.01-um klin, Tue Jun  4 14:17:17 1991  *              klin, Tue Oct 15 14:02:37 1991, Handling of symlinks changed  *              klin, Sat Oct 26 15:07:06 1991, Print tree list added  *                                              writedlist() changed  *      3.02-um klin, Fri Nov  1 13:41:58 1991, Minor changes  *              klin, Sun Nov 10 19:37:14 1991, buildlist() changed  *              klin, Sun Nov 24 11:44:49 1991, Some error fixes reported by  *                                              Rolf Gebhardt (RG 11/22/91)  *      3.03-um klin, Sat Feb 15 20:09:09 1992, Minor changes  *            e klin, Sat Apr 11 11:45:01 1992, Bug fix in newflist()  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03e-um (klin) Apr 11 1992 list.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_function_decl
name|EXTRN
name|char
modifier|*
name|readdname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|getversion
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Local/global functions and procedures --------------------------*/
end_comment

begin_comment
comment|/*  *      INTERNAL USED ROUTINES  */
end_comment

begin_comment
comment|/* Compare filenames from flist. Called by qsort() */
end_comment

begin_function
name|LOCAL
name|int
name|flistcmp
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
specifier|register
name|flist
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|sortbytime
condition|)
block|{
if|if
condition|(
name|FPTIM
argument_list|(
name|f1
argument_list|)
operator|<
name|FPTIM
argument_list|(
name|f2
argument_list|)
condition|)
return|return
operator|(
literal|99
operator|)
return|;
elseif|else
if|if
condition|(
name|FPTIM
argument_list|(
name|f1
argument_list|)
operator|>
name|FPTIM
argument_list|(
name|f2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|99
operator|)
return|;
block|}
return|return
operator|(
name|CMP
argument_list|(
name|FPFIL
argument_list|(
name|f1
argument_list|)
argument_list|,
name|FPFIL
argument_list|(
name|f2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* flistcmp() */
end_comment

begin_comment
comment|/* Compare filenames from directory name vector. Called by qsort() */
end_comment

begin_function
name|LOCAL
name|int
name|dlistcmp
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|d1
decl_stmt|,
decl|*
modifier|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|CMP
argument_list|(
operator|*
name|d1
argument_list|,
operator|*
name|d2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* dlistcmp() */
end_comment

begin_comment
comment|/* Count directory level */
end_comment

begin_function
name|LOCAL
name|int
name|countlevl
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
if|if
condition|(
operator|*
name|name
operator|++
operator|==
literal|'/'
condition|)
operator|++
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* countlevl() */
end_comment

begin_comment
comment|/* Align buffer size to avoid too often alloc and free */
end_comment

begin_function
name|LOCAL
name|unsigned
name|alignbsiz
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|unsigned
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|unsigned
name|ns
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
name|n
operator|==
literal|0
condition|)
name|ns
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|ns
operator|=
name|NBUFSZ
init|;
name|ns
operator|<
name|s
condition|;
name|ns
operator|+=
name|NBUFINC
control|)
empty_stmt|;
return|return
operator|(
name|ns
operator|)
return|;
block|}
end_function

begin_comment
comment|/* alignbsiz() */
end_comment

begin_comment
comment|/* Align filevector size to avoid too often alloc and free */
end_comment

begin_function
name|LOCAL
name|int
name|alignnfils
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|nn
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|nn
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|nn
operator|=
name|NFILES
init|;
name|nn
operator|<
name|n
condition|;
name|nn
operator|+=
name|NFILINC
control|)
empty_stmt|;
return|return
operator|(
name|nn
operator|)
return|;
block|}
end_function

begin_comment
comment|/* alignnfils() */
end_comment

begin_comment
comment|/*  *      FILE LIST ROUTINES  */
end_comment

begin_comment
comment|/* Update file f in file list */
end_comment

begin_function
name|LOCAL
name|VOID
name|insertflist
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|char
modifier|*
name|pn
decl_stmt|;
comment|/* Get mode flag for file */
name|pn
operator|=
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|pn
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|STFMT
argument_list|(
operator|&
name|st
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|S_IFLNK
case|:
comment|/* Symbolic link */
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_SLNK
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* S_IFLNK */
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
name|S_IFSOCK
case|:
comment|/* Socket */
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_SOCK
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|S_IFDIR
case|:
comment|/* Directory */
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_DIR
expr_stmt|;
operator|++
name|DNDIR
argument_list|(
name|dp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Executable or other file */
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0111
operator|)
condition|?
name|FF_EXEC
else|:
name|FF_NONE
expr_stmt|;
break|break;
block|}
name|FMTIM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|FSIZE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
else|else
block|{
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_ERR
expr_stmt|;
name|FMTIM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
name|FSIZE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
block|}
name|FITAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* insertflist() */
end_comment

begin_comment
comment|/* Delete an entry from file list */
end_comment

begin_function
name|GLOBL
name|VOID
name|deleteflist
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* Do nothing and return if file list is not yet read in (RG 11/22/91) */
if|if
condition|(
name|DFVEC
argument_list|(
name|dp
argument_list|)
operator|==
name|FNULL
condition|)
return|return;
comment|/* Move up file name, tag and mode flag in file list */
name|n
operator|=
name|f
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|FITAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|&&
name|DNTAG
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|FITAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FITAG
argument_list|(
name|dp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|FMODE
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FMODE
argument_list|(
name|dp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|++
name|f
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
comment|/* Decrement counters */
operator|--
name|DNFIL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|--
name|filecount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* deleteflist() */
end_comment

begin_comment
comment|/* Sort or resort file list from directory dp */
end_comment

begin_function
name|GLOBL
name|VOID
name|sortflist
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|f
operator|=
name|sortbytime
expr_stmt|;
name|sortbytime
operator|=
name|DSORT
argument_list|(
name|dp
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Set flag for comparing */
if|if
condition|(
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
comment|/* Sort/resort file list */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DFVEC
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|DNFIL
argument_list|(
name|dp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|flist
argument_list|)
argument_list|,
name|flistcmp
argument_list|)
expr_stmt|;
name|sortbytime
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sortflist() */
end_comment

begin_comment
comment|/* Zoom file list of directory dp */
end_comment

begin_function
name|GLOBL
name|VOID
name|zoomflist
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|DZOOM
argument_list|(
name|dp
argument_list|)
condition|)
block|{
for|for
control|(
name|f
operator|=
name|n
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|umatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|,
name|DZOOM
argument_list|(
name|dp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|!=
name|f
condition|)
name|FLIST
argument_list|(
name|dp
argument_list|,
name|n
argument_list|)
operator|=
name|FLIST
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* zoomflist() */
end_comment

begin_comment
comment|/* Rebuild file list in some cases (i.e. cp, mv ..) */
end_comment

begin_function
name|GLOBL
name|int
name|newflist
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
block|{
name|char
name|cfnam
index|[
name|NAMELEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|flist
modifier|*
name|fv
decl_stmt|;
specifier|register
name|char
modifier|*
name|fbp
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|fb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nfil
decl_stmt|,
name|ntag
decl_stmt|;
specifier|register
name|unsigned
name|size
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dirfp
decl_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Building %s"
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
comment|/* Set/reset counter */
name|nfil
operator|=
name|DNFIL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ntag
operator|=
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|filecount
operator|-=
name|DNFIL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|=
name|DNDIR
argument_list|(
name|dp
argument_list|)
operator|=
name|DNTAG
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Get status of directory and read in */
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|dirfp
operator|=
name|opendir
argument_list|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Save name of current file */
if|if
condition|(
name|nfil
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cfnam
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|DFCUR
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save flist array and file buffer */
if|if
condition|(
name|ntag
operator|>
literal|0
condition|)
block|{
name|fb
operator|=
name|DFBUF
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|fv
operator|=
name|DFVEC
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Count files */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|readdname
argument_list|(
name|dirfp
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|rewinddir
argument_list|(
name|dirfp
argument_list|)
expr_stmt|;
comment|/* Align file count and buffer size */
name|i
operator|=
name|alignnfils
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|size
operator|=
name|alignbsiz
argument_list|(
operator|(
name|unsigned
operator|)
name|st
operator|.
name|st_size
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Release current file list and file name buffer if needed */
if|if
condition|(
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|&&
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|<
name|size
condition|)
block|{
name|ufree
argument_list|(
name|DFBUF
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DFVEC
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get memory for file list and file name buffer if not yet done */
if|if
condition|(
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|==
name|NULL
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ualloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RG 11/22/91 */
name|DFVEC
argument_list|(
name|dp
argument_list|)
operator|=
operator|(
name|flist
operator|*
operator|)
name|ualloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|flist
argument_list|)
argument_list|)
expr_stmt|;
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|=
name|size
expr_stmt|;
block|}
comment|/* Fill up file list and file name buffer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fbp
operator|=
name|DFBUF
argument_list|(
name|dp
argument_list|)
init|;
name|name
operator|=
name|readdname
argument_list|(
name|dirfp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
operator|=
name|strcpy
argument_list|(
name|fbp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fbp
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|insertflist
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirfp
argument_list|)
expr_stmt|;
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|=
name|i
expr_stmt|;
name|sortflist
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DZOOM
argument_list|(
name|dp
argument_list|)
condition|)
name|zoomflist
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* Set up other directory data */
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_FIL
expr_stmt|;
name|DMTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|DCTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|st
operator|.
name|st_ctime
expr_stmt|;
name|DCANC
argument_list|(
name|dp
argument_list|)
operator|=
name|CANCD
argument_list|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to restore current file */
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|=
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nfil
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cfnam
index|[
literal|0
index|]
operator|!=
operator|*
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
operator|||
name|CMP
argument_list|(
name|cfnam
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gofile
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|i
operator|>=
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|)
while|while
condition|(
name|gofile
argument_list|(
name|dp
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
empty_stmt|;
comment|/* Try to restore tagged files */
if|if
condition|(
name|ntag
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nfil
condition|)
block|{
if|if
condition|(
name|FVTAG
argument_list|(
name|fv
argument_list|,
name|i
argument_list|)
operator|==
name|FF_TAG
condition|)
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|*
name|FVFIL
argument_list|(
name|fv
argument_list|,
name|i
argument_list|)
operator|==
operator|*
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|k
argument_list|)
operator|&&
name|EQU
argument_list|(
name|FVFIL
argument_list|(
name|fv
argument_list|,
name|i
argument_list|)
argument_list|,
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|k
argument_list|)
argument_list|)
condition|)
block|{
name|FITAG
argument_list|(
name|dp
argument_list|,
name|k
argument_list|)
operator|=
name|FF_TAG
expr_stmt|;
operator|++
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
name|filecount
operator|+=
name|DNFIL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* Error in stat: use defaults */
else|else
block|{
name|ufree
argument_list|(
name|DFBUF
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DFVEC
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DFVEC
argument_list|(
name|dp
argument_list|)
operator|=
name|FNULL
expr_stmt|;
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_FIL
expr_stmt|;
name|DMTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|DCTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|st
operator|.
name|st_ctime
expr_stmt|;
name|DCANC
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|=
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
if|if
condition|(
name|VARSET
argument_list|(
name|V_WD
argument_list|)
condition|)
block|{
name|puthelp
argument_list|(
literal|"BUILD %s (Y:exit  ELSE:continue)"
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Cannot read directory. Exit ?"
argument_list|)
operator|==
literal|'y'
condition|)
return|return
operator|(
name|RV_END
operator|)
return|;
block|}
block|}
comment|/* Release saved flist array and file buffer */
if|if
condition|(
name|ntag
operator|>
literal|0
condition|)
block|{
name|ufree
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fv
argument_list|)
expr_stmt|;
block|}
comment|/* Set screen flags */
name|treeflag
operator||=
name|SF_ECHO
expr_stmt|;
name|fileflag
operator||=
name|SF_ECHO
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* newflist() */
end_comment

begin_comment
comment|/*  *      DIRECTORY LIST ROUTINES  */
end_comment

begin_comment
comment|/* Build and set tree info flag */
end_comment

begin_function
name|GLOBL
name|VOID
name|infodlist
parameter_list|()
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* For each dir in tree check if there are dirs on the same level */
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
name|DINFO
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|np
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
init|;
name|np
operator|&&
name|DLEVL
argument_list|(
name|np
argument_list|)
operator|>
operator|(
name|i
operator|+
literal|1
operator|)
condition|;
name|np
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|np
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|np
operator|&&
name|DLEVL
argument_list|(
name|np
argument_list|)
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
name|DINFO
argument_list|(
name|dp
argument_list|)
operator||=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
for|for
control|(
name|np
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
init|;
name|np
operator|&&
name|DLEVL
argument_list|(
name|np
argument_list|)
operator|>
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|;
name|np
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|np
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|np
operator|&&
name|DLEVL
argument_list|(
name|np
argument_list|)
operator|==
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|)
name|DINFO
argument_list|(
name|dp
argument_list|)
operator||=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* infodlist() */
end_comment

begin_comment
comment|/* Insert directory dname into directory tree list */
end_comment

begin_function
name|LOCAL
name|dlist
modifier|*
name|insertdlist
parameter_list|(
name|dname
parameter_list|,
name|nfils
parameter_list|,
name|fvec
parameter_list|)
specifier|register
name|char
modifier|*
name|dname
decl_stmt|;
specifier|register
name|int
name|nfils
decl_stmt|;
specifier|register
name|flist
modifier|*
name|fvec
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
comment|/* Get memory and save directory name */
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|ualloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dlist
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
name|strsav
argument_list|(
name|pathname
argument_list|(
name|dname
argument_list|,
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up pathname/filename and file list */
name|DPNAM
argument_list|(
name|dp
argument_list|)
operator|=
name|np
expr_stmt|;
name|DFNAM
argument_list|(
name|dp
argument_list|)
operator|=
name|basename
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|DZOOM
argument_list|(
name|dp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DNFIL
argument_list|(
name|dp
argument_list|)
operator|=
name|nfils
expr_stmt|;
name|DFVEC
argument_list|(
name|dp
argument_list|)
operator|=
name|fvec
expr_stmt|;
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|=
name|GNULL
expr_stmt|;
name|DFCUR
argument_list|(
name|dp
argument_list|)
operator|=
name|DFTOP
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DNTAG
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* For each file in file list create an entry */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|nfils
condition|;
name|f
operator|++
control|)
name|insertflist
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Insert dlist into tree list */
if|if
condition|(
name|droot
operator|==
name|DNULL
condition|)
block|{
name|DPREV
argument_list|(
name|dp
argument_list|)
operator|=
name|GNULL
expr_stmt|;
name|droot
operator|=
name|dp
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|rp
operator|=
name|droot
init|;
name|DNEXT
argument_list|(
name|rp
argument_list|)
condition|;
name|rp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|rp
argument_list|)
control|)
empty_stmt|;
name|DNEXT
argument_list|(
name|rp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|dp
expr_stmt|;
name|DPREV
argument_list|(
name|dp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|rp
expr_stmt|;
block|}
comment|/* Increment directory and file counters */
operator|++
name|dircount
expr_stmt|;
name|filecount
operator|+=
name|nfils
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* insertdlist() */
end_comment

begin_comment
comment|/* Rebuild directory list after creating a new directory */
end_comment

begin_function
name|GLOBL
name|dlist
modifier|*
name|newdlist
parameter_list|(
name|name
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|levl
decl_stmt|;
comment|/* Allocate memory for new dlist entry and for pathname */
name|ndp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|ualloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dlist
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
name|strsav
argument_list|(
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert dlist into directory tree */
name|levl
operator|=
name|CLEVL
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|pdp
operator|=
name|cdlist
operator|,
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>=
name|levl
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|==
name|levl
operator|&&
name|CMP
argument_list|(
name|np
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|pdp
operator|=
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|DNEXT
argument_list|(
name|ndp
argument_list|)
operator|=
name|DNEXT
argument_list|(
name|pdp
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|DPREV
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|ndp
expr_stmt|;
block|}
name|DNEXT
argument_list|(
name|pdp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|ndp
expr_stmt|;
name|DPREV
argument_list|(
name|ndp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|pdp
expr_stmt|;
comment|/* Fill up dlist record data */
name|DPNAM
argument_list|(
name|ndp
argument_list|)
operator|=
name|np
expr_stmt|;
name|DFNAM
argument_list|(
name|ndp
argument_list|)
operator|=
name|basename
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|DZOOM
argument_list|(
name|ndp
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|np
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* Bad stat: use defaults */
name|DMTIM
argument_list|(
name|ndp
argument_list|)
operator|=
name|DCTIM
argument_list|(
name|ndp
argument_list|)
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
name|DFLAG
argument_list|(
name|ndp
argument_list|)
operator|=
name|FL_FIL
expr_stmt|;
name|DCANC
argument_list|(
name|ndp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DMTIM
argument_list|(
name|ndp
argument_list|)
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|DCTIM
argument_list|(
name|ndp
argument_list|)
operator|=
name|st
operator|.
name|st_ctime
expr_stmt|;
name|DFLAG
argument_list|(
name|ndp
argument_list|)
operator|=
name|flag
expr_stmt|;
name|DCANC
argument_list|(
name|ndp
argument_list|)
operator|=
name|CANCD
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|DSORT
argument_list|(
name|ndp
argument_list|)
operator|=
name|sortbytime
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|DFBUF
argument_list|(
name|ndp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DFVEC
argument_list|(
name|ndp
argument_list|)
operator|=
name|FNULL
expr_stmt|;
name|DBSIZ
argument_list|(
name|ndp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DLEVL
argument_list|(
name|ndp
argument_list|)
operator|=
name|levl
expr_stmt|;
if|if
condition|(
name|DLEVL
argument_list|(
name|ndp
argument_list|)
operator|>
name|maxlevel
condition|)
name|maxlevel
operator|=
name|DLEVL
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|DNFIL
argument_list|(
name|ndp
argument_list|)
operator|=
name|DNDIR
argument_list|(
name|ndp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DDNUM
argument_list|(
name|ndp
argument_list|)
operator|=
name|DDNUM
argument_list|(
name|pdp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DFCUR
argument_list|(
name|ndp
argument_list|)
operator|=
name|DFTOP
argument_list|(
name|ndp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DNTAG
argument_list|(
name|ndp
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Increment all following dlist entry numbers */
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|ndp
argument_list|)
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
operator|++
name|DDNUM
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* Update counter, flags and return */
operator|++
name|CNDIR
expr_stmt|;
operator|++
name|dircount
expr_stmt|;
name|writeflag
operator|=
literal|1
expr_stmt|;
name|checkindent
argument_list|()
expr_stmt|;
name|infodlist
argument_list|()
expr_stmt|;
return|return
operator|(
name|ndp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* newdlist() */
end_comment

begin_comment
comment|/* Delete current entry from directory list */
end_comment

begin_function
name|GLOBL
name|VOID
name|deletedlist
parameter_list|(
name|rp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|rp
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
comment|/* Search for parent directory of directory list entry dp */
for|for
control|(
name|dp
operator|=
name|rp
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>=
name|DLEVL
argument_list|(
name|rp
argument_list|)
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
comment|/* If found destroy file list entry in parent directory */
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
name|DFVEC
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* RG 11/22/91 */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|EQU
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|DFNAM
argument_list|(
name|rp
argument_list|)
argument_list|)
condition|)
break|break;
name|deleteflist
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
operator|--
name|DNDIR
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* Close the directory tree list chain */
if|if
condition|(
name|DNEXT
argument_list|(
name|rp
argument_list|)
condition|)
block|{
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|rp
argument_list|)
init|;
name|DNEXT
argument_list|(
name|dp
argument_list|)
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
while|while
condition|(
name|dp
operator|!=
name|rp
condition|)
block|{
name|p
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|=
name|DDNUM
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|DPREV
argument_list|(
name|p
argument_list|)
operator|=
name|DPREV
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|rp
argument_list|)
condition|)
name|DNEXT
argument_list|(
name|p
argument_list|)
operator|=
name|DNEXT
argument_list|(
name|rp
argument_list|)
expr_stmt|;
comment|/* Release memory */
name|ufree
argument_list|(
name|DPNAM
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
name|DFBUF
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DFVEC
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DZOOM
argument_list|(
name|rp
argument_list|)
condition|)
name|ufree
argument_list|(
name|DZOOM
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
comment|/* Decrement directory counter and update tree info flag */
operator|--
name|dircount
expr_stmt|;
name|infodlist
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* deletedlist() */
end_comment

begin_comment
comment|/* Write out directory list dependent on w to file name */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|writedlist
parameter_list|(
name|name
parameter_list|,
name|rp
parameter_list|,
name|what
parameter_list|,
name|w
parameter_list|)
specifier|register
name|dlist
modifier|*
name|rp
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|list
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|long
name|info
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|i
decl_stmt|,
name|levl
decl_stmt|;
name|time_t
name|t
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|list
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|list
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|t
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|'m'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s: file list (matching %s)"
argument_list|,
name|getversion
argument_list|()
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s: %s list"
argument_list|,
name|getversion
argument_list|()
argument_list|,
name|what
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|", %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|rp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|==
literal|'d'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|==
literal|'l'
condition|)
block|{
name|p
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|f
operator|=
name|p
operator|&&
name|DLEVL
argument_list|(
name|p
argument_list|)
operator|>
name|DLEVL
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|rp
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"R%s\n"
argument_list|,
name|DPNAM
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%cH%s\n"
argument_list|,
name|f
condition|?
literal|'U'
else|:
literal|'H'
argument_list|,
name|DFNAM
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|levl
operator|=
name|DLEVL
argument_list|(
name|rp
argument_list|)
operator|-
literal|1
expr_stmt|;
name|info
operator|=
name|DINFO
argument_list|(
name|dp
argument_list|)
operator|>>
name|levl
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|f
condition|?
literal|'V'
else|:
literal|'L'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|-
name|levl
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"I%c"
argument_list|,
name|info
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|?
literal|'V'
else|:
literal|'S'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"I%cH%s\n"
argument_list|,
name|info
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|?
literal|'T'
else|:
literal|'L'
argument_list|,
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|'m'
case|:
if|if
condition|(
name|umatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|,
name|what
argument_list|)
condition|)
goto|goto
name|WRITEFILE
goto|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|ISTAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
condition|)
break|break;
comment|/*Fall thru*/
case|case
literal|'f'
case|:
name|WRITEFILE
label|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|DLEVL
argument_list|(
name|rp
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/* writedlist() */
end_comment

begin_comment
comment|/* Check directory list after file changes in directory name */
end_comment

begin_function
name|GLOBL
name|VOID
name|checkdlist
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|fname
index|[
name|NAMELEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|ISDIR
argument_list|(
name|name
argument_list|,
name|st
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|fname
expr_stmt|;
if|if
condition|(
name|sp
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
comment|/* Bad stat: do nothing */
return|return;
block|}
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|EQU
argument_list|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
name|name
argument_list|)
operator|&&
name|CHKTIM
argument_list|(
name|dp
argument_list|,
name|st
argument_list|)
condition|)
block|{
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_CHG
expr_stmt|;
operator|++
name|buildflag
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* checkdlist() */
end_comment

begin_comment
comment|/* Scan directory tree for changes in filesystem */
end_comment

begin_function
name|GLOBL
name|int
name|scandlist
parameter_list|(
name|rp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|rp
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|rp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|RV_INT
operator|)
return|;
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|==
name|FL_FIL
operator|&&
name|changedlist
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_CHG
expr_stmt|;
operator|++
name|buildflag
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|DLEVL
argument_list|(
name|rp
argument_list|)
condition|)
do|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scandlist() */
end_comment

begin_comment
comment|/* Check if status of a directory has changed */
end_comment

begin_function
name|GLOBL
name|int
name|changedlist
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
return|return
operator|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|CHKTIM
argument_list|(
name|dp
argument_list|,
name|st
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* changedlist() */
end_comment

begin_comment
comment|/* Update directory list after changes in filesystem tree */
end_comment

begin_function
name|GLOBL
name|int
name|updatedlist
parameter_list|()
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|==
name|FL_CHG
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
break|break;
if|if
condition|(
name|dp
operator|==
name|cdlist
condition|)
name|fileflag
operator||=
name|SF_TREE
expr_stmt|;
block|}
block|}
name|buildflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* updatedlist() */
end_comment

begin_comment
comment|/*  *      BUILD UP DIRECTORY TREE  */
end_comment

begin_comment
comment|/* Build up directory tree and file lists recursively. Work is done hard. */
end_comment

begin_comment
comment|/* For each directory starting with directory pn up to level last a       */
end_comment

begin_comment
comment|/* dlist entry is allocated, the dlist record is filled with all needed   */
end_comment

begin_comment
comment|/* directory data, the directory file list and the file name buffer, and  */
end_comment

begin_comment
comment|/* then inserted into the directory tree list.                            */
end_comment

begin_function
name|GLOBL
name|int
name|buildread
parameter_list|(
name|pn
parameter_list|,
name|levl
parameter_list|,
name|last
parameter_list|,
name|intr
parameter_list|)
specifier|register
name|char
modifier|*
name|pn
decl_stmt|;
specifier|register
name|int
name|levl
decl_stmt|,
name|last
decl_stmt|,
name|intr
decl_stmt|;
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|static
name|int
name|dnum
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|dst
decl_stmt|,
name|fst
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|fp
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|flist
modifier|*
name|fvec
decl_stmt|;
specifier|register
name|char
modifier|*
name|fbuf
decl_stmt|,
modifier|*
name|fbufp
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|dvec
decl_stmt|;
specifier|register
name|int
name|nfils
decl_stmt|,
name|ndirs
decl_stmt|,
name|flag
decl_stmt|,
name|i
decl_stmt|,
name|rv
decl_stmt|;
specifier|register
name|unsigned
name|bsiz
decl_stmt|;
comment|/* Is pn a directory? */
if|if
condition|(
operator|!
name|ISDIR
argument_list|(
name|pn
argument_list|,
name|dst
argument_list|)
condition|)
return|return
operator|(
name|RV_ERR
operator|)
return|;
comment|/* Check for keyboard interrupt if interrupt is allowed */
if|if
condition|(
name|intr
operator|&&
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|RV_INT
operator|)
return|;
comment|/* Init variables */
name|ndirs
operator|=
name|nfils
operator|=
literal|0
expr_stmt|;
name|fvec
operator|=
name|FNULL
expr_stmt|;
name|fbuf
operator|=
name|NULL
expr_stmt|;
name|bsiz
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
name|FL_NUL
expr_stmt|;
comment|/* Read in directory and build dlist entry */
if|if
condition|(
name|levl
operator|<
name|last
operator|&&
operator|(
name|fp
operator|=
name|opendir
argument_list|(
name|pn
argument_list|)
operator|)
condition|)
block|{
comment|/* Count files */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|readdname
argument_list|(
name|fp
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|rewinddir
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Reading %s (%d files)"
argument_list|,
name|pn
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
comment|/* Align nfils and bsiz to avoid too often alloc and free */
name|i
operator|=
name|alignnfils
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bsiz
operator|=
name|alignbsiz
argument_list|(
operator|(
name|unsigned
operator|)
name|dst
operator|.
name|st_size
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* Get memory for file buffer, file list and directory array */
name|fbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|ualloc
argument_list|(
name|bsiz
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|fvec
operator|=
operator|(
name|flist
operator|*
operator|)
name|ualloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|flist
argument_list|)
argument_list|)
expr_stmt|;
name|dvec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ualloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fbuf
operator|=
name|NULL
expr_stmt|;
name|fvec
operator|=
name|FNULL
expr_stmt|;
block|}
comment|/* Read in directory, fill up file list and directory array */
for|for
control|(
name|nfils
operator|=
literal|0
operator|,
name|fbufp
operator|=
name|fbuf
init|;
name|fn
operator|=
name|readdname
argument_list|(
name|fp
argument_list|)
condition|;
name|nfils
operator|++
control|)
block|{
name|FVFIL
argument_list|(
name|fvec
argument_list|,
name|nfils
argument_list|)
operator|=
name|strcpy
argument_list|(
name|fbufp
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|fbufp
operator|+=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|fn
argument_list|,
name|pn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|name
argument_list|,
operator|&
name|fst
argument_list|)
condition|)
block|{
name|FVTIM
argument_list|(
name|fvec
argument_list|,
name|nfils
argument_list|)
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
name|FVSIZ
argument_list|(
name|fvec
argument_list|,
name|nfils
argument_list|)
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|FVTIM
argument_list|(
name|fvec
argument_list|,
name|nfils
argument_list|)
operator|=
name|fst
operator|.
name|st_mtime
expr_stmt|;
name|FVSIZ
argument_list|(
name|fvec
argument_list|,
name|nfils
argument_list|)
operator|=
name|fst
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|STFMT
argument_list|(
operator|&
name|fst
argument_list|)
operator|==
name|S_IFDIR
operator|&&
operator|(
name|hiddendirs
operator|||
operator|*
name|fn
operator|!=
literal|'.'
operator|)
condition|)
name|dvec
index|[
name|ndirs
operator|++
index|]
operator|=
name|FVFIL
argument_list|(
name|fvec
argument_list|,
name|nfils
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Sort file list and directory array */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fvec
argument_list|,
operator|(
name|unsigned
operator|)
name|nfils
argument_list|,
sizeof|sizeof
argument_list|(
name|flist
argument_list|)
argument_list|,
name|flistcmp
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dvec
argument_list|,
operator|(
name|unsigned
operator|)
name|ndirs
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|dlistcmp
argument_list|)
expr_stmt|;
name|flag
operator|=
name|FL_FIL
expr_stmt|;
block|}
comment|/* Insert dlist into tree list and set up dlist record */
name|dp
operator|=
name|insertdlist
argument_list|(
name|pn
argument_list|,
name|nfils
argument_list|,
name|fvec
argument_list|)
expr_stmt|;
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|=
name|fbuf
expr_stmt|;
name|DFVEC
argument_list|(
name|dp
argument_list|)
operator|=
name|fvec
expr_stmt|;
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|=
name|bsiz
expr_stmt|;
name|DCANC
argument_list|(
name|dp
argument_list|)
operator|=
name|CANCD
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|DMTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|dst
operator|.
name|st_mtime
expr_stmt|;
name|DCTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|dst
operator|.
name|st_ctime
expr_stmt|;
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|flag
expr_stmt|;
name|DSORT
argument_list|(
name|dp
argument_list|)
operator|=
name|sortbytime
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|=
name|levl
expr_stmt|;
if|if
condition|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|maxlevel
condition|)
name|maxlevel
operator|=
name|DLEVL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DNDIR
argument_list|(
name|dp
argument_list|)
operator|=
name|ndirs
expr_stmt|;
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|=
name|dnum
operator|++
expr_stmt|;
if|if
condition|(
name|nfils
operator|>
literal|0
condition|)
block|{
comment|/* Build a dlist entry for each directory found in directory list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndirs
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|dvec
index|[
name|i
index|]
argument_list|,
name|pn
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|levl
expr_stmt|;
name|rv
operator|=
name|buildread
argument_list|(
name|name
argument_list|,
name|levl
argument_list|,
name|last
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|--
name|levl
expr_stmt|;
if|if
condition|(
name|intr
operator|&&
name|rv
operator|==
name|RV_INT
condition|)
break|break;
block|}
comment|/* Release directory array */
name|ufree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dvec
argument_list|)
expr_stmt|;
block|}
comment|/* Set up tree info flag and return */
name|infodlist
argument_list|()
expr_stmt|;
return|return
operator|(
name|intr
operator|&&
name|rv
operator|==
name|RV_INT
condition|?
name|RV_INT
else|:
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* buildread() */
end_comment

begin_comment
comment|/* Build up directory tree from tree list. File lists are built up later.  */
end_comment

begin_comment
comment|/* For each directory starting with directory rn read in from tree list    */
end_comment

begin_comment
comment|/* file lfn a dlist entry is allocated, the dlist record is filled with    */
end_comment

begin_comment
comment|/* all needed directory data and inserted into the directory tree list.    */
end_comment

begin_comment
comment|/* File list and file name buffer are initially unset and filled up later. */
end_comment

begin_function
name|GLOBL
name|int
name|buildlist
parameter_list|(
name|rn
parameter_list|,
name|cwd
parameter_list|,
name|lfn
parameter_list|)
specifier|register
name|char
modifier|*
name|rn
decl_stmt|,
decl|*
name|cwd
decl_stmt|,
modifier|*
name|lfn
decl_stmt|;
end_function

begin_block
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|pn
decl_stmt|;
specifier|register
name|int
name|dlen
decl_stmt|,
name|dlev
decl_stmt|,
name|dnum
decl_stmt|,
name|i
decl_stmt|;
comment|/* Init variables */
name|dlen
operator|=
name|strlen
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|dlev
operator|=
name|countlevl
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|dnum
operator|=
literal|0
expr_stmt|;
comment|/* Read in list file fn */
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|lfn
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Building tree from list %s ... "
argument_list|,
name|lfn
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|VALID
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pn
operator|=
name|pathname
argument_list|(
name|name
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
comment|/* Skip bad entries in tree list */
if|if
condition|(
name|strncmp
argument_list|(
name|rn
argument_list|,
name|pn
argument_list|,
name|dlen
argument_list|)
operator|||
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|pn
argument_list|,
operator|&
name|st
argument_list|)
operator|||
name|STFMT
argument_list|(
operator|&
name|st
argument_list|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|writeflag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Skip hidden directories if flag is not set */
if|if
condition|(
operator|!
name|hiddendirs
operator|&&
operator|*
operator|(
name|basename
argument_list|(
name|pn
argument_list|)
operator|)
operator|==
literal|'.'
condition|)
continue|continue;
comment|/* Insert into tree list and file up record with directory   */
comment|/* data. File list and file name buffer are initially unset. */
name|dp
operator|=
name|insertdlist
argument_list|(
name|pn
argument_list|,
literal|0
argument_list|,
name|FNULL
argument_list|)
expr_stmt|;
name|DFBUF
argument_list|(
name|dp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DFVEC
argument_list|(
name|dp
argument_list|)
operator|=
name|FNULL
expr_stmt|;
name|DBSIZ
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CANCD
argument_list|(
name|pn
argument_list|)
condition|)
block|{
name|DCANC
argument_list|(
name|dp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DMTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|DCTIM
argument_list|(
name|dp
argument_list|)
operator|=
name|st
operator|.
name|st_ctime
expr_stmt|;
block|}
else|else
block|{
name|DCANC
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DMTIM
argument_list|(
name|dp
argument_list|)
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
name|DCTIM
argument_list|(
name|dp
argument_list|)
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_NUL
expr_stmt|;
name|DSORT
argument_list|(
name|dp
argument_list|)
operator|=
name|sortbytime
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|=
name|countlevl
argument_list|(
name|pn
argument_list|)
operator|-
name|dlev
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|maxlevel
condition|)
name|maxlevel
operator|=
name|DLEVL
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DNDIR
argument_list|(
name|dp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|=
name|dnum
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Set up tree info flag and return */
if|if
condition|(
name|dnum
condition|)
block|{
name|infodlist
argument_list|()
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
end_block

begin_comment
comment|/* buildlist() */
end_comment

end_unit

