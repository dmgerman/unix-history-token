begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tr -- a filter to translate characters    Copyright (C) 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Jim Meyering. */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isgraph
end_ifndef

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|c
parameter_list|)
value|(isprint (c)&& !isspace (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|LONG_MAX
value|0x7FFFFFFF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|0xFF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|N_CHARS
value|(UCHAR_MAX + 1)
end_define

begin_comment
comment|/* A pointer to a function that returns an int. */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|PFI
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_comment
comment|/* Convert from character C to its index in the collating    sequence array.  Just cast to an unsigned int to avoid    problems with sign-extension. */
end_comment

begin_define
define|#
directive|define
name|ORD
parameter_list|(
name|c
parameter_list|)
value|(unsigned int)(c)
end_define

begin_comment
comment|/* The inverse of ORD. */
end_comment

begin_define
define|#
directive|define
name|CHR
parameter_list|(
name|i
parameter_list|)
value|(unsigned char)(i)
end_define

begin_comment
comment|/* The value for Spec_list->state that indicates to    get_next that it should initialize the tail pointer.    Its value doesn't matter as long as it can't be    confused with a valid character code. */
end_comment

begin_define
define|#
directive|define
name|BEGIN_STATE
value|(2 * N_CHARS)
end_define

begin_comment
comment|/* The value for Spec_list->state that indicates to    get_next that the element pointed to by Spec_list->tail is    being considered for the first time on this pass through the    list -- it indicates that get_next should make any necessary    initializations. */
end_comment

begin_define
define|#
directive|define
name|NEW_ELEMENT
value|(BEGIN_STATE + 1)
end_define

begin_comment
comment|/* A value distinct from any character that may have been stored in a    buffer as the result of a block-read in the function squeeze_filter. */
end_comment

begin_define
define|#
directive|define
name|NOT_A_CHAR
value|(unsigned int)(-1)
end_define

begin_comment
comment|/* The following (but not CC_NO_CLASS) are indices into the array of    valid character class strings. */
end_comment

begin_enum
enum|enum
name|Char_class
block|{
name|CC_ALNUM
init|=
literal|0
block|,
name|CC_ALPHA
init|=
literal|1
block|,
name|CC_BLANK
init|=
literal|2
block|,
name|CC_CNTRL
init|=
literal|3
block|,
name|CC_DIGIT
init|=
literal|4
block|,
name|CC_GRAPH
init|=
literal|5
block|,
name|CC_LOWER
init|=
literal|6
block|,
name|CC_PRINT
init|=
literal|7
block|,
name|CC_PUNCT
init|=
literal|8
block|,
name|CC_SPACE
init|=
literal|9
block|,
name|CC_UPPER
init|=
literal|10
block|,
name|CC_XDIGIT
init|=
literal|11
block|,
name|CC_NO_CLASS
init|=
literal|9999
block|}
enum|;
end_enum

begin_comment
comment|/* Character class to which a character (returned by get_next) belonged;    but it is set only if the construct from which the character was obtained    was one of the character classes [:upper:] or [:lower:].  The value    is used only when translating and then, only to make sure that upper    and lower class constructs have the same relative positions in string1    and string2. */
end_comment

begin_enum
enum|enum
name|Upper_Lower_class
block|{
name|UL_LOWER
init|=
literal|0
block|,
name|UL_UPPER
init|=
literal|1
block|,
name|UL_NONE
init|=
literal|2
block|}
enum|;
end_enum

begin_comment
comment|/* A shortcut to ensure that when constructing the translation array,    one of the values returned by paired calls to get_next (from s1 and s2) is    from [:upper:] and the other is from [:lower:], or neither is    from upper or lower.  In fact, no other character classes are allowed    when translating, but that condition is tested elsewhere.  This array    is indexed by values of type enum Upper_Lower_class. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|class_ok
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The type of a List_element.  See build_spec_list for more details. */
end_comment

begin_enum
enum|enum
name|Range_element_type
block|{
name|RE_NO_TYPE
init|=
literal|0
block|,
name|RE_NORMAL_CHAR
block|,
name|RE_RANGE
block|,
name|RE_CHAR_CLASS
block|,
name|RE_EQUIV_CLASS
block|,
name|RE_REPEATED_CHAR
block|}
enum|;
end_enum

begin_comment
comment|/* One construct in one of tr's argument strings.    For example, consider the POSIX version of the    classic tr command:        tr -cs 'a-zA-Z_' '[\n*]'    String1 has 3 constructs, two of which are ranges (a-z and A-Z),    and a single normal character, `_'.  String2 has one construct. */
end_comment

begin_struct
struct|struct
name|List_element
block|{
name|enum
name|Range_element_type
name|type
decl_stmt|;
name|struct
name|List_element
modifier|*
name|next
decl_stmt|;
union|union
block|{
name|int
name|normal_char
decl_stmt|;
struct|struct
comment|/* unnamed */
block|{
name|unsigned
name|int
name|first_char
decl_stmt|;
name|unsigned
name|int
name|last_char
decl_stmt|;
block|}
name|range
struct|;
name|enum
name|Char_class
name|char_class
decl_stmt|;
name|int
name|equiv_code
decl_stmt|;
struct|struct
comment|/* unnamed */
block|{
name|unsigned
name|int
name|the_repeated_char
decl_stmt|;
name|long
name|repeat_count
decl_stmt|;
block|}
name|repeated_char
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Each of tr's argument strings is parsed into a form that is easier    to work with: a linked list of constructs (struct List_element).    Each Spec_list structure also encapsulates various attributes of    the corresponding argument string.  The attributes are used mainly    to verify that the strings are legal in the context of any options    specified (like -s, -d, or -c).  The main exception is the member    `tail', which is first used to construct the list.  After construction,    it is used by get_next to save its state when traversing the list.    The member `state' serves a similar function. */
end_comment

begin_struct
struct|struct
name|Spec_list
block|{
comment|/* Points to the head of the list of range elements.      The first struct is a dummy; its members are never used. */
name|struct
name|List_element
modifier|*
name|head
decl_stmt|;
comment|/* When appending, points to the last element.  When traversing via      get_next(), points to the element to process next.  Setting      Spec_list.state to the value BEGIN_STATE before calling get_next      signals get_next to initialize tail to point to head->next. */
name|struct
name|List_element
modifier|*
name|tail
decl_stmt|;
comment|/* Used to save state between calls to get_next(). */
name|unsigned
name|int
name|state
decl_stmt|;
comment|/* Length, in the sense that length('a-z[:digit:]123abc')      is 42 ( = 26 + 10 + 6). */
name|int
name|length
decl_stmt|;
comment|/* The number of [c*] and [c*0] constructs that appear in this spec. */
name|int
name|n_indefinite_repeats
decl_stmt|;
comment|/* Non-zero if this spec contains at least one equivalence      class construct e.g. [=c=]. */
name|int
name|has_equiv_class
decl_stmt|;
comment|/* Non-zero if this spec contains at least one of [:upper:] or      [:lower:] class constructs. */
name|int
name|has_upper_or_lower
decl_stmt|;
comment|/* Non-zero if this spec contains at least one of the character class      constructs (all but upper and lower) that aren't allowed in s2. */
name|int
name|has_restricted_char_class
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|stpcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name by which this program was run. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero, each sequence in the input of a repeated character    (call it c) is replaced (in the output) by a single occurrence of c    for every c in the squeeze set. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|squeeze_repeats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero, removes characters in the delete set from input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use the complement of set1 in place of set1. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|complement
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero, this flag causes GNU tr to provide strict    compliance with POSIX draft 1003.2.11.2.  The POSIX spec    says that when -d is used without -s, string2 (if present)    must be ignored.  Silently ignoring arguments is a bad idea.    The default GNU behavior is to give a usage message and exit.    Additionally, when this flag is non-zero, tr prints warnings    on stderr if it is being used in a manner that is not portable.    Applicable warnings are given by default, but are suppressed    if the environment variable `POSIXLY_CORRECT' is set, since    being POSIX conformant means we can't issue such messages.    Warnings on the following topics are suppressed when this    variable is non-zero:    1. Ambiguous octal escapes. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|posix_pedantic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When tr is performing translation and string1 is longer than string2,    POSIX says that the result is undefined.  That gives the implementor    of a POSIX conforming version of tr two reasonable choices for the    semantics of this case.     * The BSD tr pads string2 to the length of string1 by    repeating the last character in string2.     * System V tr ignores characters in string1 that have no    corresponding character in string2.  That is, string1 is effectively    truncated to the length of string2.     When non-zero, this flag causes GNU tr to imitate the behavior    of System V tr when translating with string1 longer than string2.    The default is to emulate BSD tr.  This flag is ignored in modes where    no translation is performed.  Emulating the System V tr    in this exceptional case causes the relatively common BSD idiom:         tr -cs A-Za-z0-9 '\012'     to break (it would convert only zero bytes, rather than all    non-alphanumerics, to newlines).     WARNING: This switch does not provide general BSD or System V    compatibility.  For example, it doesn't disable the interpretation    of the POSIX constructs [:alpha:], [=c=], and [c*10], so if by    some unfortunate coincidence you use such constructs in scripts    expecting to use some other version of tr, the scripts will break. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|truncate_set1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An alias for (!delete&& non_option_args == 2).    It is set in main and used there and in validate(). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|translating
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BUFSIZ
end_ifndef

begin_define
define|#
directive|define
name|BUFSIZ
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IO_BUF_SIZE
value|BUFSIZ
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|io_buf
index|[
name|IO_BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|char_class_name
index|[]
init|=
block|{
literal|"alnum"
block|,
literal|"alpha"
block|,
literal|"blank"
block|,
literal|"cntrl"
block|,
literal|"digit"
block|,
literal|"graph"
block|,
literal|"lower"
block|,
literal|"print"
block|,
literal|"punct"
block|,
literal|"space"
block|,
literal|"upper"
block|,
literal|"xdigit"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_CHAR_CLASSES
value|(sizeof(char_class_name) / sizeof(char_class_name[0]))
end_define

begin_typedef
typedef|typedef
name|char
name|SET_TYPE
typedef|;
end_typedef

begin_comment
comment|/* Array of boolean values.  A character `c' is a member of the    squeeze set if and only if in_squeeze_set[c] is true.  The squeeze    set is defined by the last (possibly, the only) string argument    on the command line when the squeeze option is given.  */
end_comment

begin_decl_stmt
specifier|static
name|SET_TYPE
name|in_squeeze_set
index|[
name|N_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of boolean values.  A character `c' is a member of the    delete set if and only if in_delete_set[c] is true.  The delete    set is defined by the first (or only) string argument on the    command line when the delete option is given.  */
end_comment

begin_decl_stmt
specifier|static
name|SET_TYPE
name|in_delete_set
index|[
name|N_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of character values defining the translation (if any) that    tr is to perform.  Translation is performed only when there are    two specification strings and the delete switch is not given. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|xlate
index|[
name|N_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"complement"
block|,
literal|0
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"delete"
block|,
literal|0
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"squeeze-repeats"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"truncate-set1"
block|,
literal|0
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-cdst] [--complement] [--delete] [--squeeze-repeats]\n\        [--truncate-set1] string1 [string2]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the character C is a member of the    equivalence class containing the character EQUIV_CLASS. */
end_comment

begin_function
specifier|static
name|int
name|is_equiv_class_member
parameter_list|(
name|equiv_class
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|int
name|equiv_class
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|equiv_class
operator|==
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the character C is a member of the    character class CHAR_CLASS. */
end_comment

begin_function
specifier|static
name|int
name|is_char_class_member
parameter_list|(
name|char_class
parameter_list|,
name|c
parameter_list|)
name|enum
name|Char_class
name|char_class
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|char_class
condition|)
block|{
case|case
name|CC_ALNUM
case|:
return|return
name|isalnum
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_ALPHA
case|:
return|return
name|isalpha
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_BLANK
case|:
return|return
name|isblank
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_CNTRL
case|:
return|return
name|iscntrl
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_DIGIT
case|:
return|return
name|isdigit
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_GRAPH
case|:
return|return
name|isgraph
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_LOWER
case|:
return|return
name|islower
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_PRINT
case|:
return|return
name|isprint
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_PUNCT
case|:
return|return
name|ispunct
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_SPACE
case|:
return|return
name|isspace
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_UPPER
case|:
return|return
name|isupper
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_XDIGIT
case|:
return|return
name|isxdigit
argument_list|(
name|c
argument_list|)
return|;
break|break;
case|case
name|CC_NO_CLASS
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Perform the first pass over each range-spec argument S,    converting all \c and \ddd escapes to their one-byte representations.    The conversion is done in-place, so S must point to writable    storage.  If an illegal quote sequence is found, an error message is    printed and the function returns non-zero.  Otherwise the length of    the resulting string is returned through LEN and the function returns 0.    The resulting array of characters may contain zero-bytes; however,    on input, S is assumed to be null-terminated, and hence    cannot contain actual (non-escaped) zero bytes. */
end_comment

begin_function
specifier|static
name|int
name|unquote
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|s
index|[
name|i
index|]
condition|)
block|{
name|int
name|c
decl_stmt|;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|s
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|int
name|oct_digit
decl_stmt|;
case|case
literal|'\\'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|c
operator|=
literal|'\007'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|c
operator|=
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|oct_digit
operator|=
name|s
index|[
name|i
operator|+
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|oct_digit
operator|&&
name|oct_digit
operator|<=
literal|7
condition|)
block|{
name|c
operator|=
literal|8
operator|*
name|c
operator|+
name|oct_digit
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|oct_digit
operator|=
name|s
index|[
name|i
operator|+
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|oct_digit
operator|&&
name|oct_digit
operator|<=
literal|7
condition|)
block|{
if|if
condition|(
literal|8
operator|*
name|c
operator|+
name|oct_digit
operator|<
name|N_CHARS
condition|)
block|{
name|c
operator|=
literal|8
operator|*
name|c
operator|+
name|oct_digit
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|posix_pedantic
condition|)
block|{
comment|/* Any octal number larger than 0377 won't 			     fit in 8 bits.  So we stop when adding the 			     next digit would put us over the limit and 			     give a warning about the ambiguity.  POSIX 			     isn't clear on this, but one person has said 			     that in his interpretation, POSIX says tr 			     can't even give a warning. */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: the ambiguous octal escape \ \\%c%c%c is being\n\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
argument_list|,
name|s
index|[
name|i
index|]
argument_list|,
name|s
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|s
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|s
index|[
name|i
index|]
argument_list|,
name|s
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|s
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'\0'
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid backslash escape at end of string"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid backslash escape `\\%c'"
argument_list|,
name|s
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
name|s
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|s
index|[
name|j
operator|++
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|len
operator|=
name|j
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If CLASS_STR is a valid character class string, return its index    in the global char_class_name array.  Otherwise, return CC_NO_CLASS. */
end_comment

begin_function
specifier|static
name|enum
name|Char_class
name|look_up_char_class
parameter_list|(
name|class_str
parameter_list|)
name|unsigned
name|char
modifier|*
name|class_str
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHAR_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class_str
argument_list|,
name|char_class_name
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
expr|enum
name|Char_class
operator|)
name|i
return|;
return|return
name|CC_NO_CLASS
return|;
block|}
end_function

begin_comment
comment|/* Return a newly allocated string with a printable version of C.    This function is used solely for formatting error messages. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_printable_char
parameter_list|(
name|c
parameter_list|)
name|unsigned
name|int
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|c
operator|<
name|N_CHARS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return a newly allocated copy of S which is suitable for printing.    LEN is the number of characters in S.  Most non-printing    (isprint) characters are represented by a backslash followed by    3 octal digits.  However, the characters represented by \c escapes    where c is one of [abfnrtv] are represented by their 2-character \c    sequences.  This function is used solely for printing error messages. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_printable_str
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Worst case is that every character expands to a backslash      followed by a 3-character octal escape sequence. */
name|char
modifier|*
name|printable_buf
init|=
name|xmalloc
argument_list|(
literal|4
operator|*
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|printable_buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|s
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\\'
case|:
name|tmp
operator|=
literal|"\\"
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|tmp
operator|=
literal|"\\a"
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|tmp
operator|=
literal|"\\b"
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|tmp
operator|=
literal|"\\f"
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|tmp
operator|=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|tmp
operator|=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|tmp
operator|=
literal|"\\t"
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|tmp
operator|=
literal|"\\v"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|buf
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|stpcpy
argument_list|(
name|p
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|printable_buf
return|;
block|}
end_function

begin_comment
comment|/* Append a newly allocated structure representing a    character C to the specification list LIST. */
end_comment

begin_function
specifier|static
name|void
name|append_normal_char
parameter_list|(
name|list
parameter_list|,
name|c
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|List_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|List_element
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|RE_NORMAL_CHAR
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|normal_char
operator|=
name|c
expr_stmt|;
name|assert
argument_list|(
name|list
operator|->
name|tail
argument_list|)
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a newly allocated structure representing the range    of characters from FIRST to LAST to the specification list LIST.    Return non-zero if LAST precedes FIRST in the collating sequence,    zero otherwise.  This means that '[c-c]' is acceptable.  */
end_comment

begin_function
specifier|static
name|int
name|append_range
parameter_list|(
name|list
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|int
name|first
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|ORD
argument_list|(
name|first
argument_list|)
operator|>
name|ORD
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp1
init|=
name|make_printable_char
argument_list|(
name|first
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp2
init|=
name|make_printable_char
argument_list|(
name|last
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"range-endpoints of `%s-%s' are in reverse collating sequence order"
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|new
operator|=
operator|(
expr|struct
name|List_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|List_element
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|RE_RANGE
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|range
operator|.
name|first_char
operator|=
name|first
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|range
operator|.
name|last_char
operator|=
name|last
expr_stmt|;
name|assert
argument_list|(
name|list
operator|->
name|tail
argument_list|)
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|new
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If CHAR_CLASS_STR is a valid character class string, append a    newly allocated structure representing that character class to the end    of the specification list LIST and return 0.  If CHAR_CLASS_STR is not    a valid string, give an error message and return non-zero. */
end_comment

begin_function
specifier|static
name|int
name|append_char_class
parameter_list|(
name|list
parameter_list|,
name|char_class_str
parameter_list|,
name|len
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|char
modifier|*
name|char_class_str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|enum
name|Char_class
name|char_class
decl_stmt|;
name|struct
name|List_element
modifier|*
name|new
decl_stmt|;
name|char_class
operator|=
name|look_up_char_class
argument_list|(
name|char_class_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_class
operator|==
name|CC_NO_CLASS
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|make_printable_str
argument_list|(
name|char_class_str
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid character class `%s'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|new
operator|=
operator|(
expr|struct
name|List_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|List_element
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|RE_CHAR_CLASS
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|char_class
operator|=
name|char_class
expr_stmt|;
name|assert
argument_list|(
name|list
operator|->
name|tail
argument_list|)
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|new
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Append a newly allocated structure representing a [c*n]    repeated character construct, to the specification list LIST.    THE_CHAR is the single character to be repeated, and REPEAT_COUNT    is non-negative repeat count. */
end_comment

begin_function
specifier|static
name|void
name|append_repeated_char
parameter_list|(
name|list
parameter_list|,
name|the_char
parameter_list|,
name|repeat_count
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|int
name|the_char
decl_stmt|;
name|long
name|int
name|repeat_count
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|List_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|List_element
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|RE_REPEATED_CHAR
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|the_repeated_char
operator|=
name|the_char
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|=
name|repeat_count
expr_stmt|;
name|assert
argument_list|(
name|list
operator|->
name|tail
argument_list|)
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a string, EQUIV_CLASS_STR, from a [=str=] context and    the length of that string, LEN, if LEN is exactly one, append    a newly allocated structure representing the specified    equivalence class to the specification list, LIST and return zero.    If LEN is not 1, issue an error message and return non-zero. */
end_comment

begin_function
specifier|static
name|int
name|append_equiv_class
parameter_list|(
name|list
parameter_list|,
name|equiv_class_str
parameter_list|,
name|len
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|char
modifier|*
name|equiv_class_str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|1
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|make_printable_str
argument_list|(
name|equiv_class_str
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: equivalence class operand must be a single character"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|new
operator|=
operator|(
expr|struct
name|List_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|List_element
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|RE_EQUIV_CLASS
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|equiv_code
operator|=
operator|*
name|equiv_class_str
expr_stmt|;
name|assert
argument_list|(
name|list
operator|->
name|tail
argument_list|)
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|new
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a newly allocated copy of P[FIRST_IDX..LAST_IDX]. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|substr
parameter_list|(
name|p
parameter_list|,
name|first_idx
parameter_list|,
name|last_idx
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|first_idx
decl_stmt|;
name|int
name|last_idx
decl_stmt|;
block|{
name|int
name|len
init|=
name|last_idx
operator|-
name|first_idx
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|first_idx
operator|<=
name|last_idx
argument_list|)
expr_stmt|;
comment|/* We must use bcopy or memcopy rather than strncpy      because `p' may contain zero-bytes. */
name|bcopy
argument_list|(
name|p
operator|+
name|first_idx
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tmp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Search forward starting at START_IDX for the 2-char sequence    (PRE_BRACKET_CHAR,']') in the string P of length P_LEN.  If such    a sequence is found, return the index of the first character,    otherwise return -1.  P may contain zero bytes. */
end_comment

begin_function
specifier|static
name|int
name|find_closing_delim
parameter_list|(
name|p
parameter_list|,
name|start_idx
parameter_list|,
name|p_len
parameter_list|,
name|pre_bracket_char
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|start_idx
decl_stmt|;
name|int
name|p_len
decl_stmt|;
name|unsigned
name|int
name|pre_bracket_char
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start_idx
init|;
name|i
operator|<
name|p_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
name|pre_bracket_char
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|']'
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert a string S with explicit length LEN, possibly    containing embedded zero bytes, to a long integer value.    If the string represents a negative value, a value larger    than LONG_MAX, or if all LEN characters do not represent a    valid integer, return non-zero and do not modify *VAL.    Otherwise, return zero and set *VAL to the converted value. */
end_comment

begin_function
specifier|static
name|int
name|non_neg_strtol
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|long
name|int
modifier|*
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|base
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
name|base
operator|=
literal|10
expr_stmt|;
else|else
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|s
index|[
name|i
index|]
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|c
operator|>=
name|base
operator|||
name|c
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|i
operator|>
literal|8
operator|&&
name|sum
operator|>
operator|(
name|LONG_MAX
operator|-
name|c
operator|)
operator|/
name|base
condition|)
return|return
literal|1
return|;
name|sum
operator|=
name|sum
operator|*
name|base
operator|+
name|c
expr_stmt|;
block|}
operator|*
name|val
operator|=
name|sum
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse the bracketed repeat-char syntax.  If the P_LEN characters    beginning with P[ START_IDX ] comprise a valid [c*n] construct,    return the character and the repeat count through the arg pointers,    CHAR_TO_REPEAT and N, and then return the index of the closing    bracket as the function value.  If the second character following    the opening bracket is not `*' or if no closing bracket can be    found, return -1.  If a closing bracket is found and the    second char is `*', but the string between the `*' and `]' isn't    empty, an octal number, or a decimal number, print an error message    and return -2. */
end_comment

begin_function
specifier|static
name|int
name|find_bracketed_repeat
parameter_list|(
name|p
parameter_list|,
name|start_idx
parameter_list|,
name|p_len
parameter_list|,
name|char_to_repeat
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|start_idx
decl_stmt|;
name|int
name|p_len
decl_stmt|;
name|unsigned
name|int
modifier|*
name|char_to_repeat
decl_stmt|;
name|long
name|int
modifier|*
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|start_idx
operator|+
literal|1
operator|<
name|p_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|start_idx
operator|+
literal|1
index|]
operator|!=
literal|'*'
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
name|start_idx
operator|+
literal|2
init|;
name|i
operator|<
name|p_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|']'
condition|)
block|{
name|unsigned
name|char
modifier|*
name|digit_str
decl_stmt|;
name|int
name|digit_str_len
init|=
name|i
operator|-
name|start_idx
operator|-
literal|2
decl_stmt|;
operator|*
name|char_to_repeat
operator|=
name|p
index|[
name|start_idx
index|]
expr_stmt|;
if|if
condition|(
name|digit_str_len
operator|==
literal|0
condition|)
block|{
comment|/* We've matched [c*] -- no explicit repeat count. */
operator|*
name|n
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* Here, we have found [c*s] where s should be a string 	     of octal or decimal digits. */
name|digit_str
operator|=
operator|&
name|p
index|[
name|start_idx
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|non_neg_strtol
argument_list|(
name|digit_str
argument_list|,
name|digit_str_len
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|make_printable_str
argument_list|(
name|digit_str
argument_list|,
name|digit_str_len
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid repeat count `%s' in [c*n] construct"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* No bracket found. */
block|}
end_function

begin_comment
comment|/* Convert string UNESACPED_STRING (which has been preprocessed to    convert backslash-escape sequences) of length LEN characters into    a linked list of the following 5 types of constructs:       - [:str:] Character class where `str' is one of the 12 valid strings.       - [=c=] Equivalence class where `c' is any single character.       - [c*n] Repeat the single character `c' `n' times. n may be omitted. 	  However, if `n' is present, it must be a non-negative octal or 	  decimal integer.       - r-s Range of characters from `r' to `s'.  The second endpoint must 	  not precede the first in the current collating sequence.       - c Any other character is interpreted as itself. */
end_comment

begin_function
specifier|static
name|int
name|build_spec_list
parameter_list|(
name|unescaped_string
parameter_list|,
name|len
parameter_list|,
name|result
parameter_list|)
name|unsigned
name|char
modifier|*
name|unescaped_string
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|Spec_list
modifier|*
name|result
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|unescaped_string
expr_stmt|;
comment|/* The main for-loop below recognizes the 4 multi-character constructs.      A character that matches (in its context) none of the multi-character      constructs is classified as `normal'.  Since all multi-character      constructs have at least 3 characters, any strings of length 2 or      less are composed solely of normal characters.  Hence, the index of      the outer for-loop runs only as far as LEN-2. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|2
condition|;
control|)
block|{
switch|switch
condition|(
name|p
index|[
name|i
index|]
condition|)
block|{
name|int
name|fall_through
decl_stmt|;
case|case
literal|'['
case|:
name|fall_through
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|int
name|closing_delim_idx
decl_stmt|;
name|int
name|closing_bracket_idx
decl_stmt|;
name|unsigned
name|int
name|char_to_repeat
decl_stmt|;
name|long
name|repeat_count
decl_stmt|;
case|case
literal|':'
case|:
case|case
literal|'='
case|:
name|closing_delim_idx
operator|=
name|find_closing_delim
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|len
argument_list|,
name|p
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|closing_delim_idx
operator|>=
literal|0
condition|)
block|{
name|int
name|parse_failed
decl_stmt|;
name|unsigned
name|char
modifier|*
name|opnd_str
init|=
name|substr
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|closing_delim_idx
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|':'
condition|)
name|parse_failed
operator|=
name|append_char_class
argument_list|(
name|result
argument_list|,
name|opnd_str
argument_list|,
operator|(
name|closing_delim_idx
operator|-
literal|1
operator|)
operator|-
operator|(
name|i
operator|+
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|parse_failed
operator|=
name|append_equiv_class
argument_list|(
name|result
argument_list|,
name|opnd_str
argument_list|,
operator|(
name|closing_delim_idx
operator|-
literal|1
operator|)
operator|-
operator|(
name|i
operator|+
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|opnd_str
argument_list|)
expr_stmt|;
comment|/* Return non-zero if append_*_class reports a problem. */
if|if
condition|(
name|parse_failed
condition|)
return|return
literal|1
return|;
else|else
name|i
operator|=
name|closing_delim_idx
operator|+
literal|2
expr_stmt|;
break|break;
block|}
comment|/* Else fall through.  This could be [:*] or [=*]. */
default|default:
comment|/* Determine whether this is a bracketed repeat range 		 matching the RE \[.\*(dec_or_oct_number)?\]. */
name|closing_bracket_idx
operator|=
name|find_bracketed_repeat
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|len
argument_list|,
operator|&
name|char_to_repeat
argument_list|,
operator|&
name|repeat_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|closing_bracket_idx
operator|>=
literal|0
condition|)
block|{
name|append_repeated_char
argument_list|(
name|result
argument_list|,
name|char_to_repeat
argument_list|,
name|repeat_count
argument_list|)
expr_stmt|;
name|i
operator|=
name|closing_bracket_idx
operator|+
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|closing_bracket_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|fall_through
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Found a string that looked like [c*n] but the 		   numeric part was invalid. */
return|return
literal|1
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|fall_through
condition|)
break|break;
comment|/* Here if we've tried to match [c*n], [:str:], and [=c=] 	     and none of them fit.  So we still have to consider the 	     range `[-c' (from `[' to `c'). */
default|default:
comment|/* Look ahead one char for ranges like a-z. */
if|if
condition|(
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|append_range
argument_list|(
name|result
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|p
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|append_normal_char
argument_list|(
name|result
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Now handle the (2 or fewer) remaining characters p[i]..p[len - 1]. */
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|append_normal_char
argument_list|(
name|result
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a Spec_list S (with its saved state implicit in the values    of its members `tail' and `state'), return the next single character    in the expansion of S's constructs.  If the last character of S was    returned on the previous call or if S was empty, this function    returns -1.  For example, successive calls to get_next where S    represents the spec-string 'a-d[y*3]' will return the sequence    of values a, b, c, d, y, y, y, -1.  Finally, if the construct from    which the returned character comes is [:upper:] or [:lower:], the    parameter CLASS is given a value to indicate which it was.  Otherwise    CLASS is set to UL_NONE.  This value is used only when constructing    the translation table to verify that any occurrences of upper and    lower class constructs in the spec-strings appear in the same relative    positions. */
end_comment

begin_function
specifier|static
name|int
name|get_next
parameter_list|(
name|s
parameter_list|,
name|class
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|s
decl_stmt|;
name|enum
name|Upper_Lower_class
modifier|*
name|class
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|p
decl_stmt|;
name|int
name|return_val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Appease the compiler. */
if|if
condition|(
name|class
condition|)
operator|*
name|class
operator|=
name|UL_NONE
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|BEGIN_STATE
condition|)
block|{
name|s
operator|->
name|tail
operator|=
name|s
operator|->
name|head
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
block|}
name|p
operator|=
name|s
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|RE_NORMAL_CHAR
case|:
name|return_val
operator|=
name|p
operator|->
name|u
operator|.
name|normal_char
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
name|s
operator|->
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|RE_RANGE
case|:
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NEW_ELEMENT
condition|)
name|s
operator|->
name|state
operator|=
name|ORD
argument_list|(
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|first_char
argument_list|)
expr_stmt|;
else|else
operator|++
operator|(
name|s
operator|->
name|state
operator|)
expr_stmt|;
name|return_val
operator|=
name|CHR
argument_list|(
name|s
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|ORD
argument_list|(
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|last_char
argument_list|)
condition|)
block|{
name|s
operator|->
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
block|}
break|break;
case|case
name|RE_CHAR_CLASS
case|:
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NEW_ELEMENT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_char_class_member
argument_list|(
name|p
operator|->
name|u
operator|.
name|char_class
argument_list|,
name|i
argument_list|)
condition|)
break|break;
name|assert
argument_list|(
name|i
operator|<
name|N_CHARS
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|i
expr_stmt|;
block|}
name|assert
argument_list|(
name|is_char_class_member
argument_list|(
name|p
operator|->
name|u
operator|.
name|char_class
argument_list|,
name|s
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
operator|=
name|CHR
argument_list|(
name|s
operator|->
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|s
operator|->
name|state
operator|+
literal|1
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_char_class_member
argument_list|(
name|p
operator|->
name|u
operator|.
name|char_class
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|N_CHARS
condition|)
name|s
operator|->
name|state
operator|=
name|i
expr_stmt|;
else|else
block|{
name|s
operator|->
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|class
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|u
operator|.
name|char_class
condition|)
block|{
case|case
name|CC_LOWER
case|:
operator|*
name|class
operator|=
name|UL_LOWER
expr_stmt|;
break|break;
case|case
name|CC_UPPER
case|:
operator|*
name|class
operator|=
name|UL_UPPER
expr_stmt|;
break|break;
default|default:
comment|/* empty */
break|break;
block|}
block|}
break|break;
case|case
name|RE_EQUIV_CLASS
case|:
comment|/* FIXME: this assumes that each character is alone in its own 	 equivalence class (which appears to be correct for my 	 LC_COLLATE.  But I don't know of any function that allows 	 one to determine a character's equivalence class. */
name|return_val
operator|=
name|p
operator|->
name|u
operator|.
name|equiv_code
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
name|s
operator|->
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|RE_REPEATED_CHAR
case|:
comment|/* Here, a repeat count of n == 0 means don't repeat at all. */
name|assert
argument_list|(
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
name|return_val
operator|=
name|get_next
argument_list|(
name|s
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NEW_ELEMENT
condition|)
block|{
name|s
operator|->
name|state
operator|=
literal|0
expr_stmt|;
block|}
operator|++
operator|(
name|s
operator|->
name|state
operator|)
expr_stmt|;
name|return_val
operator|=
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|the_repeated_char
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|>
literal|0
operator|&&
name|s
operator|->
name|state
operator|==
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
condition|)
block|{
name|s
operator|->
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NEW_ELEMENT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RE_NO_TYPE
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|return_val
return|;
block|}
end_function

begin_comment
comment|/* This is a minor kludge.  This function is called from    get_spec_stats to determine the cardinality of a set derived    from a complemented string.  It's a kludge in that some of    the same operations are (duplicated) performed in set_initialize. */
end_comment

begin_function
specifier|static
name|int
name|card_of_complement
parameter_list|(
name|s
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|cardinality
init|=
name|N_CHARS
decl_stmt|;
name|SET_TYPE
name|in_set
index|[
name|N_CHARS
index|]
decl_stmt|;
name|bzero
argument_list|(
name|in_set
argument_list|,
name|N_CHARS
operator|*
sizeof|sizeof
argument_list|(
name|in_set
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|BEGIN_STATE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|get_next
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|in_set
index|[
name|c
index|]
operator|++
condition|)
operator|--
name|cardinality
expr_stmt|;
return|return
name|cardinality
return|;
block|}
end_function

begin_comment
comment|/* Gather statistics about the spec-list S in preparation for the tests    in validate that determine the legality of the specs.  This function    is called at most twice; once for string1, and again for any string2.    LEN_S1< 0 indicates that this is the first call and that S represents    string1.  When LEN_S1>= 0, it is the length of the expansion of the    constructs in string1, and we can use its value to resolve any    indefinite repeat construct in S (which represents string2).  Hence,    this function has the side-effect that it converts a valid [c*]    construct in string2 to [c*n] where n is large enough (or 0) to give    string2 the same length as string1.  For example, with the command    tr a-z 'A[\n*]Z' on the second call to get_spec_stats, LEN_S1 would    be 26 and S (representing string2) would be converted to 'A[\n*24]Z'. */
end_comment

begin_function
specifier|static
name|void
name|get_spec_stats
parameter_list|(
name|s
parameter_list|,
name|len_s1
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|s
decl_stmt|;
name|int
name|len_s1
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|p
decl_stmt|;
name|struct
name|List_element
modifier|*
name|indefinite_repeat_element
init|=
name|NULL
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|s
operator|->
name|n_indefinite_repeats
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|has_equiv_class
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|has_restricted_char_class
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|has_upper_or_lower
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|->
name|head
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
name|int
name|i
decl_stmt|;
case|case
name|RE_NORMAL_CHAR
case|:
operator|++
name|len
expr_stmt|;
break|break;
case|case
name|RE_RANGE
case|:
name|assert
argument_list|(
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|last_char
operator|>
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|first_char
argument_list|)
expr_stmt|;
name|len
operator|+=
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|last_char
operator|-
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|first_char
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|RE_CHAR_CLASS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_char_class_member
argument_list|(
name|p
operator|->
name|u
operator|.
name|char_class
argument_list|,
name|i
argument_list|)
condition|)
operator|++
name|len
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|u
operator|.
name|char_class
condition|)
block|{
case|case
name|CC_UPPER
case|:
case|case
name|CC_LOWER
case|:
name|s
operator|->
name|has_upper_or_lower
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|s
operator|->
name|has_restricted_char_class
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|RE_EQUIV_CLASS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_equiv_class_member
argument_list|(
name|p
operator|->
name|u
operator|.
name|equiv_code
argument_list|,
name|i
argument_list|)
condition|)
operator|++
name|len
expr_stmt|;
name|s
operator|->
name|has_equiv_class
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RE_REPEATED_CHAR
case|:
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|>
literal|0
condition|)
name|len
operator|+=
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|==
literal|0
condition|)
block|{
name|indefinite_repeat_element
operator|=
name|p
expr_stmt|;
operator|++
operator|(
name|s
operator|->
name|n_indefinite_repeats
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|RE_NO_TYPE
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|len_s1
operator|>=
name|len
operator|&&
name|s
operator|->
name|n_indefinite_repeats
operator|==
literal|1
condition|)
block|{
name|indefinite_repeat_element
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|repeat_count
operator|=
name|len_s1
operator|-
name|len
expr_stmt|;
name|len
operator|=
name|len_s1
expr_stmt|;
block|}
if|if
condition|(
name|complement
operator|&&
name|len_s1
operator|<
literal|0
condition|)
name|s
operator|->
name|length
operator|=
name|card_of_complement
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|length
operator|=
name|len
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|spec_init
parameter_list|(
name|spec_list
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|spec_list
decl_stmt|;
block|{
name|spec_list
operator|->
name|head
operator|=
name|spec_list
operator|->
name|tail
operator|=
operator|(
expr|struct
name|List_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|List_element
argument_list|)
argument_list|)
expr_stmt|;
name|spec_list
operator|->
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function makes two passes over the argument string S.  The first    one converts all \c and \ddd escapes to their one-byte representations.    The second constructs a linked specification list, SPEC_LIST, of the    characters and constructs that comprise the argument string.  If either    of these passes detects an error, this function returns non-zero. */
end_comment

begin_function
specifier|static
name|int
name|parse_str
parameter_list|(
name|s
parameter_list|,
name|spec_list
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|Spec_list
modifier|*
name|spec_list
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|unquote
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|build_spec_list
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|spec_list
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given two specification lists, S1 and S2, and assuming that    S1->length> S2->length, append a single [c*n] element to S2 where c    is the last character in the expansion of S2 and n is the difference    between the two lengths.    Upon successful completion, S2->length is set to S1->length.  The only    way this function can fail to make S2 as long as S1 is when S2 has    zero-length, since in that case, there is no last character to repeat.     Providing this functionality allows the user to do some pretty    non-BSD (and non-portable) things:  For example, the command        tr -cs '[:upper:]0-9' '[:lower:]'    is almost guaranteed to give results that depend on your collating    sequence.  */
end_comment

begin_function
specifier|static
name|void
name|string2_extend
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|s1
decl_stmt|;
name|struct
name|Spec_list
modifier|*
name|s2
decl_stmt|;
block|{
name|struct
name|List_element
modifier|*
name|p
decl_stmt|;
name|int
name|char_to_repeat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|translating
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s1
operator|->
name|length
operator|>
name|s2
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|length
operator|==
literal|0
condition|)
return|return;
name|char_to_repeat
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Appease the compiler. */
name|p
operator|=
name|s2
operator|->
name|tail
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|RE_NORMAL_CHAR
case|:
name|char_to_repeat
operator|=
name|p
operator|->
name|u
operator|.
name|normal_char
expr_stmt|;
break|break;
case|case
name|RE_RANGE
case|:
name|char_to_repeat
operator|=
name|p
operator|->
name|u
operator|.
name|range
operator|.
name|last_char
expr_stmt|;
break|break;
case|case
name|RE_CHAR_CLASS
case|:
for|for
control|(
name|i
operator|=
name|N_CHARS
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|is_char_class_member
argument_list|(
name|p
operator|->
name|u
operator|.
name|char_class
argument_list|,
name|i
argument_list|)
condition|)
break|break;
name|assert
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|char_to_repeat
operator|=
name|CHR
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|RE_EQUIV_CLASS
case|:
comment|/* This shouldn't happen, because validate exits with an error 	 if it finds an equiv class in string2 when translating. */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RE_REPEATED_CHAR
case|:
name|char_to_repeat
operator|=
name|p
operator|->
name|u
operator|.
name|repeated_char
operator|.
name|the_repeated_char
expr_stmt|;
break|break;
case|case
name|RE_NO_TYPE
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|append_repeated_char
argument_list|(
name|s2
argument_list|,
name|char_to_repeat
argument_list|,
name|s1
operator|->
name|length
operator|-
name|s2
operator|->
name|length
argument_list|)
expr_stmt|;
name|s2
operator|->
name|length
operator|=
name|s1
operator|->
name|length
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Die with an error message if S1 and S2 describe strings that    are not valid with the given command line switches.    A side effect of this function is that if a legal [c*] or    [c*0] construct appears in string2, it is converted to [c*n]    with a value for n that makes s2->length == s1->length.  By    the same token, if the --truncate-set1 option is not    given, S2 may be extended. */
end_comment

begin_function
specifier|static
name|void
name|validate
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|s1
decl_stmt|;
name|struct
name|Spec_list
modifier|*
name|s2
decl_stmt|;
block|{
name|get_spec_stats
argument_list|(
name|s1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|->
name|n_indefinite_repeats
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"the [c*] repeat construct may not appear in string1"
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: it isn't clear from the POSIX spec that this is illegal,      but in the spirit of the other restrictions put on translation      with character classes, this seems a logical interpretation. */
if|if
condition|(
name|complement
operator|&&
name|s1
operator|->
name|has_upper_or_lower
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"character classes may not be used when translating and complementing"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s2
condition|)
block|{
name|get_spec_stats
argument_list|(
name|s2
argument_list|,
name|s1
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|has_restricted_char_class
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"when translating, the only character classes that may appear in\n\ \tstring2 are `upper' and `lower'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|->
name|n_indefinite_repeats
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only one [c*] repeat construct may appear in string2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|translating
condition|)
block|{
if|if
condition|(
name|s2
operator|->
name|has_equiv_class
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"[=c=] expressions may not appear in string2 when translating"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s1
operator|->
name|length
operator|>
name|s2
operator|->
name|length
condition|)
block|{
if|if
condition|(
operator|!
name|truncate_set1
condition|)
name|string2_extend
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|complement
operator|&&
name|s2
operator|->
name|has_upper_or_lower
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"character classes may not be used when translating and complementing"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not translating. */
block|{
if|if
condition|(
name|s2
operator|->
name|n_indefinite_repeats
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"the [c*] construct may appear in string2 only when translating"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read buffers of SIZE bytes via the function READER (if READER is    NULL, read from stdin) until EOF.  When non-NULL, READER is either    read_and_delete or read_and_xlate.  After each buffer is read, it is    processed and written to stdout.  The buffers are processed so that    multiple consecutive occurrences of the same character in the input    stream are replaced by a single occurrence of that character if the    character is in the squeeze set. */
end_comment

begin_function
specifier|static
name|void
name|squeeze_filter
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|reader
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|int
name|size
decl_stmt|;
name|PFI
name|reader
decl_stmt|;
block|{
name|unsigned
name|int
name|char_to_squeeze
init|=
name|NOT_A_CHAR
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|nr
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|begin
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|nr
condition|)
block|{
if|if
condition|(
name|reader
operator|==
name|NULL
condition|)
name|nr
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|nr
operator|=
call|(
modifier|*
name|reader
call|)
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
break|break;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|begin
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|char_to_squeeze
operator|==
name|NOT_A_CHAR
condition|)
block|{
name|int
name|out_len
decl_stmt|;
comment|/* Here, by being a little tricky, we can get a significant 	     performance increase in most cases when the input is 	     reasonably large.  Since tr will modify the input only 	     if two consecutive (and identical) input characters are 	     in the squeeze set, we can step by two through the data 	     when searching for a character in the squeeze set.  This 	     means there may be a little more work in a few cases and 	     perhaps twice as much work in the worst cases where most 	     of the input is removed by squeezing repeats.  But most 	     uses of this functionality seem to remove less than 20-30% 	     of the input. */
for|for
control|(
init|;
name|i
operator|<
name|nr
operator|&&
operator|!
name|in_squeeze_set
index|[
name|buf
index|[
name|i
index|]
index|]
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
comment|/* empty */
comment|/* There is a special case when i == nr and we've just 	     skipped a character (the last one in buf) that is in 	     the squeeze set. */
if|if
condition|(
name|i
operator|==
name|nr
operator|&&
name|in_squeeze_set
index|[
name|buf
index|[
name|i
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nr
condition|)
name|out_len
operator|=
name|nr
operator|-
name|begin
expr_stmt|;
else|else
block|{
name|char_to_squeeze
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
comment|/* We're about to output buf[begin..i]. */
name|out_len
operator|=
name|i
operator|-
name|begin
operator|+
literal|1
expr_stmt|;
comment|/* But since we stepped by 2 in the loop above, 		 out_len may be one too large. */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|char_to_squeeze
condition|)
operator|--
name|out_len
expr_stmt|;
comment|/* Advance i to the index of first character to be 		 considered when looking for a char different from 		 char_to_squeeze. */
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|out_len
operator|>
literal|0
operator|&&
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
index|[
name|begin
index|]
argument_list|,
literal|1
argument_list|,
name|out_len
argument_list|,
name|stdout
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|char_to_squeeze
operator|!=
name|NOT_A_CHAR
condition|)
block|{
comment|/* Advance i to index of first char != char_to_squeeze 	     (or to nr if all the rest of the characters in this 	     buffer are the same as char_to_squeeze). */
for|for
control|(
init|;
name|i
operator|<
name|nr
operator|&&
name|buf
index|[
name|i
index|]
operator|==
name|char_to_squeeze
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* empty */
if|if
condition|(
name|i
operator|<
name|nr
condition|)
name|char_to_squeeze
operator|=
name|NOT_A_CHAR
expr_stmt|;
comment|/* If (i>= nr) we've squeezed the last character in this buffer. 	     So now we have to read a new buffer and continue comparing 	     characters against char_to_squeeze. */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read buffers of SIZE bytes from stdin until one is found that    contains at least one character not in the delete set.  Store    in the array BUF, all characters from that buffer that are not    in the delete set, and return the number of characters saved    or 0 upon EOF. */
end_comment

begin_function
specifier|static
name|long
name|read_and_delete
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|not_used
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|int
name|size
decl_stmt|;
name|PFI
name|not_used
decl_stmt|;
block|{
name|long
name|n_saved
decl_stmt|;
specifier|static
name|int
name|hit_eof
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|not_used
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_eof
condition|)
return|return
literal|0
return|;
comment|/* This enclosing do-while loop is to make sure that      we don't return zero (indicating EOF) when we've      just deleted all the characters in a buffer. */
do|do
block|{
name|int
name|i
decl_stmt|;
name|int
name|nr
init|=
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
block|{
name|hit_eof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This first loop may be a waste of code, but gives much          better performance when no characters are deleted in          the beginning of a buffer.  It just avoids the copying          of buf[i] into buf[n_saved] when it would be a NOP. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
operator|&&
operator|!
name|in_delete_set
index|[
name|buf
index|[
name|i
index|]
index|]
condition|;
name|i
operator|++
control|)
comment|/* empty */
empty_stmt|;
name|n_saved
operator|=
name|i
expr_stmt|;
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|in_delete_set
index|[
name|buf
index|[
name|i
index|]
index|]
condition|)
name|buf
index|[
name|n_saved
operator|++
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
do|while
condition|(
name|n_saved
operator|==
literal|0
condition|)
do|;
return|return
name|n_saved
return|;
block|}
end_function

begin_comment
comment|/* Read at most SIZE bytes from stdin into the array BUF.  Then    perform the in-place and one-to-one mapping specified by the global    array `xlate'.  Return the number of characters read, or 0 upon EOF. */
end_comment

begin_function
specifier|static
name|long
name|read_and_xlate
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|not_used
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|int
name|size
decl_stmt|;
name|PFI
name|not_used
decl_stmt|;
block|{
name|long
name|chars_read
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|hit_eof
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|not_used
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_eof
condition|)
return|return
literal|0
return|;
name|chars_read
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|==
literal|0
condition|)
block|{
name|hit_eof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chars_read
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|xlate
index|[
name|buf
index|[
name|i
index|]
index|]
expr_stmt|;
return|return
name|chars_read
return|;
block|}
end_function

begin_comment
comment|/* Initialize a boolean membership set IN_SET with the character    values obtained by traversing the linked list of constructs S    using the function `get_next'.  If COMPLEMENT_THIS_SET is    non-zero the resulting set is complemented. */
end_comment

begin_function
specifier|static
name|void
name|set_initialize
parameter_list|(
name|s
parameter_list|,
name|complement_this_set
parameter_list|,
name|in_set
parameter_list|)
name|struct
name|Spec_list
modifier|*
name|s
decl_stmt|;
name|int
name|complement_this_set
decl_stmt|;
name|SET_TYPE
modifier|*
name|in_set
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|in_set
argument_list|,
name|N_CHARS
operator|*
sizeof|sizeof
argument_list|(
name|in_set
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|BEGIN_STATE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|get_next
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|in_set
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|complement_this_set
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
name|in_set
index|[
name|i
index|]
operator|=
operator|(
operator|!
name|in_set
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|non_option_args
decl_stmt|;
name|struct
name|Spec_list
name|buf1
decl_stmt|,
name|buf2
decl_stmt|;
name|struct
name|Spec_list
modifier|*
name|s1
init|=
operator|&
name|buf1
decl_stmt|;
name|struct
name|Spec_list
modifier|*
name|s2
init|=
operator|&
name|buf2
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cdst"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'c'
case|:
name|complement
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|squeeze_repeats
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|truncate_set1
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|posix_pedantic
operator|=
operator|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|non_option_args
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|translating
operator|=
operator|(
name|non_option_args
operator|==
literal|2
operator|&&
operator|!
name|delete
operator|)
expr_stmt|;
comment|/* Change this test if it is legal to give tr no options and      no args at all.  POSIX doesn't specifically say anything      either way, but it looks like they implied it's illegal      by omission.  If you want to make tr do a slow imitation      of `cat' use `tr a a'. */
if|if
condition|(
name|non_option_args
operator|>
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|delete
operator|&&
operator|!
name|squeeze_repeats
operator|&&
name|non_option_args
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"two strings must be given when translating"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
operator|&&
name|squeeze_repeats
operator|&&
name|non_option_args
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"two strings must be given when both \ deleting and squeezing repeats"
argument_list|)
expr_stmt|;
comment|/* If --delete is given without --squeeze-repeats, then      only one string argument may be specified.  But POSIX      says to ignore any string2 in this case, so if POSIXLY_CORRECT      is set, pretend we never saw string2.  But I think      this deserves a fatal error, so that's the default. */
if|if
condition|(
operator|(
name|delete
operator|&&
operator|!
name|squeeze_repeats
operator|)
operator|&&
name|non_option_args
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|posix_pedantic
operator|&&
name|non_option_args
operator|==
literal|2
condition|)
operator|--
name|non_option_args
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only one string may be given when deleting without squeezing repeats"
argument_list|)
expr_stmt|;
block|}
name|spec_init
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
name|optind
index|]
argument_list|,
name|s1
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_option_args
operator|==
literal|2
condition|)
block|{
name|spec_init
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_str
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|s2
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|s2
operator|=
name|NULL
expr_stmt|;
name|validate
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|squeeze_repeats
operator|&&
name|non_option_args
operator|==
literal|1
condition|)
block|{
name|set_initialize
argument_list|(
name|s1
argument_list|,
name|complement
argument_list|,
name|in_squeeze_set
argument_list|)
expr_stmt|;
name|squeeze_filter
argument_list|(
name|io_buf
argument_list|,
name|IO_BUF_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delete
operator|&&
name|non_option_args
operator|==
literal|1
condition|)
block|{
name|int
name|nr
decl_stmt|;
name|set_initialize
argument_list|(
name|s1
argument_list|,
name|complement
argument_list|,
name|in_delete_set
argument_list|)
expr_stmt|;
do|do
block|{
name|nr
operator|=
name|read_and_delete
argument_list|(
name|io_buf
argument_list|,
name|IO_BUF_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|>
literal|0
operator|&&
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|io_buf
argument_list|,
literal|1
argument_list|,
name|nr
argument_list|,
name|stdout
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nr
operator|>
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|squeeze_repeats
operator|&&
name|delete
operator|&&
name|non_option_args
operator|==
literal|2
condition|)
block|{
name|set_initialize
argument_list|(
name|s1
argument_list|,
name|complement
argument_list|,
name|in_delete_set
argument_list|)
expr_stmt|;
name|set_initialize
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|,
name|in_squeeze_set
argument_list|)
expr_stmt|;
name|squeeze_filter
argument_list|(
name|io_buf
argument_list|,
name|IO_BUF_SIZE
argument_list|,
operator|(
name|PFI
operator|)
name|read_and_delete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|translating
condition|)
block|{
if|if
condition|(
name|complement
condition|)
block|{
name|int
name|i
decl_stmt|;
name|SET_TYPE
modifier|*
name|in_s1
init|=
name|in_delete_set
decl_stmt|;
name|set_initialize
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|,
name|in_s1
argument_list|)
expr_stmt|;
name|s2
operator|->
name|state
operator|=
name|BEGIN_STATE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
name|xlate
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|in_s1
index|[
name|i
index|]
condition|)
block|{
name|int
name|c
init|=
name|get_next
argument_list|(
name|s2
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|c
operator|!=
operator|-
literal|1
operator|||
name|truncate_set1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This will happen when tr is invoked like e.g. 			 tr -cs A-Za-z0-9 '\012'.  */
break|break;
block|}
name|xlate
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|get_next
argument_list|(
name|s2
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|truncate_set1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|Upper_Lower_class
name|class_s1
decl_stmt|;
name|enum
name|Upper_Lower_class
name|class_s2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_CHARS
condition|;
name|i
operator|++
control|)
name|xlate
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|s1
operator|->
name|state
operator|=
name|BEGIN_STATE
expr_stmt|;
name|s2
operator|->
name|state
operator|=
name|BEGIN_STATE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c1
operator|=
name|get_next
argument_list|(
name|s1
argument_list|,
operator|&
name|class_s1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|get_next
argument_list|(
name|s2
argument_list|,
operator|&
name|class_s2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|class_ok
index|[
operator|(
name|int
operator|)
name|class_s1
index|]
index|[
operator|(
name|int
operator|)
name|class_s2
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"misaligned or mismatched upper and/or lower classes"
argument_list|)
expr_stmt|;
comment|/* The following should have been checked by validate... */
if|if
condition|(
name|c2
operator|==
operator|-
literal|1
condition|)
break|break;
name|xlate
index|[
name|c1
index|]
operator|=
name|c2
expr_stmt|;
block|}
name|assert
argument_list|(
name|c1
operator|==
operator|-
literal|1
operator|||
name|truncate_set1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|squeeze_repeats
condition|)
block|{
name|set_initialize
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|,
name|in_squeeze_set
argument_list|)
expr_stmt|;
name|squeeze_filter
argument_list|(
name|io_buf
argument_list|,
name|IO_BUF_SIZE
argument_list|,
operator|(
name|PFI
operator|)
name|read_and_xlate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|chars_read
decl_stmt|;
do|do
block|{
name|chars_read
operator|=
name|read_and_xlate
argument_list|(
name|io_buf
argument_list|,
name|IO_BUF_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|>
literal|0
operator|&&
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|io_buf
argument_list|,
literal|1
argument_list|,
name|chars_read
argument_list|,
name|stdout
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chars_read
operator|>
literal|0
condition|)
do|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

