begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cut - remove parts of lines of files    Copyright (C) 1984 by David M. Ihnat      This program is a total rewrite of the Bell Laboratories Unix(Tm)    command of the same name, as of System V.  It contains no proprietary    code, and therefore may be used without violation of any proprietary    agreements whatsoever.  However, you will notice that the program is    copyrighted by me.  This is to assure the program does *not* fall    into the public domain.  Thus, I may specify just what I am now:    This program may be freely copied and distributed, provided this notice    remains; it may not be sold for profit without express written consent of    the author.    Please note that I recreated the behavior of the Unix(Tm) 'cut' command    as faithfully as possible; however, I haven't run a full set of regression    tests.  Thus, the user of this program accepts full responsibility for any    effects or loss; in particular, the author is not responsible for any losses,    explicit or incidental, that may be incurred through use of this program.     I ask that any bugs (and, if possible, fixes) be reported to me when    possible.  -David Ihnat (312) 784-4544 ignatz@homebru.chi.il.us     POSIX changes, bug fixes, long-named options, and cleanup    by David MacKenzie<djm@ai.mit.edu>.     Options:    --bytes=byte-list    -b byte-list			Print only the bytes in positions listed 				in BYTE-LIST. 				Tabs and backspaces are treated like any 				other character; they take up 1 byte.     --characters=character-list    -c character-list		Print only characters in positions listed 				in CHARACTER-LIST. 				The same as -b for now, but 				internationalization will change that. 				Tabs and backspaces are treated like any 				other character; they take up 1 character.     --fields=field-list    -f field-list		Print only the fields listed in FIELD-LIST. 				Fields are separated by a TAB by default.     --delimiter=delim    -d delim			For -f, fields are separated by the first 				character in DELIM instead of TAB.     -n				Do not split multibyte chars (no-op for now).     --only-delimited    -s				For -f, do not print lines that do not contain 				the field separator character.     The BYTE-LIST, CHARACTER-LIST, and FIELD-LIST are one or more numbers    or ranges separated by commas.  The first byte, character, and field    are numbered 1.     A FILE of `-' means standard input. */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|isascii
end_ifdef

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isascii ((c))&& isdigit ((c)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isdigit ((c)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|set_fields
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cut_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cut_stream
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cut_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cut_fields
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|enlarge_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|invalid_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The number of elements allocated for the input line    and the byte or field number.    Enlarged as necessary. */
end_comment

begin_decl_stmt
name|int
name|line_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processed output buffer. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to save next char to output. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outbufptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Raw line buffer for field mode. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|inbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to save next input char. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|inbufptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What can be done about a byte or field. */
end_comment

begin_enum
enum|enum
name|field_action
block|{
name|field_omit
block|,
name|field_output
block|}
enum|;
end_enum

begin_comment
comment|/* In byte mode, which bytes to output.    In field mode, which `delim'-separated fields to output.    Both bytes and fields are numbered starting with 1,    so the first element of `fields' is unused. */
end_comment

begin_decl_stmt
name|enum
name|field_action
modifier|*
name|fields
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|operating_mode
block|{
name|undefined_mode
block|,
comment|/* Output characters that are in the given bytes. */
name|byte_mode
block|,
comment|/* Output the given delimeter-separated fields. */
name|field_mode
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|operating_mode
name|operating_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero,    for field mode, do not output lines containing no delimeter characters. */
end_comment

begin_decl_stmt
name|int
name|delimited_lines_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The delimeter character for field mode. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|delim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have ever read standard input. */
end_comment

begin_decl_stmt
name|int
name|have_read_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"bytes"
block|,
literal|1
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"characters"
block|,
literal|1
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"fields"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"delimiter"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"only-delimited"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optc
decl_stmt|,
name|exit_status
init|=
literal|0
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|line_size
operator|=
literal|512
expr_stmt|;
name|operating_mode
operator|=
name|undefined_mode
expr_stmt|;
name|delimited_lines_only
operator|=
literal|0
expr_stmt|;
name|delim
operator|=
literal|'\0'
expr_stmt|;
name|have_read_stdin
operator|=
literal|0
expr_stmt|;
name|fields
operator|=
operator|(
expr|enum
name|field_action
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|field_action
argument_list|)
argument_list|)
expr_stmt|;
name|outbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|inbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
for|for
control|(
name|optc
operator|=
literal|0
init|;
name|optc
operator|<
name|line_size
condition|;
name|optc
operator|++
control|)
name|fields
index|[
name|optc
index|]
operator|=
name|field_omit
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:c:d:f:ns"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
comment|/* Build the byte list. */
if|if
condition|(
name|operating_mode
operator|!=
name|undefined_mode
condition|)
name|usage
argument_list|()
expr_stmt|;
name|operating_mode
operator|=
name|byte_mode
expr_stmt|;
if|if
condition|(
name|set_fields
argument_list|(
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"no fields given"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Build the field list. */
if|if
condition|(
name|operating_mode
operator|!=
name|undefined_mode
condition|)
name|usage
argument_list|()
expr_stmt|;
name|operating_mode
operator|=
name|field_mode
expr_stmt|;
if|if
condition|(
name|set_fields
argument_list|(
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"no fields given"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* New delimiter. */
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"no delimiter given"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"delimiter must be a single character"
argument_list|)
expr_stmt|;
name|delim
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
break|break;
case|case
literal|'s'
case|:
name|delimited_lines_only
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operating_mode
operator|==
name|undefined_mode
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|delimited_lines_only
operator|||
name|delim
operator|!=
literal|'\0'
operator|)
operator|&&
name|operating_mode
operator|!=
name|field_mode
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|delim
operator|==
literal|'\0'
condition|)
name|delim
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|exit_status
operator||=
name|cut_file
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
name|exit_status
operator||=
name|cut_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select for printing the positions in `fields' that are listed in    byte or field specification FIELDSTR.  FIELDSTR should be    composed of one or more numbers or ranges of numbers, separated by    blanks or commas.  Incomplete ranges may be given: `-m' means    `1-m'; `n-' means `n' through end of line or last field.     Return the number of fields selected. */
end_comment

begin_function
name|int
name|set_fields
parameter_list|(
name|fieldstr
parameter_list|)
name|char
modifier|*
name|fieldstr
decl_stmt|;
block|{
name|int
name|initial
init|=
literal|1
decl_stmt|;
comment|/* Value of first number in a range. */
name|int
name|dash_found
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if a '-' is found in this field. */
name|int
name|value
init|=
literal|0
decl_stmt|;
comment|/* If nonzero, a number being accumulated. */
name|int
name|fields_selected
init|=
literal|0
decl_stmt|;
comment|/* Number of fields selected so far. */
comment|/* If nonzero, index of first field in a range that goes to end of line. */
name|int
name|eol_range_start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|fieldstr
operator|==
literal|'-'
condition|)
block|{
comment|/* Starting a range. */
if|if
condition|(
name|dash_found
condition|)
name|invalid_list
argument_list|()
expr_stmt|;
name|dash_found
operator|++
expr_stmt|;
name|fieldstr
operator|++
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
if|if
condition|(
name|value
operator|>=
name|line_size
condition|)
name|enlarge_line
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|initial
operator|=
name|value
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|initial
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fieldstr
operator|==
literal|','
operator|||
name|isblank
argument_list|(
operator|*
name|fieldstr
argument_list|)
operator|||
operator|*
name|fieldstr
operator|==
literal|'\0'
condition|)
block|{
comment|/* Ending the string, or this field/byte sublist. */
if|if
condition|(
name|dash_found
condition|)
block|{
name|dash_found
operator|=
literal|0
expr_stmt|;
comment|/* A range.  Possibilites: -n, m-n, n-. 		 In any case, `initial' contains the start of the range. */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
comment|/* `n-'.  From `initial' to end of line. */
name|eol_range_start
operator|=
name|initial
expr_stmt|;
name|fields_selected
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* `m-n' or `-n' (1-n). */
if|if
condition|(
name|value
operator|<
name|initial
condition|)
name|invalid_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|line_size
condition|)
name|enlarge_line
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Is there already a range going to end of line? */
if|if
condition|(
name|eol_range_start
operator|!=
literal|0
condition|)
block|{
comment|/* Yes.  Is the new sequence already contained 			 in the old one?  If so, no processing is 			 necessary. */
if|if
condition|(
name|initial
operator|<
name|eol_range_start
condition|)
block|{
comment|/* No, the new sequence starts before the 			     old.  Does the old range going to end of line 			     extend into the new range?  */
if|if
condition|(
name|eol_range_start
operator|<
name|value
condition|)
comment|/* Yes.  Simply move the end of line marker. */
name|eol_range_start
operator|=
name|initial
expr_stmt|;
else|else
block|{
comment|/* No.  A simple range, before and disjoint from 				 the range going to end of line.  Fill it. */
for|for
control|(
init|;
name|initial
operator|<=
name|value
condition|;
name|initial
operator|++
control|)
name|fields
index|[
name|initial
index|]
operator|=
name|field_output
expr_stmt|;
block|}
comment|/* In any case, some fields were selected. */
name|fields_selected
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is no range going to end of line. */
for|for
control|(
init|;
name|initial
operator|<=
name|value
condition|;
name|initial
operator|++
control|)
name|fields
index|[
name|initial
index|]
operator|=
name|field_output
expr_stmt|;
name|fields_selected
operator|++
expr_stmt|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* A simple field number, not a range. */
if|if
condition|(
name|value
operator|>=
name|line_size
condition|)
name|enlarge_line
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|fields
index|[
name|value
index|]
operator|=
name|field_output
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|fields_selected
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fieldstr
operator|==
literal|'\0'
condition|)
block|{
comment|/* If there was a range going to end of line, fill the 		 array from the end of line point.  */
if|if
condition|(
name|eol_range_start
condition|)
for|for
control|(
name|initial
operator|=
name|eol_range_start
init|;
name|initial
operator|<
name|line_size
condition|;
name|initial
operator|++
control|)
name|fields
index|[
name|initial
index|]
operator|=
name|field_output
expr_stmt|;
return|return
name|fields_selected
return|;
block|}
name|fieldstr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|fieldstr
argument_list|)
condition|)
block|{
name|value
operator|=
literal|10
operator|*
name|value
operator|+
operator|*
name|fieldstr
operator|-
literal|'0'
expr_stmt|;
name|fieldstr
operator|++
expr_stmt|;
block|}
else|else
name|invalid_list
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process file FILE to standard output.    Return 0 if successful, 1 if not. */
end_comment

begin_function
name|int
name|cut_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|stream
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|cut_stream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* Also clear EOF. */
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|cut_stream
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|operating_mode
operator|==
name|byte_mode
condition|)
name|cut_bytes
argument_list|(
name|stream
argument_list|)
expr_stmt|;
else|else
name|cut_fields
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the file open for reading on stream STREAM    with the bytes marked `field_omit' in `fields' removed from each line. */
end_comment

begin_function
name|void
name|cut_bytes
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Each character from the file. */
name|int
name|doneflag
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if EOF reached. */
name|int
name|char_count
decl_stmt|;
comment|/* Number of chars in the line so far. */
while|while
condition|(
name|doneflag
operator|==
literal|0
condition|)
block|{
comment|/* Start processing a line. */
name|outbufptr
operator|=
name|outbuf
expr_stmt|;
name|char_count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|doneflag
operator|++
expr_stmt|;
break|break;
block|}
comment|/* If this character is to be sent, stow it in the outbuffer. */
if|if
condition|(
operator|++
name|char_count
operator|==
name|line_size
operator|-
literal|1
condition|)
name|enlarge_line
argument_list|(
name|char_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
name|char_count
index|]
operator|==
name|field_output
operator|||
name|c
operator|==
literal|'\n'
condition|)
operator|*
name|outbufptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|char_count
condition|)
name|fwrite
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|outbufptr
operator|-
name|outbuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the file open for reading on stream STREAM    with the fields marked `field_omit' in `fields' removed from each line.    All characters are initially stowed in the raw input buffer, until    at least one field has been found. */
end_comment

begin_function
name|void
name|cut_fields
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Each character from the file. */
name|int
name|doneflag
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if EOF reached. */
name|int
name|char_count
decl_stmt|;
comment|/* Number of chars in line before any delim. */
name|int
name|fieldfound
decl_stmt|;
comment|/* Nonzero if any fields to print found. */
name|int
name|curr_field
decl_stmt|;
comment|/* Current index in `fields'. */
while|while
condition|(
name|doneflag
operator|==
literal|0
condition|)
block|{
name|char_count
operator|=
literal|0
expr_stmt|;
name|fieldfound
operator|=
literal|0
expr_stmt|;
name|curr_field
operator|=
literal|1
expr_stmt|;
name|outbufptr
operator|=
name|outbuf
expr_stmt|;
name|inbufptr
operator|=
name|inbuf
expr_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|doneflag
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fields
index|[
name|curr_field
index|]
operator|==
name|field_output
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Working on a field.  It, and its terminating 		 delimiter, go only into the processed buffer. */
name|fieldfound
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|outbufptr
operator|-
name|outbuf
operator|==
name|line_size
operator|-
literal|2
condition|)
name|enlarge_line
argument_list|(
name|outbufptr
operator|-
name|outbuf
argument_list|)
expr_stmt|;
operator|*
name|outbufptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldfound
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|char_count
operator|==
name|line_size
operator|-
literal|1
condition|)
name|enlarge_line
argument_list|(
name|char_count
argument_list|)
expr_stmt|;
operator|*
name|inbufptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
operator|++
name|curr_field
operator|==
name|line_size
operator|-
literal|1
condition|)
name|enlarge_line
argument_list|(
name|curr_field
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|fieldfound
condition|)
block|{
comment|/* Something was found. Print it. */
if|if
condition|(
name|outbufptr
index|[
operator|-
literal|1
index|]
operator|==
name|delim
condition|)
operator|--
name|outbufptr
expr_stmt|;
comment|/* Suppress trailing delimiter. */
name|fwrite
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|outbufptr
operator|-
name|outbuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|delimited_lines_only
operator|&&
name|char_count
condition|)
comment|/* A line with some characters, no delimiters, and no 	   suppression.  Print it. */
name|fwrite
argument_list|(
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|inbufptr
operator|-
name|inbuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extend the buffers to accomodate at least NEW_SIZE characters. */
end_comment

begin_function
name|void
name|enlarge_line
parameter_list|(
name|new_size
parameter_list|)
name|int
name|new_size
decl_stmt|;
block|{
name|char
modifier|*
name|newp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|new_size
operator|+=
literal|256
expr_stmt|;
comment|/* Leave some room to grow. */
name|fields
operator|=
operator|(
expr|enum
name|field_action
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|field_action
argument_list|)
argument_list|)
expr_stmt|;
name|newp
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|outbuf
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|outbufptr
operator|+=
name|newp
operator|-
name|outbuf
expr_stmt|;
name|outbuf
operator|=
name|newp
expr_stmt|;
name|newp
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|inbuf
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|inbufptr
operator|+=
name|newp
operator|-
name|inbuf
expr_stmt|;
name|inbuf
operator|=
name|newp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|line_size
init|;
name|i
operator|<
name|new_size
condition|;
name|i
operator|++
control|)
name|fields
index|[
name|i
index|]
operator|=
name|field_omit
expr_stmt|;
name|line_size
operator|=
name|new_size
expr_stmt|;
block|}
end_function

begin_function
name|void
name|invalid_list
parameter_list|()
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid byte or field list"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s {-b byte-list,--bytes=byte-list} [-n] [file...]\n\        %s {-c character-list,--characters=character-list} [file...]\n\        %s {-f field-list,--fields=field-list} [-d delim] [-s]\n\        [--delimiter=delim] [--only-delimited] [file...]\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

