begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* csplit - split a file into sections determined by context lines    Copyright (C) 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Stuart Kemp, cpsrk@groper.jcu.edu.au.    Modified by David MacKenzie, djm@gnu.ai.mit.edu. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_comment
comment|/* XXX need to resolve the conflict in RE_DUP_MAX definitions. */
end_comment

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_define
define|#
directive|define
name|RE_DUP_MAX
value|((1<< 15) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __386BSD__ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|memchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|close_output_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|create_output_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|save_line_to_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Increment size of area for control records. */
end_comment

begin_define
define|#
directive|define
name|ALLOC_SIZE
value|20
end_define

begin_comment
comment|/* The default prefix for output file names. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PREFIX
value|"xx"
end_define

begin_typedef
typedef|typedef
name|int
name|boolean
typedef|;
end_typedef

begin_comment
comment|/* A compiled pattern arg. */
end_comment

begin_struct
struct|struct
name|control
block|{
name|char
modifier|*
name|regexpr
decl_stmt|;
comment|/* Non-compiled regular expression. */
name|struct
name|re_pattern_buffer
name|re_compiled
decl_stmt|;
comment|/* Compiled regular expression. */
name|int
name|offset
decl_stmt|;
comment|/* Offset from regexp to split at. */
name|int
name|lines_required
decl_stmt|;
comment|/* Number of lines required. */
name|int
name|repeat
decl_stmt|;
comment|/* Repeat count. */
name|int
name|argnum
decl_stmt|;
comment|/* ARGV index. */
name|boolean
name|ignore
decl_stmt|;
comment|/* If true, produce no output (for regexp). */
block|}
struct|;
end_struct

begin_comment
comment|/* Initial size of data area in buffers. */
end_comment

begin_define
define|#
directive|define
name|START_SIZE
value|8191
end_define

begin_comment
comment|/* Increment size for data area. */
end_comment

begin_define
define|#
directive|define
name|INCR_SIZE
value|2048
end_define

begin_comment
comment|/* Number of lines kept in each node in line list. */
end_comment

begin_define
define|#
directive|define
name|CTRL_SIZE
value|80
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Some small values to test the algorithms. */
end_comment

begin_define
define|#
directive|define
name|START_SIZE
value|200
end_define

begin_define
define|#
directive|define
name|INCR_SIZE
value|10
end_define

begin_define
define|#
directive|define
name|CTRL_SIZE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A string with a length count. */
end_comment

begin_struct
struct|struct
name|cstring
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pointers to the beginnings of lines in the buffer area.    These structures are linked together if needed. */
end_comment

begin_struct
struct|struct
name|line
block|{
name|unsigned
name|used
decl_stmt|;
comment|/* Number of offsets used in this struct. */
name|unsigned
name|insert_index
decl_stmt|;
comment|/* Next offset to use when inserting line. */
name|unsigned
name|retrieve_index
decl_stmt|;
comment|/* Next index to use when retrieving line. */
name|struct
name|cstring
name|starts
index|[
name|CTRL_SIZE
index|]
decl_stmt|;
comment|/* Lines in the data area. */
name|struct
name|line
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list. */
block|}
struct|;
end_struct

begin_comment
comment|/* The structure to hold the input lines.    Contains a pointer to the data area and a list containing    pointers to the individual lines. */
end_comment

begin_struct
struct|struct
name|buffer_record
block|{
name|unsigned
name|bytes_alloc
decl_stmt|;
comment|/* Size of the buffer area. */
name|unsigned
name|bytes_used
decl_stmt|;
comment|/* Bytes used in the buffer area. */
name|unsigned
name|start_line
decl_stmt|;
comment|/* First line number in this buffer. */
name|unsigned
name|first_available
decl_stmt|;
comment|/* First line that can be retrieved. */
name|unsigned
name|num_lines
decl_stmt|;
comment|/* Number of complete lines in this buffer. */
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Data area. */
name|struct
name|line
modifier|*
name|line_start
decl_stmt|;
comment|/* Head of list of pointers to lines. */
name|struct
name|line
modifier|*
name|curr_line
decl_stmt|;
comment|/* The line start record currently in use. */
name|struct
name|buffer_record
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Input file descriptor. */
end_comment

begin_decl_stmt
name|int
name|input_desc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of available buffers. */
end_comment

begin_decl_stmt
name|struct
name|buffer_record
modifier|*
name|free_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start of buffer list. */
end_comment

begin_decl_stmt
name|struct
name|buffer_record
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Partially read line. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hold_area
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars in `hold_area'. */
end_comment

begin_decl_stmt
name|unsigned
name|hold_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of the last line in the buffers. */
end_comment

begin_decl_stmt
name|unsigned
name|last_line_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of the line currently being examined. */
end_comment

begin_decl_stmt
name|unsigned
name|current_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of the last line in the input file. */
end_comment

begin_decl_stmt
name|unsigned
name|last_line_in_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If TRUE, we have read EOF. */
end_comment

begin_decl_stmt
name|boolean
name|have_read_eof
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of output files. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filename_space
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix part of output file names. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of digits to use in output file names. */
end_comment

begin_decl_stmt
name|int
name|digits
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of files created so far. */
end_comment

begin_decl_stmt
name|unsigned
name|files_created
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes written to current file. */
end_comment

begin_decl_stmt
name|unsigned
name|bytes_written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file pointer. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|output_stream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perhaps it would be cleaner to pass arg values instead of indexes. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|global_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If TRUE, do not print the count of bytes in each output file. */
end_comment

begin_decl_stmt
name|boolean
name|suppress_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If TRUE, remove output files on error. */
end_comment

begin_decl_stmt
name|boolean
name|remove_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiled pattern arguments, which determine how to split    the input file. */
end_comment

begin_decl_stmt
name|struct
name|control
modifier|*
name|controls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in `controls'. */
end_comment

begin_decl_stmt
name|unsigned
name|control_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate N bytes of memory dynamically, with error checking.  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Change the size of an allocated block of memory P to N bytes,    with error checking.    If P is NULL, run xmalloc.    If N is 0, run free and return NULL.  */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|xmalloc
argument_list|(
name|n
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Keep track of NUM chars of a partial line in buffer START.    These chars will be retrieved later when another large buffer is read.    It is not necessary to create a new buffer for these chars; instead,    we keep a pointer to the existing buffer.  This buffer *is* on the    free list, and when the next buffer is obtained from this list    (even if it is this one), these chars will be placed at the    start of the new buffer. */
end_comment

begin_function
name|void
name|save_to_hold_area
parameter_list|(
name|start
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|num
decl_stmt|;
block|{
name|hold_area
operator|=
name|start
expr_stmt|;
name|hold_count
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read up to MAX chars from the input stream into DEST.    Return the number of chars read. */
end_comment

begin_function
name|int
name|read_input
parameter_list|(
name|dest
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|max
decl_stmt|;
block|{
name|int
name|bytes_read
decl_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bytes_read
operator|=
name|read
argument_list|(
name|input_desc
argument_list|,
name|dest
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
name|have_read_eof
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|bytes_read
return|;
block|}
end_function

begin_comment
comment|/* Initialize existing line record P. */
end_comment

begin_function
name|void
name|clear_line_control
parameter_list|(
name|p
parameter_list|)
name|struct
name|line
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|insert_index
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|retrieve_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize all line records in B. */
end_comment

begin_function
name|void
name|clear_all_line_control
parameter_list|(
name|b
parameter_list|)
name|struct
name|buffer_record
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|line
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|b
operator|->
name|line_start
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|clear_line_control
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new, initialized line record. */
end_comment

begin_function
name|struct
name|line
modifier|*
name|new_line_control
parameter_list|()
block|{
name|struct
name|line
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|clear_line_control
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Record LINE_START, which is the address of the start of a line    of length LINE_LEN in the large buffer, in the lines buffer of B. */
end_comment

begin_function
name|void
name|keep_new_line
parameter_list|(
name|b
parameter_list|,
name|line_start
parameter_list|,
name|line_len
parameter_list|)
name|struct
name|buffer_record
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|line_start
decl_stmt|;
name|int
name|line_len
decl_stmt|;
block|{
name|struct
name|line
modifier|*
name|l
decl_stmt|;
comment|/* If there is no existing area to keep line info, get some. */
if|if
condition|(
name|b
operator|->
name|line_start
operator|==
name|NULL
condition|)
name|b
operator|->
name|line_start
operator|=
name|b
operator|->
name|curr_line
operator|=
name|new_line_control
argument_list|()
expr_stmt|;
comment|/* If existing area for lines is full, get more. */
if|if
condition|(
name|b
operator|->
name|curr_line
operator|->
name|used
operator|==
name|CTRL_SIZE
condition|)
block|{
name|b
operator|->
name|curr_line
operator|->
name|next
operator|=
name|new_line_control
argument_list|()
expr_stmt|;
name|b
operator|->
name|curr_line
operator|=
name|b
operator|->
name|curr_line
operator|->
name|next
expr_stmt|;
block|}
name|l
operator|=
name|b
operator|->
name|curr_line
expr_stmt|;
comment|/* Record the start of the line, and update counters. */
name|l
operator|->
name|starts
index|[
name|l
operator|->
name|insert_index
index|]
operator|.
name|str
operator|=
name|line_start
expr_stmt|;
name|l
operator|->
name|starts
index|[
name|l
operator|->
name|insert_index
index|]
operator|.
name|len
operator|=
name|line_len
expr_stmt|;
name|l
operator|->
name|used
operator|++
expr_stmt|;
name|l
operator|->
name|insert_index
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the buffer in B for newline characters    and record the line start locations and lengths in B.    Return the number of lines found in this buffer.     There may be an incomplete line at the end of the buffer;    a pointer is kept to this area, which will be used when    the next buffer is filled. */
end_comment

begin_function
name|unsigned
name|record_line_starts
parameter_list|(
name|b
parameter_list|)
name|struct
name|buffer_record
modifier|*
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|line_start
decl_stmt|;
comment|/* Start of current line. */
name|char
modifier|*
name|line_end
decl_stmt|;
comment|/* End of each line found. */
name|unsigned
name|bytes_left
decl_stmt|;
comment|/* Length of incomplete last line. */
name|unsigned
name|lines
decl_stmt|;
comment|/* Number of lines found. */
name|unsigned
name|line_length
decl_stmt|;
comment|/* Length of each line found. */
if|if
condition|(
name|b
operator|->
name|bytes_used
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lines
operator|=
literal|0
expr_stmt|;
name|line_start
operator|=
name|b
operator|->
name|buffer
expr_stmt|;
name|bytes_left
operator|=
name|b
operator|->
name|bytes_used
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line_end
operator|=
name|memchr
argument_list|(
name|line_start
argument_list|,
literal|'\n'
argument_list|,
name|bytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_end
operator|==
name|NULL
condition|)
break|break;
name|line_length
operator|=
name|line_end
operator|-
name|line_start
operator|+
literal|1
expr_stmt|;
name|keep_new_line
argument_list|(
name|b
argument_list|,
name|line_start
argument_list|,
name|line_length
argument_list|)
expr_stmt|;
name|bytes_left
operator|-=
name|line_length
expr_stmt|;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
name|lines
operator|++
expr_stmt|;
block|}
comment|/* Check for an incomplete last line. */
if|if
condition|(
name|bytes_left
condition|)
block|{
if|if
condition|(
name|have_read_eof
condition|)
block|{
name|keep_new_line
argument_list|(
name|b
argument_list|,
name|line_start
argument_list|,
name|bytes_left
argument_list|)
expr_stmt|;
name|lines
operator|++
expr_stmt|;
name|last_line_in_file
operator|=
name|last_line_number
operator|+
name|lines
expr_stmt|;
block|}
else|else
name|save_to_hold_area
argument_list|(
name|line_start
argument_list|,
name|bytes_left
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|num_lines
operator|=
name|lines
expr_stmt|;
name|b
operator|->
name|first_available
operator|=
name|b
operator|->
name|start_line
operator|=
name|last_line_number
operator|+
literal|1
expr_stmt|;
name|last_line_number
operator|+=
name|lines
expr_stmt|;
return|return
name|lines
return|;
block|}
end_function

begin_comment
comment|/* Return a new buffer with room to store SIZE bytes, plus    an extra byte for safety. */
end_comment

begin_function
name|struct
name|buffer_record
modifier|*
name|create_new_buffer
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|struct
name|buffer_record
modifier|*
name|new_buffer
decl_stmt|;
name|new_buffer
operator|=
operator|(
expr|struct
name|buffer_record
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buffer_record
argument_list|)
argument_list|)
expr_stmt|;
name|new_buffer
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_buffer
operator|->
name|bytes_alloc
operator|=
name|size
expr_stmt|;
name|new_buffer
operator|->
name|line_start
operator|=
name|new_buffer
operator|->
name|curr_line
operator|=
name|NULL
expr_stmt|;
return|return
name|new_buffer
return|;
block|}
end_function

begin_comment
comment|/* Return a new buffer of at least MINSIZE bytes.  If a buffer of at    least that size is currently free, use it, otherwise create a new one. */
end_comment

begin_function
name|struct
name|buffer_record
modifier|*
name|get_new_buffer
parameter_list|(
name|min_size
parameter_list|)
name|unsigned
name|min_size
decl_stmt|;
block|{
name|struct
name|buffer_record
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|buffer_record
modifier|*
name|new_buffer
decl_stmt|;
comment|/* Buffer to return. */
name|unsigned
name|alloc_size
decl_stmt|;
comment|/* Actual size that will be requested. */
name|alloc_size
operator|=
name|START_SIZE
expr_stmt|;
while|while
condition|(
name|min_size
operator|>
name|alloc_size
condition|)
name|alloc_size
operator|+=
name|INCR_SIZE
expr_stmt|;
if|if
condition|(
name|free_list
operator|==
name|NULL
condition|)
name|new_buffer
operator|=
name|create_new_buffer
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Use first-fit to find a buffer. */
name|p
operator|=
name|new_buffer
operator|=
name|NULL
expr_stmt|;
name|q
operator|=
name|free_list
expr_stmt|;
do|do
block|{
if|if
condition|(
name|q
operator|->
name|bytes_alloc
operator|>=
name|min_size
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|free_list
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|p
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|q
condition|)
do|;
name|new_buffer
operator|=
operator|(
name|q
condition|?
name|q
else|:
name|create_new_buffer
argument_list|(
name|alloc_size
argument_list|)
operator|)
expr_stmt|;
name|new_buffer
operator|->
name|curr_line
operator|=
name|new_buffer
operator|->
name|line_start
expr_stmt|;
name|clear_all_line_control
argument_list|(
name|new_buffer
argument_list|)
expr_stmt|;
block|}
name|new_buffer
operator|->
name|num_lines
operator|=
literal|0
expr_stmt|;
name|new_buffer
operator|->
name|bytes_used
operator|=
literal|0
expr_stmt|;
name|new_buffer
operator|->
name|start_line
operator|=
name|new_buffer
operator|->
name|first_available
operator|=
name|last_line_number
operator|+
literal|1
expr_stmt|;
name|new_buffer
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|new_buffer
return|;
block|}
end_function

begin_comment
comment|/* Add buffer BUF to the list of free buffers. */
end_comment

begin_function
name|void
name|free_buffer
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer_record
modifier|*
name|buf
decl_stmt|;
block|{
name|buf
operator|->
name|next
operator|=
name|free_list
expr_stmt|;
name|free_list
operator|=
name|buf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append buffer BUF to the linked list of buffers that contain    some data yet to be processed. */
end_comment

begin_function
name|void
name|save_buffer
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer_record
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|buffer_record
modifier|*
name|p
decl_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|curr_line
operator|=
name|buf
operator|->
name|line_start
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|buf
expr_stmt|;
else|else
block|{
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
comment|/* Do nothing. */
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|buf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill a buffer of input.     Set the initial size of the buffer to a default.    Fill the buffer (from the hold area and input stream)    and find the individual lines.    If no lines are found (the buffer is too small to hold the next line),    release the current buffer (whose contents would have been put in the    hold area) and repeat the process with another large buffer until at least    one entire line has been read.     Return TRUE if a new buffer was obtained, otherwise false    (in which case end-of-file must have been encountered). */
end_comment

begin_function
name|boolean
name|load_buffer
parameter_list|()
block|{
name|struct
name|buffer_record
modifier|*
name|b
decl_stmt|;
name|unsigned
name|bytes_wanted
init|=
name|START_SIZE
decl_stmt|;
comment|/* Minimum buffer size. */
name|unsigned
name|bytes_avail
decl_stmt|;
comment|/* Size of new buffer created. */
name|unsigned
name|lines_found
decl_stmt|;
comment|/* Number of lines in this new buffer. */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Place to load into buffer. */
if|if
condition|(
name|have_read_eof
condition|)
return|return
name|FALSE
return|;
comment|/* We must make the buffer at least as large as the amount of data      in the partial line left over from the last call. */
if|if
condition|(
name|bytes_wanted
operator|<
name|hold_count
condition|)
name|bytes_wanted
operator|=
name|hold_count
expr_stmt|;
do|do
block|{
name|b
operator|=
name|get_new_buffer
argument_list|(
name|bytes_wanted
argument_list|)
expr_stmt|;
name|bytes_avail
operator|=
name|b
operator|->
name|bytes_alloc
expr_stmt|;
comment|/* Size of buffer returned. */
name|p
operator|=
name|b
operator|->
name|buffer
expr_stmt|;
comment|/* First check the `holding' area for a partial line. */
if|if
condition|(
name|hold_count
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|hold_area
condition|)
name|bcopy
argument_list|(
name|hold_area
argument_list|,
name|p
argument_list|,
name|hold_count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hold_count
expr_stmt|;
name|b
operator|->
name|bytes_used
operator|+=
name|hold_count
expr_stmt|;
name|bytes_avail
operator|-=
name|hold_count
expr_stmt|;
name|hold_count
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|bytes_used
operator|+=
operator|(
name|unsigned
operator|)
name|read_input
argument_list|(
name|p
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|lines_found
operator|=
name|record_line_starts
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bytes_wanted
operator|=
name|b
operator|->
name|bytes_alloc
operator|+
name|INCR_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|lines_found
condition|)
name|free_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|lines_found
operator|&&
operator|!
name|have_read_eof
condition|)
do|;
if|if
condition|(
name|lines_found
condition|)
name|save_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|lines_found
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the line number of the first line that has not yet been retrieved. */
end_comment

begin_function
name|unsigned
name|get_first_line_in_buffer
parameter_list|()
block|{
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
operator|!
name|load_buffer
argument_list|()
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"input disappeared"
argument_list|)
expr_stmt|;
return|return
name|head
operator|->
name|first_available
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the logical first line in the buffer and make the     next line the logical first line.    Return NULL if there is no more input. */
end_comment

begin_function
name|struct
name|cstring
modifier|*
name|remove_line
parameter_list|()
block|{
name|struct
name|cstring
modifier|*
name|line
decl_stmt|;
comment|/* Return value. */
name|unsigned
name|line_got
decl_stmt|;
comment|/* Number of the line retrieved. */
name|struct
name|line
modifier|*
name|l
decl_stmt|;
comment|/* For convenience. */
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
operator|!
name|load_buffer
argument_list|()
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|current_line
operator|<
name|head
operator|->
name|first_available
condition|)
name|current_line
operator|=
name|head
operator|->
name|first_available
expr_stmt|;
name|line_got
operator|=
name|head
operator|->
name|first_available
operator|++
expr_stmt|;
name|l
operator|=
name|head
operator|->
name|curr_line
expr_stmt|;
name|line
operator|=
operator|&
name|l
operator|->
name|starts
index|[
name|l
operator|->
name|retrieve_index
index|]
expr_stmt|;
comment|/* Advance index to next line. */
if|if
condition|(
operator|++
name|l
operator|->
name|retrieve_index
operator|==
name|l
operator|->
name|used
condition|)
block|{
comment|/* Go on to the next line record. */
name|head
operator|->
name|curr_line
operator|=
name|l
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|curr_line
operator|==
name|NULL
operator|||
name|head
operator|->
name|curr_line
operator|->
name|used
operator|==
literal|0
condition|)
block|{
comment|/* Go on to the next data block. */
name|struct
name|buffer_record
modifier|*
name|b
init|=
name|head
decl_stmt|;
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/* Search the buffers for line LINENUM, reading more input if necessary.    Return a pointer to the line, or NULL if it is not found in the file. */
end_comment

begin_function
name|struct
name|cstring
modifier|*
name|find_line
parameter_list|(
name|linenum
parameter_list|)
name|unsigned
name|linenum
decl_stmt|;
block|{
name|struct
name|buffer_record
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
operator|!
name|load_buffer
argument_list|()
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|linenum
operator|<
name|head
operator|->
name|start_line
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|b
operator|=
name|head
init|;
condition|;
control|)
block|{
if|if
condition|(
name|linenum
operator|<
name|b
operator|->
name|start_line
operator|+
name|b
operator|->
name|num_lines
condition|)
block|{
comment|/* The line is in this buffer. */
name|struct
name|line
modifier|*
name|l
decl_stmt|;
name|unsigned
name|offset
decl_stmt|;
comment|/* How far into the buffer the line is. */
name|l
operator|=
name|b
operator|->
name|line_start
expr_stmt|;
name|offset
operator|=
name|linenum
operator|-
name|b
operator|->
name|start_line
expr_stmt|;
comment|/* Find the control record. */
while|while
condition|(
name|offset
operator|>=
name|CTRL_SIZE
condition|)
block|{
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|offset
operator|-=
name|CTRL_SIZE
expr_stmt|;
block|}
return|return
operator|&
name|l
operator|->
name|starts
index|[
name|offset
index|]
return|;
block|}
if|if
condition|(
name|b
operator|->
name|next
operator|==
name|NULL
operator|&&
operator|!
name|load_buffer
argument_list|()
condition|)
return|return
name|NULL
return|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
comment|/* Try the next data block. */
block|}
block|}
end_function

begin_comment
comment|/* Return TRUE if at least one more line is available for input. */
end_comment

begin_function
name|boolean
name|no_more_lines
parameter_list|()
block|{
return|return
operator|(
name|find_line
argument_list|(
name|current_line
operator|+
literal|1
argument_list|)
operator|==
name|NULL
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Set the name of the input file to NAME and open it. */
end_comment

begin_function
name|void
name|set_input_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|input_desc
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|input_desc
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_desc
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write all lines from the beginning of the buffer up to, but    not including, line LAST_LINE, to the current output file.    If IGNORE is TRUE, do not output lines selected here.    ARGNUM is the index in ARGV of the current pattern. */
end_comment

begin_function
name|void
name|write_to_file
parameter_list|(
name|last_line
parameter_list|,
name|ignore
parameter_list|,
name|argnum
parameter_list|)
name|unsigned
name|last_line
decl_stmt|;
name|boolean
name|ignore
decl_stmt|;
name|int
name|argnum
decl_stmt|;
block|{
name|struct
name|cstring
modifier|*
name|line
decl_stmt|;
name|unsigned
name|first_line
decl_stmt|;
comment|/* First available input line. */
name|unsigned
name|lines
decl_stmt|;
comment|/* Number of lines to output. */
name|unsigned
name|i
decl_stmt|;
name|first_line
operator|=
name|get_first_line_in_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|first_line
operator|>
name|last_line
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: line number out of range"
argument_list|,
name|global_argv
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|lines
operator|=
name|last_line
operator|-
name|first_line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|line
operator|=
name|remove_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: line number out of range"
argument_list|,
name|global_argv
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ignore
condition|)
name|save_line_to_file
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output any lines left after all regexps have been processed. */
end_comment

begin_function
name|void
name|dump_rest_of_file
parameter_list|()
block|{
name|struct
name|cstring
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|remove_line
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
name|save_line_to_file
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an attempt to read beyond EOF under the control of record P,    on iteration REPETITION if nonzero. */
end_comment

begin_function
name|void
name|handle_line_error
parameter_list|(
name|p
parameter_list|,
name|repetition
parameter_list|)
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|int
name|repetition
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: `%d': line number out of range"
argument_list|,
name|program_name
argument_list|,
name|p
operator|->
name|lines_required
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" on repetition %d\n"
argument_list|,
name|repetition
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the line number that marks the end of this file,    then get those lines and save them to the output file.    P is the control record.    REPETITION is the repetition number. */
end_comment

begin_function
name|void
name|process_line_count
parameter_list|(
name|p
parameter_list|,
name|repetition
parameter_list|)
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|int
name|repetition
decl_stmt|;
block|{
name|unsigned
name|linenum
decl_stmt|;
name|unsigned
name|last_line_to_save
init|=
name|p
operator|->
name|lines_required
operator|*
operator|(
name|repetition
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|cstring
modifier|*
name|line
decl_stmt|;
name|create_output_file
argument_list|()
expr_stmt|;
name|linenum
operator|=
name|get_first_line_in_buffer
argument_list|()
expr_stmt|;
comment|/* Check for requesting a line that has already been written out.      If this ever happens, it's due to a bug in csplit. */
if|if
condition|(
name|linenum
operator|>=
name|last_line_to_save
condition|)
name|handle_line_error
argument_list|(
name|p
argument_list|,
name|repetition
argument_list|)
expr_stmt|;
while|while
condition|(
name|linenum
operator|++
operator|<
name|last_line_to_save
condition|)
block|{
name|line
operator|=
name|remove_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|handle_line_error
argument_list|(
name|p
argument_list|,
name|repetition
argument_list|)
expr_stmt|;
name|save_line_to_file
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|close_output_file
argument_list|()
expr_stmt|;
comment|/* Ensure that the line number specified is not 1 greater than      the number of lines in the file. */
if|if
condition|(
name|no_more_lines
argument_list|()
condition|)
name|handle_line_error
argument_list|(
name|p
argument_list|,
name|repetition
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|regexp_error
parameter_list|(
name|p
parameter_list|,
name|repetition
parameter_list|,
name|ignore
parameter_list|)
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|int
name|repetition
decl_stmt|;
name|boolean
name|ignore
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: `%s': match not found"
argument_list|,
name|program_name
argument_list|,
name|global_argv
index|[
name|p
operator|->
name|argnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|repetition
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" on repetition %d\n"
argument_list|,
name|repetition
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
block|{
name|dump_rest_of_file
argument_list|()
expr_stmt|;
name|close_output_file
argument_list|()
expr_stmt|;
block|}
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the input until a line matches the regexp in P, outputting    it unless P->IGNORE is TRUE.    REPETITION is this repeat-count; 0 means the first time. */
end_comment

begin_function
name|void
name|process_regexp
parameter_list|(
name|p
parameter_list|,
name|repetition
parameter_list|)
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|int
name|repetition
decl_stmt|;
block|{
name|struct
name|cstring
modifier|*
name|line
decl_stmt|;
comment|/* From input file. */
specifier|register
name|unsigned
name|line_len
decl_stmt|;
comment|/* To make "$" in regexps work. */
name|unsigned
name|break_line
decl_stmt|;
comment|/* First line number of next file. */
name|boolean
name|ignore
init|=
name|p
operator|->
name|ignore
decl_stmt|;
comment|/* If TRUE, skip this section. */
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
name|create_output_file
argument_list|()
expr_stmt|;
comment|/* If there is no offset for the regular expression, or      it is positive, then it is not necessary to buffer the lines. */
if|if
condition|(
name|p
operator|->
name|offset
operator|>=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
operator|=
name|find_line
argument_list|(
operator|++
name|current_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|regexp_error
argument_list|(
name|p
argument_list|,
name|repetition
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|line_len
operator|=
name|line
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|str
index|[
name|line_len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line_len
operator|--
expr_stmt|;
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|p
operator|->
name|re_compiled
argument_list|,
name|line
operator|->
name|str
argument_list|,
name|line_len
argument_list|,
literal|0
argument_list|,
name|line_len
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"error in regular expression search"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|line
operator|=
name|remove_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
name|save_line_to_file
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
else|else
block|{
comment|/* Buffer the lines. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
operator|=
name|find_line
argument_list|(
operator|++
name|current_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|regexp_error
argument_list|(
name|p
argument_list|,
name|repetition
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|line_len
operator|=
name|line
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|str
index|[
name|line_len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line_len
operator|--
expr_stmt|;
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|p
operator|->
name|re_compiled
argument_list|,
name|line
operator|->
name|str
argument_list|,
name|line_len
argument_list|,
literal|0
argument_list|,
name|line_len
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"error in regular expression search"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* Account for any offset from this regexp. */
name|break_line
operator|=
name|current_line
operator|+
name|p
operator|->
name|offset
expr_stmt|;
name|write_to_file
argument_list|(
name|break_line
argument_list|,
name|ignore
argument_list|,
name|p
operator|->
name|argnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
name|close_output_file
argument_list|()
expr_stmt|;
name|current_line
operator|=
name|break_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split the input file according to the control records we have built. */
end_comment

begin_function
name|void
name|split_file
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|control_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|controls
index|[
name|i
index|]
operator|.
name|regexpr
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|controls
index|[
name|i
index|]
operator|.
name|repeat
condition|;
name|j
operator|++
control|)
name|process_regexp
argument_list|(
operator|&
name|controls
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|controls
index|[
name|i
index|]
operator|.
name|repeat
condition|;
name|j
operator|++
control|)
name|process_line_count
argument_list|(
operator|&
name|controls
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
name|create_output_file
argument_list|()
expr_stmt|;
name|dump_rest_of_file
argument_list|()
expr_stmt|;
name|close_output_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of output file number NUM. */
end_comment

begin_function
name|char
modifier|*
name|make_filename
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|filename_space
argument_list|,
literal|"%s%0*d"
argument_list|,
name|prefix
argument_list|,
name|digits
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|filename_space
return|;
block|}
end_function

begin_comment
comment|/* Create the next output file. */
end_comment

begin_function
name|void
name|create_output_file
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|make_filename
argument_list|(
name|files_created
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|files_created
operator|++
expr_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files we have created. */
end_comment

begin_function
name|void
name|delete_all_files
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_created
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|make_filename
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Close the current output file and print the count    of characters in this file. */
end_comment

begin_function
name|void
name|close_output_file
parameter_list|()
block|{
if|if
condition|(
name|output_stream
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|output_stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|suppress_count
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d\n"
argument_list|,
name|bytes_written
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Optionally remove files created so far; then exit.    Called when an error detected. */
end_comment

begin_function
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|output_stream
condition|)
name|close_output_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|remove_files
condition|)
name|delete_all_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save line LINE to the output file and    increment the character count for the current file. */
end_comment

begin_function
name|void
name|save_line_to_file
parameter_list|(
name|line
parameter_list|)
name|struct
name|cstring
modifier|*
name|line
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|line
operator|->
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|line
operator|->
name|len
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
name|bytes_written
operator|+=
name|line
operator|->
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new, initialized control record. */
end_comment

begin_function
name|struct
name|control
modifier|*
name|new_control_record
parameter_list|()
block|{
specifier|static
name|unsigned
name|control_allocated
init|=
literal|0
decl_stmt|;
comment|/* Total space allocated. */
specifier|register
name|struct
name|control
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|control_allocated
operator|==
literal|0
condition|)
block|{
name|control_allocated
operator|=
name|ALLOC_SIZE
expr_stmt|;
name|controls
operator|=
operator|(
expr|struct
name|control
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|control
argument_list|)
operator|*
name|control_allocated
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control_used
operator|==
name|control_allocated
condition|)
block|{
name|control_allocated
operator|+=
name|ALLOC_SIZE
expr_stmt|;
name|controls
operator|=
operator|(
expr|struct
name|control
operator|*
operator|)
name|xrealloc
argument_list|(
name|controls
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|control
argument_list|)
operator|*
name|control_allocated
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|controls
index|[
name|control_used
operator|++
index|]
expr_stmt|;
name|p
operator|->
name|regexpr
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|repeat
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|lines_required
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Convert string NUM to an integer and put the value in *RESULT.    Return a TRUE if the string consists entirely of digits,    FALSE if not. */
end_comment

begin_function
name|boolean
name|string_to_number
parameter_list|(
name|result
parameter_list|,
name|num
parameter_list|)
name|int
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
block|{
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|num
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|ch
operator|=
operator|*
name|num
operator|++
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|val
operator|=
name|val
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check if there is a numeric offset after a regular expression.    STR is the entire command line argument.    ARGNUM is the index in ARGV of STR.    P is the control record for this regular expression.    NUM is the numeric part of STR. */
end_comment

begin_function
name|void
name|check_for_offset
parameter_list|(
name|argnum
parameter_list|,
name|p
parameter_list|,
name|str
parameter_list|,
name|num
parameter_list|)
name|int
name|argnum
decl_stmt|;
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|num
operator|!=
literal|'-'
operator|&&
operator|*
name|num
operator|!=
literal|'+'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: `+' or `-' expected after delimeter"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|string_to_number
argument_list|(
operator|&
name|p
operator|->
name|offset
argument_list|,
name|num
operator|+
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: integer expected after `%c'"
argument_list|,
name|str
argument_list|,
operator|*
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|num
operator|==
literal|'-'
condition|)
name|p
operator|->
name|offset
operator|=
operator|-
name|p
operator|->
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that the first character of command line arg STR is '{',    make sure that the rest of the string is a valid repeat count    and store its value in P.    ARGNUM is the ARGV index of STR. */
end_comment

begin_function
name|void
name|parse_repeat_count
parameter_list|(
name|argnum
parameter_list|,
name|p
parameter_list|,
name|str
parameter_list|)
name|int
name|argnum
decl_stmt|;
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'}'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: `}' is required in repeat count"
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|string_to_number
argument_list|(
operator|&
name|p
operator|->
name|repeat
argument_list|,
name|str
operator|+
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s}: integer required between `{' and `}'"
argument_list|,
name|global_argv
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'}'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract the regular expression from STR and check for a numeric offset.    STR should start with the regexp delimiter character.    Return a new control record for the regular expression.    ARGNUM is the ARGV index of STR.    Unless IGNORE is TRUE, mark these lines for output. */
end_comment

begin_function
name|struct
name|control
modifier|*
name|extract_regexp
parameter_list|(
name|argnum
parameter_list|,
name|ignore
parameter_list|,
name|str
parameter_list|)
name|int
name|argnum
decl_stmt|;
name|boolean
name|ignore
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
comment|/* Number of chars in this regexp. */
name|char
name|delim
init|=
operator|*
name|str
decl_stmt|;
name|char
modifier|*
name|closing_delim
decl_stmt|;
name|struct
name|control
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
name|closing_delim
operator|=
name|rindex
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|closing_delim
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: closing delimeter `%c' missing"
argument_list|,
name|str
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|len
operator|=
name|closing_delim
operator|-
name|str
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|new_control_record
argument_list|()
expr_stmt|;
name|p
operator|->
name|argnum
operator|=
name|argnum
expr_stmt|;
name|p
operator|->
name|ignore
operator|=
name|ignore
expr_stmt|;
name|p
operator|->
name|regexpr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|regexpr
argument_list|,
name|str
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|re_compiled
operator|.
name|allocated
operator|=
name|len
operator|*
literal|2
expr_stmt|;
name|p
operator|->
name|re_compiled
operator|.
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|p
operator|->
name|re_compiled
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|p
operator|->
name|re_compiled
operator|.
name|fastmap
operator|=
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|p
operator|->
name|re_compiled
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
name|err
operator|=
operator|(
name|char
operator|*
operator|)
name|re_compile_pattern
argument_list|(
name|p
operator|->
name|regexpr
argument_list|,
name|len
argument_list|,
operator|&
name|p
operator|->
name|re_compiled
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: invalid regular expression: %s"
argument_list|,
name|str
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|closing_delim
index|[
literal|1
index|]
condition|)
name|check_for_offset
argument_list|(
name|argnum
argument_list|,
name|p
argument_list|,
name|str
argument_list|,
name|closing_delim
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Extract the break patterns from args START through ARGC - 1 of ARGV.    After each pattern, check if the next argument is a repeat count. */
end_comment

begin_function
name|void
name|parse_patterns
parameter_list|(
name|argc
parameter_list|,
name|start
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|int
name|start
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Index into ARGV. */
name|struct
name|control
modifier|*
name|p
decl_stmt|;
comment|/* New control record created. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'/'
operator|||
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
name|p
operator|=
name|extract_regexp
argument_list|(
name|i
argument_list|,
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'%'
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|new_control_record
argument_list|()
expr_stmt|;
name|p
operator|->
name|argnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|string_to_number
argument_list|(
operator|&
name|p
operator|->
name|lines_required
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: invalid pattern"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|argc
operator|&&
operator|*
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|/* We have a repeat count. */
name|i
operator|++
expr_stmt|;
name|parse_repeat_count
argument_list|(
name|i
argument_list|,
name|p
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|interrupt_handler
parameter_list|()
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"interrupted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"digits"
block|,
literal|1
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"silent"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"keep-files"
block|,
literal|0
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"prefix"
block|,
literal|1
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optc
decl_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|struct
name|sigaction
name|oldact
decl_stmt|,
name|newact
decl_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|global_argv
operator|=
name|argv
expr_stmt|;
name|controls
operator|=
name|NULL
expr_stmt|;
name|control_used
operator|=
literal|0
expr_stmt|;
name|suppress_count
operator|=
name|FALSE
expr_stmt|;
name|remove_files
operator|=
name|TRUE
expr_stmt|;
name|prefix
operator|=
name|DEFAULT_PREFIX
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|newact
operator|.
name|sa_handler
operator|=
name|interrupt_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|newact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_POSIX_VERSION */
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:kn:s"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'f'
case|:
name|prefix
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|remove_files
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|string_to_number
argument_list|(
operator|&
name|digits
argument_list|,
name|optarg
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: invalid number"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|suppress_count
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|>=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|filename_space
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|digits
operator|+
literal|2
argument_list|)
expr_stmt|;
name|set_input_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|parse_patterns
argument_list|(
name|argc
argument_list|,
name|optind
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|split_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|input_desc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-sk] [-f prefix] [-n digits] [--prefix=prefix]\n\        [--digits=digits] [--quiet] [--silent] [--keep-files] file pattern...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

