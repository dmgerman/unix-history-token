begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* split.c -- split a file into pieces.    Copyright (C) 1988, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* By tege@sics.se, with rms.     To do:    * Implement -t CHAR or -t REGEX to specify break characters other      than newline. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|convint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isdigits
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|stdread
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|line_bytes_split
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bytes_split
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cwrite
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lines_split
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|next_file_name
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base name of output files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the end of the prefix in OUTFILE.    Suffixes are inserted here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outfile_mid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the end of OUTFILE. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outfile_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status for outfile name generation.  */
end_comment

begin_decl_stmt
name|unsigned
name|outfile_count
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|outfile_name_limit
init|=
literal|25
operator|*
literal|26
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|outfile_name_generation
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of input file.  May be "-".  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor on which input file is open.  */
end_comment

begin_decl_stmt
name|int
name|input_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor on which output file is open.  */
end_comment

begin_decl_stmt
name|int
name|output_desc
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|usage
parameter_list|(
name|reason
parameter_list|)
name|char
modifier|*
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-lines] [-l lines] [-b bytes[bkm]] [-C bytes[bkm]]\n\        [--lines=lines] [--bytes=bytes[bkm]] [--line-bytes=bytes[bkm]]\n\        [infile [outfile-prefix]]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"bytes"
block|,
literal|1
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"lines"
block|,
literal|1
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"line-bytes"
block|,
literal|1
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* numeric argument from command line */
enum|enum
block|{
name|type_undef
block|,
name|type_bytes
block|,
name|type_byteslines
block|,
name|type_lines
block|,
name|type_digits
block|}
name|split_type
init|=
name|type_undef
enum|;
name|int
name|in_blk_size
decl_stmt|;
comment|/* optimal block size of input file device */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* file i/o buffer */
name|int
name|accum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|outbase
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|digits_optind
init|=
literal|0
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Parse command line options.  */
name|infile
operator|=
literal|"-"
expr_stmt|;
name|outbase
operator|=
literal|"x"
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* This is the argv-index of the option we will read next.  */
name|int
name|this_optind
init|=
name|optind
condition|?
name|optind
else|:
literal|1
decl_stmt|;
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789b:l:C:"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|split_type
operator|!=
name|type_undef
condition|)
name|usage
argument_list|(
literal|"cannot split in more than one way"
argument_list|)
expr_stmt|;
name|split_type
operator|=
name|type_bytes
expr_stmt|;
if|if
condition|(
name|convint
argument_list|(
name|optarg
argument_list|,
operator|&
name|accum
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
literal|"invalid number of bytes"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|split_type
operator|!=
name|type_undef
condition|)
name|usage
argument_list|(
literal|"cannot split in more than one way"
argument_list|)
expr_stmt|;
name|split_type
operator|=
name|type_lines
expr_stmt|;
if|if
condition|(
operator|!
name|isdigits
argument_list|(
name|optarg
argument_list|)
condition|)
name|usage
argument_list|(
literal|"invalid number of lines"
argument_list|)
expr_stmt|;
name|accum
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|split_type
operator|!=
name|type_undef
condition|)
name|usage
argument_list|(
literal|"cannot split in more than one way"
argument_list|)
expr_stmt|;
name|split_type
operator|=
name|type_byteslines
expr_stmt|;
if|if
condition|(
name|convint
argument_list|(
name|optarg
argument_list|,
operator|&
name|accum
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
literal|"invalid number of bytes"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|split_type
operator|!=
name|type_undef
operator|&&
name|split_type
operator|!=
name|type_digits
condition|)
name|usage
argument_list|(
literal|"cannot split in more than one way"
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits_optind
operator|!=
literal|0
operator|&&
name|digits_optind
operator|!=
name|this_optind
condition|)
name|accum
operator|=
literal|0
expr_stmt|;
comment|/* More than one number given; ignore other. */
name|digits_optind
operator|=
name|this_optind
expr_stmt|;
name|split_type
operator|=
name|type_digits
expr_stmt|;
name|accum
operator|=
name|accum
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle default case.  */
if|if
condition|(
name|split_type
operator|==
name|type_undef
condition|)
block|{
name|split_type
operator|=
name|type_lines
expr_stmt|;
name|accum
operator|=
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|accum
operator|<
literal|1
condition|)
name|usage
argument_list|(
literal|"invalid number"
argument_list|)
expr_stmt|;
name|num
operator|=
name|accum
expr_stmt|;
comment|/* Get out the filename arguments.  */
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|infile
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|outbase
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|usage
argument_list|(
literal|"too many arguments"
argument_list|)
expr_stmt|;
comment|/* Open the input file.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|infile
argument_list|,
literal|"-"
argument_list|)
condition|)
name|input_desc
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|input_desc
operator|=
name|open
argument_list|(
name|infile
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_desc
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
block|}
comment|/* No output file is open now.  */
name|output_desc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Copy the output file prefix so we can add suffixes to it.      26**29 is certainly enough output files!  */
name|outfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|outbase
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|outfile
argument_list|,
name|outbase
argument_list|)
expr_stmt|;
name|outfile_mid
operator|=
name|outfile
operator|+
name|strlen
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|outfile_end
operator|=
name|outfile_mid
operator|+
literal|2
expr_stmt|;
name|bzero
argument_list|(
name|outfile_mid
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|outfile_mid
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
name|outfile_mid
index|[
literal|1
index|]
operator|=
literal|'a'
operator|-
literal|1
expr_stmt|;
comment|/* first call to next_file_name makes it an 'a' */
comment|/* Get the optimal block size of input device and make a buffer.  */
if|if
condition|(
name|fstat
argument_list|(
name|input_desc
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|in_blk_size
operator|=
name|ST_BLKSIZE
argument_list|(
name|stat_buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|in_blk_size
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|split_type
condition|)
block|{
case|case
name|type_digits
case|:
case|case
name|type_lines
case|:
name|lines_split
argument_list|(
name|num
argument_list|,
name|buf
argument_list|,
name|in_blk_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|type_bytes
case|:
name|bytes_split
argument_list|(
name|num
argument_list|,
name|buf
argument_list|,
name|in_blk_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|type_byteslines
case|:
name|line_bytes_split
argument_list|(
name|num
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|close
argument_list|(
name|input_desc
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_desc
operator|>=
literal|0
operator|&&
name|close
argument_list|(
name|output_desc
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the string STR is composed entirely of decimal digits.  */
end_comment

begin_function
name|int
name|isdigits
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
name|str
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|str
condition|)
do|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put the value of the number in STR into *VAL.    STR can specify a positive integer, optionally ending in `k'    to mean kilo or `m' to mean mega.    Return 0 if STR is valid, -1 if not. */
end_comment

begin_function
name|int
name|convint
parameter_list|(
name|str
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|{
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|int
name|arglen
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|arglen
operator|>
literal|1
condition|)
block|{
switch|switch
condition|(
name|str
index|[
name|arglen
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|multiplier
operator|=
literal|512
expr_stmt|;
name|str
index|[
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|multiplier
operator|=
literal|1024
expr_stmt|;
name|str
index|[
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|multiplier
operator|=
literal|1048576
expr_stmt|;
name|str
index|[
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isdigits
argument_list|(
name|str
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|val
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
operator|*
name|multiplier
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split into pieces of exactly NCHARS bytes.    Use buffer BUF, whose size is BUFSIZE.  */
end_comment

begin_function
name|void
name|bytes_split
parameter_list|(
name|nchars
parameter_list|,
name|buf
parameter_list|,
name|bufsize
parameter_list|)
name|int
name|nchars
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
block|{
name|int
name|n_read
decl_stmt|;
name|int
name|new_file_flag
init|=
literal|1
decl_stmt|;
name|int
name|to_read
decl_stmt|;
name|int
name|to_write
init|=
name|nchars
decl_stmt|;
name|char
modifier|*
name|bp_out
decl_stmt|;
do|do
block|{
name|n_read
operator|=
name|stdread
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|bp_out
operator|=
name|buf
expr_stmt|;
name|to_read
operator|=
name|n_read
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|to_read
operator|<
name|to_write
condition|)
block|{
if|if
condition|(
name|to_read
condition|)
comment|/* do not write 0 bytes! */
block|{
name|cwrite
argument_list|(
name|new_file_flag
argument_list|,
name|bp_out
argument_list|,
name|to_read
argument_list|)
expr_stmt|;
name|to_write
operator|-=
name|to_read
expr_stmt|;
name|new_file_flag
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|cwrite
argument_list|(
name|new_file_flag
argument_list|,
name|bp_out
argument_list|,
name|to_write
argument_list|)
expr_stmt|;
name|bp_out
operator|+=
name|to_write
expr_stmt|;
name|to_read
operator|-=
name|to_write
expr_stmt|;
name|new_file_flag
operator|=
literal|1
expr_stmt|;
name|to_write
operator|=
name|nchars
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|n_read
operator|==
name|bufsize
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split into pieces of exactly NLINES lines.    Use buffer BUF, whose size is BUFSIZE.  */
end_comment

begin_function
name|void
name|lines_split
parameter_list|(
name|nlines
parameter_list|,
name|buf
parameter_list|,
name|bufsize
parameter_list|)
name|int
name|nlines
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
block|{
name|int
name|n_read
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp_out
decl_stmt|,
modifier|*
name|eob
decl_stmt|;
name|int
name|new_file_flag
init|=
literal|1
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
do|do
block|{
name|n_read
operator|=
name|stdread
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bp_out
operator|=
name|buf
expr_stmt|;
name|eob
operator|=
name|bp
operator|+
name|n_read
expr_stmt|;
operator|*
name|eob
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|bp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* this semicolon takes most of the time */
if|if
condition|(
name|bp
operator|>
name|eob
condition|)
block|{
if|if
condition|(
name|eob
operator|!=
name|bp_out
condition|)
comment|/* do not write 0 bytes! */
block|{
name|cwrite
argument_list|(
name|new_file_flag
argument_list|,
name|bp_out
argument_list|,
name|eob
operator|-
name|bp_out
argument_list|)
expr_stmt|;
name|new_file_flag
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|++
name|n
operator|>=
name|nlines
condition|)
block|{
name|cwrite
argument_list|(
name|new_file_flag
argument_list|,
name|bp_out
argument_list|,
name|bp
operator|-
name|bp_out
argument_list|)
expr_stmt|;
name|bp_out
operator|=
name|bp
expr_stmt|;
name|new_file_flag
operator|=
literal|1
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|n_read
operator|==
name|bufsize
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split into pieces that are as large as possible while still not more    than NCHARS bytes, and are split on line boundaries except    where lines longer than NCHARS bytes occur. */
end_comment

begin_function
name|void
name|line_bytes_split
parameter_list|(
name|nchars
parameter_list|)
name|int
name|nchars
decl_stmt|;
block|{
name|int
name|n_read
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|eof
init|=
literal|0
decl_stmt|;
name|int
name|n_buffered
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nchars
argument_list|)
decl_stmt|;
do|do
block|{
comment|/* Fill up the full buffer size from the input file.  */
name|n_read
operator|=
name|stdread
argument_list|(
name|buf
operator|+
name|n_buffered
argument_list|,
name|nchars
operator|-
name|n_buffered
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|n_buffered
operator|+=
name|n_read
expr_stmt|;
if|if
condition|(
name|n_buffered
operator|!=
name|nchars
condition|)
name|eof
operator|=
literal|1
expr_stmt|;
comment|/* Find where to end this chunk.  */
name|bp
operator|=
name|buf
operator|+
name|n_buffered
expr_stmt|;
if|if
condition|(
name|n_buffered
operator|==
name|nchars
condition|)
block|{
while|while
condition|(
name|bp
operator|>
name|buf
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|bp
operator|--
expr_stmt|;
block|}
comment|/* If chunk has no newlines, use all the chunk.  */
if|if
condition|(
name|bp
operator|==
name|buf
condition|)
name|bp
operator|=
name|buf
operator|+
name|n_buffered
expr_stmt|;
comment|/* Output the chars as one output file.  */
name|cwrite
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|bp
operator|-
name|buf
argument_list|)
expr_stmt|;
comment|/* Discard the chars we just output; move rest of chunk 	 down to be the start of the next chunk.  */
name|n_buffered
operator|-=
name|bp
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|n_buffered
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|,
name|n_buffered
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write BYTES bytes at BP to an output file.    If NEW_FILE_FLAG is nonzero, open the next output file.    Otherwise add to the same output file already in use.  */
end_comment

begin_function
name|void
name|cwrite
parameter_list|(
name|new_file_flag
parameter_list|,
name|bp
parameter_list|,
name|bytes
parameter_list|)
name|int
name|new_file_flag
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
if|if
condition|(
name|new_file_flag
condition|)
block|{
if|if
condition|(
name|output_desc
operator|>=
literal|0
operator|&&
name|close
argument_list|(
name|output_desc
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|next_file_name
argument_list|()
expr_stmt|;
name|output_desc
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_desc
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|output_desc
argument_list|,
name|bp
argument_list|,
name|bytes
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read NCHARS bytes from the input file into BUF.    Return the number of bytes successfully read.    If this is less than NCHARS, do not call `stdread' again.  */
end_comment

begin_function
name|int
name|stdread
parameter_list|(
name|buf
parameter_list|,
name|nchars
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nchars
decl_stmt|;
block|{
name|int
name|n_read
decl_stmt|;
name|int
name|to_be_read
init|=
name|nchars
decl_stmt|;
while|while
condition|(
name|to_be_read
condition|)
block|{
name|n_read
operator|=
name|read
argument_list|(
name|input_desc
argument_list|,
name|buf
argument_list|,
name|to_be_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n_read
operator|==
literal|0
condition|)
break|break;
name|to_be_read
operator|-=
name|n_read
expr_stmt|;
name|buf
operator|+=
name|n_read
expr_stmt|;
block|}
return|return
name|nchars
operator|-
name|to_be_read
return|;
block|}
end_function

begin_comment
comment|/* Compute the next sequential output file name suffix and store it    into the string `outfile' at the position pointed to by `outfile_mid'.  */
end_comment

begin_function
name|void
name|next_file_name
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|ne
decl_stmt|;
name|outfile_count
operator|++
expr_stmt|;
if|if
condition|(
name|outfile_count
operator|<
name|outfile_name_limit
condition|)
block|{
for|for
control|(
name|ne
operator|=
name|outfile_end
operator|-
literal|1
init|;
condition|;
name|ne
operator|--
control|)
block|{
name|x
operator|=
operator|*
name|ne
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|'z'
condition|)
break|break;
operator|*
name|ne
operator|=
literal|'a'
expr_stmt|;
block|}
operator|*
name|ne
operator|=
name|x
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|outfile_count
operator|=
literal|0
expr_stmt|;
name|outfile_name_limit
operator|*=
literal|26
expr_stmt|;
name|outfile_name_generation
operator|++
expr_stmt|;
operator|*
name|outfile_mid
operator|++
operator|=
literal|'z'
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|outfile_name_generation
condition|;
name|x
operator|++
control|)
name|outfile_mid
index|[
name|x
index|]
operator|=
literal|'a'
expr_stmt|;
name|outfile_end
operator|+=
literal|2
expr_stmt|;
block|}
end_function

end_unit

