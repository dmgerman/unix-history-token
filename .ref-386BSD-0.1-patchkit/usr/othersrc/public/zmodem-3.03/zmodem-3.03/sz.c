begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|VERSION
value|"sz 3.03 5-09-89"
end_define

begin_define
define|#
directive|define
name|PUBDIR
value|"/usr/spool/uucppublic"
end_define

begin_comment
comment|/*% cc -compat -M2 -Ox -K -i -DTXBSIZE=16384  -DNFGVMIN -DREADCHECK sz.c -lx -o sz; size sz  /*% cc -Zi -DXX -DNFGVMIN -DREADCHECK sz.c -lx -o xsz; size xsz<-xtx-*> cc -Osal -DTXBSIZE=32768  -DSV sz.c -lx -o $B/sz; size $B/sz   ****************************************************************************  *  * sz.c By Chuck Forsberg,  Omen Technology INC  *  ****************************************************************************  *  * Typical Unix/Xenix/Clone compiles:  *  *	cc -O sz.c -o sz		USG (SYS III/V) Unix  *	cc -O -DSV sz.c -o sz		Sys V Release 2 with non-blocking input  *					Define to allow reverse channel checking  *	cc -O -DV7  sz.c -o sz		Unix Version 7, 2.8 - 4.3 BSD  *  *	cc -O -K -i -DNFGVMIN -DREADCHECK sz.c -lx -o sz	Classic Xenix  *  *	ln sz sb			**** All versions ****  *	ln sz sx			**** All versions ****  *  ****************************************************************************  *  * Typical VMS compile and install sequence:  *  *		define LNK$LIBRARY   SYS$LIBRARY:VAXCRTL.OLB  *		cc sz.c  *		cc vvmodem.c  *		link sz,vvmodem  *	sz :== $disk$user2:[username.subdir]sz.exe  *  *  If you feel adventureous, remove the #define BADSEEK line  *  immediately following the #ifdef vax11c line!  Some VMS  *  systems know how to fseek, some don't.  *  ****************************************************************************  *  *  * A program for Unix to send files and commands to computers running  *  Professional-YAM, PowerCom, YAM, IMP, or programs supporting Y/XMODEM.  *  *  Sz uses buffered I/O to greatly reduce CPU time compared to UMODEM.  *  *  USG UNIX (3.0) ioctl conventions courtesy Jeff Martin  *  *	This version implements ZMODEM Run Length Encoding, Comparision,  *	and variable length headers.  These features were not funded  *	by the original Telenet development contract.  This software,  *	including these features, may be freely used for non  *	commercial and educational purposes.  This software may also  *	be freely used to support file transfer operations to or from  *	licensed Omen Technology products.  Contact Omen Technology  *	for licensing for other uses.  Any programs which use part or  *	all of this software must be provided in source form with this  *	notice intact except by written permission from Omen  *	Technology Incorporated.  *  *		Omen Technology Inc		FAX: 503-621-3745  *		Post Office Box 4681  *		Portland OR 97208  *  *	Previous versions of this program (not containing the extensions  *	listed above) remain in the public domain.  *  *	This code is made available in the hope it will be useful,  *	BUT WITHOUT ANY WARRANTY OF ANY KIND OR LIABILITY FOR ANY  *	DAMAGES OF ANY KIND.  *  *  2.1x hacks to avoid VMS fseek() bogosity, allow input from pipe  *     -DBADSEEK -DTXBSIZE=32768    *  2.x has mods for VMS flavor  *  * 1.34 implements tx backchannel garbage count and ZCRCW after ZRPOS  * in accordance with the 7-31-87 ZMODEM Protocol Description  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XX
end_ifdef

begin_define
define|#
directive|define
name|XARGSFILE
value|"args"
end_define

begin_decl_stmt
name|long
name|Thisflen
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|substr
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_define
define|#
directive|define
name|STATIC
end_define

begin_define
define|#
directive|define
name|BADSEEK
end_define

begin_define
define|#
directive|define
name|TXBSIZE
value|32768
end_define

begin_comment
comment|/* Must be power of two,< MAXINT */
end_comment

begin_include
include|#
directive|include
file|<types.h>
end_include

begin_include
include|#
directive|include
file|<stat.h>
end_include

begin_define
define|#
directive|define
name|STAT
end_define

begin_define
define|#
directive|define
name|LOGFILE
value|"szlog.tmp"
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|OS
value|"VMS"
end_define

begin_define
define|#
directive|define
name|ROPMODE
value|"r"
end_define

begin_define
define|#
directive|define
name|READCHECK
end_define

begin_define
define|#
directive|define
name|BUFWRITE
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SS_NORMAL
value|SS$_NORMAL
end_define

begin_define
define|#
directive|define
name|xsendline
parameter_list|(
name|c
parameter_list|)
value|sendline(c)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PROGNAME
end_ifndef

begin_define
define|#
directive|define
name|PROGNAME
value|"sz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* vax11c */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GENIE
end_ifdef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_define
define|#
directive|define
name|LOGFILE
value|"szlog"
end_define

begin_define
define|#
directive|define
name|BADSEEK
end_define

begin_define
define|#
directive|define
name|TXBSIZE
value|32768
end_define

begin_comment
comment|/* Must be power of two,< MAXINT */
end_comment

begin_define
define|#
directive|define
name|OS
value|"GEnie"
end_define

begin_define
define|#
directive|define
name|SS_NORMAL
value|0
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<fildes.h>
end_include

begin_decl_stmt
name|FILDES
name|fdes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Binfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Thisflen
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sendline
parameter_list|(
name|c
parameter_list|)
value|putchar(c& 0377)
end_define

begin_define
define|#
directive|define
name|xsendline
parameter_list|(
name|c
parameter_list|)
value|putchar(c)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* GENIE */
end_comment

begin_define
define|#
directive|define
name|LOGFILE
value|"/tmp/szlog"
end_define

begin_define
define|#
directive|define
name|SS_NORMAL
value|0
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STATIC
end_define

begin_define
define|#
directive|define
name|sendline
parameter_list|(
name|c
parameter_list|)
value|putchar(c& 0377)
end_define

begin_define
define|#
directive|define
name|xsendline
parameter_list|(
name|c
parameter_list|)
value|putchar(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PATHLEN
value|256
end_define

begin_define
define|#
directive|define
name|OK
value|0
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TRUE
end_ifdef

begin_undef
undef|#
directive|undef
name|TRUE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|ERROR
value|(-1)
end_define

begin_comment
comment|/* Ward Christensen / CP/M parameters - Don't change these! */
end_comment

begin_define
define|#
directive|define
name|ENQ
value|005
end_define

begin_define
define|#
directive|define
name|CAN
value|('X'&037)
end_define

begin_define
define|#
directive|define
name|XOFF
value|('s'&037)
end_define

begin_define
define|#
directive|define
name|XON
value|('q'&037)
end_define

begin_define
define|#
directive|define
name|SOH
value|1
end_define

begin_define
define|#
directive|define
name|STX
value|2
end_define

begin_define
define|#
directive|define
name|EOT
value|4
end_define

begin_define
define|#
directive|define
name|ACK
value|6
end_define

begin_define
define|#
directive|define
name|NAK
value|025
end_define

begin_define
define|#
directive|define
name|CPMEOF
value|032
end_define

begin_define
define|#
directive|define
name|WANTCRC
value|0103
end_define

begin_comment
comment|/* send C not NAK to get crc not checksum */
end_comment

begin_define
define|#
directive|define
name|WANTG
value|0107
end_define

begin_comment
comment|/* Send G not NAK to get nonstop batch xmsn */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT
value|(-2)
end_define

begin_define
define|#
directive|define
name|RCDO
value|(-3)
end_define

begin_define
define|#
directive|define
name|GCOUNT
value|(-4)
end_define

begin_define
define|#
directive|define
name|RETRYMAX
value|10
end_define

begin_define
define|#
directive|define
name|HOWMANY
value|2
end_define

begin_decl_stmt
name|STATIC
name|int
name|Zmodem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ZMODEM protocol requested by receiver */
end_comment

begin_decl_stmt
name|unsigned
name|Baudrate
init|=
literal|4800
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default, set by first mode() call */
end_comment

begin_decl_stmt
name|STATIC
name|unsigned
name|Effbaud
init|=
literal|4800
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|unsigned
name|Txwindow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control the size of the transmitted window */
end_comment

begin_decl_stmt
name|STATIC
name|unsigned
name|Txwspac
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spacing between zcrcq requests */
end_comment

begin_decl_stmt
name|STATIC
name|unsigned
name|Txwcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter used to space ack requests */
end_comment

begin_decl_stmt
name|STATIC
name|long
name|Lrxpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receiver's last reported offset */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_include
include|#
directive|include
file|"vrzsz.c"
end_include

begin_comment
comment|/* most of the system dependent stuff here */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|GENIE
end_ifdef

begin_include
include|#
directive|include
file|"genie.c"
end_include

begin_comment
comment|/* most of the system dependent stuff here */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"rbsb.c"
end_include

begin_comment
comment|/* most of the system dependent stuff here */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XX
end_ifdef

begin_undef
undef|#
directive|undef
name|STAT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"crctab.c"
end_include

begin_decl_stmt
name|STATIC
name|int
name|Filesleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|Totalleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attention string to be executed by receiver to interrupt streaming data  *  when an error is detected.  A pause (0336) may be needed before the  *  ^C (03) or after it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|READCHECK
end_ifdef

begin_decl_stmt
name|STATIC
name|char
name|Myattn
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_decl_stmt
name|STATIC
name|char
name|Myattn
index|[]
init|=
block|{
literal|03
block|,
literal|0336
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|GENIE
end_ifndef

begin_decl_stmt
name|STATIC
name|char
name|Myattn
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|FILE
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BADSEEK
end_ifdef

begin_decl_stmt
name|STATIC
name|int
name|Canseek
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1: Can seek 0: only rewind -1: neither (pipe) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TXBSIZE
end_ifndef

begin_define
define|#
directive|define
name|TXBSIZE
value|16384
end_define

begin_comment
comment|/* Must be power of two,< MAXINT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|STATIC
name|int
name|Canseek
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1: Can seek 0: only rewind -1: neither (pipe) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TXBSIZE
end_ifdef

begin_define
define|#
directive|define
name|TXBMASK
value|(TXBSIZE-1)
end_define

begin_decl_stmt
name|STATIC
name|char
name|Txb
index|[
name|TXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Circular buffer for file reads */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|txbuf
init|=
name|Txb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to current file segment */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|STATIC
name|char
name|txbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|long
name|vpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes read from file */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|Lastrx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|Crcflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Modem2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XMODEM Protocol - don't send pathnames */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Restricted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* restricted; no /.. or ../ in filenames */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* overrides logic that would otherwise set verbose */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Ascii
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add CR's for brain damaged programs */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Fullname
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* transmit full pathname */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Unlinkafter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unlink file after it is sent */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Dottoslash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Change foo.bar.baz to foo/bar/baz */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|firstsec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|errcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files unreadable */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|blklen
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of transmitted records */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Optiong
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Let it rip no wait for sector ACK's */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Eofseen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF seen on input set by zfilbuf */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|BEofseen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF seen on input set by fooseek */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Totsecs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of sectors this file */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Filcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of number of files opened */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Lfseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|unsigned
name|Rxbuflen
init|=
literal|16384
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receiver's max buffer length */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Tframlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Override for tx frame length */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|blkopt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Override value for zmodem blklen */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Rxflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|bytcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Wantfcs32
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* want to send 32 bit FCS */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|Lzconv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local ZMODEM file conversion request */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|Lzmanag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local ZMODEM file management request */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Lskipnocor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|Lztrans
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send a command, then exit. */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Cmdstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the command string */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Cmdtries
init|=
literal|11
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Cmdack1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rx ACKs command, then do it */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Exitcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Test
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1= Force receiver to send Attn, etc with qbf. */
end_comment

begin_comment
comment|/* 2= Character transparency test */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|qbf
init|=
literal|"The quick brown fox jumped over the lazy dog's back 1234567890\r\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|Lastsync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last offset to which we got a ZRPOS */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Beenhereb4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many times we've been ZRPOS'd same place */
end_comment

begin_decl_stmt
name|STATIC
name|jmp_buf
name|tohere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For the interrupt on RX timeout */
end_comment

begin_decl_stmt
name|STATIC
name|jmp_buf
name|intrjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For the interrupt on RX CAN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XARGSFILE
end_ifdef

begin_function
name|char
modifier|*
name|mystrsave
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No memory for mystrsave!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove (presumably) terminating CR and/or LF from string */
end_comment

begin_expr_stmt
name|uncrlf
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* called by signal interrupt or terminate to clean things up */
end_comment

begin_function
name|SIGTYPE
name|bibi
parameter_list|(
name|n
parameter_list|)
block|{
name|canit
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sz: caught signal %d; exiting\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GENIE
if|if
condition|(
name|n
operator|==
name|SIGQUIT
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|99
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode(2) in rbsb.c not implemented!!\n"
argument_list|)
expr_stmt|;
name|cucheck
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|128
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when ZMODEM gets an interrupt (^X) */
end_comment

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|intrjmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|STATIC
name|int
name|Zctlesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Encode control characters */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|Nozmodem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If invoked as "sb" */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Progname
init|=
literal|"sz"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|Zrwindow
init|=
literal|1400
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RX window size (controls garbage count) */
end_comment

begin_include
include|#
directive|include
file|"zm.c"
end_include

begin_include
include|#
directive|include
file|"zmr.c"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XARGSFILE
end_ifdef

begin_define
define|#
directive|define
name|XARGSMAX
value|256
end_define

begin_decl_stmt
name|char
modifier|*
name|xargv
index|[
name|XARGSMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|npats
expr_stmt|;
name|int
name|dm
decl_stmt|;
name|char
modifier|*
modifier|*
name|patts
decl_stmt|;
specifier|static
name|char
name|xXbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"ZNULLS"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|)
name|Znulls
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|&&
operator|(
name|substr
argument_list|(
name|cp
argument_list|,
literal|"rsh"
argument_list|)
operator|||
name|substr
argument_list|(
name|cp
argument_list|,
literal|"rksh"
argument_list|)
operator|)
condition|)
name|Restricted
operator|=
name|TRUE
expr_stmt|;
name|from_cu
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|vax11c
name|chkinvok
argument_list|(
name|PROGNAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|chkinvok
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Rxtimeout
operator|=
literal|600
expr_stmt|;
name|npats
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|xXbuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argc
condition|)
block|{
name|cp
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'-'
operator|&&
operator|*
name|cp
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
name|Lzmanag
operator|=
name|ZMAPND
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CSTOPB
case|case
literal|'2'
case|:
name|Twostop
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'a'
case|:
name|Lzconv
operator|=
name|ZCNL
expr_stmt|;
name|Ascii
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|Lzconv
operator|=
name|ZCBIN
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Cmdtries
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|Cmdack1
operator|=
name|ZCACK1
expr_stmt|;
comment|/* **** FALL THROUGH TO **** */
case|case
literal|'c'
case|:
if|if
condition|(
operator|--
name|argc
operator|!=
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Command
operator|=
name|TRUE
expr_stmt|;
name|Cmdstr
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|Dottoslash
expr_stmt|;
comment|/* **** FALL THROUGH TO **** */
case|case
literal|'f'
case|:
name|Fullname
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|Zctlesc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|blklen
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|blkopt
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkopt
operator|<
literal|24
operator|||
name|blkopt
operator|>
literal|1024
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Tframlen
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tframlen
operator|<
literal|32
operator|||
name|Tframlen
operator|>
literal|1024
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|Lzmanag
operator|=
name|ZMNEWL
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|Lzmanag
operator|=
name|ZMNEW
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|Wantfcs32
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|Lzmanag
operator|=
name|ZMPROT
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|Lzconv
operator|==
name|ZCRESUM
condition|)
name|Lzmanag
operator|=
operator|(
name|Lzmanag
operator|&
name|ZMMASK
operator|)
operator||
name|ZMCRC
expr_stmt|;
name|Lzconv
operator|=
name|ZCRESUM
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|Quiet
operator|=
name|TRUE
expr_stmt|;
name|Verbose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Rxtimeout
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rxtimeout
operator|<
literal|10
operator|||
name|Rxtimeout
operator|>
literal|1000
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|++
name|Test
operator|>
literal|1
condition|)
block|{
name|chartest
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|chartest
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|vax11c
case|case
literal|'u'
case|:
operator|++
name|Unlinkafter
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'v'
case|:
operator|++
name|Verbose
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Txwindow
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Txwindow
operator|<
literal|256
condition|)
name|Txwindow
operator|=
literal|256
expr_stmt|;
name|Txwindow
operator|=
operator|(
name|Txwindow
operator|/
literal|64
operator|)
operator|*
literal|64
expr_stmt|;
name|Txwspac
operator|=
name|Txwindow
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|blkopt
operator|>
name|Txwspac
operator|||
operator|(
operator|!
name|blkopt
operator|&&
name|Txwspac
operator|<
literal|1024
operator|)
condition|)
name|blkopt
operator|=
name|Txwspac
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
operator|++
name|Modem2
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|Lskipnocor
operator|=
name|TRUE
expr_stmt|;
comment|/* **** FALLL THROUGH TO **** */
case|case
literal|'y'
case|:
name|Lzmanag
operator|=
name|ZMCLOB
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
case|case
literal|'z'
case|:
name|Lztrans
operator|=
name|ZTRLE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|npats
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
name|npats
operator|=
name|argc
expr_stmt|;
name|patts
operator|=
name|argv
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|npats
operator|<
literal|1
operator|&&
operator|!
name|Command
operator|&&
operator|!
name|Test
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
name|LOGFILE
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Can't open log file %s\n"
argument_list|,
name|LOGFILE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0200
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Fromcu
operator|&&
operator|!
name|Quiet
condition|)
block|{
if|if
condition|(
name|Verbose
operator|==
literal|0
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
block|}
name|vfile
argument_list|(
literal|"%s %s for %s\n"
argument_list|,
name|Progname
argument_list|,
name|VERSION
argument_list|,
name|OS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XARGSFILE
name|vfile
argument_list|(
literal|"npats=%d *patts=%s"
argument_list|,
name|npats
argument_list|,
operator|*
name|patts
argument_list|)
expr_stmt|;
if|if
condition|(
name|npats
operator|==
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|XARGSFILE
argument_list|,
operator|*
name|patts
argument_list|)
condition|)
block|{
name|in
operator|=
name|fopen
argument_list|(
name|XARGSFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|printf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open / control file!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|npats
operator|=
literal|0
operator|,
name|argv
operator|=
name|patts
operator|=
name|xargv
init|;
name|npats
operator|<
name|XARGSMAX
condition|;
operator|++
name|npats
operator|,
operator|++
name|argv
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|txbuf
argument_list|,
literal|1024
argument_list|,
name|in
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|uncrlf
argument_list|(
name|txbuf
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|=
name|mystrsave
argument_list|(
name|txbuf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GENIE
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|bibi
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGKILL
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|bibi
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGKILL
argument_list|,
name|bibi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
if|if
condition|(
operator|!
name|Fromcu
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|bibi
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|Modem2
condition|)
block|{
if|if
condition|(
operator|!
name|Nozmodem
condition|)
block|{
name|printf
argument_list|(
literal|"rz\r"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|countem
argument_list|(
name|npats
argument_list|,
name|patts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Nozmodem
condition|)
block|{
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|Command
condition|)
name|Txhdr
index|[
name|ZF0
index|]
operator|=
name|ZCOMMAND
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZRQINIT
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|Command
condition|)
block|{
if|if
condition|(
name|getzrxinit
argument_list|()
condition|)
block|{
name|Exitcode
operator|=
literal|0200
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zsendcmd
argument_list|(
name|Cmdstr
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|Cmdstr
argument_list|)
argument_list|)
condition|)
block|{
name|Exitcode
operator|=
literal|0200
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wcsend
argument_list|(
name|npats
argument_list|,
name|patts
argument_list|)
operator|==
name|ERROR
condition|)
block|{
name|Exitcode
operator|=
literal|0200
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dm
operator|=
operator|(
operator|(
name|errcnt
operator|!=
literal|0
operator|)
operator||
name|Exitcode
operator|)
expr_stmt|;
if|if
condition|(
name|dm
condition|)
block|{
name|cucheck
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|SS_NORMAL
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_macro
name|wcsend
argument_list|(
argument|argc
argument_list|,
argument|argp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argp
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
name|Crcflg
operator|=
name|FALSE
expr_stmt|;
name|firstsec
operator|=
name|TRUE
expr_stmt|;
name|bytcnt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Nozmodem
condition|)
block|{
name|printf
argument_list|(
literal|"Start your YMODEM receive. "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|argc
condition|;
operator|++
name|n
control|)
block|{
name|Totsecs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wcs
argument_list|(
name|argp
index|[
name|n
index|]
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
block|}
name|Totsecs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Filcnt
operator|==
literal|0
condition|)
block|{
comment|/* bitch if we couldn't open ANY files */
if|if
condition|(
operator|!
name|Nozmodem
operator|&&
operator|!
name|Modem2
condition|)
block|{
name|Command
operator|=
name|TRUE
expr_stmt|;
name|Cmdstr
operator|=
literal|"echo \"sz: Can't open any requested files\""
expr_stmt|;
if|if
condition|(
name|getnak
argument_list|()
condition|)
block|{
name|Exitcode
operator|=
literal|0200
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Zmodem
condition|)
name|canit
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|zsendcmd
argument_list|(
name|Cmdstr
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|Cmdstr
argument_list|)
argument_list|)
condition|)
block|{
name|Exitcode
operator|=
literal|0200
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
block|}
name|Exitcode
operator|=
literal|1
expr_stmt|;
return|return
name|OK
return|;
block|}
name|canit
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nCan't open any requested files.\r\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
if|if
condition|(
name|Zmodem
condition|)
name|saybibi
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Modem2
condition|)
name|wctxpn
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_macro
name|wcs
argument_list|(
argument|oname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|STAT
name|struct
name|stat
name|f
decl_stmt|;
endif|#
directive|endif
name|char
name|name
index|[
name|PATHLEN
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|oname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XARGSFILE
comment|/* Parse GEniename:REALname:length pathname syntax */
name|Thisflen
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|oname
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
operator|++
name|p
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|Thisflen
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GENIE
name|_describe
argument_list|(
name|oname
argument_list|,
operator|&
name|fdes
argument_list|)
expr_stmt|;
comment|/* An undocumented goodie */
if|if
condition|(
name|fdes
operator|.
name|type_file
operator|==
literal|1
condition|)
block|{
comment|/* Fortran Sequential Binary */
name|Binfile
operator|=
literal|1
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|oname
argument_list|,
literal|"rB"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdes
operator|.
name|type_file
operator|==
literal|0
condition|)
block|{
comment|/* Ascii */
name|Binfile
operator|=
literal|0
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|oname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not a SL filetype */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUnknown file type %d\n"
argument_list|,
name|fdes
operator|.
name|type_file
argument_list|)
expr_stmt|;
operator|++
name|errcnt
expr_stmt|;
return|return
name|OK
return|;
comment|/* pass over it, there may be others */
block|}
else|#
directive|else
if|if
condition|(
name|Restricted
condition|)
block|{
comment|/* restrict pathnames to current tree or uucppublic */
if|if
condition|(
name|substr
argument_list|(
name|name
argument_list|,
literal|"../"
argument_list|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|PUBDIR
argument_list|,
name|strlen
argument_list|(
name|PUBDIR
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|canit
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nsz:\tSecurity Violation\r\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
block|}
name|in
operator|=
name|fopen
argument_list|(
name|oname
argument_list|,
name|ROPMODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
return|return
name|OK
return|;
comment|/* pass over it, there may be others */
block|}
name|BEofseen
operator|=
name|Eofseen
operator|=
literal|0
expr_stmt|;
name|vpos
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STAT
comment|/* Check for directory or block special files */
name|fstat
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|f
operator|.
name|st_mode
operator|&
name|S_IFMT
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|S_IFDIR
operator|||
name|c
operator|==
name|S_IFBLK
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
endif|#
directive|endif
operator|++
name|Filcnt
expr_stmt|;
switch|switch
condition|(
name|wctxpn
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
name|ERROR
case|:
return|return
name|ERROR
return|;
case|case
name|ZSKIP
case|:
return|return
name|OK
return|;
block|}
ifdef|#
directive|ifdef
name|STAT
if|if
condition|(
operator|!
name|Zmodem
operator|&&
name|wctx
argument_list|(
name|f
operator|.
name|st_size
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|Zmodem
operator|&&
name|wctx
argument_list|(
literal|1000000000L
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|vax11c
ifndef|#
directive|ifndef
name|GENIE
if|if
condition|(
name|Unlinkafter
condition|)
name|unlink
argument_list|(
name|oname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * generate and transmit pathname block consisting of  *  pathname (null terminated),  *  file length, mode time and file mode in octal  *  as provided by the Unix fstat call.  *  N.B.: modifies the passed name, may extend it!  */
end_comment

begin_macro
name|wctxpn
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|name2
index|[
name|PATHLEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|STAT
name|struct
name|stat
name|f
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Modem2
condition|)
block|{
ifdef|#
directive|ifdef
name|STAT
if|if
condition|(
operator|*
name|name
operator|&&
name|fstat
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
operator|&
name|f
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sending %s, %ld XMODEM blocks. "
argument_list|,
name|name
argument_list|,
operator|(
literal|127
operator|+
name|f
operator|.
name|st_size
operator|)
operator|>>
literal|7
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Give your local XMODEM receive command now.\r\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|zperr
argument_list|(
literal|"Awaiting pathname nak for %s"
argument_list|,
operator|*
name|name
condition|?
name|name
else|:
literal|"<END>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Zmodem
condition|)
if|if
condition|(
name|getnak
argument_list|()
condition|)
return|return
name|ERROR
return|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|Dottoslash
condition|)
block|{
comment|/* change . to . */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|q
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
operator|(
name|q
operator|=
name|p
operator|)
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|&&
name|strlen
argument_list|(
operator|++
name|q
argument_list|)
operator|>
literal|8
condition|)
block|{
comment|/* If name>8 chars */
name|q
operator|+=
literal|8
expr_stmt|;
comment|/*   make it .ext */
name|strcpy
argument_list|(
name|name2
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* save excess of name */
operator|*
name|q
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
operator|++
name|q
argument_list|,
name|name2
argument_list|)
expr_stmt|;
comment|/* add it back */
block|}
block|}
for|for
control|(
name|p
operator|=
name|name
operator|,
name|q
operator|=
name|txbuf
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|(
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'/'
operator|&&
operator|!
name|Fullname
condition|)
name|q
operator|=
name|txbuf
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
name|q
operator|<
operator|(
name|txbuf
operator|+
literal|1024
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
block|{
ifdef|#
directive|ifdef
name|XX
if|if
condition|(
name|Thisflen
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%u 0 0 0 %d %ld"
argument_list|,
name|Thisflen
argument_list|,
name|Filesleft
argument_list|,
name|Totalleft
argument_list|)
expr_stmt|;
name|Totalleft
operator|-=
name|Thisflen
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GENIE
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|fdes
operator|.
name|current_file_size
operator|*
literal|1260
argument_list|)
expr_stmt|;
name|vfile
argument_list|(
literal|"%s open Binfile=%d size=%ld"
argument_list|,
name|name
argument_list|,
name|Binfile
argument_list|,
name|fdes
operator|.
name|current_file_size
operator|*
literal|1260
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STAT
ifndef|#
directive|ifndef
name|XX
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
operator|&
name|f
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%lu %lo %o 0 %d %ld"
argument_list|,
name|f
operator|.
name|st_size
argument_list|,
name|f
operator|.
name|st_mtime
argument_list|,
name|f
operator|.
name|st_mode
argument_list|,
name|Filesleft
argument_list|,
name|Totalleft
argument_list|)
expr_stmt|;
name|Totalleft
operator|-=
name|f
operator|.
name|st_size
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
operator|--
name|Filesleft
operator|<=
literal|0
condition|)
name|Totalleft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Totalleft
operator|<
literal|0
condition|)
name|Totalleft
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STAT
comment|/* force 1k blocks if name won't fit in 128 byte block */
if|if
condition|(
name|txbuf
index|[
literal|125
index|]
condition|)
name|blklen
operator|=
literal|1024
expr_stmt|;
else|else
block|{
comment|/* A little goodie for IMP/KMD */
name|txbuf
index|[
literal|127
index|]
operator|=
operator|(
name|f
operator|.
name|st_size
operator|+
literal|127
operator|)
operator|>>
literal|7
expr_stmt|;
name|txbuf
index|[
literal|126
index|]
operator|=
operator|(
name|f
operator|.
name|st_size
operator|+
literal|127
operator|)
operator|>>
literal|15
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|Zmodem
condition|)
return|return
name|zsendfile
argument_list|(
name|txbuf
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
operator|(
name|p
operator|-
name|txbuf
operator|)
argument_list|)
return|;
if|if
condition|(
name|wcputsec
argument_list|(
name|txbuf
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
return|return
name|OK
return|;
block|}
end_block

begin_macro
name|getnak
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|firstch
expr_stmt|;
name|Lastrx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|firstch
operator|=
name|readline
argument_list|(
literal|800
argument_list|)
condition|)
block|{
case|case
name|ZPAD
case|:
if|if
condition|(
name|getzrxinit
argument_list|()
condition|)
return|return
name|ERROR
return|;
name|Ascii
operator|=
literal|0
expr_stmt|;
comment|/* Receiver does the conversion */
return|return
name|FALSE
return|;
case|case
name|TIMEOUT
case|:
name|zperr
argument_list|(
literal|"Timeout on pathname"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|WANTG
case|:
ifdef|#
directive|ifdef
name|MODE2OK
name|mode
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Set cbreak, XON/XOFF, etc. */
endif|#
directive|endif
name|Optiong
operator|=
name|TRUE
expr_stmt|;
name|blklen
operator|=
literal|1024
expr_stmt|;
case|case
name|WANTCRC
case|:
name|Crcflg
operator|=
name|TRUE
expr_stmt|;
case|case
name|NAK
case|:
return|return
name|FALSE
return|;
case|case
name|CAN
case|:
if|if
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
literal|20
argument_list|)
operator|)
operator|==
name|CAN
operator|&&
name|Lastrx
operator|==
name|CAN
condition|)
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
name|Lastrx
operator|=
name|firstch
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|wctx
argument_list|(
argument|flen
argument_list|)
end_macro

begin_decl_stmt
name|long
name|flen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|thisblklen
decl_stmt|;
specifier|register
name|int
name|sectnum
decl_stmt|,
name|attempts
decl_stmt|,
name|firstch
decl_stmt|;
name|long
name|charssent
decl_stmt|;
name|charssent
operator|=
literal|0
expr_stmt|;
name|firstsec
operator|=
name|TRUE
expr_stmt|;
name|thisblklen
operator|=
name|blklen
expr_stmt|;
name|vfile
argument_list|(
literal|"wctx:file length=%ld"
argument_list|,
name|flen
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
name|Rxtimeout
argument_list|)
operator|)
operator|!=
name|NAK
operator|&&
name|firstch
operator|!=
name|WANTCRC
operator|&&
name|firstch
operator|!=
name|WANTG
operator|&&
name|firstch
operator|!=
name|TIMEOUT
operator|&&
name|firstch
operator|!=
name|CAN
condition|)
empty_stmt|;
if|if
condition|(
name|firstch
operator|==
name|CAN
condition|)
block|{
name|zperr
argument_list|(
literal|"Receiver CANcelled"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
if|if
condition|(
name|firstch
operator|==
name|WANTCRC
condition|)
name|Crcflg
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|firstch
operator|==
name|WANTG
condition|)
name|Crcflg
operator|=
name|TRUE
expr_stmt|;
name|sectnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|flen
operator|<=
operator|(
name|charssent
operator|+
literal|896L
operator|)
condition|)
name|thisblklen
operator|=
literal|128
expr_stmt|;
if|if
condition|(
operator|!
name|filbuf
argument_list|(
name|txbuf
argument_list|,
name|thisblklen
argument_list|)
condition|)
break|break;
if|if
condition|(
name|wcputsec
argument_list|(
name|txbuf
argument_list|,
operator|++
name|sectnum
argument_list|,
name|thisblklen
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
name|charssent
operator|+=
name|thisblklen
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|attempts
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|purgeline
argument_list|()
expr_stmt|;
name|sendline
argument_list|(
name|EOT
argument_list|)
expr_stmt|;
name|flushmo
argument_list|()
expr_stmt|;
operator|++
name|attempts
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|firstch
operator|=
operator|(
name|readline
argument_list|(
name|Rxtimeout
argument_list|)
operator|)
operator|!=
name|ACK
operator|)
operator|&&
name|attempts
operator|<
name|RETRYMAX
condition|)
do|;
if|if
condition|(
name|attempts
operator|==
name|RETRYMAX
condition|)
block|{
name|zperr
argument_list|(
literal|"No ACK on EOT"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
else|else
return|return
name|OK
return|;
block|}
end_block

begin_macro
name|wcputsec
argument_list|(
argument|buf
argument_list|,
argument|sectnum
argument_list|,
argument|cseclen
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sectnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cseclen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data length of this sector to send */
end_comment

begin_block
block|{
specifier|register
name|checksum
operator|,
name|wcj
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|oldcrc
decl_stmt|;
name|int
name|firstch
decl_stmt|;
name|int
name|attempts
decl_stmt|;
name|firstch
operator|=
literal|0
expr_stmt|;
comment|/* part of logic to detect CAN CAN */
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sector %3d %2dk\n"
argument_list|,
name|Totsecs
argument_list|,
name|Totsecs
operator|/
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\rSector %3d %2dk "
argument_list|,
name|Totsecs
argument_list|,
name|Totsecs
operator|/
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|attempts
operator|=
literal|0
init|;
name|attempts
operator|<=
name|RETRYMAX
condition|;
name|attempts
operator|++
control|)
block|{
name|Lastrx
operator|=
name|firstch
expr_stmt|;
name|sendline
argument_list|(
name|cseclen
operator|==
literal|1024
condition|?
name|STX
else|:
name|SOH
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|sectnum
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
operator|-
name|sectnum
operator|-
literal|1
argument_list|)
expr_stmt|;
name|oldcrc
operator|=
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|wcj
operator|=
name|cseclen
operator|,
name|cp
operator|=
name|buf
init|;
operator|--
name|wcj
operator|>=
literal|0
condition|;
control|)
block|{
name|sendline
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|oldcrc
operator|=
name|updcrc
argument_list|(
operator|(
literal|0377
operator|&
operator|*
name|cp
operator|)
argument_list|,
name|oldcrc
argument_list|)
expr_stmt|;
name|checksum
operator|+=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Crcflg
condition|)
block|{
name|oldcrc
operator|=
name|updcrc
argument_list|(
literal|0
argument_list|,
name|updcrc
argument_list|(
literal|0
argument_list|,
name|oldcrc
argument_list|)
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
operator|(
name|int
operator|)
name|oldcrc
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
operator|(
name|int
operator|)
name|oldcrc
argument_list|)
expr_stmt|;
block|}
else|else
name|sendline
argument_list|(
name|checksum
argument_list|)
expr_stmt|;
name|flushmo
argument_list|()
expr_stmt|;
if|if
condition|(
name|Optiong
condition|)
block|{
name|firstsec
operator|=
name|FALSE
expr_stmt|;
return|return
name|OK
return|;
block|}
name|firstch
operator|=
name|readline
argument_list|(
name|Rxtimeout
argument_list|)
expr_stmt|;
name|gotnak
label|:
switch|switch
condition|(
name|firstch
condition|)
block|{
case|case
name|CAN
case|:
if|if
condition|(
name|Lastrx
operator|==
name|CAN
condition|)
block|{
name|cancan
label|:
name|zperr
argument_list|(
literal|"Cancelled"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
break|break;
case|case
name|TIMEOUT
case|:
name|zperr
argument_list|(
literal|"Timeout on sector ACK"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|WANTCRC
case|:
if|if
condition|(
name|firstsec
condition|)
name|Crcflg
operator|=
name|TRUE
expr_stmt|;
case|case
name|NAK
case|:
name|zperr
argument_list|(
literal|"NAK on sector"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ACK
case|:
name|firstsec
operator|=
name|FALSE
expr_stmt|;
name|Totsecs
operator|+=
operator|(
name|cseclen
operator|>>
literal|7
operator|)
expr_stmt|;
return|return
name|OK
return|;
case|case
name|ERROR
case|:
name|zperr
argument_list|(
literal|"Got burst for sector ACK"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zperr
argument_list|(
literal|"Got %02x for sector ACK"
argument_list|,
name|firstch
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|Lastrx
operator|=
name|firstch
expr_stmt|;
if|if
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
name|Rxtimeout
argument_list|)
operator|)
operator|==
name|TIMEOUT
condition|)
break|break;
if|if
condition|(
name|firstch
operator|==
name|NAK
operator|||
name|firstch
operator|==
name|WANTCRC
condition|)
goto|goto
name|gotnak
goto|;
if|if
condition|(
name|firstch
operator|==
name|CAN
operator|&&
name|Lastrx
operator|==
name|CAN
condition|)
goto|goto
name|cancan
goto|;
block|}
block|}
name|zperr
argument_list|(
literal|"Retry Count Exceeded"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
end_block

begin_comment
comment|/* fill buf with count chars padding with ^Z for CPM */
end_comment

begin_expr_stmt
name|filbuf
argument_list|(
name|buf
argument_list|,
name|count
argument_list|)
specifier|register
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|Ascii
condition|)
block|{
name|m
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|m
operator|<
name|count
condition|)
name|buf
index|[
name|m
operator|++
index|]
operator|=
literal|032
expr_stmt|;
return|return
name|count
return|;
block|}
name|m
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|Lfseen
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|012
expr_stmt|;
operator|--
name|m
expr_stmt|;
name|Lfseen
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|012
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|015
expr_stmt|;
if|if
condition|(
operator|--
name|m
operator|==
literal|0
condition|)
block|{
name|Lfseen
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|--
name|m
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|count
condition|)
return|return
literal|0
return|;
else|else
while|while
condition|(
operator|--
name|m
operator|>=
literal|0
condition|)
operator|*
name|buf
operator|++
operator|=
name|CPMEOF
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/* Fill buffer with blklen chars */
end_comment

begin_macro
name|zfilbuf
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|TXBSIZE
name|vfile
argument_list|(
literal|"zfilbuf: bytcnt =%lu vpos=%lu blklen=%d"
argument_list|,
name|bytcnt
argument_list|,
name|vpos
argument_list|,
name|blklen
argument_list|)
expr_stmt|;
comment|/* We assume request is within buffer, or just beyond */
name|txbuf
operator|=
name|Txb
operator|+
operator|(
name|bytcnt
operator|&
name|TXBMASK
operator|)
expr_stmt|;
if|if
condition|(
name|vpos
operator|<=
name|bytcnt
condition|)
block|{
ifdef|#
directive|ifdef
name|GENIE
if|if
condition|(
name|Binfile
condition|)
block|{
name|long
name|l
decl_stmt|,
name|m
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|txbuf
operator|,
name|n
operator|=
literal|0
operator|,
name|l
operator|=
name|blklen
init|;
name|l
condition|;
name|l
operator|-=
literal|128
operator|,
name|p
operator|+=
literal|128
control|)
block|{
name|n
operator|+=
name|m
operator|=
name|fgetb
argument_list|(
name|p
argument_list|,
literal|128
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
endif|#
directive|endif
name|n
operator|=
name|fread
argument_list|(
name|txbuf
argument_list|,
literal|1
argument_list|,
name|blklen
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|blklen
condition|)
name|Eofseen
operator|=
literal|1
expr_stmt|;
name|vfile
argument_list|(
literal|"zfilbuf: n=%d vpos=%lu Eofseen=%d"
argument_list|,
name|n
argument_list|,
name|vpos
argument_list|,
name|Eofseen
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
if|if
condition|(
name|vpos
operator|>=
operator|(
name|bytcnt
operator|+
name|blklen
operator|)
condition|)
return|return
name|blklen
return|;
comment|/* May be a short block if crash recovery etc. */
name|Eofseen
operator|=
name|BEofseen
expr_stmt|;
return|return
operator|(
name|vpos
operator|-
name|bytcnt
operator|)
return|;
else|#
directive|else
name|n
operator|=
name|fread
argument_list|(
name|txbuf
argument_list|,
literal|1
argument_list|,
name|blklen
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|blklen
condition|)
name|Eofseen
operator|=
literal|1
expr_stmt|;
return|return
name|n
return|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TXBSIZE
end_ifdef

begin_comment
comment|/* Replacement for brain damaged fseek function.  Returns 0==success */
end_comment

begin_macro
name|fooseek
argument_list|(
argument|fptr
argument_list|,
argument|pos
argument_list|,
argument|whence
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|m
decl_stmt|,
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|GENIE
name|long
name|l
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|vfile
argument_list|(
literal|"fooseek: pos =%lu vpos=%lu Canseek=%d"
argument_list|,
name|pos
argument_list|,
name|vpos
argument_list|,
name|Canseek
argument_list|)
expr_stmt|;
comment|/* Seek offset< current buffer */
if|if
condition|(
name|pos
operator|<
operator|(
name|vpos
operator|-
name|TXBSIZE
operator|+
literal|1024
operator|)
condition|)
block|{
name|BEofseen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Canseek
operator|>
literal|0
condition|)
block|{
name|vpos
operator|=
name|pos
operator|&
operator|~
name|TXBMASK
expr_stmt|;
if|if
condition|(
name|vpos
operator|>=
name|pos
condition|)
name|vpos
operator|-=
name|TXBSIZE
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|fptr
argument_list|,
name|vpos
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|Canseek
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|GENIE
if|if
condition|(
name|Binfile
condition|)
block|{
if|if
condition|(
name|fseekb
argument_list|(
name|fptr
argument_list|,
name|vpos
operator|=
literal|0L
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|fseek
argument_list|(
name|fptr
argument_list|,
name|vpos
operator|=
literal|0L
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
return|return
literal|1
return|;
while|while
condition|(
name|vpos
operator|<
name|pos
condition|)
block|{
ifdef|#
directive|ifdef
name|GENIE
if|if
condition|(
name|Binfile
condition|)
block|{
for|for
control|(
name|p
operator|=
name|Txb
operator|,
name|n
operator|=
literal|0
operator|,
name|l
operator|=
name|TXBSIZE
init|;
name|l
condition|;
name|l
operator|-=
literal|128
operator|,
name|p
operator|+=
literal|128
control|)
block|{
name|n
operator|+=
operator|(
name|k
operator|=
name|fgetb
argument_list|(
name|p
argument_list|,
literal|128
argument_list|,
name|fptr
argument_list|)
operator|)
expr_stmt|;
name|vfile
argument_list|(
literal|"bsk1: l=%d k=%d"
argument_list|,
name|l
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
endif|#
directive|endif
name|n
operator|=
name|fread
argument_list|(
name|Txb
argument_list|,
literal|1
argument_list|,
name|TXBSIZE
argument_list|,
name|fptr
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|n
expr_stmt|;
name|vfile
argument_list|(
literal|"n=%d vpos=%ld"
argument_list|,
name|n
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|TXBSIZE
condition|)
block|{
name|BEofseen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|vfile
argument_list|(
literal|"vpos=%ld"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Seek offset> current buffer (Crash Recovery, etc.) */
if|if
condition|(
name|pos
operator|>
name|vpos
condition|)
block|{
if|if
condition|(
name|Canseek
condition|)
if|if
condition|(
name|fseek
argument_list|(
name|fptr
argument_list|,
name|vpos
operator|=
operator|(
name|pos
operator|&
operator|~
name|TXBMASK
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|vpos
operator|<=
name|pos
condition|)
block|{
name|txbuf
operator|=
name|Txb
operator|+
operator|(
name|vpos
operator|&
name|TXBMASK
operator|)
expr_stmt|;
name|m
operator|=
name|TXBSIZE
operator|-
operator|(
name|vpos
operator|&
name|TXBMASK
operator|)
expr_stmt|;
name|vfile
argument_list|(
literal|"m=%ld vpos=%ld"
argument_list|,
name|m
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GENIE
if|if
condition|(
name|Binfile
condition|)
block|{
for|for
control|(
name|p
operator|=
name|txbuf
operator|,
name|n
operator|=
literal|0
operator|,
name|l
operator|=
name|m
init|;
name|l
condition|;
name|l
operator|-=
literal|128
operator|,
name|p
operator|+=
literal|128
control|)
block|{
name|n
operator|+=
operator|(
name|k
operator|=
name|fgetb
argument_list|(
name|p
argument_list|,
literal|128
argument_list|,
name|fptr
argument_list|)
operator|)
expr_stmt|;
name|vfile
argument_list|(
literal|"bsk2: l=%d k=%d n=%d"
argument_list|,
name|l
argument_list|,
name|k
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
endif|#
directive|endif
name|n
operator|=
name|fread
argument_list|(
name|txbuf
argument_list|,
literal|1
argument_list|,
name|m
argument_list|,
name|fptr
argument_list|)
expr_stmt|;
name|vfile
argument_list|(
literal|"n=%ld vpos=%ld"
argument_list|,
name|n
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|n
expr_stmt|;
name|vfile
argument_list|(
literal|"bo=%d m=%ld vpos=%ld"
argument_list|,
name|txbuf
operator|-
name|Txb
argument_list|,
name|m
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|m
condition|)
block|{
name|BEofseen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* Seek offset is within current buffer */
name|vfile
argument_list|(
literal|"within buffer: vpos=%ld"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_define
define|#
directive|define
name|fseek
value|fooseek
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VARARGS1 */
end_comment

begin_expr_stmt
name|vfile
argument_list|(
name|f
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
specifier|register
name|char
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|alrm
parameter_list|()
block|{
name|longjmp
argument_list|(
name|tohere
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|GENIE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|vax11c
end_ifndef

begin_comment
comment|/*  * readline(timeout) reads character(s) from file descriptor 0  * timeout is in tenths of seconds  */
end_comment

begin_macro
name|readline
argument_list|(
argument|timeout
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|char
name|byt
index|[
literal|1
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|tohere
argument_list|)
condition|)
block|{
name|zperr
argument_list|(
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
return|return
name|TIMEOUT
return|;
block|}
name|c
operator|=
name|timeout
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|2
condition|)
name|c
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Timeout=%d Calling alarm(%d) "
argument_list|,
name|timeout
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alrm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|byt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ret %x\n"
argument_list|,
name|byt
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|1
condition|)
return|return
name|TIMEOUT
return|;
return|return
operator|(
name|byt
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
return|;
block|}
end_block

begin_macro
name|flushmo
argument_list|()
end_macro

begin_block
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|purgeline
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|USG
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* send cancel string to get the other end to shut up */
end_comment

begin_macro
name|canit
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|canistr
index|[]
init|=
block|{
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|0
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|vax11c
name|raw_wbuf
argument_list|(
name|strlen
argument_list|(
name|canistr
argument_list|)
argument_list|,
name|canistr
argument_list|)
expr_stmt|;
name|purgeline
argument_list|()
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|canistr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Log an error  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|zperr
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|,
argument|u
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|u
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Verbose
operator|<=
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Retry %d: "
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * substr(string, token) searches for token in string s  * returns pointer to token within string if found, NULL otherwise  */
end_comment

begin_function
name|char
modifier|*
name|substr
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
name|tt
decl_stmt|;
comment|/* search for first char of token */
for|for
control|(
name|ss
operator|=
name|s
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|t
condition|)
comment|/* compare token with substring */
for|for
control|(
name|ss
operator|=
name|s
operator|,
name|tt
operator|=
name|t
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|tt
operator|==
literal|0
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|*
name|ss
operator|++
operator|!=
operator|*
name|tt
operator|++
condition|)
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|babble
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|vax11c
literal|"Send file(s) with ZMODEM/YMODEM/XMODEM Protocol"
block|,
literal|"	(Y) = Option applies to YMODEM only"
block|,
literal|"	(Z) = Option applies to ZMODEM only"
block|,
literal|"Usage:	sz [-2+abdefkLlNnquvwYy] [-] file ..."
block|,
literal|"	sz [-2Ceqv] -c COMMAND"
block|,
literal|"	\\ Force next option letter to upper case"
block|,
literal|"	sb [-2adfkquv] [-] file ..."
block|,
literal|"	sx [-2akquv] [-] file"
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|vax11c
literal|"Send file(s) with ZMODEM/YMODEM/XMODEM Protocol"
block|,
literal|"	(Y) = Option applies to YMODEM only"
block|,
literal|"	(Z) = Option applies to ZMODEM only"
block|,
literal|"Usage:	sz [-2+abdefkLlNnquvwYy] [-] file ..."
block|,
literal|"	sz [-2Ceqv] -c COMMAND"
block|,
literal|"	sb [-2adfkquv] [-] file ..."
block|,
literal|"	sx [-2akquv] [-] file"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CSTOPB
literal|"	2   Use 2 stop bits"
block|,
endif|#
directive|endif
literal|"	+   Append to existing destination file (Z)"
block|,
literal|"	a   (ASCII) change NL to CR/LF"
block|,
literal|"	b   Binary file transfer override"
block|,
literal|"	c   send COMMAND (Z)"
block|,
ifndef|#
directive|ifndef
name|vax11c
literal|"	d   Change '.' to '/' in pathnames (Y/Z)"
block|,
endif|#
directive|endif
literal|"	e   Escape all control characters (Z)"
block|,
literal|"	f   send Full pathname (Y/Z)"
block|,
literal|"	i   send COMMAND, ack Immediately (Z)"
block|,
literal|"	k   Send 1024 byte packets (Y)"
block|,
literal|"	L N Limit subpacket length to N bytes (Z)"
block|,
literal|"	l N Limit frame length to N bytes (l>=L) (Z)"
block|,
literal|"	n   send file only if source newer (Z)"
block|,
literal|"	N   send file only if source newer or longer (Z)"
block|,
literal|"	o   Use 16 bit CRC instead of 32 bit CRC (Z)"
block|,
literal|"	p   Protect existing destination file (Z)"
block|,
literal|"	r   Resume/Recover interrupted file transfer (Z)"
block|,
literal|"	q   Quiet (no progress reports)"
block|,
ifndef|#
directive|ifndef
name|vax11c
literal|"	u   Unlink (remove) file after transmission"
block|,
endif|#
directive|endif
literal|"	v   Verbose - provide debugging information"
block|,
literal|"	w N restrict Window to N bytes (Z)"
block|,
literal|"	Y   Yes, overwrite existing file, skip if not present at rx (Z)"
block|,
literal|"	y   Yes, overwrite existing file (Z)"
block|,
literal|"	Z   Activate ZMODEM compression(Z)"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|babble
init|;
operator|*
operator|*
name|pp
condition|;
operator|++
name|pp
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s for %s by Chuck Forsberg, Omen Technology INC\n"
argument_list|,
name|VERSION
argument_list|,
name|OS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\042The High Reliability Software\042\n"
argument_list|)
expr_stmt|;
name|cucheck
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|SS_NORMAL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the receiver's init parameters  */
end_comment

begin_macro
name|getzrxinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|STAT
name|struct
name|stat
name|f
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|10
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
block|{
switch|switch
condition|(
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|ZCHALLENGE
case|:
comment|/* Echo receiver's challenge numbr */
name|stohdr
argument_list|(
name|Rxpos
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZACK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ZCOMMAND
case|:
comment|/* They didn't see out ZRQINIT */
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZRQINIT
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ZRINIT
case|:
name|Rxflags
operator|=
literal|0377
operator|&
name|Rxhdr
index|[
name|ZF0
index|]
expr_stmt|;
name|Usevhdrs
operator|=
name|Rxhdr
index|[
name|ZF1
index|]
operator|&
name|CANVHDR
expr_stmt|;
name|Txfcs32
operator|=
operator|(
name|Wantfcs32
operator|&&
operator|(
name|Rxflags
operator|&
name|CANFC32
operator|)
operator|)
expr_stmt|;
name|Zctlesc
operator||=
name|Rxflags
operator|&
name|TESCCTL
expr_stmt|;
name|Rxbuflen
operator|=
operator|(
literal|0377
operator|&
name|Rxhdr
index|[
name|ZP0
index|]
operator|)
operator|+
operator|(
operator|(
literal|0377
operator|&
name|Rxhdr
index|[
name|ZP1
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Rxflags
operator|&
name|CANFDX
operator|)
condition|)
name|Txwindow
operator|=
literal|0
expr_stmt|;
name|vfile
argument_list|(
literal|"Rxbuflen=%d Tframlen=%d"
argument_list|,
name|Rxbuflen
argument_list|,
name|Tframlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fromcu
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MODE2OK
name|mode
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Set cbreak, XON/XOFF, etc. */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|READCHECK
ifndef|#
directive|ifndef
name|USG
ifndef|#
directive|ifndef
name|GENIE
comment|/* Use 1024 byte frames if no sample/interrupt */
if|if
condition|(
name|Rxbuflen
operator|<
literal|32
operator|||
name|Rxbuflen
operator|>
literal|1024
condition|)
block|{
name|Rxbuflen
operator|=
literal|1024
expr_stmt|;
name|vfile
argument_list|(
literal|"Rxbuflen=%d"
argument_list|,
name|Rxbuflen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* Override to force shorter frame length */
if|if
condition|(
name|Rxbuflen
operator|&&
operator|(
name|Rxbuflen
operator|>
name|Tframlen
operator|)
operator|&&
operator|(
name|Tframlen
operator|>=
literal|32
operator|)
condition|)
name|Rxbuflen
operator|=
name|Tframlen
expr_stmt|;
if|if
condition|(
operator|!
name|Rxbuflen
operator|&&
operator|(
name|Tframlen
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|Tframlen
operator|<=
literal|1024
operator|)
condition|)
name|Rxbuflen
operator|=
name|Tframlen
expr_stmt|;
name|vfile
argument_list|(
literal|"Rxbuflen=%d"
argument_list|,
name|Rxbuflen
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GENIE
ifndef|#
directive|ifndef
name|vax11c
ifdef|#
directive|ifdef
name|STAT
comment|/* If using a pipe for testing set lower buf len */
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
block|{
name|Rxbuflen
operator|=
literal|1024
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BADSEEK
ifdef|#
directive|ifdef
name|GENIE
if|if
condition|(
name|Txwindow
operator|==
literal|0
condition|)
block|{
name|Txwspac
operator|=
operator|(
name|Txwindow
operator|=
literal|4096
operator|)
operator|/
literal|4
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|Txwindow
operator|==
literal|0
condition|)
name|Txwindow
operator|=
name|TXBSIZE
operator|-
literal|1024
expr_stmt|;
name|Txwspac
operator|=
name|TXBSIZE
operator|/
literal|4
expr_stmt|;
endif|#
directive|endif
name|Canseek
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * If input is not a regular file, force ACK's to 			 *  prevent running beyond the buffer limits 			 */
ifdef|#
directive|ifdef
name|STAT
if|if
condition|(
operator|!
name|Command
condition|)
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|in
argument_list|)
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|Canseek
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TXBSIZE
name|Txwindow
operator|=
name|TXBSIZE
operator|-
literal|1024
expr_stmt|;
name|Txwspac
operator|=
name|TXBSIZE
operator|/
literal|4
expr_stmt|;
else|#
directive|else
return|return
name|ERROR
return|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* Set initial subpacket length */
if|if
condition|(
name|blklen
operator|<
literal|1024
condition|)
block|{
comment|/* Command line override? */
if|if
condition|(
name|Effbaud
operator|>
literal|300
condition|)
name|blklen
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|Effbaud
operator|>
literal|1200
condition|)
name|blklen
operator|=
literal|512
expr_stmt|;
if|if
condition|(
name|Effbaud
operator|>
literal|2400
condition|)
name|blklen
operator|=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
name|Rxbuflen
operator|&&
name|blklen
operator|>
name|Rxbuflen
condition|)
name|blklen
operator|=
name|Rxbuflen
expr_stmt|;
if|if
condition|(
name|blkopt
operator|&&
name|blklen
operator|>
name|blkopt
condition|)
name|blklen
operator|=
name|blkopt
expr_stmt|;
ifdef|#
directive|ifdef
name|GENIE
name|blklen
operator|/=
literal|128
expr_stmt|;
name|blklen
operator|*=
literal|128
expr_stmt|;
if|if
condition|(
name|blklen
operator|<
literal|128
condition|)
name|blklen
operator|=
literal|128
expr_stmt|;
endif|#
directive|endif
name|vfile
argument_list|(
literal|"Rxbuflen=%d blklen=%d"
argument_list|,
name|Rxbuflen
argument_list|,
name|blklen
argument_list|)
expr_stmt|;
name|vfile
argument_list|(
literal|"Txwindow = %u Txwspac = %d"
argument_list|,
name|Txwindow
argument_list|,
name|Txwspac
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lztrans
operator|==
name|ZTRLE
operator|&&
operator|(
name|Rxflags
operator|&
name|CANRLE
operator|)
condition|)
name|Txfcs32
operator|=
literal|2
expr_stmt|;
else|else
name|Lztrans
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sendzsinit
argument_list|()
operator|)
return|;
case|case
name|ZCAN
case|:
case|case
name|TIMEOUT
case|:
return|return
name|ERROR
return|;
case|case
name|ZRQINIT
case|:
if|if
condition|(
name|Rxhdr
index|[
name|ZF0
index|]
operator|==
name|ZCOMMAND
condition|)
continue|continue;
default|default:
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZNAK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|ERROR
return|;
block|}
end_block

begin_comment
comment|/* Send send-init information */
end_comment

begin_macro
name|sendzsinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|Myattn
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
operator|!
name|Zctlesc
operator|||
operator|(
name|Rxflags
operator|&
name|TESCCTL
operator|)
operator|)
condition|)
return|return
name|OK
return|;
name|errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTCANOFF
name|Txhdr
index|[
name|ALTCOFF
index|]
operator|=
name|ALTCANOFF
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Zctlesc
condition|)
block|{
name|Txhdr
index|[
name|ZF0
index|]
operator||=
name|TESCCTL
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZSINIT
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
block|}
else|else
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZSINIT
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
name|zsdata
argument_list|(
name|Myattn
argument_list|,
name|ZATTNLEN
argument_list|,
name|ZCRCW
argument_list|)
expr_stmt|;
name|c
operator|=
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZCAN
case|:
return|return
name|ERROR
return|;
case|case
name|ZACK
case|:
return|return
name|OK
return|;
default|default:
if|if
condition|(
operator|++
name|errors
operator|>
literal|19
condition|)
return|return
name|ERROR
return|;
continue|continue;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Send file name and related info */
end_comment

begin_macro
name|zsendfile
argument_list|(
argument|buf
argument_list|,
argument|blen
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|UNSL
name|long
name|crc
decl_stmt|;
name|long
name|lastcrcrq
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Txhdr
index|[
name|ZF0
index|]
operator|=
name|Lzconv
expr_stmt|;
comment|/* file conversion request */
name|Txhdr
index|[
name|ZF1
index|]
operator|=
name|Lzmanag
expr_stmt|;
comment|/* file management request */
if|if
condition|(
name|Lskipnocor
condition|)
name|Txhdr
index|[
name|ZF1
index|]
operator||=
name|ZMSKNOLOC
expr_stmt|;
name|Txhdr
index|[
name|ZF2
index|]
operator|=
name|Lztrans
expr_stmt|;
comment|/* file transport request */
name|Txhdr
index|[
name|ZF3
index|]
operator|=
literal|0
expr_stmt|;
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZFILE
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
name|zsdata
argument_list|(
name|buf
argument_list|,
name|blen
argument_list|,
name|ZCRCW
argument_list|)
expr_stmt|;
name|again
label|:
name|c
operator|=
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZRINIT
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|readline
argument_list|(
literal|50
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|c
operator|==
name|ZPAD
condition|)
block|{
goto|goto
name|again
goto|;
block|}
comment|/* **** FALL THRU TO **** */
default|default:
continue|continue;
case|case
name|ZCAN
case|:
case|case
name|TIMEOUT
case|:
case|case
name|ZABORT
case|:
case|case
name|ZFIN
case|:
return|return
name|ERROR
return|;
case|case
name|ZCRC
case|:
if|if
condition|(
name|Rxpos
operator|!=
name|lastcrcrq
condition|)
block|{
name|lastcrcrq
operator|=
name|Rxpos
expr_stmt|;
name|crc
operator|=
literal|0xFFFFFFFFL
expr_stmt|;
if|if
condition|(
name|Canseek
operator|>=
literal|0
condition|)
block|{
name|fseek
argument_list|(
name|in
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|--
name|lastcrcrq
condition|)
name|crc
operator|=
name|UPDC32
argument_list|(
name|c
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
name|clearerr
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* Clear possible EOF */
name|lastcrcrq
operator|=
name|Rxpos
expr_stmt|;
block|}
block|}
name|stohdr
argument_list|(
name|crc
argument_list|)
expr_stmt|;
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZCRC
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ZSKIP
case|:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|c
return|;
case|case
name|ZRPOS
case|:
comment|/* 			 * Suppress zcrcw request otherwise triggered by 			 * lastyunc==bytcnt 			 */
ifdef|#
directive|ifdef
name|GENIE
comment|/* 			 *  Special case - turn on RLE if not archive, etc. 			 *   otherwise turn off RLE unless cmd line specified 			 */
if|if
condition|(
name|Rxflags
operator|&
name|CANRLE
condition|)
block|{
comment|/* RX can do it */
name|bytcnt
operator|=
literal|0
expr_stmt|;
name|zfilbuf
argument_list|()
expr_stmt|;
name|vfile
argument_list|(
literal|"txbuf012: %x %x %x"
argument_list|,
name|txbuf
index|[
literal|0
index|]
argument_list|,
name|txbuf
index|[
literal|1
index|]
argument_list|,
name|txbuf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txbuf
index|[
literal|0
index|]
operator|!=
literal|032
operator|)
comment|/* .ARC file */
operator|&&
operator|(
name|txbuf
index|[
literal|0
index|]
operator|!=
literal|0x1f
operator|)
comment|/* .Z file */
operator|&&
operator|(
name|txbuf
index|[
literal|0
index|]
operator|!=
literal|0x1c
operator|)
comment|/* .LHZ file */
operator|&&
name|strncmp
argument_list|(
name|txbuf
argument_list|,
literal|"ZOO"
argument_list|,
literal|3
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|txbuf
argument_list|,
literal|"GIF"
argument_list|,
literal|3
argument_list|)
operator|&&
operator|(
name|txbuf
index|[
literal|2
index|]
operator|!=
literal|3
operator|)
condition|)
comment|/* .ZIP file */
name|Txfcs32
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|Lztrans
operator|&
name|ZTRLE
operator|)
condition|)
name|Txfcs32
operator|=
literal|1
expr_stmt|;
block|}
comment|/* GEnie binary can't seek to byte */
if|if
condition|(
name|Binfile
condition|)
block|{
name|Rxpos
operator|&=
operator|~
literal|127L
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fseek
argument_list|(
name|in
argument_list|,
name|Rxpos
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ERROR
return|;
name|Lastsync
operator|=
operator|(
name|bytcnt
operator|=
name|Txpos
operator|=
name|Lrxpos
operator|=
name|Rxpos
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|zsendfdata
argument_list|()
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Send the data in the file */
end_comment

begin_macro
name|zsendfdata
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
operator|,
name|e
operator|,
name|n
expr_stmt|;
specifier|register
name|newcnt
expr_stmt|;
specifier|register
name|long
name|tcount
init|=
literal|0
decl_stmt|;
name|int
name|junkcount
decl_stmt|;
comment|/* Counts garbage chars received by TX */
specifier|static
name|int
name|tleft
init|=
literal|6
decl_stmt|;
comment|/* Counter for test mode */
name|junkcount
operator|=
literal|0
expr_stmt|;
name|Beenhereb4
operator|=
name|FALSE
expr_stmt|;
name|somemore
label|:
if|if
condition|(
name|setjmp
argument_list|(
name|intrjmp
argument_list|)
condition|)
block|{
name|waitack
label|:
name|junkcount
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getinsync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gotack
label|:
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
case|case
name|ZCAN
case|:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
case|case
name|ZSKIP
case|:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|c
return|;
case|case
name|ZACK
case|:
case|case
name|ZRPOS
case|:
break|break;
case|case
name|ZRINIT
case|:
return|return
name|OK
return|;
block|}
ifdef|#
directive|ifdef
name|READCHECK
comment|/* 		 * If the reverse channel can be tested for data, 		 *  this logic may be used to detect error packets 		 *  sent by the receiver, in place of setjmp/longjmp 		 *  rdchk(fd) returns non 0 if a character is available 		 */
while|while
condition|(
name|rdchk
argument_list|(
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EATSIT
switch|switch
condition|(
name|checked
condition|)
else|#
directive|else
switch|switch
condition|(
name|readline
argument_list|(
literal|1
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|CAN
case|:
case|case
name|ZPAD
case|:
name|c
operator|=
name|getinsync
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|gotack
goto|;
case|case
name|XOFF
case|:
comment|/* Wait a while for an XON */
case|case
name|XOFF
operator||
literal|0200
case|:
name|readline
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|Fromcu
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|newcnt
operator|=
name|Rxbuflen
expr_stmt|;
name|Txwcnt
operator|=
literal|0
expr_stmt|;
name|stohdr
argument_list|(
name|Txpos
argument_list|)
expr_stmt|;
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZDATA
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
comment|/* 	 * Special testing mode.  This should force receiver to Attn,ZRPOS 	 *  many times.  Each time the signal should be caught, causing the 	 *  file to be started over from the beginning. 	 */
if|if
condition|(
name|Test
condition|)
block|{
if|if
condition|(
operator|--
name|tleft
condition|)
while|while
condition|(
name|tcount
operator|<
literal|20000
condition|)
block|{
name|printf
argument_list|(
name|qbf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|tcount
operator|+=
name|strlen
argument_list|(
name|qbf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|READCHECK
while|while
condition|(
name|rdchk
argument_list|(
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EATSIT
switch|switch
condition|(
name|checked
condition|)
else|#
directive|else
switch|switch
condition|(
name|readline
argument_list|(
literal|1
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|CAN
case|:
case|case
name|ZPAD
case|:
ifdef|#
directive|ifdef
name|TCFLSH
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|waitack
goto|;
case|case
name|XOFF
case|:
comment|/* Wait for XON */
case|case
name|XOFF
operator||
literal|0200
case|:
name|readline
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|purgeline
argument_list|()
expr_stmt|;
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nsz: Tcount = %ld\n"
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|tleft
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Interrupts Not Caught\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|SS_NORMAL
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|n
operator|=
name|zfilbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|Eofseen
condition|)
name|e
operator|=
name|ZCRCE
expr_stmt|;
elseif|else
if|if
condition|(
name|junkcount
operator|>
literal|3
condition|)
name|e
operator|=
name|ZCRCW
expr_stmt|;
elseif|else
if|if
condition|(
name|bytcnt
operator|==
name|Lastsync
condition|)
name|e
operator|=
name|ZCRCW
expr_stmt|;
elseif|else
if|if
condition|(
name|Rxbuflen
operator|&&
operator|(
name|newcnt
operator|-=
name|n
operator|)
operator|<=
literal|0
condition|)
name|e
operator|=
name|ZCRCW
expr_stmt|;
elseif|else
if|if
condition|(
name|Txwindow
operator|&&
operator|(
name|Txwcnt
operator|+=
name|n
operator|)
operator|>=
name|Txwspac
condition|)
block|{
name|Txwcnt
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|ZCRCQ
expr_stmt|;
block|}
else|else
name|e
operator|=
name|ZCRCG
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r%7ld ZMODEM%s    "
argument_list|,
name|Txpos
argument_list|,
name|Crc32t
condition|?
literal|" CRC-32"
else|:
literal|""
argument_list|)
expr_stmt|;
name|zsdata
argument_list|(
name|txbuf
argument_list|,
name|n
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bytcnt
operator|=
name|Txpos
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|ZCRCW
condition|)
goto|goto
name|waitack
goto|;
ifdef|#
directive|ifdef
name|READCHECK
comment|/* 		 * If the reverse channel can be tested for data, 		 *  this logic may be used to detect error packets 		 *  sent by the receiver, in place of setjmp/longjmp 		 *  rdchk(fd) returns non 0 if a character is available 		 */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|rdchk
argument_list|(
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EATSIT
switch|switch
condition|(
name|checked
condition|)
else|#
directive|else
switch|switch
condition|(
name|readline
argument_list|(
literal|1
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|CAN
case|:
case|case
name|ZPAD
case|:
name|c
operator|=
name|getinsync
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ZACK
condition|)
break|break;
ifdef|#
directive|ifdef
name|TCFLSH
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* zcrce - dinna wanna starta ping-pong game */
name|zsdata
argument_list|(
name|txbuf
argument_list|,
literal|0
argument_list|,
name|ZCRCE
argument_list|)
expr_stmt|;
goto|goto
name|gotack
goto|;
case|case
name|XOFF
case|:
comment|/* Wait a while for an XON */
case|case
name|XOFF
operator||
literal|0200
case|:
name|readline
argument_list|(
literal|100
argument_list|)
expr_stmt|;
default|default:
operator|++
name|junkcount
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* READCHECK */
if|if
condition|(
name|Txwindow
condition|)
block|{
while|while
condition|(
operator|(
name|tcount
operator|=
name|Txpos
operator|-
name|Lrxpos
operator|)
operator|>=
name|Txwindow
condition|)
block|{
name|vfile
argument_list|(
literal|"%ld window>= %u"
argument_list|,
name|tcount
argument_list|,
name|Txwindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|ZCRCQ
condition|)
name|zsdata
argument_list|(
name|txbuf
argument_list|,
literal|0
argument_list|,
name|e
operator|=
name|ZCRCQ
argument_list|)
expr_stmt|;
name|c
operator|=
name|getinsync
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ZACK
condition|)
block|{
ifdef|#
directive|ifdef
name|TCFLSH
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zsdata
argument_list|(
name|txbuf
argument_list|,
literal|0
argument_list|,
name|ZCRCE
argument_list|)
expr_stmt|;
goto|goto
name|gotack
goto|;
block|}
block|}
name|vfile
argument_list|(
literal|"window = %ld"
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|Eofseen
condition|)
do|;
if|if
condition|(
operator|!
name|Fromcu
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|stohdr
argument_list|(
name|Txpos
argument_list|)
expr_stmt|;
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZEOF
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|getinsync
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|ZACK
case|:
continue|continue;
case|case
name|ZRPOS
case|:
goto|goto
name|somemore
goto|;
case|case
name|ZRINIT
case|:
return|return
name|OK
return|;
case|case
name|ZSKIP
case|:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|c
return|;
default|default:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Respond to receiver's complaint, get back in sync with receiver  */
end_comment

begin_macro
name|getinsync
argument_list|(
argument|flag
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|Test
condition|)
block|{
name|printf
argument_list|(
literal|"\r\n\n\n***** Signal Caught *****\r\n"
argument_list|)
expr_stmt|;
name|Rxpos
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|ZRPOS
expr_stmt|;
block|}
else|else
name|c
operator|=
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZCAN
case|:
case|case
name|ZABORT
case|:
case|case
name|ZFIN
case|:
case|case
name|TIMEOUT
case|:
return|return
name|ERROR
return|;
case|case
name|ZRPOS
case|:
comment|/* ************************************* */
comment|/*  If sending to a buffered modem, you  */
comment|/*   might send a break at this point to */
comment|/*   dump the modem's buffer.		 */
name|clearerr
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* In case file EOF seen */
if|if
condition|(
name|fseek
argument_list|(
name|in
argument_list|,
name|Rxpos
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ERROR
return|;
name|Eofseen
operator|=
literal|0
expr_stmt|;
name|bytcnt
operator|=
name|Lrxpos
operator|=
name|Txpos
operator|=
name|Rxpos
expr_stmt|;
ifndef|#
directive|ifndef
name|GENIE
if|if
condition|(
name|Lastsync
operator|==
name|Rxpos
condition|)
block|{
if|if
condition|(
operator|++
name|Beenhereb4
operator|>
literal|4
condition|)
if|if
condition|(
name|blklen
operator|>
literal|32
condition|)
name|blklen
operator|/=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
name|Lastsync
operator|=
name|Rxpos
expr_stmt|;
return|return
name|c
return|;
case|case
name|ZACK
case|:
name|Lrxpos
operator|=
name|Rxpos
expr_stmt|;
if|if
condition|(
name|flag
operator|||
name|Txpos
operator|==
name|Rxpos
condition|)
return|return
name|ZACK
return|;
continue|continue;
case|case
name|ZRINIT
case|:
case|case
name|ZSKIP
case|:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|c
return|;
case|case
name|ERROR
case|:
default|default:
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZNAK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Say "bibi" to the receiver, try to do it cleanly */
end_comment

begin_macro
name|saybibi
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
comment|/* CAF Was zsbhdr - minor change */
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZFIN
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
comment|/*  to make debugging easier */
switch|switch
condition|(
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|ZFIN
case|:
name|sendline
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|flushmo
argument_list|()
expr_stmt|;
case|case
name|ZCAN
case|:
case|case
name|TIMEOUT
case|:
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Local screen character display function */
end_comment

begin_macro
name|bttyout
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|Verbose
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Send command and related info */
end_comment

begin_macro
name|zsendcmd
argument_list|(
argument|buf
argument_list|,
argument|blen
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|long
name|cmdnum
decl_stmt|;
ifdef|#
directive|ifdef
name|GENIE
name|cmdnum
operator|=
literal|69
expr_stmt|;
else|#
directive|else
name|cmdnum
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|stohdr
argument_list|(
name|cmdnum
argument_list|)
expr_stmt|;
name|Txhdr
index|[
name|ZF0
index|]
operator|=
name|Cmdack1
expr_stmt|;
name|zsbhdr
argument_list|(
literal|4
argument_list|,
name|ZCOMMAND
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
name|zsdata
argument_list|(
name|buf
argument_list|,
name|blen
argument_list|,
name|ZCRCW
argument_list|)
expr_stmt|;
name|listen
label|:
name|Rxtimeout
operator|=
literal|100
expr_stmt|;
comment|/* Ten second wait for resp. */
name|Usevhdrs
operator|=
literal|0
expr_stmt|;
comment|/* Allow rx to send fixed len headers */
name|c
operator|=
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ZRINIT
case|:
goto|goto
name|listen
goto|;
comment|/* CAF 8-21-87 */
case|case
name|ERROR
case|:
case|case
name|GCOUNT
case|:
case|case
name|TIMEOUT
case|:
if|if
condition|(
operator|++
name|errors
operator|>
name|Cmdtries
condition|)
return|return
name|ERROR
return|;
continue|continue;
case|case
name|ZCAN
case|:
case|case
name|ZABORT
case|:
case|case
name|ZFIN
case|:
case|case
name|ZSKIP
case|:
case|case
name|ZRPOS
case|:
return|return
name|ERROR
return|;
default|default:
if|if
condition|(
operator|++
name|errors
operator|>
literal|20
condition|)
return|return
name|ERROR
return|;
continue|continue;
case|case
name|ZCOMPL
case|:
name|Exitcode
operator|=
name|Rxpos
expr_stmt|;
name|saybibi
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
case|case
name|ZRQINIT
case|:
ifdef|#
directive|ifdef
name|vax11c
comment|/* YAMP :== Yet Another Missing Primitive */
return|return
name|ERROR
return|;
else|#
directive|else
name|vfile
argument_list|(
literal|"******** RZ *******"
argument_list|)
expr_stmt|;
name|system
argument_list|(
literal|"rz"
argument_list|)
expr_stmt|;
name|vfile
argument_list|(
literal|"******** SZ *******"
argument_list|)
expr_stmt|;
goto|goto
name|listen
goto|;
endif|#
directive|endif
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * If called as sb use YMODEM protocol  */
end_comment

begin_macro
name|chkinvok
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|s
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|s
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'v'
condition|)
block|{
name|Verbose
operator|=
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|Progname
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
name|Nozmodem
operator|=
name|TRUE
expr_stmt|;
name|blklen
operator|=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|Modem2
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STAT
end_ifdef

begin_expr_stmt
name|countem
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|struct
name|stat
name|f
decl_stmt|;
for|for
control|(
name|Totalleft
operator|=
literal|0
operator|,
name|Filesleft
operator|=
literal|0
init|;
operator|--
name|argc
operator|>=
literal|0
condition|;
operator|++
name|argv
control|)
block|{
name|f
operator|.
name|st_size
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nCountem: %03d %s "
argument_list|,
name|argc
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
operator|*
name|argv
argument_list|,
literal|04
argument_list|)
operator|>=
literal|0
operator|&&
name|stat
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|f
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|f
operator|.
name|st_mode
operator|&
name|S_IFMT
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|S_IFDIR
operator|&&
name|c
operator|!=
name|S_IFBLK
condition|)
block|{
operator|++
name|Filesleft
expr_stmt|;
name|Totalleft
operator|+=
name|f
operator|.
name|st_size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %ld"
argument_list|,
name|f
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ncountem: Total %d %ld\n"
argument_list|,
name|Filesleft
argument_list|,
name|Totalleft
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|countem
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|size
decl_stmt|;
for|for
control|(
name|Totalleft
operator|=
literal|0
operator|,
name|Filesleft
operator|=
literal|0
init|;
operator|--
name|argc
operator|>=
literal|0
condition|;
operator|++
name|argv
control|)
block|{
name|size
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nCountem: %03d %s "
argument_list|,
name|argc
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
operator|++
name|Filesleft
expr_stmt|;
ifdef|#
directive|ifdef
name|XARGSFILE
comment|/* Look for file length in third colon sep field */
for|for
control|(
name|p
operator|=
operator|*
name|argv
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
for|for
control|(
operator|++
name|p
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
operator|++
name|p
expr_stmt|;
name|size
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Totalleft
operator|+=
name|size
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %ld"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ncountem: Total %d %ld\n"
argument_list|,
name|Filesleft
argument_list|,
name|Totalleft
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|chartest
argument_list|(
argument|m
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
name|mode
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n\nCharacter Transparency Test Mode %d\r\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If Pro-YAM/ZCOMM is not displaying ^M hit ALT-V NOW.\r\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Hit Enter.\021"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|readline
argument_list|(
literal|500
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|%
literal|8
operator|)
condition|)
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|flushmo
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|127
condition|)
block|{
name|printf
argument_list|(
literal|"Hit Enter.\021"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|readline
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\021\r\nEnter Characters, echo is in hex.\r\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Hit SPACE or pause 40 seconds for exit.\r\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|TIMEOUT
operator|&&
name|n
operator|!=
literal|' '
condition|)
block|{
name|n
operator|=
name|readline
argument_list|(
literal|400
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x\r\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\r\nMode %d character transparency test ends.\r\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* End of sz.c */
end_comment

end_unit

