begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mvdir -- rename directory    Copyright (C) 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Helper program for GNU mv on systems that lack the rename system call.     Usage: mvdir from to     FROM must be an existing directory.    TO must not exist, but its parent must exist.    This program performs the necessary sanity checking on its arguments.     Must be installed setuid root.     Ian Dall (ian@sibyl.eleceng.ua.oz.au)    and David MacKenzie (djm@gnu.ai.mit.edu) */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HIPRI
end_ifndef

begin_define
define|#
directive|define
name|HIPRI
value|-10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|link
parameter_list|(
name|FROM
parameter_list|,
name|TO
parameter_list|)
value|(printf("Linking %s to %s\n", FROM, TO), 0)
end_define

begin_define
define|#
directive|define
name|unlink
parameter_list|(
name|FILE
parameter_list|)
value|(printf("Unlinking %s\n", FILE), 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|basename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fullpath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|dirname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|strip_trailing_slashes
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|from_parent
decl_stmt|,
modifier|*
name|from_base
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|to_parent
decl_stmt|,
modifier|*
name|to_parent_path
decl_stmt|,
modifier|*
name|to_base
decl_stmt|,
modifier|*
name|to_dotdot
decl_stmt|;
name|struct
name|stat
name|from_stats
decl_stmt|,
name|to_stats
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s existing-dir new-dir\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|from
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|to
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from_parent
operator|=
name|dirname
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|to_parent
operator|=
name|dirname
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_parent
operator|||
operator|!
name|to_parent
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
comment|/* Make sure `from' is not "." or "..". */
name|from_base
operator|=
name|basename
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|from_base
argument_list|,
literal|"."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|from_base
argument_list|,
literal|".."
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot rename `.' or `..'"
argument_list|)
expr_stmt|;
comment|/* Even with an effective uid of root, link fails if the target exists.      That is what we want, so don't unlink `to' first.      However, we do need to check that the directories that link and unlink      will modify exist and are writable by the user. */
if|if
condition|(
name|stat
argument_list|(
name|from
argument_list|,
operator|&
name|from_stats
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|from_stats
operator|.
name|st_mode
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"`%s' is not a directory"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|from_parent
argument_list|,
name|W_OK
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write to `%s'"
argument_list|,
name|from_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|to_parent
argument_list|,
name|W_OK
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write to `%s'"
argument_list|,
name|to_parent
argument_list|)
expr_stmt|;
comment|/* To prevent disconnecting the tree rooted at `from' from its parent,      quit if any of the directories in `to' are the same (dev and ino)      as the directory `from'. */
name|slash
operator|=
name|to_parent_path
operator|=
name|fullpath
argument_list|(
name|to_parent
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
operator|++
name|slash
expr_stmt|;
name|slash
operator|=
name|index
argument_list|(
name|slash
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|to_parent_path
argument_list|,
operator|&
name|to_stats
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to_parent_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_stats
operator|.
name|st_dev
operator|==
name|from_stats
operator|.
name|st_dev
operator|&&
name|to_stats
operator|.
name|st_ino
operator|==
name|from_stats
operator|.
name|st_ino
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"`%s' is an ancestor of `%s'"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
operator|*
name|slash
operator|++
operator|=
literal|'/'
expr_stmt|;
else|else
break|break;
block|}
comment|/* We can't make the renaming atomic, but we do our best. */
for|for
control|(
name|i
operator|=
name|NSIG
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|i
operator|!=
name|SIGKILL
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Make real uid 0 so it is harder to kill. */
name|nice
argument_list|(
name|HIPRI
operator|-
name|nice
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Raise priority. */
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot link `%s' to `%s'"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|from
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot unlink `%s'"
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Replace the directory's `..' entry.  It used to be a link to      the parent of `from'; make it a link to the parent of `to' instead.      To handle the case where `from' is the current directory      and `to' starts with `../', we go to the full path of `to's parent,      lest we try to reference the new directory's `..' while creating it.  */
name|to_base
operator|=
name|basename
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|to_base
argument_list|)
expr_stmt|;
name|to_dotdot
operator|=
name|xmalloc
argument_list|(
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|to_dotdot
argument_list|,
name|to_base
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|to_dotdot
operator|+
name|i
argument_list|,
literal|"/.."
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|to_parent_path
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to_parent_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|to_dotdot
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot unlink `%s'"
argument_list|,
name|to_dotdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
literal|"."
argument_list|,
name|to_dotdot
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot link `%s' to `%s'"
argument_list|,
literal|"."
argument_list|,
name|to_dotdot
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the full pathname (from /) of the directory DIR,    as static data. */
end_comment

begin_function
name|char
modifier|*
name|fullpath
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|char
name|wd
index|[
name|PATH_MAX
operator|+
literal|2
index|]
decl_stmt|;
specifier|static
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|getcwd
argument_list|(
name|wd
argument_list|,
name|PATH_MAX
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get current directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|getcwd
argument_list|(
name|path
argument_list|,
name|PATH_MAX
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get current directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|wd
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|wd
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

end_unit

