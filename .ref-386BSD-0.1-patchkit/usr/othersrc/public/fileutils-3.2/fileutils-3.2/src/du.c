begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* du -- summarize disk usage    Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Differences from the Unix du:    * Doesn't simply ignore the names of regular files given as arguments      when -a is given.    * Additional options:    -l		Count the size of all files, even if they have appeared 		already in another hard link.    -x		Do not cross file-system boundaries during the recursion.    -c		Write a grand total of all of the arguments after all 		arguments have been processed.  This can be used to find 		out the disk usage of a directory, with some files excluded.    -k		Print sizes in kilobytes instead of 512 byte blocks 		(the default required by POSIX).    -b		Print sizes in bytes.    -S		Count the size of each directory separately, not including 		the sizes of subdirectories.    -D		Dereference only symbolic links given on the command line.    -L		Dereference all symbolic links.     By tege@sics.se, Torbjorn Granlund,    and djm@ai.mit.edu, David MacKenzie.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_function_decl
name|int
name|lstat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|stat
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Initial number of entries in each hash table entry's table of inodes.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_HASH_MODULE
value|100
end_define

begin_comment
comment|/* Initial number of entries in the inode hash table.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_ENTRY_TAB_SIZE
value|70
end_define

begin_comment
comment|/* Initial size to allocate for `path'.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_PATH_SIZE
value|100
end_define

begin_comment
comment|/* Hash structure for inode and device numbers.  The separate entry    structure makes it easier to rehash "in place".  */
end_comment

begin_struct
struct|struct
name|entry
block|{
name|ino_t
name|ino
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|struct
name|entry
modifier|*
name|coll_link
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for a hash table for inode numbers. */
end_comment

begin_struct
struct|struct
name|htab
block|{
name|unsigned
name|modulus
decl_stmt|;
comment|/* Size of the `hash' pointer vector.  */
name|struct
name|entry
modifier|*
name|entry_tab
decl_stmt|;
comment|/* Pointer to dynamically growing vector.  */
name|unsigned
name|entry_tab_size
decl_stmt|;
comment|/* Size of current `entry_tab' allocation.  */
name|unsigned
name|first_free_entry
decl_stmt|;
comment|/* Index in `entry_tab'.  */
name|struct
name|entry
modifier|*
name|hash
index|[
literal|1
index|]
decl_stmt|;
comment|/* Vector of pointers in `entry_tab'.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for dynamically resizable strings. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|alloc
decl_stmt|;
comment|/* Size of allocation for the text.  */
name|unsigned
name|length
decl_stmt|;
comment|/* Length of the text currently.  */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Pointer to the text.  */
block|}
typedef|*
name|string
operator|,
name|stringstruct
typedef|;
end_typedef

begin_function_decl
name|char
modifier|*
name|savedir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xgetcwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hash_insert
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hash_insert2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|count_entry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|du_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hash_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hash_reset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|str_concatc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|str_copyc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|str_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|str_trunc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, display only a total for each argument. */
end_comment

begin_decl_stmt
name|int
name|opt_summarize_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, display counts for all files, not just directories. */
end_comment

begin_decl_stmt
name|int
name|opt_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, count each hard link of files with multiple links. */
end_comment

begin_decl_stmt
name|int
name|opt_count_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not cross file-system boundaries. */
end_comment

begin_decl_stmt
name|int
name|opt_one_file_system
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, print a grand total at the end. */
end_comment

begin_decl_stmt
name|int
name|opt_combined_arguments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not add sizes of subdirectories. */
end_comment

begin_decl_stmt
name|int
name|opt_separate_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, dereference symlinks that are command line arguments. */
end_comment

begin_decl_stmt
name|int
name|opt_dereference_arguments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|output_size
block|{
name|size_blocks
block|,
comment|/* 512-byte blocks. */
name|size_kilobytes
block|,
comment|/* 1K blocks. */
name|size_bytes
comment|/* 1-byte blocks. */
block|}
enum|;
end_enum

begin_comment
comment|/* The units to count in. */
end_comment

begin_decl_stmt
name|enum
name|output_size
name|output_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accumulated path for file or directory being processed.  */
end_comment

begin_decl_stmt
name|string
name|path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to hash structure, used by the hash routines.  */
end_comment

begin_decl_stmt
name|struct
name|htab
modifier|*
name|htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Globally used stat buffer.  */
end_comment

begin_decl_stmt
name|struct
name|stat
name|stat_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to either lstat or stat, depending on whether    dereferencing of all symbolic links is to be done. */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|xstat
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The exit status to use if we don't get any fatal errors. */
end_comment

begin_decl_stmt
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
literal|0
block|,
operator|&
name|opt_all
block|,
literal|1
block|}
block|,
block|{
literal|"bytes"
block|,
literal|0
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"count-links"
block|,
literal|0
block|,
operator|&
name|opt_count_all
block|,
literal|1
block|}
block|,
block|{
literal|"dereference"
block|,
literal|0
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"dereference-args"
block|,
literal|0
block|,
operator|&
name|opt_dereference_arguments
block|,
literal|1
block|}
block|,
block|{
literal|"kilobytes"
block|,
literal|0
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"one-file-system"
block|,
literal|0
block|,
operator|&
name|opt_one_file_system
block|,
literal|1
block|}
block|,
block|{
literal|"separate-dirs"
block|,
literal|0
block|,
operator|&
name|opt_separate_dirs
block|,
literal|1
block|}
block|,
block|{
literal|"summarize"
block|,
literal|0
block|,
operator|&
name|opt_summarize_only
block|,
literal|1
block|}
block|,
block|{
literal|"total"
block|,
literal|0
block|,
operator|&
name|opt_combined_arguments
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|reason
parameter_list|)
name|char
modifier|*
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-abcklsxDLS] [--all] [--total] [--count-links] [--summarize]\n\        [--bytes] [--kilobytes] [--one-file-system] [--separate-dirs]\n\        [--dereference] [--dereference-args] [path...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xstat
operator|=
name|lstat
expr_stmt|;
name|output_size
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
condition|?
name|size_blocks
else|:
name|size_kilobytes
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abcklsxDLS"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long option. */
break|break;
case|case
literal|'a'
case|:
name|opt_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|output_size
operator|=
name|size_bytes
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|opt_combined_arguments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|output_size
operator|=
name|size_kilobytes
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|opt_count_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|opt_summarize_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt_one_file_system
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|opt_dereference_arguments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|xstat
operator|=
name|stat
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|opt_separate_dirs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opt_all
operator|&&
name|opt_summarize_only
condition|)
name|usage
argument_list|(
literal|"cannot both summarize and show all entries"
argument_list|)
expr_stmt|;
comment|/* Initialize the hash structure for inode numbers.  */
name|hash_init
argument_list|(
name|INITIAL_HASH_MODULE
argument_list|,
name|INITIAL_ENTRY_TAB_SIZE
argument_list|)
expr_stmt|;
name|str_init
argument_list|(
operator|&
name|path
argument_list|,
name|INITIAL_PATH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|str_copyc
argument_list|(
name|path
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* Initialize the hash structure for inode numbers.  */
name|hash_reset
argument_list|()
expr_stmt|;
comment|/* Get the size of the current directory only.  */
name|count_entry
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|du_files
argument_list|(
name|argv
operator|+
name|optind
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recursively print the sizes of the directories (and, if selected, files)    named in FILES, the last entry of which is NULL.  */
end_comment

begin_function
name|void
name|du_files
parameter_list|(
name|files
parameter_list|)
name|char
modifier|*
modifier|*
name|files
decl_stmt|;
block|{
name|char
modifier|*
name|wd
decl_stmt|;
name|ino_t
name|initial_ino
decl_stmt|;
comment|/* Initial directory's inode. */
name|dev_t
name|initial_dev
decl_stmt|;
comment|/* Initial directory's device. */
name|long
name|tot_size
init|=
literal|0L
decl_stmt|;
comment|/* Grand total size of all args. */
name|int
name|i
decl_stmt|;
comment|/* Index in FILES. */
name|wd
operator|=
name|xgetcwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|wd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get current directory"
argument_list|)
expr_stmt|;
comment|/* Remember the inode and device number of the current directory.  */
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stat_buf
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"current directory"
argument_list|)
expr_stmt|;
name|initial_ino
operator|=
name|stat_buf
operator|.
name|st_ino
expr_stmt|;
name|initial_dev
operator|=
name|stat_buf
operator|.
name|st_dev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|arg
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
comment|/* Delete final slash in the argument, unless the slash is alone.  */
name|s
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arg
index|[
name|s
index|]
operator|==
literal|'/'
condition|)
name|arg
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
name|str_copyc
argument_list|(
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|str_trunc
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Null path for root directory.  */
else|else
name|str_copyc
argument_list|(
name|path
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_combined_arguments
condition|)
name|hash_reset
argument_list|()
expr_stmt|;
name|tot_size
operator|+=
name|count_entry
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* chdir if `count_entry' has changed the working directory.  */
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stat_buf
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat_buf
operator|.
name|st_ino
operator|!=
name|initial_ino
operator|||
name|stat_buf
operator|.
name|st_dev
operator|!=
name|initial_dev
operator|)
operator|&&
name|chdir
argument_list|(
name|wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change to directory %s"
argument_list|,
name|wd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt_combined_arguments
condition|)
block|{
name|printf
argument_list|(
literal|"%ld\ttotal\n"
argument_list|,
name|output_size
operator|==
name|size_bytes
condition|?
name|tot_size
else|:
name|convert_blocks
argument_list|(
name|tot_size
argument_list|,
name|output_size
operator|==
name|size_kilobytes
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|wd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print (if appropriate) and return the size    (in units determined by `output_size') of file or directory ENT.    TOP is one for external calls, zero for recursive calls.    LAST_DEV is the device that the parent directory of ENT is on.  */
end_comment

begin_function
name|long
name|count_entry
parameter_list|(
name|ent
parameter_list|,
name|top
parameter_list|,
name|last_dev
parameter_list|)
name|char
modifier|*
name|ent
decl_stmt|;
name|int
name|top
decl_stmt|;
name|dev_t
name|last_dev
decl_stmt|;
block|{
name|long
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|top
operator|&&
name|opt_dereference_arguments
condition|?
name|stat
argument_list|(
name|ent
argument_list|,
operator|&
name|stat_buf
argument_list|)
else|:
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|ent
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|path
operator|->
name|text
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|opt_count_all
operator|&&
name|stat_buf
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
name|hash_insert
argument_list|(
name|stat_buf
operator|.
name|st_ino
argument_list|,
name|stat_buf
operator|.
name|st_dev
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Have counted this already.  */
if|if
condition|(
name|output_size
operator|==
name|size_bytes
condition|)
name|size
operator|=
name|stat_buf
operator|.
name|st_size
expr_stmt|;
else|else
name|size
operator|=
name|ST_NBLOCKS
argument_list|(
name|stat_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|unsigned
name|pathlen
decl_stmt|;
name|dev_t
name|dir_dev
decl_stmt|;
name|char
modifier|*
name|name_space
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
name|dir_dev
operator|=
name|stat_buf
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|opt_one_file_system
operator|&&
operator|!
name|top
operator|&&
name|last_dev
operator|!=
name|dir_dev
condition|)
return|return
literal|0
return|;
comment|/* Don't enter a new file system.  */
if|if
condition|(
name|chdir
argument_list|(
name|ent
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change to directory %s"
argument_list|,
name|path
operator|->
name|text
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|name_space
operator|=
name|savedir
argument_list|(
literal|"."
argument_list|,
name|stat_buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_space
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|path
operator|->
name|text
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
comment|/* Try to return to previous directory.  */
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the current path.  */
name|str_concatc
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|pathlen
operator|=
name|path
operator|->
name|length
expr_stmt|;
name|namep
operator|=
name|name_space
expr_stmt|;
while|while
condition|(
operator|*
name|namep
operator|!=
literal|0
condition|)
block|{
name|str_concatc
argument_list|(
name|path
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|size
operator|+=
name|count_entry
argument_list|(
name|namep
argument_list|,
literal|0
argument_list|,
name|dir_dev
argument_list|)
expr_stmt|;
name|str_trunc
argument_list|(
name|path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|namep
operator|+=
name|strlen
argument_list|(
name|namep
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|name_space
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_summarize_only
operator|||
name|top
condition|)
block|{
name|printf
argument_list|(
literal|"%ld\t%s\n"
argument_list|,
name|output_size
operator|==
name|size_bytes
condition|?
name|size
else|:
name|convert_blocks
argument_list|(
name|size
argument_list|,
name|output_size
operator|==
name|size_kilobytes
argument_list|)
argument_list|,
name|path
operator|->
name|text
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|opt_separate_dirs
condition|?
literal|0
else|:
name|size
return|;
block|}
elseif|else
if|if
condition|(
name|opt_all
operator|||
name|top
condition|)
block|{
name|printf
argument_list|(
literal|"%ld\t%s\n"
argument_list|,
name|output_size
operator|==
name|size_bytes
condition|?
name|size
else|:
name|convert_blocks
argument_list|(
name|size
argument_list|,
name|output_size
operator|==
name|size_kilobytes
argument_list|)
argument_list|,
name|path
operator|->
name|text
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate space for the hash structures, and set the global    variable `htab' to point to it.  The initial hash module is specified in    MODULUS, and the number of entries are specified in ENTRY_TAB_SIZE.  (The    hash structure will be rebuilt when ENTRY_TAB_SIZE entries have been    inserted, and MODULUS and ENTRY_TAB_SIZE in the global `htab' will be    doubled.)  */
end_comment

begin_function
name|void
name|hash_init
parameter_list|(
name|modulus
parameter_list|,
name|entry_tab_size
parameter_list|)
name|unsigned
name|modulus
decl_stmt|;
name|unsigned
name|entry_tab_size
decl_stmt|;
block|{
name|struct
name|htab
modifier|*
name|htab_r
decl_stmt|;
name|htab_r
operator|=
operator|(
expr|struct
name|htab
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|*
name|modulus
argument_list|)
expr_stmt|;
name|htab_r
operator|->
name|entry_tab
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
operator|*
name|entry_tab_size
argument_list|)
expr_stmt|;
name|htab_r
operator|->
name|modulus
operator|=
name|modulus
expr_stmt|;
name|htab_r
operator|->
name|entry_tab_size
operator|=
name|entry_tab_size
expr_stmt|;
name|htab
operator|=
name|htab_r
expr_stmt|;
name|hash_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the hash structure in the global variable `htab' to    contain no entries.  */
end_comment

begin_function
name|void
name|hash_reset
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|struct
name|entry
modifier|*
modifier|*
name|p
decl_stmt|;
name|htab
operator|->
name|first_free_entry
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|htab
operator|->
name|hash
expr_stmt|;
for|for
control|(
name|i
operator|=
name|htab
operator|->
name|modulus
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert an item (inode INO and device DEV) in the hash    structure in the global variable `htab', if an entry with the same data    was not found already.  Return zero if the item was inserted and non-zero    if it wasn't.  */
end_comment

begin_function
name|int
name|hash_insert
parameter_list|(
name|ino
parameter_list|,
name|dev
parameter_list|)
name|ino_t
name|ino
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
block|{
name|struct
name|htab
modifier|*
name|htab_r
init|=
name|htab
decl_stmt|;
comment|/* Initially a copy of the global `htab'.  */
if|if
condition|(
name|htab_r
operator|->
name|first_free_entry
operator|>=
name|htab_r
operator|->
name|entry_tab_size
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|modulus
decl_stmt|;
name|unsigned
name|entry_tab_size
decl_stmt|;
comment|/* Increase the number of hash entries, and re-hash the data. 	 The method of shrimping and increasing is made to compactify 	 the heap.  If twice as much data would be allocated 	 straightforwardly, we would never re-use a byte of memory.  */
comment|/* Let `htab' shrimp.  Keep only the header, not the pointer vector.  */
name|htab_r
operator|=
operator|(
expr|struct
name|htab
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|htab_r
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
argument_list|)
expr_stmt|;
name|modulus
operator|=
literal|2
operator|*
name|htab_r
operator|->
name|modulus
expr_stmt|;
name|entry_tab_size
operator|=
literal|2
operator|*
name|htab_r
operator|->
name|entry_tab_size
expr_stmt|;
comment|/* Increase the number of possible entries.  */
name|htab_r
operator|->
name|entry_tab
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|htab_r
operator|->
name|entry_tab
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
operator|*
name|entry_tab_size
argument_list|)
expr_stmt|;
comment|/* Increase the size of htab again.  */
name|htab_r
operator|=
operator|(
expr|struct
name|htab
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|htab_r
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|*
name|modulus
argument_list|)
expr_stmt|;
name|htab_r
operator|->
name|modulus
operator|=
name|modulus
expr_stmt|;
name|htab_r
operator|->
name|entry_tab_size
operator|=
name|entry_tab_size
expr_stmt|;
name|htab
operator|=
name|htab_r
expr_stmt|;
name|i
operator|=
name|htab_r
operator|->
name|first_free_entry
expr_stmt|;
comment|/* Make the increased hash table empty.  The entries are still 	 available in htab->entry_tab.  */
name|hash_reset
argument_list|()
expr_stmt|;
comment|/* Go through the entries and install them in the pointer vector 	 htab->hash.  The items are actually inserted in htab->entry_tab at 	 the position where they already are.  The htab->coll_link need 	 however be updated.  Could be made a little more efficient.  */
for|for
control|(
name|ep
operator|=
name|htab_r
operator|->
name|entry_tab
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|hash_insert2
argument_list|(
name|htab_r
argument_list|,
name|ep
operator|->
name|ino
argument_list|,
name|ep
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ep
operator|++
expr_stmt|;
block|}
block|}
return|return
name|hash_insert2
argument_list|(
name|htab_r
argument_list|,
name|ino
argument_list|,
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Insert INO and DEV in the hash structure HTAB, if not    already present.  Return zero if inserted and non-zero if it    already existed.  */
end_comment

begin_function
name|int
name|hash_insert2
parameter_list|(
name|htab
parameter_list|,
name|ino
parameter_list|,
name|dev
parameter_list|)
name|struct
name|htab
modifier|*
name|htab
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
block|{
name|struct
name|entry
modifier|*
modifier|*
name|hp
decl_stmt|,
modifier|*
name|ep2
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|hp
operator|=
operator|&
name|htab
operator|->
name|hash
index|[
name|ino
operator|%
name|htab
operator|->
name|modulus
index|]
expr_stmt|;
name|ep2
operator|=
operator|*
name|hp
expr_stmt|;
comment|/* Collision?  */
if|if
condition|(
name|ep2
operator|!=
name|NULL
condition|)
block|{
name|ep
operator|=
name|ep2
expr_stmt|;
comment|/* Search for an entry with the same data.  */
do|do
block|{
if|if
condition|(
name|ep
operator|->
name|ino
operator|==
name|ino
operator|&&
name|ep
operator|->
name|dev
operator|==
name|dev
condition|)
return|return
literal|1
return|;
comment|/* Found an entry with the same data.  */
name|ep
operator|=
name|ep
operator|->
name|coll_link
expr_stmt|;
block|}
do|while
condition|(
name|ep
operator|!=
name|NULL
condition|)
do|;
comment|/* Did not find it.  */
block|}
name|ep
operator|=
operator|*
name|hp
operator|=
operator|&
name|htab
operator|->
name|entry_tab
index|[
name|htab
operator|->
name|first_free_entry
operator|++
index|]
expr_stmt|;
name|ep
operator|->
name|ino
operator|=
name|ino
expr_stmt|;
name|ep
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ep
operator|->
name|coll_link
operator|=
name|ep2
expr_stmt|;
comment|/* `ep2' is NULL if no collision.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the struct string S1 for holding SIZE characters.  */
end_comment

begin_function
name|void
name|str_init
parameter_list|(
name|s1
parameter_list|,
name|size
parameter_list|)
name|string
modifier|*
name|s1
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|string
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|string
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stringstruct
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|text
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|alloc
operator|=
name|size
expr_stmt|;
operator|*
name|s1
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ensure_space
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|)
name|string
name|s
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|alloc
operator|<
name|size
condition|)
block|{
name|s
operator|->
name|text
operator|=
name|xrealloc
argument_list|(
name|s
operator|->
name|text
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|alloc
operator|=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assign the null-terminated C-string CSTR to S1.  */
end_comment

begin_function
name|void
name|str_copyc
parameter_list|(
name|s1
parameter_list|,
name|cstr
parameter_list|)
name|string
name|s1
decl_stmt|;
name|char
modifier|*
name|cstr
decl_stmt|;
block|{
name|unsigned
name|l
init|=
name|strlen
argument_list|(
name|cstr
argument_list|)
decl_stmt|;
name|ensure_space
argument_list|(
name|s1
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s1
operator|->
name|text
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
name|s1
operator|->
name|length
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
name|void
name|str_concatc
parameter_list|(
name|s1
parameter_list|,
name|cstr
parameter_list|)
name|string
name|s1
decl_stmt|;
name|char
modifier|*
name|cstr
decl_stmt|;
block|{
name|unsigned
name|l1
init|=
name|s1
operator|->
name|length
decl_stmt|;
name|unsigned
name|l2
init|=
name|strlen
argument_list|(
name|cstr
argument_list|)
decl_stmt|;
name|unsigned
name|l
init|=
name|l1
operator|+
name|l2
decl_stmt|;
name|ensure_space
argument_list|(
name|s1
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s1
operator|->
name|text
operator|+
name|l1
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
name|s1
operator|->
name|length
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate the string S1 to have length LENGTH.  */
end_comment

begin_function
name|void
name|str_trunc
parameter_list|(
name|s1
parameter_list|,
name|length
parameter_list|)
name|string
name|s1
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
block|{
if|if
condition|(
name|s1
operator|->
name|length
operator|>
name|length
condition|)
block|{
name|s1
operator|->
name|text
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|s1
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
block|}
end_function

end_unit

