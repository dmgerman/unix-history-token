begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mv -- move or rename files    Copyright (C) 1986, 1989, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Options:    -f, --force		Assume a 'y' answer to all questions it would 			normally ask, and not ask the questions.     -i, --interactive	Require confirmation from the user before 			performing any move that would destroy an 			existing file.      -u, --update		Do not move a nondirectory that has an 			existing destination with the same or newer 			modification time.       -v, --verbose		List the name of each file as it is moved, and 			the name it is moved to.      -b, --backup    -S, --suffix    -V, --version-control 			Backup file creation.     Written by Mike Parker and David MacKenzie */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"backupfile.h"
end_include

begin_function_decl
name|enum
name|backup_type
name|get_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|copy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_move
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eaccess_stat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isdir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|movefile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|yesno
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|strip_trailing_slashes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, query the user before overwriting files. */
end_comment

begin_decl_stmt
name|int
name|interactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not query the user before overwriting unwritable    files. */
end_comment

begin_decl_stmt
name|int
name|override_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not move a nondirectory that has an existing destination    with the same or newer modification time. */
end_comment

begin_decl_stmt
name|int
name|update
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, list each file as it is moved. */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, stdin is a tty. */
end_comment

begin_decl_stmt
name|int
name|stdin_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"backup"
block|,
literal|0
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"force"
block|,
literal|0
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"interactive"
block|,
literal|0
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"suffix"
block|,
literal|1
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"update"
block|,
literal|0
block|,
operator|&
name|update
block|,
literal|1
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|verbose
block|,
literal|1
block|}
block|,
block|{
literal|"version-control"
block|,
literal|1
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|errors
decl_stmt|;
name|int
name|make_backups
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|version
operator|=
name|getenv
argument_list|(
literal|"SIMPLE_BACKUP_SUFFIX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
condition|)
name|simple_backup_suffix
operator|=
name|version
expr_stmt|;
name|version
operator|=
name|getenv
argument_list|(
literal|"VERSION_CONTROL"
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|interactive
operator|=
name|override_mode
operator|=
name|verbose
operator|=
name|update
operator|=
literal|0
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"bfiuvS:V:"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'b'
case|:
name|make_backups
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|interactive
operator|=
literal|0
expr_stmt|;
name|override_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
literal|1
expr_stmt|;
name|override_mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|update
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|simple_backup_suffix
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|version
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|<
name|optind
operator|+
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|make_backups
condition|)
name|backup_type
operator|=
name|get_version
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|stdin_tty
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
name|optind
operator|+
literal|2
operator|&&
operator|!
name|isdir
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"when moving multiple files, last argument must be a directory"
argument_list|)
expr_stmt|;
comment|/* Move each arg but the last onto the last. */
for|for
control|(
init|;
name|optind
operator|<
name|argc
operator|-
literal|1
condition|;
operator|++
name|optind
control|)
name|errors
operator||=
name|movefile
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move file FROM onto TO.  Handles the case when TO is a directory.    Return 0 if successful, 1 if an error occurred.  */
end_comment

begin_function
name|int
name|movefile
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|strip_trailing_slashes
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|to
argument_list|)
condition|)
block|{
comment|/* Target is a directory; build full target filename. */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|newto
decl_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|from
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
else|else
name|cp
operator|=
name|from
expr_stmt|;
name|newto
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newto
argument_list|,
literal|"%s/%s"
argument_list|,
name|to
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|do_move
argument_list|(
name|from
argument_list|,
name|newto
argument_list|)
return|;
block|}
else|else
return|return
name|do_move
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|stat
name|to_stats
decl_stmt|,
name|from_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move FROM onto TO.  Handles cross-filesystem moves.    If TO is a directory, FROM must be also.    Return 0 if successful, 1 if an error occurred.  */
end_comment

begin_function
name|int
name|do_move
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|char
modifier|*
name|to_backup
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|from
argument_list|,
operator|&
name|from_stats
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|to
argument_list|,
operator|&
name|to_stats
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|from_stats
operator|.
name|st_dev
operator|==
name|to_stats
operator|.
name|st_dev
operator|&&
name|from_stats
operator|.
name|st_ino
operator|==
name|to_stats
operator|.
name|st_ino
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' and `%s' are the same file"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|to_stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: cannot overwrite directory"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|from_stats
operator|.
name|st_mode
argument_list|)
operator|&&
name|update
operator|&&
name|from_stats
operator|.
name|st_mtime
operator|<=
name|to_stats
operator|.
name|st_mtime
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|override_mode
operator|&&
operator|(
name|interactive
operator|||
name|stdin_tty
operator|)
operator|&&
name|eaccess_stat
argument_list|(
operator|&
name|to_stats
argument_list|,
name|W_OK
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: replace `%s', overriding mode %04o? "
argument_list|,
name|program_name
argument_list|,
name|to
argument_list|,
name|to_stats
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yesno
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|interactive
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: replace `%s'? "
argument_list|,
name|program_name
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yesno
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|backup_type
operator|!=
name|none
condition|)
block|{
name|char
modifier|*
name|tmp_backup
init|=
name|find_backup_file_name
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_backup
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|to_backup
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp_backup
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|to_backup
argument_list|,
name|tmp_backup
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_backup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|to
argument_list|,
name|to_backup
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot backup `%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|to_backup
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s -> %s\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EXDEV
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot move `%s' to `%s'"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
comment|/* rename failed on cross-filesystem link.  Copy the file instead. */
if|if
condition|(
name|copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
goto|goto
name|un_backup
goto|;
if|if
condition|(
name|unlink
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove `%s'"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
name|un_backup
label|:
if|if
condition|(
name|to_backup
condition|)
block|{
if|if
condition|(
name|rename
argument_list|(
name|to_backup
argument_list|,
name|to
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot un-backup `%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy file FROM onto file TO.    Return 1 if an error occurred, 0 if successful. */
end_comment

begin_function
name|int
name|copy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|int
name|ifd
decl_stmt|;
name|int
name|ofd
decl_stmt|;
name|char
name|buf
index|[
literal|1024
operator|*
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Number of bytes read into `buf'. */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|from_stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot move `%s' across filesystems: Not a regular file"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|to
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove `%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ifd
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ofd
operator|=
name|open
argument_list|(
name|to
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifndef|#
directive|ifndef
name|FCHMOD_MISSING
if|if
condition|(
name|fchmod
argument_list|(
name|ofd
argument_list|,
name|from_stats
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|wrote
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
do|do
block|{
name|wrote
operator|=
name|write
argument_list|(
name|ofd
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bp
operator|+=
name|wrote
expr_stmt|;
name|len
operator|-=
name|wrote
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|ifd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|ofd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|FCHMOD_MISSING
if|if
condition|(
name|chmod
argument_list|(
name|to
argument_list|,
name|from_stats
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Try to copy the old file's modtime and access time.  */
block|{
name|struct
name|utimbuf
name|tv
decl_stmt|;
name|tv
operator|.
name|actime
operator|=
name|from_stats
operator|.
name|st_atime
expr_stmt|;
name|tv
operator|.
name|modtime
operator|=
name|from_stats
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|to
argument_list|,
operator|&
name|tv
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|chown
argument_list|(
name|to
argument_list|,
name|from_stats
operator|.
name|st_uid
argument_list|,
name|from_stats
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [options] source dest\n\        %s [options] source... directory\n\ Options:\n\        [-bfiuv] [-S backup-suffix] [-V {numbered,existing,simple}]\n\        [--backup] [--force] [--interactive] [--update] [--verbose]\n\        [--suffix=backup-suffix] [--version-control={numbered,existing,simple}]\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

