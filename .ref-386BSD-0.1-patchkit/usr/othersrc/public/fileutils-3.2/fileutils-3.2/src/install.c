begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* install - copy files and set attributes    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Copy files and set their permission modes and, if possible,    their owner and group.  Used similarly to `cp'; typically    used in Makefiles to copy programs into their destination    directories.  It can also be used to create the destination    directories and any leading directories, and to set the final    directory's modes.  It refuses to copy files onto themselves.     Options:    -g, --group=GROUP 	Set the group ownership of the installed file or directory 	to the group ID of GROUP (default is process's current 	group).  GROUP may also be a numeric group ID.     -m, --mode=MODE 	Set the permission mode for the installed file or directory 	to MODE, which is an octal number (default is 0755).     -o, --owner=OWNER 	If run as root, set the ownership of the installed file to 	the user ID of OWNER (default is root).  OWNER may also be 	a numeric user ID.     -c	No effect.  For compatibility with old Unix versions of install.     -s, --strip 	Strip the symbol tables from installed files.     -d, --directory 	Create a directory and its leading directories, if they 	do not already exist.  Set the owner, group and mode 	as given on the command line.  Any leading directories 	that are created are also given those attributes. 	This is different from the SunOS 4.0 install, which gives 	directories that it creates the default attributes.     David MacKenzie<djm@gnu.ai.mit.edu> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"modechange.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_VERSION
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|uid_t
name|getuid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|gid_t
name|getgid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wait
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|endpwent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|endgrent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_comment
comment|/* True if C is an ASCII octal digit. */
end_comment

begin_define
define|#
directive|define
name|isodigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& c<= '7')
end_define

begin_comment
comment|/* Number of bytes of a file to copy at a time. */
end_comment

begin_define
define|#
directive|define
name|READ_SIZE
value|(32 * 1024)
end_define

begin_function_decl
name|char
modifier|*
name|basename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|change_attributes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|copy_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|install_dir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|install_file_in_dir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|install_file_in_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isdir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|make_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isnumber
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_ids
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|strip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|strip_trailing_slashes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with, for error messages. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user name that will own the files, or NULL to make the owner    the current user ID. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|owner_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user ID corresponding to `owner_name'. */
end_comment

begin_decl_stmt
name|uid_t
name|owner_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The group name that will own the files, or NULL to make the group    the current group ID. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|group_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The group ID corresponding to `group_name'. */
end_comment

begin_decl_stmt
name|gid_t
name|group_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The permissions to which the files will be set.  The umask has    no effect. */
end_comment

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, strip executable files after copying them. */
end_comment

begin_decl_stmt
name|int
name|strip_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, install a directory instead of a regular file. */
end_comment

begin_decl_stmt
name|int
name|dir_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"strip"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"directory"
block|,
literal|0
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"group"
block|,
literal|1
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"mode"
block|,
literal|1
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"owner"
block|,
literal|1
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optc
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|symbolic_mode
init|=
name|NULL
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|owner_name
operator|=
name|NULL
expr_stmt|;
name|group_name
operator|=
name|NULL
expr_stmt|;
name|mode
operator|=
literal|0755
expr_stmt|;
name|strip_files
operator|=
literal|0
expr_stmt|;
name|dir_arg
operator|=
literal|0
expr_stmt|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"csdg:m:o:"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'c'
case|:
break|break;
case|case
literal|'s'
case|:
name|strip_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dir_arg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|group_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|symbolic_mode
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|owner_name
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Check for invalid combinations of arguments. */
if|if
condition|(
operator|(
name|dir_arg
operator|&&
name|strip_files
operator|)
operator|||
operator|(
name|optind
operator|==
name|argc
operator|)
operator|||
operator|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|&&
operator|!
name|dir_arg
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbolic_mode
condition|)
block|{
name|struct
name|mode_change
modifier|*
name|change
init|=
name|mode_compile
argument_list|(
name|symbolic_mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|==
name|MODE_INVALID
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid mode `%s'"
argument_list|,
name|symbolic_mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|change
operator|==
name|MODE_MEMORY_EXHAUSTED
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mode_adjust
argument_list|(
literal|0
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
name|get_ids
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir_arg
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|errors
operator||=
name|make_path
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|,
name|owner_id
argument_list|,
name|group_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|2
condition|)
block|{
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
condition|)
name|errors
operator|=
name|install_file_in_file
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|2
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|errors
operator|=
name|install_file_in_dir
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|2
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
operator|-
literal|1
condition|;
operator|++
name|optind
control|)
block|{
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|errors
operator||=
name|install_file_in_dir
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|exit
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy file FROM onto file TO and give TO the appropriate    attributes.    Return 0 if successful, 1 if an error occurs. */
end_comment

begin_function
name|int
name|install_file_in_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|copy_file
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strip_files
condition|)
name|strip
argument_list|(
name|to
argument_list|)
expr_stmt|;
return|return
name|change_attributes
argument_list|(
name|to
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy file FROM into directory TO_DIR, keeping its same name,    and give the copy the appropriate attributes.    Return 0 if successful, 1 if not. */
end_comment

begin_function
name|int
name|install_file_in_dir
parameter_list|(
name|from
parameter_list|,
name|to_dir
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to_dir
decl_stmt|;
block|{
name|char
modifier|*
name|from_base
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|from_base
operator|=
name|basename
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|to
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|to_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|from_base
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|to
argument_list|,
literal|"%s/%s"
argument_list|,
name|to_dir
argument_list|,
name|from_base
argument_list|)
expr_stmt|;
name|ret
operator|=
name|install_file_in_file
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A chunk of a file being copied. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|buffer
index|[
name|READ_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy file FROM onto file TO, creating TO if necessary.    Return 0 if the copy is successful, 1 if not. */
end_comment

begin_function
name|int
name|copy_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|int
name|fromfd
decl_stmt|,
name|tofd
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|from_stats
decl_stmt|,
name|to_stats
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|from
argument_list|,
operator|&
name|from_stats
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|from_stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' is not a regular file"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|to_stats
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|to_stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' is not a regular file"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|from_stats
operator|.
name|st_dev
operator|==
name|to_stats
operator|.
name|st_dev
operator|&&
name|from_stats
operator|.
name|st_ino
operator|==
name|to_stats
operator|.
name|st_ino
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' and `%s' are the same file"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If unlink fails, try to proceed anyway.  */
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|fromfd
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromfd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Make sure to open the file in a mode that allows writing. */
name|tofd
operator|=
name|open
argument_list|(
name|to
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tofd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|bytes
operator|=
name|read
argument_list|(
name|fromfd
argument_list|,
name|buffer
argument_list|,
name|READ_SIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|tofd
argument_list|,
name|buffer
argument_list|,
name|bytes
argument_list|)
operator|!=
name|bytes
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
goto|goto
name|copy_error
goto|;
block|}
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
goto|goto
name|copy_error
goto|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fromfd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|tofd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
name|copy_error
label|:
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the attributes of file or directory PATH.    Return 0 if successful, 1 if not. */
end_comment

begin_function
name|int
name|change_attributes
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* chown must precede chmod because on some systems,      chown clears the set[ug]id bits for non-superusers,      resulting in incorrect permissions.      On System V, users can give away files with chown and then not      be able to chmod them.  So don't give files away.  */
if|if
condition|(
name|chown
argument_list|(
name|path
argument_list|,
name|owner_id
argument_list|,
name|group_id
argument_list|)
condition|)
name|err
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
condition|)
name|err
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|err
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Strip the symbol table from the file PATH.    We could dig the magic number out of the file first to    determine whether to strip it, but the header files and    magic numbers vary so much from system to system that making    it portable would be very difficult.  Not worth the effort. */
end_comment

begin_function
name|void
name|strip
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Child. */
name|execlp
argument_list|(
literal|"strip"
argument_list|,
literal|"strip"
argument_list|,
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot run strip"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Parent. */
comment|/* Parent process. */
while|while
condition|(
name|pid
operator|!=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
condition|)
comment|/* Wait for kid to finish. */
comment|/* Do nothing. */
empty_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the user and group ownership of the files to install. */
end_comment

begin_function
name|void
name|get_ids
parameter_list|()
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
if|if
condition|(
name|owner_name
condition|)
block|{
name|pw
operator|=
name|getpwnam
argument_list|(
name|owner_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isnumber
argument_list|(
name|owner_name
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid user `%s'"
argument_list|,
name|owner_name
argument_list|)
expr_stmt|;
name|owner_id
operator|=
name|atoi
argument_list|(
name|owner_name
argument_list|)
expr_stmt|;
block|}
else|else
name|owner_id
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
block|}
else|else
name|owner_id
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|group_name
condition|)
block|{
name|gr
operator|=
name|getgrnam
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isnumber
argument_list|(
name|group_name
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid group `%s'"
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
name|group_id
operator|=
name|atoi
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
block|}
else|else
name|group_id
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
block|}
else|else
name|group_id
operator|=
name|getgid
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if STR is an ASCII representation of a nonzero    decimal integer, zero if not. */
end_comment

begin_function
name|int
name|isnumber
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [options] [-s] [--strip] source dest\n\        %s [options] [-s] [--strip] source... directory\n\        %s [options] {-d,--directory} directory...\n\ Options:\n\        [-c] [-g group] [-m mode] [-o owner]\n\        [--group=group] [--mode=mode] [--owner=owner]\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

