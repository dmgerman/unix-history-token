begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* makepath.c -- Ensure that a directory path exists.    Copyright (C) 1990 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@ai.mit.edu> and    Jim Meyering<meyering@cs.utexas.edu>. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|alloca
end_ifdef

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Ensure that the directory ARGPATH exists.    Remove any trailing slashes from ARGPATH before calling this function.     Make any leading directories that don't already exist, with    permissions PARENT_MODE.    If the last element of ARGPATH does not exist, create it as    a new directory with permissions MODE.    If OWNER and GROUP are non-negative, make them the UID and GID of    created directories.    If VERBOSE_FMT_STRING is nonzero, use it as a printf format    string for printing a message after successfully making a directory,    with the name of the directory that was just made as an argument.     Return 0 if ARGPATH exists as a directory with the proper    ownership and permissions when done, otherwise 1. */
end_comment

begin_function
name|int
name|make_path
parameter_list|(
name|argpath
parameter_list|,
name|mode
parameter_list|,
name|parent_mode
parameter_list|,
name|owner
parameter_list|,
name|group
parameter_list|,
name|verbose_fmt_string
parameter_list|)
name|char
modifier|*
name|argpath
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|parent_mode
decl_stmt|;
name|int
name|owner
decl_stmt|;
name|int
name|group
decl_stmt|;
name|char
modifier|*
name|verbose_fmt_string
decl_stmt|;
block|{
name|char
modifier|*
name|dirpath
decl_stmt|;
comment|/* A copy we can scribble NULs on. */
name|struct
name|stat
name|stats
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|oldmask
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|dirpath
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|argpath
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirpath
argument_list|,
name|argpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dirpath
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|tmp_mode
decl_stmt|;
comment|/* Initial perms for leading dirs. */
name|int
name|re_protect
decl_stmt|;
comment|/* Should leading dirs be unwritable? */
struct|struct
name|ptr_list
block|{
name|char
modifier|*
name|dirname_end
decl_stmt|;
name|struct
name|ptr_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|ptr_list
modifier|*
name|p
decl_stmt|,
modifier|*
name|leading_dirs
init|=
name|NULL
decl_stmt|;
comment|/* If leading directories shouldn't be writable or executable, 	 or should have set[ug]id or sticky bits set and we are setting 	 their owners, we need to fix their permissions after making them. */
if|if
condition|(
operator|(
operator|(
name|parent_mode
operator|&
literal|0300
operator|)
operator|!=
literal|0300
operator|)
operator|||
operator|(
name|owner
operator|>=
literal|0
operator|&&
name|group
operator|>=
literal|0
operator|&&
operator|(
name|parent_mode
operator|&
literal|07000
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|tmp_mode
operator|=
literal|0700
expr_stmt|;
name|re_protect
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp_mode
operator|=
name|parent_mode
expr_stmt|;
name|re_protect
operator|=
literal|0
expr_stmt|;
block|}
name|slash
operator|=
name|dirpath
expr_stmt|;
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
while|while
condition|(
name|slash
operator|=
name|index
argument_list|(
name|slash
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dirpath
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|dirpath
argument_list|,
name|tmp_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|verbose_fmt_string
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|verbose_fmt_string
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|>=
literal|0
operator|&&
name|group
operator|>=
literal|0
operator|&&
name|chown
argument_list|(
name|dirpath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|re_protect
condition|)
block|{
name|struct
name|ptr_list
modifier|*
name|new
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptr_list
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|dirname_end
operator|=
name|slash
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|leading_dirs
expr_stmt|;
name|leading_dirs
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' exists but is not a directory"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|slash
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Avoid unnecessary calls to `stat' when given 	     pathnames containing multiple adjacent slashes.  */
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
block|}
comment|/* We're done making leading directories. 	 Make the final component of the path.  */
if|if
condition|(
name|mkdir
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|verbose_fmt_string
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|verbose_fmt_string
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|>=
literal|0
operator|&&
name|group
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|dirpath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
comment|/* chown may have turned off some permission bits we wanted. */
if|if
condition|(
operator|(
name|mode
operator|&
literal|07000
operator|)
operator|!=
literal|0
operator|&&
name|chmod
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If the mode for leading directories didn't include owner "wx" 	 privileges, we have to reset their protections to the correct 	 value.  */
for|for
control|(
name|p
operator|=
name|leading_dirs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
operator|*
operator|(
name|p
operator|->
name|dirname_end
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|dirpath
argument_list|,
name|parent_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We get here if the entire path already exists. */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' exists but is not a directory"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* chown must precede chmod because on some systems, 	 chown clears the set[ug]id bits for non-superusers, 	 resulting in incorrect permissions. 	 On System V, users can give away files with chown and then not 	 be able to chmod them.  So don't give files away.  */
if|if
condition|(
name|owner
operator|>=
literal|0
operator|&&
name|group
operator|>=
literal|0
operator|&&
name|chown
argument_list|(
name|dirpath
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

