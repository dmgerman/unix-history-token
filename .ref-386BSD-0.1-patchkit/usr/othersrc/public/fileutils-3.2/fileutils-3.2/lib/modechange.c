begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* modechange.c -- file mode manipulation    Copyright (C) 1989, 1990 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@ai.mit.edu> */
end_comment

begin_comment
comment|/* The ASCII mode string is compiled into a linked list of `struct    modechange', which can then be applied to each file to be changed.    We do this instead of re-parsing the ASCII string for each file    because the compiled form requires less computation to use; when    changing the mode of many files, this probably results in a    performance gain. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"modechange.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return newly allocated memory to hold one element of type TYPE. */
end_comment

begin_define
define|#
directive|define
name|talloc
parameter_list|(
name|type
parameter_list|)
value|((type *) malloc (sizeof (type)))
end_define

begin_define
define|#
directive|define
name|isodigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '7')
end_define

begin_function_decl
specifier|static
name|int
name|oatoi
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return a linked list of file mode change operations created from    MODE_STRING, an ASCII string that contains either an octal number    specifying an absolute mode, or symbolic mode change operations with    the form:    [ugoa...][[+-=][rwxXstugo...]...][,...]    MASKED_OPS is a bitmask indicating which symbolic mode operators (=+-)    should not affect bits set in the umask when no users are given.    Operators not selected in MASKED_OPS ignore the umask.     Return MODE_INVALID if `mode_string' does not contain a valid    representation of file mode change operations;    return MODE_MEMORY_EXHAUSTED if there is insufficient memory. */
end_comment

begin_function
name|struct
name|mode_change
modifier|*
name|mode_compile
parameter_list|(
name|mode_string
parameter_list|,
name|masked_ops
parameter_list|)
specifier|register
name|char
modifier|*
name|mode_string
decl_stmt|;
name|unsigned
name|masked_ops
decl_stmt|;
block|{
name|struct
name|mode_change
modifier|*
name|head
decl_stmt|;
comment|/* First element of the linked list. */
name|struct
name|mode_change
modifier|*
name|change
decl_stmt|;
comment|/* An element of the linked list. */
name|int
name|i
decl_stmt|;
comment|/* General purpose temporary. */
name|int
name|umask_value
decl_stmt|;
comment|/* The umask value (surprise). */
name|unsigned
name|short
name|affected_bits
decl_stmt|;
comment|/* Which bits in the mode are operated on. */
name|unsigned
name|short
name|affected_masked
decl_stmt|;
comment|/* `affected_bits' modified by umask. */
name|unsigned
name|ops_to_mask
decl_stmt|;
comment|/* Operators to actually use umask on. */
name|i
operator|=
name|oatoi
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|07777
condition|)
return|return
name|MODE_INVALID
return|;
name|head
operator|=
name|talloc
argument_list|(
expr|struct
name|mode_change
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|op
operator|=
literal|'='
expr_stmt|;
name|head
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|value
operator|=
name|i
expr_stmt|;
name|head
operator|->
name|affected
operator|=
literal|07777
expr_stmt|;
comment|/* Affect all permissions. */
return|return
name|head
return|;
block|}
name|umask_value
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|umask_value
argument_list|)
expr_stmt|;
comment|/* Restore the old value. */
name|head
operator|=
name|NULL
expr_stmt|;
operator|--
name|mode_string
expr_stmt|;
comment|/* One loop iteration for each "ugoa...=+-rwxXstugo...[=+-rwxXstugo...]". */
do|do
block|{
name|affected_bits
operator|=
literal|0
expr_stmt|;
name|ops_to_mask
operator|=
literal|0
expr_stmt|;
comment|/* Turn on all the bits in `affected_bits' for each group given. */
for|for
control|(
operator|++
name|mode_string
init|;
condition|;
operator|++
name|mode_string
control|)
switch|switch
condition|(
operator|*
name|mode_string
condition|)
block|{
case|case
literal|'u'
case|:
name|affected_bits
operator||=
literal|04700
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|affected_bits
operator||=
literal|02070
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|affected_bits
operator||=
literal|01007
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|affected_bits
operator||=
literal|07777
expr_stmt|;
break|break;
default|default:
goto|goto
name|no_more_affected
goto|;
block|}
name|no_more_affected
label|:
comment|/* If none specified, affect all bits, except perhaps those 	 set in the umask. */
if|if
condition|(
name|affected_bits
operator|==
literal|0
condition|)
block|{
name|affected_bits
operator|=
literal|07777
expr_stmt|;
name|ops_to_mask
operator|=
name|masked_ops
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|mode_string
operator|==
literal|'='
operator|||
operator|*
name|mode_string
operator|==
literal|'+'
operator|||
operator|*
name|mode_string
operator|==
literal|'-'
condition|)
block|{
comment|/* Add the element to the tail of the list, so the operations 	     are performed in the correct order. */
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|head
operator|=
name|talloc
argument_list|(
expr|struct
name|mode_change
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
name|change
operator|=
name|head
expr_stmt|;
block|}
else|else
block|{
name|change
operator|->
name|next
operator|=
name|talloc
argument_list|(
expr|struct
name|mode_change
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|mode_free
argument_list|(
name|change
argument_list|)
expr_stmt|;
return|return
name|MODE_MEMORY_EXHAUSTED
return|;
block|}
name|change
operator|=
name|change
operator|->
name|next
expr_stmt|;
block|}
name|change
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|change
operator|->
name|op
operator|=
operator|*
name|mode_string
expr_stmt|;
comment|/* One of "=+-". */
name|affected_masked
operator|=
name|affected_bits
expr_stmt|;
if|if
condition|(
name|ops_to_mask
operator|&
operator|(
operator|*
name|mode_string
operator|==
literal|'='
condition|?
name|MODE_MASK_EQUALS
else|:
operator|*
name|mode_string
operator|==
literal|'+'
condition|?
name|MODE_MASK_PLUS
else|:
name|MODE_MASK_MINUS
operator|)
condition|)
name|affected_masked
operator|&=
operator|~
name|umask_value
expr_stmt|;
name|change
operator|->
name|affected
operator|=
name|affected_masked
expr_stmt|;
name|change
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|change
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Set `value' according to the bits set in `affected_masked'. */
for|for
control|(
operator|++
name|mode_string
init|;
condition|;
operator|++
name|mode_string
control|)
switch|switch
condition|(
operator|*
name|mode_string
condition|)
block|{
case|case
literal|'r'
case|:
name|change
operator|->
name|value
operator||=
literal|00444
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|change
operator|->
name|value
operator||=
literal|00222
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|change
operator|->
name|flags
operator||=
name|MODE_X_IF_ANY_X
expr_stmt|;
comment|/* Fall through. */
case|case
literal|'x'
case|:
name|change
operator|->
name|value
operator||=
literal|00111
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Set the setuid/gid bits if `u' or `g' is selected. */
name|change
operator|->
name|value
operator||=
literal|06000
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Set the "save text image" bit if `o' is selected. */
name|change
operator|->
name|value
operator||=
literal|01000
operator|&
name|affected_masked
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Set the affected bits to the value of the `u' bits 		   on the same file.  */
if|if
condition|(
name|change
operator|->
name|value
condition|)
goto|goto
name|invalid
goto|;
name|change
operator|->
name|value
operator|=
literal|00700
expr_stmt|;
name|change
operator|->
name|flags
operator||=
name|MODE_COPY_EXISTING
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Set the affected bits to the value of the `g' bits 		   on the same file.  */
if|if
condition|(
name|change
operator|->
name|value
condition|)
goto|goto
name|invalid
goto|;
name|change
operator|->
name|value
operator|=
literal|00070
expr_stmt|;
name|change
operator|->
name|flags
operator||=
name|MODE_COPY_EXISTING
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Set the affected bits to the value of the `o' bits 		   on the same file.  */
if|if
condition|(
name|change
operator|->
name|value
condition|)
goto|goto
name|invalid
goto|;
name|change
operator|->
name|value
operator|=
literal|00007
expr_stmt|;
name|change
operator|->
name|flags
operator||=
name|MODE_COPY_EXISTING
expr_stmt|;
break|break;
default|default:
goto|goto
name|no_more_values
goto|;
block|}
name|no_more_values
label|:
empty_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|mode_string
operator|==
literal|','
condition|)
do|;
if|if
condition|(
operator|*
name|mode_string
operator|==
literal|0
condition|)
return|return
name|head
return|;
name|invalid
label|:
name|mode_free
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|MODE_INVALID
return|;
block|}
end_function

begin_comment
comment|/* Return file mode OLDMODE, adjusted as indicated by the list of change    operations CHANGES.  If OLDMODE is a directory, the type `X'    change affects it even if no execute bits were set in OLDMODE.    The returned value has the S_IFMT bits cleared. */
end_comment

begin_function
name|unsigned
name|short
name|mode_adjust
parameter_list|(
name|oldmode
parameter_list|,
name|changes
parameter_list|)
name|unsigned
name|oldmode
decl_stmt|;
specifier|register
name|struct
name|mode_change
modifier|*
name|changes
decl_stmt|;
block|{
name|unsigned
name|short
name|newmode
decl_stmt|;
comment|/* The adjusted mode and one operand. */
name|unsigned
name|short
name|value
decl_stmt|;
comment|/* The other operand. */
name|newmode
operator|=
name|oldmode
operator|&
literal|07777
expr_stmt|;
for|for
control|(
init|;
name|changes
condition|;
name|changes
operator|=
name|changes
operator|->
name|next
control|)
block|{
if|if
condition|(
name|changes
operator|->
name|flags
operator|&
name|MODE_COPY_EXISTING
condition|)
block|{
comment|/* Isolate in `value' the bits in `newmode' to copy, given in 	     the mask `changes->value'. */
name|value
operator|=
name|newmode
operator|&
name|changes
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|changes
operator|->
name|value
operator|&
literal|00700
condition|)
comment|/* Copy `u' permissions onto `g' and `o'. */
name|value
operator||=
operator|(
name|value
operator|>>
literal|3
operator|)
operator||
operator|(
name|value
operator|>>
literal|6
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|changes
operator|->
name|value
operator|&
literal|00070
condition|)
comment|/* Copy `g' permissions onto `u' and `o'. */
name|value
operator||=
operator|(
name|value
operator|<<
literal|3
operator|)
operator||
operator|(
name|value
operator|>>
literal|3
operator|)
expr_stmt|;
else|else
comment|/* Copy `o' permissions onto `u' and `g'. */
name|value
operator||=
operator|(
name|value
operator|<<
literal|3
operator|)
operator||
operator|(
name|value
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* In order to change only `u', `g', or `o' permissions, 	     or some combination thereof, clear unselected bits. 	     This can not be done in mode_compile because the value 	     to which the `changes->affected' mask is applied depends 	     on the old mode of each file. */
name|value
operator|&=
name|changes
operator|->
name|affected
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|changes
operator|->
name|value
expr_stmt|;
comment|/* If `X', do not affect the execute bits if the file is not a 	     directory and no execute bits are already set. */
if|if
condition|(
operator|(
name|changes
operator|->
name|flags
operator|&
name|MODE_X_IF_ANY_X
operator|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|oldmode
argument_list|)
operator|&&
operator|(
name|newmode
operator|&
literal|00111
operator|)
operator|==
literal|0
condition|)
name|value
operator|&=
operator|~
literal|00111
expr_stmt|;
comment|/* Clear the execute bits. */
block|}
switch|switch
condition|(
name|changes
operator|->
name|op
condition|)
block|{
case|case
literal|'='
case|:
comment|/* Preserve the previous values in `newmode' of bits that are 	     not affected by this change operation. */
name|newmode
operator|=
operator|(
name|newmode
operator|&
operator|~
name|changes
operator|->
name|affected
operator|)
operator||
name|value
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|newmode
operator||=
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|newmode
operator|&=
operator|~
name|value
expr_stmt|;
break|break;
block|}
block|}
return|return
name|newmode
return|;
block|}
end_function

begin_comment
comment|/* Free the memory used by the list of file mode change operations    CHANGES. */
end_comment

begin_function
name|void
name|mode_free
parameter_list|(
name|changes
parameter_list|)
specifier|register
name|struct
name|mode_change
modifier|*
name|changes
decl_stmt|;
block|{
specifier|register
name|struct
name|mode_change
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|changes
condition|)
block|{
name|next
operator|=
name|changes
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|changes
argument_list|)
expr_stmt|;
name|changes
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a positive integer containing the value of the ASCII    octal number S.  If S is not an octal number, return -1.  */
end_comment

begin_function
specifier|static
name|int
name|oatoi
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|isodigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
name|i
operator|=
name|i
operator|*
literal|8
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i
return|;
block|}
end_function

end_unit

