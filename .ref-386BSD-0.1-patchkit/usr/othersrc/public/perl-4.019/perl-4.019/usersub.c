begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: usersub.c,v $$Revision: 4.0.1.1 $$Date: 91/11/11 16:47:17 $  *  *  This file contains stubs for routines that the user may define to  *  set up glue routines for C libraries or to decrypt encrypted scripts  *  for execution.  *  * $Log:	usersub.c,v $  * Revision 4.0.1.1  91/11/11  16:47:17  lwall  * patch19: deleted some unused functions from usersub.c  *   * Revision 4.0  91/03/20  01:55:56  lwall  * 4.0 baseline.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_macro
name|userinit
argument_list|()
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * The following is supplied by John Macdonald as a means of decrypting  * and executing (presumably proprietary) scripts that have been encrypted  * by a (presumably secret) method.  The idea is that you supply your own  * routine in place of cryptfilter (which is purposefully a very weak  * encryption).  If an encrypted script is detected, a process is forked  * off to run the cryptfilter routine as input to perl.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CRYPTSCRIPT
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|I_VFORK
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CRYPTLOCAL
end_ifdef

begin_include
include|#
directive|include
file|"cryptlocal.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ndef CRYPTLOCAL */
end_comment

begin_define
define|#
directive|define
name|CRYPT_MAGIC_1
value|0xfb
end_define

begin_define
define|#
directive|define
name|CRYPT_MAGIC_2
value|0xf1
end_define

begin_macro
name|cryptfilter
argument_list|(
argument|fil
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fil
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fil
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putchar
argument_list|(
operator|(
name|ch
operator|^
literal|0x80
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRYPTLOCAL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|lastpipefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipepid
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VOIDSIG
end_ifdef

begin_define
define|#
directive|define
name|VOID
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VOID
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|FILE
modifier|*
name|mypfiopen
argument_list|(
name|fil
argument_list|,
name|func
argument_list|)
comment|/* open a pipe to function call for input */
name|FILE
modifier|*
name|fil
decl_stmt|;
end_decl_stmt

begin_function_decl
name|VOID
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|fil
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Can't get pipe for decrypt"
argument_list|)
expr_stmt|;
block|}
comment|/* make sure that the child doesn't get anything extra */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pipepid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fil
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Can't fork for decrypt"
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipepid
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|func
call|)
argument_list|(
name|fil
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fileno
argument_list|(
name|fil
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fil
argument_list|)
expr_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|fdpid
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
name|pipepid
expr_stmt|;
return|return
name|fdopen
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
end_block

begin_macro
name|cryptswitch
argument_list|()
end_macro

begin_block
block|{
name|int
name|ch
decl_stmt|;
ifdef|#
directive|ifdef
name|STDSTDIO
comment|/* cheat on stdio if possible */
if|if
condition|(
name|rsfp
operator|->
name|_cnt
operator|>
literal|0
operator|&&
operator|(
operator|*
name|rsfp
operator|->
name|_ptr
operator|&
literal|0xff
operator|)
operator|!=
name|CRYPT_MAGIC_1
condition|)
return|return;
endif|#
directive|endif
name|ch
operator|=
name|getc
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CRYPT_MAGIC_1
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|rsfp
argument_list|)
operator|==
name|CRYPT_MAGIC_2
condition|)
block|{
if|if
condition|(
name|perldb
condition|)
name|fatal
argument_list|(
literal|"can't debug an encrypted script"
argument_list|)
expr_stmt|;
name|rsfp
operator|=
name|mypfiopen
argument_list|(
name|rsfp
argument_list|,
name|cryptfilter
argument_list|)
expr_stmt|;
name|preprocess
operator|=
literal|1
expr_stmt|;
comment|/* force call to pclose when done */
block|}
else|else
name|fatal
argument_list|(
literal|"bad encryption format"
argument_list|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|ch
argument_list|,
name|rsfp
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MSDOS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRYPTSCRIPT */
end_comment

end_unit

