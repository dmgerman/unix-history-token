begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * mem.c - memory management  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_comment
comment|/*  	mem.c - memory management  	This file is part of zsh, the Z shell.  	zsh is free software; no one can prevent you from reading the source    code, or giving it to someone else.     This file is copyrighted under the GNU General Public License, which    can be found in the file called COPYING.     Copyright (C) 1990, 1991 Paul Falstad  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_define
define|#
directive|define
name|HEAPSIZE
value|8192
end_define

begin_comment
comment|/*  	There are two ways to allocate memory in zsh.  The first way is 	to call zalloc/zcalloc, which call malloc/calloc directly.  It 	is legal to call realloc() or free() on memory allocated this way. 	The second way is to call halloc/hcalloc, which allocates memory 	from one of the memory pools on the heap stack.  A pool can be 	created by calling pushheap(), and destroyed by calling popheap(). 	To free the memory in the pool without destroying it, call 	freeheap(); this is equivalent to { popheap(); pushheap(); } 	Memory allocated in this way does not have to be freed explicitly; 	it will all be freed when the pool is destroyed.  In fact, 	attempting to free this memory may result in a core dump. 	The pair of pointers ncalloc and alloc may point to either 	zalloc& zcalloc or halloc& hcalloc; permalloc() sets them to the 	former, and heapalloc() sets them to the latter. This can be useful. 	For example, the dupstruct() routine duplicates a syntax tree, 	allocating the new memory for the tree using alloc().  If you want 	to duplicate a structure for a one-time use (i.e. to execute the list 	in a for loop), call heapalloc(), then dupstruct().  If you want 	to duplicate a structure in order to preserve it (i.e. a function 	definition), call permalloc(), then dupstruct().  */
end_comment

begin_comment
comment|/* initialize heap stack */
end_comment

begin_function
name|void
name|meminit
parameter_list|()
comment|/**/
block|{
name|permalloc
argument_list|()
expr_stmt|;
name|heaplist
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set default allocation to heap stack */
end_comment

begin_function
name|void
name|heapalloc
parameter_list|()
comment|/**/
block|{
name|alloc
operator|=
name|hcalloc
expr_stmt|;
name|ncalloc
operator|=
name|halloc
expr_stmt|;
name|useheap
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|vptr
argument_list|(
argument|*lastcalloc
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|vptr
argument_list|(
argument|*lastncalloc
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set default allocation to malloc() */
end_comment

begin_function
name|void
name|permalloc
parameter_list|()
comment|/**/
block|{
name|lastcalloc
operator|=
name|alloc
expr_stmt|;
name|lastncalloc
operator|=
name|ncalloc
expr_stmt|;
name|alloc
operator|=
name|zcalloc
expr_stmt|;
name|ncalloc
operator|=
name|zalloc
expr_stmt|;
name|useheap
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reset previous default allocation */
end_comment

begin_function
name|void
name|lastalloc
parameter_list|()
comment|/**/
block|{
name|alloc
operator|=
name|lastcalloc
expr_stmt|;
name|ncalloc
operator|=
name|lastncalloc
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|heap
block|{
name|char
modifier|*
name|pool
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|free
decl_stmt|;
name|struct
name|heap
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* create a memory pool */
end_comment

begin_function
name|void
name|pushheap
parameter_list|()
comment|/**/
block|{
name|Heap
name|h
decl_stmt|;
name|h
operator|=
operator|(
name|Heap
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|pool
operator|=
name|h
operator|->
name|ptr
operator|=
name|zalloc
argument_list|(
name|HEAPSIZE
argument_list|)
expr_stmt|;
name|h
operator|->
name|free
operator|=
name|HEAPSIZE
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|pushnode
argument_list|(
name|heaplist
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|lastalloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reset a memory pool */
end_comment

begin_function
name|void
name|freeheap
parameter_list|()
comment|/**/
block|{
name|Heap
name|h
init|=
operator|(
name|Heap
operator|)
name|peekfirst
argument_list|(
name|heaplist
argument_list|)
decl_stmt|;
name|freeh
argument_list|(
name|h
operator|->
name|next
argument_list|)
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|free
operator|+=
operator|(
name|h
operator|->
name|ptr
operator|-
name|h
operator|->
name|pool
operator|)
expr_stmt|;
name|h
operator|->
name|ptr
operator|=
name|h
operator|->
name|pool
expr_stmt|;
block|}
end_function

begin_comment
comment|/* destroy a memory pool */
end_comment

begin_function
name|void
name|popheap
parameter_list|()
comment|/**/
block|{
name|Heap
name|h
init|=
operator|(
name|Heap
operator|)
name|getnode
argument_list|(
name|heaplist
argument_list|)
decl_stmt|;
name|freeh
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freeh
parameter_list|(
name|h
parameter_list|)
comment|/**/
name|Heap
name|h
decl_stmt|;
block|{
if|if
condition|(
name|h
condition|)
block|{
name|freeh
argument_list|(
name|h
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
operator|->
name|pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* allocate memory from the current memory pool */
end_comment

begin_function
name|vptr
name|halloc
parameter_list|(
name|size
parameter_list|)
comment|/**/
name|int
name|size
decl_stmt|;
block|{
name|Heap
name|h
init|=
operator|(
name|Heap
operator|)
name|peekfirst
argument_list|(
name|heaplist
argument_list|)
decl_stmt|,
name|h2
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator||
literal|7
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|h
operator|&&
name|h
operator|->
name|free
operator|-
name|size
operator|<
literal|0
condition|)
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|h2
operator|=
operator|(
name|Heap
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
expr|*
name|h2
argument_list|)
expr_stmt|;
name|h2
operator|->
name|pool
operator|=
name|h2
operator|->
name|ptr
operator|=
name|zalloc
argument_list|(
name|h2
operator|->
name|free
operator|=
operator|(
name|size
operator|<
name|HEAPSIZE
operator|)
condition|?
name|HEAPSIZE
else|:
operator|(
name|size
operator||
operator|(
name|HEAPSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|h2
operator|->
name|next
operator|=
operator|(
name|Heap
operator|)
name|peekfirst
argument_list|(
name|heaplist
argument_list|)
expr_stmt|;
name|setdata
argument_list|(
name|firstnode
argument_list|(
name|heaplist
argument_list|)
argument_list|,
operator|(
name|vptr
operator|)
name|h2
argument_list|)
expr_stmt|;
name|h
operator|=
name|h2
expr_stmt|;
block|}
name|h
operator|->
name|free
operator|-=
name|size
expr_stmt|;
name|ret
operator|=
name|h
operator|->
name|ptr
expr_stmt|;
name|h
operator|->
name|ptr
operator|+=
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* allocate memory from the current memory pool and clear it */
end_comment

begin_function
name|vptr
name|hcalloc
parameter_list|(
name|size
parameter_list|)
comment|/**/
name|int
name|size
decl_stmt|;
block|{
name|vptr
name|ptr
decl_stmt|;
name|ptr
operator|=
name|halloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|vptr
name|hrealloc
parameter_list|(
name|p
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|)
comment|/**/
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|old
decl_stmt|;
name|int
name|new
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|halloc
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|p
argument_list|,
name|old
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* allocate permanent memory */
end_comment

begin_function
name|vptr
name|zalloc
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|int
name|l
decl_stmt|;
block|{
name|vptr
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
name|l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"fatal error: out of memory"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_function
name|vptr
name|zcalloc
parameter_list|(
name|size
parameter_list|)
comment|/**/
name|int
name|size
decl_stmt|;
block|{
name|vptr
name|ptr
decl_stmt|;
name|ptr
operator|=
name|zalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__386BSD__
end_ifndef

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
name|t
operator|=
name|ncalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|ztrdup
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
name|t
operator|=
name|zalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

end_unit

