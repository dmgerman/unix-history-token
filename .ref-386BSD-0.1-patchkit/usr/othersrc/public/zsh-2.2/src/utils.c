begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * utils.c - miscellaneous utilities  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV
end_ifndef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_undef
undef|#
directive|undef
name|TIOCGWINSZ
end_undef

begin_function
name|int
name|readlink
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|z
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|z
decl_stmt|;
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* source a file */
end_comment

begin_function
name|int
name|source
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|cj
init|=
name|thisjob
decl_stmt|;
name|int
name|oldlineno
init|=
name|lineno
decl_stmt|,
name|oldshst
decl_stmt|;
name|FILE
modifier|*
name|obshin
init|=
name|bshin
decl_stmt|;
name|fd
operator|=
name|SHIN
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|oldshst
operator|=
name|opts
index|[
name|SHINSTDIN
index|]
expr_stmt|;
name|opts
index|[
name|SHINSTDIN
index|]
operator|=
name|OPT_UNSET
expr_stmt|;
if|if
condition|(
operator|(
name|SHIN
operator|=
name|movefd
argument_list|(
name|open
argument_list|(
name|s
argument_list|,
name|O_RDONLY
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SHIN
operator|=
name|fd
expr_stmt|;
name|thisjob
operator|=
name|cj
expr_stmt|;
name|opts
index|[
name|SHINSTDIN
index|]
operator|=
name|oldshst
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bshin
operator|=
name|fdopen
argument_list|(
name|SHIN
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|loop
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|bshin
argument_list|)
expr_stmt|;
name|bshin
operator|=
name|obshin
expr_stmt|;
name|opts
index|[
name|SHINSTDIN
index|]
operator|=
name|oldshst
expr_stmt|;
name|SHIN
operator|=
name|fd
expr_stmt|;
name|thisjob
operator|=
name|cj
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
name|retflag
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
name|oldlineno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* try to source a file in the home directory */
end_comment

begin_function
name|void
name|sourcehome
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|h
operator|=
name|getsparam
argument_list|(
literal|"ZDOTDIR"
argument_list|)
operator|)
condition|)
name|h
operator|=
name|home
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|h
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|source
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print an error */
end_comment

begin_function
name|void
name|zerrnam
parameter_list|(
name|cmd
parameter_list|,
name|fmt
parameter_list|,
name|str
parameter_list|,
name|num
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|cmd
condition|)
block|{
if|if
condition|(
name|errflag
operator|||
name|noerrs
condition|)
return|return;
name|errflag
operator|=
literal|1
expr_stmt|;
name|trashzle
argument_list|()
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: "
argument_list|,
name|argzero
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|fmt
condition|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
while|while
condition|(
operator|*
name|str
condition|)
name|niceputc
argument_list|(
operator|*
name|str
operator|++
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
while|while
condition|(
name|num
operator|--
condition|)
name|niceputc
argument_list|(
operator|*
name|str
operator|++
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|putc
argument_list|(
literal|'%'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|niceputc
argument_list|(
name|num
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|num
operator|==
name|EINTR
condition|)
block|{
name|fputs
argument_list|(
literal|"interrupt\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num
operator|==
name|EIO
condition|)
name|fputs
argument_list|(
name|sys_errlist
index|[
name|num
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
block|{
name|fputc
argument_list|(
name|tulower
argument_list|(
name|sys_errlist
index|[
name|num
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|sys_errlist
index|[
name|num
index|]
operator|+
literal|1
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
name|putc
argument_list|(
operator|*
name|fmt
operator|++
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|&&
name|lineno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [%ld]\n"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zerr
parameter_list|(
name|fmt
parameter_list|,
name|str
parameter_list|,
name|num
parameter_list|)
comment|/**/
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|errflag
operator|||
name|noerrs
condition|)
return|return;
name|errflag
operator|=
literal|1
expr_stmt|;
name|trashzle
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
operator|(
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|)
condition|?
literal|"zsh"
else|:
name|argzero
argument_list|)
expr_stmt|;
name|zerrnam
argument_list|(
name|NULL
argument_list|,
name|fmt
argument_list|,
name|str
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|niceputc
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
comment|/**/
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|itok
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|Pound
operator|&&
name|c
operator|<=
name|Comma
condition|)
name|putc
argument_list|(
name|ztokens
index|[
name|c
operator|-
name|Pound
index|]
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
operator||
literal|'@'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* enable ^C interrupts */
end_comment

begin_function
name|void
name|intr
parameter_list|()
comment|/**/
block|{
ifdef|#
directive|ifdef
name|SV_INTERRUPT
specifier|static
name|struct
name|sigvec
name|vec
init|=
block|{
name|handler
block|,
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
block|,
name|SV_INTERRUPT
block|}
decl_stmt|;
if|if
condition|(
name|interact
condition|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|vec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|interact
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|noholdintr
parameter_list|()
comment|/**/
block|{
name|intr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|holdintr
parameter_list|()
comment|/**/
block|{
ifdef|#
directive|ifdef
name|SV_INTERRUPT
specifier|static
name|struct
name|sigvec
name|vec
init|=
block|{
name|handler
block|,
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|interact
condition|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|vec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|interact
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__386BSD__
end_ifndef

begin_function
name|char
modifier|*
name|fgetline
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|in
parameter_list|)
comment|/**/
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|in
argument_list|)
condition|)
return|return
name|NULL
return|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* get a symlink-free pathname for s relative to PWD */
end_comment

begin_function
name|char
modifier|*
name|findpwd
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
return|return
name|xsymlink
argument_list|(
name|s
argument_list|)
return|;
name|s
operator|=
name|tricat
argument_list|(
operator|(
name|pwd
index|[
literal|1
index|]
operator|)
condition|?
name|pwd
else|:
literal|""
argument_list|,
literal|"/"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|xsymlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|xbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|char *fixpwd(s)
comment|/**/
end_comment

begin_endif
unit|char *s; { struct stat sbuf,tbuf; char *t;  	strcpy(xbuf,""); 	if (*s == '/') 		t = ztrdup(s); 	else 		t = tricat((pwd[1]) ? pwd : "","/",s); 	(void) xsymlinks(t+1,0);  	free(t); 	if (!*xbuf) 		strcpy(xbuf,"/"); 	if (stat(xbuf,&sbuf) == 0&& stat(".",&tbuf) == 0) 		if (!(sbuf.st_dev == tbuf.st_dev&& sbuf.st_ino == tbuf.st_ino)) 			chdir(xbuf); 	return ztrdup(xbuf); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|ispwd
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|,
name|tbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|tbuf
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|sbuf
operator|.
name|st_dev
operator|==
name|tbuf
operator|.
name|st_dev
operator|&&
name|sbuf
operator|.
name|st_ino
operator|==
name|tbuf
operator|.
name|st_ino
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* expand symlinks in s, and remove other weird things */
end_comment

begin_function
name|char
modifier|*
name|xsymlink
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|unset
argument_list|(
name|CHASELINKS
argument_list|)
condition|)
return|return
name|ztrdup
argument_list|(
name|s
argument_list|)
return|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
condition|)
return|return
name|NULL
return|;
name|strcpy
argument_list|(
name|xbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsymlinks
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|ztrdup
argument_list|(
name|s
argument_list|)
return|;
if|if
condition|(
operator|!
operator|*
name|xbuf
condition|)
return|return
name|ztrdup
argument_list|(
literal|"/"
argument_list|)
return|;
return|return
name|ztrdup
argument_list|(
name|xbuf
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|slashsplit
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|r
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|;
name|int
name|t0
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
return|;
for|for
control|(
name|t
operator|=
name|s
operator|,
name|t0
operator|=
literal|0
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
name|t0
operator|++
expr_stmt|;
name|q
operator|=
name|r
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
operator|(
name|t0
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|ztrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t
condition|)
block|{
operator|*
name|q
operator|=
name|NULL
expr_stmt|;
return|return
name|r
return|;
block|}
name|s
operator|=
name|t
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
name|ztrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|NULL
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|islink
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|readlink
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* expands symlinks and .. or . expressions */
end_comment

begin_comment
comment|/* if flag = 0, only expand .. and . expressions */
end_comment

begin_function
name|int
name|xsymlinks
parameter_list|(
name|s
parameter_list|,
name|flag
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
modifier|*
name|opp
decl_stmt|;
name|char
name|xbuf2
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|xbuf3
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|t0
decl_stmt|;
name|opp
operator|=
name|pp
operator|=
name|slashsplit
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|pp
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|pp
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|xbuf
argument_list|,
literal|"/"
argument_list|)
condition|)
continue|continue;
name|p
operator|=
name|xbuf
operator|+
name|strlen
argument_list|(
name|xbuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|p
operator|!=
literal|'/'
condition|)
empty_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unset
argument_list|(
name|CHASELINKS
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|xbuf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|xbuf
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sprintf
argument_list|(
name|xbuf2
argument_list|,
literal|"%s/%s"
argument_list|,
name|xbuf
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|t0
operator|=
name|readlink
argument_list|(
name|xbuf2
argument_list|,
name|xbuf3
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|t0
operator|==
operator|-
literal|1
operator|||
operator|!
name|flag
condition|)
block|{
name|strcat
argument_list|(
name|xbuf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|xbuf
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xbuf3
index|[
name|t0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* STUPID */
if|if
condition|(
operator|*
name|xbuf3
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|xbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsymlinks
argument_list|(
name|xbuf3
operator|+
literal|1
argument_list|,
name|flag
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|xsymlinks
argument_list|(
name|xbuf3
argument_list|,
name|flag
argument_list|)
condition|)
return|return
literal|1
return|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|opp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* print a directory */
end_comment

begin_function
name|void
name|fprintdir
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
name|t0
operator|=
name|finddir
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t0
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|home
argument_list|,
name|t0
operator|=
name|strlen
argument_list|(
name|home
argument_list|)
argument_list|)
operator|&&
name|t0
operator|>
literal|1
condition|)
block|{
name|putc
argument_list|(
literal|'~'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|s
operator|+
name|t0
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'~'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|usernames
index|[
name|t0
index|]
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|s
operator|+
name|strlen
argument_list|(
name|userdirs
index|[
name|t0
index|]
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|printdir
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintdir
argument_list|(
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printdircr
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintdir
argument_list|(
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* see if a path has a named directory as its prefix */
end_comment

begin_function
name|int
name|finddir
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|step
decl_stmt|;
if|if
condition|(
name|userdirsz
condition|)
block|{
name|step
operator|=
name|t0
operator|=
name|userdirsz
operator|/
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t1
operator|=
operator|(
name|userdirs
index|[
name|t0
index|]
operator|)
condition|?
name|dircmp
argument_list|(
name|userdirs
index|[
name|t0
index|]
argument_list|,
name|s
argument_list|)
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|t1
condition|)
block|{
while|while
condition|(
name|t0
operator|!=
name|userdirsz
operator|-
literal|1
operator|&&
name|userdirs
index|[
name|t0
operator|+
literal|1
index|]
operator|&&
operator|!
name|dircmp
argument_list|(
name|userdirs
index|[
name|t0
operator|+
literal|1
index|]
argument_list|,
name|s
argument_list|)
condition|)
name|t0
operator|++
expr_stmt|;
return|return
name|t0
return|;
block|}
if|if
condition|(
operator|!
name|step
condition|)
break|break;
if|if
condition|(
name|t1
operator|>
literal|0
condition|)
name|t0
operator|=
name|t0
operator|-
name|step
operator|+
name|step
operator|/
literal|2
expr_stmt|;
else|else
name|t0
operator|+=
name|step
operator|/
literal|2
expr_stmt|;
name|step
operator|/=
literal|2
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* add a named directory */
end_comment

begin_function
name|void
name|adduserdir
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|,
name|t1
decl_stmt|;
if|if
condition|(
operator|!
name|interact
operator|||
operator|(
operator|(
name|t0
operator|=
name|finddir
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|usernames
index|[
name|t0
index|]
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
argument_list|,
literal|"/"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|t0
operator|=
name|finddir
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|usernames
index|[
name|t0
index|]
argument_list|)
condition|)
return|return;
if|if
condition|(
name|userdirsz
operator|==
name|userdirct
condition|)
block|{
name|userdirsz
operator|*=
literal|2
expr_stmt|;
name|userdirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|userdirs
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
name|userdirsz
argument_list|)
expr_stmt|;
name|usernames
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|usernames
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
name|userdirsz
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|userdirct
init|;
name|t0
operator|!=
name|userdirsz
condition|;
name|t0
operator|++
control|)
name|userdirs
index|[
name|t0
index|]
operator|=
name|usernames
index|[
name|t0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|userdirct
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|userdirs
index|[
name|t0
index|]
argument_list|,
name|t
argument_list|)
operator|>
literal|0
condition|)
break|break;
for|for
control|(
name|t1
operator|=
name|userdirct
operator|-
literal|1
init|;
name|t1
operator|>=
name|t0
condition|;
name|t1
operator|--
control|)
block|{
name|userdirs
index|[
name|t1
operator|+
literal|1
index|]
operator|=
name|userdirs
index|[
name|t1
index|]
expr_stmt|;
name|usernames
index|[
name|t1
operator|+
literal|1
index|]
operator|=
name|usernames
index|[
name|t1
index|]
expr_stmt|;
block|}
name|userdirs
index|[
name|t0
index|]
operator|=
name|ztrdup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|usernames
index|[
name|t0
index|]
operator|=
name|ztrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|userdirct
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dircmp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|*
name|t
condition|;
name|s
operator|++
operator|,
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|t
condition|)
return|return
operator|*
name|s
operator|-
operator|*
name|t
return|;
if|if
condition|(
operator|!
operator|*
name|s
operator|&&
operator|(
operator|!
operator|*
name|t
operator|||
operator|*
name|t
operator|==
literal|'/'
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|*
name|s
operator|-
operator|*
name|t
return|;
block|}
end_function

begin_function
name|int
name|ddifftime
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
comment|/**/
name|time_t
name|t1
decl_stmt|;
name|time_t
name|t2
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|t2
operator|-
operator|(
name|long
operator|)
name|t1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* see if jobs need printing */
end_comment

begin_function
name|void
name|scanjobs
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|1
init|;
name|t0
operator|!=
name|MAXJOB
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_CHANGED
condition|)
name|printjob
argument_list|(
name|jobtab
operator|+
name|t0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do pre-prompt stuff */
end_comment

begin_function
name|void
name|preprompt
parameter_list|()
comment|/**/
block|{
name|int
name|diff
decl_stmt|;
name|List
name|list
decl_stmt|;
name|struct
name|schedcmd
modifier|*
name|sch
decl_stmt|,
modifier|*
name|schl
decl_stmt|;
if|if
condition|(
name|unset
argument_list|(
name|NOTIFY
argument_list|)
condition|)
name|scanjobs
argument_list|()
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|list
operator|=
name|getshfunc
argument_list|(
literal|"precmd"
argument_list|)
condition|)
name|doshfuncnoval
argument_list|(
name|list
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|period
operator|&&
operator|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|>
name|lastperiod
operator|+
name|period
operator|)
operator|&&
operator|(
name|list
operator|=
name|getshfunc
argument_list|(
literal|"periodic"
argument_list|)
operator|)
condition|)
block|{
name|doshfuncnoval
argument_list|(
name|list
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lastperiod
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|watch
condition|)
block|{
name|diff
operator|=
operator|(
name|int
operator|)
name|ddifftime
argument_list|(
name|lastwatch
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|logcheck
condition|)
block|{
name|dowatch
argument_list|()
expr_stmt|;
name|lastwatch
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errflag
condition|)
return|return;
name|diff
operator|=
operator|(
name|int
operator|)
name|ddifftime
argument_list|(
name|lastmailcheck
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|mailcheck
condition|)
block|{
if|if
condition|(
name|mailpath
operator|&&
operator|*
name|mailpath
condition|)
name|checkmailpath
argument_list|(
name|mailpath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mailfile
condition|)
block|{
name|char
modifier|*
name|x
index|[
literal|2
index|]
decl_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|mailfile
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|checkmailpath
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|lastmailcheck
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|schl
operator|=
operator|(
expr|struct
name|schedcmd
operator|*
operator|)
operator|&
name|schedcmds
operator|,
name|sch
operator|=
name|schedcmds
init|;
name|sch
condition|;
name|sch
operator|=
operator|(
name|schl
operator|=
name|sch
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sch
operator|->
name|time
operator|<
name|time
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|execstring
argument_list|(
name|sch
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|schl
operator|->
name|next
operator|=
name|sch
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sch
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errflag
condition|)
return|return;
block|}
block|}
end_function

begin_function
name|int
name|arrlen
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|++
operator|,
name|t0
operator|++
control|)
empty_stmt|;
return|return
name|t0
return|;
block|}
end_function

begin_function
name|void
name|checkmailpath
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|,
modifier|*
name|u
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
for|for
control|(
name|v
operator|=
operator|*
name|s
init|;
operator|*
name|v
operator|&&
operator|*
name|v
operator|!=
literal|'?'
condition|;
name|v
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|v
expr_stmt|;
operator|*
name|v
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'?'
condition|)
name|u
operator|=
name|NULL
expr_stmt|;
else|else
name|u
operator|=
name|v
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|*
name|s
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
operator|*
name|s
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|Lklist
name|l
decl_stmt|;
name|DIR
modifier|*
name|lock
init|=
name|opendir
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
operator|*
literal|2
index|]
decl_stmt|,
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|int
name|ct
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|lock
condition|)
block|{
name|pushheap
argument_list|()
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
name|l
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|readdir
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|errflag
condition|)
break|break;
if|if
condition|(
name|u
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s?%s"
argument_list|,
operator|*
name|s
argument_list|,
name|de
operator|->
name|d_name
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|*
name|s
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|l
argument_list|,
name|strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ct
operator|++
expr_stmt|;
block|}
name|closedir
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|ap
operator|=
name|arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloc
argument_list|(
name|ct
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ap
operator|++
operator|=
name|ugetnode
argument_list|(
name|l
argument_list|)
condition|)
empty_stmt|;
name|checkmailpath
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|st
operator|.
name|st_size
operator|&&
name|st
operator|.
name|st_atime
operator|<=
name|st
operator|.
name|st_mtime
operator|&&
name|st
operator|.
name|st_mtime
operator|>
name|lastmailcheck
condition|)
if|if
condition|(
operator|!
name|u
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You have new mail.\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|z
init|=
name|u
decl_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
if|if
condition|(
operator|*
name|z
operator|==
literal|'$'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|z
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
operator|*
name|z
operator|++
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|MAILWARNING
argument_list|)
operator|&&
name|st
operator|.
name|st_atime
operator|>
name|st
operator|.
name|st_mtime
operator|&&
name|st
operator|.
name|st_atime
operator|>
name|lastmailcheck
operator|&&
name|st
operator|.
name|st_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The mail in %s has been read.\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|v
operator|=
name|c
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|saveoldfuncs
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
comment|/**/
name|char
modifier|*
name|x
decl_stmt|;
name|Cmdnam
name|y
decl_stmt|;
block|{
name|Cmdnam
name|cc
decl_stmt|;
if|if
condition|(
name|y
operator|->
name|type
operator|==
name|SHFUNC
operator|||
name|y
operator|->
name|type
operator|==
name|DISABLED
condition|)
block|{
name|cc
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|cc
argument_list|)
expr_stmt|;
operator|*
name|cc
operator|=
operator|*
name|y
expr_stmt|;
name|y
operator|->
name|u
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|x
argument_list|)
argument_list|,
name|cc
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* create command hashtable */
end_comment

begin_function
name|void
name|newcmdnamtab
parameter_list|()
comment|/**/
block|{
name|Hashtab
name|oldcnt
decl_stmt|;
name|oldcnt
operator|=
name|cmdnamtab
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|cmdnamtab
operator|=
name|newhtable
argument_list|(
literal|101
argument_list|)
expr_stmt|;
name|addbuiltins
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldcnt
condition|)
block|{
name|listhtable
argument_list|(
name|oldcnt
argument_list|,
operator|(
name|HFunc
operator|)
name|saveoldfuncs
argument_list|)
expr_stmt|;
name|freehtab
argument_list|(
name|oldcnt
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
block|}
name|lastalloc
argument_list|()
expr_stmt|;
name|pathchecked
operator|=
name|path
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freecmdnam
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|struct
name|cmdnam
modifier|*
name|c
init|=
operator|(
expr|struct
name|cmdnam
operator|*
operator|)
name|a
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SHFUNC
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|u
operator|.
name|list
condition|)
name|freestruct
argument_list|(
name|c
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|BUILTIN
operator|&&
name|c
operator|->
name|type
operator|!=
name|DISABLED
condition|)
name|free
argument_list|(
name|c
operator|->
name|u
operator|.
name|nam
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freecompctl
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|Compctl
name|cc
init|=
operator|(
name|Compctl
operator|)
name|a
decl_stmt|;
name|free
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freestr
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freeanode
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|struct
name|alias
modifier|*
name|c
init|=
operator|(
expr|struct
name|alias
operator|*
operator|)
name|a
decl_stmt|;
name|free
argument_list|(
name|c
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freepm
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|struct
name|param
modifier|*
name|pm
init|=
operator|(
name|Param
operator|)
name|a
decl_stmt|;
name|free
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restoretty
parameter_list|()
comment|/**/
block|{
name|settyinfo
argument_list|(
operator|&
name|shttyinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gettyinfo
parameter_list|(
name|ti
parameter_list|)
comment|/**/
name|struct
name|ttyinfo
modifier|*
name|ti
decl_stmt|;
block|{
if|if
condition|(
name|SHTTY
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMIOS
ifdef|#
directive|ifdef
name|HAS_TCCRAP
if|if
condition|(
name|tcgetattr
argument_list|(
name|SHTTY
argument_list|,
operator|&
name|ti
operator|->
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TCGETS
argument_list|,
operator|&
name|ti
operator|->
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
name|zerr
argument_list|(
literal|"bad tcgets: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TERMIO
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ti
operator|->
name|tio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ti
operator|->
name|sgttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|ti
operator|->
name|lmodes
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|ti
operator|->
name|tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ti
operator|->
name|ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ti
operator|->
name|winsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/*	zerr("bad tiocgwinsz: %e",NULL,errno)*/
empty_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|settyinfo
parameter_list|(
name|ti
parameter_list|)
comment|/**/
name|struct
name|ttyinfo
modifier|*
name|ti
decl_stmt|;
block|{
if|if
condition|(
name|SHTTY
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMIOS
ifdef|#
directive|ifdef
name|HAS_TCCRAP
ifndef|#
directive|ifndef
name|TCSADRAIN
define|#
directive|define
name|TCSADRAIN
value|1
comment|/* XXX Princeton's include files are screwed up */
endif|#
directive|endif
if|if
condition|(
name|tcsetattr
argument_list|(
name|SHTTY
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|ti
operator|->
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TCSETS
argument_list|,
operator|&
name|ti
operator|->
name|tio
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/*	zerr("settyinfo: %e",NULL,errno)*/
empty_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TERMIO
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ti
operator|->
name|tio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|ti
operator|->
name|sgttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|ti
operator|->
name|lmodes
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|ti
operator|->
name|tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ti
operator|->
name|ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|ti
operator|->
name|winsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/*	zerr("settyinfo: %e",NULL,errno)*/
empty_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SANEKEY
parameter_list|(
name|X
parameter_list|)
define|\
value|if (ti->X == -1&& savedttyinfo.X != -1) ti->X = savedttyinfo.X;
end_define

begin_function
name|void
name|sanetty
parameter_list|(
name|ti
parameter_list|)
comment|/**/
name|struct
name|ttyinfo
modifier|*
name|ti
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
ifdef|#
directive|ifdef
name|TIO
name|ti
operator|->
name|tio
operator|.
name|c_lflag
operator||=
name|ICANON
operator||
name|ECHO
expr_stmt|;
ifdef|#
directive|ifdef
name|FLUSHO
name|ti
operator|->
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
ifdef|#
directive|ifdef
name|NCCS
name|NCCS
else|#
directive|else
name|NCC
endif|#
directive|endif
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|ti
operator|->
name|tio
operator|.
name|c_cc
index|[
name|t0
index|]
operator|==
name|VDISABLEVAL
operator|&&
name|savedttyinfo
operator|.
name|tio
operator|.
name|c_cc
index|[
name|t0
index|]
operator|!=
name|VDISABLEVAL
condition|)
name|ti
operator|->
name|tio
operator|.
name|c_cc
index|[
name|t0
index|]
operator|=
name|savedttyinfo
operator|.
name|tio
operator|.
name|c_cc
index|[
name|t0
index|]
expr_stmt|;
else|#
directive|else
name|ti
operator|->
name|sgttyb
operator|.
name|sg_flags
operator|=
operator|(
name|ti
operator|->
name|sgttyb
operator|.
name|sg_flags
operator|&
operator|~
name|CBREAK
operator|)
operator||
name|ECHO
expr_stmt|;
name|ti
operator|->
name|lmodes
operator|&=
operator|~
name|LFLUSHO
expr_stmt|;
name|SANEKEY
argument_list|(
name|tchars
operator|.
name|t_quitc
argument_list|)
expr_stmt|;
name|SANEKEY
argument_list|(
name|tchars
operator|.
name|t_startc
argument_list|)
expr_stmt|;
name|SANEKEY
argument_list|(
name|tchars
operator|.
name|t_stopc
argument_list|)
expr_stmt|;
name|SANEKEY
argument_list|(
name|ltchars
operator|.
name|t_suspc
argument_list|)
expr_stmt|;
name|SANEKEY
argument_list|(
name|ltchars
operator|.
name|t_dsuspc
argument_list|)
expr_stmt|;
name|SANEKEY
argument_list|(
name|ltchars
operator|.
name|t_lnextc
argument_list|)
expr_stmt|;
name|SANEKEY
argument_list|(
name|ltchars
operator|.
name|t_flushc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|adjustwinsize
parameter_list|()
comment|/**/
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|shttyinfo
operator|.
name|winsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|columns
operator|=
name|shttyinfo
operator|.
name|winsize
operator|.
name|ws_col
operator|)
condition|)
name|columns
operator|=
literal|80
expr_stmt|;
name|lines
operator|=
name|shttyinfo
operator|.
name|winsize
operator|.
name|ws_row
expr_stmt|;
name|setintenv
argument_list|(
literal|"COLUMNS"
argument_list|,
name|columns
argument_list|)
expr_stmt|;
name|setintenv
argument_list|(
literal|"LINES"
argument_list|,
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|zleactive
condition|)
name|refresh
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|zyztem
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|WAITPID
name|int
name|pid
decl_stmt|,
name|statusp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|s
operator|=
name|tricat
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|statusp
argument_list|,
name|WUNTRACED
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|statusp
argument_list|)
condition|)
return|return
name|WEXITSTATUS
argument_list|(
name|statusp
argument_list|)
return|;
return|return
literal|1
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|waitfork
argument_list|()
condition|)
block|{
name|s
operator|=
name|tricat
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|WAITPID
end_ifndef

begin_comment
comment|/* fork a process and wait for it to complete without confusing 	the SIGCHLD handler */
end_comment

begin_function
name|int
name|waitfork
parameter_list|()
comment|/**/
block|{
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
name|char
name|x
decl_stmt|;
name|pipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
return|return
literal|0
return|;
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
operator|&
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* move a fd to a place>= 10 */
end_comment

begin_function
name|int
name|movefd
parameter_list|(
name|fd
parameter_list|)
comment|/**/
name|int
name|fd
decl_stmt|;
block|{
name|int
name|fe
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|fd
return|;
ifdef|#
directive|ifdef
name|F_DUPFD
name|fe
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|fe
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|10
condition|)
name|fe
operator|=
name|movefd
argument_list|(
name|fe
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|fe
return|;
block|}
end_function

begin_comment
comment|/* move fd x to y */
end_comment

begin_function
name|void
name|redup
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
comment|/**/
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|!=
name|y
condition|)
block|{
name|dup2
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|settrap
parameter_list|(
name|t0
parameter_list|,
name|l
parameter_list|)
comment|/**/
name|int
name|t0
decl_stmt|;
name|List
name|l
decl_stmt|;
block|{
name|Cmd
name|c
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|c
operator|=
name|l
operator|->
name|left
operator|->
name|left
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SIMPLE
operator|&&
operator|!
name|full
argument_list|(
name|c
operator|->
name|args
argument_list|)
operator|&&
operator|!
name|full
argument_list|(
name|c
operator|->
name|redir
argument_list|)
operator|&&
operator|!
name|full
argument_list|(
name|c
operator|->
name|vars
argument_list|)
operator|&&
operator|!
name|c
operator|->
name|flags
condition|)
name|l
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|t0
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|jobbing
operator|&&
operator|(
name|t0
operator|==
name|SIGTTOU
operator|||
name|t0
operator|==
name|SIGTSTP
operator|||
name|t0
operator|==
name|SIGTTIN
operator|||
name|t0
operator|==
name|SIGPIPE
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"can't trap SIG%s in interactive shells"
argument_list|,
name|sigs
index|[
name|t0
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|l
condition|)
block|{
name|sigtrapped
index|[
name|t0
index|]
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|t0
operator|&&
name|t0
operator|<
name|SIGCOUNT
operator|&&
name|t0
operator|!=
name|SIGCHLD
condition|)
block|{
name|signal
argument_list|(
name|t0
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigtrapped
index|[
name|t0
index|]
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|t0
operator|&&
name|t0
operator|<
name|SIGCOUNT
operator|&&
name|t0
operator|!=
name|SIGCHLD
condition|)
name|signal
argument_list|(
name|t0
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|sigtrapped
index|[
name|t0
index|]
operator|=
literal|1
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|sigfuncs
index|[
name|t0
index|]
operator|=
operator|(
name|List
operator|)
name|dupstruct
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|unsettrap
parameter_list|(
name|t0
parameter_list|)
comment|/**/
name|int
name|t0
decl_stmt|;
block|{
if|if
condition|(
name|t0
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|jobbing
operator|&&
operator|(
name|t0
operator|==
name|SIGTTOU
operator|||
name|t0
operator|==
name|SIGTSTP
operator|||
name|t0
operator|==
name|SIGTTIN
operator|||
name|t0
operator|==
name|SIGPIPE
operator|)
condition|)
block|{
return|return;
block|}
name|sigtrapped
index|[
name|t0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t0
operator|==
name|SIGINT
condition|)
name|intr
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|t0
operator|&&
name|t0
operator|<
name|SIGCOUNT
operator|&&
name|t0
operator|!=
name|SIGCHLD
condition|)
name|signal
argument_list|(
name|t0
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigfuncs
index|[
name|t0
index|]
condition|)
name|freestruct
argument_list|(
name|sigfuncs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dotrap
parameter_list|(
name|sig
parameter_list|)
comment|/**/
name|int
name|sig
decl_stmt|;
block|{
name|int
name|sav
decl_stmt|,
name|savval
decl_stmt|;
name|sav
operator|=
name|sigtrapped
index|[
name|sig
index|]
expr_stmt|;
name|savval
operator|=
name|lastval
expr_stmt|;
if|if
condition|(
name|sav
operator|==
literal|2
condition|)
return|return;
name|sigtrapped
index|[
name|sig
index|]
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sigfuncs
index|[
name|sig
index|]
condition|)
block|{
name|lexsave
argument_list|()
expr_stmt|;
name|doshfuncnoval
argument_list|(
name|sigfuncs
index|[
name|sig
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lexrestore
argument_list|()
expr_stmt|;
block|}
name|sigtrapped
index|[
name|sig
index|]
operator|=
name|sav
expr_stmt|;
name|lastval
operator|=
name|savval
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy len chars from t into s, and null terminate */
end_comment

begin_function
name|void
name|ztrncpy
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* copy t into *s and update s */
end_comment

begin_function
name|void
name|strucpy
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|u
init|=
operator|*
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|u
operator|++
operator|=
operator|*
name|t
operator|++
condition|)
empty_stmt|;
operator|*
name|s
operator|=
name|u
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|struncpy
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|u
init|=
operator|*
name|s
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|u
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|s
operator|=
name|u
expr_stmt|;
operator|*
name|u
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|checkrmall
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fflush
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zsh: sure you want to delete all the files in %s? "
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zsh: sure you want to delete all the files in %s/%s? "
argument_list|,
operator|(
name|pwd
index|[
literal|1
index|]
operator|)
condition|?
name|pwd
else|:
literal|""
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|feep
argument_list|()
expr_stmt|;
name|errflag
operator||=
operator|(
name|getquery
argument_list|()
operator|!=
literal|'y'
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|getquery
parameter_list|()
comment|/**/
block|{
name|char
name|c
decl_stmt|;
name|long
name|val
decl_stmt|;
name|setcbreak
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FIONREAD
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|unsetcbreak
argument_list|()
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"n\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|'n'
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|read
argument_list|(
name|SHTTY
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
literal|'y'
expr_stmt|;
name|unsetcbreak
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|c
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|guess
decl_stmt|,
modifier|*
name|best
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|spscannodis
parameter_list|(
name|s
parameter_list|,
name|cn
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|cn
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|Cmdnam
operator|)
name|cn
operator|)
operator|->
name|type
operator|!=
name|DISABLED
condition|)
name|spscan
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spscan
parameter_list|(
name|s
parameter_list|,
name|junk
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|junk
decl_stmt|;
block|{
name|int
name|nd
decl_stmt|;
name|nd
operator|=
name|spdist
argument_list|(
name|s
argument_list|,
name|guess
argument_list|,
name|strlen
argument_list|(
name|guess
argument_list|)
operator|/
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|<=
name|d
condition|)
block|{
name|best
operator|=
name|s
expr_stmt|;
name|d
operator|=
name|nd
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* spellcheck a word */
end_comment

begin_comment
comment|/* fix s and s2 ; if s2 is non-null, fix the history list too */
end_comment

begin_function
name|void
name|spckword
parameter_list|(
name|s
parameter_list|,
name|s2
parameter_list|,
name|tptr
parameter_list|,
name|cmd
parameter_list|,
name|ask
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
modifier|*
name|tptr
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|ask
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|char
name|firstchar
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|pram
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|'-'
operator|||
operator|*
operator|*
name|s
operator|==
literal|'%'
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"in"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
index|[
literal|0
index|]
operator|||
operator|!
operator|(
operator|*
name|s
operator|)
index|[
literal|1
index|]
condition|)
return|return;
if|if
condition|(
name|gethnode
argument_list|(
operator|*
name|s
argument_list|,
name|cmdnamtab
argument_list|)
operator|||
name|gethnode
argument_list|(
operator|*
name|s
argument_list|,
name|aliastab
argument_list|)
condition|)
return|return;
name|t
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
name|Tilde
operator|||
operator|*
name|t
operator|==
name|Equals
operator|||
operator|*
name|t
operator|==
name|String
condition|)
name|t
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|itok
argument_list|(
operator|*
name|t
argument_list|)
condition|)
return|return;
name|best
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
operator|*
name|s
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
operator|*
name|s
operator|==
name|String
condition|)
block|{
if|if
condition|(
operator|*
name|t
condition|)
return|return;
name|pram
operator|=
literal|1
expr_stmt|;
name|guess
operator|=
operator|*
name|s
operator|+
literal|1
expr_stmt|;
name|d
operator|=
literal|100
expr_stmt|;
name|listhtable
argument_list|(
name|paramtab
argument_list|,
name|spscan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|spname
argument_list|(
name|guess
operator|=
operator|*
name|s
argument_list|)
operator|)
operator|!=
operator|*
name|s
condition|)
name|best
operator|=
name|u
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t
operator|&&
operator|!
name|cmd
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
operator|*
name|s
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hashcmd
argument_list|(
operator|*
name|s
argument_list|,
name|pathchecked
argument_list|)
condition|)
return|return;
name|guess
operator|=
operator|*
name|s
expr_stmt|;
name|d
operator|=
literal|100
expr_stmt|;
name|listhtable
argument_list|(
name|aliastab
argument_list|,
name|spscan
argument_list|)
expr_stmt|;
name|listhtable
argument_list|(
name|cmdnamtab
argument_list|,
name|spscan
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|best
operator|&&
name|strlen
argument_list|(
name|best
argument_list|)
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|best
argument_list|,
name|guess
argument_list|)
condition|)
block|{
if|if
condition|(
name|ask
condition|)
block|{
name|char
modifier|*
name|pp
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|rstring
operator|=
name|best
expr_stmt|;
name|Rstring
operator|=
name|guess
expr_stmt|;
name|firstchar
operator|=
operator|*
name|guess
expr_stmt|;
if|if
condition|(
operator|*
name|guess
operator|==
name|Tilde
condition|)
operator|*
name|guess
operator|=
literal|'~'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|guess
operator|==
name|String
condition|)
operator|*
name|guess
operator|=
literal|'$'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|guess
operator|==
name|Equals
condition|)
operator|*
name|guess
operator|=
literal|'='
expr_stmt|;
name|pp
operator|=
name|putprompt
argument_list|(
name|sprompt
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
operator|*
name|guess
operator|=
name|firstchar
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|feep
argument_list|()
expr_stmt|;
name|x
operator|=
name|getquery
argument_list|()
expr_stmt|;
block|}
else|else
name|x
operator|=
literal|'y'
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
operator|!
name|pram
condition|)
block|{
operator|*
name|s
operator|=
name|strdup
argument_list|(
name|best
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
name|alloc
argument_list|(
name|strlen
argument_list|(
name|best
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|s
operator|+
literal|1
argument_list|,
name|best
argument_list|)
expr_stmt|;
operator|*
operator|*
name|s
operator|=
name|String
expr_stmt|;
block|}
if|if
condition|(
name|s2
condition|)
block|{
if|if
condition|(
operator|*
name|tptr
operator|&&
operator|!
name|strcmp
argument_list|(
name|hlastw
argument_list|,
operator|*
name|s2
argument_list|)
operator|&&
name|hlastw
operator|<
name|hptr
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|hptr
operator|=
name|hlastw
expr_stmt|;
if|if
condition|(
name|pram
condition|)
name|hwaddc
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
for|for
control|(
name|z
operator|=
name|best
init|;
operator|*
name|z
condition|;
name|z
operator|++
control|)
name|hwaddc
argument_list|(
operator|*
name|z
argument_list|)
expr_stmt|;
name|hwaddc
argument_list|(
name|HISTSPACE
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|=
name|hptr
operator|-
literal|1
expr_stmt|;
operator|*
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|s2
operator|=
name|strdup
argument_list|(
name|best
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'a'
condition|)
block|{
name|histdone
operator||=
name|HISTFLAG_NOEXEC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'e'
condition|)
block|{
name|histdone
operator||=
name|HISTFLAG_NOEXEC
operator||
name|HISTFLAG_RECALL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|ztrftime
parameter_list|(
name|buf
parameter_list|,
name|bufsize
parameter_list|,
name|fmt
parameter_list|,
name|tm
parameter_list|)
comment|/**/
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|astr
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|estr
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|lstr
index|[]
init|=
block|{
literal|"12"
block|,
literal|" 1"
block|,
literal|" 2"
block|,
literal|" 3"
block|,
literal|" 4"
block|,
literal|" 5"
block|,
literal|" 6"
block|,
literal|" 7"
block|,
literal|" 8"
block|,
literal|" 9"
block|,
literal|"10"
block|,
literal|"11"
block|}
decl_stmt|;
name|char
name|tmp
index|[
literal|3
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_STRFTIME
name|char
modifier|*
name|origbuf
init|=
name|buf
decl_stmt|;
endif|#
directive|endif
name|tmp
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
condition|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
name|strucpy
argument_list|(
operator|&
name|buf
argument_list|,
name|astr
index|[
name|tm
operator|->
name|tm_wday
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|strucpy
argument_list|(
operator|&
name|buf
argument_list|,
name|estr
index|[
name|tm
operator|->
name|tm_mon
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_mday
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_mday
operator|%
literal|10
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|tm
operator|->
name|tm_mday
operator|>
literal|9
condition|)
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_mday
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_mday
operator|%
literal|10
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|>
literal|9
condition|)
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_hour
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_hour
operator|%
literal|10
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|strucpy
argument_list|(
operator|&
name|buf
argument_list|,
name|lstr
index|[
name|tm
operator|->
name|tm_hour
operator|%
literal|12
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|tm
operator|->
name|tm_mon
operator|+
literal|1
operator|)
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|tm
operator|->
name|tm_mon
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_min
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_min
operator|%
literal|10
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|tm
operator|->
name|tm_hour
operator|>
literal|11
operator|)
condition|?
literal|'p'
else|:
literal|'a'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'m'
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_sec
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_sec
operator|%
literal|10
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_year
operator|/
literal|10
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'0'
operator|+
name|tm
operator|->
name|tm_year
operator|%
literal|10
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|HAS_STRFTIME
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|fmt
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
name|bufsize
operator|-
name|strlen
argument_list|(
name|origbuf
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|buf
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|fmt
index|[
operator|-
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
else|else
operator|*
name|buf
operator|++
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|join
parameter_list|(
name|arr
parameter_list|,
name|delim
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|arr
decl_stmt|;
name|int
name|delim
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|char
modifier|*
name|lastmem
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|s
operator|=
name|arr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
operator|*
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|lastmem
condition|)
name|free
argument_list|(
name|lastmem
argument_list|)
expr_stmt|;
name|lastmem
operator|=
name|ptr
operator|=
name|ret
operator|=
name|zalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|arr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|strucpy
argument_list|(
operator|&
name|ptr
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|delim
expr_stmt|;
block|}
name|ptr
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|spacejoin
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|join
argument_list|(
name|s
argument_list|,
operator|*
name|ifs
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|colonjoin
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|join
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|colonsplit
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|ct
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|ret
decl_stmt|,
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|lastmem
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|,
name|ct
operator|=
literal|0
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|ct
operator|++
expr_stmt|;
if|if
condition|(
name|lastmem
condition|)
name|freearray
argument_list|(
name|lastmem
argument_list|)
expr_stmt|;
name|lastmem
operator|=
name|ptr
operator|=
name|ret
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
operator|(
name|ct
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
do|do
block|{
for|for
control|(
name|s
operator|=
name|t
init|;
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|':'
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|ptr
operator|=
name|zalloc
argument_list|(
operator|(
name|t
operator|-
name|s
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ztrncpy
argument_list|(
operator|*
name|ptr
operator|++
argument_list|,
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|t
operator|++
condition|)
do|;
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|spacesplit
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|ct
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|ret
decl_stmt|,
modifier|*
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|,
name|ct
operator|=
literal|0
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|isep
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|ct
operator|++
expr_stmt|;
name|ptr
operator|=
name|ret
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
operator|(
name|ct
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
do|do
block|{
for|for
control|(
name|s
operator|=
name|t
init|;
operator|*
name|t
operator|&&
operator|!
name|isep
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|ptr
operator|=
name|zalloc
argument_list|(
operator|(
name|t
operator|-
name|s
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ztrncpy
argument_list|(
operator|*
name|ptr
operator|++
argument_list|,
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|t
operator|++
condition|)
do|;
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|List
name|getshfunc
parameter_list|(
name|nam
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
block|{
name|Cmdnam
name|x
init|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
name|nam
argument_list|,
name|cmdnamtab
argument_list|)
decl_stmt|;
return|return
operator|(
name|x
operator|&&
name|x
operator|->
name|type
operator|==
name|SHFUNC
operator|)
condition|?
name|x
operator|->
name|u
operator|.
name|list
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* allocate a tree element */
end_comment

begin_function
name|vptr
name|allocnode
parameter_list|(
name|type
parameter_list|)
comment|/**/
name|int
name|type
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
name|struct
name|node
modifier|*
name|n
init|=
operator|(
expr|struct
name|node
operator|*
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
decl_stmt|;
specifier|static
name|int
name|typetab
index|[
name|N_COUNT
index|]
index|[
literal|4
index|]
init|=
block|{
name|NT_NODE
block|,
name|NT_NODE
block|,
literal|0
block|,
literal|0
block|,
name|NT_NODE
block|,
name|NT_NODE
block|,
literal|0
block|,
literal|0
block|,
name|NT_NODE
block|,
name|NT_NODE
block|,
literal|0
block|,
literal|0
block|,
name|NT_STR
operator||
name|NT_LIST
block|,
name|NT_NODE
block|,
name|NT_NODE
operator||
name|NT_LIST
block|,
name|NT_NODE
operator||
name|NT_LIST
block|,
name|NT_STR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NT_NODE
block|,
name|NT_NODE
block|,
literal|0
block|,
literal|0
block|,
name|NT_STR
block|,
name|NT_NODE
block|,
literal|0
block|,
literal|0
block|,
name|NT_NODE
block|,
name|NT_STR
block|,
name|NT_NODE
block|,
literal|0
block|,
name|NT_NODE
block|,
name|NT_NODE
block|,
name|NT_NODE
block|,
literal|0
block|,
name|NT_NODE
block|,
name|NT_NODE
block|,
literal|0
block|,
literal|0
block|,
name|NT_STR
block|,
name|NT_STR
block|,
name|NT_STR
operator||
name|NT_LIST
block|,
literal|0
block|}
decl_stmt|;
name|n
operator|->
name|type
operator|=
name|type
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|4
condition|;
name|t0
operator|++
control|)
name|n
operator|->
name|types
index|[
name|t0
index|]
operator|=
name|typetab
index|[
name|type
index|]
index|[
name|t0
index|]
expr_stmt|;
return|return
operator|(
name|vptr
operator|)
name|n
return|;
block|}
end_function

begin_comment
comment|/* duplicate a syntax tree */
end_comment

begin_function
name|vptr
name|dupstruct
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|struct
name|node
modifier|*
name|n
init|=
name|a
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|t0
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|NULL
return|;
name|m
operator|=
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
operator|*
name|n
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|4
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
condition|)
switch|switch
condition|(
name|m
operator|->
name|types
index|[
name|t0
index|]
condition|)
block|{
case|case
name|NT_NODE
case|:
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
operator|=
name|dupstruct
argument_list|(
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NT_STR
case|:
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
operator|=
operator|(
name|useheap
operator|)
condition|?
name|strdup
argument_list|(
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|)
else|:
name|ztrdup
argument_list|(
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NT_LIST
operator||
name|NT_NODE
case|:
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
operator|=
name|duplist
argument_list|(
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|,
name|dupstruct
argument_list|)
expr_stmt|;
break|break;
case|case
name|NT_LIST
operator||
name|NT_STR
case|:
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
operator|=
name|duplist
argument_list|(
name|m
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|,
call|(
name|VFunc
call|)
argument_list|(
operator|(
name|useheap
operator|)
condition|?
name|strdup
else|:
name|ztrdup
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|vptr
operator|)
name|m
return|;
block|}
end_function

begin_comment
comment|/* free a syntax tree */
end_comment

begin_function
name|void
name|freestruct
parameter_list|(
name|a
parameter_list|)
comment|/**/
name|vptr
name|a
decl_stmt|;
block|{
name|struct
name|node
modifier|*
name|n
init|=
operator|(
expr|struct
name|node
operator|*
operator|)
name|a
decl_stmt|;
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|4
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|ptrs
index|[
name|t0
index|]
condition|)
switch|switch
condition|(
name|n
operator|->
name|types
index|[
name|t0
index|]
condition|)
block|{
case|case
name|NT_NODE
case|:
name|freestruct
argument_list|(
name|n
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NT_STR
case|:
name|free
argument_list|(
name|n
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NT_LIST
operator||
name|NT_STR
case|:
name|freetable
argument_list|(
name|n
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|,
name|freestr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NT_LIST
operator||
name|NT_NODE
case|:
name|freetable
argument_list|(
name|n
operator|->
name|ptrs
index|[
name|t0
index|]
argument_list|,
name|freestruct
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Lklist
name|duplist
parameter_list|(
name|l
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
name|VFunc
name|func
decl_stmt|;
block|{
name|Lklist
name|ret
decl_stmt|;
name|Lknode
name|node
decl_stmt|;
name|ret
operator|=
name|newlist
argument_list|()
expr_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|l
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
control|)
name|addnode
argument_list|(
name|ret
argument_list|,
name|func
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|mkarray
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|t
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
operator|(
name|s
operator|)
condition|?
operator|(
literal|2
operator|*
sizeof|sizeof
name|s
operator|)
else|:
operator|(
sizeof|sizeof
name|s
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|t
operator|=
name|s
condition|)
name|t
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|feep
parameter_list|()
comment|/**/
block|{
if|if
condition|(
name|unset
argument_list|(
name|NOBEEP
argument_list|)
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"\07"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freearray
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|t
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|free
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|equalsplit
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|t
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'='
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|t
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* see if the right side of a list is trivial */
end_comment

begin_function
name|void
name|simplifyright
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|List
name|l
decl_stmt|;
block|{
name|Cmd
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|->
name|right
condition|)
return|return;
if|if
condition|(
name|l
operator|->
name|right
operator|->
name|right
operator|||
name|l
operator|->
name|right
operator|->
name|left
operator|->
name|right
operator|||
name|l
operator|->
name|right
operator|->
name|left
operator|->
name|left
operator|->
name|right
condition|)
return|return;
name|c
operator|=
name|l
operator|->
name|left
operator|->
name|left
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SIMPLE
operator|||
name|full
argument_list|(
name|c
operator|->
name|args
argument_list|)
operator|||
name|full
argument_list|(
name|c
operator|->
name|redir
argument_list|)
operator|||
name|full
argument_list|(
name|c
operator|->
name|vars
argument_list|)
condition|)
return|return;
name|l
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* initialize the ztypes table */
end_comment

begin_function
name|void
name|inittyptab
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|typtab
index|[
name|t0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|32
condition|;
name|t0
operator|++
control|)
name|typtab
index|[
name|t0
index|]
operator|=
name|typtab
index|[
name|t0
operator|+
literal|128
index|]
operator|=
name|ICNTRL
expr_stmt|;
name|typtab
index|[
literal|127
index|]
operator|=
name|ICNTRL
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|'0'
init|;
name|t0
operator|<=
literal|'9'
condition|;
name|t0
operator|++
control|)
name|typtab
index|[
name|t0
index|]
operator|=
name|IDIGIT
operator||
name|IALNUM
operator||
name|IWORD
operator||
name|IIDENT
operator||
name|IUSER
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|'a'
init|;
name|t0
operator|<=
literal|'z'
condition|;
name|t0
operator|++
control|)
name|typtab
index|[
name|t0
index|]
operator|=
name|typtab
index|[
name|t0
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
name|IALPHA
operator||
name|IALNUM
operator||
name|IIDENT
operator||
name|IUSER
operator||
name|IWORD
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0240
init|;
name|t0
operator|!=
literal|0400
condition|;
name|t0
operator|++
control|)
name|typtab
index|[
name|t0
index|]
operator|=
name|IALPHA
operator||
name|IALNUM
operator||
name|IIDENT
operator||
name|IUSER
operator||
name|IWORD
expr_stmt|;
name|typtab
index|[
literal|'_'
index|]
operator|=
name|IIDENT
operator||
name|IUSER
expr_stmt|;
name|typtab
index|[
literal|'-'
index|]
operator|=
name|IUSER
expr_stmt|;
name|typtab
index|[
literal|' '
index|]
operator||=
name|IBLANK
operator||
name|INBLANK
expr_stmt|;
name|typtab
index|[
literal|'\t'
index|]
operator||=
name|IBLANK
operator||
name|INBLANK
expr_stmt|;
name|typtab
index|[
literal|'\n'
index|]
operator||=
name|INBLANK
expr_stmt|;
for|for
control|(
name|t0
operator|=
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|ALPOP
init|;
name|t0
operator|<=
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Nularg
condition|;
name|t0
operator|++
control|)
name|typtab
index|[
name|t0
index|]
operator||=
name|ITOK
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ifs
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|typtab
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator||=
name|ISEP
expr_stmt|;
for|for
control|(
name|s
operator|=
name|wordchars
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|typtab
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator||=
name|IWORD
expr_stmt|;
for|for
control|(
name|s
operator|=
name|SPECCHARS
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|typtab
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator||=
name|ISPECIAL
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|arrdup
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|x
decl_stmt|,
modifier|*
modifier|*
name|y
decl_stmt|;
name|y
operator|=
name|x
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ncalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|arrlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|x
operator|++
operator|=
name|strdup
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
empty_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* next few functions stolen (with changes) from Kernighan& Pike */
end_comment

begin_comment
comment|/* "The UNIX Programming Environment" (w/o permission) */
end_comment

begin_function
name|char
modifier|*
name|spname
parameter_list|(
name|oldname
parameter_list|)
comment|/**/
name|char
modifier|*
name|oldname
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|guess
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
name|best
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|newname
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|new
init|=
name|newname
decl_stmt|,
modifier|*
name|old
decl_stmt|;
if|if
condition|(
name|itok
argument_list|(
operator|*
name|oldname
argument_list|)
condition|)
block|{
name|singsub
argument_list|(
operator|&
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldname
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|access
argument_list|(
name|oldname
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|old
operator|=
name|oldname
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|old
operator|==
literal|'/'
condition|)
operator|*
name|new
operator|++
operator|=
operator|*
name|old
operator|++
expr_stmt|;
operator|*
name|new
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|old
operator|==
literal|'\0'
condition|)
return|return
name|newname
return|;
name|p
operator|=
name|guess
expr_stmt|;
for|for
control|(
init|;
operator|*
name|old
operator|!=
literal|'/'
operator|&&
operator|*
name|old
operator|!=
literal|'\0'
condition|;
name|old
operator|++
control|)
if|if
condition|(
name|p
operator|<
name|guess
operator|+
name|MAXPATHLEN
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|old
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|mindist
argument_list|(
name|newname
argument_list|,
name|guess
argument_list|,
name|best
argument_list|)
operator|>=
literal|3
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|p
operator|=
name|best
init|;
operator|*
name|new
operator|=
operator|*
name|p
operator|++
condition|;
control|)
name|new
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mindist
parameter_list|(
name|dir
parameter_list|,
name|guess
parameter_list|,
name|best
parameter_list|)
comment|/**/
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|guess
decl_stmt|;
name|char
modifier|*
name|best
decl_stmt|;
block|{
name|int
name|d
decl_stmt|,
name|nd
decl_stmt|;
name|DIR
modifier|*
name|dd
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dir
operator|=
literal|"."
expr_stmt|;
name|d
operator|=
literal|100
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|guess
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|best
argument_list|,
name|guess
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|dd
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
return|return
name|d
return|;
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|dd
argument_list|)
condition|)
block|{
name|nd
operator|=
name|spdist
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
name|guess
argument_list|,
name|strlen
argument_list|(
name|guess
argument_list|)
operator|/
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|<=
name|d
condition|)
block|{
name|strcpy
argument_list|(
name|best
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|d
operator|=
name|nd
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|closedir
argument_list|(
name|dd
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|int
name|spdist
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|thresh
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|thresh
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|keymap
init|=
literal|"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ \t1234567890-=\t\ \tqwertyuiop[]\t\ \tasdfghjkl;'\n\t\ \tzxcvbnm,./\t\t\t\ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\ \t!@#$%^&*()_+\t\ \tQWERTYUIOP{}\t\ \tASDFGHJKL:\"\n\t\ \tZXCVBNM<>?\n\n\t\ \n\n\n\n\n\n\n\n\n\n\n\n\n\n"
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* any number of upper/lower mistakes allowed (dist = 1) */
for|for
control|(
name|p
operator|=
name|s
operator|,
name|q
operator|=
name|t
init|;
operator|*
name|p
operator|&&
name|tulower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|tulower
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|!
operator|*
name|q
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|thresh
condition|)
return|return
literal|200
return|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|q
operator|=
name|t
init|;
operator|*
name|p
operator|&&
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
operator|*
name|q
condition|)
continue|continue;
comment|/* don't consider "aa" transposed, ash */
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|q
index|[
literal|0
index|]
operator|&&
name|q
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
comment|/* transpositions */
return|return
name|spdist
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|q
operator|+
literal|2
argument_list|,
name|thresh
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|q
index|[
literal|0
index|]
condition|)
comment|/* missing letter */
return|return
name|spdist
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|+
literal|0
argument_list|,
name|thresh
operator|-
literal|1
argument_list|)
operator|+
literal|2
return|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|q
index|[
literal|1
index|]
condition|)
comment|/* missing letter */
return|return
name|spdist
argument_list|(
name|p
operator|+
literal|0
argument_list|,
name|q
operator|+
literal|1
argument_list|,
name|thresh
operator|-
literal|1
argument_list|)
operator|+
literal|2
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
break|break;
if|if
condition|(
operator|(
operator|!
operator|*
name|p
operator|&&
name|strlen
argument_list|(
name|q
argument_list|)
operator|==
literal|1
operator|)
operator|||
operator|(
operator|!
operator|*
name|q
operator|&&
name|strlen
argument_list|(
name|p
argument_list|)
operator|==
literal|1
operator|)
condition|)
return|return
literal|2
return|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|q
operator|=
name|t
init|;
operator|*
name|p
operator|&&
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|q
index|[
literal|0
index|]
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|q
index|[
literal|1
index|]
condition|)
block|{
name|int
name|t0
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
comment|/* mistyped letter */
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|strchr
argument_list|(
name|keymap
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|*
name|z
operator|==
literal|'\n'
operator|||
operator|*
name|z
operator|==
literal|'\t'
condition|)
return|return
name|spdist
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|+
literal|1
argument_list|,
name|thresh
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
name|t0
operator|=
name|z
operator|-
name|keymap
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|-
literal|15
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|-
literal|14
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|-
literal|13
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|-
literal|1
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|+
literal|1
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|+
literal|13
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|+
literal|14
index|]
operator|||
operator|*
name|q
operator|==
name|keymap
index|[
name|t0
operator|+
literal|15
index|]
condition|)
return|return
name|spdist
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|+
literal|1
argument_list|,
name|thresh
operator|-
literal|1
argument_list|)
operator|+
literal|2
return|;
return|return
literal|200
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
break|break;
return|return
literal|200
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|zgetenv
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|av
operator|=
name|environ
init|;
operator|*
name|av
condition|;
name|av
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|av
operator|,
name|q
operator|=
name|s
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
operator|&&
operator|*
name|q
operator|&&
operator|*
name|p
operator|==
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
operator|&&
operator|!
operator|*
name|q
condition|)
return|return
name|p
operator|+
literal|1
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|tulower
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|int
name|c
decl_stmt|;
block|{
name|c
operator|&=
literal|0xff
expr_stmt|;
return|return
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tuupper
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|int
name|c
decl_stmt|;
block|{
name|c
operator|&=
literal|0xff
expr_stmt|;
return|return
operator|(
name|islower
argument_list|(
name|c
argument_list|)
condition|?
name|toupper
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_function
name|int
name|gethostname
parameter_list|(
name|nameptr
parameter_list|,
name|maxlength
parameter_list|)
name|char
modifier|*
name|nameptr
decl_stmt|;
name|int
name|maxlength
decl_stmt|;
block|{
name|struct
name|utsname
modifier|*
name|name
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|uname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|nameptr
argument_list|,
name|name
operator|->
name|sysname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* set cbreak mode, or the equivalent */
end_comment

begin_function
name|void
name|setcbreak
parameter_list|()
comment|/**/
block|{
name|struct
name|ttyinfo
name|ti
decl_stmt|;
name|ti
operator|=
name|shttyinfo
expr_stmt|;
ifdef|#
directive|ifdef
name|TIO
name|ti
operator|.
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|ti
operator|.
name|sgttyb
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
endif|#
directive|endif
name|settyinfo
argument_list|(
operator|&
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|getlineleng
parameter_list|()
comment|/**/
block|{
name|int
name|z
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
name|z
operator|=
name|shttyinfo
operator|.
name|winsize
operator|.
name|ws_col
expr_stmt|;
return|return
operator|(
name|z
operator|)
condition|?
name|z
else|:
literal|80
return|;
else|#
directive|else
return|return
literal|80
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|unsetcbreak
parameter_list|()
comment|/**/
block|{
name|settyinfo
argument_list|(
operator|&
name|shttyinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* give the tty to some process */
end_comment

begin_function
name|void
name|attachtty
parameter_list|(
name|pgrp
parameter_list|)
comment|/**/
name|long
name|pgrp
decl_stmt|;
block|{
specifier|static
name|int
name|ep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|jobbing
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_TCSETPGRP
if|if
condition|(
name|SHTTY
operator|!=
operator|-
literal|1
operator|&&
name|tcsetpgrp
argument_list|(
name|SHTTY
argument_list|,
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|!
name|ep
condition|)
else|#
directive|else
name|int
name|arg
init|=
name|pgrp
decl_stmt|;
if|if
condition|(
name|SHTTY
operator|!=
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|arg
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|!
name|ep
condition|)
endif|#
directive|endif
block|{
name|zerr
argument_list|(
literal|"can't set tty pgrp: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|opts
index|[
name|MONITOR
index|]
operator|=
name|OPT_UNSET
expr_stmt|;
name|ep
operator|=
literal|1
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* get the tty pgrp */
end_comment

begin_function
name|long
name|gettygrp
parameter_list|()
comment|/**/
block|{
name|int
name|arg
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|SHTTY
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|HAS_TCSETPGRP
name|arg
operator|=
name|tcgetpgrp
argument_list|(
name|SHTTY
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|arg
return|;
block|}
end_function

end_unit

