begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * jobs.c - job control  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_comment
comment|/* != 0 means the handler is active */
end_comment

begin_decl_stmt
specifier|static
name|int
name|handling
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INTHANDTYPE
end_ifdef

begin_define
define|#
directive|define
name|RETURN
value|return 0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RETURN
value|return
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the signal handler */
end_comment

begin_function
name|HANDTYPE
name|handler
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|)
comment|/**/
name|int
name|sig
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|long
name|pid
decl_stmt|;
name|int
name|statusp
decl_stmt|;
name|Job
name|jn
decl_stmt|;
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_RUSAGE
name|struct
name|rusage
name|ru
decl_stmt|;
else|#
directive|else
name|long
name|chlds
decl_stmt|,
name|chldu
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RESETHANDNEEDED
name|signal
argument_list|(
name|sig
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sig
operator|==
name|SIGINT
condition|)
block|{
if|if
condition|(
name|sigtrapped
index|[
name|SIGINT
index|]
condition|)
name|dotrap
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
else|else
name|errflag
operator|=
literal|1
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGWINCH
if|if
condition|(
name|sig
operator|==
name|SIGWINCH
condition|)
name|adjustwinsize
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sig
operator|!=
name|SIGCHLD
condition|)
block|{
name|dotrap
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGALRM
operator|&&
operator|!
name|sigtrapped
index|[
name|SIGALRM
index|]
condition|)
block|{
name|zerr
argument_list|(
literal|"timeout"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAS_RUSAGE
name|pid
operator|=
name|wait3
argument_list|(
operator|(
name|vptr
operator|)
operator|&
name|statusp
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|WNOHANG
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|statusp
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait3
argument_list|(
operator|(
name|vptr
operator|)
operator|&
name|statusp
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chlds
operator|=
name|shtms
operator|.
name|tms_cstime
expr_stmt|;
name|chldu
operator|=
name|shtms
operator|.
name|tms_cutime
expr_stmt|;
name|times
argument_list|(
operator|&
name|shtms
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|zerr
argument_list|(
literal|"wait failed: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pid
condition|)
name|RETURN
expr_stmt|;
name|findproc
argument_list|(
name|pid
argument_list|,
operator|&
name|jn
argument_list|,
operator|&
name|pn
argument_list|)
expr_stmt|;
comment|/* find the process of this pid */
if|if
condition|(
name|jn
condition|)
block|{
name|pn
operator|->
name|statusp
operator|=
name|statusp
expr_stmt|;
name|handling
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_RUSAGE
name|pn
operator|->
name|ti
operator|.
name|ru
operator|=
name|ru
expr_stmt|;
else|#
directive|else
name|pn
operator|->
name|ti
operator|.
name|st
operator|=
name|shtms
operator|.
name|tms_cstime
operator|-
name|chlds
expr_stmt|;
name|pn
operator|->
name|ti
operator|.
name|ut
operator|=
name|shtms
operator|.
name|tms_cutime
operator|-
name|chldu
expr_stmt|;
endif|#
directive|endif
name|pn
operator|->
name|endtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|updatestatus
argument_list|(
name|jn
argument_list|)
expr_stmt|;
name|handling
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if (WIFSTOPPED(statusp)) 			kill(pid,SIGKILL);
comment|/* kill stopped untraced children */
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* change job table entry from stopped to running */
end_comment

begin_function
name|void
name|makerunning
parameter_list|(
name|jn
parameter_list|)
comment|/**/
name|Job
name|jn
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
name|jn
operator|->
name|stat
operator|&=
operator|~
name|STAT_STOPPED
expr_stmt|;
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|pn
operator|->
name|statusp
operator|=
name|SP_RUNNING
expr_stmt|;
block|}
end_function

begin_comment
comment|/* update status of job, possibly printing it */
end_comment

begin_function
name|void
name|updatestatus
parameter_list|(
name|jn
parameter_list|)
comment|/**/
name|Job
name|jn
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
name|int
name|notrunning
init|=
literal|1
decl_stmt|,
name|alldone
init|=
literal|1
decl_stmt|,
name|val
decl_stmt|,
name|job
init|=
name|jn
operator|-
name|jobtab
decl_stmt|,
name|somestopped
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pn
operator|->
name|statusp
operator|==
name|SP_RUNNING
condition|)
name|notrunning
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|statusp
operator|==
name|SP_RUNNING
operator|||
name|WIFSTOPPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|alldone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|somestopped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pn
operator|->
name|next
operator|&&
name|jn
condition|)
name|val
operator|=
operator|(
name|WIFSIGNALED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
operator|)
condition|?
literal|0200
operator||
name|WTERMSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
else|:
name|WEXITSTATUS
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|notrunning
condition|)
return|return;
if|if
condition|(
name|somestopped
operator|&&
operator|(
name|jn
operator|->
name|stat
operator|&
name|STAT_STOPPED
operator|)
condition|)
return|return;
name|jn
operator|->
name|stat
operator||=
operator|(
name|alldone
operator|)
condition|?
name|STAT_CHANGED
operator||
name|STAT_DONE
else|:
name|STAT_CHANGED
operator||
name|STAT_STOPPED
expr_stmt|;
if|if
condition|(
name|alldone
operator|&&
name|job
operator|==
name|thisjob
condition|)
block|{
if|if
condition|(
operator|!
name|ttyfrozen
operator|&&
operator|!
name|val
condition|)
block|{
name|gettyinfo
argument_list|(
operator|&
name|shttyinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|interact
operator|&&
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|&&
name|SHTTY
operator|!=
operator|-
literal|1
operator|&&
name|isset
argument_list|(
name|USEZLE
argument_list|)
condition|)
name|sanetty
argument_list|(
operator|&
name|shttyinfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
if|if
condition|(
operator|!
operator|(
name|columns
operator|=
name|shttyinfo
operator|.
name|winsize
operator|.
name|ws_col
operator|)
condition|)
name|columns
operator|=
literal|80
expr_stmt|;
name|lines
operator|=
name|shttyinfo
operator|.
name|winsize
operator|.
name|ws_row
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|settyinfo
argument_list|(
operator|&
name|shttyinfo
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|jn
operator|->
name|stat
operator|&
operator|(
name|STAT_DONE
operator||
name|STAT_STOPPED
operator|)
operator|)
operator|==
name|STAT_STOPPED
condition|)
block|{
name|prevjob
operator|=
name|curjob
expr_stmt|;
name|curjob
operator|=
name|job
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|isset
argument_list|(
name|NOTIFY
argument_list|)
operator|||
name|job
operator|==
name|thisjob
operator|)
operator|&&
name|jn
operator|->
name|stat
operator|&
name|STAT_LOCKED
condition|)
block|{
name|printjob
argument_list|(
name|jn
argument_list|,
operator|!
operator|!
name|isset
argument_list|(
name|LONGLISTJOBS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zleactive
condition|)
name|refresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sigtrapped
index|[
name|SIGCHLD
index|]
operator|&&
name|job
operator|!=
name|thisjob
condition|)
name|dotrap
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find process and job associated with pid */
end_comment

begin_function
name|void
name|findproc
parameter_list|(
name|pid
parameter_list|,
name|jptr
parameter_list|,
name|pptr
parameter_list|)
comment|/**/
name|int
name|pid
decl_stmt|;
name|Job
modifier|*
name|jptr
decl_stmt|;
name|struct
name|process
modifier|*
modifier|*
name|pptr
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
name|int
name|jn
decl_stmt|;
for|for
control|(
name|jn
operator|=
literal|1
init|;
name|jn
operator|!=
name|MAXJOB
condition|;
name|jn
operator|++
control|)
for|for
control|(
name|pn
operator|=
name|jobtab
index|[
name|jn
index|]
operator|.
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
if|if
condition|(
name|pn
operator|->
name|pid
operator|==
name|pid
condition|)
block|{
operator|*
name|pptr
operator|=
name|pn
expr_stmt|;
operator|*
name|jptr
operator|=
name|jobtab
operator|+
name|jn
expr_stmt|;
return|return;
block|}
operator|*
name|pptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|jptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 	lng = 0 means jobs  	lng = 1 means jobs -l 	lng = 2 means jobs -p */
end_comment

begin_function
name|void
name|printjob
parameter_list|(
name|jn
parameter_list|,
name|lng
parameter_list|)
comment|/**/
name|Job
name|jn
decl_stmt|;
name|int
name|lng
decl_stmt|;
block|{
name|int
name|job
init|=
name|jn
operator|-
name|jobtab
decl_stmt|,
name|len
init|=
literal|9
decl_stmt|,
name|sig
init|=
operator|-
literal|1
decl_stmt|,
name|sflag
init|=
literal|0
decl_stmt|,
name|llen
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
name|int
name|conted
init|=
literal|0
decl_stmt|,
name|lineleng
init|=
name|getlineleng
argument_list|()
decl_stmt|,
name|skip
init|=
literal|0
decl_stmt|,
name|doputnl
init|=
literal|0
decl_stmt|;
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
if|if
condition|(
name|lng
operator|<
literal|0
condition|)
block|{
name|conted
operator|=
literal|1
expr_stmt|;
name|lng
operator|=
literal|0
expr_stmt|;
block|}
comment|/* find length of longest signame, check to see if we 		really need to print this job */
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pn
operator|->
name|statusp
operator|!=
name|SP_RUNNING
condition|)
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WTERMSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
expr_stmt|;
name|llen
operator|=
name|strlen
argument_list|(
name|sigmsg
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|WCOREDUMPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|llen
operator|+=
literal|14
expr_stmt|;
if|if
condition|(
name|llen
operator|>
name|len
condition|)
name|len
operator|=
name|llen
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGINT
operator|&&
name|sig
operator|!=
name|SIGPIPE
condition|)
name|sflag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sig
operator|==
name|SIGINT
condition|)
name|errflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|thisjob
operator|&&
name|sig
operator|==
name|SIGINT
condition|)
name|doputnl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WSTOPSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sigmsg
index|[
name|sig
index|]
argument_list|)
operator|>
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|sigmsg
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|thisjob
operator|&&
name|sig
operator|==
name|SIGTSTP
condition|)
name|doputnl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|PRINTEXITVALUE
argument_list|)
operator|&&
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|sflag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* print if necessary */
if|if
condition|(
name|interact
operator|&&
name|jobbing
operator|&&
operator|(
operator|(
name|jn
operator|->
name|stat
operator|&
name|STAT_STOPPED
operator|)
operator|||
name|sflag
operator|||
name|job
operator|!=
name|thisjob
operator|)
condition|)
block|{
name|int
name|len2
decl_stmt|,
name|fline
init|=
literal|1
decl_stmt|;
name|struct
name|process
modifier|*
name|qn
decl_stmt|;
name|trashzle
argument_list|()
expr_stmt|;
if|if
condition|(
name|doputnl
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
control|)
block|{
name|len2
operator|=
operator|(
operator|(
name|job
operator|==
name|thisjob
operator|)
condition|?
literal|5
else|:
literal|10
operator|)
operator|+
name|len
expr_stmt|;
comment|/* 2 spaces */
if|if
condition|(
name|lng
condition|)
name|qn
operator|=
name|pn
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|qn
operator|=
name|pn
operator|->
name|next
init|;
name|qn
condition|;
name|qn
operator|=
name|qn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qn
operator|->
name|statusp
operator|!=
name|pn
operator|->
name|statusp
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|qn
operator|->
name|text
argument_list|)
operator|+
name|len2
operator|+
operator|(
operator|(
name|qn
operator|->
name|next
operator|)
condition|?
literal|3
else|:
literal|0
operator|)
operator|>
name|lineleng
condition|)
break|break;
name|len2
operator|+=
name|strlen
argument_list|(
name|qn
operator|->
name|text
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|!=
name|thisjob
condition|)
if|if
condition|(
name|fline
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d]  %c "
argument_list|,
name|jn
operator|-
name|jobtab
argument_list|,
operator|(
name|job
operator|==
name|curjob
operator|)
condition|?
literal|'+'
else|:
operator|(
name|job
operator|==
name|prevjob
operator|)
condition|?
literal|'-'
else|:
literal|' '
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|job
operator|>
literal|9
operator|)
condition|?
literal|"        "
else|:
literal|"       "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zsh: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lng
condition|)
if|if
condition|(
name|lng
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|pn
operator|->
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|x
init|=
name|jn
operator|->
name|gleader
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|x
argument_list|)
expr_stmt|;
do|do
name|skip
operator|++
expr_stmt|;
do|while
condition|(
name|x
operator|/=
literal|10
condition|)
do|;
name|skip
operator|++
expr_stmt|;
name|lng
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|statusp
operator|==
name|SP_RUNNING
condition|)
if|if
condition|(
operator|!
name|conted
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"running%*s"
argument_list|,
name|len
operator|-
literal|7
operator|+
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"continued%*s"
argument_list|,
name|len
operator|-
literal|9
operator|+
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exit %-4d%*s"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
argument_list|,
name|len
operator|-
literal|9
operator|+
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done%*s"
argument_list|,
name|len
operator|-
literal|4
operator|+
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-*s"
argument_list|,
name|len
operator|+
literal|2
argument_list|,
name|sigmsg
index|[
name|WSTOPSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WCOREDUMPED
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (core dumped)%*s"
argument_list|,
name|sigmsg
index|[
name|WTERMSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
index|]
argument_list|,
name|len
operator|-
literal|14
operator|+
literal|2
operator|-
name|strlen
argument_list|(
name|sigmsg
index|[
name|WTERMSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
index|]
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-*s"
argument_list|,
name|len
operator|+
literal|2
argument_list|,
name|sigmsg
index|[
name|WTERMSIG
argument_list|(
name|pn
operator|->
name|statusp
argument_list|)
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pn
operator|!=
name|qn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|pn
operator|->
name|next
operator|)
condition|?
literal|"%s | "
else|:
literal|"%s"
argument_list|,
name|pn
operator|->
name|text
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fline
operator|=
literal|0
expr_stmt|;
block|}
name|printed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doputnl
operator|&&
name|interact
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* print "(pwd now: foo)" messages */
if|if
condition|(
name|interact
operator|&&
name|job
operator|==
name|thisjob
operator|&&
name|strcmp
argument_list|(
name|jn
operator|->
name|pwd
argument_list|,
name|pwd
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"(pwd now: "
argument_list|)
expr_stmt|;
name|printdir
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* delete job if done */
if|if
condition|(
name|jn
operator|->
name|stat
operator|&
name|STAT_DONE
condition|)
block|{
specifier|static
name|struct
name|job
name|zero
decl_stmt|;
name|struct
name|process
modifier|*
name|nx
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|jn
operator|->
name|stat
operator|&
name|STAT_TIMED
operator|)
operator|||
operator|(
name|reporttime
operator|!=
operator|-
literal|1
operator|&&
name|report
argument_list|(
name|jn
argument_list|)
operator|)
condition|)
block|{
name|dumptime
argument_list|(
name|jn
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|nx
control|)
block|{
name|nx
operator|=
name|pn
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|jn
operator|->
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|jn
operator|->
name|filelist
condition|)
block|{
while|while
condition|(
name|s
operator|=
name|getnode
argument_list|(
name|jn
operator|->
name|filelist
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|jn
operator|->
name|filelist
argument_list|)
expr_stmt|;
block|}
operator|*
name|jn
operator|=
name|zero
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|curjob
condition|)
block|{
name|curjob
operator|=
name|prevjob
expr_stmt|;
name|prevjob
operator|=
name|job
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|==
name|prevjob
condition|)
name|setprevjob
argument_list|()
expr_stmt|;
block|}
else|else
name|jn
operator|->
name|stat
operator|&=
operator|~
name|STAT_CHANGED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set the previous job to something reasonable */
end_comment

begin_function
name|void
name|setprevjob
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
name|MAXJOB
operator|-
literal|1
init|;
name|t0
condition|;
name|t0
operator|--
control|)
if|if
condition|(
operator|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_INUSE
operator|)
operator|&&
operator|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
operator|)
operator|&&
name|t0
operator|!=
name|curjob
operator|&&
name|t0
operator|!=
name|thisjob
condition|)
break|break;
if|if
condition|(
operator|!
name|t0
condition|)
for|for
control|(
name|t0
operator|=
name|MAXJOB
operator|-
literal|1
init|;
name|t0
condition|;
name|t0
operator|--
control|)
if|if
condition|(
operator|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_INUSE
operator|)
operator|&&
name|t0
operator|!=
name|curjob
operator|&&
name|t0
operator|!=
name|thisjob
condition|)
break|break;
name|prevjob
operator|=
operator|(
name|t0
operator|)
condition|?
name|t0
else|:
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize a job table entry */
end_comment

begin_function
name|void
name|initjob
parameter_list|()
comment|/**/
block|{
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|pwd
operator|=
name|ztrdup
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|stat
operator|=
name|STAT_INUSE
expr_stmt|;
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a process to the current job */
end_comment

begin_function
name|struct
name|process
modifier|*
name|addproc
parameter_list|(
name|pid
parameter_list|,
name|text
parameter_list|)
comment|/**/
name|long
name|pid
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|process
decl_stmt|;
if|if
condition|(
operator|!
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
condition|)
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
operator|=
name|pid
expr_stmt|;
name|process
operator|=
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|process
argument_list|)
expr_stmt|;
name|process
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|text
condition|)
name|strcpy
argument_list|(
name|process
operator|->
name|text
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
operator|*
name|process
operator|->
name|text
operator|=
literal|'\0'
expr_stmt|;
name|process
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|process
operator|->
name|statusp
operator|=
name|SP_RUNNING
expr_stmt|;
name|process
operator|->
name|bgtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|procs
condition|)
block|{
name|struct
name|process
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|procs
init|;
name|n
operator|->
name|next
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
empty_stmt|;
name|process
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|process
expr_stmt|;
block|}
else|else
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|procs
operator|=
name|process
expr_stmt|;
return|return
name|process
return|;
block|}
end_function

begin_comment
comment|/* determine if it's all right to exec a command without 	forking in last component of subshells; it's not ok if we have files 	to delete */
end_comment

begin_function
name|int
name|execok
parameter_list|()
comment|/**/
block|{
name|Job
name|jn
decl_stmt|;
if|if
condition|(
operator|!
name|exiting
condition|)
return|return
literal|0
return|;
for|for
control|(
name|jn
operator|=
name|jobtab
operator|+
literal|1
init|;
name|jn
operator|!=
name|jobtab
operator|+
name|MAXJOB
condition|;
name|jn
operator|++
control|)
if|if
condition|(
name|jn
operator|->
name|stat
operator|&&
name|jn
operator|->
name|filelist
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|waitforpid
parameter_list|(
name|pid
parameter_list|)
comment|/**/
name|long
name|pid
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|errflag
operator|&&
operator|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ESRCH
operator|)
condition|)
name|chldsuspend
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wait for a job to finish */
end_comment

begin_function
name|void
name|waitjob
parameter_list|(
name|job
parameter_list|)
comment|/**/
name|int
name|job
decl_stmt|;
block|{
specifier|static
name|struct
name|job
name|zero
decl_stmt|;
name|Job
name|jn
decl_stmt|;
if|if
condition|(
name|jobtab
index|[
name|job
index|]
operator|.
name|procs
condition|)
comment|/* if any forks were done */
block|{
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
operator||=
name|STAT_LOCKED
expr_stmt|;
if|if
condition|(
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
operator|&
name|STAT_CHANGED
condition|)
name|printjob
argument_list|(
name|jobtab
operator|+
name|job
argument_list|,
operator|!
operator|!
name|isset
argument_list|(
name|LONGLISTJOBS
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
operator|&&
operator|!
operator|(
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
operator|&
operator|(
name|STAT_DONE
operator||
name|STAT_STOPPED
operator|)
operator|)
condition|)
name|chldsuspend
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* else do what printjob() usually does */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|jn
operator|=
name|jobtab
operator|+
name|job
expr_stmt|;
name|free
argument_list|(
name|jn
operator|->
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|jn
operator|->
name|filelist
condition|)
block|{
while|while
condition|(
name|s
operator|=
name|getnode
argument_list|(
name|jn
operator|->
name|filelist
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|jn
operator|->
name|filelist
argument_list|)
expr_stmt|;
block|}
operator|*
name|jn
operator|=
name|zero
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* wait for running job to finish */
end_comment

begin_function
name|void
name|waitjobs
parameter_list|()
comment|/**/
block|{
name|waitjob
argument_list|(
name|thisjob
argument_list|)
expr_stmt|;
name|thisjob
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear job table when entering subshells */
end_comment

begin_function
name|void
name|clearjobtab
parameter_list|()
comment|/**/
block|{
specifier|static
name|struct
name|job
name|zero
decl_stmt|;
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|1
init|;
name|t0
operator|!=
name|MAXJOB
condition|;
name|t0
operator|++
control|)
name|jobtab
index|[
name|thisjob
index|]
operator|=
name|zero
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get a free entry in the job table to use */
end_comment

begin_function
name|int
name|getfreejob
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|1
init|;
name|t0
operator|!=
name|MAXJOB
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
condition|)
block|{
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator||=
name|STAT_INUSE
expr_stmt|;
return|return
name|t0
return|;
block|}
name|zerr
argument_list|(
literal|"job table full or recursion limit exceeded"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* print pids for& */
end_comment

begin_function
name|void
name|spawnjob
parameter_list|()
comment|/**/
block|{
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
if|if
condition|(
operator|!
name|subsh
condition|)
block|{
if|if
condition|(
name|curjob
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
name|jobtab
index|[
name|curjob
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
operator|)
condition|)
block|{
name|curjob
operator|=
name|thisjob
expr_stmt|;
name|setprevjob
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prevjob
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
name|jobtab
index|[
name|prevjob
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
operator|)
condition|)
name|prevjob
operator|=
name|thisjob
expr_stmt|;
if|if
condition|(
name|interact
operator|&&
name|jobbing
operator|&&
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|procs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d]"
argument_list|,
name|thisjob
argument_list|)
expr_stmt|;
for|for
control|(
name|pn
operator|=
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
name|pn
operator|->
name|pid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|procs
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|struct
name|job
name|zero
decl_stmt|;
name|struct
name|job
modifier|*
name|jn
decl_stmt|;
name|jn
operator|=
name|jobtab
operator|+
name|thisjob
expr_stmt|;
name|free
argument_list|(
name|jn
operator|->
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|jn
operator|->
name|filelist
condition|)
block|{
while|while
condition|(
name|s
operator|=
name|getnode
argument_list|(
name|jn
operator|->
name|filelist
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|jn
operator|->
name|filelist
argument_list|)
expr_stmt|;
block|}
operator|*
name|jn
operator|=
name|zero
expr_stmt|;
block|}
else|else
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|stat
operator||=
name|STAT_LOCKED
expr_stmt|;
name|thisjob
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fixsigs
parameter_list|()
comment|/**/
block|{
name|unblockchld
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|report
parameter_list|(
name|j
parameter_list|)
comment|/**/
name|Job
name|j
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|j
operator|->
name|procs
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAS_RUSAGE
return|return
operator|(
name|j
operator|->
name|procs
operator|->
name|ti
operator|.
name|ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|j
operator|->
name|procs
operator|->
name|ti
operator|.
name|ru
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|)
operator|>=
name|reporttime
return|;
else|#
directive|else
return|return
operator|(
name|j
operator|->
name|procs
operator|->
name|ti
operator|.
name|ut
operator|+
name|j
operator|->
name|procs
operator|->
name|ti
operator|.
name|st
operator|)
operator|/
name|HZ
operator|>=
name|reporttime
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|printtime
parameter_list|(
name|real
parameter_list|,
name|ti
parameter_list|,
name|desc
parameter_list|)
comment|/**/
name|time_t
name|real
decl_stmt|;
name|struct
name|timeinfo
modifier|*
name|ti
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|sun
name|long
name|ticks
init|=
literal|1
decl_stmt|;
name|int
name|pk
init|=
name|getpagesize
argument_list|()
operator|/
literal|1024
decl_stmt|;
else|#
directive|else
name|long
name|sec
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_RUSAGE
name|struct
name|rusage
modifier|*
name|ru
init|=
operator|&
name|ti
operator|->
name|ru
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|desc
condition|)
name|desc
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_RUSAGE
ifdef|#
directive|ifdef
name|sun
name|ticks
operator|=
operator|(
name|ru
operator|->
name|ru_utime
operator|.
name|tv_sec
operator|+
name|ru
operator|->
name|ru_stime
operator|.
name|tv_sec
operator|)
operator|*
name|HZ
operator|+
operator|(
name|ru
operator|->
name|ru_utime
operator|.
name|tv_usec
operator|+
name|ru
operator|->
name|ru_stime
operator|.
name|tv_usec
operator|)
operator|*
name|HZ
operator|/
literal|1000000
expr_stmt|;
if|if
condition|(
operator|!
name|ticks
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|sec
operator|=
name|ru
operator|->
name|ru_utime
operator|.
name|tv_sec
operator|+
name|ru
operator|->
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
name|sec
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
name|s
operator|=
name|timefmt
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
switch|switch
condition|(
name|s
operator|++
operator|,
operator|*
name|s
condition|)
block|{
case|case
literal|'E'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lds"
argument_list|,
name|real
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|HAS_RUSAGE
case|case
literal|'U'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld.%03lds"
argument_list|,
name|ti
operator|->
name|ut
operator|/
name|HZ
argument_list|,
name|ti
operator|->
name|ut
operator|*
literal|1000
operator|/
literal|60
operator|%
literal|1000
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld.%03lds"
argument_list|,
name|ti
operator|->
name|st
operator|/
name|HZ
argument_list|,
name|ti
operator|->
name|st
operator|*
literal|1000
operator|/
literal|60
operator|%
literal|1000
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|real
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d%%"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|100
operator|*
operator|(
operator|(
name|ti
operator|->
name|ut
operator|+
name|ti
operator|->
name|st
operator|)
operator|/
name|HZ
operator|)
argument_list|)
operator|/
name|real
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|'U'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld.%03lds"
argument_list|,
name|ru
operator|->
name|ru_utime
operator|.
name|tv_sec
argument_list|,
name|ru
operator|->
name|ru_utime
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld.%03lds"
argument_list|,
name|ru
operator|->
name|ru_stime
operator|.
name|tv_sec
argument_list|,
name|ru
operator|->
name|ru_stime
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|real
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d%%"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|100
operator|*
operator|(
name|ru
operator|->
name|ru_utime
operator|.
name|tv_sec
operator|+
name|ru
operator|->
name|ru_stime
operator|.
name|tv_sec
operator|)
argument_list|)
operator|/
name|real
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_nswap
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|sun
case|case
literal|'K'
case|:
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_idrss
operator|/
name|ticks
operator|*
name|pk
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_maxrss
operator|*
name|pk
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|'X'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_ixrss
operator|/
name|sec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|ru
operator|->
name|ru_idrss
operator|+
name|ru
operator|->
name|ru_isrss
operator|)
operator|/
name|sec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|ru
operator|->
name|ru_ixrss
operator|+
name|ru
operator|->
name|ru_idrss
operator|+
name|ru
operator|->
name|ru_isrss
operator|)
operator|/
name|sec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_maxrss
operator|/
literal|1024
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'F'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_majflt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_minflt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_inblock
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_oublock
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_msgrcv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_msgsnd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_nsignals
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_nvcsw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld"
argument_list|,
name|ru
operator|->
name|ru_nivcsw
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'J'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%%%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dumptime
parameter_list|(
name|jn
parameter_list|)
comment|/**/
name|Job
name|jn
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pn
init|=
name|jn
operator|->
name|procs
decl_stmt|;
if|if
condition|(
operator|!
name|jn
operator|->
name|procs
condition|)
return|return;
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
name|printtime
argument_list|(
name|pn
operator|->
name|endtime
operator|-
name|pn
operator|->
name|bgtime
argument_list|,
operator|&
name|pn
operator|->
name|ti
argument_list|,
name|pn
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shelltime
parameter_list|()
comment|/**/
block|{
name|struct
name|timeinfo
name|ti
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_RUSAGE
name|struct
name|rusage
name|ru
decl_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ti
operator|.
name|ru
argument_list|,
operator|&
name|ru
argument_list|,
sizeof|sizeof
argument_list|(
name|ru
argument_list|)
argument_list|)
expr_stmt|;
name|printtime
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|shtimer
argument_list|,
operator|&
name|ti
argument_list|,
literal|"shell"
argument_list|)
expr_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ti
operator|.
name|ru
argument_list|,
operator|&
name|ru
argument_list|,
sizeof|sizeof
argument_list|(
name|ru
argument_list|)
argument_list|)
expr_stmt|;
name|printtime
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|shtimer
argument_list|,
operator|&
name|ti
argument_list|,
literal|"children"
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|tms
name|buf
decl_stmt|;
name|times
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ti
operator|.
name|ut
operator|=
name|buf
operator|.
name|tms_utime
expr_stmt|;
name|ti
operator|.
name|st
operator|=
name|buf
operator|.
name|tms_stime
expr_stmt|;
name|printtime
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|shtimer
argument_list|,
operator|&
name|ti
argument_list|,
literal|"shell"
argument_list|)
expr_stmt|;
name|ti
operator|.
name|ut
operator|=
name|buf
operator|.
name|tms_cutime
expr_stmt|;
name|ti
operator|.
name|st
operator|=
name|buf
operator|.
name|tms_cstime
expr_stmt|;
name|printtime
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|shtimer
argument_list|,
operator|&
name|ti
argument_list|,
literal|"children"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* SIGHUP any jobs left running */
end_comment

begin_function
name|void
name|killrunjobs
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|,
name|killed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|NOHUP
argument_list|)
condition|)
return|return;
for|for
control|(
name|t0
operator|=
literal|1
init|;
name|t0
operator|!=
name|MAXJOB
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|t0
operator|!=
name|thisjob
operator|&&
operator|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_LOCKED
operator|)
operator|&&
operator|!
operator|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
operator|)
condition|)
block|{
if|if
condition|(
name|killpg
argument_list|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|gleader
argument_list|,
name|SIGHUP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|killed
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|killed
condition|)
name|zerr
argument_list|(
literal|"warning: %d jobs SIGHUPed"
argument_list|,
name|NULL
argument_list|,
name|killed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check to see if user has jobs running/stopped */
end_comment

begin_function
name|void
name|checkjobs
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
name|scanjobs
argument_list|()
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|1
init|;
name|t0
operator|!=
name|MAXJOB
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|t0
operator|!=
name|thisjob
operator|&&
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_LOCKED
condition|)
break|break;
if|if
condition|(
name|t0
operator|!=
name|MAXJOB
condition|)
block|{
if|if
condition|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_SUSPENDED
name|zerr
argument_list|(
literal|"you have suspended jobs."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|zerr
argument_list|(
literal|"you have stopped jobs."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|zerr
argument_list|(
literal|"you have running jobs."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stopmsg
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* send a signal to a job (simply involves kill if monitoring is on) */
end_comment

begin_function
name|int
name|killjb
parameter_list|(
name|jn
parameter_list|,
name|sig
parameter_list|)
comment|/**/
name|Job
name|jn
decl_stmt|;
name|int
name|sig
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|jobbing
condition|)
return|return
operator|(
name|killpg
argument_list|(
name|jn
operator|->
name|gleader
argument_list|,
name|sig
argument_list|)
operator|)
return|;
for|for
control|(
name|pn
operator|=
name|jn
operator|->
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|err
operator|=
name|kill
argument_list|(
name|pn
operator|->
name|pid
argument_list|,
name|sig
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ESRCH
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|err
return|;
block|}
end_function

end_unit

