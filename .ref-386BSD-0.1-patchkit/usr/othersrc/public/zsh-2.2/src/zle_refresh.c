begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * zle_refresh.c - screen update  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_define
define|#
directive|define
name|ZLE
end_define

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_decl_stmt
name|char
modifier|*
modifier|*
name|obuf
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|nbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|olnct
decl_stmt|,
name|nlnct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|winw
decl_stmt|,
name|winh
decl_stmt|,
name|winpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vcs
decl_stmt|,
name|vln
decl_stmt|,
name|vmaxln
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|resetvideo
parameter_list|()
comment|/**/
block|{
name|int
name|ln
decl_stmt|;
specifier|static
name|int
name|lwinw
init|=
operator|-
literal|1
decl_stmt|,
name|lwinh
init|=
operator|-
literal|1
decl_stmt|;
name|setterm
argument_list|()
expr_stmt|;
name|winw
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|SINGLELINEZLE
argument_list|)
operator|||
operator|!
name|termok
condition|)
name|winh
operator|=
literal|1
expr_stmt|;
else|else
name|winh
operator|=
operator|(
name|lines
operator|<
literal|2
operator|)
condition|?
literal|24
else|:
name|lines
expr_stmt|;
name|winpos
operator|=
name|vln
operator|=
name|vmaxln
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lwinw
operator|!=
name|winw
operator|||
name|lwinh
operator|!=
name|winh
condition|)
block|{
if|if
condition|(
name|nbuf
condition|)
block|{
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|!=
name|lwinh
condition|;
name|ln
operator|++
control|)
block|{
name|free
argument_list|(
name|nbuf
index|[
name|ln
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obuf
index|[
name|ln
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
block|}
name|nbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
operator|(
name|winh
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
operator|(
name|winh
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|!=
name|winh
operator|+
literal|1
condition|;
name|ln
operator|++
control|)
block|{
name|nbuf
index|[
name|ln
index|]
operator|=
name|zalloc
argument_list|(
name|winw
operator|+
literal|1
argument_list|)
expr_stmt|;
name|obuf
index|[
name|ln
index|]
operator|=
name|zalloc
argument_list|(
name|winw
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|lwinw
operator|=
name|winw
expr_stmt|;
name|lwinh
operator|=
name|winh
expr_stmt|;
block|}
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|!=
name|winh
operator|+
literal|1
condition|;
name|ln
operator|++
control|)
block|{
operator|*
name|nbuf
index|[
name|ln
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|obuf
index|[
name|ln
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pptlen
condition|)
name|nbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|obuf
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|!=
name|pptlen
operator|-
literal|1
condition|;
name|ln
operator|++
control|)
name|nbuf
index|[
literal|0
index|]
index|[
name|ln
index|]
operator|=
name|obuf
index|[
literal|0
index|]
index|[
name|ln
index|]
operator|=
literal|' '
expr_stmt|;
name|nbuf
index|[
literal|0
index|]
index|[
name|ln
index|]
operator|=
name|obuf
index|[
literal|0
index|]
index|[
name|ln
index|]
operator|=
literal|'>'
expr_stmt|;
name|nbuf
index|[
literal|0
index|]
index|[
name|pptlen
index|]
operator|=
name|obuf
index|[
literal|0
index|]
index|[
name|pptlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|vcs
operator|=
name|pptlen
expr_stmt|;
name|olnct
operator|=
name|nlnct
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|scrollwindow
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|,
name|hwinh
init|=
name|winh
operator|/
literal|2
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|winh
operator|-
name|hwinh
condition|;
name|t0
operator|++
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|nbuf
index|[
name|t0
index|]
expr_stmt|;
name|nbuf
index|[
name|t0
index|]
operator|=
name|nbuf
index|[
name|t0
operator|+
name|hwinh
index|]
expr_stmt|;
name|nbuf
index|[
name|t0
operator|+
name|hwinh
index|]
operator|=
name|s
expr_stmt|;
block|}
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|pptlen
operator|-
literal|1
condition|;
name|t0
operator|++
control|)
name|nbuf
index|[
literal|0
index|]
index|[
name|t0
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|nbuf
index|[
literal|0
index|]
operator|+
name|t0
argument_list|,
literal|"> ..."
argument_list|)
expr_stmt|;
return|return
name|winh
operator|-
name|hwinh
return|;
block|}
end_function

begin_comment
comment|/* this is the messy part. */
end_comment

begin_comment
comment|/* this define belongs where it's used!!! */
end_comment

begin_define
define|#
directive|define
name|nextline
value|{ *s = (unsigned char)'\0'; \ 	if (winh == ln+1) if (nvln != -1) break; else ln = scrollwindow()-1; \ 	s = (unsigned char *)nbuf[++ln]; sen = s+winw; \ 	}
end_define

begin_function
name|void
name|refresh
parameter_list|()
comment|/**/
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|sen
decl_stmt|,
modifier|*
name|scs
init|=
name|line
operator|+
name|cs
decl_stmt|;
name|char
modifier|*
modifier|*
name|qbuf
decl_stmt|;
name|int
name|ln
init|=
literal|0
decl_stmt|,
name|nvcs
decl_stmt|,
name|nvln
init|=
operator|-
literal|1
decl_stmt|,
name|t0
decl_stmt|;
name|cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resetneeded
condition|)
block|{
name|resetvideo
argument_list|()
expr_stmt|;
name|resetneeded
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|SINGLELINEZLE
argument_list|)
operator|||
operator|!
name|termok
condition|)
name|vcs
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|pmpt
argument_list|)
expr_stmt|;
block|}
name|zleactive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|SINGLELINEZLE
argument_list|)
operator|||
operator|!
name|termok
condition|)
block|{
name|singlerefresh
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* first, we generate the video line buffers so we know what to 	put on the screen.   	s = ptr into the video buffer. 	t = ptr into the real buffer. 	sen = end of the video buffer (eol) */
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|nbuf
index|[
name|ln
operator|=
literal|0
index|]
operator|+
name|pptlen
operator|)
expr_stmt|;
name|t
operator|=
name|line
expr_stmt|;
name|sen
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|nbuf
operator|+
name|winw
operator|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|icntrl
argument_list|(
operator|(
name|char
operator|)
operator|*
name|t
argument_list|)
condition|)
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|scs
condition|)
block|{
name|nvcs
operator|=
operator|(
name|char
operator|*
operator|)
name|s
operator|-
name|nbuf
index|[
name|nvln
operator|=
name|ln
index|]
expr_stmt|;
name|scs
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|nextline
block|}
elseif|else
if|if
condition|(
operator|(
name|char
operator|)
operator|*
name|t
operator|==
literal|'\t'
condition|)
block|{
name|int
name|t1
init|=
operator|(
name|char
operator|*
operator|)
name|s
operator|-
name|nbuf
index|[
name|ln
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|t1
operator||
literal|7
operator|)
operator|+
literal|1
operator|>=
name|winw
condition|)
name|nextline
else|else
do|do
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
do|while
condition|(
operator|(
operator|++
name|t1
operator|)
operator|&
literal|7
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|==
name|sen
condition|)
name|nextline
operator|*
name|s
operator|++
operator|=
literal|'^'
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|sen
condition|)
name|nextline
operator|*
name|s
operator|++
operator|=
operator|(
operator|*
name|t
operator|==
literal|127
operator|)
condition|?
literal|'?'
else|:
operator|(
operator|*
name|t
operator||
literal|'@'
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|==
name|sen
condition|)
name|nextline
operator|*
name|s
operator|++
operator|=
operator|*
name|t
expr_stmt|;
block|}
comment|/* if the cursor is here, remember it */
if|if
condition|(
name|t
operator|==
name|scs
condition|)
name|nvcs
operator|=
name|s
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|nbuf
index|[
name|nvln
operator|=
name|ln
index|]
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scs
operator|==
name|t
condition|)
name|nvcs
operator|=
name|s
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|nbuf
index|[
name|nvln
operator|=
name|ln
index|]
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|nlnct
operator|=
name|ln
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|statusline
condition|)
name|strcpy
argument_list|(
name|nbuf
index|[
operator|(
name|nlnct
operator|==
name|winh
operator|)
condition|?
name|winh
operator|-
literal|1
else|:
name|nlnct
operator|++
index|]
argument_list|,
name|statusline
argument_list|)
expr_stmt|;
comment|/* do RPROMPT */
if|if
condition|(
name|pmpt2
operator|&&
name|ln
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|nbuf
index|[
literal|0
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|pmpt2
argument_list|)
operator|<
name|winw
condition|)
block|{
for|for
control|(
name|t0
operator|=
name|strlen
argument_list|(
name|nbuf
index|[
literal|0
index|]
argument_list|)
init|;
name|t0
operator|!=
name|winw
condition|;
name|t0
operator|++
control|)
name|nbuf
index|[
literal|0
index|]
index|[
name|t0
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|nbuf
index|[
literal|0
index|]
operator|+
name|winw
operator|-
name|strlen
argument_list|(
name|pmpt2
argument_list|)
argument_list|,
name|pmpt2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|nlnct
condition|;
name|ln
operator|++
control|)
block|{
comment|/* if old line and new line are different, 	see if we can insert/delete a line */
if|if
condition|(
name|ln
operator|<
name|olnct
operator|&&
name|strncmp
argument_list|(
name|nbuf
index|[
name|ln
index|]
argument_list|,
name|obuf
index|[
name|ln
index|]
argument_list|,
literal|16
argument_list|)
condition|)
block|{
if|if
condition|(
name|tccan
argument_list|(
name|TCDELLINE
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|nbuf
index|[
name|ln
index|]
argument_list|,
name|obuf
index|[
name|ln
operator|+
literal|1
index|]
argument_list|,
literal|16
argument_list|)
operator|&&
name|obuf
index|[
name|ln
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|&&
name|ln
operator|!=
name|olnct
condition|)
block|{
name|int
name|t0
decl_stmt|;
name|moveto
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcout
argument_list|(
name|TCDELLINE
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|ln
init|;
name|t0
operator|!=
name|olnct
condition|;
name|t0
operator|++
control|)
name|strcpy
argument_list|(
name|obuf
index|[
name|t0
index|]
argument_list|,
name|obuf
index|[
name|t0
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|olnct
operator|--
expr_stmt|;
block|}
comment|/* don't try to insert a line if olnct< vmaxln (vmaxln is the number 	of lines that have been displayed by this routine) so that we don't 	go off the end of the screen. */
elseif|else
if|if
condition|(
name|tccan
argument_list|(
name|TCINSLINE
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|nbuf
index|[
name|ln
operator|+
literal|1
index|]
argument_list|,
name|obuf
index|[
name|ln
index|]
argument_list|,
literal|16
argument_list|)
operator|&&
name|olnct
operator|<
name|vmaxln
operator|&&
name|nbuf
index|[
name|ln
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|&&
name|ln
operator|!=
name|olnct
condition|)
block|{
name|int
name|t0
decl_stmt|;
name|moveto
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcout
argument_list|(
name|TCINSLINE
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|olnct
init|;
name|t0
operator|!=
name|ln
condition|;
name|t0
operator|--
control|)
name|strcpy
argument_list|(
name|obuf
index|[
name|t0
index|]
argument_list|,
name|obuf
index|[
name|t0
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|obuf
index|[
name|ln
index|]
operator|=
literal|'\0'
expr_stmt|;
name|olnct
operator|++
expr_stmt|;
block|}
block|}
name|refreshline
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
comment|/* if old buffer had extra lines, do a clear-end-of-display if we can, 	otherwise, just fill new buffer with blank lines and refresh them */
if|if
condition|(
name|olnct
operator|>
name|nlnct
condition|)
block|{
for|for
control|(
name|ln
operator|=
name|nlnct
init|;
name|ln
operator|<
name|olnct
condition|;
name|ln
operator|++
control|)
name|nbuf
index|[
name|ln
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tccan
argument_list|(
name|TCCLEAREOD
argument_list|)
condition|)
block|{
name|moveto
argument_list|(
name|nlnct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcout
argument_list|(
name|TCCLEAREOD
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|ln
operator|=
name|nlnct
init|;
name|ln
operator|<
name|olnct
condition|;
name|ln
operator|++
control|)
name|refreshline
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
comment|/* move to the new cursor position */
name|moveto
argument_list|(
name|nvln
argument_list|,
name|nvcs
argument_list|)
expr_stmt|;
name|qbuf
operator|=
name|nbuf
expr_stmt|;
name|nbuf
operator|=
name|obuf
expr_stmt|;
name|obuf
operator|=
name|qbuf
expr_stmt|;
name|olnct
operator|=
name|nlnct
expr_stmt|;
if|if
condition|(
name|nlnct
operator|>
name|vmaxln
condition|)
name|vmaxln
operator|=
name|nlnct
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|tcinscost
parameter_list|(
name|X
parameter_list|)
value|(tccan(TCMULTINS) ? tclen[TCMULTINS] : (X)*tclen[TCINS])
end_define

begin_define
define|#
directive|define
name|tcdelcost
parameter_list|(
name|X
parameter_list|)
value|(tccan(TCMULTDEL) ? tclen[TCMULTDEL] : (X)*tclen[TCDEL])
end_define

begin_define
define|#
directive|define
name|tc_delchars
parameter_list|(
name|X
parameter_list|)
value|tcmultout(TCDEL,TCMULTDEL,(X))
end_define

begin_define
define|#
directive|define
name|tc_inschars
parameter_list|(
name|X
parameter_list|)
value|tcmultout(TCINS,TCMULTINS,(X))
end_define

begin_define
define|#
directive|define
name|tc_upcurs
parameter_list|(
name|X
parameter_list|)
value|tcmultout(TCUP,TCMULTUP,(X))
end_define

begin_define
define|#
directive|define
name|tc_leftcurs
parameter_list|(
name|X
parameter_list|)
value|tcmultout(TCLEFT,TCMULTLEFT,(X))
end_define

begin_function
name|void
name|refreshline
parameter_list|(
name|ln
parameter_list|)
comment|/**/
name|int
name|ln
decl_stmt|;
block|{
name|char
modifier|*
name|nl
init|=
name|nbuf
index|[
name|ln
index|]
decl_stmt|,
modifier|*
name|ol
init|=
name|obuf
index|[
name|ln
index|]
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
name|junk
decl_stmt|,
modifier|*
name|truncptr
init|=
operator|&
name|junk
decl_stmt|;
name|int
name|ccs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ln
operator|>=
name|olnct
condition|)
operator|*
name|ol
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|nl
operator|&&
operator|*
name|nl
operator|==
operator|*
name|ol
condition|)
block|{
name|nl
operator|++
operator|,
name|ol
operator|++
operator|,
name|ccs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|nl
operator|&&
operator|!
operator|*
name|ol
condition|)
block|{
operator|*
name|truncptr
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
comment|/* if this is the end of the new buffer but the old buffer has stuff 	here, clear to end of line if we can, otherwise fill the new buffer 	with blanks and continue. */
if|if
condition|(
operator|!
operator|*
name|nl
condition|)
block|{
if|if
condition|(
name|tccan
argument_list|(
name|TCCLEAREOL
argument_list|)
operator|&&
name|strlen
argument_list|(
name|ol
argument_list|)
operator|>
name|tclen
index|[
name|TCCLEAREOL
index|]
condition|)
block|{
name|moveto
argument_list|(
name|ln
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|tcout
argument_list|(
name|TCCLEAREOL
argument_list|)
expr_stmt|;
operator|*
name|ol
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|truncptr
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|x
init|=
name|strlen
argument_list|(
name|ol
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|nl
decl_stmt|;
name|truncptr
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|x
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* if this is the end of the old buffer, just dump the rest of the 	new buffer. */
if|if
condition|(
operator|!
operator|*
name|ol
condition|)
block|{
while|while
condition|(
operator|*
name|nl
operator|==
literal|' '
condition|)
name|nl
operator|++
operator|,
name|ccs
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nl
condition|)
block|{
name|moveto
argument_list|(
name|ln
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|nl
argument_list|,
name|strlen
argument_list|(
name|nl
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|strlen
argument_list|(
name|nl
argument_list|)
expr_stmt|;
name|ccs
operator|=
operator|(
name|vcs
operator|+=
name|strlen
argument_list|(
name|nl
argument_list|)
operator|)
expr_stmt|;
block|}
operator|*
name|truncptr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|moveto
argument_list|(
name|ln
argument_list|,
name|ccs
argument_list|)
expr_stmt|;
comment|/* try to insert/delete characters */
if|if
condition|(
name|ol
index|[
literal|1
index|]
operator|!=
name|nl
index|[
literal|1
index|]
operator|&&
name|tccan
argument_list|(
name|TCDEL
argument_list|)
condition|)
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|ol
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
operator|,
name|ct
operator|++
control|)
if|if
condition|(
name|tcdelcost
argument_list|(
name|ct
argument_list|)
operator|<
name|streqct
argument_list|(
name|p1
argument_list|,
name|nl
argument_list|)
condition|)
block|{
name|tc_delchars
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|ol
operator|=
name|p1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p1
condition|)
continue|continue;
block|}
if|if
condition|(
name|ol
index|[
literal|1
index|]
operator|!=
name|nl
index|[
literal|1
index|]
operator|&&
name|tccan
argument_list|(
name|TCINS
argument_list|)
condition|)
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|nl
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
operator|,
name|ct
operator|++
control|)
if|if
condition|(
name|tcinscost
argument_list|(
name|ct
argument_list|)
operator|<
name|streqct
argument_list|(
name|p1
argument_list|,
name|ol
argument_list|)
operator|+
name|ct
condition|)
block|{
if|#
directive|if
literal|0
comment|/* make sure we aren't inserting characters off the end of the screen; 	if we are, jump to the end and truncate the line, if we can do 	it quickly (gee, clever idea, Paul!) */
block|if (ct+ccs+strlen(ol)>= winw-1) 						{ 						if (!tccan(TCMULTRIGHT) || ccs> winw-tclen[TCMULTRIGHT]) 							continue; 						moveto(ln,winw-1-ct); 						if (!tccan(TCCLEAREOL) || ct< tclen[TCCLEAREOL]) 							{ 							int x = ct;  							while (vcs++,x--) 								putchar(' '); 							} 						else 							tcout(TCCLEAREOL); 						moveto(ln,ccs); 						}
endif|#
directive|endif
if|if
condition|(
name|ct
operator|+
name|ccs
operator|+
name|strlen
argument_list|(
name|ol
argument_list|)
operator|<
name|winw
operator|-
literal|1
condition|)
block|{
name|tc_inschars
argument_list|(
name|ct
operator|=
name|p1
operator|-
name|nl
argument_list|)
expr_stmt|;
name|ccs
operator|=
operator|(
name|vcs
operator|+=
name|p1
operator|-
name|nl
operator|)
expr_stmt|;
name|cost
operator|+=
name|ct
expr_stmt|;
name|fwrite
argument_list|(
name|nl
argument_list|,
name|ct
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nl
operator|+=
name|ct
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p1
condition|)
continue|continue;
block|}
comment|/* if we can't do anything fancy, just write the new character and 	keep going. */
name|putchar
argument_list|(
operator|*
name|nl
argument_list|)
expr_stmt|;
name|cost
operator|++
expr_stmt|;
name|nl
operator|++
operator|,
name|ol
operator|++
operator|,
name|ccs
operator|=
operator|++
name|vcs
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|moveto
parameter_list|(
name|ln
parameter_list|,
name|cl
parameter_list|)
comment|/**/
name|int
name|ln
decl_stmt|;
name|int
name|cl
decl_stmt|;
block|{
comment|/* move up */
if|if
condition|(
name|ln
operator|<
name|vln
condition|)
block|{
name|tc_upcurs
argument_list|(
name|vln
operator|-
name|ln
argument_list|)
expr_stmt|;
name|vln
operator|=
name|ln
expr_stmt|;
block|}
comment|/* move down; if we might go off the end of the screen, use newlines 	instead of TCDOWN */
while|while
condition|(
name|ln
operator|>
name|vln
condition|)
if|if
condition|(
name|cl
operator|<
operator|(
name|vcs
operator|/
literal|2
operator|)
operator|||
name|ln
operator|>=
name|vmaxln
operator|||
operator|!
name|tccan
argument_list|(
name|TCLEFT
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|cost
operator|+=
literal|2
expr_stmt|;
name|vln
operator|++
expr_stmt|;
name|vcs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tc_downcurs
argument_list|(
name|ln
operator|-
name|vln
argument_list|)
expr_stmt|;
name|vln
operator|=
name|ln
expr_stmt|;
block|}
if|if
condition|(
name|cl
operator|<
operator|(
name|vcs
operator|/
literal|2
operator|)
operator|||
operator|!
name|tccan
argument_list|(
name|TCLEFT
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|cost
operator|++
expr_stmt|;
name|vcs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vcs
operator|<
name|cl
condition|)
name|tc_rightcurs
argument_list|(
name|cl
operator|-
name|vcs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vcs
operator|>
name|cl
condition|)
name|tc_leftcurs
argument_list|(
name|vcs
operator|-
name|cl
argument_list|)
expr_stmt|;
name|vcs
operator|=
name|cl
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcmultout
parameter_list|(
name|cap
parameter_list|,
name|multcap
parameter_list|,
name|ct
parameter_list|)
comment|/**/
name|int
name|cap
decl_stmt|;
name|int
name|multcap
decl_stmt|;
name|int
name|ct
decl_stmt|;
block|{
if|if
condition|(
name|tccan
argument_list|(
name|multcap
argument_list|)
operator|&&
operator|(
operator|!
name|tccan
argument_list|(
name|cap
argument_list|)
operator|||
name|tclen
index|[
name|multcap
index|]
operator|<
name|tclen
index|[
name|cap
index|]
operator|*
name|ct
operator|)
condition|)
name|tcoutarg
argument_list|(
name|multcap
argument_list|,
name|ct
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|ct
operator|--
condition|)
name|tcout
argument_list|(
name|cap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_rightcurs
parameter_list|(
name|ct
parameter_list|)
comment|/**/
name|int
name|ct
decl_stmt|;
block|{
comment|/* do a multright if it's cheaper or if we're walking over the prompt.  */
if|if
condition|(
name|tccan
argument_list|(
name|TCMULTRIGHT
argument_list|)
operator|&&
operator|(
name|ct
operator|>
name|tclen
index|[
name|TCMULTRIGHT
index|]
operator|||
name|vln
operator|==
literal|0
operator|&&
name|vcs
operator|<
name|pptlen
operator|)
condition|)
name|tcoutarg
argument_list|(
name|TCMULTRIGHT
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* if we're walking over the prompt and we can do a bunch of cursor rights, 	do them, even though they're more expensive.  (We can't redraw the 	prompt very easily in general.)  */
elseif|else
if|if
condition|(
name|vln
operator|==
literal|0
operator|&&
name|vcs
operator|<
name|pptlen
operator|&&
name|tccan
argument_list|(
name|TCRIGHT
argument_list|)
condition|)
while|while
condition|(
name|ct
operator|--
condition|)
name|tcout
argument_list|(
name|TCRIGHT
argument_list|)
expr_stmt|;
comment|/* otherwise write the contents of the video buffer. */
else|else
name|fwrite
argument_list|(
name|nbuf
index|[
name|vln
index|]
operator|+
name|vcs
argument_list|,
name|ct
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_downcurs
parameter_list|(
name|ct
parameter_list|)
comment|/**/
name|int
name|ct
decl_stmt|;
block|{
if|if
condition|(
name|tccan
argument_list|(
name|TCMULTDOWN
argument_list|)
operator|&&
operator|(
operator|!
name|tccan
argument_list|(
name|TCDOWN
argument_list|)
operator|||
name|tclen
index|[
name|TCMULTDOWN
index|]
operator|<
name|tclen
index|[
name|TCDOWN
index|]
operator|*
name|ct
operator|)
condition|)
name|tcoutarg
argument_list|(
name|TCMULTDOWN
argument_list|,
name|ct
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tccan
argument_list|(
name|TCDOWN
argument_list|)
condition|)
while|while
condition|(
name|ct
operator|--
condition|)
name|tcout
argument_list|(
name|TCDOWN
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ct
operator|--
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|vcs
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* I'm NOT going to worry about padding unless anyone complains. */
end_comment

begin_function
name|void
name|tcout
parameter_list|(
name|cap
parameter_list|)
comment|/**/
name|int
name|cap
decl_stmt|;
block|{
name|tputs
argument_list|(
name|tcstr
index|[
name|cap
index|]
argument_list|,
literal|1
argument_list|,
name|putraw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcoutarg
parameter_list|(
name|cap
parameter_list|,
name|arg
parameter_list|)
comment|/**/
name|int
name|cap
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|tcstr
index|[
name|cap
index|]
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|putraw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clearscreen
parameter_list|()
comment|/**/
block|{
name|tcout
argument_list|(
name|TCCLEARSCREEN
argument_list|)
expr_stmt|;
name|resetneeded
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|redisplay
parameter_list|()
comment|/**/
block|{
name|trashzle
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|trashzle
parameter_list|()
comment|/**/
block|{
if|if
condition|(
name|zleactive
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
name|moveto
argument_list|(
name|nlnct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|postedit
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|unsetterm
argument_list|()
expr_stmt|;
name|resetneeded
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|singlerefresh
parameter_list|()
comment|/**/
block|{
name|char
modifier|*
name|vbuf
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|qbuf
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|vsiz
decl_stmt|,
name|nvcs
decl_stmt|;
for|for
control|(
name|vsiz
operator|=
literal|1
operator|+
name|pptlen
operator|,
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|ll
condition|;
name|t0
operator|++
operator|,
name|vsiz
operator|++
control|)
if|if
condition|(
name|line
index|[
name|t0
index|]
operator|==
literal|'\t'
condition|)
name|vsiz
operator|+=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|icntrl
argument_list|(
name|line
index|[
name|t0
index|]
argument_list|)
condition|)
name|vsiz
operator|++
expr_stmt|;
name|vbuf
operator|=
name|zalloc
argument_list|(
name|vsiz
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|vbuf
argument_list|,
name|pmpt
argument_list|)
expr_stmt|;
name|vp
operator|=
name|vbuf
operator|+
name|pptlen
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|ll
condition|;
name|t0
operator|++
control|)
block|{
if|if
condition|(
name|line
index|[
name|t0
index|]
operator|==
literal|'\t'
condition|)
do|do
operator|*
name|vp
operator|++
operator|=
literal|' '
expr_stmt|;
do|while
condition|(
operator|(
name|vp
operator|-
name|vbuf
operator|)
operator|&
literal|7
condition|)
do|;
elseif|else
if|if
condition|(
name|line
index|[
name|t0
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|'n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
index|[
name|t0
index|]
operator|==
literal|0x7f
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|icntrl
argument_list|(
name|line
index|[
name|t0
index|]
argument_list|)
condition|)
block|{
operator|*
name|vp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|line
index|[
name|t0
index|]
operator||
literal|'@'
expr_stmt|;
block|}
else|else
operator|*
name|vp
operator|++
operator|=
name|line
index|[
name|t0
index|]
expr_stmt|;
if|if
condition|(
name|t0
operator|==
name|cs
condition|)
name|nvcs
operator|=
name|vp
operator|-
name|vbuf
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t0
operator|==
name|cs
condition|)
name|nvcs
operator|=
name|vp
operator|-
name|vbuf
expr_stmt|;
operator|*
name|vp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|winpos
operator|&&
name|nvcs
operator|<
name|winpos
operator|+
literal|1
operator|)
operator|||
operator|(
name|nvcs
operator|>
name|winpos
operator|+
name|winw
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|winpos
operator|=
name|nvcs
operator|-
operator|(
name|winw
operator|/
literal|2
operator|)
operator|)
operator|<
literal|0
condition|)
name|winpos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|winpos
condition|)
name|vbuf
index|[
name|winpos
index|]
operator|=
literal|'<'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|vbuf
operator|+
name|winpos
argument_list|)
operator|>
name|winw
condition|)
block|{
name|vbuf
index|[
name|winpos
operator|+
name|winw
operator|-
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
name|vbuf
index|[
name|winpos
operator|+
name|winw
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|nbuf
index|[
literal|0
index|]
argument_list|,
name|vbuf
operator|+
name|winpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vbuf
argument_list|)
expr_stmt|;
name|nvcs
operator|-=
name|winpos
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
operator|,
name|vp
operator|=
operator|*
name|nbuf
operator|,
name|op
operator|=
operator|*
name|obuf
init|;
operator|*
name|vp
condition|;
name|t0
operator|++
operator|,
name|vp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|vp
operator|!=
operator|*
name|op
operator|&&
operator|!
operator|(
operator|*
name|vp
operator|==
literal|' '
operator|&&
operator|!
operator|*
name|op
operator|)
condition|)
block|{
name|singmoveto
argument_list|(
name|t0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|vp
argument_list|)
expr_stmt|;
name|vcs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|op
condition|)
name|op
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|op
condition|)
block|{
name|singmoveto
argument_list|(
name|t0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|op
condition|;
name|op
operator|++
control|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|vcs
operator|++
expr_stmt|;
block|}
block|}
name|singmoveto
argument_list|(
name|nvcs
argument_list|)
expr_stmt|;
name|qbuf
operator|=
name|nbuf
expr_stmt|;
name|nbuf
operator|=
name|obuf
expr_stmt|;
name|obuf
operator|=
name|qbuf
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|singmoveto
parameter_list|(
name|pos
parameter_list|)
comment|/**/
name|int
name|pos
decl_stmt|;
block|{
while|while
condition|(
name|pos
operator|<
name|vcs
condition|)
block|{
name|vcs
operator|--
expr_stmt|;
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pos
operator|>
name|vcs
condition|)
block|{
name|putchar
argument_list|(
name|nbuf
index|[
literal|0
index|]
index|[
name|vcs
index|]
argument_list|)
expr_stmt|;
name|vcs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|streqct
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|==
operator|*
name|t
condition|)
name|s
operator|++
operator|,
name|t
operator|++
operator|,
name|ct
operator|++
expr_stmt|;
return|return
name|ct
return|;
block|}
end_function

end_unit

