begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * builtin.c - builtin commands  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_define
define|#
directive|define
name|makecond
parameter_list|()
value|allocnode(N_COND)
end_define

begin_comment
comment|/* builtin flags */
end_comment

begin_define
define|#
directive|define
name|BINF_PLUSOPTS
value|1
end_define

begin_comment
comment|/* +xyz legal */
end_comment

begin_define
define|#
directive|define
name|BINF_R
value|2
end_define

begin_comment
comment|/* this is r (fc -e -) */
end_comment

begin_define
define|#
directive|define
name|BINF_PRINTOPTS
value|4
end_define

begin_define
define|#
directive|define
name|BINF_SETOPTS
value|8
end_define

begin_define
define|#
directive|define
name|BINF_FCOPTS
value|16
end_define

begin_define
define|#
directive|define
name|BINF_TYPEOPT
value|32
end_define

begin_define
define|#
directive|define
name|BINF_TYPEOPTS
value|(BINF_TYPEOPT|BINF_PLUSOPTS)
end_define

begin_define
define|#
directive|define
name|BINF_ECHOPTS
value|64
end_define

begin_comment
comment|/* builtin funcs */
end_comment

begin_define
define|#
directive|define
name|BIN_TYPESET
value|0
end_define

begin_define
define|#
directive|define
name|BIN_BG
value|1
end_define

begin_define
define|#
directive|define
name|BIN_FG
value|2
end_define

begin_define
define|#
directive|define
name|BIN_JOBS
value|3
end_define

begin_define
define|#
directive|define
name|BIN_WAIT
value|4
end_define

begin_define
define|#
directive|define
name|BIN_DISOWN
value|5
end_define

begin_define
define|#
directive|define
name|BIN_BREAK
value|6
end_define

begin_define
define|#
directive|define
name|BIN_CONTINUE
value|7
end_define

begin_define
define|#
directive|define
name|BIN_EXIT
value|8
end_define

begin_define
define|#
directive|define
name|BIN_RETURN
value|9
end_define

begin_define
define|#
directive|define
name|BIN_SHIFT
value|10
end_define

begin_define
define|#
directive|define
name|BIN_CD
value|11
end_define

begin_define
define|#
directive|define
name|BIN_POPD
value|12
end_define

begin_define
define|#
directive|define
name|BIN_PUSHD
value|13
end_define

begin_define
define|#
directive|define
name|BIN_PRINT
value|14
end_define

begin_define
define|#
directive|define
name|BIN_EVAL
value|15
end_define

begin_define
define|#
directive|define
name|BIN_SCHED
value|16
end_define

begin_define
define|#
directive|define
name|BIN_FC
value|17
end_define

begin_define
define|#
directive|define
name|BIN_PUSHLINE
value|18
end_define

begin_define
define|#
directive|define
name|BIN_LOGOUT
value|19
end_define

begin_define
define|#
directive|define
name|BIN_BUILTIN
value|20
end_define

begin_define
define|#
directive|define
name|BIN_TEST
value|21
end_define

begin_define
define|#
directive|define
name|BIN_BRACKET
value|22
end_define

begin_struct
struct|struct
name|bincmd
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
argument_list|(
argument|*handlerfunc
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|int
name|minargs
decl_stmt|;
comment|/* min # of args */
name|int
name|maxargs
decl_stmt|;
comment|/* max # of args, or -1 for no limit */
name|int
name|flags
decl_stmt|;
comment|/* BINF_flags (see above) */
name|int
name|funcid
decl_stmt|;
comment|/* xbins (see above) for overloaded handlerfuncs */
name|char
modifier|*
name|optstr
decl_stmt|;
comment|/* string of legal options */
name|char
modifier|*
name|defopts
decl_stmt|;
comment|/* options set by default for overloaded handlerfuncs */
block|}
struct|;
end_struct

begin_comment
comment|/* structure for foo=bar assignments */
end_comment

begin_struct
struct|struct
name|asgment
block|{
name|struct
name|asgment
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auxdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|auxlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|showflag
init|=
literal|0
decl_stmt|,
name|showflag2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bincmd
name|builtins
index|[]
init|=
block|{
literal|"["
block|,
name|bin_test
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_BRACKET
block|,
name|NULL
block|,
name|NULL
block|,
literal|"."
block|,
name|bin_dot
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|":"
block|,
name|bin_colon
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"alias"
block|,
name|bin_alias
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"ga"
block|,
name|NULL
block|,
literal|"autoload"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"tx"
block|,
literal|"fu"
block|,
literal|"bg"
block|,
name|bin_fg
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_BG
block|,
name|NULL
block|,
name|NULL
block|,
literal|"bindkey"
block|,
name|bin_bindkey
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"asvemdrl"
block|,
name|NULL
block|,
literal|"break"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_BREAK
block|,
name|NULL
block|,
name|NULL
block|,
literal|"builtin"
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|BIN_BUILTIN
block|,
name|NULL
block|,
name|NULL
block|,
literal|"bye"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_EXIT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"cd"
block|,
name|bin_cd
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
name|BIN_CD
block|,
name|NULL
block|,
name|NULL
block|,
literal|"chdir"
block|,
name|bin_cd
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
name|BIN_CD
block|,
name|NULL
block|,
name|NULL
block|,
literal|"compctl"
block|,
name|bin_compctl
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"continue"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_CONTINUE
block|,
name|NULL
block|,
name|NULL
block|,
literal|"declare"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"LRZfilrtux"
block|,
name|NULL
block|,
literal|"dirs"
block|,
name|bin_dirs
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"v"
block|,
name|NULL
block|,
literal|"disable"
block|,
name|bin_disable
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"disown"
block|,
name|bin_fg
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_DISOWN
block|,
name|NULL
block|,
name|NULL
block|,
literal|"echo"
block|,
name|bin_print
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_PRINTOPTS
operator||
name|BINF_ECHOPTS
block|,
name|BIN_PRINT
block|,
literal|"n"
block|,
literal|"-"
block|,
literal|"echotc"
block|,
name|bin_echotc
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"enable"
block|,
name|bin_enable
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"eval"
block|,
name|bin_eval
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_EVAL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"exit"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_EXIT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"export"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"LRZfilrtu"
block|,
literal|"x"
block|,
literal|"false"
block|,
name|bin_let
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fc"
block|,
name|bin_fc
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_FCOPTS
block|,
name|BIN_FC
block|,
literal|"nlreRWAdD"
block|,
name|NULL
block|,
literal|"fg"
block|,
name|bin_fg
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_FG
block|,
name|NULL
block|,
name|NULL
block|,
literal|"functions"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"tu"
block|,
literal|"f"
block|,
literal|"getln"
block|,
name|bin_read
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|"zr"
block|,
literal|"getopts"
block|,
name|bin_getopts
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"hash"
block|,
name|bin_hash
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|"r"
block|,
name|NULL
block|,
literal|"history"
block|,
name|bin_fc
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_FC
block|,
literal|"nrdD"
block|,
literal|"l"
block|,
literal|"integer"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"LRZlrtux"
block|,
literal|"i"
block|,
literal|"jobs"
block|,
name|bin_fg
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_JOBS
block|,
literal|"lpZ"
block|,
name|NULL
block|,
literal|"kill"
block|,
name|bin_kill
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"let"
block|,
name|bin_let
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"limit"
block|,
name|bin_limit
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"sh"
block|,
name|NULL
block|,
literal|"local"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"LRZfilrtux"
block|,
name|NULL
block|,
literal|"log"
block|,
name|bin_log
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"logout"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_LOGOUT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"popd"
block|,
name|bin_cd
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
name|BIN_POPD
block|,
name|NULL
block|,
name|NULL
block|,
literal|"print"
block|,
name|bin_print
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_PRINTOPTS
block|,
name|BIN_PRINT
block|,
literal|"RDPnrslzNu0123456789p-"
block|,
name|NULL
block|,
literal|"pushd"
block|,
name|bin_cd
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
name|BIN_PUSHD
block|,
name|NULL
block|,
name|NULL
block|,
literal|"pushln"
block|,
name|bin_print
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_PRINTOPTS
block|,
name|BIN_PRINT
block|,
name|NULL
block|,
literal|"-nz"
block|,
literal|"pwd"
block|,
name|bin_pwd
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"r"
block|,
name|bin_fc
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_R
block|,
name|BIN_FC
block|,
literal|"nrl"
block|,
name|NULL
block|,
literal|"read"
block|,
name|bin_read
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"rzu0123456789p"
block|,
name|NULL
block|,
literal|"readonly"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"LRZfiltux"
block|,
literal|"r"
block|,
literal|"rehash"
block|,
name|bin_rehash
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"f"
block|,
name|NULL
block|,
literal|"return"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_RETURN
block|,
name|NULL
block|,
name|NULL
block|,
literal|"sched"
block|,
name|bin_sched
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"set"
block|,
name|bin_set
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_SETOPTS
operator||
name|BINF_PLUSOPTS
block|,
literal|0
block|,
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZaefghijklnosuvwxy"
block|,
name|NULL
block|,
literal|"setopt"
block|,
name|bin_setopt
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_PLUSOPTS
block|,
literal|0
block|,
literal|"0123456789BCDEFGHIJKLMNOPQRSTUVWXYZaefghijklmnosuvwxy"
block|,
name|NULL
block|,
literal|"shift"
block|,
name|bin_break
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|BIN_SHIFT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"source"
block|,
name|bin_dot
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"suspend"
block|,
name|bin_suspend
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"f"
block|,
name|NULL
block|,
literal|"test"
block|,
name|bin_test
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_TEST
block|,
name|NULL
block|,
name|NULL
block|,
literal|"ttyctl"
block|,
name|bin_ttyctl
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"fu"
block|,
name|NULL
block|,
literal|"times"
block|,
name|bin_times
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"trap"
block|,
name|bin_trap
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"true"
block|,
name|bin_colon
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"type"
block|,
name|bin_whence
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"pfa"
block|,
literal|"v"
block|,
literal|"typeset"
block|,
name|bin_typeset
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_TYPEOPTS
block|,
literal|0
block|,
literal|"LRZfilrtux"
block|,
name|NULL
block|,
literal|"ulimit"
block|,
name|bin_ulimit
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"HSacdfmnt"
block|,
name|NULL
block|,
literal|"umask"
block|,
name|bin_umask
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"unalias"
block|,
name|bin_unalias
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"unfunction"
block|,
name|bin_unhash
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"unhash"
block|,
name|bin_unhash
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"unlimit"
block|,
name|bin_unlimit
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"h"
block|,
name|NULL
block|,
literal|"unset"
block|,
name|bin_unset
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"unsetopt"
block|,
name|bin_setopt
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|BINF_PLUSOPTS
block|,
literal|1
block|,
literal|"0123456789BCDEFGHIJKLMNOPQRSTUWXYZabefghijklmnosuvwxy"
block|,
name|NULL
block|,
literal|"vared"
block|,
name|bin_vared
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|"wait"
block|,
name|bin_fg
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|BIN_WAIT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"whence"
block|,
name|bin_whence
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"pvcfa"
block|,
name|NULL
block|,
literal|"which"
block|,
name|bin_whence
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"pa"
block|,
literal|"c"
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print options */
end_comment

begin_function
specifier|static
name|void
name|prtopt
parameter_list|()
block|{
name|struct
name|option
modifier|*
name|opp
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|KSHOPTIONPRINT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Current option settings\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|opp
operator|=
name|optns
init|;
name|opp
operator|->
name|name
condition|;
name|opp
operator|++
control|)
name|printf
argument_list|(
literal|"%-20s%s\n"
argument_list|,
name|opp
operator|->
name|name
argument_list|,
operator|(
name|opts
index|[
name|opp
operator|->
name|id
index|]
operator|==
name|OPT_SET
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|opp
operator|=
name|optns
init|;
name|opp
operator|->
name|name
condition|;
name|opp
operator|++
control|)
if|if
condition|(
name|opts
index|[
name|opp
operator|->
name|id
index|]
operator|==
name|OPT_SET
condition|)
name|puts
argument_list|(
name|opp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add builtins to the command hash table */
end_comment

begin_function
name|void
name|addbuiltins
parameter_list|()
comment|/**/
block|{
name|struct
name|cmdnam
modifier|*
name|c
decl_stmt|;
name|struct
name|bincmd
modifier|*
name|b
decl_stmt|;
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
operator|,
name|b
operator|=
name|builtins
init|;
name|b
operator|->
name|name
condition|;
name|b
operator|++
operator|,
name|t0
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|BUILTIN
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|binnum
operator|=
name|t0
expr_stmt|;
name|addhperm
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|c
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* enable */
end_comment

begin_function
name|int
name|bin_enable
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|whocares
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|whocares
decl_stmt|;
block|{
name|struct
name|cmdnam
modifier|*
name|c
decl_stmt|;
name|struct
name|bincmd
modifier|*
name|b
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
operator|,
name|b
operator|=
name|builtins
init|;
name|b
operator|->
name|name
condition|;
name|b
operator|++
operator|,
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|b
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|b
operator|->
name|name
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no such builtin: %s"
argument_list|,
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|BUILTIN
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|binnum
operator|=
name|t0
expr_stmt|;
name|addhperm
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|c
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* :, true */
end_comment

begin_function
name|int
name|bin_colon
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|whocares
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|whocares
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* break, bye, continue, exit, logout, return, shift */
end_comment

begin_function
name|int
name|bin_break
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|num
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|argv
condition|)
name|num
operator|=
name|matheval
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|func
operator|==
name|BIN_BREAK
operator|||
name|func
operator|==
name|BIN_CONTINUE
operator|)
operator|&&
operator|!
name|loops
condition|)
block|{
if|if
condition|(
name|func
operator|==
name|BIN_CONTINUE
condition|)
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"not in loop"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|BIN_CONTINUE
case|:
name|contflag
operator|=
literal|1
expr_stmt|;
case|case
name|BIN_BREAK
case|:
name|breaks
operator|=
operator|(
name|num
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
name|num
expr_stmt|;
if|if
condition|(
name|breaks
operator|>
name|loops
condition|)
name|breaks
operator|=
name|loops
expr_stmt|;
break|break;
case|case
name|BIN_LOGOUT
case|:
if|if
condition|(
operator|!
name|islogin
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"not login shell"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|BIN_EXIT
case|:
name|zexit
argument_list|(
operator|(
name|num
operator|==
operator|-
literal|1
operator|)
condition|?
name|lastval
else|:
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIN_RETURN
case|:
name|retflag
operator|=
literal|1
expr_stmt|;
return|return
name|lastval
operator|=
operator|(
name|num
operator|==
operator|-
literal|1
operator|)
condition|?
name|lastval
else|:
name|num
return|;
case|case
name|BIN_SHIFT
case|:
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|num
operator|==
operator|-
literal|1
condition|)
name|num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|arrlen
argument_list|(
name|pparams
argument_list|)
condition|)
name|num
operator|=
name|arrlen
argument_list|(
name|pparams
argument_list|)
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|s
operator|=
name|arrdup
argument_list|(
name|pparams
operator|+
name|num
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
name|freearray
argument_list|(
name|pparams
argument_list|)
expr_stmt|;
name|pparams
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* bg, disown, fg, jobs, wait */
end_comment

begin_function
name|int
name|bin_fg
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|job
decl_stmt|,
name|lng
decl_stmt|,
name|firstjob
init|=
operator|-
literal|1
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ops
index|[
literal|'Z'
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|argv
condition|)
name|strcpy
argument_list|(
name|hackzero
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lng
operator|=
operator|(
name|ops
index|[
literal|'l'
index|]
operator|)
condition|?
literal|1
else|:
operator|(
name|ops
index|[
literal|'p'
index|]
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|func
operator|==
name|BIN_FG
operator|||
name|func
operator|==
name|BIN_BG
operator|)
operator|&&
operator|!
name|jobbing
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no job control in this shell."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|unset
argument_list|(
name|NOTIFY
argument_list|)
condition|)
name|scanjobs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jobtab
index|[
name|curjob
index|]
operator|.
name|stat
operator|&
name|STAT_INUSE
operator|)
condition|)
block|{
name|curjob
operator|=
name|prevjob
expr_stmt|;
name|setprevjob
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jobtab
index|[
name|curjob
index|]
operator|.
name|stat
operator|&
name|STAT_INUSE
operator|)
condition|)
name|curjob
operator|=
name|prevjob
expr_stmt|;
name|setprevjob
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|BIN_JOBS
condition|)
name|stopmsg
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
if|if
condition|(
name|func
operator|==
name|BIN_FG
operator|||
name|func
operator|==
name|BIN_BG
condition|)
block|{
if|if
condition|(
name|curjob
operator|==
operator|-
literal|1
operator|||
name|curjob
operator|==
name|thisjob
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no current job"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|firstjob
operator|=
name|curjob
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func
operator|==
name|BIN_JOBS
condition|)
block|{
for|for
control|(
name|job
operator|=
literal|0
init|;
name|job
operator|!=
name|MAXJOB
condition|;
name|job
operator|++
control|)
if|if
condition|(
name|job
operator|!=
name|thisjob
operator|&&
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
condition|)
name|printjob
argument_list|(
name|job
operator|+
name|jobtab
argument_list|,
name|lng
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|job
operator|=
literal|0
init|;
name|job
operator|!=
name|MAXJOB
condition|;
name|job
operator|++
control|)
if|if
condition|(
name|job
operator|!=
name|thisjob
operator|&&
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
condition|)
name|waitjob
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|lastval
return|;
block|}
for|for
control|(
init|;
operator|(
name|firstjob
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|*
name|argv
condition|;
call|(
name|void
call|)
argument_list|(
operator|*
name|argv
operator|&&
name|argv
operator|++
argument_list|)
control|)
block|{
name|int
name|stopped
decl_stmt|,
name|ocj
init|=
name|thisjob
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|BIN_WAIT
operator|&&
name|isanum
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
name|waitforpid
argument_list|(
operator|(
name|long
operator|)
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lastval
expr_stmt|;
name|thisjob
operator|=
name|ocj
expr_stmt|;
continue|continue;
block|}
name|job
operator|=
operator|(
operator|*
name|argv
operator|)
condition|?
name|getjob
argument_list|(
operator|*
name|argv
argument_list|,
name|name
argument_list|)
else|:
name|firstjob
expr_stmt|;
name|firstjob
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|job
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
operator|&
name|STAT_INUSE
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no such job: %d"
argument_list|,
literal|0
argument_list|,
name|job
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|BIN_FG
case|:
case|case
name|BIN_BG
case|:
if|if
condition|(
name|stopped
operator|=
operator|(
name|jobtab
index|[
name|job
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
operator|)
condition|)
name|makerunning
argument_list|(
name|jobtab
operator|+
name|job
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|func
operator|==
name|BIN_BG
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"job already in background"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisjob
operator|=
name|ocj
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|curjob
operator|==
name|job
condition|)
block|{
name|curjob
operator|=
name|prevjob
expr_stmt|;
name|prevjob
operator|=
operator|(
name|func
operator|==
name|BIN_BG
operator|)
condition|?
operator|-
literal|1
else|:
name|job
expr_stmt|;
block|}
if|if
condition|(
name|prevjob
operator|==
name|job
condition|)
name|prevjob
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prevjob
operator|==
operator|-
literal|1
condition|)
name|setprevjob
argument_list|()
expr_stmt|;
if|if
condition|(
name|curjob
operator|==
operator|-
literal|1
condition|)
block|{
name|curjob
operator|=
name|prevjob
expr_stmt|;
name|setprevjob
argument_list|()
expr_stmt|;
block|}
name|printjob
argument_list|(
name|jobtab
operator|+
name|job
argument_list|,
operator|(
name|stopped
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|BIN_FG
condition|)
block|{
name|thisjob
operator|=
name|job
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|jobtab
index|[
name|job
index|]
operator|.
name|pwd
argument_list|,
name|pwd
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"(pwd : "
argument_list|)
expr_stmt|;
name|printdir
argument_list|(
name|jobtab
index|[
name|job
index|]
operator|.
name|pwd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|attachtty
argument_list|(
name|jobtab
index|[
name|job
index|]
operator|.
name|gleader
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stopped
condition|)
name|killpg
argument_list|(
name|jobtab
index|[
name|job
index|]
operator|.
name|gleader
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|BIN_FG
condition|)
name|waitjobs
argument_list|()
expr_stmt|;
break|break;
case|case
name|BIN_JOBS
case|:
name|printjob
argument_list|(
name|job
operator|+
name|jobtab
argument_list|,
name|lng
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIN_WAIT
case|:
name|waitjob
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lastval
expr_stmt|;
break|break;
case|case
name|BIN_DISOWN
case|:
block|{
specifier|static
name|struct
name|job
name|zero
decl_stmt|;
name|jobtab
index|[
name|job
index|]
operator|=
name|zero
expr_stmt|;
break|break;
block|}
block|}
name|thisjob
operator|=
name|ocj
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* false, let */
end_comment

begin_function
name|int
name|bin_let
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|long
name|val
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
name|val
operator|=
name|matheval
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
return|return
operator|!
name|val
return|;
block|}
end_function

begin_comment
comment|/* print the directory stack */
end_comment

begin_function
specifier|static
name|void
name|pdstack
parameter_list|()
block|{
name|Lknode
name|node
decl_stmt|;
name|printdir
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|dirstack
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
control|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printdir
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exit the shell */
end_comment

begin_function
name|int
name|zexit
parameter_list|(
name|val
parameter_list|)
comment|/**/
name|int
name|val
decl_stmt|;
block|{
if|if
condition|(
name|isset
argument_list|(
name|MONITOR
argument_list|)
condition|)
if|if
condition|(
operator|!
name|stopmsg
condition|)
block|{
name|checkjobs
argument_list|()
expr_stmt|;
if|if
condition|(
name|stopmsg
condition|)
block|{
name|stopmsg
operator|=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
name|killrunjobs
argument_list|()
expr_stmt|;
name|savehistfile
argument_list|(
name|getsparam
argument_list|(
literal|"HISTFILE"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|islogin
operator|&&
name|unset
argument_list|(
name|NORCS
argument_list|)
condition|)
name|sourcehome
argument_list|(
literal|".zlogout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtrapped
index|[
name|SIGEXIT
index|]
condition|)
name|dotrap
argument_list|(
name|SIGEXIT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* identify an option name */
end_comment

begin_function
name|int
name|optlookup
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|struct
name|option
modifier|*
name|o
decl_stmt|;
name|t
operator|=
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
if|if
condition|(
operator|*
name|t
operator|==
literal|'_'
condition|)
name|chuck
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|t
operator|=
name|tulower
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
for|for
control|(
name|o
operator|=
name|optns
init|;
name|o
operator|->
name|name
condition|;
name|o
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|o
operator|->
name|id
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* setopt, unsetopt */
end_comment

begin_function
name|int
name|bin_setopt
parameter_list|(
name|nam
parameter_list|,
name|args
parameter_list|,
name|ops
parameter_list|,
name|isun
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|isun
decl_stmt|;
block|{
name|struct
name|option
modifier|*
name|opp
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|ops
index|[
literal|'@'
index|]
operator|&&
operator|!
operator|*
name|args
condition|)
block|{
if|if
condition|(
operator|!
name|isun
condition|)
name|prtopt
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opp
operator|=
name|optns
init|;
name|opp
operator|->
name|name
condition|;
name|opp
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|opp
operator|->
name|id
index|]
operator|==
literal|1
operator|+
name|isun
condition|)
name|opts
index|[
name|opp
operator|->
name|id
index|]
operator|=
name|OPT_SET
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
name|opp
operator|->
name|id
index|]
operator|==
literal|2
operator|-
name|isun
condition|)
name|opts
index|[
name|opp
operator|->
name|id
index|]
operator|=
name|OPT_UNSET
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|c
operator|=
name|optlookup
argument_list|(
operator|*
name|args
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|INTERACTIVE
operator|||
name|c
operator|==
name|MONITOR
condition|)
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"can't change that option"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|opts
index|[
name|c
index|]
operator|=
operator|(
name|isun
operator|)
condition|?
name|OPT_UNSET
else|:
name|OPT_SET
expr_stmt|;
block|}
else|else
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"no such option: %s"
argument_list|,
name|args
index|[
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* execute func on each member of the hash table ht */
end_comment

begin_function
name|void
name|listhtable
parameter_list|(
name|ht
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|Hashtab
name|ht
decl_stmt|;
name|HFunc
name|func
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
name|struct
name|hashnode
modifier|*
name|hn
decl_stmt|;
for|for
control|(
name|t0
operator|=
name|ht
operator|->
name|hsize
operator|-
literal|1
init|;
name|t0
operator|>=
literal|0
condition|;
name|t0
operator|--
control|)
for|for
control|(
name|hn
operator|=
name|ht
operator|->
name|nodes
index|[
name|t0
index|]
init|;
name|hn
condition|;
name|hn
operator|=
name|hn
operator|->
name|next
control|)
name|func
argument_list|(
name|hn
operator|->
name|nam
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print a shell function (used with listhtable) */
end_comment

begin_function
name|void
name|pshfunc
parameter_list|(
name|s
parameter_list|,
name|cc
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|Cmdnam
name|cc
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|cc
operator|->
name|type
operator|!=
name|SHFUNC
condition|)
return|return;
if|if
condition|(
name|showflag
operator|&&
operator|(
name|cc
operator|->
name|flags
operator|&
name|showflag2
operator|)
operator|!=
name|showflag2
condition|)
return|return;
if|if
condition|(
name|cc
operator|->
name|flags
operator|&
name|PMFLAG_u
condition|)
name|printf
argument_list|(
literal|"undefined "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|flags
operator|&
name|PMFLAG_t
condition|)
name|printf
argument_list|(
literal|"traced "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cc
operator|->
name|u
operator|.
name|list
operator|||
operator|!
name|showflag
condition|)
block|{
name|printf
argument_list|(
literal|"%s ()\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|getpermtext
argument_list|(
call|(
name|vptr
call|)
argument_list|(
name|cc
operator|->
name|u
operator|.
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s () {\n\t%s\n}\n"
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|niceprint
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|niceprintf
argument_list|(
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|niceprintf
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|fputc
argument_list|(
operator|*
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|s
operator||
literal|0x40
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|bin_umask
parameter_list|(
name|nam
parameter_list|,
name|args
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|um
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|*
name|args
decl_stmt|;
name|um
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|printf
argument_list|(
literal|"%03o\n"
argument_list|,
name|um
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|um
operator|=
name|zstrtol
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"bad umask"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
name|int
name|whomask
decl_stmt|,
name|op
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'u'
condition|)
name|s
operator|++
operator|,
name|whomask
operator|=
literal|0100
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'g'
condition|)
name|s
operator|++
operator|,
name|whomask
operator|=
literal|0010
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'o'
condition|)
name|s
operator|++
operator|,
name|whomask
operator|=
literal|0001
expr_stmt|;
else|else
name|whomask
operator|=
literal|0111
expr_stmt|;
name|op
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|==
literal|'+'
operator|||
name|op
operator|==
literal|'-'
operator|||
name|op
operator|==
literal|'='
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"bad symbolic mode operator: %c"
argument_list|,
name|NULL
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|mask
operator|=
name|whomask
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'r'
condition|)
name|mask
operator|*=
literal|04
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'w'
condition|)
name|mask
operator|*=
literal|02
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|'x'
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"bad symbolic mode permission: %c"
argument_list|,
name|NULL
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|op
operator|==
literal|'+'
condition|)
name|um
operator||=
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|'-'
condition|)
name|um
operator|&=
operator|~
name|mask
expr_stmt|;
else|else
comment|/* op == '=' */
name|um
operator|=
operator|(
name|um
operator|&
operator|~
operator|(
name|whomask
operator|*
literal|07
operator|)
operator|)
operator||
name|mask
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"bad character in symbolic mode: %c"
argument_list|,
name|NULL
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* type, whence, which */
end_comment

begin_function
name|int
name|bin_whence
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|struct
name|cmdnam
modifier|*
name|chn
decl_stmt|;
name|struct
name|alias
modifier|*
name|a
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|csh
init|=
name|ops
index|[
literal|'c'
index|]
decl_stmt|,
name|all
init|=
name|ops
index|[
literal|'a'
index|]
decl_stmt|;
name|int
name|v
init|=
name|ops
index|[
literal|'v'
index|]
operator|||
name|csh
decl_stmt|;
name|char
modifier|*
name|cnam
decl_stmt|;
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ops
index|[
literal|'p'
index|]
operator|&&
operator|(
name|a
operator|=
operator|(
name|Alias
operator|)
name|gethnode
argument_list|(
operator|*
name|argv
argument_list|,
name|aliastab
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|cmd
operator|<
literal|0
condition|)
name|printf
argument_list|(
operator|(
name|csh
operator|)
condition|?
literal|"%s: shell reserved word\n"
else|:
operator|(
name|v
operator|)
condition|?
literal|"%s is a reserved word\n"
else|:
literal|"%s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|v
condition|)
name|puts
argument_list|(
name|a
operator|->
name|text
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|cmd
condition|)
name|printf
argument_list|(
operator|(
name|csh
operator|)
condition|?
literal|"%s: aliased to %s\n"
else|:
literal|"%s is an alias for %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|a
operator|->
name|text
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
operator|(
name|csh
operator|)
condition|?
literal|"%s: globally aliased to %s\n"
else|:
literal|"%s is a global alias for %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|a
operator|->
name|text
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|all
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|ops
index|[
literal|'p'
index|]
operator|&&
operator|(
name|chn
operator|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
operator|*
name|argv
argument_list|,
name|cmdnamtab
argument_list|)
operator|)
operator|&&
operator|(
name|chn
operator|->
name|type
operator|==
name|SHFUNC
operator|||
name|chn
operator|->
name|type
operator|==
name|BUILTIN
operator|)
condition|)
block|{
if|if
condition|(
name|chn
operator|->
name|type
operator|==
name|SHFUNC
condition|)
block|{
if|if
condition|(
name|csh
operator|||
name|ops
index|[
literal|'f'
index|]
condition|)
block|{
name|showflag
operator|=
literal|1
expr_stmt|;
name|showflag2
operator|=
literal|0
expr_stmt|;
name|pshfunc
argument_list|(
operator|*
name|argv
argument_list|,
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
operator|(
name|v
operator|)
condition|?
literal|"%s is a function\n"
else|:
literal|"%s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
operator|(
name|csh
operator|)
condition|?
literal|"%s: shell built-in command\n"
else|:
operator|(
name|v
operator|)
condition|?
literal|"%s is a shell builtin\n"
else|:
literal|"%s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|all
condition|)
continue|continue;
block|}
if|if
condition|(
name|all
condition|)
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|,
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
modifier|*
name|z
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|path
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
name|z
operator|=
name|buf
expr_stmt|;
name|strucpy
argument_list|(
operator|&
name|z
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|z
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscom
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|v
operator|&&
operator|!
name|csh
condition|)
name|printf
argument_list|(
literal|"%s is %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|cnam
operator|=
name|findcmd
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"%s not found\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|v
operator|&&
operator|!
name|csh
condition|)
name|printf
argument_list|(
literal|"%s is %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|cnam
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
name|cnam
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* cd, chdir, pushd, popd */
end_comment

begin_function
name|int
name|bin_cd
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|BIN_CD
operator|&&
name|isset
argument_list|(
name|AUTOPUSHD
argument_list|)
condition|)
name|func
operator|=
name|BIN_PUSHD
expr_stmt|;
name|dest
operator|=
name|cd_get_dest
argument_list|(
name|nam
argument_list|,
name|argv
argument_list|,
name|ops
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
return|return
literal|1
return|;
name|dest
operator|=
name|cd_do_chdir
argument_list|(
name|nam
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
condition|)
return|return
literal|1
return|;
name|cd_new_pwd
argument_list|(
name|func
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cd_get_dest
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
operator|!
name|argv
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|func
operator|==
name|BIN_CD
operator|||
operator|(
name|func
operator|==
name|BIN_PUSHD
operator|&&
name|isset
argument_list|(
name|PUSHDTOHOME
argument_list|)
operator|||
operator|!
name|full
argument_list|(
name|dirstack
argument_list|)
operator|)
condition|)
name|dest
operator|=
name|home
expr_stmt|;
else|else
name|dest
operator|=
name|getnode
argument_list|(
name|dirstack
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|Lknode
name|n
decl_stmt|;
name|int
name|dd
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
operator|(
name|isset
argument_list|(
name|PUSHDMINUS
argument_list|)
condition|?
literal|'-'
else|:
literal|'+'
operator|)
condition|)
block|{
name|dd
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dd
operator|<
literal|0
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"bad directory specification"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|dirstack
argument_list|)
init|;
name|n
operator|&&
name|dd
condition|;
name|dd
operator|--
operator|,
name|incnode
argument_list|(
name|n
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"no such entry in dir stack"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dest
operator|=
name|remnode
argument_list|(
name|dirstack
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
operator|(
name|isset
argument_list|(
name|PUSHDMINUS
argument_list|)
condition|?
literal|'+'
else|:
literal|'-'
operator|)
condition|)
block|{
name|dd
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|lastnode
argument_list|(
name|dirstack
argument_list|)
init|;
name|n
operator|!=
operator|(
name|Lknode
operator|)
name|dirstack
operator|&&
name|dd
condition|;
name|dd
operator|--
operator|,
name|n
operator|=
name|prevnode
argument_list|(
name|n
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|n
operator|==
operator|(
name|Lknode
operator|)
name|dirstack
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"no such entry in dir stack"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dest
operator|=
name|remnode
argument_list|(
name|dirstack
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|printdircr
argument_list|(
name|dest
operator|=
name|oldpwd
argument_list|)
expr_stmt|;
else|else
name|dest
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|u
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|len3
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|u
operator|=
name|ztrstr
argument_list|(
name|pwd
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"string not in pwd: %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len1
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|len3
operator|=
name|u
operator|-
name|pwd
expr_stmt|;
name|dest
operator|=
name|alloc
argument_list|(
name|len3
operator|+
name|len2
operator|+
name|strlen
argument_list|(
name|u
operator|+
name|len1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dest
argument_list|,
name|pwd
argument_list|,
name|len3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dest
operator|+
name|len3
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dest
argument_list|,
name|u
operator|+
name|len1
argument_list|)
expr_stmt|;
name|printdircr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cd_do_chdir
parameter_list|(
name|cnam
parameter_list|,
name|dest
parameter_list|)
comment|/**/
name|char
modifier|*
name|cnam
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
block|{
name|int
name|hasdot
init|=
literal|0
decl_stmt|,
name|eno
init|=
name|ENOENT
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|*
name|dest
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|ret
operator|=
name|cd_try_chdir
argument_list|(
name|NULL
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|ret
return|;
name|zerrnam
argument_list|(
name|cnam
argument_list|,
literal|"%e: %s"
argument_list|,
name|dest
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|pp
operator|=
name|cdpath
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|hasdot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hasdot
condition|)
block|{
if|if
condition|(
name|ret
operator|=
name|cd_try_chdir
argument_list|(
name|NULL
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|errno
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
name|cdpath
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|ret
operator|=
name|cd_try_chdir
argument_list|(
operator|*
name|pp
argument_list|,
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|pp
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|printdircr
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|errno
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|CDABLEVARS
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|getsparam
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|&&
operator|*
name|s
operator|==
literal|'/'
operator|&&
name|chdir
argument_list|(
name|s
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|printdircr
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|errno
expr_stmt|;
block|}
name|zerrnam
argument_list|(
name|cnam
argument_list|,
literal|"%e: %s"
argument_list|,
name|dest
argument_list|,
name|eno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cd_try_chdir
parameter_list|(
name|pfix
parameter_list|,
name|dest
parameter_list|)
comment|/**/
name|char
modifier|*
name|pfix
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|buf2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|dotsct
decl_stmt|;
if|if
condition|(
name|pfix
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|(
operator|!
name|strcmp
argument_list|(
literal|"/"
argument_list|,
name|pfix
argument_list|)
operator|)
condition|?
literal|""
else|:
name|pfix
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dotsct
operator|=
name|fixdir
argument_list|(
name|buf2
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|chdir
argument_list|(
name|buf2
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|?
name|NULL
else|:
name|buf2
return|;
if|if
condition|(
operator|!
name|dotsct
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
operator|(
operator|*
name|buf2
operator|)
condition|?
name|buf2
else|:
literal|"."
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|buf2
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|(
operator|!
name|strcmp
argument_list|(
literal|"/"
argument_list|,
name|pwd
argument_list|)
operator|)
condition|?
literal|""
else|:
name|pwd
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|dotsct
operator|--
condition|)
while|while
condition|(
name|s
operator|!=
name|buf
condition|)
if|if
condition|(
operator|*
operator|--
name|s
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|buf
operator|||
operator|*
name|buf2
condition|)
name|s
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|buf
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|chdir
argument_list|(
name|dest
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|buf
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|fixdir
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|d0
init|=
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_RFS
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
while|while
condition|(
name|d
operator|>
name|d0
operator|+
literal|1
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|d
operator|--
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ct
return|;
block|}
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|>
name|d0
operator|+
literal|1
condition|)
block|{
for|for
control|(
name|d
operator|--
init|;
name|d
operator|>
name|d0
operator|+
literal|1
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|;
name|d
operator|--
control|)
empty_stmt|;
block|}
else|else
name|ct
operator|++
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cd_new_pwd
parameter_list|(
name|func
parameter_list|,
name|s
parameter_list|)
comment|/**/
name|int
name|func
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|Param
name|pm
decl_stmt|;
name|List
name|l
decl_stmt|;
name|oldpwd
operator|=
name|pwd
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|CHASELINKS
argument_list|)
condition|)
name|pwd
operator|=
name|findpwd
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|pwd
operator|=
name|ztrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|gethnode
argument_list|(
literal|"PWD"
argument_list|,
name|paramtab
argument_list|)
operator|)
operator|&&
operator|(
name|pm
operator|->
name|flags
operator|&
name|PMFLAG_x
operator|)
operator|&&
name|pm
operator|->
name|env
condition|)
name|pm
operator|->
name|env
operator|=
name|replenv
argument_list|(
name|pm
operator|->
name|env
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|=
name|gethnode
argument_list|(
literal|"OLDPWD"
argument_list|,
name|paramtab
argument_list|)
operator|)
operator|&&
operator|(
name|pm
operator|->
name|flags
operator|&
name|PMFLAG_x
operator|)
operator|&&
name|pm
operator|->
name|env
condition|)
name|pm
operator|->
name|env
operator|=
name|replenv
argument_list|(
name|pm
operator|->
name|env
argument_list|,
name|oldpwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|BIN_PUSHD
condition|)
block|{
name|permalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|PUSHDIGNOREDUPS
argument_list|)
condition|)
block|{
name|Lknode
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|dirstack
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oldpwd
argument_list|,
name|getdata
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|remnode
argument_list|(
name|dirstack
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|pushnode
argument_list|(
name|dirstack
argument_list|,
name|oldpwd
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|unset
argument_list|(
name|PUSHDSILENT
argument_list|)
operator|&&
name|func
operator|!=
name|BIN_CD
operator|&&
name|isset
argument_list|(
name|INTERACTIVE
argument_list|)
condition|)
name|pdstack
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
operator|=
name|getshfunc
argument_list|(
literal|"chpwd"
argument_list|)
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|doshfuncnoval
argument_list|(
name|dupstruct
argument_list|(
name|l
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirstacksize
operator|!=
operator|-
literal|1
operator|&&
name|countnodes
argument_list|(
name|dirstack
argument_list|)
operator|>=
name|dirstacksize
condition|)
block|{
if|if
condition|(
name|dirstacksize
operator|<
literal|2
condition|)
name|dirstacksize
operator|=
literal|2
expr_stmt|;
else|else
name|free
argument_list|(
name|remnode
argument_list|(
name|dirstack
argument_list|,
name|lastnode
argument_list|(
name|dirstack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|convertwd
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|off
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|char
modifier|*
name|u
decl_stmt|,
modifier|*
name|start
decl_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'/'
expr_stmt|;
name|start
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|off
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
name|s
operator|++
expr_stmt|;
for|for
control|(
name|u
operator|=
name|s
init|;
operator|*
name|u
operator|&&
operator|*
name|u
operator|!=
literal|'/'
condition|;
name|u
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"."
argument_list|,
name|u
operator|-
name|s
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|".."
argument_list|,
name|u
operator|-
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
name|t
operator|!=
name|start
operator|&&
operator|*
operator|--
name|t
operator|!=
literal|'/'
condition|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|!=
name|start
condition|)
operator|*
name|t
operator|++
operator|=
literal|'/'
expr_stmt|;
name|struncpy
argument_list|(
operator|&
name|t
argument_list|,
name|s
argument_list|,
name|u
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|u
condition|)
break|break;
name|s
operator|=
name|u
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bin_rehash
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|newcmdnamtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'f'
index|]
condition|)
name|fullhash
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_hash
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|struct
name|cmdnam
modifier|*
name|chn
decl_stmt|;
name|chn
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|chn
argument_list|)
expr_stmt|;
name|chn
operator|->
name|type
operator|=
name|EXCMD
expr_stmt|;
name|chn
operator|->
name|pcomp
operator|=
name|NULL
expr_stmt|;
comment|/* this is probably a bug ! */
name|chn
operator|->
name|u
operator|.
name|nam
operator|=
name|ztrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|chn
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* != 0 if s is a prefix of t */
end_comment

begin_function
name|int
name|prefix
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|t
operator|&&
operator|*
name|s
operator|==
operator|*
name|t
condition|)
name|s
operator|++
operator|,
name|t
operator|++
expr_stmt|;
return|return
operator|(
operator|!
operator|*
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert %%, %1, %foo, %?bar? to a job number */
end_comment

begin_function
name|int
name|getjob
parameter_list|(
name|s
parameter_list|,
name|prog
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|,
name|retval
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'%'
condition|)
goto|goto
name|jump
goto|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|!
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|curjob
operator|==
operator|-
literal|1
condition|)
block|{
name|zerrnam
argument_list|(
name|prog
argument_list|,
literal|"no current job"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|retval
operator|=
name|curjob
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|prevjob
operator|==
operator|-
literal|1
condition|)
block|{
name|zerrnam
argument_list|(
name|prog
argument_list|,
literal|"no previous job"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|retval
operator|=
name|prevjob
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|t0
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t0
operator|&&
name|t0
operator|<
name|MAXJOB
operator|&&
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&&
name|t0
operator|!=
name|thisjob
condition|)
block|{
name|retval
operator|=
name|t0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|zerrnam
argument_list|(
name|prog
argument_list|,
literal|"no such job"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'?'
condition|)
block|{
name|struct
name|process
modifier|*
name|pn
decl_stmt|;
for|for
control|(
name|t0
operator|=
name|MAXJOB
operator|-
literal|1
init|;
name|t0
operator|>=
literal|0
condition|;
name|t0
operator|--
control|)
if|if
condition|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&&
name|t0
operator|!=
name|thisjob
condition|)
for|for
control|(
name|pn
operator|=
name|jobtab
index|[
name|t0
index|]
operator|.
name|procs
init|;
name|pn
condition|;
name|pn
operator|=
name|pn
operator|->
name|next
control|)
if|if
condition|(
name|ztrstr
argument_list|(
name|pn
operator|->
name|text
argument_list|,
name|s
operator|+
literal|1
argument_list|)
condition|)
block|{
name|retval
operator|=
name|t0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|zerrnam
argument_list|(
name|prog
argument_list|,
literal|"job not found: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|jump
label|:
if|if
condition|(
operator|(
name|t0
operator|=
name|findjobnam
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|retval
operator|=
name|t0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|zerrnam
argument_list|(
name|prog
argument_list|,
literal|"job not found: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
name|done
label|:
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* find a job named s */
end_comment

begin_function
name|int
name|findjobnam
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
name|MAXJOB
operator|-
literal|1
init|;
name|t0
operator|>=
literal|0
condition|;
name|t0
operator|--
control|)
if|if
condition|(
name|jobtab
index|[
name|t0
index|]
operator|.
name|stat
operator|&&
name|jobtab
index|[
name|t0
index|]
operator|.
name|procs
operator|&&
name|t0
operator|!=
name|thisjob
operator|&&
name|jobtab
index|[
name|t0
index|]
operator|.
name|procs
operator|->
name|text
operator|&&
name|prefix
argument_list|(
name|s
argument_list|,
name|jobtab
index|[
name|t0
index|]
operator|.
name|procs
operator|->
name|text
argument_list|)
condition|)
return|return
name|t0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|isanum
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|||
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'\0'
return|;
block|}
end_function

begin_function
name|int
name|bin_kill
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|sig
init|=
name|SIGTERM
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|argv
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|idigit
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
name|sig
operator|=
name|atoi
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sigs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|sig
operator|=
literal|2
init|;
name|sig
operator|!=
name|SIGCOUNT
condition|;
name|sig
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|sigs
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|sig
operator|=
literal|0
init|;
name|sig
operator|!=
name|SIGCOUNT
condition|;
name|sig
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sigs
index|[
name|sig
index|]
argument_list|,
operator|*
name|argv
operator|+
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sig
operator|==
name|SIGCOUNT
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"unknown signal: SIG%s"
argument_list|,
operator|*
name|argv
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"type kill -l for a List of signals"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|argv
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'%'
condition|)
block|{
name|int
name|p
init|=
name|getjob
argument_list|(
operator|*
name|argv
argument_list|,
literal|"kill"
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|-
literal|1
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|killjb
argument_list|(
name|jobtab
operator|+
name|p
argument_list|,
name|sig
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|zerrnam
argument_list|(
literal|"kill"
argument_list|,
literal|"kill failed: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|jobtab
index|[
name|p
index|]
operator|.
name|stat
operator|&
name|STAT_STOPPED
condition|)
block|{
if|if
condition|(
name|sig
operator|==
name|SIGCONT
condition|)
name|jobtab
index|[
name|p
index|]
operator|.
name|stat
operator|&=
operator|~
name|STAT_STOPPED
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGKILL
operator|&&
name|sig
operator|!=
name|SIGCONT
operator|&&
name|sig
operator|!=
name|SIGTSTP
operator|&&
name|sig
operator|!=
name|SIGTTOU
operator|&&
name|sig
operator|!=
name|SIGTTIN
operator|&&
name|sig
operator|!=
name|SIGSTOP
condition|)
name|killjb
argument_list|(
name|jobtab
operator|+
name|p
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isanum
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
name|zerrnam
argument_list|(
literal|"kill"
argument_list|,
literal|"illegal pid: %s"
argument_list|,
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|,
name|sig
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|zerrnam
argument_list|(
literal|"kill"
argument_list|,
literal|"kill failed: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|recs
index|[]
init|=
block|{
literal|"cputime"
block|,
literal|"filesize"
block|,
literal|"datasize"
block|,
literal|"stacksize"
block|,
literal|"coredumpsize"
block|,
literal|"resident"
block|,
literal|"descriptors"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|bin_limit
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|RLIM_INFINITY
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"not available on this system"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|hard
init|=
name|ops
index|[
literal|'h'
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|lim
decl_stmt|;
name|long
name|val
decl_stmt|;
if|if
condition|(
name|ops
index|[
literal|'s'
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|argv
condition|)
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"arguments after -s ignored"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|setrlimit
argument_list|(
name|t0
argument_list|,
name|limits
operator|+
name|t0
argument_list|)
operator|<
literal|0
condition|)
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"setrlimit failed: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|showlimits
argument_list|(
name|hard
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|s
operator|=
operator|*
name|argv
operator|++
condition|)
block|{
for|for
control|(
name|lim
operator|=
operator|-
literal|1
operator|,
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|recs
index|[
name|t0
index|]
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|lim
operator|!=
operator|-
literal|1
condition|)
name|lim
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|lim
operator|=
name|t0
expr_stmt|;
block|}
if|if
condition|(
name|lim
operator|<
literal|0
condition|)
block|{
name|zerrnam
argument_list|(
literal|"limit"
argument_list|,
operator|(
name|lim
operator|==
operator|-
literal|2
operator|)
condition|?
literal|"ambiguous resource specification: %s"
else|:
literal|"no such resource: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|*
name|argv
operator|++
operator|)
condition|)
block|{
name|showlimits
argument_list|(
name|hard
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|lim
condition|)
block|{
name|val
operator|=
name|zstrtol
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'h'
operator|||
operator|*
name|s
operator|==
literal|'H'
operator|)
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
name|val
operator|*=
literal|3600L
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'m'
operator|||
operator|*
name|s
operator|==
literal|'M'
operator|)
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
name|val
operator|*=
literal|60L
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
name|val
operator|=
name|val
operator|*
literal|60
operator|+
name|zstrtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
block|{
name|zerrnam
argument_list|(
literal|"limit"
argument_list|,
literal|"unknown scaling factor: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
elseif|else
if|if
condition|(
name|lim
operator|==
name|RLIMIT_NOFILE
condition|)
name|val
operator|=
name|zstrtol
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|val
operator|=
name|zstrtol
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
operator|||
operator|(
operator|(
operator|*
name|s
operator|==
literal|'k'
operator|||
operator|*
name|s
operator|==
literal|'K'
operator|)
operator|&&
operator|!
name|s
index|[
literal|1
index|]
operator|)
condition|)
name|val
operator|*=
literal|1024L
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'M'
operator|||
operator|*
name|s
operator|==
literal|'m'
operator|)
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
name|val
operator|*=
literal|1024L
operator|*
literal|1024
expr_stmt|;
else|else
block|{
name|zerrnam
argument_list|(
literal|"limit"
argument_list|,
literal|"unknown scaling factor: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|hard
condition|)
if|if
condition|(
name|val
operator|>
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
operator|&&
name|geteuid
argument_list|()
condition|)
block|{
name|zerrnam
argument_list|(
literal|"limit"
argument_list|,
literal|"can't raise hard limits"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
operator|<
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_cur
condition|)
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_cur
operator|=
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
condition|)
block|{
name|zerrnam
argument_list|(
literal|"limit"
argument_list|,
literal|"limit exceeds hard limit"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_cur
operator|=
name|val
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|bin_unlimit
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|RLIM_INFINITY
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"not available on this system"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
name|int
name|hard
init|=
name|ops
index|[
literal|'h'
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|lim
decl_stmt|;
if|if
condition|(
name|hard
operator|&&
name|geteuid
argument_list|()
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"can't remove hard limits"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
block|{
if|if
condition|(
name|hard
condition|)
name|limits
index|[
name|t0
index|]
operator|.
name|rlim_max
operator|=
name|RLIM_INFINITY
expr_stmt|;
else|else
name|limits
index|[
name|t0
index|]
operator|.
name|rlim_cur
operator|=
name|limits
index|[
name|t0
index|]
operator|.
name|rlim_max
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
for|for
control|(
name|lim
operator|=
operator|-
literal|1
operator|,
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|recs
index|[
name|t0
index|]
argument_list|,
operator|*
name|argv
argument_list|,
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|lim
operator|!=
operator|-
literal|1
condition|)
name|lim
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|lim
operator|=
name|t0
expr_stmt|;
block|}
if|if
condition|(
name|lim
operator|<
literal|0
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
operator|(
name|lim
operator|==
operator|-
literal|2
operator|)
condition|?
literal|"ambiguous resource specification: %s"
else|:
literal|"no such resource: %s"
argument_list|,
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|hard
condition|)
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
operator|=
name|RLIM_INFINITY
expr_stmt|;
else|else
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_cur
operator|=
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|showlimits
parameter_list|(
name|hard
parameter_list|,
name|lim
parameter_list|)
comment|/**/
name|int
name|hard
decl_stmt|;
name|int
name|lim
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
name|long
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIM_INFINITY
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|t0
operator|==
name|lim
operator|||
name|lim
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%-16s"
argument_list|,
name|recs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|hard
operator|)
condition|?
name|limits
index|[
name|t0
index|]
operator|.
name|rlim_max
else|:
name|limits
index|[
name|t0
index|]
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|RLIM_INFINITY
condition|)
name|printf
argument_list|(
literal|"unlimited\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|t0
condition|)
name|printf
argument_list|(
literal|"%d:%02d:%02d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|val
operator|/
literal|3600
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|val
operator|/
literal|60
argument_list|)
operator|%
literal|60
argument_list|,
call|(
name|int
call|)
argument_list|(
name|val
operator|%
literal|60
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
elseif|else
if|if
condition|(
name|t0
operator|==
name|RLIMIT_NOFILE
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|val
operator|>=
literal|1024L
operator|*
literal|1024L
condition|)
name|printf
argument_list|(
literal|"%ldMb\n"
argument_list|,
name|val
operator|/
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ldKb\n"
argument_list|,
name|val
operator|/
literal|1024L
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|bin_sched
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|argv
operator|++
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|long
name|h
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|struct
name|schedcmd
modifier|*
name|sch
decl_stmt|,
modifier|*
name|sch2
decl_stmt|,
modifier|*
name|schl
decl_stmt|;
name|int
name|t0
decl_stmt|;
if|if
condition|(
name|s
operator|&&
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|t0
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t0
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"usage for delete: sched -<item#>."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|schl
operator|=
operator|(
expr|struct
name|schedcmd
operator|*
operator|)
operator|&
name|schedcmds
operator|,
name|sch
operator|=
name|schedcmds
operator|,
name|t0
operator|--
init|;
name|sch
operator|&&
name|t0
condition|;
name|sch
operator|=
operator|(
name|schl
operator|=
name|sch
operator|)
operator|->
name|next
operator|,
name|t0
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|sch
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"not that many entries"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|schl
operator|->
name|next
operator|=
name|sch
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sch
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|char
name|tbuf
index|[
literal|40
index|]
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|1
operator|,
name|sch
operator|=
name|schedcmds
init|;
name|sch
condition|;
name|sch
operator|=
name|sch
operator|->
name|next
operator|,
name|t0
operator|++
control|)
block|{
name|t
operator|=
name|sch
operator|->
name|time
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|ztrftime
argument_list|(
name|tbuf
argument_list|,
literal|20
argument_list|,
literal|"%a %b %e %k:%M:%S"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3d %s %s\n"
argument_list|,
name|t0
argument_list|,
name|tbuf
argument_list|,
name|sch
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"not enough arguments"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
name|h
operator|=
name|zstrtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|':'
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"bad time specifier"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|m
operator|=
name|zstrtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"bad time specifier"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|h
operator|*
literal|3600
operator|+
name|m
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|zstrtol
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|':'
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"bad time specifier"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|m
operator|=
name|zstrtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'a'
operator|&&
operator|*
name|s
operator|!=
literal|'p'
condition|)
block|{
name|zerrnam
argument_list|(
literal|"sched"
argument_list|,
literal|"bad time specifier"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|t
operator|-=
name|tm
operator|->
name|tm_sec
operator|+
name|tm
operator|->
name|tm_min
operator|*
literal|60
operator|+
name|tm
operator|->
name|tm_hour
operator|*
literal|3600
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
condition|)
name|h
operator|+=
literal|12
expr_stmt|;
name|t
operator|+=
name|h
operator|*
literal|3600
operator|+
name|m
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|time
argument_list|(
name|NULL
argument_list|)
condition|)
name|t
operator|+=
literal|3600
operator|*
literal|24
expr_stmt|;
block|}
name|sch
operator|=
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|sch
argument_list|)
expr_stmt|;
name|sch
operator|->
name|time
operator|=
name|t
expr_stmt|;
name|sch
operator|->
name|cmd
operator|=
name|ztrdup
argument_list|(
name|spacejoin
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
name|sch
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sch2
operator|=
operator|(
expr|struct
name|schedcmd
operator|*
operator|)
operator|&
name|schedcmds
init|;
name|sch2
operator|->
name|next
condition|;
name|sch2
operator|=
name|sch2
operator|->
name|next
control|)
empty_stmt|;
name|sch2
operator|->
name|next
operator|=
name|sch
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_eval
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|ztrdup
argument_list|(
name|spacejoin
argument_list|(
name|argv
argument_list|)
argument_list|)
decl_stmt|;
name|List
name|list
decl_stmt|;
name|hungets
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strinbeg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parse_list
argument_list|()
operator|)
condition|)
block|{
name|hflush
argument_list|()
expr_stmt|;
name|strinend
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|strinend
argument_list|()
expr_stmt|;
name|runlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|lastval
return|;
block|}
end_function

begin_comment
comment|/* get the history event associated with s */
end_comment

begin_function
name|int
name|fcgetcomm
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|cmd
decl_stmt|;
if|if
condition|(
name|cmd
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|<
literal|0
condition|)
name|cmd
operator|=
name|curhist
operator|+
name|cmd
operator|+
literal|1
expr_stmt|;
return|return
name|cmd
return|;
block|}
name|cmd
operator|=
name|hcomsearch
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
operator|-
literal|1
condition|)
name|zerrnam
argument_list|(
literal|"fc"
argument_list|,
literal|"event not found: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/* perform old=new substituion */
end_comment

begin_function
name|int
name|fcsubs
parameter_list|(
name|sp
parameter_list|,
name|sub
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|struct
name|asgment
modifier|*
name|sub
decl_stmt|;
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|,
modifier|*
name|s4
decl_stmt|,
modifier|*
name|s
init|=
operator|*
name|sp
decl_stmt|,
modifier|*
name|s5
decl_stmt|;
name|int
name|subbed
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|sub
condition|)
block|{
name|s1
operator|=
name|sub
operator|->
name|name
expr_stmt|;
name|s2
operator|=
name|sub
operator|->
name|value
expr_stmt|;
name|sub
operator|=
name|sub
operator|->
name|next
expr_stmt|;
name|s5
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s3
operator|=
operator|(
name|char
operator|*
operator|)
name|ztrstr
argument_list|(
name|s5
argument_list|,
name|s1
argument_list|)
condition|)
block|{
name|s4
operator|=
name|alloc
argument_list|(
literal|1
operator|+
operator|(
name|s3
operator|-
name|s
operator|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
operator|+
name|strlen
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ztrncpy
argument_list|(
name|s4
argument_list|,
name|s
argument_list|,
name|s3
operator|-
name|s
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s4
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|s5
operator|=
name|s4
operator|+
name|strlen
argument_list|(
name|s4
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s4
argument_list|,
name|s3
operator|+
name|strlen
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|s4
expr_stmt|;
name|subbed
operator|=
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|sp
operator|=
name|s
expr_stmt|;
return|return
name|subbed
return|;
block|}
end_function

begin_comment
comment|/* print a series of history events to a file */
end_comment

begin_function
name|int
name|fclist
parameter_list|(
name|f
parameter_list|,
name|n
parameter_list|,
name|r
parameter_list|,
name|D
parameter_list|,
name|d
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|subs
parameter_list|)
comment|/**/
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|D
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
name|struct
name|asgment
modifier|*
name|subs
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|hs
decl_stmt|;
name|Histent
name|ent
decl_stmt|;
if|if
condition|(
operator|!
name|subs
condition|)
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|hs
operator|=
name|quietgetevent
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hs
condition|)
block|{
name|zerrnam
argument_list|(
literal|"fc"
argument_list|,
literal|"no such event: %d"
argument_list|,
name|NULL
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|s
operator|=
name|makehstr
argument_list|(
name|hs
argument_list|)
expr_stmt|;
name|done
operator||=
name|fcsubs
argument_list|(
operator|&
name|s
argument_list|,
name|subs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%5d  "
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|ent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|struct
name|tm
modifier|*
name|ltm
decl_stmt|;
if|if
condition|(
operator|!
name|ent
condition|)
name|ent
operator|=
name|gethistent
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|ltm
operator|=
name|localtime
argument_list|(
operator|&
name|ent
operator|->
name|stim
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%2d:%02d  "
argument_list|,
name|ltm
operator|->
name|tm_hour
argument_list|,
name|ltm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|D
condition|)
block|{
name|long
name|diff
decl_stmt|;
if|if
condition|(
operator|!
name|ent
condition|)
name|ent
operator|=
name|gethistent
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
name|ent
operator|->
name|ftim
operator|)
condition|?
name|ent
operator|->
name|ftim
operator|-
name|ent
operator|->
name|stim
else|:
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d:%02d  "
argument_list|,
name|diff
operator|/
literal|60
argument_list|,
name|diff
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|stdout
condition|)
block|{
name|niceprintf
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
operator|(
name|r
operator|)
condition|?
name|first
operator|--
else|:
name|first
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|zerrnam
argument_list|(
literal|"fc"
argument_list|,
literal|"no substitutions performed"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fcedit
parameter_list|(
name|ename
parameter_list|,
name|fn
parameter_list|)
comment|/**/
name|char
modifier|*
name|ename
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ename
argument_list|,
literal|"-"
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|zyztem
argument_list|(
name|ename
argument_list|,
name|fn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* fc, history, r */
end_comment

begin_function
name|int
name|bin_fc
parameter_list|(
name|nam
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|first
init|=
operator|-
literal|1
decl_stmt|,
name|last
init|=
operator|-
literal|1
decl_stmt|,
name|retval
decl_stmt|,
name|minflag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|asgment
modifier|*
name|asgf
init|=
name|NULL
decl_stmt|,
modifier|*
name|asgl
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|interact
condition|)
block|{
name|zerrnam
argument_list|(
name|nam
argument_list|,
literal|"not interactive shell"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ops
index|[
literal|'l'
index|]
operator|&&
name|unset
argument_list|(
name|HISTNOSTORE
argument_list|)
operator|)
condition|)
name|remhist
argument_list|()
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'R'
index|]
condition|)
block|{
name|readhistfile
argument_list|(
operator|*
name|argv
condition|?
operator|*
name|argv
else|:
name|getsparam
argument_list|(
literal|"HISTFILE"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ops
index|[
literal|'W'
index|]
condition|)
block|{
name|savehistfile
argument_list|(
operator|*
name|argv
condition|?
operator|*
name|argv
else|:
name|getsparam
argument_list|(
literal|"HISTFILE"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ops
index|[
literal|'A'
index|]
condition|)
block|{
name|savehistfile
argument_list|(
operator|*
name|argv
condition|?
operator|*
name|argv
else|:
name|getsparam
argument_list|(
literal|"HISTFILE"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|argv
operator|&&
name|equalsplit
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
name|struct
name|asgment
modifier|*
name|a
init|=
operator|(
expr|struct
name|asgment
operator|*
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|asgf
condition|)
name|asgf
operator|=
name|asgl
operator|=
name|a
expr_stmt|;
else|else
block|{
name|asgl
operator|->
name|next
operator|=
name|a
expr_stmt|;
name|asgl
operator|=
name|a
expr_stmt|;
block|}
name|a
operator|->
name|name
operator|=
operator|*
name|argv
expr_stmt|;
name|a
operator|->
name|value
operator|=
name|s
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|minflag
operator|=
operator|*
operator|*
name|argv
operator|==
literal|'-'
expr_stmt|;
name|first
operator|=
name|fcgetcomm
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|last
operator|=
name|fcgetcomm
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|zerrnam
argument_list|(
literal|"fc"
argument_list|,
literal|"too many arguments"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|first
operator|==
operator|-
literal|1
condition|)
name|first
operator|=
operator|(
name|ops
index|[
literal|'l'
index|]
operator|)
condition|?
name|curhist
operator|-
literal|16
else|:
name|curhist
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
name|last
operator|=
operator|(
name|ops
index|[
literal|'l'
index|]
operator|)
condition|?
name|curhist
else|:
name|first
expr_stmt|;
if|if
condition|(
name|first
operator|<
name|firsthist
argument_list|()
condition|)
name|first
operator|=
name|firsthist
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
name|last
operator|=
operator|(
name|minflag
operator|)
condition|?
name|curhist
else|:
name|first
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'l'
index|]
condition|)
name|retval
operator|=
name|fclist
argument_list|(
name|stdout
argument_list|,
operator|!
name|ops
index|[
literal|'n'
index|]
argument_list|,
name|ops
index|[
literal|'r'
index|]
argument_list|,
name|ops
index|[
literal|'D'
index|]
argument_list|,
name|ops
index|[
literal|'d'
index|]
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|asgf
argument_list|)
expr_stmt|;
else|else
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|fil
init|=
name|gettemp
argument_list|()
decl_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|fil
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
name|zerrnam
argument_list|(
literal|"fc"
argument_list|,
literal|"can't open temp file: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fclist
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|ops
index|[
literal|'r'
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|asgf
argument_list|)
condition|)
if|if
condition|(
name|fcedit
argument_list|(
name|auxdata
condition|?
name|auxdata
else|:
name|fceditparam
argument_list|,
name|fil
argument_list|)
condition|)
if|if
condition|(
name|stuff
argument_list|(
name|fil
argument_list|)
condition|)
name|zerrnam
argument_list|(
literal|"fc"
argument_list|,
literal|"%e: %s"
argument_list|,
name|s
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
block|}
name|unlink
argument_list|(
name|fil
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|bin_suspend
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
if|if
condition|(
name|islogin
operator|&&
operator|!
name|ops
index|[
literal|'f'
index|]
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"can't suspend login shell"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|jobbing
condition|)
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobbing
condition|)
block|{
while|while
condition|(
name|gettygrp
argument_list|()
operator|!=
name|mypgrp
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettygrp
argument_list|()
operator|!=
name|mypgrp
condition|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_alias
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|struct
name|alias
modifier|*
name|an
decl_stmt|;
name|struct
name|asgment
modifier|*
name|asg
decl_stmt|;
name|int
name|incm
init|=
operator|!
operator|(
name|ops
index|[
literal|'a'
index|]
operator|||
name|ops
index|[
literal|'g'
index|]
operator|)
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|showflag
operator|=
operator|!
name|incm
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
name|listhtable
argument_list|(
name|aliastab
argument_list|,
operator|(
name|HFunc
operator|)
name|printalias
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|asg
operator|=
name|getasg
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
name|asg
operator|->
name|value
condition|)
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|asg
operator|->
name|name
argument_list|)
argument_list|,
name|mkanode
argument_list|(
name|ztrdup
argument_list|(
name|asg
operator|->
name|value
argument_list|)
argument_list|,
name|incm
argument_list|)
argument_list|,
name|aliastab
argument_list|,
name|freeanode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|an
operator|=
operator|(
name|Alias
operator|)
name|gethnode
argument_list|(
name|asg
operator|->
name|name
argument_list|,
name|aliastab
argument_list|)
condition|)
name|printalias
argument_list|(
name|asg
operator|->
name|name
argument_list|,
name|an
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* print an alias; used with listhtable */
end_comment

begin_function
name|void
name|printalias
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|alias
modifier|*
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|->
name|cmd
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|showflag
operator|&&
name|a
operator|->
name|cmd
operator|)
condition|)
name|printf
argument_list|(
literal|"%s=%s\n"
argument_list|,
name|s
argument_list|,
name|a
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print a param; used with listhtable */
end_comment

begin_function
name|void
name|printparam
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|Param
name|p
decl_stmt|;
block|{
if|if
condition|(
name|showflag
operator|>
literal|0
operator|&&
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|showflag
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|showflag
condition|)
block|{
name|int
name|fgs
init|=
name|p
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_i
condition|)
name|printf
argument_list|(
literal|"integer "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_A
condition|)
name|printf
argument_list|(
literal|"array "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_L
condition|)
name|printf
argument_list|(
literal|"left justified %d "
argument_list|,
name|p
operator|->
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_R
condition|)
name|printf
argument_list|(
literal|"right justified %d "
argument_list|,
name|p
operator|->
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_Z
condition|)
name|printf
argument_list|(
literal|"zero filled %d "
argument_list|,
name|p
operator|->
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_l
condition|)
name|printf
argument_list|(
literal|"lowercase "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_u
condition|)
name|printf
argument_list|(
literal|"uppercase "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_r
condition|)
name|printf
argument_list|(
literal|"readonly "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_t
condition|)
name|printf
argument_list|(
literal|"tagged "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgs
operator|&
name|PMFLAG_x
condition|)
name|printf
argument_list|(
literal|"exported "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|showflag2
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|u
decl_stmt|;
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|flags
operator|&
name|PMTYPE
condition|)
block|{
case|case
name|PMFLAG_s
case|:
if|if
condition|(
name|p
operator|->
name|gets
operator|.
name|cfn
operator|&&
operator|(
name|t
operator|=
name|p
operator|->
name|gets
operator|.
name|cfn
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|puts
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMFLAG_i
case|:
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|p
operator|->
name|gets
operator|.
name|ifn
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMFLAG_A
case|:
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|u
operator|=
name|p
operator|->
name|gets
operator|.
name|afn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|u
condition|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|u
index|[
literal|1
index|]
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
operator|*
name|u
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s)\n"
argument_list|,
operator|*
name|u
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* autoload, declare, export, functions, integer, local, readonly, typeset */
end_comment

begin_function
name|int
name|bin_typeset
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|on
init|=
literal|0
decl_stmt|,
name|off
init|=
literal|0
decl_stmt|,
name|roff
decl_stmt|,
name|bit
init|=
literal|1
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|optstr
init|=
literal|"LRZilurtx"
decl_stmt|;
name|struct
name|param
modifier|*
name|pm
decl_stmt|;
name|struct
name|asgment
modifier|*
name|asg
decl_stmt|;
for|for
control|(
init|;
operator|*
name|optstr
condition|;
name|optstr
operator|++
operator|,
name|bit
operator|<<=
literal|1
control|)
if|if
condition|(
name|ops
index|[
operator|*
name|optstr
index|]
operator|==
literal|1
condition|)
name|on
operator||=
name|bit
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
operator|*
name|optstr
index|]
operator|==
literal|2
condition|)
name|off
operator||=
name|bit
expr_stmt|;
name|roff
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'f'
index|]
condition|)
block|{
name|on
operator|&=
name|PMFLAG_t
operator||
name|PMFLAG_u
expr_stmt|;
name|off
operator|&=
name|PMFLAG_t
operator||
name|PMFLAG_u
expr_stmt|;
name|showflag
operator|=
operator|(
name|ops
index|[
literal|'f'
index|]
operator|==
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'@'
index|]
operator|&&
operator|(
operator|(
name|off
operator|&
operator|~
name|PMFLAG_t
operator|)
operator|||
operator|(
name|on
operator|&
operator|~
operator|(
name|PMFLAG_u
operator||
name|PMFLAG_t
operator|)
operator|)
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"invalid option(s)"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|showflag2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|showflag2
operator|=
name|off
operator||
name|on
expr_stmt|;
name|listhtable
argument_list|(
name|cmdnamtab
argument_list|,
operator|(
name|HFunc
operator|)
name|pshfunc
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
name|Cmdnam
name|cc
decl_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
operator|*
name|argv
argument_list|,
name|cmdnamtab
argument_list|)
operator|)
operator|&&
name|cc
operator|->
name|type
operator|==
name|SHFUNC
condition|)
if|if
condition|(
name|on
operator||
name|off
condition|)
name|cc
operator|->
name|flags
operator|=
operator|(
name|cc
operator|->
name|flags
operator||
name|on
operator|)
operator|&
operator|(
operator|~
name|off
operator|)
expr_stmt|;
else|else
name|pshfunc
argument_list|(
operator|*
name|argv
argument_list|,
name|cc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|on
operator|&
name|PMFLAG_u
condition|)
block|{
name|cc
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|type
operator|=
name|SHFUNC
expr_stmt|;
name|cc
operator|->
name|flags
operator|=
name|on
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|,
name|cc
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
block|}
else|else
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|retcode
return|;
block|}
if|if
condition|(
name|on
operator|&
name|PMFLAG_L
condition|)
name|off
operator||=
name|PMFLAG_R
expr_stmt|;
if|if
condition|(
name|on
operator|&
name|PMFLAG_R
condition|)
name|off
operator||=
name|PMFLAG_L
expr_stmt|;
if|if
condition|(
name|on
operator|&
name|PMFLAG_u
condition|)
name|off
operator||=
name|PMFLAG_l
expr_stmt|;
if|if
condition|(
name|on
operator|&
name|PMFLAG_l
condition|)
name|off
operator||=
name|PMFLAG_u
expr_stmt|;
name|on
operator|&=
operator|~
name|off
expr_stmt|;
name|showflag
operator|=
name|showflag2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|showflag
operator|=
name|on
operator||
name|off
expr_stmt|;
name|showflag2
operator|=
name|roff
expr_stmt|;
name|listhtable
argument_list|(
name|paramtab
argument_list|,
operator|(
name|HFunc
operator|)
name|printparam
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|asg
operator|=
name|getasg
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
name|asg
operator|->
name|value
operator|&&
operator|*
name|asg
operator|->
name|value
operator|==
literal|'~'
condition|)
block|{
operator|*
name|asg
operator|->
name|value
operator|=
name|Tilde
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|asg
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|pm
operator|=
operator|(
name|Param
operator|)
name|gethnode
argument_list|(
name|asg
operator|->
name|name
argument_list|,
name|paramtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
condition|)
block|{
if|if
condition|(
operator|!
name|on
operator|&&
operator|!
name|roff
operator|&&
operator|!
name|asg
operator|->
name|value
condition|)
block|{
name|printparam
argument_list|(
name|asg
operator|->
name|name
argument_list|,
name|pm
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pm
operator|->
name|flags
operator|=
operator|(
name|pm
operator|->
name|flags
operator||
name|on
operator|)
operator|&
operator|~
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|on
operator|&
operator|(
name|PMFLAG_L
operator||
name|PMFLAG_R
operator||
name|PMFLAG_Z
operator||
name|PMFLAG_i
operator|)
operator|)
operator|&&
operator|(
name|pmtype
argument_list|(
name|pm
argument_list|)
operator|!=
name|PMFLAG_A
operator|)
condition|)
name|pm
operator|->
name|ct
operator|=
name|auxlen
expr_stmt|;
if|if
condition|(
name|pmtype
argument_list|(
name|pm
argument_list|)
operator|!=
name|PMFLAG_A
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|flags
operator|&
name|PMFLAG_x
condition|)
block|{
if|if
condition|(
operator|!
name|pm
operator|->
name|env
condition|)
name|pm
operator|->
name|env
operator|=
name|addenv
argument_list|(
name|asg
operator|->
name|name
argument_list|,
operator|(
name|asg
operator|->
name|value
operator|)
condition|?
name|asg
operator|->
name|value
else|:
name|getsparam
argument_list|(
name|asg
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm
operator|->
name|env
condition|)
block|{
name|delenv
argument_list|(
name|pm
operator|->
name|env
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pm
operator|->
name|env
argument_list|)
expr_stmt|;
name|pm
operator|->
name|env
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|asg
operator|->
name|value
condition|)
name|setsparam
argument_list|(
name|asg
operator|->
name|name
argument_list|,
name|ztrdup
argument_list|(
name|asg
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|locallist
operator|&&
operator|!
operator|(
name|on
operator|&
name|PMFLAG_x
operator|)
condition|)
block|{
name|permalloc
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|locallist
argument_list|,
name|ztrdup
argument_list|(
name|asg
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
block|}
name|createparam
argument_list|(
name|ztrdup
argument_list|(
name|asg
operator|->
name|name
argument_list|)
argument_list|,
name|ztrdup
argument_list|(
operator|(
name|asg
operator|->
name|value
operator|)
condition|?
name|asg
operator|->
name|value
else|:
literal|""
argument_list|)
argument_list|,
name|on
argument_list|)
expr_stmt|;
name|pm
operator|=
operator|(
name|Param
operator|)
name|gethnode
argument_list|(
name|asg
operator|->
name|name
argument_list|,
name|paramtab
argument_list|)
expr_stmt|;
name|pm
operator|->
name|ct
operator|=
name|auxlen
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* convert s with escape sequences */
end_comment

begin_function
name|char
modifier|*
name|escsubst
parameter_list|(
name|s
parameter_list|,
name|nnl
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|nnl
decl_stmt|;
block|{
name|char
modifier|*
name|t
init|=
name|alloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|,
modifier|*
name|ret
init|=
name|t
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
condition|)
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'b'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|*
name|nnl
operator||=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
operator|*
name|t
operator|++
operator|=
name|zstrtol
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
break|break;
default|default:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* echo, print, pushln */
end_comment

begin_function
name|int
name|bin_print
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|nnl
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|;
name|Histent
name|ent
decl_stmt|;
name|FILE
modifier|*
name|fout
init|=
name|stdout
decl_stmt|;
if|if
condition|(
name|ops
index|[
literal|'z'
index|]
condition|)
block|{
name|permalloc
argument_list|()
expr_stmt|;
name|pushnode
argument_list|(
name|bufstack
argument_list|,
name|ztrdup
argument_list|(
name|spacejoin
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ops
index|[
literal|'s'
index|]
condition|)
block|{
name|permalloc
argument_list|()
expr_stmt|;
name|ent
operator|=
name|gethistent
argument_list|(
operator|++
name|curhist
argument_list|)
expr_stmt|;
name|ent
operator|->
name|lex
operator|=
name|ztrdup
argument_list|(
name|join
argument_list|(
name|args
argument_list|,
name|HISTSPACE
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|lit
operator|=
name|ztrdup
argument_list|(
name|join
argument_list|(
name|args
argument_list|,
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|stim
operator|=
name|ent
operator|->
name|ftim
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ops
index|[
literal|'R'
index|]
condition|)
name|ops
index|[
literal|'r'
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'u'
index|]
operator|||
name|ops
index|[
literal|'p'
index|]
condition|)
block|{
if|if
condition|(
name|ops
index|[
literal|'u'
index|]
condition|)
block|{
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
literal|10
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|fd
operator|+
literal|'0'
index|]
condition|)
break|break;
if|if
condition|(
name|fd
operator|==
literal|10
condition|)
name|fd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|coprocout
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"bad file number"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|fout
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"bad mode on fd"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
for|for
control|(
init|;
operator|*
name|args
condition|;
name|args
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ops
index|[
literal|'r'
index|]
condition|)
operator|*
name|args
operator|=
name|escsubst
argument_list|(
operator|*
name|args
argument_list|,
operator|&
name|nnl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'D'
index|]
condition|)
name|fprintdir
argument_list|(
operator|*
name|args
argument_list|,
name|fout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'P'
index|]
condition|)
block|{
name|int
name|junk
decl_stmt|;
name|fputs
argument_list|(
name|putprompt
argument_list|(
operator|*
name|args
argument_list|,
operator|&
name|junk
argument_list|)
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
operator|*
name|args
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
name|fputc
argument_list|(
name|ops
index|[
literal|'l'
index|]
condition|?
literal|'\n'
else|:
name|ops
index|[
literal|'0'
index|]
condition|?
literal|'\0'
else|:
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ops
index|[
literal|'n'
index|]
operator|||
name|nnl
operator|)
condition|)
name|fputc
argument_list|(
name|ops
index|[
literal|'N'
index|]
condition|?
literal|'\0'
else|:
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_dirs
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|Lklist
name|l
decl_stmt|;
if|if
condition|(
name|ops
index|[
literal|'v'
index|]
condition|)
block|{
name|Lknode
name|node
decl_stmt|;
name|int
name|t0
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
literal|"0\t"
argument_list|)
expr_stmt|;
name|printdir
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|dirstack
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"\n%d\t"
argument_list|,
name|t0
operator|++
argument_list|)
expr_stmt|;
name|printdir
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|pdstack
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|permalloc
argument_list|()
expr_stmt|;
name|l
operator|=
name|newlist
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|heapalloc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|argv
condition|)
name|addnode
argument_list|(
name|l
argument_list|,
name|ztrdup
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|freetable
argument_list|(
name|dirstack
argument_list|,
name|freestr
argument_list|)
expr_stmt|;
name|dirstack
operator|=
name|l
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_unalias
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|vptr
name|dat
decl_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
name|dat
operator|=
name|remhnode
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|aliastab
argument_list|)
condition|)
name|freeanode
argument_list|(
name|dat
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|bin_disable
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|Cmdnam
name|chn
decl_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"TRAP"
argument_list|,
literal|4
argument_list|)
condition|)
name|unsettrap
argument_list|(
name|getsignum
argument_list|(
operator|*
name|argv
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|chn
operator|=
name|zalloc
argument_list|(
sizeof|sizeof
expr|*
name|chn
argument_list|)
expr_stmt|;
name|chn
operator|->
name|type
operator|=
name|DISABLED
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
argument_list|,
name|chn
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_unhash
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|vptr
name|dat
decl_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"TRAP"
argument_list|,
literal|4
argument_list|)
condition|)
name|unsettrap
argument_list|(
name|getsignum
argument_list|(
operator|*
name|argv
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dat
operator|=
name|remhnode
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|cmdnamtab
argument_list|)
condition|)
name|freecmdnam
argument_list|(
name|dat
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_unset
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|s
operator|=
operator|*
name|argv
operator|++
condition|)
if|if
condition|(
name|gethnode
argument_list|(
name|s
argument_list|,
name|paramtab
argument_list|)
condition|)
name|unsetparam
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
literal|1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readfd
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zread
parameter_list|()
comment|/**/
block|{
name|char
name|cc
decl_stmt|;
if|if
condition|(
name|zbuf
condition|)
return|return
operator|(
operator|*
name|zbuf
operator|)
condition|?
operator|*
name|zbuf
operator|++
else|:
name|EOF
return|;
if|if
condition|(
name|read
argument_list|(
name|readfd
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|EOF
return|;
return|return
name|cc
return|;
block|}
end_function

begin_function
name|int
name|bin_read
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|reply
decl_stmt|,
modifier|*
name|pmpt
decl_stmt|;
name|int
name|bsiz
decl_stmt|,
name|c
decl_stmt|,
name|gotnl
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bptr
decl_stmt|;
name|reply
operator|=
operator|(
operator|*
name|args
operator|)
condition|?
operator|*
name|args
operator|++
else|:
literal|"REPLY"
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'u'
index|]
operator|&&
operator|!
name|ops
index|[
literal|'p'
index|]
condition|)
block|{
for|for
control|(
name|readfd
operator|=
literal|0
init|;
name|readfd
operator|<
literal|10
condition|;
operator|++
name|readfd
control|)
if|if
condition|(
name|ops
index|[
name|readfd
operator|+
literal|'0'
index|]
condition|)
break|break;
if|if
condition|(
name|readfd
operator|==
literal|10
condition|)
name|readfd
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ops
index|[
literal|'p'
index|]
condition|)
name|readfd
operator|=
name|coprocin
expr_stmt|;
else|else
block|{
name|attachtty
argument_list|(
operator|(
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
operator|)
condition|?
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
else|:
name|mypgrp
argument_list|)
expr_stmt|;
name|readfd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
for|for
control|(
name|pmpt
operator|=
name|reply
init|;
operator|*
name|pmpt
operator|&&
operator|*
name|pmpt
operator|!=
literal|'?'
condition|;
name|pmpt
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|pmpt
operator|++
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
name|pmpt
argument_list|,
name|strlen
argument_list|(
name|pmpt
argument_list|)
argument_list|)
expr_stmt|;
name|pmpt
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|else if (isset(SHINSTDIN)&& unset(INTERACTIVE)) { 			if (isatty(1)) readfd = 1; 			else if (isatty(2)) readfd = 2; 		}
endif|#
directive|endif
block|}
name|zbuf
operator|=
operator|(
operator|!
name|ops
index|[
literal|'z'
index|]
operator|)
operator|?
name|NULL
operator|:
operator|(
name|full
argument_list|(
name|bufstack
argument_list|)
operator|)
operator|?
operator|(
name|char
operator|*
operator|)
name|getnode
argument_list|(
name|bufstack
argument_list|)
operator|:
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|buf
operator|=
name|bptr
operator|=
name|zalloc
argument_list|(
name|bsiz
operator|=
literal|64
argument_list|)
expr_stmt|;
name|redo
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|gotnl
condition|)
break|break;
name|c
operator|=
name|zread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ops
index|[
literal|'r'
index|]
operator|&&
name|c
operator|==
literal|'\n'
operator|&&
name|bptr
operator|!=
name|buf
operator|&&
name|bptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|bptr
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|isep
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|bptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|bptr
operator|==
name|buf
operator|+
name|bsiz
condition|)
block|{
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bsiz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|bptr
operator|=
name|buf
operator|+
operator|(
name|bsiz
operator|/
literal|2
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|readfd
operator|==
name|coprocin
condition|)
block|{
name|close
argument_list|(
name|coprocin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|coprocout
argument_list|)
expr_stmt|;
name|coprocin
operator|=
name|coprocout
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|gotnl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bptr
operator|==
name|buf
condition|)
goto|goto
name|redo
goto|;
operator|*
name|bptr
operator|=
literal|'\0'
expr_stmt|;
name|setsparam
argument_list|(
name|reply
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|*
name|args
operator|++
expr_stmt|;
block|}
name|buf
operator|=
name|bptr
operator|=
name|zalloc
argument_list|(
name|bsiz
operator|=
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotnl
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|zread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ops
index|[
literal|'r'
index|]
operator|&&
name|c
operator|==
literal|'\n'
operator|&&
name|bptr
operator|!=
name|buf
operator|&&
name|bptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|bptr
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
operator|!
name|zbuf
operator|)
condition|)
break|break;
operator|*
name|bptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|bptr
operator|==
name|buf
operator|+
name|bsiz
condition|)
block|{
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bsiz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|bptr
operator|=
name|buf
operator|+
operator|(
name|bsiz
operator|/
literal|2
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|bptr
operator|=
literal|'\0'
expr_stmt|;
name|setsparam
argument_list|(
name|reply
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|readfd
operator|==
name|coprocin
condition|)
block|{
name|close
argument_list|(
name|coprocin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|coprocout
argument_list|)
expr_stmt|;
name|coprocin
operator|=
name|coprocout
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_vared
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|struct
name|param
modifier|*
name|pm
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|getsparam
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no such variable: %s"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|permalloc
argument_list|()
expr_stmt|;
name|pushnode
argument_list|(
name|bufstack
argument_list|,
name|ztrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|zleread
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"> "
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|errflag
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t
index|[
name|strlen
argument_list|(
name|t
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|t
index|[
name|strlen
argument_list|(
name|t
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pm
operator|=
name|gethnode
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|paramtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmtype
argument_list|(
name|pm
argument_list|)
operator|==
name|PMFLAG_A
condition|)
name|setaparam
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|spacesplit
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setsparam
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fset
parameter_list|(
name|X
parameter_list|)
value|(flags& X)
end_define

begin_comment
comment|/* execute a builtin handler function after parsing the arguments */
end_comment

begin_function
name|int
name|execbin
parameter_list|(
name|args
parameter_list|,
name|cnode
parameter_list|)
comment|/**/
name|Lklist
name|args
decl_stmt|;
name|Cmdnam
name|cnode
decl_stmt|;
block|{
name|struct
name|bincmd
modifier|*
name|b
decl_stmt|;
name|char
name|ops
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|oargv
decl_stmt|,
modifier|*
name|optstr
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|flags
decl_stmt|,
name|sense
decl_stmt|,
name|argc
init|=
literal|0
decl_stmt|,
name|op
decl_stmt|;
name|Lknode
name|n
decl_stmt|;
name|auxdata
operator|=
name|NULL
expr_stmt|;
name|auxlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|128
condition|;
name|t0
operator|++
control|)
name|ops
index|[
name|t0
index|]
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|b
operator|=
name|builtins
operator|+
name|cnode
operator|->
name|u
operator|.
name|binnum
expr_stmt|;
comment|/* the 'builtin' builtin is handled specially */
if|if
condition|(
name|b
operator|->
name|funcid
operator|==
name|BIN_BUILTIN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|name
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
literal|"builtin"
argument_list|,
literal|"command name expected"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|t0
operator|=
literal|0
operator|,
name|b
operator|=
name|builtins
init|;
name|b
operator|->
name|name
condition|;
name|b
operator|++
operator|,
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|b
operator|->
name|name
condition|)
block|{
name|zerrnam
argument_list|(
literal|"builtin"
argument_list|,
literal|"no such builtin: %s"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|flags
operator|=
name|b
operator|->
name|flags
expr_stmt|;
name|arg
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|optstr
operator|=
name|b
operator|->
name|optstr
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BINF_ECHOPTS
operator|&&
name|arg
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|optstr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|optstr
condition|)
while|while
condition|(
name|arg
operator|&&
operator|(
operator|(
name|sense
operator|=
operator|*
name|arg
operator|==
literal|'-'
operator|)
operator|||
name|fset
argument_list|(
name|BINF_PLUSOPTS
argument_list|)
operator|&&
operator|*
name|arg
operator|==
literal|'+'
operator|)
operator|&&
operator|(
name|fset
argument_list|(
name|BINF_PLUSOPTS
argument_list|)
operator|||
operator|!
name|atoi
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|pp
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|arg
index|[
literal|1
index|]
condition|)
block|{
name|ops
index|[
literal|'-'
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sense
condition|)
name|ops
index|[
literal|'+'
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ops
index|[
literal|'@'
index|]
operator|=
literal|1
expr_stmt|;
name|op
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|arg
condition|)
if|if
condition|(
name|strchr
argument_list|(
name|b
operator|->
name|optstr
argument_list|,
name|op
operator|=
operator|*
name|arg
argument_list|)
condition|)
name|ops
index|[
operator|*
name|arg
index|]
operator|=
operator|(
name|sense
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
else|else
break|break;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
name|zerr
argument_list|(
literal|"bad option: %c"
argument_list|,
name|NULL
argument_list|,
operator|*
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|arg
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fset
argument_list|(
name|BINF_SETOPTS
argument_list|)
operator|&&
name|op
operator|==
literal|'o'
condition|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|prtopt
argument_list|()
expr_stmt|;
else|else
block|{
name|c
operator|=
name|optlookup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|zerr
argument_list|(
literal|"bad option: %s"
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|ops
index|[
name|c
index|]
operator|=
name|ops
index|[
literal|'o'
index|]
expr_stmt|;
name|arg
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|fset
argument_list|(
name|BINF_PRINTOPTS
argument_list|)
operator|&&
name|ops
index|[
literal|'R'
index|]
operator|)
operator|||
name|ops
index|[
literal|'-'
index|]
condition|)
break|break;
if|if
condition|(
name|fset
argument_list|(
name|BINF_SETOPTS
argument_list|)
operator|&&
name|ops
index|[
literal|'A'
index|]
condition|)
block|{
name|auxdata
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fset
argument_list|(
name|BINF_FCOPTS
argument_list|)
operator|&&
name|op
operator|==
literal|'e'
condition|)
block|{
name|auxdata
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fset
argument_list|(
name|BINF_TYPEOPT
argument_list|)
operator|&&
operator|(
name|op
operator|==
literal|'L'
operator|||
name|op
operator|==
literal|'R'
operator|||
name|op
operator|==
literal|'Z'
operator|||
name|op
operator|==
literal|'i'
operator|)
operator|&&
name|arg
operator|&&
name|idigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|auxlen
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fset
argument_list|(
name|BINF_R
argument_list|)
condition|)
name|auxdata
operator|=
literal|"-"
expr_stmt|;
if|if
condition|(
name|pp
operator|=
name|b
operator|->
name|defopts
condition|)
while|while
condition|(
operator|*
name|pp
condition|)
name|ops
index|[
operator|*
name|pp
operator|++
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|argc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|firstnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
condition|)
name|argc
operator|++
operator|,
name|incnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|oargv
operator|=
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ncalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|++
operator|=
name|arg
condition|)
while|while
condition|(
operator|*
name|argv
operator|++
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
condition|)
empty_stmt|;
name|argv
operator|=
name|oargv
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|argc
operator|<
name|b
operator|->
name|minargs
operator|||
operator|(
name|argc
operator|>
name|b
operator|->
name|maxargs
operator|&&
name|b
operator|->
name|maxargs
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
operator|(
name|argc
operator|<
name|b
operator|->
name|minargs
operator|)
condition|?
literal|"not enough arguments"
else|:
literal|"too many arguments"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|XTRACE
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|pp
init|=
name|argv
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|prompt4
operator|)
condition|?
name|prompt4
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
operator|(
name|b
operator|->
name|handlerfunc
operator|)
operator|)
operator|(
name|name
operator|,
name|argv
operator|,
name|ops
operator|,
name|b
operator|->
name|funcid
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|asgment
modifier|*
name|getasg
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|struct
name|asgment
name|asg
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
name|zerr
argument_list|(
literal|"bad assignment"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|asg
operator|.
name|name
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'='
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|asg
operator|.
name|value
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|asg
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|asg
return|;
block|}
end_function

begin_comment
comment|/* ., source */
end_comment

begin_function
name|int
name|bin_dot
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|old
decl_stmt|,
modifier|*
name|old0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|t
decl_stmt|,
modifier|*
name|enam
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
return|return
literal|0
return|;
name|old
operator|=
name|pparams
expr_stmt|;
name|old0
operator|=
name|argzero
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|permalloc
argument_list|()
expr_stmt|;
name|pparams
operator|=
name|arrdup
argument_list|(
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
block|}
name|enam
operator|=
name|argzero
operator|=
name|ztrdup
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
name|argzero
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|ret
operator|=
name|source
argument_list|(
name|argzero
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
for|for
control|(
name|t
operator|=
name|path
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|t
operator|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
operator|(
operator|*
name|t
operator|)
index|[
literal|1
index|]
condition|)
block|{
name|ret
operator|=
name|source
argument_list|(
name|argzero
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|*
name|t
argument_list|,
name|argzero
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|source
argument_list|(
name|enam
operator|=
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|t
operator|&&
name|access
argument_list|(
name|argzero
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|source
argument_list|(
name|enam
operator|=
name|argzero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|freearray
argument_list|(
name|pparams
argument_list|)
expr_stmt|;
name|pparams
operator|=
name|old
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"%e: %s"
argument_list|,
name|enam
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argzero
argument_list|)
expr_stmt|;
name|argzero
operator|=
name|old0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|bin_set
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|struct
name|option
modifier|*
name|opp
decl_stmt|;
name|char
modifier|*
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ops
index|[
literal|'+'
index|]
operator|&&
name|ops
index|[
literal|'-'
index|]
operator|)
operator|||
operator|!
name|ops
index|[
literal|'-'
index|]
operator|)
operator|&&
operator|!
name|ops
index|[
literal|'@'
index|]
operator|&&
operator|!
operator|*
name|argv
condition|)
block|{
name|showflag
operator|=
operator|~
literal|0
expr_stmt|;
name|showflag2
operator|=
name|ops
index|[
literal|'+'
index|]
expr_stmt|;
name|listhtable
argument_list|(
name|paramtab
argument_list|,
operator|(
name|HFunc
operator|)
name|printparam
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|opp
operator|=
name|optns
init|;
name|opp
operator|->
name|name
condition|;
name|opp
operator|++
control|)
if|if
condition|(
name|ops
index|[
name|opp
operator|->
name|id
index|]
operator|==
literal|1
condition|)
name|opts
index|[
name|opp
operator|->
name|id
index|]
operator|=
name|OPT_SET
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
name|opp
operator|->
name|id
index|]
operator|==
literal|2
condition|)
name|opts
index|[
name|opp
operator|->
name|id
index|]
operator|=
name|OPT_UNSET
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
operator|&&
operator|!
name|ops
index|[
literal|'-'
index|]
condition|)
return|return
literal|0
return|;
name|permalloc
argument_list|()
expr_stmt|;
name|x
operator|=
name|arrdup
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'A'
index|]
condition|)
name|setaparam
argument_list|(
name|auxdata
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|freearray
argument_list|(
name|pparams
argument_list|)
expr_stmt|;
name|pparams
operator|=
name|x
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|pttime
parameter_list|(
name|X
parameter_list|)
value|printf("%dm%ds",(X)/3600,(X)/60%60)
end_define

begin_function
name|int
name|bin_times
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|struct
name|tms
name|buf
decl_stmt|;
if|if
condition|(
name|times
argument_list|(
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|pttime
argument_list|(
name|buf
operator|.
name|tms_utime
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pttime
argument_list|(
name|buf
operator|.
name|tms_stime
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pttime
argument_list|(
name|buf
operator|.
name|tms_cutime
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pttime
argument_list|(
name|buf
operator|.
name|tms_cstime
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_getopts
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|optstr
init|=
operator|*
name|argv
operator|++
decl_stmt|,
modifier|*
name|var
init|=
operator|*
name|argv
operator|++
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
init|=
operator|(
operator|*
name|argv
operator|)
condition|?
name|argv
else|:
name|pparams
decl_stmt|;
specifier|static
name|int
name|optcind
init|=
literal|1
decl_stmt|,
name|quiet
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
name|optbuf
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|opch
init|=
name|optbuf
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zoptind
operator|<
literal|1
condition|)
name|zoptind
operator|=
literal|1
expr_stmt|;
name|optbuf
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|optbuf
index|[
literal|1
index|]
operator|=
name|optbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|optarg
condition|)
name|free
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|optarg
operator|=
name|ztrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|setsparam
argument_list|(
name|var
argument_list|,
name|ztrdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optstr
operator|==
literal|':'
condition|)
block|{
name|quiet
operator|=
literal|1
expr_stmt|;
name|optstr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zoptind
operator|>
name|arrlen
argument_list|(
name|args
argument_list|)
condition|)
return|return
literal|1
return|;
name|str
operator|=
name|args
index|[
name|zoptind
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'+'
operator|&&
operator|*
name|str
operator|!=
literal|'-'
operator|||
name|optcind
operator|>=
name|strlen
argument_list|(
name|str
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"--"
argument_list|,
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'+'
operator|||
operator|*
name|str
operator|==
literal|'-'
condition|)
name|zoptind
operator|++
expr_stmt|;
name|optcind
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|optcind
condition|)
name|optcind
operator|=
literal|1
expr_stmt|;
operator|*
name|opch
operator|=
name|str
index|[
name|optcind
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|args
index|[
name|zoptind
operator|-
literal|1
index|]
index|[
name|optcind
index|]
condition|)
block|{
name|zoptind
operator|++
expr_stmt|;
name|optcind
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|optstr
condition|;
name|optstr
operator|++
control|)
if|if
condition|(
operator|*
name|opch
operator|==
operator|*
name|optstr
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|optstr
condition|)
block|{
name|setsparam
argument_list|(
name|var
argument_list|,
name|ztrdup
argument_list|(
literal|"?"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
block|{
name|free
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|optarg
operator|=
name|ztrdup
argument_list|(
name|opch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zerr
argument_list|(
literal|"bad option: %c"
argument_list|,
name|NULL
argument_list|,
operator|*
name|opch
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|setsparam
argument_list|(
name|var
argument_list|,
name|ztrdup
argument_list|(
name|opch
operator|-
operator|(
operator|*
name|str
operator|==
literal|'+'
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|zoptind
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
block|{
name|free
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|optarg
operator|=
name|ztrdup
argument_list|(
name|opch
argument_list|)
expr_stmt|;
name|setsparam
argument_list|(
name|var
argument_list|,
name|ztrdup
argument_list|(
literal|":"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|setsparam
argument_list|(
name|var
argument_list|,
name|ztrdup
argument_list|(
literal|"?"
argument_list|)
argument_list|)
expr_stmt|;
name|zerr
argument_list|(
literal|"argument expected after %c option"
argument_list|,
name|NULL
argument_list|,
operator|*
name|opch
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|optarg
operator|=
name|ztrdup
argument_list|(
name|args
index|[
name|zoptind
operator|-
literal|1
index|]
operator|+
name|optcind
argument_list|)
expr_stmt|;
name|zoptind
operator|++
expr_stmt|;
name|optcind
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get a signal number from a string */
end_comment

begin_function
name|int
name|getsignum
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|x
init|=
name|atoi
argument_list|(
name|s
argument_list|)
decl_stmt|,
name|t0
decl_stmt|;
if|if
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<
name|VSIGCOUNT
condition|)
return|return
name|x
return|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|VSIGCOUNT
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|sigs
index|[
name|t0
index|]
argument_list|)
condition|)
return|return
name|t0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|bin_trap
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|List
name|l
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|VSIGCOUNT
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|sigtrapped
index|[
name|t0
index|]
condition|)
if|if
condition|(
operator|!
name|sigfuncs
index|[
name|t0
index|]
condition|)
name|printf
argument_list|(
literal|"TRAP%s () {}\n"
argument_list|,
name|sigs
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|s
init|=
name|getpermtext
argument_list|(
operator|(
name|vptr
operator|)
name|sigfuncs
index|[
name|t0
index|]
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"TRAP%s () {\n\t%s\n}\n"
argument_list|,
name|sigs
index|[
name|t0
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|int
name|t0
decl_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|VSIGCOUNT
condition|;
name|t0
operator|++
control|)
name|unsettrap
argument_list|(
name|t0
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|argv
condition|)
name|unsettrap
argument_list|(
name|getsignum
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg
condition|)
name|l
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|l
operator|=
name|parselstring
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"couldn't parse trap command"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
name|int
name|sg
init|=
name|getsignum
argument_list|(
operator|*
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|sg
operator|==
operator|-
literal|1
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"undefined signal: %s"
argument_list|,
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|settrap
argument_list|(
name|sg
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
name|popheap
argument_list|()
expr_stmt|;
return|return
name|errflag
return|;
block|}
end_function

begin_function
name|void
name|printulimit
parameter_list|(
name|lim
parameter_list|,
name|hard
parameter_list|)
comment|/**/
name|int
name|lim
decl_stmt|;
name|int
name|hard
decl_stmt|;
block|{
name|long
name|t0
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIM_INFINITY
name|t0
operator|=
operator|(
name|hard
operator|)
condition|?
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_max
else|:
name|limits
index|[
name|lim
index|]
operator|.
name|rlim_cur
expr_stmt|;
switch|switch
condition|(
name|lim
condition|)
block|{
case|case
name|RLIMIT_CPU
case|:
name|printf
argument_list|(
literal|"cpu time (seconds)         "
argument_list|)
expr_stmt|;
break|break;
case|case
name|RLIMIT_FSIZE
case|:
name|printf
argument_list|(
literal|"file size (blocks)         "
argument_list|)
expr_stmt|;
name|t0
operator|/=
literal|512
expr_stmt|;
break|break;
case|case
name|RLIMIT_DATA
case|:
name|printf
argument_list|(
literal|"data seg size (kbytes)     "
argument_list|)
expr_stmt|;
name|t0
operator|/=
literal|1024
expr_stmt|;
break|break;
case|case
name|RLIMIT_STACK
case|:
name|printf
argument_list|(
literal|"stack size (kbytes)        "
argument_list|)
expr_stmt|;
name|t0
operator|/=
literal|1024
expr_stmt|;
break|break;
case|case
name|RLIMIT_CORE
case|:
name|printf
argument_list|(
literal|"core file size (blocks)    "
argument_list|)
expr_stmt|;
name|t0
operator|/=
literal|512
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RLIMIT_RSS
case|case
name|RLIMIT_RSS
case|:
name|printf
argument_list|(
literal|"resident set size (kbytes) "
argument_list|)
expr_stmt|;
name|t0
operator|/=
literal|1024
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
case|case
name|RLIMIT_NOFILE
case|:
name|printf
argument_list|(
literal|"file descriptors           "
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|t0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|bin_ulimit
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|res
decl_stmt|,
name|hard
decl_stmt|;
ifndef|#
directive|ifndef
name|RLIM_INFINITY
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"not available on this system"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
name|hard
operator|=
name|ops
index|[
literal|'H'
index|]
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'a'
index|]
operator|||
operator|!
name|ops
index|[
literal|'@'
index|]
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'t'
index|]
condition|)
name|res
operator|=
name|RLIMIT_CPU
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'f'
index|]
condition|)
name|res
operator|=
name|RLIMIT_FSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'d'
index|]
condition|)
name|res
operator|=
name|RLIMIT_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'s'
index|]
condition|)
name|res
operator|=
name|RLIMIT_STACK
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'c'
index|]
condition|)
name|res
operator|=
name|RLIMIT_CORE
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_RSS
elseif|else
if|if
condition|(
name|ops
index|[
literal|'m'
index|]
condition|)
name|res
operator|=
name|RLIMIT_RSS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
elseif|else
if|if
condition|(
name|ops
index|[
literal|'n'
index|]
condition|)
name|res
operator|=
name|RLIMIT_NOFILE
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no such limit"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no arguments required after -a"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
name|printulimit
argument_list|(
name|t0
argument_list|,
name|hard
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
name|printulimit
argument_list|(
name|res
argument_list|,
name|hard
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"unlimited"
argument_list|)
condition|)
block|{
name|long
name|t0
decl_stmt|;
name|t0
operator|=
name|atol
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|RLIMIT_FSIZE
case|:
case|case
name|RLIMIT_CORE
case|:
name|t0
operator|*=
literal|512
expr_stmt|;
break|break;
case|case
name|RLIMIT_DATA
case|:
case|case
name|RLIMIT_STACK
case|:
ifdef|#
directive|ifdef
name|RLIMIT_RSS
case|case
name|RLIMIT_RSS
case|:
endif|#
directive|endif
name|t0
operator|*=
literal|1024
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hard
condition|)
block|{
if|if
condition|(
name|t0
operator|>
name|limits
index|[
name|res
index|]
operator|.
name|rlim_max
operator|&&
name|geteuid
argument_list|()
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"can't raise hard limits"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|limits
index|[
name|res
index|]
operator|.
name|rlim_max
operator|=
name|t0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t0
operator|>
name|limits
index|[
name|res
index|]
operator|.
name|rlim_max
condition|)
block|{
if|if
condition|(
name|geteuid
argument_list|()
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"value exceeds hard limit"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|limits
index|[
name|res
index|]
operator|.
name|rlim_max
operator|=
name|limits
index|[
name|res
index|]
operator|.
name|rlim_cur
operator|=
name|t0
expr_stmt|;
block|}
else|else
name|limits
index|[
name|res
index|]
operator|.
name|rlim_cur
operator|=
name|t0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hard
condition|)
block|{
if|if
condition|(
name|geteuid
argument_list|()
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"can't remove hard limits"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|limits
index|[
name|res
index|]
operator|.
name|rlim_max
operator|=
name|RLIM_INFINITY
expr_stmt|;
block|}
else|else
name|limits
index|[
name|res
index|]
operator|.
name|rlim_cur
operator|=
name|limits
index|[
name|res
index|]
operator|.
name|rlim_max
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|putraw
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|int
name|c
decl_stmt|;
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_echotc
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|buf
index|[
literal|2048
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|int
name|num
decl_stmt|,
name|argct
decl_stmt|,
name|t0
decl_stmt|;
name|s
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|termok
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|num
operator|=
name|tgetnum
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|u
operator|=
name|buf
expr_stmt|;
name|t
operator|=
name|tgetstr
argument_list|(
name|s
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
operator|!
operator|*
name|t
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"no such capability: %s"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|argct
operator|=
literal|0
operator|,
name|u
operator|=
name|t
init|;
operator|*
name|u
condition|;
name|u
operator|++
control|)
if|if
condition|(
operator|*
name|u
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|u
operator|++
operator|,
operator|(
operator|*
name|u
operator|==
literal|'d'
operator|||
operator|*
name|u
operator|==
literal|'2'
operator|||
operator|*
name|u
operator|==
literal|'3'
operator|||
operator|*
name|u
operator|==
literal|'.'
operator|||
operator|*
name|u
operator|==
literal|'+'
operator|)
condition|)
name|argct
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arrlen
argument_list|(
name|argv
argument_list|)
operator|!=
name|argct
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
operator|(
name|arrlen
argument_list|(
name|argv
argument_list|)
operator|<
name|argct
operator|)
condition|?
literal|"not enough arguments"
else|:
literal|"too many arguments"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|argct
condition|)
name|tputs
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|putraw
argument_list|)
expr_stmt|;
else|else
block|{
name|t0
operator|=
operator|(
name|argv
index|[
literal|1
index|]
operator|)
condition|?
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
else|:
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|t
argument_list|,
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|,
name|t0
argument_list|)
argument_list|,
name|t0
argument_list|,
name|putraw
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bin_pwd
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TEST_END
value|0
end_define

begin_define
define|#
directive|define
name|TEST_INPAR
value|1
end_define

begin_define
define|#
directive|define
name|TEST_OUTPAR
value|2
end_define

begin_define
define|#
directive|define
name|TEST_STR
value|3
end_define

begin_define
define|#
directive|define
name|TEST_AND
value|4
end_define

begin_define
define|#
directive|define
name|TEST_OR
value|5
end_define

begin_define
define|#
directive|define
name|TEST_NOT
value|6
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|tsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|tip
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|bin_test
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|int
name|cnt
decl_stmt|,
modifier|*
name|arr
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|Cond
name|c
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|BIN_BRACKET
condition|)
block|{
for|for
control|(
name|s
operator|=
name|argv
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|s
operator|==
name|argv
operator|||
name|strcmp
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|,
literal|"]"
argument_list|)
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"']' expected"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|s
index|[
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|argv
operator|,
name|cnt
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|++
operator|,
name|cnt
operator|++
control|)
empty_stmt|;
name|ap
operator|=
name|arr
operator|=
name|alloc
argument_list|(
operator|(
name|cnt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|arr
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|argv
init|;
operator|*
name|s
condition|;
name|s
operator|++
operator|,
name|ap
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"("
argument_list|)
condition|)
operator|*
name|ap
operator|=
name|TEST_INPAR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
literal|")"
argument_list|)
condition|)
operator|*
name|ap
operator|=
name|TEST_OUTPAR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"-a"
argument_list|)
condition|)
operator|*
name|ap
operator|=
name|TEST_AND
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"-o"
argument_list|)
condition|)
operator|*
name|ap
operator|=
name|TEST_OR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
literal|"!"
argument_list|)
condition|)
operator|*
name|ap
operator|=
name|TEST_NOT
expr_stmt|;
else|else
operator|*
name|ap
operator|=
name|TEST_STR
expr_stmt|;
operator|*
name|ap
operator|=
name|TEST_END
expr_stmt|;
name|tsp
operator|=
name|argv
expr_stmt|;
name|tip
operator|=
name|arr
expr_stmt|;
name|c
operator|=
name|partest
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tip
operator|!=
name|TEST_END
operator|||
name|errflag
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"parse error"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
operator|(
name|c
operator|)
condition|?
operator|!
name|evalcond
argument_list|(
name|c
argument_list|)
else|:
literal|1
return|;
block|}
end_function

begin_function
name|Cond
name|partest
parameter_list|(
name|level
parameter_list|)
comment|/**/
name|int
name|level
decl_stmt|;
block|{
name|Cond
name|a
decl_stmt|,
name|b
decl_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|0
case|:
name|a
operator|=
name|partest
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tip
operator|==
name|TEST_OR
condition|)
block|{
name|tip
operator|++
operator|,
name|tsp
operator|++
expr_stmt|;
name|b
operator|=
name|makecond
argument_list|()
expr_stmt|;
name|b
operator|->
name|left
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|right
operator|=
name|partest
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|COND_OR
expr_stmt|;
return|return
name|b
return|;
block|}
return|return
name|a
return|;
case|case
literal|1
case|:
name|a
operator|=
name|partest
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tip
operator|==
name|TEST_AND
condition|)
block|{
name|tip
operator|++
operator|,
name|tsp
operator|++
expr_stmt|;
name|b
operator|=
name|makecond
argument_list|()
expr_stmt|;
name|b
operator|->
name|left
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|right
operator|=
name|partest
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|COND_AND
expr_stmt|;
return|return
name|b
return|;
block|}
return|return
name|a
return|;
case|case
literal|2
case|:
if|if
condition|(
operator|*
name|tip
operator|==
name|TEST_NOT
condition|)
block|{
name|tip
operator|++
operator|,
name|tsp
operator|++
expr_stmt|;
name|b
operator|=
name|makecond
argument_list|()
expr_stmt|;
name|b
operator|->
name|left
operator|=
name|partest
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|COND_NOT
expr_stmt|;
return|return
name|b
return|;
block|}
case|case
literal|3
case|:
if|if
condition|(
operator|*
name|tip
operator|==
name|TEST_INPAR
condition|)
block|{
name|tip
operator|++
operator|,
name|tsp
operator|++
expr_stmt|;
name|b
operator|=
name|partest
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tip
operator|!=
name|TEST_OUTPAR
condition|)
block|{
name|zerrnam
argument_list|(
literal|"test"
argument_list|,
literal|"parse error"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tip
operator|++
operator|,
name|tsp
operator|++
expr_stmt|;
return|return
name|b
return|;
block|}
if|if
condition|(
name|tip
index|[
literal|0
index|]
operator|!=
name|TEST_STR
condition|)
block|{
name|zerrnam
argument_list|(
literal|"test"
argument_list|,
literal|"parse error"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|tip
index|[
literal|1
index|]
operator|!=
name|TEST_STR
condition|)
block|{
name|b
operator|=
name|makecond
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|tsp
argument_list|,
literal|"-t"
argument_list|)
condition|)
block|{
name|b
operator|->
name|left
operator|=
name|strdup
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
literal|'t'
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|left
operator|=
name|tsp
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|->
name|type
operator|=
literal|'n'
expr_stmt|;
block|}
name|tip
operator|++
operator|,
name|tsp
operator|++
expr_stmt|;
return|return
name|b
return|;
block|}
elseif|else
if|if
condition|(
name|tip
index|[
literal|2
index|]
operator|!=
name|TEST_STR
condition|)
block|{
name|b
operator|=
name|par_cond_double
argument_list|(
name|tsp
index|[
literal|0
index|]
argument_list|,
name|tsp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tip
operator|+=
literal|2
operator|,
name|tsp
operator|+=
literal|2
expr_stmt|;
return|return
name|b
return|;
block|}
else|else
block|{
name|b
operator|=
name|par_cond_triple
argument_list|(
name|tsp
index|[
literal|0
index|]
argument_list|,
name|tsp
index|[
literal|1
index|]
argument_list|,
name|tsp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tip
operator|+=
literal|3
operator|,
name|tsp
operator|+=
literal|3
expr_stmt|;
return|return
name|b
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|bin_compctl
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|Compctl
name|cc
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|usrkeys
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
operator|*
name|argv
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|;
name|argv
operator|++
control|)
while|while
condition|(
operator|*
operator|++
operator|(
operator|*
name|argv
operator|)
condition|)
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'c'
case|:
name|flags
operator||=
name|CC_COMMPATH
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flags
operator||=
name|CC_FILES
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|flags
operator||=
name|CC_HOSTS
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|flags
operator||=
name|CC_OPTIONS
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator||=
name|CC_VARS
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|flags
operator||=
name|CC_BINDINGS
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|flags
operator||=
name|CC_USRKEYS
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
name|usrkeys
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
expr_stmt|;
operator|*
name|argv
operator|=
literal|""
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"variable name expected after -k"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|usrkeys
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|""
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
name|cc
operator|=
operator|&
name|cc_compos
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|cc
operator|=
operator|&
name|cc_default
expr_stmt|;
break|break;
default|default:
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"bad option: %c"
argument_list|,
name|NULL
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|cc
condition|)
block|{
name|cc
operator|->
name|mask
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|keyvar
condition|)
name|free
argument_list|(
name|cc
operator|->
name|keyvar
argument_list|)
expr_stmt|;
name|cc
operator|->
name|keyvar
operator|=
name|ztrdup
argument_list|(
name|usrkeys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
if|if
condition|(
operator|!
name|cc
condition|)
block|{
name|showflag
operator|=
name|flags
expr_stmt|;
name|listhtable
argument_list|(
name|compctltab
argument_list|,
operator|(
name|HFunc
operator|)
name|printcompctl
argument_list|)
expr_stmt|;
name|printcompctl
argument_list|(
literal|"COMMAND"
argument_list|,
operator|&
name|cc_compos
argument_list|)
expr_stmt|;
name|printcompctl
argument_list|(
literal|"DEFAULT"
argument_list|,
operator|&
name|cc_default
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|compctl_process
argument_list|(
name|argv
argument_list|,
name|flags
argument_list|,
name|usrkeys
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|printcompctl
parameter_list|(
name|s
parameter_list|,
name|cc
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|Compctl
name|cc
decl_stmt|;
block|{
name|char
modifier|*
name|css
init|=
literal|"fchovb"
decl_stmt|;
if|if
condition|(
name|cc
operator|->
name|mask
operator|&
name|showflag
condition|)
block|{
name|puts
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|showflag
condition|)
block|{
name|int
name|flags
init|=
name|cc
operator|->
name|mask
decl_stmt|;
name|printf
argument_list|(
literal|"%s -"
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|css
condition|)
block|{
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|putchar
argument_list|(
operator|*
name|css
argument_list|)
expr_stmt|;
name|css
operator|++
expr_stmt|;
name|flags
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"k %s"
argument_list|,
name|cc
operator|->
name|keyvar
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|compctl_process
parameter_list|(
name|s
parameter_list|,
name|mask
parameter_list|,
name|uk
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|uk
decl_stmt|;
block|{
name|Compctl
name|cc
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|cc
operator|=
name|zalloc
argument_list|(
sizeof|sizeof
expr|*
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|cc
operator|->
name|keyvar
operator|=
name|ztrdup
argument_list|(
name|uk
argument_list|)
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|cc
argument_list|,
name|compctltab
argument_list|,
name|freecompctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bin_ttyctl
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|func
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
if|if
condition|(
name|ops
index|[
literal|'f'
index|]
operator|||
operator|!
name|ops
index|[
literal|'@'
index|]
condition|)
name|ttyfrozen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ops
index|[
literal|'u'
index|]
condition|)
name|ttyfrozen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

