begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Low level character input from the input file.  * We use these special purpose routines which optimize moving  * both forward and backward from the current read pointer.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
name|public
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of the input file */
end_comment

begin_decl_stmt
name|public
name|int
name|ignore_eoi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pool of buffers holding the most recently used blocks of the input file.  */
end_comment

begin_define
define|#
directive|define
name|BUFSIZ
value|1024
end_define

begin_struct
struct|struct
name|buf
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* Must be first to match struct filestate */
name|long
name|block
decl_stmt|;
name|unsigned
name|int
name|datasize
decl_stmt|;
name|unsigned
name|char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The buffer pool is kept as a doubly-linked circular list,  * in order from most- to least-recently used.  * The circular list is anchored by the file state "thisfile".  *  * The file state is maintained in a filestate structure.  * There are two such structures, one used when input is a pipe  * and the other when input is an ordinary file.  * This is so that we can leave a pipe, look and other files,  * and return to the pipe without losing buffered data.  * Buffered data can be reconstructed for a non-pipe file by  * simply re-reading the file, but a pipe cannot be re-read.  */
end_comment

begin_struct
struct|struct
name|filestate
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* Must be first to match struct buf */
name|POSITION
name|fpos
decl_stmt|;
name|int
name|nbufs
decl_stmt|;
name|long
name|block
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|POSITION
name|fsize
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|END_OF_CHAIN
value|((struct buf *)thisfile)
end_define

begin_define
define|#
directive|define
name|buf_head
value|thisfile->next
end_define

begin_define
define|#
directive|define
name|buf_tail
value|thisfile->prev
end_define

begin_define
define|#
directive|define
name|ch_nbufs
value|thisfile->nbufs
end_define

begin_define
define|#
directive|define
name|ch_block
value|thisfile->block
end_define

begin_define
define|#
directive|define
name|ch_offset
value|thisfile->offset
end_define

begin_define
define|#
directive|define
name|ch_fpos
value|thisfile->fpos
end_define

begin_define
define|#
directive|define
name|ch_fsize
value|thisfile->fsize
end_define

begin_decl_stmt
specifier|static
name|struct
name|filestate
name|pipefile
init|=
block|{
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|&
name|pipefile
block|,
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|&
name|pipefile
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filestate
name|nonpipefile
init|=
block|{
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|&
name|nonpipefile
block|,
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|&
name|nonpipefile
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filestate
modifier|*
name|thisfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|autobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_decl_stmt
specifier|extern
name|int
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|namelogfile
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ch_addbuf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get the character pointed to by the read pointer.  * ch_get() is a macro which is more efficient to call  * than fch_get (the function), in the usual case   * that the block desired is at the head of the chain.  */
end_comment

begin_define
define|#
directive|define
name|ch_get
parameter_list|()
value|((ch_block == buf_head->block&& \ 		     ch_offset< buf_head->datasize) ? \ 			buf_head->data[ch_offset] : fch_get())
end_define

begin_function
specifier|static
name|int
name|fch_get
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|slept
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|len
decl_stmt|;
name|slept
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Look for a buffer holding the desired block. 	 */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|ch_block
condition|)
block|{
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 				 * Need more data in this buffer. 				 */
goto|goto
name|read_more
goto|;
goto|goto
name|found
goto|;
block|}
comment|/* 	 * Block is not in a buffer.   	 * Take the least recently used buffer  	 * and read the desired block into it. 	 * If the LRU buffer has data in it,  	 * and autobuf is true, and input is a pipe,  	 * then try to allocate a new buffer first. 	 */
if|if
condition|(
name|autobuf
operator|&&
name|ispipe
operator|&&
name|buf_tail
operator|->
name|block
operator|!=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
if|if
condition|(
name|ch_addbuf
argument_list|(
literal|1
argument_list|)
condition|)
comment|/* 			 * Allocation failed: turn off autobuf. 			 */
name|autobuf
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buf_tail
expr_stmt|;
name|bp
operator|->
name|block
operator|=
name|ch_block
expr_stmt|;
name|bp
operator|->
name|datasize
operator|=
literal|0
expr_stmt|;
name|read_more
label|:
name|pos
operator|=
operator|(
name|ch_block
operator|*
name|BUFSIZ
operator|)
operator|+
name|bp
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>=
name|len
condition|)
comment|/* 		 * At end of file. 		 */
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|pos
operator|!=
name|ch_fpos
condition|)
block|{
comment|/* 		 * Not at the correct position: must seek. 		 * If input is a pipe, we're in trouble (can't seek on a pipe). 		 * Some data has been lost: just return "?". 		 */
if|if
condition|(
name|ispipe
condition|)
return|return
operator|(
literal|'?'
operator|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|file
argument_list|,
operator|(
name|offset_t
operator|)
name|pos
argument_list|,
literal|0
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
block|{
name|error
argument_list|(
literal|"seek error"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch_fpos
operator|=
name|pos
expr_stmt|;
block|}
comment|/* 	 * Read the block. 	 * If we read less than a full block, that's ok. 	 * We use partial block and pick up the rest next time. 	 */
name|n
operator|=
name|iread
argument_list|(
name|file
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|BUFSIZ
operator|-
name|bp
operator|->
name|datasize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|READ_INTR
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"read error"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch_fpos
operator|+=
name|n
expr_stmt|;
if|#
directive|if
name|LOGFILE
comment|/* 	 * If we have a log file, write the new data to it. 	 */
if|if
condition|(
name|logfile
operator|>=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
name|write
argument_list|(
name|logfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|datasize
operator|+=
name|n
expr_stmt|;
comment|/* 	 * If we have read to end of file, set ch_fsize to indicate 	 * the position of the end of file. 	 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|ch_fsize
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|ignore_eoi
condition|)
block|{
comment|/* 			 * We are ignoring EOF. 			 * Wait a while, then try again. 			 */
if|if
condition|(
operator|!
name|slept
condition|)
name|ierror
argument_list|(
literal|"Waiting for data"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|slept
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sigs
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
block|}
name|found
label|:
if|if
condition|(
name|buf_head
operator|!=
name|bp
condition|)
block|{
comment|/* 		 * Move the buffer to the head of the buffer chain. 		 * This orders the buffer chain, most- to least-recently used. 		 */
name|bp
operator|->
name|next
operator|->
name|prev
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
name|bp
operator|->
name|prev
operator|->
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|buf_head
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|buf_head
operator|->
name|prev
operator|=
name|bp
expr_stmt|;
name|buf_head
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 		 * After all that, we still don't have enough data. 		 * Go back and try again. 		 */
goto|goto
name|read_more
goto|;
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_comment
comment|/*  * Close the logfile.  * If we haven't read all of standard input into it, do that now.  */
end_comment

begin_function
name|public
name|void
name|end_logfile
parameter_list|()
block|{
specifier|static
name|int
name|tried
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|logfile
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|tried
operator|&&
name|ch_fsize
operator|==
name|NULL_POSITION
condition|)
block|{
name|tried
operator|=
literal|1
expr_stmt|;
name|ierror
argument_list|(
literal|"Finishing logfile"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|sigs
condition|)
break|break;
block|}
name|close
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
operator|-
literal|1
expr_stmt|;
name|namelogfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a log file AFTER less has already been running.  * Invoked from the - command; see toggle_option().  * Write all the existing buffered data to the log file.  */
end_comment

begin_function
name|public
name|void
name|sync_logfile
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|long
name|block
decl_stmt|;
name|long
name|last_block
decl_stmt|;
name|last_block
operator|=
operator|(
name|ch_fpos
operator|+
name|BUFSIZ
operator|-
literal|1
operator|)
operator|/
name|BUFSIZ
expr_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<=
name|last_block
condition|;
name|block
operator|++
control|)
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
block|{
name|write
argument_list|(
name|logfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|data
argument_list|,
name|bp
operator|->
name|datasize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determine if a specific block is currently in one of the buffers.  */
end_comment

begin_function
specifier|static
name|int
name|buffered
parameter_list|(
name|block
parameter_list|)
name|long
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to a specified position in the file.  * Return 0 if successful, non-zero if can't seek there.  */
end_comment

begin_function
name|public
name|int
name|ch_seek
parameter_list|(
name|pos
parameter_list|)
specifier|register
name|POSITION
name|pos
decl_stmt|;
block|{
name|long
name|new_block
decl_stmt|;
name|POSITION
name|len
decl_stmt|;
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|ch_zero
argument_list|()
operator|||
operator|(
name|len
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>
name|len
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|new_block
operator|=
name|pos
operator|/
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|ispipe
operator|&&
name|pos
operator|!=
name|ch_fpos
operator|&&
operator|!
name|buffered
argument_list|(
name|new_block
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Set read pointer. 	 */
name|ch_block
operator|=
name|new_block
expr_stmt|;
name|ch_offset
operator|=
name|pos
operator|%
name|BUFSIZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the end of the file.  */
end_comment

begin_function
name|public
name|int
name|ch_end_seek
parameter_list|()
block|{
name|POSITION
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ispipe
condition|)
name|ch_fsize
operator|=
name|filesize
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL_POSITION
condition|)
return|return
operator|(
name|ch_seek
argument_list|(
name|len
argument_list|)
operator|)
return|;
comment|/* 	 * Do it the slow way: read till end of data. 	 */
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|sigs
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the beginning of the file, or as close to it as we can get.  * We may not be able to seek there if input is a pipe and the  * beginning of the pipe is no longer buffered.  */
end_comment

begin_function
name|public
name|int
name|ch_beg_seek
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|firstbp
decl_stmt|;
comment|/* 	 * Try a plain ch_seek first. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|ch_zero
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Can't get to position 0. 	 * Look thru the buffers for the one closest to position 0. 	 */
name|firstbp
operator|=
name|bp
operator|=
name|buf_head
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|END_OF_CHAIN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bp
operator|->
name|next
operator|)
operator|!=
name|END_OF_CHAIN
condition|)
if|if
condition|(
name|bp
operator|->
name|block
operator|<
name|firstbp
operator|->
name|block
condition|)
name|firstbp
operator|=
name|bp
expr_stmt|;
name|ch_block
operator|=
name|firstbp
operator|->
name|block
expr_stmt|;
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of the file, if known.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_length
parameter_list|()
block|{
if|if
condition|(
name|ignore_eoi
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
return|return
operator|(
name|ch_fsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current position in the file.  */
end_comment

begin_define
define|#
directive|define
name|tellpos
parameter_list|(
name|blk
parameter_list|,
name|off
parameter_list|)
value|((POSITION)((((long)(blk)) * BUFSIZ) + (off)))
end_define

begin_function
name|public
name|POSITION
name|ch_tell
parameter_list|()
block|{
return|return
operator|(
name|tellpos
argument_list|(
name|ch_block
argument_list|,
name|ch_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current char and post-increment the read pointer.  */
end_comment

begin_function
name|public
name|int
name|ch_forw_get
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ch_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|ch_offset
operator|<
name|BUFSIZ
operator|-
literal|1
condition|)
name|ch_offset
operator|++
expr_stmt|;
else|else
block|{
if|#
directive|if
name|__ZOFFSET
comment|/* NOT WORKING */
if|if
condition|(
name|ch_fsize
operator|!=
name|NULL_POSITION
operator|&&
name|tellpos
argument_list|(
name|ch_block
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
operator|>=
name|ch_fsize
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
endif|#
directive|endif
name|ch_block
operator|++
expr_stmt|;
name|ch_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-decrement the read pointer and get the new current char.  */
end_comment

begin_function
name|public
name|int
name|ch_back_get
parameter_list|()
block|{
if|if
condition|(
name|ch_offset
operator|>
literal|0
condition|)
name|ch_offset
operator|--
expr_stmt|;
else|else
block|{
if|#
directive|if
name|__ZOFFSET
comment|/* NOT WORKING */
if|if
condition|(
name|tellpos
argument_list|(
name|ch_block
operator|-
literal|1
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|)
operator|<
name|ch_zero
argument_list|()
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|ch_block
operator|<=
literal|0
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|ispipe
operator|&&
operator|!
name|buffered
argument_list|(
name|ch_block
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
name|ch_block
operator|--
expr_stmt|;
name|ch_offset
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ch_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate buffers.  * Caller wants us to have a total of at least want_nbufs buffers.  */
end_comment

begin_function
name|public
name|int
name|ch_nbuf
parameter_list|(
name|want_nbufs
parameter_list|)
name|int
name|want_nbufs
decl_stmt|;
block|{
name|PARG
name|parg
decl_stmt|;
if|if
condition|(
name|ch_nbufs
operator|<
name|want_nbufs
operator|&&
name|ch_addbuf
argument_list|(
name|want_nbufs
operator|-
name|ch_nbufs
argument_list|)
condition|)
block|{
comment|/* 		 * Cannot allocate enough buffers. 		 * If we don't have ANY, then quit. 		 * Otherwise, just report the error and return. 		 */
name|parg
operator|.
name|p_int
operator|=
name|want_nbufs
operator|-
name|ch_nbufs
expr_stmt|;
name|error
argument_list|(
literal|"Cannot allocate %d buffers"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_nbufs
operator|==
literal|0
condition|)
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ch_nbufs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush any saved file state, including buffer contents.  */
end_comment

begin_function
name|public
name|void
name|ch_flush
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|ispipe
condition|)
block|{
comment|/* 		 * If input is a pipe, we don't flush buffer contents, 		 * since the contents can't be recovered. 		 */
name|ch_fsize
operator|=
name|NULL_POSITION
expr_stmt|;
return|return;
block|}
comment|/* 	 * Initialize all the buffers. 	 */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the size of the file, if we can. 	 */
name|ch_fsize
operator|=
name|filesize
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* 	 * Seek to a known position: the beginning of the file. 	 */
name|ch_fpos
operator|=
literal|0
expr_stmt|;
name|ch_block
operator|=
name|ch_fpos
operator|/
name|BUFSIZ
expr_stmt|;
name|ch_offset
operator|=
name|ch_fpos
operator|%
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|file
argument_list|,
operator|(
name|offset_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
block|{
comment|/* 		 * Warning only; even if the seek fails for some reason, 		 * there's a good chance we're at the beginning anyway. 		 * {{ I think this is bogus reasoning. }} 		 */
name|error
argument_list|(
literal|"seek error to 0"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate some new buffers.  * The buffers are added to the tail of the buffer chain.  */
end_comment

begin_function
specifier|static
name|int
name|ch_addbuf
parameter_list|(
name|nnew
parameter_list|)
name|int
name|nnew
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|newbufs
decl_stmt|;
comment|/* 	 * We don't have enough buffers.   	 * Allocate some new ones. 	 */
name|newbufs
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|calloc
argument_list|(
name|nnew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbufs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Initialize the new buffers and link them together. 	 * Link them all onto the tail of the buffer list. 	 */
name|ch_nbufs
operator|+=
name|nnew
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|newbufs
index|[
literal|0
index|]
init|;
name|bp
operator|<
operator|&
name|newbufs
index|[
name|nnew
index|]
condition|;
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|next
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|newbufs
index|[
name|nnew
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|newbufs
index|[
literal|0
index|]
operator|.
name|prev
operator|=
name|buf_tail
expr_stmt|;
name|buf_tail
operator|->
name|next
operator|=
operator|&
name|newbufs
index|[
literal|0
index|]
expr_stmt|;
name|buf_tail
operator|=
operator|&
name|newbufs
index|[
name|nnew
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use the pipe file state.  */
end_comment

begin_function
name|public
name|void
name|ch_pipe
parameter_list|()
block|{
name|thisfile
operator|=
operator|&
name|pipefile
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use the non-pipe file state.  */
end_comment

begin_function
name|public
name|void
name|ch_nonpipe
parameter_list|()
block|{
name|thisfile
operator|=
operator|&
name|nonpipefile
expr_stmt|;
block|}
end_function

end_unit

