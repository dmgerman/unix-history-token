begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|__MSDOS__
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISPIPE
parameter_list|(
name|fd
parameter_list|)
value|((fd)==0)
end_define

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|new_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errmsgs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_at_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|every_first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|any_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|force_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|old_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|scrpos
name|initial_scrpos
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_decl_stmt
specifier|extern
name|int
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|force_logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|namelogfile
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Edit a new file.  * Filename == "-" means standard input.  * Filename == NULL means just close the current file.  */
end_comment

begin_function
name|public
name|int
name|edit
parameter_list|(
name|filename
parameter_list|,
name|just_looking
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|just_looking
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|answer
decl_stmt|;
name|int
name|no_display
decl_stmt|;
name|struct
name|scrpos
name|scrpos
decl_stmt|;
name|PARG
name|parg
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Close the current file, but don't open a new one. 		 */
name|f
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*  		 * Use standard input. 		 */
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|parg
operator|.
name|p_string
operator|=
name|bad_file
argument_list|(
name|filename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parg
operator|.
name|p_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
name|__MSDOS__
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
block|}
end_function

begin_elseif
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|parg
operator|.
name|p_string
operator|=
name|errno_message
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parg
operator|.
name|p_string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|!
name|force_open
operator|&&
operator|!
name|just_looking
operator|&&
name|bin_file
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|answer
operator|=
name|query
argument_list|(
literal|"\"%s\" may be a binary file.  Continue? "
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|'y'
operator|&&
name|answer
operator|!=
literal|'Y'
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_elseif

begin_if
if|if
condition|(
name|f
operator|>=
literal|0
operator|&&
name|isatty
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* 		 * Not really necessary to call this an error, 		 * but if the control terminal (for commands) 		 * and the input file (for data) are the same, 		 * we get weird results at best. 		 */
if|#
directive|if
name|__MSDOS__
name|parg
operator|.
name|p_string
operator|=
literal|"less -?"
expr_stmt|;
else|#
directive|else
name|parg
operator|.
name|p_string
operator|=
literal|"less -\\?"
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
literal|"Cannot take input from a terminal (\"%s\" for help)"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISPIPE
argument_list|(
name|f
argument_list|)
condition|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_if

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_expr_stmt
name|s
operator|=
name|namelogfile
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|end_logfile
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|f
operator|>=
literal|0
operator|&&
name|ISPIPE
argument_list|(
name|f
argument_list|)
operator|&&
name|s
operator|!=
name|NULL
operator|&&
name|is_tty
condition|)
name|use_logfile
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * We are now committed to using the new file. 	 * Close the current input file and set up to use the new one. 	 */
end_comment

begin_if
if|if
condition|(
name|curr_ifile
operator|!=
name|NULL_IFILE
condition|)
block|{
comment|/* 		 * Save the current position so that we can return to 		 * the same position if we edit this file again. 		 */
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrpos
operator|.
name|pos
operator|!=
name|NULL_POSITION
condition|)
block|{
name|store_pos
argument_list|(
name|curr_ifile
argument_list|,
operator|&
name|scrpos
argument_list|)
expr_stmt|;
name|lastmark
argument_list|()
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* 	 * Close the current file, unless it is a pipe. 	 */
end_comment

begin_if
if|if
condition|(
operator|!
name|ISPIPE
argument_list|(
name|file
argument_list|)
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|file
operator|=
name|f
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|f
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
end_if

begin_comment
comment|/* 	 * Get the new ifile. 	 * Get the saved position for that file. 	 */
end_comment

begin_expr_stmt
name|old_ifile
operator|=
name|curr_ifile
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curr_ifile
operator|=
name|get_ifile
argument_list|(
name|filename
argument_list|,
name|curr_ifile
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|get_pos
argument_list|(
name|curr_ifile
argument_list|,
operator|&
name|initial_scrpos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ispipe
operator|=
name|ISPIPE
argument_list|(
name|f
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ispipe
condition|)
name|ch_pipe
argument_list|()
expr_stmt|;
else|else
name|ch_nonpipe
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|ch_nbuf
argument_list|(
name|cbufs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ch_flush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|new_file
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|__MSDOS__
end_if

begin_expr_stmt
name|top_filename
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|every_first_cmd
operator|!=
name|NULL
condition|)
name|ungetsc
argument_list|(
name|every_first_cmd
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|no_display
operator|=
operator|!
name|any_display
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|any_display
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|is_tty
condition|)
block|{
comment|/* 		 * Output is to a real tty. 		 */
comment|/* 		 * Indicate there is nothing displayed yet. 		 */
name|pos_clear
argument_list|()
expr_stmt|;
name|clr_linenum
argument_list|()
expr_stmt|;
if|if
condition|(
name|no_display
operator|&&
name|errmsgs
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We displayed some messages on error output 			 * (file descriptor 2; see error() function). 			 * Before erasing the screen contents, 			 * display the file name and wait for a keystroke. 			 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Edit a space-separated list of files.  * For each filename in the list, enter it into the ifile list.  * Then edit the first one.  */
end_comment

begin_function
unit|public
name|void
name|edit_list
parameter_list|(
name|list
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|es
decl_stmt|;
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|good_filename
decl_stmt|;
name|IFILE
name|save_curr_ifile
decl_stmt|;
comment|/* 	 * good_filename keeps track of the first valid filename. 	 */
name|good_filename
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|list
expr_stmt|;
name|es
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|save_curr_ifile
operator|=
name|curr_ifile
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|skipsp
argument_list|(
name|s
argument_list|)
operator|)
operator|<
name|es
condition|)
block|{
comment|/* 		 * Get the next filename and null terminate it. 		 */
name|filename
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Try to edit the file. 		 * This enters it into the command line list (if it is good). 		 * If it is the first good file we've seen, remember it. 		 * {{ A little weirdness here: if any of the filenames 		 *    are already in the list, subsequent ones get 		 *    entered after the position where that one already 		 *    was, instead of at the end. }} 		 */
if|if
condition|(
name|edit
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|good_filename
operator|==
name|NULL
condition|)
name|good_filename
operator|=
name|filename
expr_stmt|;
block|}
comment|/* 	 * Edit the first valid filename in the list. 	 */
if|if
condition|(
name|good_filename
operator|!=
name|NULL
condition|)
block|{
name|curr_ifile
operator|=
name|save_curr_ifile
expr_stmt|;
operator|(
name|void
operator|)
name|edit
argument_list|(
name|good_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Edit the first file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_first
parameter_list|()
block|{
name|curr_ifile
operator|=
name|NULL_IFILE
expr_stmt|;
return|return
operator|(
name|edit_next
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit the last file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_last
parameter_list|()
block|{
name|curr_ifile
operator|=
name|NULL_IFILE
expr_stmt|;
return|return
operator|(
name|edit_prev
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit the next file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_next
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|IFILE
name|h
decl_stmt|;
name|h
operator|=
name|curr_ifile
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|||
name|edit
argument_list|(
name|get_filename
argument_list|(
name|h
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|next_ifile
argument_list|(
name|h
argument_list|)
operator|)
operator|==
name|NULL_IFILE
condition|)
comment|/* 			 * Reached end of the ifile list. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Found a file that we can edit. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit the previous file in the command line list.  */
end_comment

begin_function
name|public
name|int
name|edit_prev
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|IFILE
name|h
decl_stmt|;
name|h
operator|=
name|curr_ifile
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|||
name|edit
argument_list|(
name|get_filename
argument_list|(
name|h
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|prev_ifile
argument_list|(
name|h
argument_list|)
operator|)
operator|==
name|NULL_IFILE
condition|)
comment|/* 			 * Reached beginning of the ifile list. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Found a file that we can edit. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit a specific file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_index
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|IFILE
name|h
decl_stmt|;
name|h
operator|=
name|NULL_IFILE
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|next_ifile
argument_list|(
name|h
argument_list|)
operator|)
operator|==
name|NULL_IFILE
condition|)
block|{
comment|/* 			 * Reached end of the list without finding it. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|get_index
argument_list|(
name|h
argument_list|)
operator|!=
name|n
condition|)
do|;
return|return
operator|(
name|edit
argument_list|(
name|get_filename
argument_list|(
name|h
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a file directly to standard output.  * Used if standard output is not a tty.  */
end_comment

begin_function
name|public
name|void
name|cat_file
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|!=
name|EOI
condition|)
name|putchr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_comment
comment|/*  * If the user asked for a log file and our input file  * is standard input, create the log file.    * We take care not to blindly overwrite an existing file.  */
end_comment

begin_function
name|public
name|void
name|use_logfile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|exists
decl_stmt|;
specifier|register
name|int
name|answer
decl_stmt|;
name|PARG
name|parg
decl_stmt|;
comment|/* 	 * {{ We could use access() here. }} 	 */
name|exists
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|exists
argument_list|)
expr_stmt|;
name|exists
operator|=
operator|(
name|exists
operator|>=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Decide whether to overwrite the log file or append to it. 	 * (If it doesn't exist we "overwrite" it. 	 */
if|if
condition|(
operator|!
name|exists
operator|||
name|force_logfile
condition|)
block|{
comment|/* 		 * Overwrite (or create) the log file. 		 */
name|answer
operator|=
literal|'O'
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Ask user what to do. 		 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|answer
operator|=
name|query
argument_list|(
literal|"Warning: \"%s\" exists; Overwrite, Append or Don't log? "
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
name|loop
label|:
switch|switch
condition|(
name|answer
condition|)
block|{
case|case
literal|'O'
case|:
case|case
literal|'o'
case|:
comment|/* 		 * Overwrite: create the file. 		 */
name|logfile
operator|=
name|creat
argument_list|(
name|filename
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
comment|/* 		 * Append: open the file and seek to the end. 		 */
if|#
directive|if
name|__MSDOS__
name|logfile
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_APPEND
operator||
name|O_WRONLY
argument_list|)
expr_stmt|;
else|#
directive|else
name|logfile
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lseek
argument_list|(
name|logfile
argument_list|,
operator|(
name|offset_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
block|{
name|close
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
comment|/* 		 * Don't do anything. 		 */
return|return;
case|case
literal|'q'
case|:
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
comment|/* 		 * Eh? 		 */
name|answer
operator|=
name|query
argument_list|(
literal|"Overwrite, Append, or Don't log? "
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|logfile
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Error in opening logfile. 		 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|error
argument_list|(
literal|"Cannot write to \"%s\""
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

