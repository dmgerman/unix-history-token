begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/sh.c,v 3.20 1991/12/19 22:34:14 christos Exp $ */
end_comment

begin_comment
comment|/*  * sh.c: Main shell routines  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1980, 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/* Intern */
end_comment

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1991 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_macro
name|RCSID
argument_list|(
literal|"$Id: sh.c,v 3.20 1991/12/19 22:34:14 christos Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"tc.h"
end_include

begin_include
include|#
directive|include
file|"ed.h"
end_include

begin_decl_stmt
specifier|extern
name|bool
name|MapsAreInited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|NLSMapsAreInited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|NoNLSRebind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * C Shell  *  * Bill Joy, UC Berkeley, California, USA  * October 1978, May 1980  *  * Jim Kulp, IIASA, Laxenburg, Austria  * April 1980  *  * Filename recognition added:  * Ken Greer, Ind. Consultant, Palo Alto CA  * October 1983.  *  * Karl Kleinpaste, Computer Consoles, Inc.  * Added precmd, periodic/tperiod, prompt changes,  * directory stack hack, and login watch.  * Sometime March 1983 - Feb 1984.  *  * Added scheduled commands, including the "sched" command,  * plus the call to sched_run near the precmd et al  * routines.  * Upgraded scheduled events for running events while  * sitting idle at command input.  *  * Paul Placeway, Ohio State  * added stuff for running with twenex/inputl  9 Oct 1984.  *  * ported to Apple Unix (TM) (OREO)  26 -- 29 Jun 1987  */
end_comment

begin_decl_stmt
name|jmp_buf
name|reslab
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TESLA
end_ifdef

begin_decl_stmt
name|int
name|do_logout
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TESLA */
end_comment

begin_decl_stmt
name|Char
modifier|*
name|dumphist
index|[]
init|=
block|{
name|STRhistory
block|,
name|STRmh
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|loadhist
index|[]
init|=
block|{
name|STRsource
block|,
name|STRmh
block|,
name|STRtildothist
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CSHDIRS
end_ifdef

begin_decl_stmt
name|Char
modifier|*
name|loaddirs
index|[]
init|=
block|{
name|STRsource
block|,
name|STRdirfile
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|convex
argument_list|)
operator|||
name|defined
argument_list|(
name|__convex__
argument_list|)
end_if

begin_decl_stmt
name|bool
name|use_fork
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use fork() instead of vfork()? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nofile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|reenter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|nverbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|nexececho
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|quitit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|fast
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|batch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|prompt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|enterhist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|tellwhat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|t_period
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|srccat
name|__P
argument_list|(
operator|(
name|Char
operator|*
operator|,
name|Char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|srcfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigret_t
name|phup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|srcunit
name|__P
argument_list|(
operator|(
name|int
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mailchk
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Char
modifier|*
modifier|*
name|defaultpath
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOLOGOUT
specifier|register
name|Char
modifier|*
name|cp2
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|tcp
decl_stmt|,
modifier|*
name|ttyn
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|tempv
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDSIGS
name|sigvec_t
name|osv
decl_stmt|;
endif|#
directive|endif
comment|/* BSDSIGS */
name|settimes
argument_list|()
expr_stmt|;
comment|/* Immed. estab. timing base */
ifdef|#
directive|ifdef
name|TESLA
name|do_logout
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TESLA */
name|osinit
argument_list|()
expr_stmt|;
comment|/* Os dependent initialization */
comment|/*      * Initialize non constant strings      */
ifdef|#
directive|ifdef
name|_PATH_BSHELL
name|STR_BSHELL
operator|=
name|SAVE
argument_list|(
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_CSHELL
name|STR_SHELLPATH
operator|=
name|SAVE
argument_list|(
name|_PATH_CSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_TCSHELL
name|STR_SHELLPATH
operator|=
name|SAVE
argument_list|(
name|_PATH_TCSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STR_environ
operator|=
name|blk2short
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|short2blk
argument_list|(
name|STR_environ
argument_list|)
expr_stmt|;
comment|/* So that we can free it */
name|STR_WORD_CHARS
operator|=
name|SAVE
argument_list|(
name|WORD_CHARS
argument_list|)
expr_stmt|;
name|HIST
operator|=
literal|'!'
expr_stmt|;
name|HISTSUB
operator|=
literal|'^'
expr_stmt|;
name|word_chars
operator|=
name|STR_WORD_CHARS
expr_stmt|;
name|bslash_quote
operator|=
literal|0
expr_stmt|;
comment|/* PWP: do tcsh-style backslash quoting? */
name|tempv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|str2short
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|STRaout
argument_list|)
condition|)
comment|/* A.out's are quittable */
name|quitit
operator|=
literal|1
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
comment|/*      * We are a login shell if: 1. we were invoked as -<something> and we had      * no arguments 2. or we were invoked only with the -l flag      */
name|loginsh
operator|=
operator|(
operator|*
operator|*
name|tempv
operator|==
literal|'-'
operator|&&
name|argc
operator|==
literal|1
operator|)
operator|||
operator|(
name|argc
operator|==
literal|2
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
if|if
condition|(
name|loginsh
operator|&&
operator|*
operator|*
name|tempv
operator|!=
literal|'-'
condition|)
block|{
comment|/* 	 * Mangle the argv space 	 */
name|tempv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tcp
operator|=
operator|*
name|tempv
init|;
operator|*
name|tcp
operator|++
condition|;
control|)
empty_stmt|;
for|for
control|(
name|tcp
operator|--
init|;
name|tcp
operator|>=
operator|*
name|tempv
condition|;
name|tcp
operator|--
control|)
name|tcp
index|[
literal|1
index|]
operator|=
name|tcp
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|++
name|tcp
operator|=
literal|'-'
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|chktim
argument_list|)
expr_stmt|;
name|AsciiOnly
operator|=
literal|1
expr_stmt|;
name|NoNLSRebind
operator|=
name|getenv
argument_list|(
literal|"NOREBIND"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NLS
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0200
init|;
name|k
operator|<=
literal|0377
operator|&&
operator|!
name|Isprint
argument_list|(
name|k
argument_list|)
condition|;
name|k
operator|++
control|)
empty_stmt|;
name|AsciiOnly
operator|=
name|k
operator|>
literal|0377
expr_stmt|;
block|}
else|#
directive|else
name|AsciiOnly
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|==
name|NULL
operator|&&
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|==
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* NLS */
if|if
condition|(
name|MapsAreInited
operator|&&
operator|!
name|NLSMapsAreInited
condition|)
name|ed_InitNLSMaps
argument_list|()
expr_stmt|;
comment|/*      * Initialize for periodic command intervals. Also, initialize the dummy      * tty list for login-watch.      */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t_period
argument_list|)
expr_stmt|;
name|initwatch
argument_list|()
expr_stmt|;
comment|/*      * Move the descriptors to safe places. The variable didfds is 0 while we      * have only FSH* to work with. When didfds is true, we have 0,1,2 and      * prefer to use these.      */
name|initdesc
argument_list|()
expr_stmt|;
comment|/*      * Get and set the tty now      */
if|if
condition|(
name|ttyn
operator|=
name|ttyname
argument_list|(
name|SHIN
argument_list|)
condition|)
block|{
comment|/* 	 * Could use rindex to get rid of other possible path components, but 	 * hpux preserves the subdirectory /pty/ when storing the tty name in 	 * utmp, so we keep it too. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|ttyn
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|set
argument_list|(
name|STRtty
argument_list|,
name|cp
operator|=
name|SAVE
argument_list|(
name|ttyn
operator|+
literal|5
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set
argument_list|(
name|STRtty
argument_list|,
name|cp
operator|=
name|SAVE
argument_list|(
name|ttyn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|set
argument_list|(
name|STRtty
argument_list|,
name|cp
operator|=
name|SAVE
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Initialize the shell variables. ARGV and PROMPT are initialized later.      * STATUS is also munged in several places. CHILD is munged when      * forking/waiting      */
comment|/*      * 7-10-87 Paul Placeway autologout should be set ONLY on login shells and      * on shells running as root.  Out of these, autologout should NOT be set      * for any psudo-terminals (this catches most window systems) and not for      * any terminal running X windows.      *       * At Ohio State, we have had problems with a user having his X session       * drop out from under him (on a Sun) because the shell in his master       * xterm timed out and exited.      *       * Really, this should be done with a program external to the shell, that      * watches for no activity (and NO running programs, such as dump) on a      * terminal for a long peroid of time, and then SIGHUPS the shell on that      * terminal.      *       * bugfix by Rich Salz<rsalz@PINEAPPLE.BBN.COM>: For root rsh things       * allways first check to see if loginsh or really root, then do things       * with ttyname()      *       * Also by Jean-Francois Lamy<lamy%ai.toronto.edu@RELAY.CS.NET>: check the      * value of cp before using it! ("root can rsh too")      *       * PWP: keep the nested ifs; the order of the tests matters and a good       * (smart) C compiler might re-arange things wrong.      */
ifdef|#
directive|ifdef
name|AUTOLOGOUT
if|if
condition|(
name|loginsh
operator|||
operator|(
name|uid
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* only for login shells or root and we must have a tty */
if|if
condition|(
operator|(
name|cp2
operator|=
name|Strrchr
argument_list|(
name|cp
argument_list|,
operator|(
name|Char
operator|)
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|Strncmp
argument_list|(
name|cp
argument_list|,
name|STRtty
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cp
index|[
literal|3
index|]
operator|>=
literal|'p'
operator|&&
name|cp
index|[
literal|3
index|]
operator|<=
literal|'u'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* NOT on X window shells */
name|set
argument_list|(
name|STRautologout
argument_list|,
name|Strsave
argument_list|(
name|STRdefautologout
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* AUTOLOGOUT */
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGALRM
argument_list|,
name|alrmcatch
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRstatus
argument_list|,
name|Strsave
argument_list|(
name|STR0
argument_list|)
argument_list|)
expr_stmt|;
name|fix_version
argument_list|()
expr_stmt|;
comment|/* publish the shell version */
comment|/*      * increment the shell level.      */
name|shlvl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|SAVE
argument_list|(
name|tcp
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|fast
operator|=
literal|1
expr_stmt|;
comment|/* No home -> can't read scripts */
else|else
name|set
argument_list|(
name|STRhome
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dinit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* dinit thinks that HOME == cwd in a login 				 * shell */
comment|/*      * Grab other useful things from the environment. Should we grab      * everything??      */
block|{
name|char
modifier|*
name|cln
decl_stmt|,
modifier|*
name|cus
decl_stmt|;
name|Char
name|buff
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|apollo
name|int
name|oid
init|=
name|getoid
argument_list|()
decl_stmt|;
name|Itoa
argument_list|(
name|oid
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRoid
argument_list|,
name|Strsave
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
name|Itoa
argument_list|(
name|uid
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRuid
argument_list|,
name|Strsave
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|Itoa
argument_list|(
name|gid
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRgid
argument_list|,
name|Strsave
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|cln
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
name|cus
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cus
operator|!=
name|NULL
condition|)
name|set
argument_list|(
name|STRuser
argument_list|,
name|SAVE
argument_list|(
name|cus
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cln
operator|!=
name|NULL
condition|)
name|set
argument_list|(
name|STRuser
argument_list|,
name|SAVE
argument_list|(
name|cln
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|set
argument_list|(
name|STRuser
argument_list|,
name|SAVE
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set
argument_list|(
name|STRuser
argument_list|,
name|SAVE
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cln
operator|==
name|NULL
condition|)
name|Setenv
argument_list|(
name|STRLOGNAME
argument_list|,
name|value
argument_list|(
name|STRuser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cus
operator|==
name|NULL
condition|)
name|Setenv
argument_list|(
name|STRUSER
argument_list|,
name|value
argument_list|(
name|STRuser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * HOST may be wrong, since rexd transports the entire environment on sun      * 3.x Just set it again      */
block|{
name|char
name|cbuff
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|cbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuff
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|cbuff
index|[
sizeof|sizeof
argument_list|(
name|cbuff
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
name|Setenv
argument_list|(
name|STRHOST
argument_list|,
name|str2short
argument_list|(
name|cbuff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Setenv
argument_list|(
name|STRHOST
argument_list|,
name|str2short
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * HOSTTYPE, too. Just set it again.      */
name|Setenv
argument_list|(
name|STRHOSTTYPE
argument_list|,
name|gethosttype
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"SYSTYPE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tcp
operator|=
literal|"bsd4.3"
expr_stmt|;
name|Setenv
argument_list|(
name|STRSYSTYPE
argument_list|,
name|str2short
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
comment|/*      * set editing on by default, unless running under Emacs as an inferior      * shell.      * We try to do this intelligently. If $TERM is available, then it      * should determine if we should edit or not. $TERM is preserved      * across rlogin sessions, so we will not get confused if we rlogin      * under an emacs shell. Another advantage is that if we run an      * xterm under an emacs shell, then the $TERM will be set to       * xterm, so we are going to want to edit. Unfortunately emacs      * does not restore all the tty modes, so xterm is not very well      * set up. But this is not the shell's fault.      */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|set
argument_list|(
name|STRterm
argument_list|,
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|editing
operator|=
operator|(
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"emacs"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
name|editing
operator|=
operator|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|tcp
argument_list|,
literal|"t"
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/*       * The 'edit' variable is either set or unset.  It doesn't       * need a value.  Making it 'emacs' might be confusing.       */
if|if
condition|(
name|editing
condition|)
name|set
argument_list|(
name|STRedit
argument_list|,
name|Strsave
argument_list|(
name|STRNULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * still more mutability: make the complete routine automatically add the      * suffix of file names...      */
name|set
argument_list|(
name|STRaddsuffix
argument_list|,
name|Strsave
argument_list|(
name|STRNULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Re-initialize path if set in environment      */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|set1
argument_list|(
name|STRpath
argument_list|,
name|defaultpath
argument_list|()
argument_list|,
operator|&
name|shvhed
argument_list|)
expr_stmt|;
else|else
name|importpath
argument_list|(
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRshell
argument_list|,
name|Strsave
argument_list|(
name|STR_SHELLPATH
argument_list|)
argument_list|)
expr_stmt|;
name|doldol
operator|=
name|putn
argument_list|(
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* For $$ */
name|shtemp
operator|=
name|Strspl
argument_list|(
name|STRtmpsh
argument_list|,
name|doldol
argument_list|)
expr_stmt|;
comment|/* For<< */
comment|/*      * Record the interrupt states from the parent process. If the parent is      * non-interruptible our hand must be forced or we (and our children) won't      * be either. Our children inherit termination from our parent. We catch it      * only if we are the login shell.      */
ifdef|#
directive|ifdef
name|BSDSIGS
comment|/* parents interruptibility */
operator|(
name|void
operator|)
name|mysigvec
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|parintr
operator|=
operator|(
name|sigret_t
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|osv
operator|.
name|sv_handler
expr_stmt|;
operator|(
name|void
operator|)
name|mysigvec
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|parterm
operator|=
operator|(
name|sigret_t
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|osv
operator|.
name|sv_handler
expr_stmt|;
else|#
directive|else
comment|/* BSDSIGS */
name|parintr
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* parents interruptibility */
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|parintr
argument_list|)
expr_stmt|;
comment|/* ... restore */
name|parterm
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* parents terminability */
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGTERM
argument_list|,
name|parterm
argument_list|)
expr_stmt|;
comment|/* ... restore */
endif|#
directive|endif
comment|/* BSDSIGS */
if|if
condition|(
name|loginsh
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|phup
argument_list|)
expr_stmt|;
comment|/* exit processing on HUP */
ifdef|#
directive|ifdef
name|SIGXCPU
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGXCPU
argument_list|,
name|phup
argument_list|)
expr_stmt|;
comment|/* ...and on XCPU */
endif|#
directive|endif
comment|/* SIGXCPU */
ifdef|#
directive|ifdef
name|SIGXFSZ
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|phup
argument_list|)
expr_stmt|;
comment|/* ...and on XFSZ */
endif|#
directive|endif
comment|/* SIGXFSZ */
block|}
ifdef|#
directive|ifdef
name|TCF
comment|/* Enable process migration on ourselves and our progeny */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGMIGRATE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TCF */
comment|/*      * Process the arguments.      *       * Note that processing of -v/-x is actually delayed till after script      * processing.      *       * We set the first character of our name to be '-' if we are a shell running      * interruptible commands.  Many programs which examine ps'es use this to      * filter such shells out.      */
name|argc
operator|--
operator|,
name|tempv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|tcp
operator|=
name|tempv
index|[
literal|0
index|]
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|*
operator|++
name|tcp
operator|!=
literal|'\0'
operator|&&
operator|!
name|batch
condition|)
block|{
do|do
switch|switch
condition|(
operator|*
name|tcp
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* -	Interruptible, no prompt */
name|prompt
operator|=
literal|0
expr_stmt|;
name|setintr
operator|=
literal|1
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* -b	Next arg is input file */
name|batch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* -c	Command input from arg */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|tempv
operator|++
expr_stmt|;
name|arginp
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * * Give an error on -c arguments that end in * backslash to 		 * ensure that you don't make * nonportable csh scripts. 		 */
block|{
specifier|register
name|Char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|cp
operator|=
name|arginp
operator|+
name|Strlen
argument_list|(
name|arginp
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|arginp
operator|&&
operator|*
operator|--
name|cp
operator|==
literal|'\\'
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|exiterr
operator|=
literal|1
expr_stmt|;
name|stderror
argument_list|(
name|ERR_ARGC
argument_list|)
expr_stmt|;
block|}
block|}
name|prompt
operator|=
literal|0
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|apollo
case|case
literal|'D'
case|:
comment|/* -D	Define environment variable */
block|{
specifier|register
name|Char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|cp
operator|=
name|str2short
argument_list|(
name|tcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|=
name|Strchr
argument_list|(
name|cp
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Setenv
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
name|Setenv
argument_list|(
name|cp
argument_list|,
name|STRNULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|tcp
operator|=
literal|'\0'
expr_stmt|;
comment|/* done with this argument */
break|break;
endif|#
directive|endif
comment|/* apollo */
ifdef|#
directive|ifdef
name|CSHDIRS
case|case
literal|'d'
case|:
comment|/* -d   Force load of ~/.cshdirs */
name|dflag
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
comment|/* -e	Exit on any error */
name|exiterr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* -f	Fast start */
name|fast
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* -i	Interactive, even if !intty */
name|intact
operator|=
literal|1
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* -m	read .cshrc (from su) */
name|mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* -n	Don't execute */
name|noexec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* -q	(Undoc'd) ... die on quit */
name|quitit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* -s	Read from std input */
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* -t	Read one line from input */
name|onelflg
operator|=
literal|2
expr_stmt|;
name|prompt
operator|=
literal|0
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -v	Echo hist expanded input */
name|nverbose
operator|=
literal|1
expr_stmt|;
comment|/* ... later */
break|break;
case|case
literal|'x'
case|:
comment|/* -x	Echo just before execution */
name|nexececho
operator|=
literal|1
expr_stmt|;
comment|/* ... later */
break|break;
case|case
literal|'V'
case|:
comment|/* -V	Echo hist expanded input */
name|setNS
argument_list|(
name|STRverbose
argument_list|)
expr_stmt|;
comment|/* NOW! */
break|break;
case|case
literal|'X'
case|:
comment|/* -X	Echo just before execution */
name|setNS
argument_list|(
name|STRecho
argument_list|)
expr_stmt|;
comment|/* NOW! */
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__convex__
argument_list|)
operator|||
name|defined
argument_list|(
name|convex
argument_list|)
case|case
literal|'F'
case|:
comment|/* Undocumented flag */
comment|/* 		 * This will cause children to be created using fork instead of 		 * vfork. 		 */
name|use_fork
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unknown command option */
name|exiterr
operator|=
literal|1
expr_stmt|;
name|stderror
argument_list|(
name|ERR_TCSHUSAGE
argument_list|,
name|tcp
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|*
name|tcp
condition|)
do|;
name|tempv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|quitit
condition|)
comment|/* With all due haste, for debugging */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/*      * Unless prevented by -, -c, -i, -s, or -t, if there are remaining      * arguments the first of them is the name of a shell file from which to      * read commands.      */
if|if
condition|(
name|nofile
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
name|nofile
operator|=
name|open
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|nofile
operator|<
literal|0
condition|)
block|{
name|child
operator|=
literal|1
expr_stmt|;
comment|/* So this ... */
comment|/* ... doesn't return */
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tempv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffile
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*  	 * Replace FSHIN. Handle /dev/std{in,out,err} specially 	 * since once they are closed we cannot open them again. 	 * In that case we use our own saved descriptors 	 */
if|if
condition|(
operator|(
name|SHIN
operator|=
name|dmove
argument_list|(
name|nofile
argument_list|,
name|FSHIN
argument_list|)
operator|)
operator|<
literal|0
condition|)
switch|switch
condition|(
name|nofile
condition|)
block|{
case|case
literal|0
case|:
name|SHIN
operator|=
name|FSHIN
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|SHIN
operator|=
name|FSHOUT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|SHIN
operator|=
name|FSHDIAG
expr_stmt|;
break|break;
default|default:
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tempv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|FIOCLEX
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHIN
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prompt
operator|=
literal|0
expr_stmt|;
comment|/* argc not used any more */
name|tempv
operator|++
expr_stmt|;
block|}
comment|/*      * Consider input a tty if it really is or we are interactive. but not for      * editing (christos)      */
if|if
condition|(
operator|!
operator|(
name|intty
operator|=
name|isatty
argument_list|(
name|SHIN
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|adrof
argument_list|(
name|STRedit
argument_list|)
condition|)
name|unsetv
argument_list|(
name|STRedit
argument_list|)
expr_stmt|;
name|editing
operator|=
literal|0
expr_stmt|;
block|}
name|intty
operator||=
name|intact
expr_stmt|;
if|if
condition|(
name|intty
operator|||
operator|(
name|intact
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|batch
operator|&&
operator|(
name|uid
operator|!=
name|geteuid
argument_list|()
operator|||
name|gid
operator|!=
name|getegid
argument_list|()
operator|)
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
name|child
operator|=
literal|1
expr_stmt|;
comment|/* So this ... */
comment|/* ... doesn't return */
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
literal|"tcsh"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|isoutatty
operator|=
name|isatty
argument_list|(
name|SHOUT
argument_list|)
expr_stmt|;
name|isdiagatty
operator|=
name|isatty
argument_list|(
name|SHDIAG
argument_list|)
expr_stmt|;
comment|/*      * Decide whether we should play with signals or not. If we are explicitly      * told (via -i, or -) or we are a login shell (arg0 starts with -) or the      * input and output are both the ttys("csh", or "csh</dev/ttyx>/dev/ttyx")      * Note that in only the login shell is it likely that parent may have set      * signals to be ignored      */
if|if
condition|(
name|loginsh
operator|||
name|intact
operator|||
operator|(
name|intty
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
condition|)
name|setintr
operator|=
literal|1
expr_stmt|;
name|settell
argument_list|()
expr_stmt|;
comment|/*      * Save the remaining arguments in argv.      */
name|setq
argument_list|(
name|STRargv
argument_list|,
name|blk2short
argument_list|(
name|tempv
argument_list|)
argument_list|,
operator|&
name|shvhed
argument_list|)
expr_stmt|;
comment|/*      * Set up the prompt.      */
if|if
condition|(
name|prompt
condition|)
block|{
name|set
argument_list|(
name|STRprompt
argument_list|,
name|Strsave
argument_list|(
name|uid
operator|==
literal|0
condition|?
name|STRsymhash
else|:
name|STRsymarrow
argument_list|)
argument_list|)
expr_stmt|;
comment|/* that's a meta-questionmark */
name|set
argument_list|(
name|STRprompt2
argument_list|,
name|Strsave
argument_list|(
name|STRmquestion
argument_list|)
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRprompt3
argument_list|,
name|Strsave
argument_list|(
name|STRCORRECT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we are an interactive shell, then start fiddling with the signals;      * this is a tricky game.      */
name|shpgrp
operator|=
name|mygetpgrp
argument_list|()
expr_stmt|;
name|opgrp
operator|=
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
operator|*
operator|*
name|argv
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
operator|!
name|quitit
condition|)
comment|/* Wary! */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|pintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|quitit
operator|==
literal|0
operator|&&
name|arginp
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTIN
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	     * Wait till in foreground, in case someone stupidly runs csh& 	     * dont want to try to grab away the tty. 	     */
if|if
condition|(
name|isatty
argument_list|(
name|FSHDIAG
argument_list|)
condition|)
name|f
operator|=
name|FSHDIAG
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|FSHOUT
argument_list|)
condition|)
name|f
operator|=
name|FSHOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|OLDSTD
argument_list|)
condition|)
name|f
operator|=
name|OLDSTD
expr_stmt|;
else|else
name|f
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NeXT
comment|/* NeXT 2.0 /usr/etc/rlogind, does not set our process group! */
if|if
condition|(
name|shpgrp
operator|==
literal|0
condition|)
block|{
name|shpgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NeXT */
ifdef|#
directive|ifdef
name|BSDJOBS
comment|/* if we have tty job control */
name|retry
label|:
if|if
condition|(
operator|(
name|tpgrp
operator|=
name|tcgetpgrp
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tpgrp
operator|!=
name|shpgrp
condition|)
block|{
name|sigret_t
function_decl|(
modifier|*
name|old
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
function_decl|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|old
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* 		 * Thanks to Matt Day for the POSIX references, and to 		 * Paul Close for the SGI clarification. 		 */
if|if
condition|(
name|setdisc
argument_list|(
name|f
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|opgrp
operator|=
name|shpgrp
expr_stmt|;
name|shpgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|tpgrp
operator|=
name|shpgrp
expr_stmt|;
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * On hpux 7.03 this fails with EPERM. This happens on 			 * the 800 when opgrp != shpgrp at this point. (we were 			 * forked from a non job control shell) 			 * POSIX 7.2.4, says we failed because the process 			 * group specified did not belong to a process 			 * in the same session with the tty. So we set our 			 * process group and try again. 			 */
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"setpgid:"
argument_list|)
expr_stmt|;
goto|goto
name|notty
goto|;
block|}
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"tcsetpgrp:"
argument_list|)
expr_stmt|;
goto|goto
name|notty
goto|;
block|}
block|}
comment|/* 		     * We check the process group now. If it is the same, then 		     * we don't need to set it again. On hpux 7.0 on the 300's 		     * if we set it again it fails with EPERM. This is the 		     * correct behavior according to POSIX 4.3.3 if the process 		     * was a session leader . 		     */
elseif|else
if|if
condition|(
name|shpgrp
operator|!=
name|mygetpgrp
argument_list|()
condition|)
block|{
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"setpgid:"
argument_list|)
expr_stmt|;
goto|goto
name|notty
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|IRIS4D
comment|/* 		     * But on irix 3.3 we need to set it again, even if it is 		     * the same. We do that to tell the system that we 		     * need BSD process group compatibility. 		     */
else|else
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIOCLEX
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|dcopy
argument_list|(
name|f
argument_list|,
name|FSHTTY
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* FIOCLEX */
operator|(
name|void
operator|)
name|dcopy
argument_list|(
name|f
argument_list|,
name|FSHTTY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FIOCLEX */
block|}
else|else
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
condition|)
block|{
name|notty
label|:
name|xprintf
argument_list|(
literal|"Warning: no access to tty (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|xprintf
argument_list|(
literal|"Thus no job control in this shell.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Fix from:Sakari Jalovaara<sja@sirius.hut.fi> if we don't 		 * have access to tty, disable editing too 		 */
if|if
condition|(
name|adrof
argument_list|(
name|STRedit
argument_list|)
condition|)
name|unsetv
argument_list|(
name|STRedit
argument_list|)
expr_stmt|;
name|editing
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* BSDJOBS */
comment|/* don't have job control, so frotz it */
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* BSDJOBS */
block|}
block|}
if|if
condition|(
operator|(
name|setintr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|parintr
operator|==
name|SIG_DFL
operator|)
condition|)
name|setintr
operator|=
literal|1
expr_stmt|;
comment|/*  * SVR4 doesn't send a SIGCHLD when a child is stopped or continued if the  * handler is installed with signal(2) or sigset(2).  sigaction(2) must  * be used instead.  *  * David Dawes (dawes@physics.su.oz.au) Sept 1991  */
if|#
directive|if
name|SVID
operator|>
literal|3
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|pchild
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|act
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't block any extra sigs when the 				      * handler is called 				      */
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
comment|/* want behaviour of sigset() without                                     * SA_NOCLDSTOP 				    */
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* SVID<= 3 */
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGCHLD
argument_list|,
name|pchild
argument_list|)
expr_stmt|;
comment|/* while signals not ready */
endif|#
directive|endif
comment|/* SVID<= 3 */
if|if
condition|(
name|intty
operator|&&
operator|!
name|arginp
condition|)
operator|(
name|void
operator|)
name|ed_Setup
argument_list|(
name|editing
argument_list|)
expr_stmt|;
comment|/* Get the tty state, and set defaults */
comment|/* Only alter the tty state if editing */
comment|/*      * Set an exit here in case of an interrupt or error reading the shell      * start-up scripts.      */
name|reenter
operator|=
name|setexit
argument_list|()
expr_stmt|;
comment|/* PWP */
name|haderr
operator|=
literal|0
expr_stmt|;
comment|/* In case second time through */
if|if
condition|(
operator|!
name|fast
operator|&&
name|reenter
operator|==
literal|0
condition|)
block|{
comment|/* Will have value(STRhome) here because set fast if don't */
block|{
name|int
name|osetintr
init|=
name|setintr
decl_stmt|;
name|sigret_t
function_decl|(
modifier|*
name|oparintr
function_decl|)
parameter_list|()
init|=
name|parintr
function_decl|;
ifdef|#
directive|ifdef
name|BSDSIGS
name|sigmask_t
name|omask
init|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setintr
operator|=
literal|0
expr_stmt|;
name|parintr
operator|=
name|SIG_IGN
expr_stmt|;
comment|/* onintr in /etc/ files has no effect */
ifdef|#
directive|ifdef
name|_PATH_DOTCSHRC
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTCSHRC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|arginp
operator|&&
operator|!
name|onelflg
operator|&&
operator|!
name|havhash
condition|)
name|dohash
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_DOTLOGIN
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setintr
operator|=
name|osetintr
expr_stmt|;
name|parintr
operator|=
name|oparintr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOGINFIRST
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotlogin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* upward compat. */
if|if
condition|(
operator|!
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldottcshrc
argument_list|)
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotcshrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fast
operator|&&
operator|!
name|arginp
operator|&&
operator|!
name|onelflg
operator|&&
operator|!
name|havhash
condition|)
name|dohash
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Source history before .login so that it is available in .login 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|value
argument_list|(
name|STRhistfile
argument_list|)
operator|)
operator|!=
name|STRNULL
condition|)
name|loadhist
index|[
literal|2
index|]
operator|=
name|cp
expr_stmt|;
name|dosource
argument_list|(
name|loadhist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LOGINFIRST
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotlogin
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CSHDIRS
comment|/* 	 * if dflag then source ~/.cshdirs, but if fast ALWAYS skip the dirs 	 * restoring. (dflag used to get non-login shells to source the save 	 * dirs file). Of course, ~/.cshdirs must exist. -strike 	 */
block|{
specifier|extern
name|int
name|bequiet
decl_stmt|;
comment|/* make dirs shut up */
name|Char
name|cshd
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|cshd
argument_list|,
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strcat
argument_list|(
name|cshd
argument_list|,
name|STRsldtdirs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|short2str
argument_list|(
name|cshd
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
operator|(
name|dflag
operator|||
name|loginsh
operator|)
operator|&&
operator|!
name|fast
condition|)
block|{
name|bequiet
operator|=
literal|1
expr_stmt|;
name|dosource
argument_list|(
name|loaddirs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bequiet
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* Initing AFTER .cshrc is the Right Way */
if|if
condition|(
name|intty
operator|&&
operator|!
name|arginp
condition|)
block|{
comment|/* PWP setup stuff */
name|ed_Init
argument_list|()
expr_stmt|;
comment|/* init the new line editor */
ifdef|#
directive|ifdef
name|SIG_WINDOW
name|check_window_size
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* mung environment */
endif|#
directive|endif
comment|/* SIG_WINDOW */
block|}
comment|/*      * Now are ready for the -v and -x flags      */
if|if
condition|(
name|nverbose
condition|)
name|setNS
argument_list|(
name|STRverbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexececho
condition|)
name|setNS
argument_list|(
name|STRecho
argument_list|)
expr_stmt|;
comment|/*      * All the rest of the world is inside this call. The argument to process      * indicates whether it should catch "error unwinds".  Thus if we are a      * interactive shell our call here will never return by being blown past on      * an error.      */
name|process
argument_list|(
name|setintr
argument_list|)
expr_stmt|;
comment|/*      * Mop-up.      */
if|if
condition|(
name|intty
condition|)
block|{
if|if
condition|(
name|loginsh
condition|)
block|{
name|xprintf
argument_list|(
literal|"logout\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|child
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TESLA
name|do_logout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TESLA */
name|goodbye
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xprintf
argument_list|(
literal|"exit\n"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CSHDIRS
comment|/*      * save the directory stack -strike      */
name|recdirs
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|rechist
argument_list|()
expr_stmt|;
name|exitstat
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|untty
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BSDJOBS
if|if
condition|(
name|tpgrp
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|opgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|FSHTTY
argument_list|,
name|opgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|resetdisc
argument_list|(
name|FSHTTY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BSDJOBS */
block|}
end_function

begin_function
name|void
name|importpath
parameter_list|(
name|cp
parameter_list|)
name|Char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|Char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|Char
modifier|*
modifier|*
name|pv
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|*
name|dp
operator|==
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
comment|/*      * i+2 where i is the number of colons in the path. There are i+1      * directories in the path plus we need room for a zero terminator.      */
name|pv
operator|=
operator|(
name|Char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cp
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|dp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|dp
operator|)
operator|==
literal|':'
operator|||
name|c
operator|==
literal|0
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
name|pv
index|[
name|i
operator|++
index|]
operator|=
name|Strsave
argument_list|(
operator|*
name|cp
condition|?
name|cp
else|:
name|STRdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|cp
operator|=
name|dp
operator|+
literal|1
expr_stmt|;
operator|*
name|dp
operator|=
literal|':'
expr_stmt|;
block|}
else|else
break|break;
block|}
name|dp
operator|++
expr_stmt|;
block|}
name|pv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|set1
argument_list|(
name|STRpath
argument_list|,
name|pv
argument_list|,
operator|&
name|shvhed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Source to the file which is the catenation of the argument names.  */
end_comment

begin_function
specifier|static
name|int
name|srccat
parameter_list|(
name|cp
parameter_list|,
name|dp
parameter_list|)
name|Char
modifier|*
name|cp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|srcfile
argument_list|(
name|short2str
argument_list|(
name|dp
argument_list|)
argument_list|,
name|mflag
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
specifier|register
name|Char
modifier|*
name|ep
init|=
name|Strspl
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|short2str
argument_list|(
name|ep
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|ep
argument_list|)
expr_stmt|;
return|return
name|srcfile
argument_list|(
name|ptr
argument_list|,
name|mflag
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * Source to a file putting the file descriptor in a safe place (> 2).  */
end_comment

begin_function
specifier|static
name|int
name|srcfile
parameter_list|(
name|f
parameter_list|,
name|onlyown
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|bool
name|onlyown
decl_stmt|,
name|flag
decl_stmt|;
block|{
specifier|register
name|int
name|unit
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|unit
operator|=
name|dmove
argument_list|(
name|unit
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIOCLEX
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|unit
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|srcunit
argument_list|(
name|unit
argument_list|,
name|onlyown
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Source to a unit.  If onlyown it must be our file or our group or  * we don't chance it.	This occurs on ".cshrc"s and the like.  */
end_comment

begin_decl_stmt
name|int
name|insource
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|srcunit
parameter_list|(
name|unit
parameter_list|,
name|onlyown
parameter_list|,
name|hflg
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
name|bool
name|onlyown
decl_stmt|,
name|hflg
decl_stmt|;
block|{
comment|/*      * PWP: this is arranged like this so that an optimizing compiler won't go      * and put things like oSHIN in a register that longjmp() restores.  The      * problem is that on my Sun 3/50, gcc will put oSHIN in a register.  That      * would be OK, but setjmp() saves ALL of the registers and longjmp()      * restores ALL of them, thus if you do a setjmp(), set oSHIN to something      * (like SHIN), then do a longjmp(), the value of oSHIN will magically      * become -1 again.      *       * Perhaps setjmp() should only save the stack pointer, frame pointer, and      * program counter...      */
comment|/* We have to push down a lot of state here */
comment|/* All this could go into a structure */
name|int
name|oSHIN
init|=
operator|-
literal|1
decl_stmt|,
name|oldintty
init|=
name|intty
decl_stmt|,
name|oinsource
init|=
name|insource
decl_stmt|;
name|struct
name|whyle
modifier|*
name|oldwhyl
init|=
name|whyles
decl_stmt|;
name|Char
modifier|*
name|ogointr
init|=
name|gointr
decl_stmt|,
modifier|*
name|oarginp
init|=
name|arginp
decl_stmt|;
name|Char
modifier|*
name|oevalp
init|=
name|evalp
decl_stmt|,
modifier|*
modifier|*
name|oevalvec
init|=
name|evalvec
decl_stmt|;
name|int
name|oonelflg
init|=
name|onelflg
decl_stmt|;
name|bool
name|oenterhist
init|=
name|enterhist
decl_stmt|;
name|char
name|OHIST
init|=
name|HIST
decl_stmt|;
name|bool
name|otell
init|=
name|cantell
decl_stmt|;
name|struct
name|Bin
name|saveB
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDSIGS
specifier|volatile
name|sigmask_t
name|omask
init|=
operator|(
name|sigmask_t
operator|)
literal|0
decl_stmt|;
endif|#
directive|endif
name|jmp_buf
name|oldexit
decl_stmt|;
comment|/* The (few) real local variables */
name|int
name|my_reenter
decl_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|didfds
condition|)
name|donefds
argument_list|()
expr_stmt|;
if|if
condition|(
name|onlyown
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|unit
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
comment|/* || (stb.st_uid != uid&& stb.st_gid != gid) */
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*      * There is a critical section here while we are pushing down the input      * stream since we have stuff in different structures. If we weren't      * careful an interrupt could corrupt SHIN's Bin structure and kill the      * shell.      *       * We could avoid the critical region by grouping all the stuff in a single      * structure and pointing at it to move it all at once.  This is less      * efficient globally on many variable references however.      */
name|insource
operator|=
literal|1
expr_stmt|;
name|getexit
argument_list|(
name|oldexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
ifdef|#
directive|ifdef
name|BSDSIGS
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Bugfix for running out of memory by: Jak Kirman      *<jak%cs.brown.edu@RELAY.CS.NET>.  Solution: pay attention to what      * setexit() is returning because my_reenter _may_ be in a register, and      * thus restored to 0 on a longjump(). (PWP: insert flames about      * compiler-dependant code here) PWP: THANKS LOTS !!!      */
comment|/* Setup the new values of the state stuff saved above */
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|saveB
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|B
argument_list|,
sizeof|sizeof
argument_list|(
name|B
argument_list|)
argument_list|)
expr_stmt|;
name|fbuf
operator|=
name|NULL
expr_stmt|;
name|fseekp
operator|=
name|feobp
operator|=
name|fblocks
operator|=
literal|0
expr_stmt|;
name|oSHIN
operator|=
name|SHIN
operator|,
name|SHIN
operator|=
name|unit
operator|,
name|arginp
operator|=
literal|0
operator|,
name|onelflg
operator|=
literal|0
expr_stmt|;
name|intty
operator|=
name|isatty
argument_list|(
name|SHIN
argument_list|)
operator|,
name|whyles
operator|=
literal|0
operator|,
name|gointr
operator|=
literal|0
expr_stmt|;
name|evalvec
operator|=
literal|0
expr_stmt|;
name|evalp
operator|=
literal|0
expr_stmt|;
name|enterhist
operator|=
name|hflg
expr_stmt|;
if|if
condition|(
name|enterhist
condition|)
name|HIST
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Now if we are allowing commands to be interrupted, we let ourselves be      * interrupted.      */
if|if
condition|(
name|setintr
condition|)
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|settell
argument_list|()
expr_stmt|;
comment|/* PWP: think of this as like a LISP (unwind-protect ...) */
comment|/* thanks to Diana Smetters for pointing out how this _should_ be written */
ifdef|#
directive|ifdef
name|cray
name|my_reenter
operator|=
literal|1
expr_stmt|;
comment|/* assume non-zero return val */
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
block|{
name|my_reenter
operator|=
literal|0
expr_stmt|;
comment|/* Oh well, we were wrong */
else|#
directive|else
if|if
condition|(
operator|(
name|my_reenter
operator|=
name|setexit
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|process
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 -> blow away on errors */
block|}
if|if
condition|(
name|setintr
condition|)
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|oSHIN
operator|>=
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* We made it to the new state... free up its storage */
comment|/* This code could get run twice but xfree doesn't care */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fblocks
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|fbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|fbuf
argument_list|)
expr_stmt|;
comment|/* Reset input arena */
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|B
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|saveB
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|B
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|SHIN
argument_list|)
operator|,
name|SHIN
operator|=
name|oSHIN
expr_stmt|;
name|arginp
operator|=
name|oarginp
operator|,
name|onelflg
operator|=
name|oonelflg
expr_stmt|;
name|evalp
operator|=
name|oevalp
operator|,
name|evalvec
operator|=
name|oevalvec
expr_stmt|;
name|intty
operator|=
name|oldintty
operator|,
name|whyles
operator|=
name|oldwhyl
operator|,
name|gointr
operator|=
name|ogointr
expr_stmt|;
if|if
condition|(
name|enterhist
condition|)
name|HIST
operator|=
name|OHIST
expr_stmt|;
name|enterhist
operator|=
name|oenterhist
expr_stmt|;
name|cantell
operator|=
name|otell
expr_stmt|;
block|}
name|resexit
argument_list|(
name|oldexit
argument_list|)
expr_stmt|;
comment|/*      * If process reset() (effectively an unwind) then we must also unwind.      */
if|if
condition|(
name|my_reenter
condition|)
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
name|insource
operator|=
name|oinsource
expr_stmt|;
block|}
name|void
name|rechist
parameter_list|()
block|{
name|Char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|,
modifier|*
name|hfile
decl_stmt|;
name|int
name|fp
decl_stmt|,
name|ftmp
decl_stmt|,
name|oldidfds
decl_stmt|;
if|if
condition|(
operator|!
name|fast
condition|)
block|{
if|if
condition|(
name|value
argument_list|(
name|STRsavehist
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
operator|(
name|hfile
operator|=
name|value
argument_list|(
name|STRhistfile
argument_list|)
operator|)
operator|==
name|STRNULL
condition|)
block|{
name|hfile
operator|=
name|Strcpy
argument_list|(
name|buf
argument_list|,
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strcat
argument_list|(
name|buf
argument_list|,
name|STRsldthist
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|creat
argument_list|(
name|short2str
argument_list|(
name|hfile
argument_list|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
operator|-
literal|1
condition|)
return|return;
name|oldidfds
operator|=
name|didfds
expr_stmt|;
name|didfds
operator|=
literal|0
expr_stmt|;
name|ftmp
operator|=
name|SHOUT
expr_stmt|;
name|SHOUT
operator|=
name|fp
expr_stmt|;
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|buf
argument_list|,
name|value
argument_list|(
name|STRsavehist
argument_list|)
argument_list|)
expr_stmt|;
name|dumphist
index|[
literal|2
index|]
operator|=
name|buf
expr_stmt|;
name|dohist
argument_list|(
name|dumphist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|SHOUT
operator|=
name|ftmp
expr_stmt|;
name|didfds
operator|=
name|oldidfds
expr_stmt|;
block|}
block|}
comment|/*ARGSUSED*/
name|void
name|goodbye
parameter_list|(
name|v
parameter_list|,
name|c
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|c
decl_stmt|;
block|{
name|rechist
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CSHDIRS
name|recdirs
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|loginsh
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setintr
operator|=
literal|0
expr_stmt|;
comment|/* No interrupts after "logout" */
if|if
condition|(
operator|!
operator|(
name|adrof
argument_list|(
name|STRlogout
argument_list|)
operator|)
condition|)
name|set
argument_list|(
name|STRlogout
argument_list|,
name|STRnormal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_DOTLOGOUT
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGOUT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adrof
argument_list|(
name|STRhome
argument_list|)
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldtlogout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TESLA
name|do_logout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TESLA */
block|}
name|exitstat
argument_list|()
expr_stmt|;
block|}
name|void
name|exitstat
parameter_list|()
block|{
specifier|register
name|Char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PROF
name|monitor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Note that if STATUS is corrupted (i.e. getn bombs) then error will exit      * directly because we poke child here. Otherwise we might continue      * unwarrantedly (sic).      */
name|child
operator|=
literal|1
expr_stmt|;
comment|/*       * PWP: do this step-by-step because we might get a bus error if      * status isn't set, so we call getn(NULL).      */
name|cp
operator|=
name|value
argument_list|(
name|STRstatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|i
operator|=
literal|13
expr_stmt|;
else|else
name|i
operator|=
name|getn
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/*  * in the event of a HUP we want to save the history  */
specifier|static
name|sigret_t
name|phup
parameter_list|(
name|snum
parameter_list|)
name|int
name|snum
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UNRELSIGS
if|if
condition|(
name|snum
condition|)
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|snum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNRELSIGS */
name|rechist
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CSHDIRS
comment|/*      * save the directory stack on HUP - strike      */
name|recdirs
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|xexit
argument_list|(
name|snum
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
name|snum
operator|)
return|;
endif|#
directive|endif
block|}
name|Char
modifier|*
name|jobargv
index|[
literal|2
index|]
init|=
block|{
name|STRjobs
block|,
literal|0
block|}
decl_stmt|;
comment|/*  * Catch an interrupt, e.g. during lexical input.  * If we are an interactive shell, we reset the interrupt catch  * immediately.  In any case we drain the shell output,  * and finally go through the normal error mechanism, which  * gets a chance to make the shell go away.  */
name|int
name|just_signaled
decl_stmt|;
comment|/* bugfix by Michael Bloom (mg@ttidca.TTI.COM) */
ifdef|#
directive|ifdef
name|SIGVOID
comment|/*ARGSUSED*/
endif|#
directive|endif
name|sigret_t
name|pintr
parameter_list|(
name|snum
parameter_list|)
name|int
name|snum
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UNRELSIGS
if|if
condition|(
name|snum
condition|)
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|snum
argument_list|,
name|pintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNRELSIGS */
name|just_signaled
operator|=
literal|1
expr_stmt|;
name|pintr1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGVOID
return|return
operator|(
name|snum
operator|)
return|;
endif|#
directive|endif
block|}
name|void
name|pintr1
parameter_list|(
name|wantnl
parameter_list|)
name|bool
name|wantnl
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDSIGS
name|sigmask_t
name|omask
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSDSIGS
name|omask
operator|=
name|sigblock
argument_list|(
operator|(
name|sigmask_t
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setintr
condition|)
block|{
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pjobs
condition|)
block|{
name|pjobs
operator|=
literal|0
expr_stmt|;
name|xprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dojobs
argument_list|(
name|jobargv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_INTR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* JV - Make sure we shut off inputl */
block|{
specifier|extern
name|Char
name|GettingInput
decl_stmt|;
operator|(
name|void
operator|)
name|Cookedmode
argument_list|()
expr_stmt|;
name|GettingInput
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|setintr
condition|)
operator|(
name|void
operator|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|draino
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|endpwent
argument_list|()
expr_stmt|;
comment|/*      * If we have an active "onintr" then we search for the label. Note that if      * one does "onintr -" then we shan't be interruptible so we needn't worry      * about that here.      */
if|if
condition|(
name|gointr
condition|)
block|{
name|gotolab
argument_list|(
name|gointr
argument_list|)
expr_stmt|;
name|timflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|=
name|pargv
condition|)
name|pargv
operator|=
literal|0
operator|,
name|blkfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|=
name|gargv
condition|)
name|gargv
operator|=
literal|0
operator|,
name|blkfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intty
operator|&&
name|wantnl
condition|)
block|{
comment|/* xprintf("\n"); */
comment|/* Some like this, others don't */
operator|(
name|void
operator|)
name|putraw
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putraw
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
block|}
comment|/*  * Process is the main driving routine for the shell.  * It runs all command processing, except for those within { ... }  * in expressions (which is run by a routine evalav in sh.exp.c which  * is a stripped down process), and `...` evaluation which is run  * also by a subset of this code in sh.glob.c in the routine backeval.  *  * The code here is a little strange because part of it is interruptible  * and hence freeing of structures appears to occur when none is necessary  * if this is ignored.  *  * Note that if catch is not set then we will unwind on any error.  * If an end-of-file occurs, we return.  */
name|struct
name|command
modifier|*
name|savet
init|=
name|NULL
decl_stmt|;
name|void
name|process
parameter_list|(
name|catch
parameter_list|)
name|bool
name|catch
decl_stmt|;
block|{
specifier|extern
name|char
name|Expand
decl_stmt|;
name|jmp_buf
name|osetexit
decl_stmt|;
comment|/* PWP: This might get nuked my longjmp so don't make it a register var */
name|struct
name|command
modifier|*
name|t
init|=
name|savet
decl_stmt|;
name|savet
operator|=
name|NULL
expr_stmt|;
name|getexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pendjob
argument_list|()
expr_stmt|;
name|paraml
operator|.
name|next
operator|=
name|paraml
operator|.
name|prev
operator|=
operator|&
name|paraml
expr_stmt|;
name|paraml
operator|.
name|word
operator|=
name|STRNULL
expr_stmt|;
operator|(
name|void
operator|)
name|setexit
argument_list|()
expr_stmt|;
name|justpr
operator|=
name|enterhist
expr_stmt|;
comment|/* execute if not entering history */
comment|/* 	 * Interruptible during interactive reads 	 */
if|if
condition|(
name|setintr
condition|)
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
operator|(
name|sigmask_t
operator|)
literal|0
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * For the sake of reset() 	 */
name|freelex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
if|if
condition|(
name|savet
condition|)
name|freesyn
argument_list|(
name|savet
argument_list|)
operator|,
name|savet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|haderr
condition|)
block|{
if|if
condition|(
operator|!
name|catch
condition|)
block|{
comment|/* unwind */
name|doneinp
operator|=
literal|0
expr_stmt|;
name|savet
operator|=
name|t
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
name|haderr
operator|=
literal|0
expr_stmt|;
comment|/* 	     * Every error is eventually caught here or the shell dies.  It is 	     * at this point that we clean up any left-over open files, by 	     * closing all but a fixed number of pre-defined files.  Thus 	     * routines don't have to worry about leaving files open due to 	     * deeper errors... they will get closed here. 	     */
name|closem
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|doneinp
condition|)
block|{
name|doneinp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chkstop
condition|)
name|chkstop
operator|--
expr_stmt|;
if|if
condition|(
name|neednote
condition|)
name|pnote
argument_list|()
expr_stmt|;
if|if
condition|(
name|intty
operator|&&
name|prompt
operator|&&
name|evalvec
operator|==
literal|0
condition|)
block|{
name|mailchk
argument_list|()
expr_stmt|;
comment|/* 	     * Watch for logins/logouts. Next is scheduled commands stored 	     * previously using "sched." Then execute periodic commands. 	     * Following that, the prompt precmd is run. 	     */
name|watch_login
argument_list|()
expr_stmt|;
name|sched_run
argument_list|()
expr_stmt|;
name|period_cmd
argument_list|()
expr_stmt|;
name|precmd
argument_list|()
expr_stmt|;
comment|/* 	     * If we are at the end of the input buffer then we are going to 	     * read fresh stuff. Otherwise, we are rereading input and don't 	     * need or want to prompt. 	     */
if|if
condition|(
name|fseekp
operator|==
name|feobp
operator|&&
name|aret
operator|==
name|F_SEEK
condition|)
name|printprompt
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|setalarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seterr
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|seterr
argument_list|)
expr_stmt|;
name|seterr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Echo not only on VERBOSE, but also with history expansion. If there 	 * is a lexical error then we forego history echo. 	 */
if|if
condition|(
operator|(
name|lex
argument_list|(
operator|&
name|paraml
argument_list|)
operator|&&
operator|!
name|seterr
operator|&&
name|intty
operator|&&
operator|!
name|tellwhat
operator|&&
operator|!
name|Expand
operator|)
operator|||
name|adrof
argument_list|(
name|STRverbose
argument_list|)
condition|)
block|{
name|haderr
operator|=
literal|1
expr_stmt|;
name|prlex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
name|haderr
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Autologout OFF */
comment|/* 	 * The parser may lose space if interrupted. 	 */
if|if
condition|(
name|setintr
condition|)
ifdef|#
directive|ifdef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Save input text on the history list if reading in old history, or it 	 * is from the terminal at the top level and not in a loop. 	 *  	 * PWP: entry of items in the history list while in a while loop is done 	 * elsewhere... 	 */
if|if
condition|(
name|enterhist
operator|||
operator|(
name|catch
operator|&&
name|intty
operator|&&
operator|!
name|whyles
operator|&&
operator|!
name|tellwhat
operator|)
condition|)
name|savehist
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
if|if
condition|(
name|Expand
operator|&&
name|seterr
condition|)
name|Expand
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Print lexical error messages, except when sourcing history lists. 	 */
if|if
condition|(
operator|!
name|enterhist
operator|&&
name|seterr
condition|)
name|stderror
argument_list|(
name|ERR_OLD
argument_list|)
expr_stmt|;
comment|/* 	 * If had a history command :p modifier then this is as far as we 	 * should go 	 */
if|if
condition|(
name|justpr
condition|)
name|reset
argument_list|()
expr_stmt|;
comment|/* 	 * If had a tellwhat from twenex() then do 	 */
if|if
condition|(
name|tellwhat
condition|)
block|{
name|tellmewhat
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
name|alias
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSDJOBS
comment|/* 	 * If we are interactive, try to continue jobs that we have stopped 	 */
if|if
condition|(
name|prompt
condition|)
name|continue_jobs
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSDJOBS */
comment|/* 	 * Check to see if the user typed "rm * .o" or something 	 */
if|if
condition|(
name|prompt
condition|)
name|rmstar
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the words of the input into a parse tree. 	 */
name|savet
operator|=
name|syntax
argument_list|(
name|paraml
operator|.
name|next
argument_list|,
operator|&
name|paraml
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|seterr
condition|)
name|stderror
argument_list|(
name|ERR_OLD
argument_list|)
expr_stmt|;
comment|/* 	 * Execute the parse tree From: Michael Schroeder 	 *<mlschroe@immd4.informatik.uni-erlangen.de> was execute(t, tpgrp); 	 */
name|execute
argument_list|(
name|savet
argument_list|,
operator|(
name|tpgrp
operator|>
literal|0
condition|?
name|tpgrp
else|:
operator|-
literal|1
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Made it! 	 */
name|freelex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
name|freesyn
argument_list|(
name|savet
argument_list|)
operator|,
name|savet
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SIG_WINDOW
if|if
condition|(
name|catch
operator|&&
name|intty
operator|&&
operator|!
name|whyles
operator|&&
operator|!
name|tellwhat
condition|)
name|window_change
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* for window systems */
endif|#
directive|endif
comment|/* SIG_WINDOW */
block|}
name|savet
operator|=
name|t
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
block|}
comment|/*ARGSUSED*/
name|void
name|dosource
parameter_list|(
name|t
parameter_list|,
name|c
parameter_list|)
specifier|register
name|Char
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|command
modifier|*
name|c
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|f
decl_stmt|;
name|bool
name|hflg
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|&&
name|eq
argument_list|(
operator|*
name|t
argument_list|,
name|STRmh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|t
operator|==
name|NULL
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_HFLAG
argument_list|)
expr_stmt|;
name|hflg
operator|++
expr_stmt|;
block|}
name|f
operator|=
name|globone
argument_list|(
operator|*
name|t
argument_list|,
name|G_ERROR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|short2str
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|srcfile
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|hflg
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|hflg
operator|)
condition|)
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check for mail.  * If we are a login shell, then we don't want to tell  * about any mail file unless its been modified  * after the time we started.  * This prevents us from telling the user things he already  * knows, since the login program insists on saying  * "You have mail."  */
specifier|static
name|void
name|mailchk
parameter_list|()
block|{
specifier|register
name|struct
name|varent
modifier|*
name|v
decl_stmt|;
specifier|register
name|Char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|intvl
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|bool
name|new
decl_stmt|;
name|v
operator|=
name|adrof
argument_list|(
name|STRmail
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|vp
operator|=
name|v
operator|->
name|vec
expr_stmt|;
name|cnt
operator|=
name|blklen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|intvl
operator|=
operator|(
name|cnt
operator|&&
name|number
argument_list|(
operator|*
name|vp
argument_list|)
operator|)
condition|?
operator|(
operator|--
name|cnt
operator|,
name|getn
argument_list|(
operator|*
name|vp
operator|++
argument_list|)
operator|)
else|:
name|MAILINTVL
expr_stmt|;
if|if
condition|(
name|intvl
operator|<
literal|1
condition|)
name|intvl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chktim
operator|+
name|intvl
operator|>
name|t
condition|)
return|return;
for|for
control|(
init|;
operator|*
name|vp
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|short2str
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|BSDTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|time0
operator|.
name|tv_sec
expr_stmt|;
else|#
directive|else
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|time0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stb
operator|.
name|st_size
operator|==
literal|0
operator|||
name|stb
operator|.
name|st_atime
operator|>
name|stb
operator|.
name|st_mtime
operator|||
operator|(
name|stb
operator|.
name|st_atime
operator|<=
name|chktim
operator|&&
name|stb
operator|.
name|st_mtime
operator|<=
name|chktim
operator|)
operator|||
operator|(
name|loginsh
operator|&&
operator|!
name|new
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
name|xprintf
argument_list|(
literal|"You have %smail.\n"
argument_list|,
name|new
condition|?
literal|"new "
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|xprintf
argument_list|(
literal|"%s in %s.\n"
argument_list|,
name|new
condition|?
literal|"New mail"
else|:
literal|"Mail"
argument_list|,
name|short2str
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chktim
operator|=
name|t
expr_stmt|;
block|}
comment|/*  * Extract a home directory from the password file  * The argument points to a buffer where the name of the  * user whose home directory is sought is currently.  * We write the home directory of the user back there.  */
name|int
name|gethdir
parameter_list|(
name|home
parameter_list|)
name|Char
modifier|*
name|home
decl_stmt|;
block|{
name|Char
modifier|*
name|h
decl_stmt|;
comment|/*      * Is it us?      */
if|if
condition|(
operator|*
name|home
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|h
operator|=
name|value
argument_list|(
name|STRhome
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|home
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
comment|/*      * Look in the cache      */
if|if
condition|(
operator|(
name|h
operator|=
name|gettilde
argument_list|(
name|home
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
else|else
block|{
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|home
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/*  * Move the initial descriptors to their eventual  * resting places, closing all other units.  */
name|void
name|initdesc
parameter_list|()
block|{
name|didfds
operator|=
literal|0
expr_stmt|;
comment|/* 0, 1, 2 aren't set up */
ifdef|#
directive|ifdef
name|FIOCLEX
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHIN
operator|=
name|dcopy
argument_list|(
literal|0
argument_list|,
name|FSHIN
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHOUT
operator|=
name|dcopy
argument_list|(
literal|1
argument_list|,
name|FSHOUT
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHDIAG
operator|=
name|dcopy
argument_list|(
literal|2
argument_list|,
name|FSHDIAG
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|OLDSTD
operator|=
name|dcopy
argument_list|(
name|SHIN
argument_list|,
name|FOLDSTD
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|didcch
operator|=
literal|0
expr_stmt|;
comment|/* Havent closed for child */
name|SHIN
operator|=
name|dcopy
argument_list|(
literal|0
argument_list|,
name|FSHIN
argument_list|)
expr_stmt|;
name|SHOUT
operator|=
name|dcopy
argument_list|(
literal|1
argument_list|,
name|FSHOUT
argument_list|)
expr_stmt|;
name|isoutatty
operator|=
name|isatty
argument_list|(
name|SHOUT
argument_list|)
expr_stmt|;
name|SHDIAG
operator|=
name|dcopy
argument_list|(
literal|2
argument_list|,
name|FSHDIAG
argument_list|)
expr_stmt|;
name|isdiagatty
operator|=
name|isatty
argument_list|(
name|SHDIAG
argument_list|)
expr_stmt|;
name|OLDSTD
operator|=
name|dcopy
argument_list|(
name|SHIN
argument_list|,
name|FOLDSTD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|closem
argument_list|()
expr_stmt|;
block|}
name|void
ifdef|#
directive|ifdef
name|PROF
name|done
parameter_list|(
name|i
parameter_list|)
else|#
directive|else
function|xexit
parameter_list|(
name|i
parameter_list|)
endif|#
directive|endif
name|int
name|i
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TESLA
if|if
condition|(
name|loginsh
operator|&&
name|do_logout
condition|)
block|{
comment|/* this is to send hangup signal to the develcon */
comment|/* we toggle DTR. clear dtr - sleep 1 - set dtr */
comment|/* ioctl will return ENOTTY for pty's but we ignore it 	 */
comment|/* exitstat will run after disconnect */
comment|/* we sleep for 2 seconds to let things happen in */
comment|/* .logout and rechist() */
ifdef|#
directive|ifdef
name|TIOCCDTR
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCCDTR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|FSHTTY
argument_list|,
name|TIOCSDTR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCCDTR */
block|}
endif|#
directive|endif
comment|/* TESLA */
name|untty
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
specifier|static
name|Char
modifier|*
modifier|*
name|defaultpath
parameter_list|()
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|Char
modifier|*
modifier|*
name|blk
decl_stmt|,
modifier|*
modifier|*
name|blkp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|blkp
operator|=
name|blk
operator|=
operator|(
name|Char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|Char
operator|*
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DOTLAST
operator|*
name|blkp
operator|++
operator|=
name|Strsave
argument_list|(
name|STRdot
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|DIRAPPEND
parameter_list|(
name|a
parameter_list|)
define|\
value|if (stat(ptr = a,&stb) == 0&& S_ISDIR(stb.st_mode)) \ 		*blkp++ = SAVE(ptr)
ifdef|#
directive|ifdef
name|_PATH_LOCAL
name|DIRAPPEND
argument_list|(
name|_PATH_LOCAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_USRUCB
name|DIRAPPEND
argument_list|(
name|_PATH_USRUCB
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_USRBSD
name|DIRAPPEND
argument_list|(
name|_PATH_USRBSD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_BIN
name|DIRAPPEND
argument_list|(
name|_PATH_BIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_USRBIN
name|DIRAPPEND
argument_list|(
name|_PATH_USRBIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|DIRAPPEND
ifdef|#
directive|ifdef
name|DOTLAST
operator|*
name|blkp
operator|++
operator|=
name|Strsave
argument_list|(
name|STRdot
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|blkp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

end_unit

