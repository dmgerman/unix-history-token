begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  C K U U S X --  "User Interface" common functions. */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*   This module contains user interface functions needed by both the interactive   user interface and the command-line-only user interface. */
end_comment

begin_comment
comment|/* Includes */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_include
include|#
directive|include
file|<stsdef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* Variables declared here */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
name|debfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging log file name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TLOG
end_ifdef

begin_decl_stmt
name|char
name|trafil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transaction log file name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TLOG */
end_comment

begin_decl_stmt
name|char
name|pktfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet log file name */
end_comment

begin_decl_stmt
name|char
name|sesfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Session log file name */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_decl_stmt
name|char
name|optbuf
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options for MAIL or REMOTE PRINT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_decl_stmt
name|char
name|cmdstr
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place to build generic command */
end_comment

begin_decl_stmt
name|char
name|fspec
index|[
name|FSPECL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename string for \v(filespec) */
end_comment

begin_decl_stmt
name|int
name|success
init|=
literal|1
decl_stmt|,
comment|/* Command success/failure flag */
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
init|=
literal|0
decl_stmt|,
comment|/* Command level */
endif|#
directive|endif
comment|/* NOSPL */
name|action
decl_stmt|,
comment|/* Action selected on command line*/
name|sessft
init|=
literal|0
decl_stmt|,
comment|/* Session log file type, 0 = text */
name|pflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print prompt& messages */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOMSEND
end_ifndef

begin_comment
comment|/* Multiple SEND */
end_comment

begin_decl_stmt
name|char
modifier|*
name|msfiles
index|[
name|MSENDMAX
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOMSEND */
end_comment

begin_comment
comment|/* External variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|local
decl_stmt|,
name|quiet
decl_stmt|,
name|binary
decl_stmt|,
name|bctu
decl_stmt|,
name|rptflg
decl_stmt|,
name|ebqflg
decl_stmt|,
name|network
decl_stmt|,
name|server
decl_stmt|,
name|what
decl_stmt|,
name|spsiz
decl_stmt|,
name|urpsiz
decl_stmt|,
name|wmax
decl_stmt|,
name|czseen
decl_stmt|,
name|cxseen
decl_stmt|,
name|winlo
decl_stmt|,
name|displa
decl_stmt|,
name|timint
decl_stmt|,
name|npad
decl_stmt|,
name|ebq
decl_stmt|,
name|ebqflg
decl_stmt|,
name|bctr
decl_stmt|,
name|rptq
decl_stmt|,
name|atcapu
decl_stmt|,
name|lpcapu
decl_stmt|,
name|swcapu
decl_stmt|,
name|wslotn
decl_stmt|,
name|wslotr
decl_stmt|,
name|rtimo
decl_stmt|,
name|mypadn
decl_stmt|,
name|sq
decl_stmt|,
name|capas
decl_stmt|,
name|rpsiz
decl_stmt|,
name|tsecs
decl_stmt|,
name|dfloc
decl_stmt|,
name|tralog
decl_stmt|,
name|pktlog
decl_stmt|,
name|seslog
decl_stmt|,
name|lscapu
decl_stmt|,
name|xitsta
decl_stmt|,
name|escape
decl_stmt|,
name|tlevel
decl_stmt|,
name|bgset
decl_stmt|,
name|backgrd
decl_stmt|,
name|wslots
decl_stmt|,
name|suspend
decl_stmt|,
name|srvdis
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|speed
decl_stmt|,
name|filcnt
decl_stmt|,
name|ffc
decl_stmt|,
name|rptn
decl_stmt|,
name|fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|rdatap
decl_stmt|,
name|padch
decl_stmt|,
name|seol
decl_stmt|,
name|ctlq
decl_stmt|,
name|mypadc
decl_stmt|,
name|eol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|,
modifier|*
name|dftty
decl_stmt|,
modifier|*
name|cmarg
decl_stmt|,
modifier|*
modifier|*
name|cmlist
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmdbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCCTRAP
end_ifndef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* Control-C trap */
end_comment

begin_decl_stmt
name|jmp_buf
name|cmjbuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCCTRAP */
end_comment

begin_comment
comment|/*  S D E B U  -- Record spar results in debugging log  */
end_comment

begin_function
name|VOID
name|sdebu
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
name|debug
argument_list|(
name|F111
argument_list|,
literal|"spar: data"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rdatap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" spsiz "
argument_list|,
literal|""
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" timint"
argument_list|,
literal|""
argument_list|,
name|timint
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" npad  "
argument_list|,
literal|""
argument_list|,
name|npad
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" padch "
argument_list|,
literal|""
argument_list|,
name|padch
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" seol  "
argument_list|,
literal|""
argument_list|,
name|seol
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" ctlq  "
argument_list|,
literal|""
argument_list|,
name|ctlq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" ebq   "
argument_list|,
literal|""
argument_list|,
name|ebq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" ebqflg"
argument_list|,
literal|""
argument_list|,
name|ebqflg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" bctr  "
argument_list|,
literal|""
argument_list|,
name|bctr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rptq  "
argument_list|,
literal|""
argument_list|,
name|rptq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rptflg"
argument_list|,
literal|""
argument_list|,
name|rptflg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" lscapu"
argument_list|,
literal|""
argument_list|,
name|lscapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" atcapu"
argument_list|,
literal|""
argument_list|,
name|atcapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" lpcapu"
argument_list|,
literal|""
argument_list|,
name|lpcapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" swcapu"
argument_list|,
literal|""
argument_list|,
name|swcapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" wslotn"
argument_list|,
literal|""
argument_list|,
name|wslotn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  R D E B U -- Debugging display of rpar() values  */
end_comment

begin_function
name|VOID
name|rdebu
parameter_list|(
name|d
parameter_list|,
name|len
parameter_list|)
name|CHAR
modifier|*
name|d
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|debug
argument_list|(
name|F111
argument_list|,
literal|"rpar: data"
argument_list|,
name|d
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rpsiz "
argument_list|,
literal|""
argument_list|,
name|xunchar
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rtimo "
argument_list|,
literal|""
argument_list|,
name|rtimo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" mypadn"
argument_list|,
literal|""
argument_list|,
name|mypadn
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" mypadc"
argument_list|,
literal|""
argument_list|,
name|mypadc
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" eol   "
argument_list|,
literal|""
argument_list|,
name|eol
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" ctlq  "
argument_list|,
literal|""
argument_list|,
name|ctlq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" sq    "
argument_list|,
literal|""
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" ebq   "
argument_list|,
literal|""
argument_list|,
name|ebq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" ebqflg"
argument_list|,
literal|""
argument_list|,
name|ebqflg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" bctr  "
argument_list|,
literal|""
argument_list|,
name|bctr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rptq  "
argument_list|,
literal|""
argument_list|,
name|d
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rptflg"
argument_list|,
literal|""
argument_list|,
name|rptflg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" capas "
argument_list|,
literal|""
argument_list|,
name|capas
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" bits  "
argument_list|,
literal|""
argument_list|,
name|d
index|[
name|capas
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" lscapu"
argument_list|,
literal|""
argument_list|,
name|lscapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" atcapu"
argument_list|,
literal|""
argument_list|,
name|atcapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" lpcapu"
argument_list|,
literal|""
argument_list|,
name|lpcapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" swcapu"
argument_list|,
literal|""
argument_list|,
name|swcapu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" wslotr"
argument_list|,
literal|""
argument_list|,
name|wslotr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rpsiz(extended)"
argument_list|,
literal|""
argument_list|,
name|rpsiz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  F A T A L  --  Fatal error message */
end_comment

begin_function
name|VOID
name|fatal
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|screen
argument_list|(
name|SCR_EM
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"fatal"
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Fatal:"
argument_list|,
name|msg
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|doexit
argument_list|(
name|BAD_EXIT
argument_list|,
name|xitsta
argument_list|)
expr_stmt|;
comment|/* Exit indicating failure */
block|}
end_function

begin_comment
comment|/*  B L D L E N  --  Make length-encoded copy of string  */
end_comment

begin_function
name|char
modifier|*
name|bldlen
parameter_list|(
name|str
parameter_list|,
name|dest
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|tochar
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dest
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|+
name|len
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  S E T G E N  --  Construct a generic command  */
end_comment

begin_function
name|CHAR
ifdef|#
directive|ifdef
name|CK_ANSIC
name|setgen
parameter_list|(
name|char
name|type
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|,
name|char
modifier|*
name|arg2
parameter_list|,
name|char
modifier|*
name|arg3
parameter_list|)
else|#
directive|else
function|setgen
parameter_list|(
name|type
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
name|type
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_ANSIC */
end_comment

begin_comment
comment|/* setgen */
end_comment

begin_block
block|{
name|char
modifier|*
name|upstr
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|cmdstr
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|type
expr_stmt|;
operator|*
name|cp
operator|=
name|NUL
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|!=
name|NUL
condition|)
block|{
name|upstr
operator|=
name|bldlen
argument_list|(
name|arg1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg2
operator|!=
name|NUL
condition|)
block|{
name|upstr
operator|=
name|bldlen
argument_list|(
name|arg2
argument_list|,
name|upstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg3
operator|!=
name|NUL
condition|)
name|bldlen
argument_list|(
name|arg3
argument_list|,
name|upstr
argument_list|)
expr_stmt|;
block|}
block|}
name|cmarg
operator|=
name|cmdstr
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"setgen"
argument_list|,
name|cmarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'g'
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NOMSEND
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mgbufp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  F N P A R S E  --  */
end_comment

begin_comment
comment|/*   Argument is a character string containing one or more filespecs.   This function breaks the string apart into an array of pointers, one   to each filespec, and returns the number of filespecs.  Used by server   when it receives a GET command to allow it to process multiple file   specifications in one transaction.  Sets cmlist to point to a list of   file pointers, exactly as if they were command line arguments.    This version of fnparse treats spaces as filename separators.  If your   operating system allows spaces in filenames, you'll need a different    separator.      This version of fnparse mallocs a string buffer to contain the names.  It   cannot assume that the string that is pointed to by the argument is safe. */
end_comment

begin_function
name|int
name|fnparse
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|,
name|x
decl_stmt|;
comment|/* Return code */
if|if
condition|(
name|mgbufp
condition|)
name|free
argument_list|(
name|mgbufp
argument_list|)
expr_stmt|;
comment|/* Free this from last time. */
name|mgbufp
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mgbufp
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"fnparse malloc error"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOICP
ifndef|#
directive|ifndef
name|NOSPL
name|strncpy
argument_list|(
name|fspec
argument_list|,
name|string
argument_list|,
name|FSPECL
argument_list|)
expr_stmt|;
comment|/* Make copy for \v(filespec) */
endif|#
directive|endif
comment|/* NOSPL */
endif|#
directive|endif
comment|/* NOICP */
name|s
operator|=
name|string
expr_stmt|;
comment|/* Input string */
name|p
operator|=
name|q
operator|=
name|mgbufp
expr_stmt|;
comment|/* Point to the copy */
name|r
operator|=
literal|0
expr_stmt|;
comment|/* Initialize our return code */
while|while
condition|(
operator|*
name|s
operator|==
name|SP
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip leading spaces */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Loop through rest of string */
if|if
condition|(
operator|*
name|s
operator|==
name|CMDQ
condition|)
block|{
comment|/* Backslash (quote character)? */
if|if
condition|(
operator|(
name|x
operator|=
name|xxesc
argument_list|(
operator|&
name|s
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Go interpret it. */
operator|*
name|q
operator|++
operator|=
operator|(
name|char
operator|)
name|x
expr_stmt|;
comment|/* Numeric backslash code, ok */
block|}
else|else
block|{
comment|/* Just let it quote next char */
name|s
operator|++
expr_stmt|;
comment|/* get past the backslash */
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* deposit next char */
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|SP
operator|||
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* Unquoted space or NUL? */
operator|*
name|q
operator|++
operator|=
name|NUL
expr_stmt|;
comment|/* End of output filename. */
name|msfiles
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
comment|/* Add this filename to the list */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"fnparse"
argument_list|,
name|msfiles
index|[
name|r
index|]
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|++
expr_stmt|;
comment|/* Count it */
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
break|break;
comment|/* End of string? */
while|while
condition|(
operator|*
name|s
operator|==
name|SP
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip repeated spaces */
name|p
operator|=
name|q
expr_stmt|;
comment|/* Start of next name */
continue|continue;
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|s
expr_stmt|;
comment|/* Otherwise copy the character */
name|s
operator|++
expr_stmt|;
comment|/* Next input character */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"fnparse r"
argument_list|,
literal|""
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|cmlist
operator|=
name|msfiles
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOMSEND */
end_comment

begin_function
name|char
modifier|*
comment|/* dbchr() for DEBUG SESSION */
name|dbchr
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|s
index|[
literal|8
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|s
decl_stmt|;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
comment|/* 8th bit on */
name|sprintf
argument_list|(
name|cp
operator|++
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
name|SP
condition|)
block|{
comment|/* Control character */
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"^%c"
argument_list|,
name|ctl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|DEL
condition|)
block|{
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"^?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Printing character */
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|s
expr_stmt|;
comment|/* Return pointer to it */
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  C K H O S T  --  Get name of local host (where C-Kermit is running)  */
end_comment

begin_comment
comment|/*   Call with pointer to buffer to put hostname in, and length of buffer.   Copies hostname into buffer on success, puts null string in buffer on   failure. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATTSV
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTSV */
end_comment

begin_function
name|VOID
name|ckhost
parameter_list|(
name|vvbuf
parameter_list|,
name|vvlen
parameter_list|)
name|char
modifier|*
name|vvbuf
decl_stmt|;
name|int
name|vvlen
decl_stmt|;
block|{
name|char
modifier|*
name|g
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|x
decl_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|ATTSV
name|struct
name|utsname
name|hname
decl_stmt|;
endif|#
directive|endif
comment|/* ATTSV */
operator|*
name|vvbuf
operator|=
name|NUL
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTSV
if|if
condition|(
name|uname
argument_list|(
operator|&
name|hname
argument_list|)
operator|>
operator|-
literal|1
condition|)
name|strncpy
argument_list|(
name|vvbuf
argument_list|,
name|hname
operator|.
name|nodename
argument_list|,
name|vvlen
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD4
if|if
condition|(
name|gethostname
argument_list|(
name|vvbuf
argument_list|,
name|vvlen
argument_list|)
operator|<
literal|0
condition|)
operator|*
name|vvbuf
operator|=
name|NUL
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
name|g
operator|=
name|getenv
argument_list|(
literal|"SYS$NODE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
condition|)
name|strncpy
argument_list|(
name|vvbuf
argument_list|,
name|g
argument_list|,
name|vvlen
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|vvbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|1
operator|&&
name|vvbuf
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|vvbuf
index|[
name|x
operator|-
literal|2
index|]
operator|==
literal|':'
condition|)
name|vvbuf
index|[
name|x
operator|-
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* BSD4 */
endif|#
directive|endif
comment|/* ATTSV */
if|if
condition|(
operator|*
name|vvbuf
operator|==
name|NUL
condition|)
block|{
comment|/* If it's still empty */
name|g
operator|=
name|getenv
argument_list|(
literal|"HOST"
argument_list|)
expr_stmt|;
comment|/* try this */
if|if
condition|(
name|g
condition|)
name|strncpy
argument_list|(
name|vvbuf
argument_list|,
name|g
argument_list|,
name|vvlen
argument_list|)
expr_stmt|;
block|}
name|vvbuf
index|[
name|vvlen
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* Make sure result is terminated. */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_define
define|#
directive|define
name|ASKMORE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOHELP
end_ifndef

begin_define
define|#
directive|define
name|ASKMORE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOHELP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASKMORE
end_ifdef

begin_comment
comment|/*   A S K M O R E  --  Poor person's "more".   Returns 0 if no more, 1 if more wanted.   Presently used by SHO MAC, SHO GLOB, and HELP, so compiled out if   those options are also compiled out. */
end_comment

begin_function
name|int
name|askmore
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX
ifdef|#
directive|ifdef
name|NOSETBUF
name|printf
argument_list|(
literal|"more? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOSETBUF */
endif|#
directive|endif
comment|/* UNIX */
name|c
operator|=
name|coninc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Yes */
case|case
name|SP
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
case|case
literal|012
case|:
case|case
literal|015
case|:
name|printf
argument_list|(
literal|"\015      \015"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* No */
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|printf
argument_list|(
literal|"\015\012"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Invalid answer */
default|default:
name|printf
argument_list|(
literal|"Y or space-bar for yes, N for no\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASKMORE */
end_comment

begin_comment
comment|/*  T R A P  --  Terminal interrupt handler */
end_comment

begin_function
name|SIGTYP
name|trap
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|GEMDOS
comment|/* GEM is not reentrant, no i/o from interrupt level */
name|longjmp
argument_list|(
name|cmjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Jump back to parser now! */
endif|#
directive|endif
comment|/* GEMDOS */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"^C trap() caught signal"
argument_list|,
literal|""
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|zclose
argument_list|(
name|ZIFILE
argument_list|)
expr_stmt|;
comment|/* If we were transferring a file, */
name|zclose
argument_list|(
name|ZOFILE
argument_list|)
expr_stmt|;
comment|/* close it. */
ifdef|#
directive|ifdef
name|VMS
comment|/*   Fix terminal. */
name|conres
argument_list|()
expr_stmt|;
name|i
operator|=
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* Echo ^C to standard output */
if|if
condition|(
name|i
operator|<
literal|1
operator|&&
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
comment|/* If there was an error */
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* close standard output */
name|f
operator|=
name|fopen
argument_list|(
name|dftty
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* open the controlling terminal */
if|if
condition|(
name|f
condition|)
name|stdout
operator|=
name|f
expr_stmt|;
comment|/* and make it standard output */
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* and echo the ^C again. */
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* Not VMS, no problem... */
endif|#
directive|endif
comment|/* VMS */
ifndef|#
directive|ifndef
name|NOCCTRAP
ifdef|#
directive|ifdef
name|UNIX
name|ttimoff
argument_list|()
expr_stmt|;
comment|/* Turn off any timer interrupts */
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|OSK
name|ttimoff
argument_list|()
expr_stmt|;
comment|/* Turn off any timer interrupts */
endif|#
directive|endif
comment|/* OSK */
name|longjmp
argument_list|(
name|cmjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Jump back to parser */
else|#
directive|else
comment|/* No Ctrl-C trap, just exit. */
name|doexit
argument_list|(
name|BAD_EXIT
argument_list|,
name|what
argument_list|)
expr_stmt|;
comment|/* Exit poorly */
endif|#
directive|endif
comment|/* NOCCTRAP */
block|}
end_function

begin_comment
comment|/*  C C _ C L E A N  --  Cleanup after terminal interrupt handler */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GEMDOS
end_ifdef

begin_function
name|int
name|cc_clean
parameter_list|()
block|{
name|zclose
argument_list|(
name|ZIFILE
argument_list|)
expr_stmt|;
comment|/* If we were transferring a file, */
name|zclose
argument_list|(
name|ZOFILE
argument_list|)
expr_stmt|;
comment|/* close it. */
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* Not VMS, no problem... */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GEMDOS */
end_comment

begin_comment
comment|/*  S T P T R A P -- Handle SIGTSTP (suspend) signals */
end_comment

begin_function
name|SIGTYP
name|stptrap
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NOJC
name|int
name|x
decl_stmt|;
specifier|extern
name|int
name|cmflgs
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"stptrap() caught signal"
argument_list|,
literal|""
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suspend
condition|)
block|{
name|printf
argument_list|(
literal|"\r\nsuspend disabled\r\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOICP
if|if
condition|(
name|what
operator|==
name|W_COMMAND
condition|)
block|{
comment|/* If command parsing was */
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
comment|/* reissue the prompt and partial */
if|if
condition|(
operator|!
name|cmflgs
condition|)
comment|/* command (if any) */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOICP */
block|}
else|else
block|{
name|conres
argument_list|()
expr_stmt|;
comment|/* Reset the console */
ifndef|#
directive|ifndef
name|OS2
name|x
operator|=
name|psuspend
argument_list|(
name|suspend
argument_list|)
expr_stmt|;
comment|/* Try to suspend. */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* OS2 */
name|printf
argument_list|(
literal|"Job control not supported\r\n"
argument_list|)
expr_stmt|;
name|conint
argument_list|(
name|trap
argument_list|,
name|stptrap
argument_list|)
expr_stmt|;
comment|/* Rearm the trap. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"stptrap back from suspend"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|W_CONNECT
case|:
comment|/* If suspended during CONNECT? */
name|conbin
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
comment|/* put console back in binary mode */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"stptrap W_CONNECT"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOICP
case|case
name|W_COMMAND
case|:
comment|/* Suspended in command mode */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"stptrap W_COMMAND pflag"
argument_list|,
literal|""
argument_list|,
name|pflag
argument_list|)
expr_stmt|;
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
comment|/* Put back CBREAK tty mode */
if|if
condition|(
name|pflag
condition|)
block|{
comment|/* If command parsing was */
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
comment|/* reissue the prompt and partial */
if|if
condition|(
operator|!
name|cmflgs
condition|)
comment|/* command (if any) */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* NOICP */
default|default:
comment|/* All other cases... */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"stptrap default"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
comment|/* Put it back in CBREAK mode */
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* NOJC */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_comment
comment|/*   The rest of this file is for all implementations but the Macintosh. */
end_comment

begin_comment
comment|/*  C H K I N T  --  Check for console interrupts  */
end_comment

begin_function
name|int
name|chkint
parameter_list|()
block|{
name|int
name|ch
decl_stmt|,
name|cn
decl_stmt|;
name|long
name|zz
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|local
operator|)
operator|||
operator|(
name|quiet
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Only do this if local& not quiet */
ifdef|#
directive|ifdef
name|datageneral
name|cn
operator|=
operator|(
name|con_reads_mt
operator|)
condition|?
literal|1
else|:
name|conchk
argument_list|()
expr_stmt|;
comment|/* Any input waiting? */
else|#
directive|else
name|cn
operator|=
name|conchk
argument_list|()
expr_stmt|;
comment|/* Any input waiting? */
endif|#
directive|endif
comment|/* datageneral */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"conchk"
argument_list|,
literal|""
argument_list|,
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|datageneral
comment|/* We must be careful to just print out one result for each character      * read.  The flag, conint_avl, controls duplication of characters.      * Only one character is handled at a time, which is a reasonable      * limit.  More complicated schemes could handle a buffer.      */
if|if
condition|(
name|con_reads_mt
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|conint_ch
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* I/O error, or no data */
elseif|else
if|if
condition|(
name|conint_avl
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Char already read */
else|else
name|conint_avl
operator|=
literal|0
expr_stmt|;
comment|/* Flag char as read */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|coninc
argument_list|(
literal|5
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|ch
operator|=
name|coninc
argument_list|(
literal|5
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* datageneral */
switch|switch
condition|(
name|ch
operator|&
literal|0177
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
case|case
literal|0001
case|:
comment|/* Status report */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Status report:"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|" file type: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|binary
operator|==
name|XYFT_I
condition|)
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"image"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binary
operator|==
name|XYFT_L
condition|)
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"labeled"
argument_list|)
expr_stmt|;
else|else
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
else|#
directive|else
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
else|else
block|{
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
block|}
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
name|filcnt
argument_list|,
literal|" file number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsize
condition|)
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
name|fsize
argument_list|,
literal|" size"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
name|ffc
argument_list|,
literal|" characters so far"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsize
condition|)
block|{
name|zz
operator|=
operator|(
name|ffc
operator|*
literal|100L
operator|)
operator|/
name|fsize
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
name|zz
argument_list|,
literal|" percent done"
argument_list|)
expr_stmt|;
block|}
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|bctu
argument_list|,
literal|" block check"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|rptflg
argument_list|,
literal|" compression"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|ebqflg
argument_list|,
literal|" 8th-bit prefixing"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|lscapu
argument_list|,
literal|" locking shifts"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|network
condition|)
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
name|speed
argument_list|,
literal|" speed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|W_SEND
condition|)
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|spsiz
argument_list|,
literal|" packet length"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|what
operator|==
name|W_RECV
operator|||
name|what
operator|==
name|W_REMO
condition|)
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|urpsiz
argument_list|,
literal|" packet length"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|wslots
argument_list|,
literal|" window slots"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
case|case
literal|0002
case|:
comment|/* Cancel batch */
case|case
literal|'Z'
case|:
case|case
literal|'z'
case|:
case|case
literal|0032
case|:
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Cancelling Batch "
argument_list|)
expr_stmt|;
name|czseen
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
case|case
literal|0006
case|:
comment|/* Cancel file */
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
case|case
literal|0030
case|:
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Cancelling File "
argument_list|)
expr_stmt|;
name|cxseen
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
case|case
literal|0022
case|:
comment|/* Resend */
case|case
literal|0015
case|:
case|case
literal|0012
case|:
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Resending packet "
argument_list|)
expr_stmt|;
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
comment|/* Send error packet */
case|case
literal|0005
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
comment|/* Anything else, print message */
name|intmsg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  I N T M S G  --  Issue message about terminal interrupts  */
end_comment

begin_function
name|VOID
name|intmsg
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|displa
operator|||
name|quiet
condition|)
comment|/* Not if we're being quiet */
return|return;
if|if
condition|(
name|server
operator|&&
operator|(
operator|!
name|srvdis
operator|||
name|n
operator|>
operator|-
literal|1L
operator|)
condition|)
comment|/* Special for server */
return|return;
name|buf
index|[
literal|0
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* Keep compilers happy */
ifdef|#
directive|ifdef
name|ATTSV
name|conchk
argument_list|()
expr_stmt|;
comment|/* Clear out pending escape-signals */
endif|#
directive|endif
comment|/* ATTSV */
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
comment|/* So Ctrl-C will work */
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
operator|(
operator|!
name|server
operator|&&
name|n
operator|==
literal|1L
operator|)
operator|||
operator|(
name|server
operator|&&
name|n
operator|<
literal|0L
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ATTSV
comment|/* We need to signal before kb input */
ifndef|#
directive|ifndef
name|aegis
ifndef|#
directive|ifndef
name|datageneral
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Type escape character (%s) followed by:"
argument_list|,
name|dbchr
argument_list|(
name|escape
argument_list|)
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
endif|#
directive|endif
comment|/* aegis */
endif|#
directive|endif
comment|/* ATTSV */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"X to cancel file,  CR to resend current packet"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Z to cancel group, A for status report"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"E to send Error packet, Ctrl-C to quit immediately: "
argument_list|)
expr_stmt|;
comment|/* if (server) */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|screen
argument_list|(
name|SCR_TU
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  S C R E E N  --  Screen display function  */
end_comment

begin_comment
comment|/*  screen(f,c,n,s)       f - argument descriptor       c - a character or small integer       n - a long integer       s - a string.  Fill in this routine with the appropriate display update for the system.  This version is for a dumb tty. */
end_comment

begin_function
name|VOID
ifdef|#
directive|ifdef
name|CK_ANSIC
name|screen
parameter_list|(
name|int
name|f
parameter_list|,
name|char
name|c
parameter_list|,
name|long
name|n
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
else|#
directive|else
function|screen
parameter_list|(
name|f
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|)
name|int
name|f
decl_stmt|;
name|char
name|c
decl_stmt|;
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* screen */
block|{
specifier|static
name|int
name|p
init|=
literal|0
decl_stmt|;
comment|/* Screen position */
name|int
name|len
decl_stmt|;
comment|/* Length of string */
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* Output buffer */
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Length of string */
if|if
condition|(
operator|(
name|f
operator|!=
name|SCR_WM
operator|)
operator|&&
operator|(
name|f
operator|!=
name|SCR_EM
operator|)
condition|)
comment|/* Always update warning& errors */
if|if
condition|(
operator|!
name|displa
operator|||
name|quiet
operator|||
name|backgrd
operator|||
operator|(
name|server
operator|&&
operator|!
name|srvdis
operator|)
condition|)
return|return;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|SCR_FN
case|:
comment|/* filename */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|conoc
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
operator|+
literal|1
expr_stmt|;
return|return;
case|case
name|SCR_AN
case|:
comment|/* as-name */
if|if
condition|(
name|p
operator|+
name|len
operator|>
literal|75
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conol
argument_list|(
literal|"=> "
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|+=
operator|(
name|len
operator|+
literal|3
operator|)
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return;
case|case
name|SCR_FS
case|:
comment|/* file-size */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|", Size: %ld"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|SCR_XD
case|:
comment|/* x-packet data */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|SCR_ST
case|:
comment|/* File status */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ST_OK
case|:
comment|/*  Transferred OK */
if|if
condition|(
operator|(
name|p
operator|+=
literal|5
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conoll
argument_list|(
literal|" [OK]"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
return|return;
case|case
name|ST_DISC
case|:
comment|/*  Discarded */
if|if
condition|(
operator|(
name|p
operator|+=
literal|12
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conoll
argument_list|(
literal|" [discarded]"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|12
expr_stmt|;
return|return;
case|case
name|ST_INT
case|:
comment|/*  Interrupted */
if|if
condition|(
operator|(
name|p
operator|+=
literal|14
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conoll
argument_list|(
literal|" [interrupted]"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|14
expr_stmt|;
return|return;
case|case
name|ST_SKIP
case|:
comment|/*  Skipped */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
literal|"Skipping "
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|ST_ERR
case|:
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
literal|"Error "
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|ST_REFU
case|:
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
literal|"Refused: "
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|conoll
argument_list|(
literal|"*** screen() called with bad status ***"
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
case|case
name|SCR_PN
case|:
comment|/* Packet number */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %ld"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_PT
case|:
comment|/* Packet type or pseudotype */
if|if
condition|(
name|c
operator|==
literal|'Y'
condition|)
return|return;
comment|/* Don't bother with ACKs */
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
block|{
comment|/* Only show every 4th data packet */
if|if
condition|(
name|n
operator|%
literal|4
condition|)
return|return;
name|c
operator|=
literal|'.'
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|AMIGA
if|if
condition|(
name|p
operator|++
operator|>
literal|77
condition|)
block|{
comment|/* If near right margin, */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Start new line */
name|p
operator|=
literal|0
expr_stmt|;
comment|/* and reset counter. */
block|}
endif|#
directive|endif
comment|/* AMIGA */
name|conoc
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Display the character. */
ifdef|#
directive|ifdef
name|AMIGA
if|if
condition|(
name|c
operator|==
literal|'G'
condition|)
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* new line after G packets */
endif|#
directive|endif
comment|/* AMIGA */
return|return;
case|case
name|SCR_TC
case|:
comment|/* transaction complete */
name|conoc
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_EM
case|:
comment|/* Error message */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conoc
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
comment|/* +1	*/
case|case
name|SCR_WM
case|:
comment|/* Warning message */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|SCR_TU
case|:
comment|/* Undelimited text */
if|if
condition|(
operator|(
name|p
operator|+=
name|len
operator|)
operator|>
literal|77
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
expr_stmt|;
block|}
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_TN
case|:
comment|/* Text delimited at beginning */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
expr_stmt|;
return|return;
case|case
name|SCR_TZ
case|:
comment|/* Text delimited at end */
if|if
condition|(
operator|(
name|p
operator|+=
name|len
operator|)
operator|>
literal|77
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
expr_stmt|;
block|}
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_QE
case|:
comment|/* Quantity equals */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %ld"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|conoll
argument_list|(
literal|"*** screen() called with bad object ***"
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  E R M S G  --  Nonfatal error message  */
end_comment

begin_comment
comment|/* Should be used only for printing the message text from an Error packet. */
end_comment

begin_function
name|VOID
name|ermsg
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
comment|/* Print error message */
if|if
condition|(
name|local
operator|&&
operator|!
name|quiet
condition|)
block|{
ifdef|#
directive|ifdef
name|OSK
name|printf
argument_list|(
literal|"\n%s %s\n"
argument_list|,
literal|"Protocol Error:"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\r\n%s %s\r\n"
argument_list|,
literal|"Protocol Error:"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OSK */
block|}
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Protocol Error:"
argument_list|,
name|msg
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|doclean
parameter_list|()
block|{
comment|/* General cleanup upon exit */
ifndef|#
directive|ifndef
name|NOICP
ifndef|#
directive|ifndef
name|NOSPL
specifier|extern
name|struct
name|mtab
modifier|*
name|mactab
decl_stmt|;
comment|/* For ON_EXIT macro. */
specifier|extern
name|int
name|nmac
decl_stmt|;
endif|#
directive|endif
comment|/* NOSPL */
endif|#
directive|endif
comment|/* NOICP */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
condition|)
block|{
comment|/* Close any open logs. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"Debug Log Closed"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|debfil
operator|=
literal|'\0'
expr_stmt|;
name|deblog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZDFILE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|pktlog
condition|)
block|{
operator|*
name|pktfil
operator|=
literal|'\0'
expr_stmt|;
name|pktlog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZPFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seslog
condition|)
block|{
operator|*
name|sesfil
operator|=
literal|'\0'
expr_stmt|;
name|seslog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZSFILE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TLOG
if|if
condition|(
name|tralog
condition|)
block|{
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Transaction Log Closed"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
operator|*
name|trafil
operator|=
literal|'\0'
expr_stmt|;
name|tralog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZTFILE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TLOG */
ifndef|#
directive|ifndef
name|NOICP
ifndef|#
directive|ifndef
name|NOSPL
name|zclose
argument_list|(
name|ZRFILE
argument_list|)
expr_stmt|;
comment|/* READ and WRITE files, if any. */
name|zclose
argument_list|(
name|ZWFILE
argument_list|)
expr_stmt|;
comment|/*   If a macro named "on_exit" is defined, execute it.  Also remove it from the   macro table, in case its definition includes an EXIT or QUIT command, which   would cause much recursion and would prevent the program from ever actually   EXITing. */
if|if
condition|(
name|nmac
condition|)
block|{
comment|/* Any macros defined? */
name|int
name|k
decl_stmt|;
comment|/* Yes */
name|k
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"on_exit"
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* Look up "on_exit" */
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
block|{
comment|/* If found, */
operator|*
operator|(
name|mactab
index|[
name|k
index|]
operator|.
name|kwd
operator|)
operator|=
name|NUL
expr_stmt|;
comment|/* poke its name from the table, */
if|if
condition|(
name|dodo
argument_list|(
name|k
argument_list|,
literal|""
argument_list|)
operator|>
operator|-
literal|1
condition|)
comment|/* set it up, */
name|parser
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* and execute it */
block|}
block|}
endif|#
directive|endif
comment|/* NOSPL */
endif|#
directive|endif
comment|/* NOICP */
comment|/*   Put console terminal back to normal.  This is done here because the   ON_EXIT macro calls the parser, which meddles with console terminal modes. */
name|ttclos
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close external line, if any */
if|if
condition|(
name|local
condition|)
block|{
name|strcpy
argument_list|(
name|ttname
argument_list|,
name|dftty
argument_list|)
expr_stmt|;
comment|/* Restore default tty */
name|local
operator|=
name|dfloc
expr_stmt|;
comment|/* And default remote/local status */
block|}
name|conres
argument_list|()
expr_stmt|;
comment|/* Restore console terminal. */
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Should be no need for this, and maybe it's screwing this up? */
name|connoi
argument_list|()
expr_stmt|;
comment|/* Turn off console interrupt traps */
endif|#
directive|endif
comment|/* COMMENT */
name|syscleanup
argument_list|()
expr_stmt|;
comment|/* System-dependent cleanup, last */
block|}
end_function

begin_comment
comment|/*  D O E X I T  --  Exit from the program.  */
end_comment

begin_comment
comment|/*   First arg is general, system-independent symbol: GOOD_EXIT or BAD_EXIT.   If second arg is -1, take 1st arg literally.   If second arg is not -1, work it into the exit code. */
end_comment

begin_function
name|VOID
name|doexit
parameter_list|(
name|exitstat
parameter_list|,
name|what
parameter_list|)
name|int
name|exitstat
decl_stmt|,
name|what
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|char
name|envstr
index|[
literal|64
index|]
decl_stmt|;
specifier|static
name|$DESCRIPTOR
argument_list|(
name|symnam
argument_list|,
literal|"CKERMIT_STATUS"
argument_list|)
expr_stmt|;
specifier|static
name|struct
name|dsc$descriptor_s
name|symval
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"doexit exitstat"
argument_list|,
literal|""
argument_list|,
name|exitstat
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"doexit what"
argument_list|,
literal|""
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|doclean
argument_list|()
expr_stmt|;
comment|/* First, clean up everything */
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|what
operator|==
operator|-
literal|1
condition|)
name|what
operator|=
literal|0
expr_stmt|;
comment|/* Since we set two different items */
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"%d"
argument_list|,
name|exitstat
operator||
name|what
argument_list|)
expr_stmt|;
name|symval
operator|.
name|dsc$w_length
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
name|symval
operator|.
name|dsc$a_pointer
operator|=
name|envstr
expr_stmt|;
name|symval
operator|.
name|dsc$b_class
operator|=
name|DSC$K_CLASS_S
expr_stmt|;
name|symval
operator|.
name|dsc$b_dtype
operator|=
name|DSC$K_DTYPE_T
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
comment|/* Store in global table */
name|LIB$SET_SYMBOL
argument_list|(
operator|&
name|symnam
argument_list|,
operator|&
name|symval
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitstat
operator|==
name|BAD_EXIT
condition|)
name|exitstat
operator|=
name|SS$_ABORT
operator||
name|STS$M_INHIB_MSG
expr_stmt|;
if|if
condition|(
name|exitstat
operator|==
name|GOOD_EXIT
condition|)
name|exitstat
operator|=
name|SS$_NORMAL
operator||
name|STS$M_INHIB_MSG
expr_stmt|;
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Not VMS */
if|if
condition|(
name|what
operator|==
operator|-
literal|1
condition|)
comment|/* Take 1st arg literally */
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
comment|/* e.g. user-supplied exit code */
else|else
comment|/* otherwise */
name|exit
argument_list|(
name|exitstat
operator||
name|what
argument_list|)
expr_stmt|;
comment|/* OR in the bits */
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_comment
comment|/* Set up interrupts */
end_comment

begin_function
name|VOID
name|setint
parameter_list|()
block|{
name|conint
argument_list|(
name|trap
argument_list|,
name|stptrap
argument_list|)
expr_stmt|;
comment|/* Turn on console terminal interrupts. */
name|bgchk
argument_list|()
expr_stmt|;
comment|/* Check background status */
block|}
end_function

begin_function
name|VOID
name|bgchk
parameter_list|()
block|{
comment|/* Check background status */
if|if
condition|(
name|bgset
operator|<
literal|0
condition|)
name|pflag
operator|=
operator|!
name|backgrd
expr_stmt|;
else|else
name|pflag
operator|=
operator|(
name|bgset
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  D E B U G  --  Enter a record in the debugging log  */
end_comment

begin_comment
comment|/*  Call with a format, two strings, and a number:    f  - Format, a bit string in range 0-7.         If bit x is on, then argument number x is printed.    s1 - String, argument number 1.  If selected, printed as is.    s2 - String, argument number 2.  If selected, printed in brackets.    n  - Int, argument 3.  If selected, printed preceded by equals sign.      f=0 is special: print s1,s2, and interpret n as a char. */
end_comment

begin_define
define|#
directive|define
name|DBUFL
value|2300
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dbptr
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dodebug
parameter_list|(
name|f
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|dbptr
condition|)
block|{
name|dbptr
operator|=
name|malloc
argument_list|(
name|DBUFL
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbptr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|dbptr
expr_stmt|;
if|if
condition|(
operator|!
name|deblog
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If no debug log, don't. */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|F000
case|:
comment|/* 0, print both strings, and n as a char */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|5
operator|>
name|DBUFL
condition|)
block|{
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"DEBUG string too long\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|>
literal|31
operator|&&
name|n
operator|<
literal|127
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s%s:%c\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|32
operator|||
name|n
operator|==
literal|127
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s%s:^%c\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
operator|(
name|n
operator|+
literal|64
operator|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|127
operator|&&
name|n
operator|<
literal|160
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s%s:~^%c\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
operator|(
name|n
operator|-
literal|64
operator|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|159
operator|&&
name|n
operator|<
literal|256
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s%s:~%c\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s%s:%ld\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F001
case|:
comment|/* 1, "=n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"=%ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F010
case|:
comment|/* 2, "[s2]" */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|4
operator|>
name|DBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"DEBUG string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s]\n"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
literal|""
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F011
case|:
comment|/* 3, "[s2]=n" */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|15
operator|>
name|DBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"DEBUG string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s]=%ld\n"
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F100
case|:
comment|/* 4, "s1" */
if|if
condition|(
name|zsoutl
argument_list|(
name|ZDFILE
argument_list|,
name|s1
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F101
case|:
comment|/* 5, "s1=n" */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|15
operator|>
name|DBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"DEBUG string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s=%ld\n"
argument_list|,
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F110
case|:
comment|/* 6, "s1[s2]" */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|4
operator|>
name|DBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"DEBUG string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s[%s]\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F111
case|:
comment|/* 7, "s1[s2]=n" */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|15
operator|>
name|DBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"DEBUG string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s[%s]=%ld\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"\n?Invalid format for debug() - %d\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|dbptr
argument_list|)
operator|<
literal|0
condition|)
name|deblog
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TLOG
end_ifdef

begin_define
define|#
directive|define
name|TBUFL
value|300
end_define

begin_comment
comment|/*  T L O G  --  Log a record in the transaction file  */
end_comment

begin_comment
comment|/*  Call with a format and 3 arguments: two strings and a number:    f  - Format, a bit string in range 0-7, bit x is on, arg #x is printed.    s1,s2 - String arguments 1 and 2.    n  - Int, argument 3. */
end_comment

begin_function
name|VOID
name|tlog
parameter_list|(
name|f
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|int
name|f
decl_stmt|;
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|s
index|[
name|TBUFL
index|]
decl_stmt|;
name|char
modifier|*
name|sp
init|=
name|s
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|tralog
condition|)
return|return;
comment|/* If no transaction log, don't */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|F000
case|:
comment|/* 0 (special) "s1 n s2"  */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|15
operator|>
name|TBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"?T-Log string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s %ld %s\n"
argument_list|,
name|s1
argument_list|,
name|n
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F001
case|:
comment|/* 1, " n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|" %ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F010
case|:
comment|/* 2, "[s2]" */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|x
operator|+
literal|6
operator|>
name|TBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"?T-Log string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s]\n"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
literal|""
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F011
case|:
comment|/* 3, "[s2] n" */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|x
operator|+
literal|6
operator|>
name|TBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"?T-Log string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s] %ld\n"
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F100
case|:
comment|/* 4, "s1" */
if|if
condition|(
name|zsoutl
argument_list|(
name|ZTFILE
argument_list|,
name|s1
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F101
case|:
comment|/* 5, "s1: n" */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|15
operator|>
name|TBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"?T-Log string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s: %ld\n"
argument_list|,
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F110
case|:
comment|/* 6, "s1 s2" */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|x
operator|+
literal|4
operator|>
name|TBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"?T-Log string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|F111
case|:
comment|/* 7, "s1 s2: n" */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|x
operator|+
literal|15
operator|>
name|TBUFL
condition|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"?T-Log string too long\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s %s: %ld\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"\n?Invalid format for tlog() - %ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
name|tralog
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TLOG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

end_unit

