begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_comment
comment|/*  C K U U S 3 --  "User Interface" for Unix Kermit, part 3  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*  SET command (but much material has been split off into ckuus7.c). */
end_comment

begin_comment
comment|/*   Kermit-specific includes.   Definitions here supersede those from system include files. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_comment
comment|/* Debugging& compiler things */
end_comment

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_comment
comment|/* ASCII character symbols */
end_comment

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_comment
comment|/* Kermit application definitions */
end_comment

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_comment
comment|/* Character set translation */
end_comment

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_comment
comment|/* Network symbols */
end_comment

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_comment
comment|/* User interface symbols */
end_comment

begin_comment
comment|/* Variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size
decl_stmt|,
name|spsiz
decl_stmt|,
name|spmax
decl_stmt|,
name|urpsiz
decl_stmt|,
name|srvtim
decl_stmt|,
name|local
decl_stmt|,
name|server
decl_stmt|,
name|success
decl_stmt|,
name|flow
decl_stmt|,
name|binary
decl_stmt|,
name|delay
decl_stmt|,
name|parity
decl_stmt|,
name|escape
decl_stmt|,
name|what
decl_stmt|,
name|srvdis
decl_stmt|,
name|turn
decl_stmt|,
name|duplex
decl_stmt|,
name|turnch
decl_stmt|,
name|bctr
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|keep
decl_stmt|,
name|maxtry
decl_stmt|,
name|unkcs
decl_stmt|,
name|network
decl_stmt|,
name|ebqflg
decl_stmt|,
name|quiet
decl_stmt|,
name|swcapr
decl_stmt|,
name|nettype
decl_stmt|,
name|wslotr
decl_stmt|,
name|lscapr
decl_stmt|,
name|lscapu
decl_stmt|,
name|carrier
decl_stmt|,
name|debses
decl_stmt|,
name|cdtimo
decl_stmt|,
name|nlangs
decl_stmt|,
name|bgset
decl_stmt|,
name|pflag
decl_stmt|,
name|dblchar
decl_stmt|,
name|cmdmsk
decl_stmt|,
name|spsizr
decl_stmt|,
name|wildxpand
decl_stmt|,
name|suspend
decl_stmt|,
name|techo
decl_stmt|,
name|terror
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSCRIPT
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|secho
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether SCRIPT cmd should echo */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSCRIPT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|count
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|count
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|mecho
decl_stmt|,
name|merror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro echo, error */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|incase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INPUT case */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bigsbsiz
decl_stmt|,
name|bigrbsiz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet buffers */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|speed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal speed */
end_comment

begin_decl_stmt
specifier|extern
name|CHAR
name|sstate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protocol start state */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Communication device name */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NOSETKEY
end_ifndef

begin_decl_stmt
specifier|extern
name|KEY
modifier|*
name|keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character map for SET KEY (1:1)  */
end_comment

begin_decl_stmt
specifier|extern
name|MACRO
modifier|*
name|macrotab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro map for SET KEY (1:string) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_decl_stmt
name|int
name|wideresult
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for SET KEY, wide OS/2 scan codes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSETKEY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_comment
comment|/* system-independent character sets, defined in ckcxla.[ch] */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|csinfo
name|tcsinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|langinfo
name|langs
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other character-set related variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tcharset
decl_stmt|,
name|tslevel
decl_stmt|,
name|language
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_comment
comment|/* Declarations from cmd package */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmdbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|line
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_comment
comment|/* From main ckuser module... */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|tmpbuf
index|[]
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary buffer */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take Command file level */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|cmdlvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Overall command level */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|sessft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Session-log file type */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Keyword tables for SET commands */
end_comment

begin_comment
comment|/* For SET MODEM */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|autotab
index|[]
init|=
block|{
literal|"changes-speed"
block|,
literal|1
block|,
literal|0
block|,
literal|"matches-speed"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For SET CARRIER */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|crrtab
index|[]
init|=
block|{
literal|"auto"
block|,
name|CAR_AUT
block|,
literal|0
block|,
literal|"off"
block|,
name|CAR_OFF
block|,
literal|0
block|,
literal|"on"
block|,
name|CAR_ON
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncrr
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For SET DEBUG */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|dbgtab
index|[]
init|=
block|{
literal|"off"
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|,
literal|1
block|,
literal|0
block|,
literal|"session"
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndbg
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transmission speeds */
end_comment

begin_comment
comment|/* Note, the values are encoded in cps rather than bps because 19200 and */
end_comment

begin_comment
comment|/* 38400 are too big for some ints.  All but 75bps are multiples of ten. */
end_comment

begin_comment
comment|/* Result of lookup in this table must be multiplied by 10 to get actual */
end_comment

begin_comment
comment|/* speed in bps.  If this number is 70, it must be changed to 75. */
end_comment

begin_comment
comment|/* If it is 888, this means 75/1200 split speed.  134.5 (IBM 2741) is not */
end_comment

begin_comment
comment|/* supported, and split speed is not possible in AT&T UNIX. */
end_comment

begin_comment
comment|/* The values are generic, rather than specific to UNIX.  We can't use */
end_comment

begin_comment
comment|/* B75, B1200, B9600, etc, because non-UNIX versions of C-Kermit will not */
end_comment

begin_comment
comment|/* necessarily have these symbols defined. */
end_comment

begin_comment
comment|/* Like all other keytabs, this one must be in "alphabetical" order, */
end_comment

begin_comment
comment|/* rather than numeric order. */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|spdtab
index|[]
init|=
block|{
literal|"0"
block|,
literal|0
block|,
name|CM_INV
block|,
literal|"110"
block|,
literal|11
block|,
literal|0
block|,
literal|"1200"
block|,
literal|120
block|,
literal|0
block|,
literal|"150"
block|,
literal|15
block|,
literal|0
block|,
literal|"19200"
block|,
literal|1920
block|,
literal|0
block|,
literal|"200"
block|,
literal|20
block|,
literal|0
block|,
literal|"2400"
block|,
literal|240
block|,
literal|0
block|,
literal|"300"
block|,
literal|30
block|,
literal|0
block|,
literal|"3600"
block|,
literal|360
block|,
literal|0
block|,
literal|"38400"
block|,
literal|3840
block|,
literal|0
block|,
literal|"4800"
block|,
literal|480
block|,
literal|0
block|,
literal|"50"
block|,
literal|5
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|OS2
literal|"57600"
block|,
literal|5760
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"600"
block|,
literal|60
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|OS2
literal|"7200"
block|,
literal|720
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"75"
block|,
literal|7
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|ANYBSD
literal|"75/1200"
block|,
literal|888
block|,
literal|0
block|,
comment|/* Special code "888" for split speed */
endif|#
directive|endif
literal|"9600"
block|,
literal|960
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nspd
init|=
operator|(
sizeof|sizeof
argument_list|(
name|spdtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many speeds */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|lngtab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Languages for SET LANGUAGE */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nlng
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_comment
comment|/* Duplex keyword table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|dpxtab
index|[]
init|=
block|{
literal|"full"
block|,
literal|0
block|,
literal|0
block|,
literal|"half"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SET FILE parameters */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|filtab
index|[]
init|=
block|{
literal|"bytesize"
block|,
name|XYFILS
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOCSETS
literal|"character-set"
block|,
name|XYFILC
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOCSETS */
literal|"collision"
block|,
name|XYFILX
block|,
literal|0
block|,
literal|"display"
block|,
name|XYFILD
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|VMS
literal|"label"
block|,
name|XYFILL
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* VMS */
literal|"names"
block|,
name|XYFILN
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|VMS
literal|"record-length"
block|,
name|XYFILR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* VMS */
literal|"type"
block|,
name|XYFILT
block|,
literal|0
block|,
literal|"warning"
block|,
name|XYFILW
block|,
name|CM_INV
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfilp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|filtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flow Control */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UTEK
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|flotab
index|[]
init|=
block|{
literal|"none"
block|,
name|FLO_NONE
block|,
literal|0
block|,
literal|"xon/xoff"
block|,
name|FLO_XONX
block|,
literal|0
block|,
literal|"idtr/octs"
block|,
name|FLO_HARD
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|keytab
name|flotab
index|[]
init|=
block|{
literal|"none"
block|,
name|FLO_NONE
block|,
literal|0
block|,
literal|"dtr/cd"
block|,
name|FLO_DTRC
block|,
literal|0
block|,
literal|"rts/cts"
block|,
name|FLO_RTSC
block|,
literal|0
block|,
literal|"xon/xoff"
block|,
name|FLO_XONX
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTEK */
end_comment

begin_decl_stmt
name|int
name|nflo
init|=
operator|(
sizeof|sizeof
argument_list|(
name|flotab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Handshake characters  */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|hshtab
index|[]
init|=
block|{
literal|"bell"
block|,
literal|007
block|,
literal|0
block|,
literal|"code"
block|,
literal|998
block|,
literal|0
block|,
literal|"cr"
block|,
literal|015
block|,
literal|0
block|,
literal|"esc"
block|,
literal|033
block|,
literal|0
block|,
literal|"lf"
block|,
literal|012
block|,
literal|0
block|,
literal|"none"
block|,
literal|999
block|,
literal|0
block|,
comment|/* (can't use negative numbers) */
literal|"xoff"
block|,
literal|023
block|,
literal|0
block|,
literal|"xon"
block|,
literal|021
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nhsh
init|=
operator|(
sizeof|sizeof
argument_list|(
name|hshtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|fttab
index|[]
init|=
block|{
comment|/* File types */
ifdef|#
directive|ifdef
name|VMS
literal|"b"
block|,
name|XYFT_B
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
endif|#
directive|endif
comment|/* VMS */
literal|"binary"
block|,
name|XYFT_B
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|VMS
literal|"block"
block|,
name|XYFT_I
block|,
name|CM_INV
block|,
literal|"image"
block|,
name|XYFT_I
block|,
literal|0
block|,
literal|"labeled"
block|,
name|XYFT_L
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* VMS */
literal|"text"
block|,
name|XYFT_T
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfttyp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|fttab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|mdmtab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modem types (in module ckudia.c) */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nmdm
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|wildtab
index|[]
init|=
block|{
comment|/* SET WILDCARD-EXPANSION */
literal|"kermit"
block|,
literal|0
block|,
literal|0
block|,
literal|"shell"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|netcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nnets
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|x25tab
index|[]
init|=
block|{
literal|"call-user-data"
block|,
name|XYUDAT
block|,
literal|0
block|,
literal|"closed-user-group"
block|,
name|XYCLOS
block|,
literal|0
block|,
literal|"reverse-charge"
block|,
name|XYREVC
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nx25
init|=
operator|(
sizeof|sizeof
argument_list|(
name|x25tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|padx3tab
index|[]
init|=
block|{
literal|"break-action"
block|,
name|PAD_BREAK_ACTION
block|,
literal|0
block|,
literal|"break-character"
block|,
name|PAD_BREAK_CHARACTER
block|,
literal|0
block|,
literal|"character-delete"
block|,
name|PAD_CHAR_DELETE_CHAR
block|,
literal|0
block|,
literal|"cr-padding"
block|,
name|PAD_PADDING_AFTER_CR
block|,
literal|0
block|,
literal|"discard-output"
block|,
name|PAD_SUPPRESSION_OF_DATA
block|,
literal|0
block|,
literal|"echo"
block|,
name|PAD_ECHO
block|,
literal|0
block|,
literal|"editing"
block|,
name|PAD_EDITING
block|,
literal|0
block|,
literal|"escape"
block|,
name|PAD_ESCAPE
block|,
literal|0
block|,
literal|"forward"
block|,
name|PAD_DATA_FORWARD_CHAR
block|,
literal|0
block|,
literal|"lf-padding"
block|,
name|PAD_PADDING_AFTER_LF
block|,
literal|0
block|,
literal|"lf-insert"
block|,
name|PAD_LF_AFTER_CR
block|,
literal|0
block|,
literal|"line-delete"
block|,
name|PAD_BUFFER_DELETE_CHAR
block|,
literal|0
block|,
literal|"line-display"
block|,
name|PAD_BUFFER_DISPLAY_CHAR
block|,
literal|0
block|,
literal|"line-fold"
block|,
name|PAD_LINE_FOLDING
block|,
literal|0
block|,
literal|"pad-flow-control"
block|,
name|PAD_FLOW_CONTROL_BY_PAD
block|,
literal|0
block|,
literal|"service-signals"
block|,
name|PAD_SUPPRESSION_OF_SIGNALS
block|,
literal|0
block|,
literal|"timeout"
block|,
name|PAD_DATA_FORWARD_TIMEOUT
block|,
literal|0
block|,
comment|/* Speed is read-only */
literal|"transmission-rate"
block|,
name|PAD_LINE_SPEED
block|,
literal|0
block|,
literal|"user-flow-control"
block|,
name|PAD_FLOW_CONTROL_BY_USER
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npadx3
init|=
operator|(
sizeof|sizeof
argument_list|(
name|padx3tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_comment
comment|/* Parity keyword table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|partab
index|[]
init|=
block|{
literal|"even"
block|,
literal|'e'
block|,
literal|0
block|,
literal|"mark"
block|,
literal|'m'
block|,
literal|0
block|,
literal|"none"
block|,
literal|0
block|,
literal|0
block|,
literal|"odd"
block|,
literal|'o'
block|,
literal|0
block|,
literal|"space"
block|,
literal|'s'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npar
init|=
operator|(
sizeof|sizeof
argument_list|(
name|partab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On/Off table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|onoff
index|[]
init|=
block|{
literal|"off"
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incomplete File Disposition table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keytab
name|ifdtab
index|[]
init|=
block|{
literal|"discard"
block|,
literal|0
block|,
literal|0
block|,
literal|"keep"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take parameters table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keytab
name|taktab
index|[]
init|=
block|{
literal|"echo"
block|,
literal|0
block|,
literal|0
block|,
literal|"error"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSCRIPT
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|keytab
name|scrtab
index|[]
init|=
block|{
literal|"echo"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSCRIPT */
end_comment

begin_comment
comment|/* Bytesize table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|byttab
index|[]
init|=
block|{
literal|"bytesize"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSERVER
end_ifndef

begin_comment
comment|/* Server parameters table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|srvtab
index|[]
init|=
block|{
literal|"display"
block|,
name|XYSERD
block|,
literal|0
block|,
literal|"timeout"
block|,
name|XYSERT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSERVER */
end_comment

begin_comment
comment|/* 'set transfer' table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|tstab
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NOCSETS
literal|"character-set"
block|,
literal|1
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOCSETS */
literal|"locking-shift"
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nts
init|=
operator|(
sizeof|sizeof
argument_list|(
name|tstab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_comment
comment|/* SET TRANSFER CHARACTER-SET table */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|tcstab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ntcs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_comment
comment|/* SET TRANSFER LOCKING-SHIFT table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|lstab
index|[]
init|=
block|{
literal|"forced"
block|,
literal|2
block|,
literal|0
block|,
literal|"off"
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nls
init|=
operator|(
sizeof|sizeof
argument_list|(
name|lstab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NOSETKEY
end_ifndef

begin_function
name|int
name|set_key
parameter_list|()
block|{
comment|/* SET KEY */
name|int
name|y
decl_stmt|;
name|int
name|kc
decl_stmt|;
comment|/* Key code */
name|char
modifier|*
name|bind
decl_stmt|;
comment|/* Key binding */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"numeric key code"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|kc
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|kc
operator|<
literal|0
operator|||
name|kc
operator|>=
name|KMSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"?key code must be between 0 and %d\n"
argument_list|,
name|KMSIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"key definition"
argument_list|,
literal|""
argument_list|,
operator|&
name|bind
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|macrotab
index|[
name|kc
index|]
condition|)
block|{
comment|/* Possibly free old macro from key */
name|free
argument_list|(
name|macrotab
index|[
name|kc
index|]
argument_list|)
expr_stmt|;
name|macrotab
index|[
name|kc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|strlen
argument_list|(
name|bind
argument_list|)
condition|)
block|{
comment|/* Action depends on length */
case|case
literal|0
case|:
comment|/* Reset to default binding */
name|keymap
index|[
name|kc
index|]
operator|=
name|kc
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Single character */
ifdef|#
directive|ifdef
name|OS2
name|keymap
index|[
name|kc
index|]
operator|=
name|wideresult
expr_stmt|;
else|#
directive|else
name|keymap
index|[
name|kc
index|]
operator|=
operator|(
name|CHAR
operator|)
operator|*
name|bind
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
break|break;
default|default:
comment|/* Character string */
name|keymap
index|[
name|kc
index|]
operator|=
name|kc
expr_stmt|;
name|macrotab
index|[
name|kc
index|]
operator|=
operator|(
name|MACRO
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|bind
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|macrotab
index|[
name|kc
index|]
condition|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|macrotab
index|[
name|kc
index|]
argument_list|,
name|bind
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSETKEY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  D O P R M  --  Set a parameter.  */
end_comment

begin_comment
comment|/*  Returns:   -2: illegal input   -1: reparse needed    0: success */
end_comment

begin_function
name|int
name|doprm
parameter_list|(
name|xx
parameter_list|,
name|rmsflg
parameter_list|)
name|int
name|xx
decl_stmt|,
name|rmsflg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|,
name|z
decl_stmt|;
name|long
name|zz
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|xx
condition|)
block|{
ifdef|#
directive|ifdef
name|SUNX25
comment|/* SET X25 ... */
case|case
name|XYX25
case|:
return|return
operator|(
name|setx25
argument_list|()
operator|)
return|;
case|case
name|XYPAD
case|:
comment|/* SET PAD ... */
return|return
operator|(
name|setpadp
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* SUNX25 */
case|case
name|XYEOL
case|:
comment|/* These have all been moved to set send/receive... */
case|case
name|XYLEN
case|:
comment|/* Let the user know what to do. */
case|case
name|XYMARK
case|:
case|case
name|XYNPAD
case|:
case|case
name|XYPADC
case|:
case|case
name|XYTIMO
case|:
name|printf
argument_list|(
literal|"...Use 'set send' or 'set receive' instead.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Type 'help set send' or 'help set receive' for more info.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
case|case
name|XYATTR
case|:
comment|/* File Attribute packets */
return|return
operator|(
name|setat
argument_list|(
name|rmsflg
argument_list|)
operator|)
return|;
case|case
name|XYIFD
case|:
comment|/* Incomplete file disposition */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|ifdtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"discard"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"310"
argument_list|,
name|y
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|keep
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSPL
case|case
name|XYINPU
case|:
comment|/* SET INPUT */
return|return
operator|(
name|setinp
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
ifdef|#
directive|ifdef
name|NETCONN
case|case
name|XYNET
case|:
comment|/* SET NETWORK */
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|netcmd
argument_list|,
name|nnets
argument_list|,
literal|""
argument_list|,
literal|"tcp/ip"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|nettype
operator|=
name|z
expr_stmt|;
if|if
condition|(
operator|(
name|nettype
operator|!=
name|NET_SX25
operator|)
operator|&&
operator|(
name|nettype
operator|!=
name|NET_TCPB
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"?Network type not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NETCONN */
case|case
name|XYHOST
case|:
comment|/* SET HOST or SET LINE */
case|case
name|XYLINE
case|:
return|return
operator|(
name|setlin
argument_list|(
name|xx
argument_list|,
literal|1
argument_list|)
operator|)
return|;
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|NOSETKEY
case|case
name|XYKEY
case|:
comment|/* SET KEY */
return|return
operator|(
name|set_key
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOSETKEY */
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOCSETS
case|case
name|XYLANG
case|:
comment|/* Language */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|lngtab
argument_list|,
name|nlng
argument_list|,
literal|""
argument_list|,
literal|"none"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* language code */
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* And confirmation of command */
comment|/* Look up language and get associated character sets */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nlangs
operator|)
operator|&&
operator|(
name|langs
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|y
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
name|nlangs
condition|)
block|{
name|printf
argument_list|(
literal|"?internal error, sorry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
name|language
operator|=
name|i
expr_stmt|;
comment|/* All good, set the language, */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NOCSETS */
ifndef|#
directive|ifndef
name|MAC
case|case
name|XYBACK
case|:
comment|/* BACKGROUND */
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|bgset
operator|=
name|z
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
name|bgchk
argument_list|()
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
endif|#
directive|endif
comment|/* MAC */
case|case
name|XYQUIE
case|:
comment|/* QUIET */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|quiet
argument_list|)
operator|)
return|;
case|case
name|XYBUF
case|:
block|{
comment|/* BUFFERS */
ifdef|#
directive|ifdef
name|DYNAMIC
name|int
name|sb
decl_stmt|,
name|rb
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"send buffer size"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|sb
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
name|printf
argument_list|(
literal|"?two numbers required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|sb
operator|<
literal|80
condition|)
block|{
name|printf
argument_list|(
literal|"?too small"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"receive buffer size"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|rb
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
name|printf
argument_list|(
literal|"?receive buffer size required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|rb
operator|<
literal|80
condition|)
block|{
name|printf
argument_list|(
literal|"?too small"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|inibufs
argument_list|(
name|sb
argument_list|,
name|rb
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|y
operator|=
name|adjpkl
argument_list|(
name|urpsiz
argument_list|,
name|wslotr
argument_list|,
name|bigrbsiz
argument_list|)
expr_stmt|;
comment|/* Maybe adjust packet sizes */
if|if
condition|(
name|y
operator|!=
name|urpsiz
condition|)
name|urpsiz
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|adjpkl
argument_list|(
name|spsiz
argument_list|,
name|wslotr
argument_list|,
name|bigsbsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|spsiz
condition|)
name|spsiz
operator|=
name|spmax
operator|=
name|spsizr
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
else|#
directive|else
name|printf
argument_list|(
literal|"?Sorry, not available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* DYNAMIC */
block|}
case|case
name|XYCHKT
case|:
comment|/* BLOCK-CHECK */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"1, 2, or 3"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 1, 2, and 3\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|bctr
operator|=
name|x
expr_stmt|;
comment|/* Set locally too, even if REMOTE SET */
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"400"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|MAC
comment|/*   The Mac has no carrier... */
case|case
name|XYCARR
case|:
comment|/* CARRIER */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|crrtab
argument_list|,
name|ncrr
argument_list|,
literal|""
argument_list|,
literal|"auto"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|y
operator|==
name|CAR_ON
condition|)
block|{
name|x
operator|=
name|cmnum
argument_list|(
literal|"Carrier wait timeout, seconds"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|carrier
operator|=
name|ttscarr
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|cdtimo
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* MAC */
default|default:
break|break;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
ifndef|#
directive|ifndef
name|NOSPL
case|case
name|XYCOUN
case|:
comment|/* SET COUNT */
name|x
operator|=
name|cmnum
argument_list|(
literal|"Positive number"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?A positive number, please\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"XYCOUN: z"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|setnum
argument_list|(
operator|&
name|count
index|[
name|cmdlvl
index|]
argument_list|,
name|z
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
case|case
name|XYCASE
case|:
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|incase
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
case|case
name|XYCMD
case|:
comment|/* COMMAND ... */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|byttab
argument_list|,
name|nbytt
argument_list|,
literal|""
argument_list|,
literal|"bytesize"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"bytesize for command characters, 7 or 8"
argument_list|,
literal|"7"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|!=
literal|7
operator|&&
name|x
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n?The choices are 7 and 8\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|7
condition|)
name|cmdmsk
operator|=
literal|0177
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|8
condition|)
name|cmdmsk
operator|=
literal|0377
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYDFLT
case|:
comment|/* SET DEFAULT = CD */
return|return
operator|(
name|success
operator|=
name|docd
argument_list|()
operator|)
return|;
case|case
name|XYDEBU
case|:
comment|/* SET DEBUG { on, off, session } */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|dbgtab
argument_list|,
name|ndbg
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
switch|switch
condition|(
name|y
condition|)
block|{
case|case
literal|0
case|:
comment|/* 0 = all debugging off. */
name|debses
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|deblog
condition|)
name|doclslog
argument_list|(
name|LOGD
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
literal|1
case|:
comment|/* 1 = log debugging to debug.log */
name|deblog
operator|=
name|debopn
argument_list|(
literal|"debug.log"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|deblog
condition|?
literal|1
else|:
literal|0
operator|)
return|;
case|case
literal|2
case|:
comment|/* 2 = session. */
return|return
operator|(
name|success
operator|=
name|debses
operator|=
literal|1
operator|)
return|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"?Sorry, debugging not enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* DEBUG */
case|case
name|XYDELA
case|:
comment|/* SET DELAY */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Number of seconds before starting to send"
argument_list|,
literal|"5"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"XYDELA: y"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|setnum
argument_list|(
operator|&
name|delay
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|94
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
ifndef|#
directive|ifndef
name|NODIAL
case|case
name|XYDIAL
case|:
comment|/* SET DIAL */
return|return
operator|(
name|setdial
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NODIAL */
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Unused at present */
case|case
name|XYDOUB
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"Character to double"
argument_list|,
literal|"none"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|dblchar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Doubling Off\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|lp
argument_list|,
literal|"none"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|dblchar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Doubling Off\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|lp
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|dblchar
operator|=
operator|*
name|lp
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Doubled: %d\n"
argument_list|,
name|dblchar
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* COMMENT */
case|case
name|XYDUPL
case|:
comment|/* SET DUPLEX */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|dpxtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"full"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|duplex
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYLCLE
case|:
comment|/* LOCAL-ECHO (= DUPLEX) */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|duplex
argument_list|)
operator|)
return|;
case|case
name|XYESC
case|:
comment|/* SET ESCAPE */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for escape character"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|setcc
argument_list|(
operator|&
name|escape
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
case|case
name|XYFILE
case|:
comment|/* SET FILE */
return|return
operator|(
name|setfil
argument_list|(
name|rmsflg
argument_list|)
operator|)
return|;
case|case
name|XYFLOW
case|:
comment|/* FLOW-CONTROL */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|flotab
argument_list|,
name|nflo
argument_list|,
literal|""
argument_list|,
literal|"xon/xoff"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|NOTERMIX
ifdef|#
directive|ifdef
name|NEXT
if|if
condition|(
name|y
operator|!=
name|FLO_NONE
operator|||
name|y
operator|!=
name|FLO_XONX
condition|)
block|{
if|if
condition|(
name|y
operator|==
name|FLO_RTSC
condition|)
block|{
name|printf
argument_list|(
literal|"Informational only, you must use the /dev/cuf? device.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?Flow control type not supported on this computer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|y
operator|!=
name|FLO_NONE
operator|||
name|y
operator|!=
name|FLO_XONX
condition|)
block|{
name|printf
argument_list|(
literal|"?Flow control type not supported on this computer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NEXT */
endif|#
directive|endif
comment|/* TERMIX */
name|flow
operator|=
name|y
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"set flow"
argument_list|,
literal|""
argument_list|,
name|flow
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYHAND
case|:
comment|/* HANDSHAKE */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|hshtab
argument_list|,
name|nhsh
argument_list|,
literal|""
argument_list|,
literal|"none"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|y
operator|==
literal|998
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmnum
argument_list|(
literal|"ASCII value"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|<
literal|1
operator|)
operator|||
operator|(
operator|(
name|y
operator|>
literal|31
operator|)
operator|&&
operator|(
name|y
operator|!=
literal|127
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"?Character must be in ASCII control range\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|turn
operator|=
operator|(
name|y
operator|>
literal|0127
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|turnch
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
ifndef|#
directive|ifndef
name|NOSPL
case|case
name|XYMACR
case|:
comment|/* SET MACRO */
comment|/* Note, if TAKE and MACRO options become different, make a new table */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|taktab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|mecho
argument_list|)
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|merror
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NODIAL
case|case
name|XYMODM
case|:
comment|/* SET MODEM */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|mdmtab
argument_list|,
name|nmdm
argument_list|,
literal|"type of modem"
argument_list|,
literal|"none"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|autotab
argument_list|,
literal|2
argument_list|,
literal|"speed configuration"
argument_list|,
literal|"changes-speed"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|mdmtyp
operator|=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|mdmspd
operator|=
name|y
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NODIAL */
default|default:
break|break;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
case|case
name|XYPARI
case|:
comment|/* PARITY */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|partab
argument_list|,
name|npar
argument_list|,
literal|""
argument_list|,
literal|"none"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* If parity not none, then we also want 8th-bit prefixing */
if|if
condition|(
name|parity
operator|=
name|y
condition|)
name|ebqflg
operator|=
literal|1
expr_stmt|;
else|else
name|ebqflg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
ifndef|#
directive|ifndef
name|NOFRILLS
case|case
name|XYPROM
case|:
comment|/* SET PROMPT */
comment|/*   Note: xxstring not invoked here.  Instead, it is invoked every time the   prompt is issued.  This allows the prompt string to contain variables   that can change, like \v(dir), \v(time), etc. */
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Program's command prompt"
argument_list|,
literal|"Mac-Kermit>"
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Program's command prompt"
argument_list|,
literal|"C-Kermit>"
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* MAC */
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Remove enclosing braces, if any */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
condition|)
block|{
comment|/* For compatibility with pre-5A */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|cmsetp
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* set the prompt */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NOFRILLS */
case|case
name|XYRETR
case|:
comment|/* RETRY: per-packet retry limit */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Maximum retries per packet"
argument_list|,
literal|"10"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|setnum
argument_list|(
operator|&
name|maxtry
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|94
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|maxtry
operator|<=
name|wslotr
condition|)
block|{
name|printf
argument_list|(
literal|"?Retry limit must be greater than window size\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|maxtry
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"403"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
return|return
operator|(
name|success
operator|=
name|x
operator|)
return|;
ifndef|#
directive|ifndef
name|NOSERVER
case|case
name|XYSERV
case|:
comment|/* SET SERVER items */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|srvtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XYSERT
case|:
name|tp
operator|=
name|tmpbuf
expr_stmt|;
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|DSRVTIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"interval for server NAKs, 0 = none"
argument_list|,
name|tp
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Specify a positive number, or 0 for no server NAKs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"404"
argument_list|,
name|tp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|srvtim
operator|=
name|x
expr_stmt|;
comment|/* Set the server timeout variable */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
case|case
name|XYSERD
case|:
comment|/* SERVER DISPLAY */
name|seton
argument_list|(
operator|&
name|srvdis
argument_list|)
expr_stmt|;
comment|/* on or off... */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSERVER */
ifdef|#
directive|ifdef
name|UNIX
ifndef|#
directive|ifndef
name|NOJC
case|case
name|XYSUSP
case|:
comment|/* SET SUSPEND */
name|seton
argument_list|(
operator|&
name|suspend
argument_list|)
expr_stmt|;
comment|/* on or off... */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NOJC */
endif|#
directive|endif
comment|/* UNIX */
case|case
name|XYTAKE
case|:
comment|/* SET TAKE */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|taktab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|techo
argument_list|)
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|terror
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSCRIPT
case|case
name|XYSCRI
case|:
comment|/* SET SCRIPT */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|scrtab
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"echo"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|secho
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSCRIPT */
default|default:
break|break;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
case|case
name|XYTERM
case|:
comment|/* SET TERMINAL */
return|return
operator|(
name|settrm
argument_list|()
operator|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
comment|/* SET SEND/RECEIVE protocol parameters. */
case|case
name|XYRECV
case|:
case|case
name|XYSEND
case|:
return|return
operator|(
name|setsr
argument_list|(
name|xx
argument_list|,
name|rmsflg
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|UNIX
case|case
name|XYSESS
case|:
comment|/* SESSION-LOG */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fttab
argument_list|,
literal|2
argument_list|,
literal|"type of file"
argument_list|,
literal|"text"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|sessft
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* UNIX */
case|case
name|XYSPEE
case|:
comment|/* SET SPEED */
if|if
condition|(
name|network
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Speed cannot be set for network connections\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
name|lp
operator|=
name|line
expr_stmt|;
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|"Transmission rate for %s in bits per second"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|spdtab
argument_list|,
name|nspd
argument_list|,
name|line
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
name|printf
argument_list|(
literal|"?value required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"?Sorry, you must 'set line' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
name|zz
operator|=
operator|(
name|long
operator|)
name|x
operator|*
literal|10L
expr_stmt|;
if|if
condition|(
name|zz
operator|==
literal|70
condition|)
name|zz
operator|=
literal|75
expr_stmt|;
comment|/* (see spdtab[] def) */
if|if
condition|(
name|ttsspd
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Call ttsspd with cps, not bps! */
name|printf
argument_list|(
literal|"?Unsupported line speed - %ld\n"
argument_list|,
name|zz
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
else|else
block|{
name|speed
operator|=
name|zz
expr_stmt|;
if|if
condition|(
name|pflag
operator|&&
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
operator|==
literal|0
else|#
directive|else
name|tlevel
operator|<
literal|0
endif|#
directive|endif
comment|/* NOSPL */
condition|)
block|{
if|if
condition|(
name|speed
operator|==
literal|8880
condition|)
name|printf
argument_list|(
literal|"%s, 75/1200 bps\n"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s, %ld bps\n"
argument_list|,
name|ttname
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
case|case
name|XYXFER
case|:
comment|/* SET TRANSFER */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|tstab
argument_list|,
name|nts
argument_list|,
literal|""
argument_list|,
literal|"character-set"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifndef|#
directive|ifndef
name|NOCSETS
if|if
condition|(
name|y
operator|==
literal|1
condition|)
block|{
comment|/* character-set */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|tcstab
argument_list|,
name|ntcs
argument_list|,
literal|""
argument_list|,
literal|"transparent"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"405"
argument_list|,
name|tcsinfo
index|[
name|y
index|]
operator|.
name|designator
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|tslevel
operator|=
operator|(
name|y
operator|==
name|TC_TRANSP
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* transfer syntax level */
name|tcharset
operator|=
name|y
expr_stmt|;
comment|/* transfer character set */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* NOCSETS */
if|if
condition|(
name|y
operator|==
literal|2
condition|)
block|{
comment|/* LOCKING-SHIFT options */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|lstab
argument_list|,
name|nls
argument_list|,
literal|""
argument_list|,
literal|"on"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|lscapr
operator|=
operator|(
name|y
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* ON: requested = 1 */
name|lscapu
operator|=
operator|(
name|y
operator|==
literal|2
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|/* FORCED:  used = 1 */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
ifndef|#
directive|ifndef
name|NOXMIT
case|case
name|XYXMIT
case|:
comment|/* SET TRANSMIT */
return|return
operator|(
name|setxmit
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOXMIT */
ifndef|#
directive|ifndef
name|NOCSETS
case|case
name|XYUNCS
case|:
comment|/* UNKNOWN-CHARACTER-SET */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|ifdtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"discard"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|unkcs
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NOCSETS */
ifdef|#
directive|ifdef
name|UNIX
case|case
name|XYWILD
case|:
comment|/* WILDCARD-EXPANSION */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|wildtab
argument_list|,
literal|2
argument_list|,
literal|"who expands wildcards"
argument_list|,
literal|"kermit"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|wildxpand
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* UNIX */
case|case
name|XYWIND
case|:
comment|/* WINDOW-SLOTS */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Number of sliding-window slots, 1 to 31"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|wslotr
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|wslotr
operator|<
literal|1
condition|)
name|wslotr
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* This is unreasonable */
if|if
condition|(
name|maxtry
operator|<
name|wslotr
condition|)
block|{
name|printf
argument_list|(
literal|"?Window slots must be less than retry limit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
name|rmsflg
condition|)
block|{
name|tp
operator|=
name|tmpbuf
expr_stmt|;
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|wslotr
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"406"
argument_list|,
name|tp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|swcapr
operator|=
operator|(
name|wslotr
operator|>
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Set window bit in capas word? */
if|if
condition|(
name|wslotr
operator|>
literal|1
condition|)
block|{
comment|/* Window size> 1? */
name|y
operator|=
name|adjpkl
argument_list|(
name|urpsiz
argument_list|,
name|wslotr
argument_list|,
name|bigrbsiz
argument_list|)
expr_stmt|;
comment|/* Maybe adjust packet size */
if|if
condition|(
name|y
operator|!=
name|urpsiz
condition|)
block|{
comment|/* Did it change? */
name|urpsiz
operator|=
name|y
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Adjusting receive packet size to %d for %d window slots\n"
argument_list|,
name|urpsiz
argument_list|,
name|wslotr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|swcapr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
default|default:
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|printf
argument_list|(
literal|"Not working yet - %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

end_unit

