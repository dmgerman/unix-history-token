begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NOSCRIPT
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|loginv
init|=
literal|"Script Command, 5A(012) 25 Dec 91"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  C K U S C R  --  Login script for logging onto remote system */
end_comment

begin_comment
comment|/*  This module should work under all versions of Unix.  It calls externally  defined system-depended functions for i/o.   The module expects a login string of the expect send [expect send] ...  format.  It is intended to operate similarly to the way the common  uucp "L.sys" login entries work.  Conditional responses are supported  expect[-send-expect[...]] as with uucp.  The send keyword EOT sends a  control-d, and the keyword BREAK sends a break.  Letters prefixed  by '~' are '~b' backspace, '~s' space, '~n' linefeed, '~r' return, '~x' xon,  '~t' tab, '~q' ? (not allowed on kermit command lines), '~' ~, '~'',   '~"', '~c' don't append return, '~o[o[o]]' octal character.  As with  some uucp systems, sent strings are followed by ~r (not ~n) unless they  end with ~c. Null expect strings (e.g., ~0 or --) cause a short  delay, and are useful for sending sequences requiring slight pauses.    Author: Herm Fischer (HFISCHER@USC-ECLB)   Contributed to Columbia University for inclusion in C-Kermit.   Copyright (C) 1985, Herman Fischer, 16400 Ventura Blvd, Encino CA 91436, and   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University.    Modifications added 1985-1992, F. da Cruz, Columbia University, and others. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_macro
name|_PROTOTYP
argument_list|(
argument|VOID flushi
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_define
define|#
directive|define
name|SIGALRM
value|(1<<10)
end_define

begin_undef
undef|#
directive|undef
name|SIGTYP
end_undef

begin_comment
comment|/* put in ckcdeb.h later */
end_comment

begin_define
define|#
directive|define
name|SIGTYP
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|local
decl_stmt|,
name|flow
decl_stmt|,
name|seslog
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|quiet
decl_stmt|,
name|duplex
decl_stmt|,
name|backgrd
decl_stmt|,
name|secho
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|network
decl_stmt|,
name|ttnproto
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
name|cmdstk
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|techo
decl_stmt|,
name|cmdlvl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mecho
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scr_echo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to echo script commands */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exp_alrm
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time to wait for expect string */
end_comment

begin_define
define|#
directive|define
name|SND_ALRM
value|15
end_define

begin_comment
comment|/* Time to allow for sending string */
end_comment

begin_define
define|#
directive|define
name|NULL_EXP
value|2
end_define

begin_comment
comment|/* Time to pause on null expect strg*/
end_comment

begin_define
define|#
directive|define
name|DEL_MSEC
value|300
end_define

begin_comment
comment|/* milliseconds to pause on ~d */
end_comment

begin_define
define|#
directive|define
name|SBUFL
value|512
end_define

begin_decl_stmt
specifier|static
name|char
name|seq_buf
index|[
name|SBUFL
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Login Sequence buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fls_buf
index|[
name|SBUFL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flush buffer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|got_it
decl_stmt|,
name|no_cr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  connect state parent/child communication signal handlers */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|alrmrng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Envir ptr for connect errors */
end_comment

begin_function
name|SIGTYP
name|scrtime
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{
comment|/* modem read failure handler, */
name|longjmp
argument_list|(
name|alrmrng
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* notifies parent process to stop */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Sequence interpreter -- pick up next sequence from command string,  decode escapes and place into seq_buf.   If string contains a ~d (delay) then sequenc returns a 1 expecting  to be called again after the ~d executes. */
end_comment

begin_function
specifier|static
name|int
name|sequenc
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|,
name|oct_char
decl_stmt|;
name|no_cr
operator|=
literal|0
expr_stmt|;
comment|/* output needs cr appended */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBUFL
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|||
operator|*
name|s
operator|==
literal|'-'
operator|||
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
comment|/* done */
name|seq_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
condition|)
block|{
comment|/* escape character */
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
condition|)
block|{
case|case
literal|'n'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
name|LF
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
name|CR
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* The default case should catch these now... */
case|case
literal|'~'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* COMMENT */
case|case
literal|'\''
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\021'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|no_cr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
block|{
comment|/* send what we have& then */
name|seq_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* expect to send rest after */
name|no_cr
operator|=
literal|1
expr_stmt|;
comment|/* sender delays a little */
name|s
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
case|case
literal|'w'
case|:
block|{
comment|/* wait count */
name|exp_alrm
operator|=
literal|15
expr_stmt|;
comment|/* default to 15 sec */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|exp_alrm
operator|=
operator|*
name|s
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|exp_alrm
operator|=
name|exp_alrm
operator|*
literal|10
operator|+
operator|(
operator|*
name|s
operator|&
literal|15
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* octal character */
name|oct_char
operator|=
operator|(
name|c
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* most significant digit */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|oct_char
operator|=
operator|(
name|oct_char
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|s
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|oct_char
operator|=
operator|(
name|oct_char
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|s
operator|&
literal|7
operator|)
expr_stmt|;
block|}
block|}
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
name|oct_char
expr_stmt|;
break|break;
block|}
else|else
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
comment|/* Treat ~ as quote */
block|}
block|}
else|else
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
comment|/* Plain old character */
name|s
operator|++
expr_stmt|;
block|}
name|seq_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* end of space, return anyway */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Receive sequence -- see if expected response comes,  return success (or failure) in got_it. */
end_comment

begin_function
specifier|static
name|VOID
name|recvseq
parameter_list|()
block|{
name|char
modifier|*
name|e
decl_stmt|,
name|got
index|[
literal|7
index|]
decl_stmt|,
name|trace
index|[
name|SBUFL
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|x
decl_stmt|;
name|sequenc
argument_list|()
expr_stmt|;
name|l
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|e
operator|=
name|seq_buf
argument_list|)
expr_stmt|;
comment|/* no more than 7 chars allowed */
if|if
condition|(
name|l
operator|>
literal|7
condition|)
block|{
name|e
operator|+=
name|l
operator|-
literal|7
expr_stmt|;
name|l
operator|=
literal|7
expr_stmt|;
block|}
name|tlog
argument_list|(
name|F111
argument_list|,
literal|"expecting sequence"
argument_list|,
name|e
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
comment|/* null sequence, just delay a little */
name|sleep
argument_list|(
name|NULL_EXP
argument_list|)
expr_stmt|;
name|got_it
operator|=
literal|1
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"got it (null sequence)"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|trace
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|got
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|scrtime
argument_list|)
expr_stmt|;
comment|/* did we get it? */
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|alrmrng
argument_list|)
condition|)
block|{
comment|/* not timed out yet */
name|alarm
argument_list|(
name|exp_alrm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|got_it
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|got
index|[
name|i
index|]
operator|=
name|got
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Shift over */
name|x
operator|=
name|ttinc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Read a character */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"recvseq"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
goto|goto
name|rcvx
goto|;
comment|/* Check for error */
ifdef|#
directive|ifdef
name|NETCONN
comment|/* Check for telnet protocol negotiation */
if|if
condition|(
name|network
operator|&&
operator|(
name|ttnproto
operator|==
name|NP_TELNET
operator|)
operator|&&
operator|(
operator|(
name|x
operator|&
literal|0xff
operator|)
operator|==
name|IAC
operator|)
condition|)
block|{
switch|switch
condition|(
name|tn_doop
argument_list|(
call|(
name|CHAR
call|)
argument_list|(
name|x
operator|&
literal|0xff
argument_list|)
argument_list|,
name|duplex
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|duplex
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|1
case|:
name|duplex
operator|=
literal|1
expr_stmt|;
default|default:
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* NETCONN */
name|got
index|[
name|l
operator|-
literal|1
index|]
operator|=
name|x
operator|&
literal|0x7f
expr_stmt|;
comment|/* Got a character */
if|if
condition|(
name|scr_echo
condition|)
name|conoc
argument_list|(
name|got
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Echo it */
if|if
condition|(
name|seslog
condition|)
comment|/* Log it in session log */
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|got
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|trace
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|trace
argument_list|)
operator|-
literal|2
condition|)
name|strcat
argument_list|(
name|trace
argument_list|,
name|dbchr
argument_list|(
name|got
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|got_it
operator|=
operator|(
operator|!
name|strncmp
argument_list|(
name|e
argument_list|,
name|got
argument_list|,
name|l
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
name|got_it
operator|=
literal|0
expr_stmt|;
comment|/* timed out here */
name|rcvx
label|:
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"received sequence: "
argument_list|,
name|trace
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"returning with got-it code"
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|got_it
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Output A Sequence starting at pointer s,  return 0 if okay,  1 if failed to read (modem hangup or whatever) */
end_comment

begin_function
specifier|static
name|int
name|outseq
parameter_list|()
block|{
name|char
modifier|*
name|sb
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|delay
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|delay
operator|=
name|sequenc
argument_list|()
expr_stmt|;
name|l
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|seq_buf
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F111
argument_list|,
literal|"sending sequence "
argument_list|,
name|seq_buf
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|scrtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|alrmrng
argument_list|)
condition|)
block|{
name|alarm
argument_list|(
name|SND_ALRM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|seq_buf
argument_list|,
literal|"EOT"
argument_list|)
condition|)
block|{
name|ttoc
argument_list|(
name|dopar
argument_list|(
literal|'\004'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scr_echo
condition|)
name|conol
argument_list|(
literal|"<EOT>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
operator|&&
name|duplex
condition|)
if|if
condition|(
name|zsout
argument_list|(
name|ZSFILE
argument_list|,
literal|"<EOT>"
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|seq_buf
argument_list|,
literal|"BREAK"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|seq_buf
argument_list|,
literal|"\\b"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|seq_buf
argument_list|,
literal|"\\B"
argument_list|)
condition|)
block|{
name|ttsndb
argument_list|()
expr_stmt|;
if|if
condition|(
name|scr_echo
condition|)
name|conol
argument_list|(
literal|"<BREAK>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
condition|)
if|if
condition|(
name|zsout
argument_list|(
name|ZSFILE
argument_list|,
literal|"{BREAK}"
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|sb
operator|=
name|seq_buf
init|;
operator|*
name|sb
condition|;
name|sb
operator|++
control|)
operator|*
name|sb
operator|=
name|dopar
argument_list|(
operator|*
name|sb
argument_list|)
expr_stmt|;
comment|/* add parity */
name|ttol
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
name|seq_buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* send it */
if|if
condition|(
name|scr_echo
operator|&&
name|duplex
condition|)
name|conxo
argument_list|(
name|l
argument_list|,
name|seq_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
operator|&&
name|duplex
condition|)
comment|/* log it */
if|if
condition|(
name|zsout
argument_list|(
name|ZSFILE
argument_list|,
name|seq_buf
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_cr
condition|)
block|{
name|ttoc
argument_list|(
name|dopar
argument_list|(
name|CR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
operator|&&
name|duplex
condition|)
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|dopar
argument_list|(
name|CR
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
name|retcode
operator||=
operator|-
literal|1
expr_stmt|;
comment|/* else -- alarm rang */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
return|return
operator|(
name|retcode
operator|)
return|;
ifndef|#
directive|ifndef
name|MAC
name|msleep
argument_list|(
name|DEL_MSEC
argument_list|)
expr_stmt|;
comment|/* delay, loop to next send */
endif|#
directive|endif
comment|/* MAC */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  L O G I N  --  Login to remote system */
end_comment

begin_function
name|int
name|dologin
parameter_list|(
name|cmdstr
parameter_list|)
name|char
modifier|*
name|cmdstr
decl_stmt|;
block|{
name|SIGTYP
function_decl|(
modifier|*
name|savealm
function_decl|)
parameter_list|()
function_decl|;
comment|/* save incoming alarm function */
name|char
modifier|*
name|e
decl_stmt|;
name|s
operator|=
name|cmdstr
expr_stmt|;
comment|/* make global to ckuscr.c */
name|tlog
argument_list|(
name|F100
argument_list|,
name|loginv
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<
literal|0L
condition|)
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
if|if
condition|(
name|ttopen
argument_list|(
name|ttname
argument_list|,
operator|&
name|local
argument_list|,
name|mdmtyp
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|seq_buf
argument_list|,
literal|"Sorry, can't open %s"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|seq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Whether to echo script cmds */
name|scr_echo
operator|=
operator|(
operator|!
name|quiet
operator|&&
operator|!
name|backgrd
operator|&&
name|secho
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|scr_echo
operator|&&
name|cmdlvl
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_TF
condition|)
name|scr_echo
operator|=
name|techo
expr_stmt|;
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_MD
condition|)
name|scr_echo
operator|=
name|mecho
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
if|if
condition|(
name|scr_echo
condition|)
block|{
ifdef|#
directive|ifdef
name|NETCONN
if|if
condition|(
name|network
condition|)
name|printf
argument_list|(
literal|"Executing SCRIPT to host %s.\n"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* NETCONN */
name|printf
argument_list|(
literal|"Executing SCRIPT through %s, speed %ld.\n"
argument_list|,
name|ttname
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
operator|*
name|seq_buf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|s
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
name|strcat
argument_list|(
name|seq_buf
argument_list|,
name|dbchr
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Skip this because it tends to contain a password... */
if|if
condition|(
name|scr_echo
condition|)
name|printf
argument_list|(
literal|"SCRIPT string: %s\n"
argument_list|,
name|seq_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"SCRIPT string: "
argument_list|,
name|seq_buf
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* Condition console terminal and communication line */
if|if
condition|(
name|ttvt
argument_list|(
name|speed
argument_list|,
name|flow
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, Can't condition communication line\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Save initial timer interrupt value */
name|savealm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
comment|/* flush stale input */
comment|/* start expect - send sequence */
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/* while not done with buffer */
while|while
condition|(
operator|*
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip over separating whitespaces */
comment|/* gather up expect sequence */
name|got_it
operator|=
literal|0
expr_stmt|;
name|recvseq
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|got_it
condition|)
block|{
comment|/* Have it yet? */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'-'
condition|)
comment|/* No, is there a conditional send? */
goto|goto
name|failret
goto|;
comment|/* No, return failure */
name|flushi
argument_list|()
expr_stmt|;
comment|/* Yes, flush out input buffer */
if|if
condition|(
name|outseq
argument_list|()
condition|)
comment|/* If unable to send, */
goto|goto
name|failret
goto|;
comment|/* return failure. */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'-'
condition|)
comment|/* If no conditional response here, */
goto|goto
name|failret
goto|;
comment|/* return failure. */
name|recvseq
argument_list|()
expr_stmt|;
comment|/* All OK, read response from host. */
block|}
comment|/* Loop back and check got_it */
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
empty_stmt|;
comment|/* Skip over conditionals */
while|while
condition|(
operator|*
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip over separating whitespaces */
name|flushi
argument_list|()
expr_stmt|;
comment|/* Flush */
if|if
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|outseq
argument_list|()
condition|)
goto|goto
name|failret
goto|;
comment|/* If any */
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|savealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|scr_echo
condition|)
name|printf
argument_list|(
literal|"Script successful.\n"
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Script successful."
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|failret
label|:
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|savealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|scr_echo
condition|)
name|printf
argument_list|(
literal|"Sorry, script failed\n"
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Script failed"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  F L U S H I  --  Flush, but log, input buffer  */
end_comment

begin_function
name|VOID
name|flushi
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|seslog
condition|)
block|{
comment|/* Logging session? */
name|n
operator|=
name|ttchk
argument_list|()
expr_stmt|;
comment|/* Yes, anything in buffer? */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* If so, */
if|if
condition|(
name|n
operator|>
name|SBUFL
condition|)
name|n
operator|=
name|SBUFL
expr_stmt|;
comment|/* make sure not too much, */
name|n
operator|=
name|ttxin
argument_list|(
name|n
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
name|fls_buf
argument_list|)
expr_stmt|;
comment|/* then read it, */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
if|if
condition|(
name|zsout
argument_list|(
name|ZSFILE
argument_list|,
name|fls_buf
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Otherwise just flush. */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_macro
name|alarm
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Fix this later */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|loginv
init|=
literal|"Script Command Disabled"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSCRIPT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

end_unit

