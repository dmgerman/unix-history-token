begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * Polk's hash list manager.  So cool.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)hash.c 1.14 92/03/31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* global caches */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|listcache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Node
modifier|*
name|nodecache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|void
name|freenode_mem
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|freenode_mem
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_comment
comment|/* hash function */
end_comment

begin_function
specifier|static
name|int
name|hashp
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|key
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|n
operator|+=
operator|*
name|p
expr_stmt|;
return|return
operator|(
name|n
operator|%
name|HASHSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a new list (or get an old one from the cache)  */
end_comment

begin_function
name|List
modifier|*
name|getlist
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|listcache
operator|!=
name|NULL
condition|)
block|{
comment|/* get a list from the cache and clear it */
name|list
operator|=
name|listcache
expr_stmt|;
name|listcache
operator|=
name|listcache
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
name|list
operator|->
name|hasharray
index|[
name|i
index|]
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* make a new list from scratch */
name|list
operator|=
operator|(
name|List
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|list
operator|->
name|list
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|HEADER
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|node
operator|->
name|prev
operator|=
name|node
expr_stmt|;
block|}
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free up a list  */
end_comment

begin_function
name|void
name|dellist
parameter_list|(
name|listp
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
return|return;
name|p
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|list
expr_stmt|;
comment|/* free each node in the list (except header) */
while|while
condition|(
name|p
operator|->
name|next
operator|!=
name|p
condition|)
name|delnode
argument_list|(
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* free any list-private data, without freeing the actual header */
name|freenode_mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* free up the header nodes for hash lists (if any) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|hasharray
index|[
name|i
index|]
operator|)
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* put the nodes into the cache */
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* put it on the cache */
operator|(
operator|*
name|listp
operator|)
operator|->
name|next
operator|=
name|listcache
expr_stmt|;
name|listcache
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new list node  */
end_comment

begin_function
name|Node
modifier|*
name|getnode
parameter_list|()
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nodecache
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* get one from the cache */
name|p
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* make a new one */
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* always make it clean */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * remove a node from it's list (maybe hash list too) and free it  */
end_comment

begin_function
name|void
name|delnode
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* take it out of the list */
name|p
operator|->
name|next
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* if it was hashed, remove it from there too */
if|if
condition|(
name|p
operator|->
name|hashnext
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|->
name|hashnext
operator|->
name|hashprev
operator|=
name|p
operator|->
name|hashprev
expr_stmt|;
name|p
operator|->
name|hashprev
operator|->
name|hashnext
operator|=
name|p
operator|->
name|hashnext
expr_stmt|;
block|}
comment|/* free up the storage */
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up the storage associated with a node  */
end_comment

begin_function
specifier|static
name|void
name|freenode_mem
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|delproc
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
condition|)
name|p
operator|->
name|delproc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* call the specified delproc */
else|else
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
comment|/* otherwise free() it if necessary */
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|key
operator|!=
name|NULL
condition|)
comment|/* free the key if necessary */
name|free
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* to be safe, re-initialize these */
name|p
operator|->
name|key
operator|=
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up the storage associated with a node and recycle it  */
end_comment

begin_function
name|void
name|freenode
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* first free the memory */
name|freenode_mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* then put it in the cache */
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * insert item p at end of list "list" (maybe hash it too) if hashing and it  * already exists, return -1 and don't actually put it in the list  *   * return 0 on success  */
end_comment

begin_function
name|int
name|addnode
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|hashval
decl_stmt|;
name|Node
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|key
operator|!=
name|NULL
condition|)
comment|/* hash it too? */
block|{
name|hashval
operator|=
name|hashp
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|==
name|NULL
condition|)
comment|/* make a header for list? */
block|{
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|HEADER
expr_stmt|;
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|=
name|q
operator|->
name|hashnext
operator|=
name|q
operator|->
name|hashprev
operator|=
name|q
expr_stmt|;
block|}
comment|/* put it into the hash list if it's not already there */
for|for
control|(
name|q
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|->
name|hashnext
init|;
name|q
operator|!=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
condition|;
name|q
operator|=
name|q
operator|->
name|hashnext
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|q
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
expr_stmt|;
name|p
operator|->
name|hashprev
operator|=
name|q
operator|->
name|hashprev
expr_stmt|;
name|p
operator|->
name|hashnext
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|hashprev
operator|->
name|hashnext
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|hashprev
operator|=
name|p
expr_stmt|;
block|}
comment|/* put it into the regular list */
name|p
operator|->
name|prev
operator|=
name|list
operator|->
name|list
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|list
operator|->
name|list
expr_stmt|;
name|list
operator|->
name|list
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|list
operator|->
name|list
operator|->
name|prev
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * look up an entry in hash list table  */
end_comment

begin_function
name|Node
modifier|*
name|findnode
parameter_list|(
name|list
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|list
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
name|head
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashp
argument_list|(
name|key
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|hashnext
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|hashnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * walk a list with a specific proc  */
end_comment

begin_decl_stmt
name|int
name|walklist
argument_list|(
name|list
argument_list|,
name|proc
argument_list|)
name|List
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|head
operator|=
name|list
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|err
operator|+=
name|proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * sort the elements of a list (in place)  */
end_comment

begin_decl_stmt
name|void
name|sortlist
argument_list|(
name|list
argument_list|,
name|comp
argument_list|)
name|List
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|comp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|remain
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* save the old first element of the list */
name|head
operator|=
name|list
operator|->
name|list
expr_stmt|;
name|remain
operator|=
name|head
operator|->
name|next
expr_stmt|;
comment|/* make the header node into a null list of it's own */
name|head
operator|->
name|next
operator|=
name|head
operator|->
name|prev
operator|=
name|head
expr_stmt|;
comment|/* while there are nodes remaining, do insert sort */
while|while
condition|(
name|remain
operator|!=
name|head
condition|)
block|{
comment|/* take one from the list */
name|p
operator|=
name|remain
expr_stmt|;
name|remain
operator|=
name|remain
operator|->
name|next
expr_stmt|;
comment|/* traverse the sorted list looking for the place to insert it */
for|for
control|(
name|q
operator|=
name|head
operator|->
name|next
init|;
name|q
operator|!=
name|head
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|comp
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* p comes before q */
name|p
operator|->
name|next
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|q
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|prev
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|q
operator|==
name|head
condition|)
block|{
comment|/* it belongs at the end of the list */
name|p
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|head
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

