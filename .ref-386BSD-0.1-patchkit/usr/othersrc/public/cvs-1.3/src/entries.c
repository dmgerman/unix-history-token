begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * Entries file to Files file  *   * Creates the file Files containing the names that comprise the project, from  * the Entries file.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)entries.c 1.37 92/03/31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|Node
modifier|*
name|AddEntryNode
parameter_list|(
name|List
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|version
parameter_list|,
name|char
modifier|*
name|timestamp
parameter_list|,
name|char
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
name|date
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|Node
modifier|*
name|AddEntryNode
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|entfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for error messages */
end_comment

begin_comment
comment|/*  * Write out the line associated with a node of an entries file  */
end_comment

begin_function
specifier|static
name|int
name|write_ent_proc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|Entnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"/%s/%s/%s/%s/"
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|p
operator|->
name|version
argument_list|,
name|p
operator|->
name|timestamp
argument_list|,
name|p
operator|->
name|options
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"T%s\n"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|date
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"D%s\n"
argument_list|,
name|p
operator|->
name|date
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"\n"
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write out the current entries file given a list,  making a backup copy  * first of course  */
end_comment

begin_function
specifier|static
name|void
name|write_entries
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
comment|/* open the new one and walk the list writing entries */
name|entfilename
operator|=
name|CVSADM_ENTBAK
expr_stmt|;
name|entfile
operator|=
name|open_file
argument_list|(
name|entfilename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|list
argument_list|,
name|write_ent_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
comment|/* now, atomically (on systems that support it) rename it */
name|rename_file
argument_list|(
name|entfilename
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes the argument file from the Entries file if necessary.  */
end_comment

begin_function
name|void
name|Scratch_Entry
parameter_list|(
name|list
parameter_list|,
name|fname
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> Scratch_Entry(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* hashlookup to see if it is there */
if|if
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|list
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* delete the node */
if|if
condition|(
operator|!
name|noexec
condition|)
name|write_entries
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* re-write the file */
block|}
block|}
end_function

begin_comment
comment|/*  * Enters the given file name/version/time-stamp into the Entries file,  * removing the old entry first, if necessary.  */
end_comment

begin_function
name|void
name|Register
parameter_list|(
name|list
parameter_list|,
name|fname
parameter_list|,
name|vn
parameter_list|,
name|ts
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> Register(%s, %s, %s, %s, %s %s)\n"
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* was it already there? */
if|if
condition|(
operator|(
name|node
operator|=
name|findnode
argument_list|(
name|list
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* take it out */
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* add the new one and re-write the file */
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|list
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
name|write_entries
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add the new one */
name|node
operator|=
name|AddEntryNode
argument_list|(
name|list
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
comment|/* append it to the end */
name|entfilename
operator|=
name|CVSADM_ENT
expr_stmt|;
name|entfile
operator|=
name|open_file
argument_list|(
name|entfilename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write_ent_proc
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Node delete procedure for list-private sticky dir tag/date info  */
end_comment

begin_function
specifier|static
name|void
name|freesdt
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|tag
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|date
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|options
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the entries file into a list, hashing on the file name.  */
end_comment

begin_function
name|List
modifier|*
name|ParseEntries
parameter_list|(
name|aflag
parameter_list|)
name|int
name|aflag
decl_stmt|;
block|{
name|List
modifier|*
name|entries
decl_stmt|;
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|user
decl_stmt|,
modifier|*
name|vn
decl_stmt|,
modifier|*
name|ts
decl_stmt|,
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag_or_date
decl_stmt|,
modifier|*
name|tag
decl_stmt|,
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|dirtag
decl_stmt|,
modifier|*
name|dirdate
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fpin
decl_stmt|;
comment|/* get a fresh list... */
name|entries
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * Parse the CVS/Tag file, to get any default tag/date settings. Use      * list-private storage to tuck them away for Version_TS().      */
name|ParseTag
argument_list|(
operator|&
name|dirtag
argument_list|,
operator|&
name|dirdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|||
name|dirtag
operator|||
name|dirdate
condition|)
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|aflag
operator|=
name|aflag
expr_stmt|;
name|sdtp
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|dirtag
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|dirdate
argument_list|)
expr_stmt|;
comment|/* feed it into the list-private area */
name|entries
operator|->
name|list
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|sdtp
expr_stmt|;
name|entries
operator|->
name|list
operator|->
name|delproc
operator|=
name|freesdt
expr_stmt|;
block|}
name|again
label|:
name|fpin
operator|=
name|fopen
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fpin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|user
operator|=
name|line
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vn
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|vn
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|ts
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|options
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|options
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tag_or_date
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|tag_or_date
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|tag
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|date
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'T'
condition|)
name|tag
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'D'
condition|)
name|date
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|entries
argument_list|,
name|user
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* try conversion only on first line */
if|if
condition|(
name|lineno
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
name|check_entries
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
block|}
comment|/* clean up and return */
if|if
condition|(
name|fpin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirtag
condition|)
name|free
argument_list|(
name|dirtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirdate
condition|)
name|free
argument_list|(
name|dirdate
argument_list|)
expr_stmt|;
return|return
operator|(
name|entries
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look at the entries file to determine if it is in the old entries format.  * If so, convert it to the new format.  */
end_comment

begin_function
name|void
name|check_entries
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fpin
decl_stmt|,
modifier|*
name|fpout
decl_stmt|;
name|char
name|tmp
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
name|entname
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
name|entbak
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|user
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|ts
decl_stmt|,
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|entname
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|entbak
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ENTBAK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|entname
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|entbak
argument_list|,
name|CVSADM_ENTBAK
argument_list|)
expr_stmt|;
block|}
name|fpin
operator|=
name|open_file
argument_list|(
name|entname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fpin
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|rename_file
argument_list|(
name|entname
argument_list|,
name|entbak
argument_list|)
expr_stmt|;
name|fpin
operator|=
name|open_file
argument_list|(
name|entbak
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fpout
operator|=
name|open_file
argument_list|(
name|entname
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fpin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|fputs
argument_list|(
name|line
argument_list|,
name|fpout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rev
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|ts
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|ts
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|user
operator|=
name|rindex
argument_list|(
name|ts
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|user
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|user
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|opt
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
ifdef|#
directive|ifdef
name|HAD_RCS4
name|opt
operator|=
literal|"-V4"
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|fprintf
argument_list|(
name|fpout
argument_list|,
literal|"/%s/%s/%s/%s/\n"
argument_list|,
name|user
argument_list|,
name|rev
argument_list|,
name|ts
argument_list|,
name|opt
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fpout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|entname
argument_list|)
expr_stmt|;
comment|/* clean up any old Files or Mod files */
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_FILE
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|CVSADM_FILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|tmp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_MOD
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|CVSADM_MOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|tmp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up the memory associated with the data section of an ENTRIES type  * node  */
end_comment

begin_function
specifier|static
name|void
name|Entries_delproc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|Entnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|version
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
condition|)
name|free
argument_list|(
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|date
condition|)
name|free
argument_list|(
name|p
operator|->
name|date
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get an Entries file list node, initialize it, and add it to the specified  * list  */
end_comment

begin_function
specifier|static
name|Node
modifier|*
name|AddEntryNode
parameter_list|(
name|list
parameter_list|,
name|name
parameter_list|,
name|version
parameter_list|,
name|timestamp
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|char
modifier|*
name|timestamp
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
comment|/* get a node and fill in the regular stuff */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|ENTRIES
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|Entries_delproc
expr_stmt|;
comment|/* this one gets a key of the name for hashing */
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* malloc the data parts and fill them in */
name|p
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Entnode
argument_list|)
argument_list|)
expr_stmt|;
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|entdata
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|entdata
operator|->
name|timestamp
operator|=
name|xstrdup
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|entdata
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|entdata
operator|->
name|options
operator|==
name|NULL
condition|)
name|entdata
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* must be non-NULL */
name|entdata
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|entdata
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
comment|/* put the node into the list */
if|if
condition|(
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Duplicate filename in entries file (%s) -- ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out/Clear the CVS/Tag file.  */
end_comment

begin_function
name|void
name|WriteTag
parameter_list|(
name|dir
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
block|{
name|FILE
modifier|*
name|fout
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|||
name|date
condition|)
block|{
name|fout
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"T%s\n"
argument_list|,
name|tag
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"D%s\n"
argument_list|,
name|date
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the CVS/Tag file for the current directory.  */
end_comment

begin_function
name|void
name|ParseTag
parameter_list|(
name|tagp
parameter_list|,
name|datep
parameter_list|)
name|char
modifier|*
modifier|*
name|tagp
decl_stmt|;
name|char
modifier|*
modifier|*
name|datep
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
name|MAXLINELEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|tagp
condition|)
operator|*
name|tagp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|datep
condition|)
operator|*
name|datep
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'T'
operator|&&
name|tagp
condition|)
operator|*
name|tagp
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|line
operator|==
literal|'D'
operator|&&
name|datep
condition|)
operator|*
name|datep
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

