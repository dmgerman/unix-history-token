begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"msdos.h"
end_include

begin_decl_stmt
name|int
name|fat_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of FAT table (in sectors) */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|end_fat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the end-of-chain marker */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|last_fat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the last in a chain marker */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|fat_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the File Allocation Table */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fat_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get and decode a FAT (file allocation table) entry.  Returns the cluster  * number on success or 1 on failure.  */
end_comment

begin_function
name|unsigned
name|int
name|fat_decode
parameter_list|(
name|num
parameter_list|)
name|unsigned
name|int
name|num
decl_stmt|;
block|{
name|unsigned
name|int
name|fat
decl_stmt|,
name|fat_hi
decl_stmt|,
name|fat_low
decl_stmt|,
name|byte_1
decl_stmt|,
name|byte_2
decl_stmt|;
name|int
name|start
decl_stmt|;
if|if
condition|(
name|fat_bits
operator|==
literal|12
condition|)
block|{
comment|/* 		 *	|    byte n     |   byte n+1    |   byte n+2    | 		 *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0| 		 *	| | | | | | | | | | | | | | | | | | | | | | | | | 		 *	| n+0.0 | n+0.5 | n+1.0 | n+1.5 | n+2.0 | n+2.5 | 		 *	    \_____  \____   \______/________/_____   / 		 *	      ____\______\________/   _____/  ____\_/ 		 *	     /     \      \          /       /     \ 		 *	| n+1.5 | n+0.0 | n+0.5 | n+2.0 | n+2.5 | n+1.0 | 		 *	|      FAT entry k      |    FAT entry k+1      | 		 */
comment|/* which bytes contain the entry */
name|start
operator|=
name|num
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|start
operator|<=
literal|2
operator|||
name|start
operator|+
literal|1
operator|>
operator|(
name|fat_len
operator|*
name|MSECTOR_SIZE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|byte_1
operator|=
operator|*
operator|(
name|fat_buf
operator|+
name|start
operator|)
expr_stmt|;
name|byte_2
operator|=
operator|*
operator|(
name|fat_buf
operator|+
name|start
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* (odd) not on byte boundary */
if|if
condition|(
name|num
operator|%
literal|2
condition|)
block|{
name|fat_hi
operator|=
operator|(
name|byte_2
operator|&
literal|0xff
operator|)
operator|<<
literal|4
expr_stmt|;
name|fat_low
operator|=
operator|(
name|byte_1
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
comment|/* (even) on byte boundary */
else|else
block|{
name|fat_hi
operator|=
operator|(
name|byte_2
operator|&
literal|0xf
operator|)
operator|<<
literal|8
expr_stmt|;
name|fat_low
operator|=
name|byte_1
operator|&
literal|0xff
expr_stmt|;
block|}
name|fat
operator|=
operator|(
name|fat_hi
operator|+
name|fat_low
operator|)
operator|&
literal|0xfff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	|    byte n     |   byte n+1    | 		 *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0| 		 *	| | | | | | | | | | | | | | | | | 		 *	|         FAT entry k           | 		 */
comment|/* which bytes contain the entry */
name|start
operator|=
name|num
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|start
operator|<=
literal|3
operator|||
name|start
operator|+
literal|1
operator|>
operator|(
name|fat_len
operator|*
name|MSECTOR_SIZE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|fat
operator|=
operator|(
operator|*
operator|(
name|fat_buf
operator|+
name|start
operator|+
literal|1
operator|)
operator|*
literal|0x100
operator|)
operator|+
operator|*
operator|(
name|fat_buf
operator|+
name|start
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|fat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the entire FAT table into memory.  */
end_comment

begin_function
name|void
name|fat_read
parameter_list|(
name|start
parameter_list|)
name|int
name|start
decl_stmt|;
block|{
name|int
name|buflen
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|void
name|perror
argument_list|()
decl_stmt|,
name|exit
argument_list|()
decl_stmt|,
name|disk_read
argument_list|()
decl_stmt|;
comment|/* only the first copy of the FAT */
name|buflen
operator|=
name|fat_len
operator|*
name|MSECTOR_SIZE
expr_stmt|;
name|fat_buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat_buf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fat_read: malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* read the FAT sectors */
name|disk_read
argument_list|(
operator|(
name|long
operator|)
name|start
argument_list|,
name|fat_buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
comment|/* the encoding scheme */
if|if
condition|(
name|fat_bits
operator|==
literal|12
condition|)
block|{
name|end_fat
operator|=
literal|0xfff
expr_stmt|;
name|last_fat
operator|=
literal|0xff8
expr_stmt|;
block|}
else|else
block|{
name|end_fat
operator|=
literal|0xffff
expr_stmt|;
name|last_fat
operator|=
literal|0xfff8
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

