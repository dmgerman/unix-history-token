begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stty -- change and print terminal line settings    Copyright (C) 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Usage: stty [-ag] [--all] [--save] [setting...]     Options:    -a, --all	Write all current settings to stdout in human-readable form.    -g, --save	Write all current settings to stdout in stty-readable form.     If no args are given, write to stdout the baud rate and settings that    have been changed from their defaults.  Mode reading and changes    are done on stdin.     David MacKenzie<djm@ai.mit.edu> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* Needed to get window size. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WINSIZE_IN_PTEM
end_ifdef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args, lastarg)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GWINSZ_BROKEN
argument_list|)
end_if

begin_comment
comment|/* Such as for SCO UNIX 3.2.2. */
end_comment

begin_undef
undef|#
directive|undef
name|TIOCGWINSZ
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_VDISABLE
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_VDISABLE
value|((unsigned char) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Control
parameter_list|(
name|c
parameter_list|)
value|((c)& 0x1f)
end_define

begin_comment
comment|/* Canonical values for control characters. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CINTR
end_ifndef

begin_define
define|#
directive|define
name|CINTR
value|Control ('c')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CQUIT
end_ifndef

begin_define
define|#
directive|define
name|CQUIT
value|28
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CERASE
end_ifndef

begin_define
define|#
directive|define
name|CERASE
value|127
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CKILL
end_ifndef

begin_define
define|#
directive|define
name|CKILL
value|Control ('u')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CEOF
end_ifndef

begin_define
define|#
directive|define
name|CEOF
value|Control ('d')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CEOL
end_ifndef

begin_define
define|#
directive|define
name|CEOL
value|_POSIX_VDISABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CSTART
end_ifndef

begin_define
define|#
directive|define
name|CSTART
value|Control ('q')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CSTOP
end_ifndef

begin_define
define|#
directive|define
name|CSTOP
value|Control ('s')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CSUSP
end_ifndef

begin_define
define|#
directive|define
name|CSUSP
value|Control ('z')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VEOL2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CEOL2
argument_list|)
end_if

begin_define
define|#
directive|define
name|CEOL2
value|_POSIX_VDISABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VSWTCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CSWTCH
argument_list|)
end_if

begin_define
define|#
directive|define
name|CSWTCH
value|_POSIX_VDISABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VDSUSP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CDSUSP
argument_list|)
end_if

begin_define
define|#
directive|define
name|CDSUSP
value|Control ('y')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VREPRINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CRPRNT
argument_list|)
end_if

begin_define
define|#
directive|define
name|CRPRNT
value|Control ('r')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VWERASE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CWERASE
argument_list|)
end_if

begin_define
define|#
directive|define
name|CWERASE
value|Control ('w')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VLNEXT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CLNEXT
argument_list|)
end_if

begin_define
define|#
directive|define
name|CLNEXT
value|Control ('v')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|visible
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|long
name|baud_to_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|recover_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|screen_columns
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|set_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|string_to_baud
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|integer_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tcflag_t
modifier|*
name|mode_type_flag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display_changed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display_recoverable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display_settings
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display_speed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display_window_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sane_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_control_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_speed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_window_size
parameter_list|()
function_decl|;
end_function_decl

begin_enum
enum|enum
name|speed_setting
block|{
name|input_speed
block|,
name|output_speed
block|,
name|both_speeds
block|}
enum|;
end_enum

begin_enum
enum|enum
name|output_type
block|{
name|changed
block|,
name|all
block|,
name|recoverable
block|}
enum|;
end_enum

begin_enum
enum|enum
name|mode_type
block|{
name|control
block|,
name|input
block|,
name|output
block|,
name|local
block|,
name|combination
block|}
enum|;
end_enum

begin_comment
comment|/* Flags for `struct mode_info'. */
end_comment

begin_define
define|#
directive|define
name|SANE_SET
value|1
end_define

begin_comment
comment|/* Set in `sane' mode. */
end_comment

begin_define
define|#
directive|define
name|SANE_UNSET
value|2
end_define

begin_comment
comment|/* Unset in `sane' mode. */
end_comment

begin_define
define|#
directive|define
name|REV
value|4
end_define

begin_comment
comment|/* Can be turned off by prepending `-'. */
end_comment

begin_define
define|#
directive|define
name|OMIT
value|8
end_define

begin_comment
comment|/* Don't display value. */
end_comment

begin_struct
struct|struct
name|mode_info
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|mode_type
name|type
decl_stmt|;
name|char
name|flags
decl_stmt|;
name|unsigned
name|long
name|bits
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mode_info
name|mode_info
index|[]
init|=
block|{
block|{
literal|"parenb"
block|,
name|control
block|,
name|REV
block|,
name|PARENB
block|,
literal|0
block|}
block|,
block|{
literal|"parodd"
block|,
name|control
block|,
name|REV
block|,
name|PARODD
block|,
literal|0
block|}
block|,
block|{
literal|"cs5"
block|,
name|control
block|,
literal|0
block|,
name|CS5
block|,
name|CSIZE
block|}
block|,
block|{
literal|"cs6"
block|,
name|control
block|,
literal|0
block|,
name|CS6
block|,
name|CSIZE
block|}
block|,
block|{
literal|"cs7"
block|,
name|control
block|,
literal|0
block|,
name|CS7
block|,
name|CSIZE
block|}
block|,
block|{
literal|"cs8"
block|,
name|control
block|,
literal|0
block|,
name|CS8
block|,
name|CSIZE
block|}
block|,
block|{
literal|"hupcl"
block|,
name|control
block|,
name|REV
block|,
name|HUPCL
block|,
literal|0
block|}
block|,
block|{
literal|"hup"
block|,
name|control
block|,
name|REV
operator||
name|OMIT
block|,
name|HUPCL
block|,
literal|0
block|}
block|,
block|{
literal|"cstopb"
block|,
name|control
block|,
name|REV
block|,
name|CSTOPB
block|,
literal|0
block|}
block|,
block|{
literal|"cread"
block|,
name|control
block|,
name|SANE_SET
operator||
name|REV
block|,
name|CREAD
block|,
literal|0
block|}
block|,
block|{
literal|"clocal"
block|,
name|control
block|,
name|REV
block|,
name|CLOCAL
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|CRTSCTS
block|{
literal|"crtscts"
block|,
name|control
block|,
name|REV
block|,
name|CRTSCTS
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"ignbrk"
block|,
name|input
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|IGNBRK
block|,
literal|0
block|}
block|,
block|{
literal|"brkint"
block|,
name|input
block|,
name|SANE_SET
operator||
name|REV
block|,
name|BRKINT
block|,
literal|0
block|}
block|,
block|{
literal|"ignpar"
block|,
name|input
block|,
name|REV
block|,
name|IGNPAR
block|,
literal|0
block|}
block|,
block|{
literal|"parmrk"
block|,
name|input
block|,
name|REV
block|,
name|PARMRK
block|,
literal|0
block|}
block|,
block|{
literal|"inpck"
block|,
name|input
block|,
name|REV
block|,
name|INPCK
block|,
literal|0
block|}
block|,
block|{
literal|"istrip"
block|,
name|input
block|,
name|REV
block|,
name|ISTRIP
block|,
literal|0
block|}
block|,
block|{
literal|"inlcr"
block|,
name|input
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|INLCR
block|,
literal|0
block|}
block|,
block|{
literal|"igncr"
block|,
name|input
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|IGNCR
block|,
literal|0
block|}
block|,
block|{
literal|"icrnl"
block|,
name|input
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ICRNL
block|,
literal|0
block|}
block|,
block|{
literal|"ixon"
block|,
name|input
block|,
name|REV
block|,
name|IXON
block|,
literal|0
block|}
block|,
block|{
literal|"ixoff"
block|,
name|input
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|IXOFF
block|,
literal|0
block|}
block|,
block|{
literal|"tandem"
block|,
name|input
block|,
name|REV
operator||
name|OMIT
block|,
name|IXOFF
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|IUCLC
block|{
literal|"iuclc"
block|,
name|input
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|IUCLC
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IXANY
block|{
literal|"ixany"
block|,
name|input
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|IXANY
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IMAXBEL
block|{
literal|"imaxbel"
block|,
name|input
block|,
name|SANE_SET
operator||
name|REV
block|,
name|IMAXBEL
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"opost"
block|,
name|output
block|,
name|SANE_SET
operator||
name|REV
block|,
name|OPOST
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OLCUC
block|{
literal|"olcuc"
block|,
name|output
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|OLCUC
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OCRNL
block|{
literal|"ocrnl"
block|,
name|output
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|OCRNL
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ONLCR
block|{
literal|"onlcr"
block|,
name|output
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ONLCR
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ONOCR
block|{
literal|"onocr"
block|,
name|output
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|ONOCR
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ONLRET
block|{
literal|"onlret"
block|,
name|output
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|ONLRET
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OFILL
block|{
literal|"ofill"
block|,
name|output
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|OFILL
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OFDEL
block|{
literal|"ofdel"
block|,
name|output
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|OFDEL
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NLDLY
block|{
literal|"nl1"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|NL1
block|,
name|NLDLY
block|}
block|,
block|{
literal|"nl0"
block|,
name|output
block|,
name|SANE_SET
block|,
name|NL0
block|,
name|NLDLY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CRDLY
block|{
literal|"cr3"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|CR3
block|,
name|CRDLY
block|}
block|,
block|{
literal|"cr2"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|CR2
block|,
name|CRDLY
block|}
block|,
block|{
literal|"cr1"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|CR1
block|,
name|CRDLY
block|}
block|,
block|{
literal|"cr0"
block|,
name|output
block|,
name|SANE_SET
block|,
name|CR0
block|,
name|CRDLY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
block|{
literal|"tab3"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|TAB3
block|,
name|TABDLY
block|}
block|,
block|{
literal|"tab2"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|TAB2
block|,
name|TABDLY
block|}
block|,
block|{
literal|"tab1"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|TAB1
block|,
name|TABDLY
block|}
block|,
block|{
literal|"tab0"
block|,
name|output
block|,
name|SANE_SET
block|,
name|TAB0
block|,
name|TABDLY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSDLY
block|{
literal|"bs1"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|BS1
block|,
name|BSDLY
block|}
block|,
block|{
literal|"bs0"
block|,
name|output
block|,
name|SANE_SET
block|,
name|BS0
block|,
name|BSDLY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VTDLY
block|{
literal|"vt1"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|VT1
block|,
name|VTDLY
block|}
block|,
block|{
literal|"vt0"
block|,
name|output
block|,
name|SANE_SET
block|,
name|VT0
block|,
name|VTDLY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FFDLY
block|{
literal|"ff1"
block|,
name|output
block|,
name|SANE_UNSET
block|,
name|FF1
block|,
name|FFDLY
block|}
block|,
block|{
literal|"ff0"
block|,
name|output
block|,
name|SANE_SET
block|,
name|FF0
block|,
name|FFDLY
block|}
block|,
endif|#
directive|endif
block|{
literal|"isig"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ISIG
block|,
literal|0
block|}
block|,
block|{
literal|"icanon"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ICANON
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|IEXTEN
block|{
literal|"iexten"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|IEXTEN
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"echo"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ECHO
block|,
literal|0
block|}
block|,
block|{
literal|"echoe"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ECHOE
block|,
literal|0
block|}
block|,
block|{
literal|"crterase"
block|,
name|local
block|,
name|REV
operator||
name|OMIT
block|,
name|ECHOE
block|,
literal|0
block|}
block|,
block|{
literal|"echok"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ECHOK
block|,
literal|0
block|}
block|,
block|{
literal|"echonl"
block|,
name|local
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|ECHONL
block|,
literal|0
block|}
block|,
block|{
literal|"noflsh"
block|,
name|local
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|NOFLSH
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|XCASE
block|{
literal|"xcase"
block|,
name|local
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|XCASE
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TOSTOP
block|{
literal|"tostop"
block|,
name|local
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|TOSTOP
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECHOPRT
block|{
literal|"echoprt"
block|,
name|local
block|,
name|SANE_UNSET
operator||
name|REV
block|,
name|ECHOPRT
block|,
literal|0
block|}
block|,
block|{
literal|"prterase"
block|,
name|local
block|,
name|REV
operator||
name|OMIT
block|,
name|ECHOPRT
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECHOCTL
block|{
literal|"echoctl"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ECHOCTL
block|,
literal|0
block|}
block|,
block|{
literal|"ctlecho"
block|,
name|local
block|,
name|REV
operator||
name|OMIT
block|,
name|ECHOCTL
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECHOKE
block|{
literal|"echoke"
block|,
name|local
block|,
name|SANE_SET
operator||
name|REV
block|,
name|ECHOKE
block|,
literal|0
block|}
block|,
block|{
literal|"crtkill"
block|,
name|local
block|,
name|REV
operator||
name|OMIT
block|,
name|ECHOKE
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"evenp"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"parity"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"oddp"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nl"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ek"
block|,
name|combination
block|,
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sane"
block|,
name|combination
block|,
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cooked"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"raw"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"pass8"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"litout"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"cbreak"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|IXANY
block|{
literal|"decctlq"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
block|{
literal|"tabs"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCASE
argument_list|)
operator|&&
name|defined
argument_list|(
name|IUCLC
argument_list|)
operator|&&
name|defined
argument_list|(
name|OLCUC
argument_list|)
block|{
literal|"lcase"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"LCASE"
block|,
name|combination
block|,
name|REV
operator||
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECHOCTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ECHOKE
argument_list|)
block|{
literal|"crt"
block|,
name|combination
block|,
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"dec"
block|,
name|combination
block|,
name|OMIT
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|control
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|control_info
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
name|saneval
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Control characters. */
end_comment

begin_decl_stmt
name|struct
name|control_info
name|control_info
index|[]
init|=
block|{
block|{
literal|"intr"
block|,
name|CINTR
block|,
name|VINTR
block|}
block|,
block|{
literal|"quit"
block|,
name|CQUIT
block|,
name|VQUIT
block|}
block|,
block|{
literal|"erase"
block|,
name|CERASE
block|,
name|VERASE
block|}
block|,
block|{
literal|"kill"
block|,
name|CKILL
block|,
name|VKILL
block|}
block|,
block|{
literal|"eof"
block|,
name|CEOF
block|,
name|VEOF
block|}
block|,
block|{
literal|"eol"
block|,
name|CEOL
block|,
name|VEOL
block|}
block|,
ifdef|#
directive|ifdef
name|VEOL2
block|{
literal|"eol2"
block|,
name|CEOL2
block|,
name|VEOL2
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSWTCH
block|{
literal|"swtch"
block|,
name|CSWTCH
block|,
name|VSWTCH
block|}
block|,
endif|#
directive|endif
block|{
literal|"start"
block|,
name|CSTART
block|,
name|VSTART
block|}
block|,
block|{
literal|"stop"
block|,
name|CSTOP
block|,
name|VSTOP
block|}
block|,
block|{
literal|"susp"
block|,
name|CSUSP
block|,
name|VSUSP
block|}
block|,
ifdef|#
directive|ifdef
name|VDSUSP
block|{
literal|"dsusp"
block|,
name|CDSUSP
block|,
name|VDSUSP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VREPRINT
block|{
literal|"rprnt"
block|,
name|CRPRNT
block|,
name|VREPRINT
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VWERASE
block|{
literal|"werase"
block|,
name|CWERASE
block|,
name|VWERASE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VLNEXT
block|{
literal|"lnext"
block|,
name|CLNEXT
block|,
name|VLNEXT
block|}
block|,
endif|#
directive|endif
comment|/* These must be last because of the display routines. */
block|{
literal|"min"
block|,
literal|0
block|,
name|VMIN
block|}
block|,
block|{
literal|"time"
block|,
literal|0
block|,
name|VTIME
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The width of the screen, for output wrapping. */
end_comment

begin_decl_stmt
name|int
name|max_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position, to know when to wrap. */
end_comment

begin_decl_stmt
name|int
name|current_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"all"
block|,
literal|0
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"save"
block|,
literal|0
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print format string MESSAGE and optional args.    Wrap to next line first if it won't fit.    Print a space first unless MESSAGE will start a new line. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|wrapf
parameter_list|(
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|wrapf
parameter_list|(
name|message
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* Plenty long for our needs. */
name|int
name|buflen
decl_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_col
operator|+
name|buflen
operator|>=
name|max_col
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_col
operator|>
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|current_col
operator|++
expr_stmt|;
block|}
name|current_col
operator|+=
name|buflen
expr_stmt|;
name|VA_START
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|termios
name|mode
decl_stmt|;
name|enum
name|output_type
name|output_type
init|=
name|changed
decl_stmt|;
name|int
name|optc
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ag"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|optc
operator|==
literal|'a'
condition|)
name|output_type
operator|=
name|all
expr_stmt|;
elseif|else
if|if
condition|(
name|optc
operator|==
literal|'g'
condition|)
name|output_type
operator|=
name|recoverable
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
name|max_col
operator|=
name|screen_columns
argument_list|()
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|optc
operator|==
literal|'?'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid argument `%s'"
argument_list|,
name|argv
index|[
operator|--
name|optind
index|]
argument_list|)
expr_stmt|;
name|display_settings
argument_list|(
name|output_type
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|int
name|match_found
init|=
literal|0
decl_stmt|;
name|int
name|reversed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|++
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|reversed
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mode_info
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|mode_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|match_found
operator|=
name|set_mode
argument_list|(
operator|&
name|mode_info
index|[
name|i
index|]
argument_list|,
name|reversed
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match_found
operator|==
literal|0
operator|&&
name|reversed
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid argument `%s'"
argument_list|,
operator|--
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_found
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|control_info
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|control_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument to `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|match_found
operator|=
literal|1
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|set_control_char
argument_list|(
operator|&
name|control_info
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|match_found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"ispeed"
argument_list|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument to `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|set_speed
argument_list|(
name|input_speed
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"ospeed"
argument_list|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument to `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|set_speed
argument_list|(
name|output_speed
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCGWINSZ
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"rows"
argument_list|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument to `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|set_window_size
argument_list|(
operator|(
name|int
operator|)
name|integer_arg
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"cols"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"columns"
argument_list|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument to `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|set_window_size
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|integer_arg
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"size"
argument_list|)
condition|)
name|display_window_size
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|C_LINE_MISSING
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"line"
argument_list|)
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument to `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|mode
operator|.
name|c_line
operator|=
name|integer_arg
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"speed"
argument_list|)
condition|)
name|display_speed
argument_list|(
operator|&
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|string_to_baud
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|set_speed
argument_list|(
name|both_speeds
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|recover_mode
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|mode
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid argument `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
name|optind
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 0 if not applied because not reversible; otherwise return 1. */
end_comment

begin_function
name|int
name|set_mode
parameter_list|(
name|info
parameter_list|,
name|reversed
parameter_list|,
name|mode
parameter_list|)
name|struct
name|mode_info
modifier|*
name|info
decl_stmt|;
name|int
name|reversed
decl_stmt|;
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|tcflag_t
modifier|*
name|bitsp
decl_stmt|;
if|if
condition|(
name|reversed
operator|&&
operator|(
name|info
operator|->
name|flags
operator|&
name|REV
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bitsp
operator|=
name|mode_type_flag
argument_list|(
name|info
operator|->
name|type
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitsp
operator|==
name|NULL
condition|)
block|{
comment|/* Combination mode. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"evenp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"parity"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|PARENB
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS8
expr_stmt|;
else|else
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|PARODD
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|PARENB
operator||
name|CS7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"oddp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|PARENB
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS8
expr_stmt|;
else|else
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS7
operator||
name|PARODD
operator||
name|PARENB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"nl"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|mode
operator|->
name|c_iflag
operator|=
name|mode
operator|->
name|c_iflag
operator|&
operator|~
operator|(
name|ICRNL
operator||
name|INLCR
operator||
name|IGNCR
operator|)
expr_stmt|;
else|else
name|mode
operator|->
name|c_iflag
operator|=
name|mode
operator|->
name|c_iflag
operator||
name|ICRNL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"ek"
argument_list|)
condition|)
block|{
name|mode
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|CERASE
expr_stmt|;
name|mode
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
name|CKILL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"sane"
argument_list|)
condition|)
name|sane_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"cbreak"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|mode
operator|->
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
else|else
name|mode
operator|->
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"pass8"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
block|{
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS7
operator||
name|PARENB
expr_stmt|;
name|mode
operator|->
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|PARENB
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS8
expr_stmt|;
name|mode
operator|->
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"litout"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
block|{
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS7
operator||
name|PARENB
expr_stmt|;
name|mode
operator|->
name|c_iflag
operator||=
name|ISTRIP
expr_stmt|;
name|mode
operator|->
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|->
name|c_cflag
operator|=
operator|(
name|mode
operator|->
name|c_cflag
operator|&
operator|~
name|PARENB
operator|&
operator|~
name|CSIZE
operator|)
operator||
name|CS8
expr_stmt|;
name|mode
operator|->
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
name|mode
operator|->
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"raw"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"cooked"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'r'
operator|&&
name|reversed
operator|)
operator|||
operator|(
name|info
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
operator|!
name|reversed
operator|)
condition|)
block|{
comment|/* Cooked mode. */
name|mode
operator|->
name|c_iflag
operator||=
name|BRKINT
operator||
name|IGNPAR
operator||
name|ISTRIP
operator||
name|ICRNL
operator||
name|IXON
expr_stmt|;
name|mode
operator|->
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
name|mode
operator|->
name|c_lflag
operator||=
name|ISIG
operator||
name|ICANON
expr_stmt|;
if|#
directive|if
name|VMIN
operator|==
name|VEOF
name|mode
operator|->
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|CEOF
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VTIME
operator|==
name|VEOL
name|mode
operator|->
name|c_cc
index|[
name|VEOL
index|]
operator|=
name|CEOL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Raw mode. */
name|mode
operator|->
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
name|mode
operator|->
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
ifdef|#
directive|ifdef
name|XCASE
operator||
name|XCASE
endif|#
directive|endif
operator|)
expr_stmt|;
name|mode
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|mode
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IXANY
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"decctlq"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|mode
operator|->
name|c_iflag
operator||=
name|IXANY
expr_stmt|;
else|else
name|mode
operator|->
name|c_iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABDLY
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"tabs"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|mode
operator|->
name|c_oflag
operator|=
operator|(
name|mode
operator|->
name|c_oflag
operator|&
operator|~
name|TABDLY
operator|)
operator||
name|TAB3
expr_stmt|;
else|else
name|mode
operator|->
name|c_oflag
operator|=
operator|(
name|mode
operator|->
name|c_oflag
operator|&
operator|~
name|TABDLY
operator|)
operator||
name|TAB0
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCASE
argument_list|)
operator|&&
name|defined
argument_list|(
name|IUCLC
argument_list|)
operator|&&
name|defined
argument_list|(
name|OLCUC
argument_list|)
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"lcase"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"LCASE"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
block|{
name|mode
operator|->
name|c_lflag
operator|&=
operator|~
name|XCASE
expr_stmt|;
name|mode
operator|->
name|c_iflag
operator|&=
operator|~
name|IUCLC
expr_stmt|;
name|mode
operator|->
name|c_oflag
operator|&=
operator|~
name|OLCUC
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|->
name|c_lflag
operator||=
name|XCASE
expr_stmt|;
name|mode
operator|->
name|c_iflag
operator||=
name|IUCLC
expr_stmt|;
name|mode
operator|->
name|c_oflag
operator||=
name|OLCUC
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECHOCTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ECHOKE
argument_list|)
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"crt"
argument_list|)
condition|)
name|mode
operator|->
name|c_lflag
operator||=
name|ECHOE
operator||
name|ECHOCTL
operator||
name|ECHOKE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"dec"
argument_list|)
condition|)
block|{
name|mode
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|=
literal|3
expr_stmt|;
comment|/* ^C */
name|mode
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|127
expr_stmt|;
comment|/* DEL */
name|mode
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|21
expr_stmt|;
comment|/* ^U */
name|mode
operator|->
name|c_lflag
operator||=
name|ECHOE
operator||
name|ECHOCTL
operator||
name|ECHOKE
expr_stmt|;
ifdef|#
directive|ifdef
name|IXANY
name|mode
operator|->
name|c_iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|reversed
condition|)
operator|*
name|bitsp
operator|=
operator|*
name|bitsp
operator|&
operator|~
name|info
operator|->
name|mask
operator|&
operator|~
name|info
operator|->
name|bits
expr_stmt|;
else|else
operator|*
name|bitsp
operator|=
operator|(
operator|*
name|bitsp
operator|&
operator|~
name|info
operator|->
name|mask
operator|)
operator||
name|info
operator|->
name|bits
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|set_control_char
parameter_list|(
name|info
parameter_list|,
name|arg
parameter_list|,
name|mode
parameter_list|)
name|struct
name|control_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|unsigned
name|char
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"min"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
literal|"time"
argument_list|)
condition|)
name|value
operator|=
name|integer_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|value
operator|=
name|arg
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"^-"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"undef"
argument_list|)
condition|)
name|value
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'^'
operator|&&
name|arg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
comment|/* Ignore any trailing junk. */
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
name|value
operator|=
literal|127
expr_stmt|;
else|else
name|value
operator|=
name|arg
index|[
literal|1
index|]
operator|&
operator|~
literal|0140
expr_stmt|;
comment|/* Non-letters get weird results. */
block|}
else|else
name|value
operator|=
name|integer_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mode
operator|->
name|c_cc
index|[
name|info
operator|->
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_speed
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|,
name|mode
parameter_list|)
name|enum
name|speed_setting
name|type
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|baud
decl_stmt|;
name|baud
operator|=
name|string_to_baud
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|input_speed
operator|||
name|type
operator|==
name|both_speeds
condition|)
name|cfsetispeed
argument_list|(
name|mode
argument_list|,
name|baud
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|output_speed
operator|||
name|type
operator|==
name|both_speeds
condition|)
name|cfsetospeed
argument_list|(
name|mode
argument_list|,
name|baud
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_function
name|void
name|set_window_size
parameter_list|(
name|rows
parameter_list|,
name|cols
parameter_list|)
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
block|{
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|>=
literal|0
condition|)
name|win
operator|.
name|ws_row
operator|=
name|rows
expr_stmt|;
if|if
condition|(
name|cols
operator|>=
literal|0
condition|)
name|win
operator|.
name|ws_col
operator|=
name|cols
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_window_size
parameter_list|(
name|fancy
parameter_list|)
name|int
name|fancy
decl_stmt|;
block|{
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
name|wrapf
argument_list|(
name|fancy
condition|?
literal|"rows %d; columns %d;"
else|:
literal|"%d %d\n"
argument_list|,
name|win
operator|.
name|ws_row
argument_list|,
name|win
operator|.
name|ws_col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fancy
condition|)
name|current_col
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|screen_columns
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|.
name|ws_col
operator|>
literal|0
condition|)
return|return
name|win
operator|.
name|ws_col
return|;
endif|#
directive|endif
if|if
condition|(
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
condition|)
return|return
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
argument_list|)
return|;
return|return
literal|80
return|;
block|}
end_function

begin_function
name|tcflag_t
modifier|*
name|mode_type_flag
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|)
name|enum
name|mode_type
name|type
decl_stmt|;
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|control
case|:
return|return
operator|&
name|mode
operator|->
name|c_cflag
return|;
case|case
name|input
case|:
return|return
operator|&
name|mode
operator|->
name|c_iflag
return|;
case|case
name|output
case|:
return|return
operator|&
name|mode
operator|->
name|c_oflag
return|;
case|case
name|local
case|:
return|return
operator|&
name|mode
operator|->
name|c_lflag
return|;
case|case
name|combination
case|:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|void
name|display_settings
parameter_list|(
name|output_type
parameter_list|,
name|mode
parameter_list|)
name|enum
name|output_type
name|output_type
decl_stmt|;
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|output_type
condition|)
block|{
case|case
name|changed
case|:
name|display_changed
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|all
case|:
name|display_all
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|recoverable
case|:
name|display_recoverable
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|display_changed
parameter_list|(
name|mode
parameter_list|)
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|empty_line
decl_stmt|;
name|tcflag_t
modifier|*
name|bitsp
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|enum
name|mode_type
name|prev_type
init|=
name|control
decl_stmt|;
name|display_speed
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|C_LINE_MISSING
name|wrapf
argument_list|(
literal|"line = %d;"
argument_list|,
name|mode
operator|->
name|c_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
name|empty_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|strcmp
argument_list|(
name|control_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"min"
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode
operator|->
name|c_cc
index|[
name|control_info
index|[
name|i
index|]
operator|.
name|offset
index|]
operator|==
name|control_info
index|[
name|i
index|]
operator|.
name|saneval
condition|)
continue|continue;
name|empty_line
operator|=
literal|0
expr_stmt|;
name|wrapf
argument_list|(
literal|"%s = %s;"
argument_list|,
name|control_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|visible
argument_list|(
name|mode
operator|->
name|c_cc
index|[
name|control_info
index|[
name|i
index|]
operator|.
name|offset
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|->
name|c_lflag
operator|&
name|ICANON
operator|)
operator|==
literal|0
condition|)
block|{
name|wrapf
argument_list|(
literal|"min = %d; time = %d;\n"
argument_list|,
operator|(
name|int
operator|)
name|mode
operator|->
name|c_cc
index|[
name|VMIN
index|]
argument_list|,
operator|(
name|int
operator|)
name|mode
operator|->
name|c_cc
index|[
name|VTIME
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|empty_line
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
name|empty_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mode_info
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|OMIT
condition|)
continue|continue;
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|prev_type
condition|)
block|{
if|if
condition|(
name|empty_line
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
name|empty_line
operator|=
literal|1
expr_stmt|;
block|}
name|prev_type
operator|=
name|mode_info
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
block|}
name|bitsp
operator|=
name|mode_type_flag
argument_list|(
name|mode_info
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mode_info
index|[
name|i
index|]
operator|.
name|mask
condition|?
name|mode_info
index|[
name|i
index|]
operator|.
name|mask
else|:
name|mode_info
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bitsp
operator|&
name|mask
operator|)
operator|==
name|mode_info
index|[
name|i
index|]
operator|.
name|bits
condition|)
block|{
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SANE_UNSET
condition|)
block|{
name|wrapf
argument_list|(
literal|"%s"
argument_list|,
name|mode_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|empty_line
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
operator|(
name|SANE_SET
operator||
name|REV
operator|)
operator|)
operator|==
operator|(
name|SANE_SET
operator||
name|REV
operator|)
condition|)
block|{
name|wrapf
argument_list|(
literal|"-%s"
argument_list|,
name|mode_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|empty_line
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|empty_line
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_all
parameter_list|(
name|mode
parameter_list|)
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tcflag_t
modifier|*
name|bitsp
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|enum
name|mode_type
name|prev_type
init|=
name|control
decl_stmt|;
name|display_speed
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|display_window_size
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|C_LINE_MISSING
name|wrapf
argument_list|(
literal|"line = %d;"
argument_list|,
name|mode
operator|->
name|c_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|strcmp
argument_list|(
name|control_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"min"
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|wrapf
argument_list|(
literal|"%s = %s;"
argument_list|,
name|control_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|visible
argument_list|(
name|mode
operator|->
name|c_cc
index|[
name|control_info
index|[
name|i
index|]
operator|.
name|offset
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|wrapf
argument_list|(
literal|"min = %d; time = %d;\n"
argument_list|,
name|mode
operator|->
name|c_cc
index|[
name|VMIN
index|]
argument_list|,
name|mode
operator|->
name|c_cc
index|[
name|VTIME
index|]
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mode_info
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|OMIT
condition|)
continue|continue;
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|prev_type
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
name|prev_type
operator|=
name|mode_info
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
block|}
name|bitsp
operator|=
name|mode_type_flag
argument_list|(
name|mode_info
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mode_info
index|[
name|i
index|]
operator|.
name|mask
condition|?
name|mode_info
index|[
name|i
index|]
operator|.
name|mask
else|:
name|mode_info
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bitsp
operator|&
name|mask
operator|)
operator|==
name|mode_info
index|[
name|i
index|]
operator|.
name|bits
condition|)
name|wrapf
argument_list|(
literal|"%s"
argument_list|,
name|mode_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|REV
condition|)
name|wrapf
argument_list|(
literal|"-%s"
argument_list|,
name|mode_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|current_col
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_speed
parameter_list|(
name|mode
parameter_list|,
name|fancy
parameter_list|)
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
name|int
name|fancy
decl_stmt|;
block|{
if|if
condition|(
name|cfgetispeed
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|||
name|cfgetispeed
argument_list|(
name|mode
argument_list|)
operator|==
name|cfgetospeed
argument_list|(
name|mode
argument_list|)
condition|)
name|wrapf
argument_list|(
name|fancy
condition|?
literal|"speed %lu baud;"
else|:
literal|"%lu\n"
argument_list|,
name|baud_to_value
argument_list|(
name|cfgetospeed
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|wrapf
argument_list|(
name|fancy
condition|?
literal|"ispeed %lu baud; ospeed %lu baud;"
else|:
literal|"%lu %lu\n"
argument_list|,
name|baud_to_value
argument_list|(
name|cfgetispeed
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|baud_to_value
argument_list|(
name|cfgetospeed
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fancy
condition|)
name|current_col
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_recoverable
parameter_list|(
name|mode
parameter_list|)
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%lx:%lx:%lx:%lx"
argument_list|,
name|mode
operator|->
name|c_iflag
argument_list|,
name|mode
operator|->
name|c_oflag
argument_list|,
name|mode
operator|->
name|c_cflag
argument_list|,
name|mode
operator|->
name|c_lflag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCS
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|":%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mode
operator|->
name|c_cc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|recover_mode
parameter_list|(
name|arg
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|int
name|chr
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%lx:%lx:%lx:%lx%n"
argument_list|,
operator|&
name|mode
operator|->
name|c_iflag
argument_list|,
operator|&
name|mode
operator|->
name|c_oflag
argument_list|,
operator|&
name|mode
operator|->
name|c_cflag
argument_list|,
operator|&
name|mode
operator|->
name|c_lflag
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|4
condition|)
return|return
literal|0
return|;
name|arg
operator|+=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCCS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|":%x%n"
argument_list|,
operator|&
name|chr
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|mode
operator|->
name|c_cc
index|[
name|i
index|]
operator|=
name|chr
expr_stmt|;
name|arg
operator|+=
name|n
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|speed_map
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* ASCII representation. */
name|speed_t
name|speed
decl_stmt|;
comment|/* Internal form. */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* Numeric value. */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|speed_map
name|speeds
index|[]
init|=
block|{
block|{
literal|"0"
block|,
name|B0
block|,
literal|0
block|}
block|,
block|{
literal|"50"
block|,
name|B50
block|,
literal|50
block|}
block|,
block|{
literal|"75"
block|,
name|B75
block|,
literal|75
block|}
block|,
block|{
literal|"110"
block|,
name|B110
block|,
literal|110
block|}
block|,
block|{
literal|"134"
block|,
name|B134
block|,
literal|134
block|}
block|,
block|{
literal|"134.5"
block|,
name|B134
block|,
literal|134
block|}
block|,
block|{
literal|"150"
block|,
name|B150
block|,
literal|150
block|}
block|,
block|{
literal|"200"
block|,
name|B200
block|,
literal|200
block|}
block|,
block|{
literal|"300"
block|,
name|B300
block|,
literal|300
block|}
block|,
block|{
literal|"600"
block|,
name|B600
block|,
literal|600
block|}
block|,
block|{
literal|"1200"
block|,
name|B1200
block|,
literal|1200
block|}
block|,
block|{
literal|"1800"
block|,
name|B1800
block|,
literal|1800
block|}
block|,
block|{
literal|"2400"
block|,
name|B2400
block|,
literal|2400
block|}
block|,
block|{
literal|"4800"
block|,
name|B4800
block|,
literal|4800
block|}
block|,
block|{
literal|"9600"
block|,
name|B9600
block|,
literal|9600
block|}
block|,
block|{
literal|"19200"
block|,
name|B19200
block|,
literal|19200
block|}
block|,
block|{
literal|"38400"
block|,
name|B38400
block|,
literal|38400
block|}
block|,
block|{
literal|"exta"
block|,
name|B19200
block|,
literal|19200
block|}
block|,
block|{
literal|"extb"
block|,
name|B38400
block|,
literal|38400
block|}
block|,
ifdef|#
directive|ifdef
name|B57600
block|{
literal|"57600"
block|,
name|B57600
block|,
literal|57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
literal|"115200"
block|,
name|B115200
block|,
literal|115200
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|string_to_baud
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|speeds
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
return|return
name|speeds
index|[
name|i
index|]
operator|.
name|speed
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|baud_to_value
parameter_list|(
name|speed
parameter_list|)
name|speed_t
name|speed
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|speed
operator|==
name|speeds
index|[
name|i
index|]
operator|.
name|speed
condition|)
return|return
name|speeds
index|[
name|i
index|]
operator|.
name|value
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sane_mode
parameter_list|(
name|mode
parameter_list|)
name|struct
name|termios
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tcflag_t
modifier|*
name|bitsp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|control_info
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
block|{
if|#
directive|if
name|VMIN
operator|==
name|VEOF
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|control_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"min"
argument_list|)
condition|)
break|break;
endif|#
directive|endif
name|mode
operator|->
name|c_cc
index|[
name|control_info
index|[
name|i
index|]
operator|.
name|offset
index|]
operator|=
name|control_info
index|[
name|i
index|]
operator|.
name|saneval
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mode_info
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SANE_SET
condition|)
block|{
name|bitsp
operator|=
name|mode_type_flag
argument_list|(
name|mode_info
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|*
name|bitsp
operator|=
operator|(
operator|*
name|bitsp
operator|&
operator|~
name|mode_info
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator||
name|mode_info
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode_info
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SANE_UNSET
condition|)
block|{
name|bitsp
operator|=
name|mode_type_flag
argument_list|(
name|mode_info
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|*
name|bitsp
operator|=
operator|*
name|bitsp
operator|&
operator|~
name|mode_info
index|[
name|i
index|]
operator|.
name|mask
operator|&
operator|~
name|mode_info
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a string that is the printable representation of character CH.  */
end_comment

begin_comment
comment|/* Adapted from `cat' by Torbjorn Granlund.  */
end_comment

begin_function
name|char
modifier|*
name|visible
parameter_list|(
name|ch
parameter_list|)
name|unsigned
name|char
name|ch
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|bpout
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|_POSIX_VDISABLE
condition|)
return|return
literal|"<undef>"
return|;
if|if
condition|(
name|ch
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|127
condition|)
operator|*
name|bpout
operator|++
operator|=
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|127
condition|)
block|{
operator|*
name|bpout
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|bpout
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bpout
operator|++
operator|=
literal|'M'
operator|,
operator|*
name|bpout
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|128
operator|+
literal|32
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|128
operator|+
literal|127
condition|)
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|-
literal|128
expr_stmt|;
else|else
block|{
operator|*
name|bpout
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|bpout
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|bpout
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|-
literal|128
operator|+
literal|64
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
operator|*
name|bpout
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|+
literal|64
expr_stmt|;
block|}
operator|*
name|bpout
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Parse string S as an integer, using decimal radix by default,    but allowing octal and hex numbers as in C.  */
end_comment

begin_comment
comment|/* From `od' by Richard Stallman.  */
end_comment

begin_function
name|long
name|integer_arg
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|long
name|value
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|radix
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'x'
condition|)
block|{
name|radix
operator|=
literal|16
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|radix
operator|=
literal|8
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|radix
operator|==
literal|16
operator|&&
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|>=
literal|'A'
operator|&&
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|value
operator|*=
name|radix
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|value
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|value
operator|+=
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|-
literal|'A'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|value
operator|*=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|value
operator|*=
literal|1024
expr_stmt|;
else|else
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid integer argument `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

