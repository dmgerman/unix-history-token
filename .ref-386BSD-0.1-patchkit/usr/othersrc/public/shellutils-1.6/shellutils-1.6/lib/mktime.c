begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Free Software Foundation, Inc. This file is part of the GNU C Library.  The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU C Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TM_IN_SYS_TIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONG_MAX
value|(~(1<< (sizeof (long) * 8 - 1)))
end_define

begin_define
define|#
directive|define
name|LONG_MIN
value|(-LONG_MAX - 1)
end_define

begin_define
define|#
directive|define
name|INT_MAX
value|(~(1<< (sizeof (int) * 8 - 1)))
end_define

begin_define
define|#
directive|define
name|INT_MIN
value|(-INT_MAX - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__isleap
end_ifndef

begin_comment
comment|/* Nonzero if YEAR is a leap year (every 4 years,    except every 100th isn't, and every 1000th is).  */
end_comment

begin_define
define|#
directive|define
name|__isleap
parameter_list|(
name|year
parameter_list|)
define|\
value|((year) % 4 == 0&& ((year) % 100 != 0 || (year) % 1000 == 0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How many days are in each month.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|int
name|__mon_lengths
index|[
literal|2
index|]
index|[
literal|12
index|]
init|=
block|{
comment|/* Normal years.  */
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|,
comment|/* Leap years.  */
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|invalid
parameter_list|()
value|return (time_t) -1
end_define

begin_comment
comment|/* Return the `time_t' representation of TP and normalizes TP.    Return (time_t) -1 if TP is not representable as a `time_t'.    Note that 31 Dec 1969 23:59:59 is not representable    because it is represented as (time_t) -1.  */
end_comment

begin_function
name|time_t
name|mktime
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
block|{
specifier|static
name|struct
name|tm
name|min
decl_stmt|,
name|max
decl_stmt|;
specifier|static
name|char
name|init
init|=
literal|0
decl_stmt|;
specifier|register
name|time_t
name|result
decl_stmt|;
specifier|register
name|time_t
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|new
decl_stmt|;
name|time_t
name|end
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|invalid
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|init
operator|=
literal|1
expr_stmt|;
name|end
operator|=
operator|(
name|time_t
operator|)
name|LONG_MIN
expr_stmt|;
name|new
operator|=
name|gmtime
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
name|min
operator|=
operator|*
name|new
expr_stmt|;
else|else
name|min
operator|.
name|tm_sec
operator|=
name|min
operator|.
name|tm_min
operator|=
name|min
operator|.
name|tm_hour
operator|=
name|min
operator|.
name|tm_mday
operator|=
name|min
operator|.
name|tm_mon
operator|=
name|min
operator|.
name|tm_year
operator|=
name|INT_MIN
expr_stmt|;
name|end
operator|=
operator|(
name|time_t
operator|)
name|LONG_MAX
expr_stmt|;
name|new
operator|=
name|gmtime
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
name|max
operator|=
operator|*
name|new
expr_stmt|;
else|else
name|max
operator|.
name|tm_sec
operator|=
name|max
operator|.
name|tm_min
operator|=
name|max
operator|.
name|tm_hour
operator|=
name|max
operator|.
name|tm_mday
operator|=
name|max
operator|.
name|tm_mon
operator|=
name|max
operator|.
name|tm_year
operator|=
name|INT_MAX
expr_stmt|;
block|}
while|while
condition|(
name|tp
operator|->
name|tm_mon
operator|<
literal|0
condition|)
block|{
operator|--
name|tp
operator|->
name|tm_year
expr_stmt|;
name|tp
operator|->
name|tm_mon
operator|+=
literal|12
expr_stmt|;
block|}
while|while
condition|(
name|tp
operator|->
name|tm_mon
operator|>
literal|11
condition|)
block|{
operator|++
name|tp
operator|->
name|tm_year
expr_stmt|;
name|tp
operator|->
name|tm_mon
operator|-=
literal|12
expr_stmt|;
block|}
comment|/* Check for out-of-range values.  */
define|#
directive|define
name|lowhigh
parameter_list|(
name|field
parameter_list|,
name|minmax
parameter_list|,
name|cmp
parameter_list|)
value|(tp->field cmp minmax.field)
define|#
directive|define
name|low
parameter_list|(
name|field
parameter_list|)
value|lowhigh(field, min,<)
define|#
directive|define
name|high
parameter_list|(
name|field
parameter_list|)
value|lowhigh(field, max,>)
define|#
directive|define
name|oor
parameter_list|(
name|field
parameter_list|)
value|(low(field) || high(field))
define|#
directive|define
name|lowbound
parameter_list|(
name|field
parameter_list|)
value|(tp->field == min.field)
define|#
directive|define
name|highbound
parameter_list|(
name|field
parameter_list|)
value|(tp->field == max.field)
if|if
condition|(
name|oor
argument_list|(
name|tm_year
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|lowbound
argument_list|(
name|tm_year
argument_list|)
condition|)
block|{
if|if
condition|(
name|low
argument_list|(
name|tm_mon
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|lowbound
argument_list|(
name|tm_mon
argument_list|)
condition|)
block|{
if|if
condition|(
name|low
argument_list|(
name|tm_mday
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|lowbound
argument_list|(
name|tm_mday
argument_list|)
condition|)
block|{
if|if
condition|(
name|low
argument_list|(
name|tm_hour
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|lowbound
argument_list|(
name|tm_hour
argument_list|)
condition|)
block|{
if|if
condition|(
name|low
argument_list|(
name|tm_min
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|lowbound
argument_list|(
name|tm_min
argument_list|)
condition|)
block|{
if|if
condition|(
name|low
argument_list|(
name|tm_sec
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|highbound
argument_list|(
name|tm_year
argument_list|)
condition|)
block|{
if|if
condition|(
name|high
argument_list|(
name|tm_mon
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|highbound
argument_list|(
name|tm_mon
argument_list|)
condition|)
block|{
if|if
condition|(
name|high
argument_list|(
name|tm_mday
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|highbound
argument_list|(
name|tm_mday
argument_list|)
condition|)
block|{
if|if
condition|(
name|high
argument_list|(
name|tm_hour
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|highbound
argument_list|(
name|tm_hour
argument_list|)
condition|)
block|{
if|if
condition|(
name|high
argument_list|(
name|tm_min
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|highbound
argument_list|(
name|tm_min
argument_list|)
condition|)
block|{
if|if
condition|(
name|high
argument_list|(
name|tm_sec
argument_list|)
condition|)
name|invalid
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1970
init|;
name|i
operator|>
literal|1900
operator|+
name|tp
operator|->
name|tm_year
condition|;
operator|--
name|i
control|)
name|t
operator|-=
name|__isleap
argument_list|(
name|i
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1970
init|;
name|i
operator|<
literal|1900
operator|+
name|tp
operator|->
name|tm_year
condition|;
operator|++
name|i
control|)
name|t
operator|+=
name|__isleap
argument_list|(
name|i
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
name|l
operator|=
name|__mon_lengths
index|[
name|__isleap
argument_list|(
literal|1900
operator|+
name|tp
operator|->
name|tm_year
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|tm_mon
condition|;
operator|++
name|i
control|)
name|t
operator|+=
name|l
index|[
name|i
index|]
expr_stmt|;
name|t
operator|+=
name|tp
operator|->
name|tm_mday
operator|-
literal|1
expr_stmt|;
name|result
operator|=
operator|(
operator|(
name|t
operator|*
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
operator|+
operator|(
name|tp
operator|->
name|tm_hour
operator|*
literal|60
operator|*
literal|60
operator|)
operator|+
operator|(
name|tp
operator|->
name|tm_min
operator|*
literal|60
operator|)
operator|+
name|tp
operator|->
name|tm_sec
operator|)
expr_stmt|;
name|end
operator|=
name|result
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code breaks it, on SunOS anyway. */
block|if (tp->tm_isdst< 0)     new = localtime(&end);   else
endif|#
directive|endif
name|new
operator|=
name|gmtime
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
name|invalid
argument_list|()
expr_stmt|;
name|new
operator|->
name|tm_isdst
operator|=
name|tp
operator|->
name|tm_isdst
expr_stmt|;
operator|*
name|tp
operator|=
operator|*
name|new
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

