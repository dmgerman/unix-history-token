begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pciercx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pciercx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PCIERCX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PCIERCX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG000
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG000(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG000
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG001
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG001(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000004ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG001
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000004ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG002
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG002(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG002
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG003
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG003(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000000Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG003
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000000Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG004
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG004(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG004
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG005
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG005(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000014ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG005
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000014ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG006
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG006(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000018ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG006
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000018ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG007
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG007(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000001Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG007
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000001Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG008
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG008(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG008
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG009
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG009(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000024ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG009
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000024ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG010
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG010(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000028ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG010
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000028ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG011
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG011(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000002Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG011
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000002Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG012
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG012(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000030ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG012
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000030ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG013
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG013(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000034ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG013
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000034ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG014
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG014(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000038ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG014
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000038ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG015
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG015(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000003Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG015
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000003Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG016
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG016(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000040ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG016
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000040ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG017
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG017(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000044ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG017
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000044ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG020
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG020(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000050ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG020
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000050ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG021
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG021(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000054ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG021
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000054ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG022
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG022(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000058ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG022
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000058ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG023
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG023(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000005Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG023
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000005Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG028
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG028(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000070ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG028
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000070ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG029
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG029(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000074ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG029
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000074ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG030
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG030(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000078ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG030
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000078ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG031
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG031(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000007Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG031
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000007Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG032
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG032(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000080ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG032
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000080ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG033
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG033(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000084ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG033
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000084ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG034
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG034(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000088ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG034
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000088ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG035
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG035(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000008Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG035
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000008Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG036
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG036(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000090ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG036
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000090ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG037
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG037(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000094ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG037
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000094ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG038
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG038(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000098ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG038
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000098ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG039
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG039(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000009Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG039
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000009Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG040
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG040(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG040
parameter_list|(
name|block_id
parameter_list|)
value|(0x00000000000000A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG041
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG041(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000A4ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG041
parameter_list|(
name|block_id
parameter_list|)
value|(0x00000000000000A4ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG042
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG042(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000A8ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG042
parameter_list|(
name|block_id
parameter_list|)
value|(0x00000000000000A8ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG064
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG064(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000100ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG064
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000100ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG065
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG065(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000104ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG065
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000104ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG066
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG066(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000108ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG066
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000108ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG067
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG067(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000010Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG067
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000010Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG068
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG068(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000110ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG068
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000110ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG069
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG069(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000114ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG069
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000114ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG070
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG070(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000118ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG070
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000118ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG071
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG071(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000011Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG071
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000011Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG072
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG072(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000120ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG072
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000120ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG073
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG073(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000124ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG073
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000124ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG074
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG074(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000128ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG074
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000128ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG075
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG075(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000012Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG075
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000012Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG076
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG076(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000130ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG076
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000130ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG077
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG077(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000134ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG077
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000134ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG448
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG448(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000700ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG448
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000700ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG449
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG449(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000704ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG449
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000704ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG450
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG450(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000708ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG450
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000708ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG451
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG451(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000070Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG451
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000070Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG452
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG452(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000710ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG452
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000710ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG453
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG453(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000714ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG453
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000714ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG454
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG454(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000718ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG454
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000718ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG455
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG455(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000071Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG455
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000071Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG456
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG456(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000720ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG456
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000720ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG458
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG458(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000728ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG458
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000728ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG459
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG459(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000072Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG459
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000072Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG460
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG460(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000730ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG460
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000730ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG461
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG461(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000734ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG461
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000734ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG462
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG462(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000738ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG462
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000738ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG463
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG463(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000073Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG463
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000073Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG464
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG464(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000740ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG464
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000740ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG465
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG465(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000744ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG465
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000744ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG466
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG466(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000748ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG466
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000748ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG467
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG467(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000074Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG467
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000074Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG468
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG468(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000750ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG468
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000750ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG490
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG490(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000007A8ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG490
parameter_list|(
name|block_id
parameter_list|)
value|(0x00000000000007A8ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG491
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG491(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000007ACull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG491
parameter_list|(
name|block_id
parameter_list|)
value|(0x00000000000007ACull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG492
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG492(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000007B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG492
parameter_list|(
name|block_id
parameter_list|)
value|(0x00000000000007B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG515
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG515(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000080Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG515
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000080Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG516
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG516(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000810ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG516
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000810ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCIERCX_CFG517
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCIERCX_CFG517(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000814ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCIERCX_CFG517
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000814ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pcierc#_cfg000  *  * PCIE_CFG000 = First 32-bits of PCIE type 1 config space (Device ID and Vendor ID Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg000
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg000_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|devid
range|:
literal|16
decl_stmt|;
comment|/**< Device ID, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|vendid
range|:
literal|16
decl_stmt|;
comment|/**< Vendor ID, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|vendid
range|:
literal|16
decl_stmt|;
name|uint32_t
name|devid
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg000_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg000_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg000_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg000_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg000_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg000_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg000
name|cvmx_pciercx_cfg000_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg001  *  * PCIE_CFG001 = Second 32-bits of PCIE type 1 config space (Command/Status Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg001
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg001_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dpe
range|:
literal|1
decl_stmt|;
comment|/**< Detected Parity Error */
name|uint32_t
name|sse
range|:
literal|1
decl_stmt|;
comment|/**< Signaled System Error */
name|uint32_t
name|rma
range|:
literal|1
decl_stmt|;
comment|/**< Received Master Abort */
name|uint32_t
name|rta
range|:
literal|1
decl_stmt|;
comment|/**< Received Target Abort */
name|uint32_t
name|sta
range|:
literal|1
decl_stmt|;
comment|/**< Signaled Target Abort */
name|uint32_t
name|devt
range|:
literal|2
decl_stmt|;
comment|/**< DEVSEL Timing                                                          Not applicable for PCI Express. Hardwired to 0. */
name|uint32_t
name|mdpe
range|:
literal|1
decl_stmt|;
comment|/**< Master Data Parity Error */
name|uint32_t
name|fbb
range|:
literal|1
decl_stmt|;
comment|/**< Fast Back-to-Back Capable                                                          Not applicable for PCI Express. Hardwired to 0. */
name|uint32_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m66
range|:
literal|1
decl_stmt|;
comment|/**< 66 MHz Capable                                                          Not applicable for PCI Express. Hardwired to 0. */
name|uint32_t
name|cl
range|:
literal|1
decl_stmt|;
comment|/**< Capabilities List                                                          Indicates presence of an extended capability item.                                                          Hardwired to 1. */
name|uint32_t
name|i_stat
range|:
literal|1
decl_stmt|;
comment|/**< INTx Status */
name|uint32_t
name|reserved_11_18
range|:
literal|8
decl_stmt|;
name|uint32_t
name|i_dis
range|:
literal|1
decl_stmt|;
comment|/**< INTx Assertion Disable */
name|uint32_t
name|fbbe
range|:
literal|1
decl_stmt|;
comment|/**< Fast Back-to-Back Enable                                                          Not applicable for PCI Express. Must be hardwired to 0. */
name|uint32_t
name|see
range|:
literal|1
decl_stmt|;
comment|/**< SERR# Enable */
name|uint32_t
name|ids_wcc
range|:
literal|1
decl_stmt|;
comment|/**< IDSEL Stepping/Wait Cycle Control                                                          Not applicable for PCI Express. Must be hardwired to 0 */
name|uint32_t
name|per
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error Response */
name|uint32_t
name|vps
range|:
literal|1
decl_stmt|;
comment|/**< VGA Palette Snoop                                                          Not applicable for PCI Express. Must be hardwired to 0. */
name|uint32_t
name|mwice
range|:
literal|1
decl_stmt|;
comment|/**< Memory Write and Invalidate                                                          Not applicable for PCI Express. Must be hardwired to 0. */
name|uint32_t
name|scse
range|:
literal|1
decl_stmt|;
comment|/**< Special Cycle Enable                                                          Not applicable for PCI Express. Must be hardwired to 0. */
name|uint32_t
name|me
range|:
literal|1
decl_stmt|;
comment|/**< Bus Master Enable */
name|uint32_t
name|msae
range|:
literal|1
decl_stmt|;
comment|/**< Memory Space Enable */
name|uint32_t
name|isae
range|:
literal|1
decl_stmt|;
comment|/**< I/O Space Enable */
else|#
directive|else
name|uint32_t
name|isae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|me
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scse
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mwice
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|per
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ids_wcc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|see
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fbbe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_dis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_11_18
range|:
literal|8
decl_stmt|;
name|uint32_t
name|i_stat
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m66
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fbb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mdpe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|devt
range|:
literal|2
decl_stmt|;
name|uint32_t
name|sta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rma
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sse
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dpe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg001_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg001_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg001_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg001_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg001_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg001_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg001
name|cvmx_pciercx_cfg001_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg002  *  * PCIE_CFG002 = Third 32-bits of PCIE type 1 config space (Revision ID/Class Code Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg002
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg002_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|bcc
range|:
literal|8
decl_stmt|;
comment|/**< Base Class Code, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|sc
range|:
literal|8
decl_stmt|;
comment|/**< Subclass Code, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|pi
range|:
literal|8
decl_stmt|;
comment|/**< Programming Interface, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|rid
range|:
literal|8
decl_stmt|;
comment|/**< Revision ID, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|rid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|pi
range|:
literal|8
decl_stmt|;
name|uint32_t
name|sc
range|:
literal|8
decl_stmt|;
name|uint32_t
name|bcc
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg002_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg002_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg002_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg002_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg002_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg002_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg002
name|cvmx_pciercx_cfg002_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg003  *  * PCIE_CFG003 = Fourth 32-bits of PCIE type 1 config space (Cache Line Size/Master Latency Timer/Header Type Register/BIST Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg003
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg003_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|bist
range|:
literal|8
decl_stmt|;
comment|/**< The BIST register functions are not supported.                                                          All 8 bits of the BIST register are hardwired to 0. */
name|uint32_t
name|mfd
range|:
literal|1
decl_stmt|;
comment|/**< Multi Function Device                                                          The Multi Function Device bit is writable through PEM(0..1)_CFG_WR.                                                          However, this is a single function device. Therefore, the                                                          application must not write a 1 to this bit. */
name|uint32_t
name|chf
range|:
literal|7
decl_stmt|;
comment|/**< Configuration Header Format                                                          Hardwired to 1. */
name|uint32_t
name|lt
range|:
literal|8
decl_stmt|;
comment|/**< Master Latency Timer                                                          Not applicable for PCI Express, hardwired to 0. */
name|uint32_t
name|cls
range|:
literal|8
decl_stmt|;
comment|/**< Cache Line Size                                                          The Cache Line Size register is RW for legacy compatibility                                                          purposes and is not applicable to PCI Express device                                                          functionality. */
else|#
directive|else
name|uint32_t
name|cls
range|:
literal|8
decl_stmt|;
name|uint32_t
name|lt
range|:
literal|8
decl_stmt|;
name|uint32_t
name|chf
range|:
literal|7
decl_stmt|;
name|uint32_t
name|mfd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bist
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg003_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg003_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg003_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg003_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg003_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg003_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg003
name|cvmx_pciercx_cfg003_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg004  *  * PCIE_CFG004 = Fifth 32-bits of PCIE type 1 config space (Base Address Register 0 - Low)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg004
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg004_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg004_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg004_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg004_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg004_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg004_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg004_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg004
name|cvmx_pciercx_cfg004_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg005  *  * PCIE_CFG005 = Sixth 32-bits of PCIE type 1 config space (Base Address Register 0 - High)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg005
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg005_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg005_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg005_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg005_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg005_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg005_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg005_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg005
name|cvmx_pciercx_cfg005_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg006  *  * PCIE_CFG006 = Seventh 32-bits of PCIE type 1 config space (Bus Number Registers)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg006
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg006_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|slt
range|:
literal|8
decl_stmt|;
comment|/**< Secondary Latency Timer                                                          Not applicable to PCI Express, hardwired to 0x00. */
name|uint32_t
name|subbnum
range|:
literal|8
decl_stmt|;
comment|/**< Subordinate Bus Number */
name|uint32_t
name|sbnum
range|:
literal|8
decl_stmt|;
comment|/**< Secondary Bus Number */
name|uint32_t
name|pbnum
range|:
literal|8
decl_stmt|;
comment|/**< Primary Bus Number */
else|#
directive|else
name|uint32_t
name|pbnum
range|:
literal|8
decl_stmt|;
name|uint32_t
name|sbnum
range|:
literal|8
decl_stmt|;
name|uint32_t
name|subbnum
range|:
literal|8
decl_stmt|;
name|uint32_t
name|slt
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg006_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg006_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg006_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg006_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg006_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg006_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg006
name|cvmx_pciercx_cfg006_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg007  *  * PCIE_CFG007 = Eighth 32-bits of PCIE type 1 config space (IO Base and IO Limit/Secondary Status Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg007
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg007_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dpe
range|:
literal|1
decl_stmt|;
comment|/**< Detected Parity Error */
name|uint32_t
name|sse
range|:
literal|1
decl_stmt|;
comment|/**< Signaled System Error */
name|uint32_t
name|rma
range|:
literal|1
decl_stmt|;
comment|/**< Received Master Abort */
name|uint32_t
name|rta
range|:
literal|1
decl_stmt|;
comment|/**< Received Target Abort */
name|uint32_t
name|sta
range|:
literal|1
decl_stmt|;
comment|/**< Signaled Target Abort */
name|uint32_t
name|devt
range|:
literal|2
decl_stmt|;
comment|/**< DEVSEL Timing                                                          Not applicable for PCI Express. Hardwired to 0. */
name|uint32_t
name|mdpe
range|:
literal|1
decl_stmt|;
comment|/**< Master Data Parity Error */
name|uint32_t
name|fbb
range|:
literal|1
decl_stmt|;
comment|/**< Fast Back-to-Back Capable                                                          Not applicable for PCI Express. Hardwired to 0. */
name|uint32_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m66
range|:
literal|1
decl_stmt|;
comment|/**< 66 MHz Capable                                                          Not applicable for PCI Express. Hardwired to 0. */
name|uint32_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint32_t
name|lio_limi
range|:
literal|4
decl_stmt|;
comment|/**< I/O Space Limit */
name|uint32_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint32_t
name|io32b
range|:
literal|1
decl_stmt|;
comment|/**< 32-Bit I/O Space */
name|uint32_t
name|lio_base
range|:
literal|4
decl_stmt|;
comment|/**< I/O Space Base */
name|uint32_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint32_t
name|io32a
range|:
literal|1
decl_stmt|;
comment|/**< 32-Bit I/O Space                                                          o 0 = 16-bit I/O addressing                                                          o 1 = 32-bit I/O addressing                                                          This bit is writable through PEM(0..1)_CFG_WR.                                                          When the application                                                          writes to this bit through PEM(0..1)_CFG_WR,                                                          the same value is written                                                          to bit 8 of this register. */
else|#
directive|else
name|uint32_t
name|io32a
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint32_t
name|lio_base
range|:
literal|4
decl_stmt|;
name|uint32_t
name|io32b
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint32_t
name|lio_limi
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint32_t
name|m66
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fbb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mdpe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|devt
range|:
literal|2
decl_stmt|;
name|uint32_t
name|sta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rma
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sse
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dpe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg007_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg007_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg007_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg007_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg007_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg007_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg007
name|cvmx_pciercx_cfg007_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg008  *  * PCIE_CFG008 = Ninth 32-bits of PCIE type 1 config space (Memory Base and Memory Limit Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg008
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg008_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|ml_addr
range|:
literal|12
decl_stmt|;
comment|/**< Memory Limit Address */
name|uint32_t
name|reserved_16_19
range|:
literal|4
decl_stmt|;
name|uint32_t
name|mb_addr
range|:
literal|12
decl_stmt|;
comment|/**< Memory Base Address */
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint32_t
name|mb_addr
range|:
literal|12
decl_stmt|;
name|uint32_t
name|reserved_16_19
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ml_addr
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg008_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg008_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg008_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg008_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg008_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg008_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg008
name|cvmx_pciercx_cfg008_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg009  *  * PCIE_CFG009 = Tenth 32-bits of PCIE type 1 config space (Prefetchable Memory Base and Limit Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg009
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg009_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lmem_limit
range|:
literal|12
decl_stmt|;
comment|/**< Upper 12 bits of 32-bit Prefetchable Memory End Address */
name|uint32_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint32_t
name|mem64b
range|:
literal|1
decl_stmt|;
comment|/**< 64-Bit Memory Addressing                                                          o 0 = 32-bit memory addressing                                                          o 1 = 64-bit memory addressing */
name|uint32_t
name|lmem_base
range|:
literal|12
decl_stmt|;
comment|/**< Upper 12 bits of 32-bit Prefetchable Memory Start Address */
name|uint32_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint32_t
name|mem64a
range|:
literal|1
decl_stmt|;
comment|/**< 64-Bit Memory Addressing                                                          o 0 = 32-bit memory addressing                                                          o 1 = 64-bit memory addressing                                                          This bit is writable through PEM(0..1)_CFG_WR.                                                          When the application                                                          writes to this bit through PEM(0..1)_CFG_WR,                                                          the same value is written                                                          to bit 16 of this register. */
else|#
directive|else
name|uint32_t
name|mem64a
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint32_t
name|lmem_base
range|:
literal|12
decl_stmt|;
name|uint32_t
name|mem64b
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint32_t
name|lmem_limit
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg009_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg009_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg009_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg009_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg009_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg009_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg009
name|cvmx_pciercx_cfg009_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg010  *  * PCIE_CFG010 = Eleventh 32-bits of PCIE type 1 config space (Prefetchable Base Upper 32 Bits Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg010
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg010_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|umem_base
range|:
literal|32
decl_stmt|;
comment|/**< Upper 32 Bits of Base Address of Prefetchable Memory Space                                                          Used only when 64-bit prefetchable memory addressing is                                                          enabled. */
else|#
directive|else
name|uint32_t
name|umem_base
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg010_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg010_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg010_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg010_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg010_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg010_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg010
name|cvmx_pciercx_cfg010_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg011  *  * PCIE_CFG011 = Twelfth 32-bits of PCIE type 1 config space (Prefetchable Limit Upper 32 Bits Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg011
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg011_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|umem_limit
range|:
literal|32
decl_stmt|;
comment|/**< Upper 32 Bits of Limit Address of Prefetchable Memory Space                                                          Used only when 64-bit prefetchable memory addressing is                                                          enabled. */
else|#
directive|else
name|uint32_t
name|umem_limit
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg011_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg011_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg011_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg011_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg011_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg011_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg011
name|cvmx_pciercx_cfg011_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg012  *  * PCIE_CFG012 = Thirteenth 32-bits of PCIE type 1 config space (IO Base and Limit Upper 16 Bits Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg012
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg012_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|uio_limit
range|:
literal|16
decl_stmt|;
comment|/**< Upper 16 Bits of I/O Limit (if 32-bit I/O decoding is supported                                                          for devices on the secondary side) */
name|uint32_t
name|uio_base
range|:
literal|16
decl_stmt|;
comment|/**< Upper 16 Bits of I/O Base (if 32-bit I/O decoding is supported                                                          for devices on the secondary side) */
else|#
directive|else
name|uint32_t
name|uio_base
range|:
literal|16
decl_stmt|;
name|uint32_t
name|uio_limit
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg012_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg012_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg012_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg012_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg012_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg012_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg012
name|cvmx_pciercx_cfg012_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg013  *  * PCIE_CFG013 = Fourteenth 32-bits of PCIE type 1 config space (Capability Pointer Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg013
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg013_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
name|uint32_t
name|cp
range|:
literal|8
decl_stmt|;
comment|/**< First Capability Pointer.                                                          Points to Power Management Capability structure by                                                          default, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|cp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg013_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg013_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg013_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg013_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg013_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg013_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg013
name|cvmx_pciercx_cfg013_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg014  *  * PCIE_CFG014 = Fifteenth 32-bits of PCIE type 1 config space (Expansion ROM Base Address Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg014
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg014_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg014_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg014_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg014_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg014_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg014_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg014_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg014
name|cvmx_pciercx_cfg014_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg015  *  * PCIE_CFG015 = Sixteenth 32-bits of PCIE type 1 config space (Interrupt Line Register/Interrupt Pin/Bridge Control Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg015
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg015_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dtsees
range|:
literal|1
decl_stmt|;
comment|/**< Discard Timer SERR Enable Status                                                          Not applicable to PCI Express, hardwired to 0. */
name|uint32_t
name|dts
range|:
literal|1
decl_stmt|;
comment|/**< Discard Timer Status                                                          Not applicable to PCI Express, hardwired to 0. */
name|uint32_t
name|sdt
range|:
literal|1
decl_stmt|;
comment|/**< Secondary Discard Timer                                                          Not applicable to PCI Express, hardwired to 0. */
name|uint32_t
name|pdt
range|:
literal|1
decl_stmt|;
comment|/**< Primary Discard Timer                                                          Not applicable to PCI Express, hardwired to 0. */
name|uint32_t
name|fbbe
range|:
literal|1
decl_stmt|;
comment|/**< Fast Back-to-Back Transactions Enable                                                          Not applicable to PCI Express, hardwired to 0. */
name|uint32_t
name|sbrst
range|:
literal|1
decl_stmt|;
comment|/**< Secondary Bus Reset                                                          Hot reset. Causes TS1s with the hot reset bit to be sent to                                                          the link partner. When set, SW should wait 2ms before                                                          clearing. The link partner normally responds by sending TS1s                                                          with the hot reset bit set, which will cause a link                                                          down event - refer to "PCIe Link-Down Reset in RC Mode"                                                          section. */
name|uint32_t
name|mam
range|:
literal|1
decl_stmt|;
comment|/**< Master Abort Mode                                                          Not applicable to PCI Express, hardwired to 0. */
name|uint32_t
name|vga16d
range|:
literal|1
decl_stmt|;
comment|/**< VGA 16-Bit Decode */
name|uint32_t
name|vgae
range|:
literal|1
decl_stmt|;
comment|/**< VGA Enable */
name|uint32_t
name|isae
range|:
literal|1
decl_stmt|;
comment|/**< ISA Enable */
name|uint32_t
name|see
range|:
literal|1
decl_stmt|;
comment|/**< SERR Enable */
name|uint32_t
name|pere
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error Response Enable */
name|uint32_t
name|inta
range|:
literal|8
decl_stmt|;
comment|/**< Interrupt Pin                                                          Identifies the legacy interrupt Message that the device                                                          (or device function) uses.                                                          The Interrupt Pin register is writable through PEM(0..1)_CFG_WR.                                                          In a single-function configuration, only INTA is used.                                                          Therefore, the application must not change this field. */
name|uint32_t
name|il
range|:
literal|8
decl_stmt|;
comment|/**< Interrupt Line */
else|#
directive|else
name|uint32_t
name|il
range|:
literal|8
decl_stmt|;
name|uint32_t
name|inta
range|:
literal|8
decl_stmt|;
name|uint32_t
name|pere
range|:
literal|1
decl_stmt|;
name|uint32_t
name|see
range|:
literal|1
decl_stmt|;
name|uint32_t
name|isae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vgae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vga16d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mam
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sbrst
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fbbe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pdt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sdt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dtsees
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg015_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg015_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg015_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg015_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg015_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg015_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg015
name|cvmx_pciercx_cfg015_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg016  *  * PCIE_CFG016 = Seventeenth 32-bits of PCIE type 1 config space  * (Power Management Capability ID/  * Power Management Next Item Pointer/  * Power Management Capabilities Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg016
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg016_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pmes
range|:
literal|5
decl_stmt|;
comment|/**< PME_Support                                                          A value of 0 for any bit indicates that the                                                          device (or function) is not capable of generating PME Messages                                                          while in that power state:                                                          o Bit 11: If set, PME Messages can be generated from D0                                                          o Bit 12: If set, PME Messages can be generated from D1                                                          o Bit 13: If set, PME Messages can be generated from D2                                                          o Bit 14: If set, PME Messages can be generated from D3hot                                                          o Bit 15: If set, PME Messages can be generated from D3cold                                                          The PME_Support field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|d2s
range|:
literal|1
decl_stmt|;
comment|/**< D2 Support, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|d1s
range|:
literal|1
decl_stmt|;
comment|/**< D1 Support, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|auxc
range|:
literal|3
decl_stmt|;
comment|/**< AUX Current, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|dsi
range|:
literal|1
decl_stmt|;
comment|/**< Device Specific Initialization (DSI), writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pme_clock
range|:
literal|1
decl_stmt|;
comment|/**< PME Clock, hardwired to 0 */
name|uint32_t
name|pmsv
range|:
literal|3
decl_stmt|;
comment|/**< Power Management Specification Version, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
comment|/**< Next Capability Pointer                                                          Points to the MSI capabilities by default, writable                                                          through PEM(0..1)_CFG_WR. */
name|uint32_t
name|pmcid
range|:
literal|8
decl_stmt|;
comment|/**< Power Management Capability ID */
else|#
directive|else
name|uint32_t
name|pmcid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|pmsv
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pme_clock
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dsi
range|:
literal|1
decl_stmt|;
name|uint32_t
name|auxc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|d1s
range|:
literal|1
decl_stmt|;
name|uint32_t
name|d2s
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmes
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg016_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg016_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg016_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg016_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg016_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg016_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg016
name|cvmx_pciercx_cfg016_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg017  *  * PCIE_CFG017 = Eighteenth 32-bits of PCIE type 1 config space (Power Management Control and Status Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg017
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg017_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pmdia
range|:
literal|8
decl_stmt|;
comment|/**< Data register for additional information (not supported) */
name|uint32_t
name|bpccee
range|:
literal|1
decl_stmt|;
comment|/**< Bus Power/Clock Control Enable, hardwired to 0 */
name|uint32_t
name|bd3h
range|:
literal|1
decl_stmt|;
comment|/**< B2/B3 Support, hardwired to 0 */
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|pmess
range|:
literal|1
decl_stmt|;
comment|/**< PME Status                                                          Indicates if a previously enabled PME event occurred or not. */
name|uint32_t
name|pmedsia
range|:
literal|2
decl_stmt|;
comment|/**< Data Scale (not supported) */
name|uint32_t
name|pmds
range|:
literal|4
decl_stmt|;
comment|/**< Data Select (not supported) */
name|uint32_t
name|pmeens
range|:
literal|1
decl_stmt|;
comment|/**< PME Enable                                                          A value of 1 indicates that the device is enabled to                                                          generate PME. */
name|uint32_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint32_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< No Soft Reset, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ps
range|:
literal|2
decl_stmt|;
comment|/**< Power State                                                          Controls the device power state:                                                            o 00b: D0                                                            o 01b: D1                                                            o 10b: D2                                                            o 11b: D3                                                          The written value is ignored if the specific state is                                                          not supported. */
else|#
directive|else
name|uint32_t
name|ps
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint32_t
name|pmeens
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmds
range|:
literal|4
decl_stmt|;
name|uint32_t
name|pmedsia
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pmess
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|bd3h
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bpccee
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmdia
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg017_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg017_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg017_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg017_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg017_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg017_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg017
name|cvmx_pciercx_cfg017_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg020  *  * PCIE_CFG020 = Twenty-first 32-bits of PCIE type 1 config space  * (MSI Capability ID/  *  MSI Next Item Pointer/  *  MSI Control Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg020
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg020_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint32_t
name|m64
range|:
literal|1
decl_stmt|;
comment|/**< 64-bit Address Capable, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|mme
range|:
literal|3
decl_stmt|;
comment|/**< Multiple Message Enabled                                                          Indicates that multiple Message mode is enabled by system                                                          software. The number of Messages enabled must be less than                                                          or equal to the Multiple Message Capable value. */
name|uint32_t
name|mmc
range|:
literal|3
decl_stmt|;
comment|/**< Multiple Message Capable, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|msien
range|:
literal|1
decl_stmt|;
comment|/**< MSI Enabled                                                          When set, INTx must be disabled.                                                          This bit must never be set, as internal-MSI is not supported in                                                          RC mode. (Note that this has no effect on external MSI, which                                                          will be commonly used in RC mode.) */
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
comment|/**< Next Capability Pointer                                                          Points to PCI Express Capabilities by default,                                                          writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|msicid
range|:
literal|8
decl_stmt|;
comment|/**< MSI Capability ID */
else|#
directive|else
name|uint32_t
name|msicid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|msien
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mmc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|mme
range|:
literal|3
decl_stmt|;
name|uint32_t
name|m64
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg020_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg020_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg020_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg020_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg020_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg020_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg020
name|cvmx_pciercx_cfg020_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg021  *  * PCIE_CFG021 = Twenty-second 32-bits of PCIE type 1 config space (MSI Lower 32 Bits Address Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg021
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg021_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lmsi
range|:
literal|30
decl_stmt|;
comment|/**< Lower 32-bit Address */
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint32_t
name|lmsi
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg021_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg021_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg021_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg021_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg021_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg021_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg021
name|cvmx_pciercx_cfg021_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg022  *  * PCIE_CFG022 = Twenty-third 32-bits of PCIE type 1 config space (MSI Upper 32 bits Address Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg022
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg022_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|umsi
range|:
literal|32
decl_stmt|;
comment|/**< Upper 32-bit Address */
else|#
directive|else
name|uint32_t
name|umsi
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg022_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg022_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg022_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg022_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg022_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg022_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg022
name|cvmx_pciercx_cfg022_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg023  *  * PCIE_CFG023 = Twenty-fourth 32-bits of PCIE type 1 config space (MSI Data Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg023
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg023_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|msimd
range|:
literal|16
decl_stmt|;
comment|/**< MSI Data                                                          Pattern assigned by system software, bits [4:0] are Or-ed with                                                          MSI_VECTOR to generate 32 MSI Messages per function. */
else|#
directive|else
name|uint32_t
name|msimd
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg023_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg023_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg023_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg023_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg023_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg023_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg023
name|cvmx_pciercx_cfg023_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg028  *  * PCIE_CFG028 = Twenty-ninth 32-bits of PCIE type 1 config space  * (PCI Express Capabilities List Register/  *  PCI Express Capabilities Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg028
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg028_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint32_t
name|imn
range|:
literal|5
decl_stmt|;
comment|/**< Interrupt Message Number                                                          Updated by hardware, writable through PEM(0..1)_CFG_WR.                                                           However, the application must not change this field. */
name|uint32_t
name|si
range|:
literal|1
decl_stmt|;
comment|/**< Slot Implemented                                                          This bit is writable through PEM(0..1)_CFG_WR.                                                          However, it must 0 for an                                                          Endpoint device. Therefore, the application must not write a                                                          1 to this bit. */
name|uint32_t
name|dpt
range|:
literal|4
decl_stmt|;
comment|/**< Device Port Type */
name|uint32_t
name|pciecv
range|:
literal|4
decl_stmt|;
comment|/**< PCI Express Capability Version */
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
comment|/**< Next Capability Pointer                                                          writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|pcieid
range|:
literal|8
decl_stmt|;
comment|/**< PCIE Capability ID */
else|#
directive|else
name|uint32_t
name|pcieid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|pciecv
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dpt
range|:
literal|4
decl_stmt|;
name|uint32_t
name|si
range|:
literal|1
decl_stmt|;
name|uint32_t
name|imn
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg028_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg028_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg028_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg028_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg028_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg028_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg028
name|cvmx_pciercx_cfg028_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg029  *  * PCIE_CFG029 = Thirtieth 32-bits of PCIE type 1 config space (Device Capabilities Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg029
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg029_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint32_t
name|cspls
range|:
literal|2
decl_stmt|;
comment|/**< Captured Slot Power Limit Scale                                                          Not applicable for RC port, upstream port only. */
name|uint32_t
name|csplv
range|:
literal|8
decl_stmt|;
comment|/**< Captured Slot Power Limit Value                                                          Not applicable for RC port, upstream port only. */
name|uint32_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint32_t
name|rber
range|:
literal|1
decl_stmt|;
comment|/**< Role-Based Error Reporting, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_12_14
range|:
literal|3
decl_stmt|;
name|uint32_t
name|el1al
range|:
literal|3
decl_stmt|;
comment|/**< Endpoint L1 Acceptable Latency, writable through PEM(0..1)_CFG_WR                                                          Must be 0x0 for non-endpoint devices. */
name|uint32_t
name|el0al
range|:
literal|3
decl_stmt|;
comment|/**< Endpoint L0s Acceptable Latency, writable through PEM(0..1)_CFG_WR                                                          Must be 0x0 for non-endpoint devices. */
name|uint32_t
name|etfs
range|:
literal|1
decl_stmt|;
comment|/**< Extended Tag Field Supported                                                          This bit is writable through PEM(0..1)_CFG_WR.                                                          However, the application                                                          must not write a 1 to this bit. */
name|uint32_t
name|pfs
range|:
literal|2
decl_stmt|;
comment|/**< Phantom Function Supported                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, Phantom                                                          Function is not supported. Therefore, the application must not                                                          write any value other than 0x0 to this field. */
name|uint32_t
name|mpss
range|:
literal|3
decl_stmt|;
comment|/**< Max_Payload_Size Supported, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|mpss
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pfs
range|:
literal|2
decl_stmt|;
name|uint32_t
name|etfs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|el0al
range|:
literal|3
decl_stmt|;
name|uint32_t
name|el1al
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_12_14
range|:
literal|3
decl_stmt|;
name|uint32_t
name|rber
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint32_t
name|csplv
range|:
literal|8
decl_stmt|;
name|uint32_t
name|cspls
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg029_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg029_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg029_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg029_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg029_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg029_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg029
name|cvmx_pciercx_cfg029_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg030  *  * PCIE_CFG030 = Thirty-first 32-bits of PCIE type 1 config space  * (Device Control Register/Device Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg030
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg030_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_22_31
range|:
literal|10
decl_stmt|;
name|uint32_t
name|tp
range|:
literal|1
decl_stmt|;
comment|/**< Transaction Pending                                                          Set to 1 when Non-Posted Requests are not yet completed                                                          and clear when they are completed. */
name|uint32_t
name|ap_d
range|:
literal|1
decl_stmt|;
comment|/**< Aux Power Detected                                                          Set to 1 if Aux power detected. */
name|uint32_t
name|ur_d
range|:
literal|1
decl_stmt|;
comment|/**< Unsupported Request Detected                                                          Errors are logged in this register regardless of whether                                                           error reporting is enabled in the Device Control register.                                                          UR_D occurs when we receive something we don't support.                                                          Unsupported requests are Nonfatal errors, so UR_D should                                                          cause NFE_D.  Receiving a  vendor defined message should                                                          cause an unsupported request. */
name|uint32_t
name|fe_d
range|:
literal|1
decl_stmt|;
comment|/**< Fatal Error Detected                                                          Errors are logged in this register regardless of whether                                                           error reporting is enabled in the Device Control register.                                                          FE_D is set if receive any of the errors in PCIE_CFG066 that                                                          has a severity set to Fatal.  Malformed TLP's generally fit                                                          into this category. */
name|uint32_t
name|nfe_d
range|:
literal|1
decl_stmt|;
comment|/**< Non-Fatal Error detected                                                          Errors are logged in this register regardless of whether                                                           error reporting is enabled in the Device Control register.                                                          NFE_D is set if we receive any of the errors in PCIE_CFG066                                                          that has a severity set to Nonfatal and does NOT meet Advisory                                                          Nonfatal criteria , which                                                          most poisoned TLP's should be. */
name|uint32_t
name|ce_d
range|:
literal|1
decl_stmt|;
comment|/**< Correctable Error Detected                                                           Errors are logged in this register regardless of whether                                                           error reporting is enabled in the Device Control register.                                                          CE_D is set if we receive any of the errors in PCIE_CFG068                                                          for example a Replay Timer Timeout.  Also, it can be set if                                                          we get any of the errors in PCIE_CFG066 that has a severity                                                          set to Nonfatal and meets the Advisory Nonfatal criteria,                                                          which most ECRC errors should be. */
name|uint32_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrrs
range|:
literal|3
decl_stmt|;
comment|/**< Max Read Request Size                                                           0 = 128B                                                           1 = 256B                                                           2 = 512B                                                           3 = 1024B                                                           4 = 2048B                                                           5 = 4096B                                                          Note: SLI_S2M_PORT#_CTL[MRRS] and DPI_SLI_PRT#_CFG[MRRS] and                                                                also must be set properly.                                                                SLI_S2M_PORT#_CTL[MRRS] and DPI_SLI_PRT#_CFG[MRRS] must                                                                not exceed the desired max read request size. */
name|uint32_t
name|ns_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable No Snoop */
name|uint32_t
name|ap_en
range|:
literal|1
decl_stmt|;
comment|/**< AUX Power PM Enable */
name|uint32_t
name|pf_en
range|:
literal|1
decl_stmt|;
comment|/**< Phantom Function Enable                                                          This bit should never be set - OCTEON requests never use                                                          phantom functions. */
name|uint32_t
name|etf_en
range|:
literal|1
decl_stmt|;
comment|/**< Extended Tag Field Enable                                                          This bit should never be set - OCTEON requests never use                                                          extended tags. */
name|uint32_t
name|mps
range|:
literal|3
decl_stmt|;
comment|/**< Max Payload Size                                                           Legal values:                                                            0  = 128B                                                            1  = 256B                                                           Larger sizes not supported.                                                          Note: Both PCI Express Ports must be set to the same value                                                                for Peer-to-Peer to function properly.                                                          Note: DPI_SLI_PRT#_CFG[MPS] must also be set to the same                                                                value for proper functionality. */
name|uint32_t
name|ro_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable Relaxed Ordering */
name|uint32_t
name|ur_en
range|:
literal|1
decl_stmt|;
comment|/**< Unsupported Request Reporting Enable */
name|uint32_t
name|fe_en
range|:
literal|1
decl_stmt|;
comment|/**< Fatal Error Reporting Enable */
name|uint32_t
name|nfe_en
range|:
literal|1
decl_stmt|;
comment|/**< Non-Fatal Error Reporting Enable */
name|uint32_t
name|ce_en
range|:
literal|1
decl_stmt|;
comment|/**< Correctable Error Reporting Enable */
else|#
directive|else
name|uint32_t
name|ce_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nfe_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fe_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ur_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ro_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mps
range|:
literal|3
decl_stmt|;
name|uint32_t
name|etf_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pf_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ns_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrrs
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ce_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nfe_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fe_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ur_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_22_31
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg030_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg030_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg030_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg030_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg030_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg030_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg030
name|cvmx_pciercx_cfg030_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg031  *  * PCIE_CFG031 = Thirty-second 32-bits of PCIE type 1 config space  * (Link Capabilities Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg031
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg031_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pnum
range|:
literal|8
decl_stmt|;
comment|/**< Port Number, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint32_t
name|lbnc
range|:
literal|1
decl_stmt|;
comment|/**< Link Bandwith Notification Capability */
name|uint32_t
name|dllarc
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Layer Active Reporting Capable                                                          Set to 1 for Root Complex devices and 0 for Endpoint devices. */
name|uint32_t
name|sderc
range|:
literal|1
decl_stmt|;
comment|/**< Surprise Down Error Reporting Capable                                                          Not supported, hardwired to 0x0. */
name|uint32_t
name|cpm
range|:
literal|1
decl_stmt|;
comment|/**< Clock Power Management                                                          The default value is the value you specify during hardware                                                          configuration, writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|l1el
range|:
literal|3
decl_stmt|;
comment|/**< L1 Exit Latency                                                          The default value is the value you specify during hardware                                                          configuration, writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|l0el
range|:
literal|3
decl_stmt|;
comment|/**< L0s Exit Latency                                                          The default value is the value you specify during hardware                                                          configuration, writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|aslpms
range|:
literal|2
decl_stmt|;
comment|/**< Active State Link PM Support                                                          The default value is the value you specify during hardware                                                          configuration, writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|mlw
range|:
literal|6
decl_stmt|;
comment|/**< Maximum Link Width                                                          The default value is the value you specify during hardware                                                          configuration (x1, x4, x8, or x16), writable through PEM(0..1)_CFG_WR. */
name|uint32_t
name|mls
range|:
literal|4
decl_stmt|;
comment|/**< Maximum Link Speed                                                          The following values are accepted:                                                          0001b: 2.5 GHz supported                                                          0010b: 5.0 GHz and 2.5 GHz supported                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|mls
range|:
literal|4
decl_stmt|;
name|uint32_t
name|mlw
range|:
literal|6
decl_stmt|;
name|uint32_t
name|aslpms
range|:
literal|2
decl_stmt|;
name|uint32_t
name|l0el
range|:
literal|3
decl_stmt|;
name|uint32_t
name|l1el
range|:
literal|3
decl_stmt|;
name|uint32_t
name|cpm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sderc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dllarc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lbnc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pnum
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg031_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg031_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg031_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg031_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg031_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg031_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg031
name|cvmx_pciercx_cfg031_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg032  *  * PCIE_CFG032 = Thirty-third 32-bits of PCIE type 1 config space  * (Link Control Register/Link Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg032
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg032_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lab
range|:
literal|1
decl_stmt|;
comment|/**< Link Autonomous Bandwidth Status */
name|uint32_t
name|lbm
range|:
literal|1
decl_stmt|;
comment|/**< Link Bandwidth Management Status */
name|uint32_t
name|dlla
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Layer Active */
name|uint32_t
name|scc
range|:
literal|1
decl_stmt|;
comment|/**< Slot Clock Configuration                                                          Indicates that the component uses the same physical reference                                                          clock that the platform provides on the connector. The default                                                          value is the value you select during hardware configuration,                                                          writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|lt
range|:
literal|1
decl_stmt|;
comment|/**< Link Training */
name|uint32_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nlw
range|:
literal|6
decl_stmt|;
comment|/**< Negotiated Link Width                                                          Set automatically by hardware after Link initialization. */
name|uint32_t
name|ls
range|:
literal|4
decl_stmt|;
comment|/**< Link Speed                                                          The negotiated Link speed: 2.5 Gbps */
name|uint32_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint32_t
name|lab_int_enb
range|:
literal|1
decl_stmt|;
comment|/**< Link Autonomous Bandwidth Interrupt Enable                                                          This interrupt is for Gen2 and is not supported. This bit should                                                          always be written to zero. */
name|uint32_t
name|lbm_int_enb
range|:
literal|1
decl_stmt|;
comment|/**< Link Bandwidth Management Interrupt Enable                                                          This interrupt is for Gen2 and is not supported. This bit should                                                          always be written to zero. */
name|uint32_t
name|hawd
range|:
literal|1
decl_stmt|;
comment|/**< Hardware Autonomous Width Disable                                                          (Not Supported) */
name|uint32_t
name|ecpm
range|:
literal|1
decl_stmt|;
comment|/**< Enable Clock Power Management                                                          Hardwired to 0 if Clock Power Management is disabled in                                                          the Link Capabilities register. */
name|uint32_t
name|es
range|:
literal|1
decl_stmt|;
comment|/**< Extended Synch */
name|uint32_t
name|ccc
range|:
literal|1
decl_stmt|;
comment|/**< Common Clock Configuration */
name|uint32_t
name|rl
range|:
literal|1
decl_stmt|;
comment|/**< Retrain Link */
name|uint32_t
name|ld
range|:
literal|1
decl_stmt|;
comment|/**< Link Disable */
name|uint32_t
name|rcb
range|:
literal|1
decl_stmt|;
comment|/**< Read Completion Boundary (RCB), writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field                                                          because an RCB of 64 bytes is not supported. */
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|aslpc
range|:
literal|2
decl_stmt|;
comment|/**< Active State Link PM Control */
else|#
directive|else
name|uint32_t
name|aslpc
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rcb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ld
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ccc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|es
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ecpm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hawd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lbm_int_enb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lab_int_enb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ls
range|:
literal|4
decl_stmt|;
name|uint32_t
name|nlw
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dlla
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lbm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lab
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg032_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg032_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg032_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg032_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg032_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg032_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg032
name|cvmx_pciercx_cfg032_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg033  *  * PCIE_CFG033 = Thirty-fourth 32-bits of PCIE type 1 config space  * (Slot Capabilities Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg033
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg033_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|ps_num
range|:
literal|13
decl_stmt|;
comment|/**< Physical Slot Number, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|nccs
range|:
literal|1
decl_stmt|;
comment|/**< No Command Complete Support, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|emip
range|:
literal|1
decl_stmt|;
comment|/**< Electromechanical Interlock Present, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|sp_ls
range|:
literal|2
decl_stmt|;
comment|/**< Slot Power Limit Scale, writable through PEM(0..1)_CFG_WR. */
name|uint32_t
name|sp_lv
range|:
literal|8
decl_stmt|;
comment|/**< Slot Power Limit Value, writable through PEM(0..1)_CFG_WR. */
name|uint32_t
name|hp_c
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Capable, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|hp_s
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Surprise, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|pip
range|:
literal|1
decl_stmt|;
comment|/**< Power Indicator Present, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|aip
range|:
literal|1
decl_stmt|;
comment|/**< Attention Indicator Present, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|mrlsp
range|:
literal|1
decl_stmt|;
comment|/**< MRL Sensor Present, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|pcp
range|:
literal|1
decl_stmt|;
comment|/**< Power Controller Present, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
name|uint32_t
name|abp
range|:
literal|1
decl_stmt|;
comment|/**< Attention Button Present, writable through PEM(0..1)_CFG_WR                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|abp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pcp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrlsp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|aip
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pip
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hp_s
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hp_c
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sp_lv
range|:
literal|8
decl_stmt|;
name|uint32_t
name|sp_ls
range|:
literal|2
decl_stmt|;
name|uint32_t
name|emip
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nccs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ps_num
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg033_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg033_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg033_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg033_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg033_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg033_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg033
name|cvmx_pciercx_cfg033_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg034  *  * PCIE_CFG034 = Thirty-fifth 32-bits of PCIE type 1 config space  * (Slot Control Register/Slot Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg034
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg034_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint32_t
name|dlls_c
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Layer State Changed */
name|uint32_t
name|emis
range|:
literal|1
decl_stmt|;
comment|/**< Electromechanical Interlock Status */
name|uint32_t
name|pds
range|:
literal|1
decl_stmt|;
comment|/**< Presence Detect State */
name|uint32_t
name|mrlss
range|:
literal|1
decl_stmt|;
comment|/**< MRL Sensor State */
name|uint32_t
name|ccint_d
range|:
literal|1
decl_stmt|;
comment|/**< Command Completed */
name|uint32_t
name|pd_c
range|:
literal|1
decl_stmt|;
comment|/**< Presence Detect Changed */
name|uint32_t
name|mrls_c
range|:
literal|1
decl_stmt|;
comment|/**< MRL Sensor Changed */
name|uint32_t
name|pf_d
range|:
literal|1
decl_stmt|;
comment|/**< Power Fault Detected */
name|uint32_t
name|abp_d
range|:
literal|1
decl_stmt|;
comment|/**< Attention Button Pressed */
name|uint32_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint32_t
name|dlls_en
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Layer State Changed Enable */
name|uint32_t
name|emic
range|:
literal|1
decl_stmt|;
comment|/**< Electromechanical Interlock Control */
name|uint32_t
name|pcc
range|:
literal|1
decl_stmt|;
comment|/**< Power Controller Control */
name|uint32_t
name|pic
range|:
literal|2
decl_stmt|;
comment|/**< Power Indicator Control */
name|uint32_t
name|aic
range|:
literal|2
decl_stmt|;
comment|/**< Attention Indicator Control */
name|uint32_t
name|hpint_en
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt Enable */
name|uint32_t
name|ccint_en
range|:
literal|1
decl_stmt|;
comment|/**< Command Completed Interrupt Enable */
name|uint32_t
name|pd_en
range|:
literal|1
decl_stmt|;
comment|/**< Presence Detect Changed Enable */
name|uint32_t
name|mrls_en
range|:
literal|1
decl_stmt|;
comment|/**< MRL Sensor Changed Enable */
name|uint32_t
name|pf_en
range|:
literal|1
decl_stmt|;
comment|/**< Power Fault Detected Enable */
name|uint32_t
name|abp_en
range|:
literal|1
decl_stmt|;
comment|/**< Attention Button Pressed Enable */
else|#
directive|else
name|uint32_t
name|abp_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pf_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrls_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pd_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ccint_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hpint_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|aic
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pic
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pcc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|emic
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dlls_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint32_t
name|abp_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pf_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrls_c
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pd_c
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ccint_d
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrlss
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pds
range|:
literal|1
decl_stmt|;
name|uint32_t
name|emis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dlls_c
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg034_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg034_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg034_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg034_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg034_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg034_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg034
name|cvmx_pciercx_cfg034_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg035  *  * PCIE_CFG035 = Thirty-sixth 32-bits of PCIE type 1 config space  * (Root Control Register/Root Capabilities Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg035
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg035_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint32_t
name|crssv
range|:
literal|1
decl_stmt|;
comment|/**< CRS Software Visibility                                                          Not supported, hardwired to 0x0. */
name|uint32_t
name|reserved_5_15
range|:
literal|11
decl_stmt|;
name|uint32_t
name|crssve
range|:
literal|1
decl_stmt|;
comment|/**< CRS Software Visibility Enable                                                          Not supported, hardwired to 0x0. */
name|uint32_t
name|pmeie
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt Enable */
name|uint32_t
name|sefee
range|:
literal|1
decl_stmt|;
comment|/**< System Error on Fatal Error Enable */
name|uint32_t
name|senfee
range|:
literal|1
decl_stmt|;
comment|/**< System Error on Non-fatal Error Enable */
name|uint32_t
name|secee
range|:
literal|1
decl_stmt|;
comment|/**< System Error on Correctable Error Enable */
else|#
directive|else
name|uint32_t
name|secee
range|:
literal|1
decl_stmt|;
name|uint32_t
name|senfee
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sefee
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmeie
range|:
literal|1
decl_stmt|;
name|uint32_t
name|crssve
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_15
range|:
literal|11
decl_stmt|;
name|uint32_t
name|crssv
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg035_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg035_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg035_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg035_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg035_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg035_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg035
name|cvmx_pciercx_cfg035_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg036  *  * PCIE_CFG036 = Thirty-seventh 32-bits of PCIE type 1 config space  * (Root Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg036
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg036_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint32_t
name|pme_pend
range|:
literal|1
decl_stmt|;
comment|/**< PME Pending */
name|uint32_t
name|pme_stat
range|:
literal|1
decl_stmt|;
comment|/**< PME Status */
name|uint32_t
name|pme_rid
range|:
literal|16
decl_stmt|;
comment|/**< PME Requester ID */
else|#
directive|else
name|uint32_t
name|pme_rid
range|:
literal|16
decl_stmt|;
name|uint32_t
name|pme_stat
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pme_pend
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg036_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg036_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg036_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg036_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg036_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg036_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg036
name|cvmx_pciercx_cfg036_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg037  *  * PCIE_CFG037 = Thirty-eighth 32-bits of PCIE type 1 config space  * (Device Capabilities 2 Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg037
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg037_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
name|uint32_t
name|ctds
range|:
literal|1
decl_stmt|;
comment|/**< Completion Timeout Disable Supported */
name|uint32_t
name|ctrs
range|:
literal|4
decl_stmt|;
comment|/**< Completion Timeout Ranges Supported                                                          Value of 0 indicates that Completion Timeout Programming                                                          is not supported                                                          Completion timeout is 16.7ms. */
else|#
directive|else
name|uint32_t
name|ctrs
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ctds
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg037_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg037_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg037_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg037_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg037_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg037_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg037
name|cvmx_pciercx_cfg037_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg038  *  * PCIE_CFG038 = Thirty-ninth 32-bits of PCIE type 1 config space  * (Device Control 2 Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg038
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg038_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
name|uint32_t
name|ctd
range|:
literal|1
decl_stmt|;
comment|/**< Completion Timeout Disable */
name|uint32_t
name|ctv
range|:
literal|4
decl_stmt|;
comment|/**< Completion Timeout Value                                                          Completion Timeout Programming is not supported                                                          Completion timeout is 16.7ms. */
else|#
directive|else
name|uint32_t
name|ctv
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ctd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg038_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg038_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg038_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg038_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg038_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg038_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg038
name|cvmx_pciercx_cfg038_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg039  *  * PCIE_CFG039 = Fourtieth 32-bits of PCIE type 1 config space  * (Link Capabilities 2 Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg039
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg039_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg039_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg039_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg039_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg039_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg039_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg039_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg039
name|cvmx_pciercx_cfg039_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg040  *  * PCIE_CFG040 = Fourty-first 32-bits of PCIE type 1 config space  * (Link Control 2 Register/Link Status 2 Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg040
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg040_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint32_t
name|cdl
range|:
literal|1
decl_stmt|;
comment|/**< Current De-emphasis Level                                                          When the Link is operating at 5 GT/s speed, this bit                                                          reflects the level of de-emphasis. Encodings:                                                           1b: -3.5 dB                                                           0b: -6 dB                                                          Note: The value in this bit is undefined when the Link is                                                          operating at 2.5 GT/s speed */
name|uint32_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint32_t
name|cde
range|:
literal|1
decl_stmt|;
comment|/**< Compliance De-emphasis                                                          This bit sets the de-emphasis level in Polling. Compliance                                                          state if the entry occurred due to the Tx Compliance                                                          Receive bit being 1b. Encodings:                                                           1b: -3.5 dB                                                           0b: -6 dB                                                          Note: When the Link is operating at 2.5 GT/s, the setting                                                          of this bit has no effect. */
name|uint32_t
name|csos
range|:
literal|1
decl_stmt|;
comment|/**< Compliance SOS                                                          When set to 1b, the LTSSM is required to send SKP                                                          Ordered Sets periodically in between the (modified)                                                          compliance patterns.                                                          Note: When the Link is operating at 2.5 GT/s, the setting                                                          of this bit has no effect. */
name|uint32_t
name|emc
range|:
literal|1
decl_stmt|;
comment|/**< Enter Modified Compliance                                                          When this bit is set to 1b, the device transmits a modified                                                          compliance pattern if the LTSSM enters Polling.                                                          Compliance state. */
name|uint32_t
name|tm
range|:
literal|3
decl_stmt|;
comment|/**< Transmit Margin                                                          This field controls the value of the non-de-emphasized                                                          voltage level at the Transmitter pins:                                                           - 000: 800-1200 mV for full swing 400-600 mV for half-swing                                                           - 001-010: values must be monotonic with a non-zero slope                                                           - 011: 200-400 mV for full-swing and 100-200 mV for halfswing                                                           - 100-111: reserved                                                          This field is reset to 000b on entry to the LTSSM Polling.                                                          Compliance substate.                                                          When operating in 5.0 GT/s mode with full swing, the                                                          de-emphasis ratio must be maintained within +/- 1 dB                                                          from the specification-defined operational value                                                          either -3.5 or -6 dB). */
name|uint32_t
name|sde
range|:
literal|1
decl_stmt|;
comment|/**< Selectable De-emphasis                                                          When the Link is operating at 5.0 GT/s speed, selects the                                                          level of de-emphasis:                                                          - 1: -3.5 dB                                                          - 0: -6 dB                                                          When the Link is operating at 2.5 GT/s speed, the setting                                                          of this bit has no effect. */
name|uint32_t
name|hasd
range|:
literal|1
decl_stmt|;
comment|/**< Hardware Autonomous Speed Disable                                                          When asserted, the                                                          application must disable hardware from changing the Link                                                          speed for device-specific reasons other than attempting to                                                          correct unreliable Link operation by reducing Link speed.                                                          Initial transition to the highest supported common link                                                          speed is not blocked by this signal. */
name|uint32_t
name|ec
range|:
literal|1
decl_stmt|;
comment|/**< Enter Compliance                                                          Software is permitted to force a link to enter Compliance                                                          mode at the speed indicated in the Target Link Speed                                                          field by setting this bit to 1b in both components on a link                                                          and then initiating a hot reset on the link. */
name|uint32_t
name|tls
range|:
literal|4
decl_stmt|;
comment|/**< Target Link Speed                                                          For Downstream ports, this field sets an upper limit on link                                                          operational speed by restricting the values advertised by                                                          the upstream component in its training sequences:                                                            - 0001: 2.5Gb/s Target Link Speed                                                            - 0010: 5Gb/s Target Link Speed                                                          All other encodings are reserved.                                                          If a value is written to this field that does not correspond to                                                          a speed included in the Supported Link Speeds field, the                                                          result is undefined.                                                          For both Upstream and Downstream ports, this field is                                                          used to set the target compliance mode speed when                                                          software is using the Enter Compliance bit to force a link                                                          into compliance mode.                                                          Out of reset this will have a value of 1 or 2 which is                                                          selected by qlmCfgx[1]. */
else|#
directive|else
name|uint32_t
name|tls
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ec
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hasd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sde
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tm
range|:
literal|3
decl_stmt|;
name|uint32_t
name|emc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|csos
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cde
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint32_t
name|cdl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pciercx_cfg040_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pciercx_cfg040_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg040_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg040_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg040_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg040_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg040
name|cvmx_pciercx_cfg040_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg041  *  * PCIE_CFG041 = Fourty-second 32-bits of PCIE type 1 config space  * (Slot Capabilities 2 Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg041
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg041_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg041_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg041_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg041_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg041_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg041_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg041_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg041
name|cvmx_pciercx_cfg041_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg042  *  * PCIE_CFG042 = Fourty-third 32-bits of PCIE type 1 config space  * (Slot Control 2 Register/Slot Status 2 Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg042
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg042_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg042_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg042_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg042_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg042_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg042_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg042_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg042
name|cvmx_pciercx_cfg042_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg064  *  * PCIE_CFG064 = Sixty-fifth 32-bits of PCIE type 1 config space  * (PCI Express Enhanced Capability Header)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg064
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg064_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|nco
range|:
literal|12
decl_stmt|;
comment|/**< Next Capability Offset */
name|uint32_t
name|cv
range|:
literal|4
decl_stmt|;
comment|/**< Capability Version */
name|uint32_t
name|pcieec
range|:
literal|16
decl_stmt|;
comment|/**< PCIE Express Extended Capability */
else|#
directive|else
name|uint32_t
name|pcieec
range|:
literal|16
decl_stmt|;
name|uint32_t
name|cv
range|:
literal|4
decl_stmt|;
name|uint32_t
name|nco
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg064_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg064_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg064_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg064_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg064_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg064_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg064
name|cvmx_pciercx_cfg064_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg065  *  * PCIE_CFG065 = Sixty-sixth 32-bits of PCIE type 1 config space  * (Uncorrectable Error Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg065
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg065_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|ures
range|:
literal|1
decl_stmt|;
comment|/**< Unsupported Request Error Status */
name|uint32_t
name|ecrces
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Error Status */
name|uint32_t
name|mtlps
range|:
literal|1
decl_stmt|;
comment|/**< Malformed TLP Status */
name|uint32_t
name|ros
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Overflow Status */
name|uint32_t
name|ucs
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Completion Status */
name|uint32_t
name|cas
range|:
literal|1
decl_stmt|;
comment|/**< Completer Abort Status */
name|uint32_t
name|cts
range|:
literal|1
decl_stmt|;
comment|/**< Completion Timeout Status */
name|uint32_t
name|fcpes
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Protocol Error Status */
name|uint32_t
name|ptlps
range|:
literal|1
decl_stmt|;
comment|/**< Poisoned TLP Status */
name|uint32_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint32_t
name|sdes
range|:
literal|1
decl_stmt|;
comment|/**< Surprise Down Error Status (not supported) */
name|uint32_t
name|dlpes
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Protocol Error Status */
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dlpes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sdes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint32_t
name|ptlps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fcpes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cas
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ucs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ros
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mtlps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ecrces
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ures
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg065_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg065_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg065_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg065_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg065_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg065_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg065
name|cvmx_pciercx_cfg065_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg066  *  * PCIE_CFG066 = Sixty-seventh 32-bits of PCIE type 1 config space  * (Uncorrectable Error Mask Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg066
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg066_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|urem
range|:
literal|1
decl_stmt|;
comment|/**< Unsupported Request Error Mask */
name|uint32_t
name|ecrcem
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Error Mask */
name|uint32_t
name|mtlpm
range|:
literal|1
decl_stmt|;
comment|/**< Malformed TLP Mask */
name|uint32_t
name|rom
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Overflow Mask */
name|uint32_t
name|ucm
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Completion Mask */
name|uint32_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< Completer Abort Mask */
name|uint32_t
name|ctm
range|:
literal|1
decl_stmt|;
comment|/**< Completion Timeout Mask */
name|uint32_t
name|fcpem
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Protocol Error Mask */
name|uint32_t
name|ptlpm
range|:
literal|1
decl_stmt|;
comment|/**< Poisoned TLP Mask */
name|uint32_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint32_t
name|sdem
range|:
literal|1
decl_stmt|;
comment|/**< Surprise Down Error Mask (not supported) */
name|uint32_t
name|dlpem
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Protocol Error Mask */
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dlpem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sdem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint32_t
name|ptlpm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fcpem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ctm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ucm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rom
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mtlpm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ecrcem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|urem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg066_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg066_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg066_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg066_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg066_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg066_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg066
name|cvmx_pciercx_cfg066_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg067  *  * PCIE_CFG067 = Sixty-eighth 32-bits of PCIE type 1 config space  * (Uncorrectable Error Severity Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg067
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg067_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|ures
range|:
literal|1
decl_stmt|;
comment|/**< Unsupported Request Error Severity */
name|uint32_t
name|ecrces
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Error Severity */
name|uint32_t
name|mtlps
range|:
literal|1
decl_stmt|;
comment|/**< Malformed TLP Severity */
name|uint32_t
name|ros
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Overflow Severity */
name|uint32_t
name|ucs
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Completion Severity */
name|uint32_t
name|cas
range|:
literal|1
decl_stmt|;
comment|/**< Completer Abort Severity */
name|uint32_t
name|cts
range|:
literal|1
decl_stmt|;
comment|/**< Completion Timeout Severity */
name|uint32_t
name|fcpes
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Protocol Error Severity */
name|uint32_t
name|ptlps
range|:
literal|1
decl_stmt|;
comment|/**< Poisoned TLP Severity */
name|uint32_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint32_t
name|sdes
range|:
literal|1
decl_stmt|;
comment|/**< Surprise Down Error Severity (not supported) */
name|uint32_t
name|dlpes
range|:
literal|1
decl_stmt|;
comment|/**< Data Link Protocol Error Severity */
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dlpes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sdes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint32_t
name|ptlps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fcpes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cas
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ucs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ros
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mtlps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ecrces
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ures
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg067_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg067_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg067_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg067_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg067_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg067_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg067
name|cvmx_pciercx_cfg067_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg068  *  * PCIE_CFG068 = Sixty-ninth 32-bits of PCIE type 1 config space  * (Correctable Error Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg068
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg068_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_14_31
range|:
literal|18
decl_stmt|;
name|uint32_t
name|anfes
range|:
literal|1
decl_stmt|;
comment|/**< Advisory Non-Fatal Error Status */
name|uint32_t
name|rtts
range|:
literal|1
decl_stmt|;
comment|/**< Replay Timer Timeout Status */
name|uint32_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint32_t
name|rnrs
range|:
literal|1
decl_stmt|;
comment|/**< REPLAY_NUM Rollover Status */
name|uint32_t
name|bdllps
range|:
literal|1
decl_stmt|;
comment|/**< Bad DLLP Status */
name|uint32_t
name|btlps
range|:
literal|1
decl_stmt|;
comment|/**< Bad TLP Status */
name|uint32_t
name|reserved_1_5
range|:
literal|5
decl_stmt|;
name|uint32_t
name|res
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Error Status */
else|#
directive|else
name|uint32_t
name|res
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_5
range|:
literal|5
decl_stmt|;
name|uint32_t
name|btlps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bdllps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rnrs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint32_t
name|rtts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|anfes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_14_31
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg068_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg068_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg068_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg068_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg068_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg068_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg068
name|cvmx_pciercx_cfg068_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg069  *  * PCIE_CFG069 = Seventieth 32-bits of PCIE type 1 config space  * (Correctable Error Mask Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg069
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg069_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_14_31
range|:
literal|18
decl_stmt|;
name|uint32_t
name|anfem
range|:
literal|1
decl_stmt|;
comment|/**< Advisory Non-Fatal Error Mask */
name|uint32_t
name|rttm
range|:
literal|1
decl_stmt|;
comment|/**< Replay Timer Timeout Mask */
name|uint32_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint32_t
name|rnrm
range|:
literal|1
decl_stmt|;
comment|/**< REPLAY_NUM Rollover Mask */
name|uint32_t
name|bdllpm
range|:
literal|1
decl_stmt|;
comment|/**< Bad DLLP Mask */
name|uint32_t
name|btlpm
range|:
literal|1
decl_stmt|;
comment|/**< Bad TLP Mask */
name|uint32_t
name|reserved_1_5
range|:
literal|5
decl_stmt|;
name|uint32_t
name|rem
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Error Mask */
else|#
directive|else
name|uint32_t
name|rem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_5
range|:
literal|5
decl_stmt|;
name|uint32_t
name|btlpm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bdllpm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rnrm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint32_t
name|rttm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|anfem
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_14_31
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg069_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg069_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg069_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg069_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg069_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg069_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg069
name|cvmx_pciercx_cfg069_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg070  *  * PCIE_CFG070 = Seventy-first 32-bits of PCIE type 1 config space  * (Advanced Capabilities and Control Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg070
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg070_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint32_t
name|ce
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Check Enable */
name|uint32_t
name|cc
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Check Capable */
name|uint32_t
name|ge
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Generation Enable */
name|uint32_t
name|gc
range|:
literal|1
decl_stmt|;
comment|/**< ECRC Generation Capability */
name|uint32_t
name|fep
range|:
literal|5
decl_stmt|;
comment|/**< First Error Pointer */
else|#
directive|else
name|uint32_t
name|fep
range|:
literal|5
decl_stmt|;
name|uint32_t
name|gc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ge
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ce
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg070_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg070_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg070_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg070_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg070_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg070_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg070
name|cvmx_pciercx_cfg070_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg071  *  * PCIE_CFG071 = Seventy-second 32-bits of PCIE type 1 config space  *                  (Header Log Register 1)  *  * The Header Log registers collect the header for the TLP corresponding to a detected error.  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg071
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg071_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dword1
range|:
literal|32
decl_stmt|;
comment|/**< Header Log Register (first DWORD) */
else|#
directive|else
name|uint32_t
name|dword1
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg071_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg071_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg071_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg071_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg071_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg071_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg071
name|cvmx_pciercx_cfg071_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg072  *  * PCIE_CFG072 = Seventy-third 32-bits of PCIE type 1 config space  *                  (Header Log Register 2)  *  * The Header Log registers collect the header for the TLP corresponding to a detected error.  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg072
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg072_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dword2
range|:
literal|32
decl_stmt|;
comment|/**< Header Log Register (second DWORD) */
else|#
directive|else
name|uint32_t
name|dword2
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg072_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg072_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg072_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg072_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg072_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg072_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg072
name|cvmx_pciercx_cfg072_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg073  *  * PCIE_CFG073 = Seventy-fourth 32-bits of PCIE type 1 config space  *                  (Header Log Register 3)  *  * The Header Log registers collect the header for the TLP corresponding to a detected error.  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg073
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg073_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dword3
range|:
literal|32
decl_stmt|;
comment|/**< Header Log Register (third DWORD) */
else|#
directive|else
name|uint32_t
name|dword3
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg073_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg073_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg073_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg073_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg073_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg073_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg073
name|cvmx_pciercx_cfg073_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg074  *  * PCIE_CFG074 = Seventy-fifth 32-bits of PCIE type 1 config space  *                  (Header Log Register 4)  *  * The Header Log registers collect the header for the TLP corresponding to a detected error.  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg074
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg074_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dword4
range|:
literal|32
decl_stmt|;
comment|/**< Header Log Register (fourth DWORD) */
else|#
directive|else
name|uint32_t
name|dword4
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg074_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg074_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg074_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg074_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg074_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg074_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg074
name|cvmx_pciercx_cfg074_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg075  *  * PCIE_CFG075 = Seventy-sixth 32-bits of PCIE type 1 config space  * (Root Error Command Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg075
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg075_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint32_t
name|fere
range|:
literal|1
decl_stmt|;
comment|/**< Fatal Error Reporting Enable */
name|uint32_t
name|nfere
range|:
literal|1
decl_stmt|;
comment|/**< Non-Fatal Error Reporting Enable */
name|uint32_t
name|cere
range|:
literal|1
decl_stmt|;
comment|/**< Correctable Error Reporting Enable */
else|#
directive|else
name|uint32_t
name|cere
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nfere
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fere
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg075_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg075_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg075_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg075_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg075_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg075_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg075
name|cvmx_pciercx_cfg075_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg076  *  * PCIE_CFG076 = Seventy-seventh 32-bits of PCIE type 1 config space  * (Root Error Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg076
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg076_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|aeimn
range|:
literal|5
decl_stmt|;
comment|/**< Advanced Error Interrupt Message Number,                                                          writable through PEM(0..1)_CFG_WR */
name|uint32_t
name|reserved_7_26
range|:
literal|20
decl_stmt|;
name|uint32_t
name|femr
range|:
literal|1
decl_stmt|;
comment|/**< Fatal Error Messages Received */
name|uint32_t
name|nfemr
range|:
literal|1
decl_stmt|;
comment|/**< Non-Fatal Error Messages Received */
name|uint32_t
name|fuf
range|:
literal|1
decl_stmt|;
comment|/**< First Uncorrectable Fatal */
name|uint32_t
name|multi_efnfr
range|:
literal|1
decl_stmt|;
comment|/**< Multiple ERR_FATAL/NONFATAL Received */
name|uint32_t
name|efnfr
range|:
literal|1
decl_stmt|;
comment|/**< ERR_FATAL/NONFATAL Received */
name|uint32_t
name|multi_ecr
range|:
literal|1
decl_stmt|;
comment|/**< Multiple ERR_COR Received */
name|uint32_t
name|ecr
range|:
literal|1
decl_stmt|;
comment|/**< ERR_COR Received */
else|#
directive|else
name|uint32_t
name|ecr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|multi_ecr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|efnfr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|multi_efnfr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fuf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nfemr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|femr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_7_26
range|:
literal|20
decl_stmt|;
name|uint32_t
name|aeimn
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg076_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg076_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg076_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg076_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg076_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg076_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg076
name|cvmx_pciercx_cfg076_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg077  *  * PCIE_CFG077 = Seventy-eighth 32-bits of PCIE type 1 config space  * (Error Source Identification Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg077
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg077_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|efnfsi
range|:
literal|16
decl_stmt|;
comment|/**< ERR_FATAL/NONFATAL Source Identification */
name|uint32_t
name|ecsi
range|:
literal|16
decl_stmt|;
comment|/**< ERR_COR Source Identification */
else|#
directive|else
name|uint32_t
name|ecsi
range|:
literal|16
decl_stmt|;
name|uint32_t
name|efnfsi
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg077_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg077_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg077_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg077_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg077_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg077_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg077
name|cvmx_pciercx_cfg077_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg448  *  * PCIE_CFG448 = Four hundred forty-ninth 32-bits of PCIE type 1 config space  * (Ack Latency Timer and Replay Timer Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg448
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg448_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|rtl
range|:
literal|16
decl_stmt|;
comment|/**< Replay Time Limit                                                          The replay timer expires when it reaches this limit. The PCI                                                          Express bus initiates a replay upon reception of a Nak or when                                                          the replay timer expires.                                                          The default is then updated based on the Negotiated Link Width                                                          and Max_Payload_Size. */
name|uint32_t
name|rtltl
range|:
literal|16
decl_stmt|;
comment|/**< Round Trip Latency Time Limit                                                          The Ack/Nak latency timer expires when it reaches this limit.                                                          The default is then updated based on the Negotiated Link Width                                                          and Max_Payload_Size. */
else|#
directive|else
name|uint32_t
name|rtltl
range|:
literal|16
decl_stmt|;
name|uint32_t
name|rtl
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg448_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg448_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg448_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg448_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg448_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg448_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg448
name|cvmx_pciercx_cfg448_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg449  *  * PCIE_CFG449 = Four hundred fiftieth 32-bits of PCIE type 1 config space  * (Other Message Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg449
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg449_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|omr
range|:
literal|32
decl_stmt|;
comment|/**< Other Message Register                                                          This register can be used for either of the following purposes:                                                          o To send a specific PCI Express Message, the application                                                            writes the payload of the Message into this register, then                                                            sets bit 0 of the Port Link Control Register to send the                                                            Message.                                                          o To store a corruption pattern for corrupting the LCRC on all                                                            TLPs, the application places a 32-bit corruption pattern into                                                            this register and enables this function by setting bit 25 of                                                            the Port Link Control Register. When enabled, the transmit                                                            LCRC result is XOR'd with this pattern before inserting                                                            it into the packet. */
else|#
directive|else
name|uint32_t
name|omr
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg449_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg449_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg449_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg449_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg449_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg449_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg449
name|cvmx_pciercx_cfg449_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg450  *  * PCIE_CFG450 = Four hundred fifty-first 32-bits of PCIE type 1 config space  * (Port Force Link Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg450
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg450_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lpec
range|:
literal|8
decl_stmt|;
comment|/**< Low Power Entrance Count                                                          The Power Management state will wait for this many clock cycles                                                          for the associated completion of a CfgWr to PCIE_CFG017 register                                                          Power State (PS) field register to go low-power. This register                                                          is intended for applications that do not let the PCI Express                                                          bus handle a completion for configuration request to the                                                          Power Management Control and Status (PCIE_CFG017) register. */
name|uint32_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint32_t
name|link_state
range|:
literal|6
decl_stmt|;
comment|/**< Link State                                                          The Link state that the PCI Express Bus will be forced to                                                          when bit 15 (Force Link) is set.                                                          State encoding:                                                          o DETECT_QUIET              00h                                                          o DETECT_ACT                01h                                                          o POLL_ACTIVE               02h                                                          o POLL_COMPLIANCE           03h                                                          o POLL_CONFIG               04h                                                          o PRE_DETECT_QUIET          05h                                                          o DETECT_WAIT               06h                                                          o CFG_LINKWD_START          07h                                                          o CFG_LINKWD_ACEPT          08h                                                          o CFG_LANENUM_WAIT          09h                                                          o CFG_LANENUM_ACEPT         0Ah                                                          o CFG_COMPLETE              0Bh                                                          o CFG_IDLE                  0Ch                                                          o RCVRY_LOCK                0Dh                                                          o RCVRY_SPEED               0Eh                                                          o RCVRY_RCVRCFG             0Fh                                                          o RCVRY_IDLE                10h                                                          o L0                        11h                                                          o L0S                       12h                                                          o L123_SEND_EIDLE           13h                                                          o L1_IDLE                   14h                                                          o L2_IDLE                   15h                                                          o L2_WAKE                   16h                                                          o DISABLED_ENTRY            17h                                                          o DISABLED_IDLE             18h                                                          o DISABLED                  19h                                                          o LPBK_ENTRY                1Ah                                                          o LPBK_ACTIVE               1Bh                                                          o LPBK_EXIT                 1Ch                                                          o LPBK_EXIT_TIMEOUT         1Dh                                                          o HOT_RESET_ENTRY           1Eh                                                          o HOT_RESET                 1Fh */
name|uint32_t
name|force_link
range|:
literal|1
decl_stmt|;
comment|/**< Force Link                                                          Forces the Link to the state specified by the Link State field.                                                          The Force Link pulse will trigger Link re-negotiation.                                                          * As the The Force Link is a pulse, writing a 1 to it does                                                            trigger the forced link state event, even thought reading it                                                            always returns a 0. */
name|uint32_t
name|reserved_8_14
range|:
literal|7
decl_stmt|;
name|uint32_t
name|link_num
range|:
literal|8
decl_stmt|;
comment|/**< Link Number */
else|#
directive|else
name|uint32_t
name|link_num
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_8_14
range|:
literal|7
decl_stmt|;
name|uint32_t
name|force_link
range|:
literal|1
decl_stmt|;
name|uint32_t
name|link_state
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint32_t
name|lpec
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg450_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg450_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg450_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg450_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg450_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg450_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg450
name|cvmx_pciercx_cfg450_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg451  *  * PCIE_CFG451 = Four hundred fifty-second 32-bits of PCIE type 1 config space  * (Ack Frequency Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg451
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg451_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint32_t
name|l1el
range|:
literal|3
decl_stmt|;
comment|/**< L1 Entrance Latency                                                          Values correspond to:                                                          o 000: 1 ms                                                          o 001: 2 ms                                                          o 010: 4 ms                                                          o 011: 8 ms                                                          o 100: 16 ms                                                          o 101: 32 ms                                                          o 110 or 111: 64 ms */
name|uint32_t
name|l0el
range|:
literal|3
decl_stmt|;
comment|/**< L0s Entrance Latency                                                          Values correspond to:                                                          o 000: 1 ms                                                          o 001: 2 ms                                                          o 010: 3 ms                                                          o 011: 4 ms                                                          o 100: 5 ms                                                          o 101: 6 ms                                                          o 110 or 111: 7 ms */
name|uint32_t
name|n_fts_cc
range|:
literal|8
decl_stmt|;
comment|/**< N_FTS when common clock is used.                                                          The number of Fast Training Sequence ordered sets to be                                                          transmitted when transitioning from L0s to L0. The maximum                                                          number of FTS ordered-sets that a component can request is 255.                                                           Note: The core does not support a value of zero; a value of                                                                 zero can cause the LTSSM to go into the recovery state                                                                 when exiting from L0s. */
name|uint32_t
name|n_fts
range|:
literal|8
decl_stmt|;
comment|/**< N_FTS                                                          The number of Fast Training Sequence ordered sets to be                                                          transmitted when transitioning from L0s to L0. The maximum                                                          number of FTS ordered-sets that a component can request is 255.                                                          Note: The core does not support a value of zero; a value of                                                                zero can cause the LTSSM to go into the recovery state                                                                when exiting from L0s. */
name|uint32_t
name|ack_freq
range|:
literal|8
decl_stmt|;
comment|/**< Ack Frequency                                                          The number of pending Ack's specified here (up to 255) before                                                          sending an Ack. */
else|#
directive|else
name|uint32_t
name|ack_freq
range|:
literal|8
decl_stmt|;
name|uint32_t
name|n_fts
range|:
literal|8
decl_stmt|;
name|uint32_t
name|n_fts_cc
range|:
literal|8
decl_stmt|;
name|uint32_t
name|l0el
range|:
literal|3
decl_stmt|;
name|uint32_t
name|l1el
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg451_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg451_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg451_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg451_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg451_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg451_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg451
name|cvmx_pciercx_cfg451_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg452  *  * PCIE_CFG452 = Four hundred fifty-third 32-bits of PCIE type 1 config space  * (Port Link Control Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg452
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg452_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint32_t
name|eccrc
range|:
literal|1
decl_stmt|;
comment|/**< Enable Corrupted CRC                                                          Causes corrupt LCRC for TLPs when set,                                                          using the pattern contained in the Other Message register.                                                          This is a test feature, not to be used in normal operation. */
name|uint32_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint32_t
name|lme
range|:
literal|6
decl_stmt|;
comment|/**< Link Mode Enable                                                          o 000001: x1                                                          o 000011: x2                                                          o 000111: x4                                                          o 001111: x8  (not supported)                                                          o 011111: x16 (not supported)                                                          o 111111: x32 (not supported)                                                          This field indicates the MAXIMUM number of lanes supported                                                          by the PCIe port. The value can be set less than 0x7                                                          to limit the number of lanes the PCIe will attempt to use.                                                          The programming of this field needs to be done by SW BEFORE                                                          enabling the link. See also MLW.                                                          (Note: The value of this field does NOT indicate the number                                                           of lanes in use by the PCIe. LME sets the max number of lanes                                                           in the PCIe core that COULD be used. As per the PCIe specs,                                                           the PCIe core can negotiate a smaller link width, so all                                                           of x4, x2, and x1 are supported when LME=0x7,                                                           for example.) */
name|uint32_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint32_t
name|flm
range|:
literal|1
decl_stmt|;
comment|/**< Fast Link Mode                                                          Sets all internal timers to fast mode for simulation purposes. */
name|uint32_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dllle
range|:
literal|1
decl_stmt|;
comment|/**< DLL Link Enable                                                          Enables Link initialization. If DLL Link Enable = 0, the PCI                                                          Express bus does not transmit InitFC DLLPs and does not                                                          establish a Link. */
name|uint32_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ra
range|:
literal|1
decl_stmt|;
comment|/**< Reset Assert                                                          Triggers a recovery and forces the LTSSM to the Hot Reset                                                          state (downstream port only). */
name|uint32_t
name|le
range|:
literal|1
decl_stmt|;
comment|/**< Loopback Enable                                                          Initiate loopback mode as a master. On a 0->1 transition,                                                          the PCIe core sends TS ordered sets with the loopback bit set                                                          to cause the link partner to enter into loopback mode as a                                                          slave. Normal transmission is not possible when LE=1. To exit                                                          loopback mode, take the link through a reset sequence. */
name|uint32_t
name|sd
range|:
literal|1
decl_stmt|;
comment|/**< Scramble Disable                                                          Turns off data scrambling. */
name|uint32_t
name|omr
range|:
literal|1
decl_stmt|;
comment|/**< Other Message Request                                                          When software writes a `1' to this bit, the PCI Express bus                                                          transmits the Message contained in the Other Message register. */
else|#
directive|else
name|uint32_t
name|omr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|le
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ra
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dllle
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint32_t
name|flm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint32_t
name|lme
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint32_t
name|eccrc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg452_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg452_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg452_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg452_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg452_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg452_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg452
name|cvmx_pciercx_cfg452_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg453  *  * PCIE_CFG453 = Four hundred fifty-fourth 32-bits of PCIE type 1 config space  * (Lane Skew Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg453
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg453_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dlld
range|:
literal|1
decl_stmt|;
comment|/**< Disable Lane-to-Lane Deskew                                                          Disables the internal Lane-to-Lane deskew logic. */
name|uint32_t
name|reserved_26_30
range|:
literal|5
decl_stmt|;
name|uint32_t
name|ack_nak
range|:
literal|1
decl_stmt|;
comment|/**< Ack/Nak Disable                                                          Prevents the PCI Express bus from sending Ack and Nak DLLPs. */
name|uint32_t
name|fcd
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Disable                                                          Prevents the PCI Express bus from sending FC DLLPs. */
name|uint32_t
name|ilst
range|:
literal|24
decl_stmt|;
comment|/**< Insert Lane Skew for Transmit (not supported for x16)                                                          Causes skew between lanes for test purposes. There are three                                                          bits per Lane. The value is in units of one symbol time. For                                                          example, the value 010b for a Lane forces a skew of two symbol                                                          times for that Lane. The maximum skew value for any Lane is 5                                                          symbol times. */
else|#
directive|else
name|uint32_t
name|ilst
range|:
literal|24
decl_stmt|;
name|uint32_t
name|fcd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ack_nak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_26_30
range|:
literal|5
decl_stmt|;
name|uint32_t
name|dlld
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg453_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg453_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg453_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg453_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg453_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg453_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg453
name|cvmx_pciercx_cfg453_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg454  *  * PCIE_CFG454 = Four hundred fifty-fifth 32-bits of PCIE type 1 config space  * (Symbol Number Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg454
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg454_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint32_t
name|tmfcwt
range|:
literal|5
decl_stmt|;
comment|/**< Timer Modifier for Flow Control Watchdog Timer                                                          Increases the timer value for the Flow Control watchdog timer,                                                          in increments of 16 clock cycles. */
name|uint32_t
name|tmanlt
range|:
literal|5
decl_stmt|;
comment|/**< Timer Modifier for Ack/Nak Latency Timer                                                          Increases the timer value for the Ack/Nak latency timer, in                                                          increments of 64 clock cycles. */
name|uint32_t
name|tmrt
range|:
literal|5
decl_stmt|;
comment|/**< Timer Modifier for Replay Timer                                                          Increases the timer value for the replay timer, in increments                                                          of 64 clock cycles. */
name|uint32_t
name|reserved_11_13
range|:
literal|3
decl_stmt|;
name|uint32_t
name|nskps
range|:
literal|3
decl_stmt|;
comment|/**< Number of SKP Symbols */
name|uint32_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ntss
range|:
literal|4
decl_stmt|;
comment|/**< Number of TS Symbols                                                          Sets the number of TS identifier symbols that are sent in TS1                                                          and TS2 ordered sets. */
else|#
directive|else
name|uint32_t
name|ntss
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint32_t
name|nskps
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_11_13
range|:
literal|3
decl_stmt|;
name|uint32_t
name|tmrt
range|:
literal|5
decl_stmt|;
name|uint32_t
name|tmanlt
range|:
literal|5
decl_stmt|;
name|uint32_t
name|tmfcwt
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg454_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg454_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg454_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg454_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg454_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg454_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg454
name|cvmx_pciercx_cfg454_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg455  *  * PCIE_CFG455 = Four hundred fifty-sixth 32-bits of PCIE type 1 config space  * (Symbol Timer Register/Filter Mask Register 1)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg455
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg455_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|m_cfg0_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask filtering of received Configuration Requests (RC mode only) */
name|uint32_t
name|m_io_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask filtering of received I/O Requests (RC mode only) */
name|uint32_t
name|msg_ctrl
range|:
literal|1
decl_stmt|;
comment|/**< Message Control                                                          The application must not change this field. */
name|uint32_t
name|m_cpl_ecrc_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask ECRC error filtering for Completions */
name|uint32_t
name|m_ecrc_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask ECRC error filtering */
name|uint32_t
name|m_cpl_len_err
range|:
literal|1
decl_stmt|;
comment|/**< Mask Length mismatch error for received Completions */
name|uint32_t
name|m_cpl_attr_err
range|:
literal|1
decl_stmt|;
comment|/**< Mask Attributes mismatch error for received Completions */
name|uint32_t
name|m_cpl_tc_err
range|:
literal|1
decl_stmt|;
comment|/**< Mask Traffic Class mismatch error for received Completions */
name|uint32_t
name|m_cpl_fun_err
range|:
literal|1
decl_stmt|;
comment|/**< Mask function mismatch error for received Completions */
name|uint32_t
name|m_cpl_rid_err
range|:
literal|1
decl_stmt|;
comment|/**< Mask Requester ID mismatch error for received Completions */
name|uint32_t
name|m_cpl_tag_err
range|:
literal|1
decl_stmt|;
comment|/**< Mask Tag error rules for received Completions */
name|uint32_t
name|m_lk_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask Locked Request filtering */
name|uint32_t
name|m_cfg1_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask Type 1 Configuration Request filtering */
name|uint32_t
name|m_bar_match
range|:
literal|1
decl_stmt|;
comment|/**< Mask BAR match filtering */
name|uint32_t
name|m_pois_filt
range|:
literal|1
decl_stmt|;
comment|/**< Mask poisoned TLP filtering */
name|uint32_t
name|m_fun
range|:
literal|1
decl_stmt|;
comment|/**< Mask function */
name|uint32_t
name|dfcwt
range|:
literal|1
decl_stmt|;
comment|/**< Disable FC Watchdog Timer */
name|uint32_t
name|reserved_11_14
range|:
literal|4
decl_stmt|;
name|uint32_t
name|skpiv
range|:
literal|11
decl_stmt|;
comment|/**< SKP Interval Value */
else|#
directive|else
name|uint32_t
name|skpiv
range|:
literal|11
decl_stmt|;
name|uint32_t
name|reserved_11_14
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dfcwt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_fun
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_pois_filt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_bar_match
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cfg1_filt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_lk_filt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_tag_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_rid_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_fun_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_tc_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_attr_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_len_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_ecrc_filt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cpl_ecrc_filt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_ctrl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_io_filt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_cfg0_filt
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg455_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg455_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg455_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg455_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg455_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg455_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg455
name|cvmx_pciercx_cfg455_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg456  *  * PCIE_CFG456 = Four hundred fifty-seventh 32-bits of PCIE type 1 config space  * (Filter Mask Register 2)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg456
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg456_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_2_31
range|:
literal|30
decl_stmt|;
name|uint32_t
name|m_vend1_drp
range|:
literal|1
decl_stmt|;
comment|/**< Mask Vendor MSG Type 1 dropped silently */
name|uint32_t
name|m_vend0_drp
range|:
literal|1
decl_stmt|;
comment|/**< Mask Vendor MSG Type 0 dropped with UR error reporting. */
else|#
directive|else
name|uint32_t
name|m_vend0_drp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m_vend1_drp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_2_31
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg456_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg456_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg456_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg456_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg456_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg456_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg456
name|cvmx_pciercx_cfg456_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg458  *  * PCIE_CFG458 = Four hundred fifty-ninth 32-bits of PCIE type 1 config space  * (Debug Register 0)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg458
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg458_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dbg_info_l32
range|:
literal|32
decl_stmt|;
comment|/**< The value on cxpl_debug_info[31:0]. */
else|#
directive|else
name|uint32_t
name|dbg_info_l32
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg458_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg458_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg458_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg458_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg458_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg458_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg458
name|cvmx_pciercx_cfg458_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg459  *  * PCIE_CFG459 = Four hundred sixtieth 32-bits of PCIE type 1 config space  * (Debug Register 1)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg459
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg459_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dbg_info_u32
range|:
literal|32
decl_stmt|;
comment|/**< The value on cxpl_debug_info[63:32]. */
else|#
directive|else
name|uint32_t
name|dbg_info_u32
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg459_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg459_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg459_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg459_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg459_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg459_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg459
name|cvmx_pciercx_cfg459_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg460  *  * PCIE_CFG460 = Four hundred sixty-first 32-bits of PCIE type 1 config space  * (Transmit Posted FC Credit Status)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg460
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg460_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tphfcc
range|:
literal|8
decl_stmt|;
comment|/**< Transmit Posted Header FC Credits                                                          The Posted Header credits advertised by the receiver at the                                                          other end of the Link, updated with each UpdateFC DLLP. */
name|uint32_t
name|tpdfcc
range|:
literal|12
decl_stmt|;
comment|/**< Transmit Posted Data FC Credits                                                          The Posted Data credits advertised by the receiver at the other                                                          end of the Link, updated with each UpdateFC DLLP. */
else|#
directive|else
name|uint32_t
name|tpdfcc
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tphfcc
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg460_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg460_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg460_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg460_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg460_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg460_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg460
name|cvmx_pciercx_cfg460_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg461  *  * PCIE_CFG461 = Four hundred sixty-second 32-bits of PCIE type 1 config space  * (Transmit Non-Posted FC Credit Status)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg461
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg461_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tchfcc
range|:
literal|8
decl_stmt|;
comment|/**< Transmit Non-Posted Header FC Credits                                                          The Non-Posted Header credits advertised by the receiver at the                                                          other end of the Link, updated with each UpdateFC DLLP. */
name|uint32_t
name|tcdfcc
range|:
literal|12
decl_stmt|;
comment|/**< Transmit Non-Posted Data FC Credits                                                          The Non-Posted Data credits advertised by the receiver at the                                                          other end of the Link, updated with each UpdateFC DLLP. */
else|#
directive|else
name|uint32_t
name|tcdfcc
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tchfcc
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg461_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg461_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg461_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg461_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg461_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg461_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg461
name|cvmx_pciercx_cfg461_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg462  *  * PCIE_CFG462 = Four hundred sixty-third 32-bits of PCIE type 1 config space  * (Transmit Completion FC Credit Status )  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg462
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg462_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tchfcc
range|:
literal|8
decl_stmt|;
comment|/**< Transmit Completion Header FC Credits                                                          The Completion Header credits advertised by the receiver at the                                                          other end of the Link, updated with each UpdateFC DLLP. */
name|uint32_t
name|tcdfcc
range|:
literal|12
decl_stmt|;
comment|/**< Transmit Completion Data FC Credits                                                          The Completion Data credits advertised by the receiver at the                                                          other end of the Link, updated with each UpdateFC DLLP. */
else|#
directive|else
name|uint32_t
name|tcdfcc
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tchfcc
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg462_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg462_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg462_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg462_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg462_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg462_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg462
name|cvmx_pciercx_cfg462_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg463  *  * PCIE_CFG463 = Four hundred sixty-fourth 32-bits of PCIE type 1 config space  * (Queue Status)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg463
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg463_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint32_t
name|rqne
range|:
literal|1
decl_stmt|;
comment|/**< Received Queue Not Empty                                                          Indicates there is data in one or more of the receive buffers. */
name|uint32_t
name|trbne
range|:
literal|1
decl_stmt|;
comment|/**< Transmit Retry Buffer Not Empty                                                          Indicates that there is data in the transmit retry buffer. */
name|uint32_t
name|rtlpfccnr
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP FC Credits Not Returned                                                          Indicates that the PCI Express bus has sent a TLP but has not                                                          yet received an UpdateFC DLLP indicating that the credits for                                                          that TLP have been restored by the receiver at the other end of                                                          the Link. */
else|#
directive|else
name|uint32_t
name|rtlpfccnr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|trbne
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rqne
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg463_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg463_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg463_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg463_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg463_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg463_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg463
name|cvmx_pciercx_cfg463_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg464  *  * PCIE_CFG464 = Four hundred sixty-fifth 32-bits of PCIE type 1 config space  * (VC Transmit Arbitration Register 1)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg464
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg464_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|wrr_vc3
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC3 */
name|uint32_t
name|wrr_vc2
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC2 */
name|uint32_t
name|wrr_vc1
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC1 */
name|uint32_t
name|wrr_vc0
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC0 */
else|#
directive|else
name|uint32_t
name|wrr_vc0
range|:
literal|8
decl_stmt|;
name|uint32_t
name|wrr_vc1
range|:
literal|8
decl_stmt|;
name|uint32_t
name|wrr_vc2
range|:
literal|8
decl_stmt|;
name|uint32_t
name|wrr_vc3
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg464_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg464_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg464_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg464_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg464_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg464_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg464
name|cvmx_pciercx_cfg464_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg465  *  * PCIE_CFG465 = Four hundred sixty-sixth 32-bits of config space  * (VC Transmit Arbitration Register 2)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg465
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg465_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|wrr_vc7
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC7 */
name|uint32_t
name|wrr_vc6
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC6 */
name|uint32_t
name|wrr_vc5
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC5 */
name|uint32_t
name|wrr_vc4
range|:
literal|8
decl_stmt|;
comment|/**< WRR Weight for VC4 */
else|#
directive|else
name|uint32_t
name|wrr_vc4
range|:
literal|8
decl_stmt|;
name|uint32_t
name|wrr_vc5
range|:
literal|8
decl_stmt|;
name|uint32_t
name|wrr_vc6
range|:
literal|8
decl_stmt|;
name|uint32_t
name|wrr_vc7
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg465_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg465_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg465_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg465_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg465_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg465_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg465
name|cvmx_pciercx_cfg465_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg466  *  * PCIE_CFG466 = Four hundred sixty-seventh 32-bits of PCIE type 1 config space  * (VC0 Posted Receive Queue Control)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg466
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg466_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|rx_queue_order
range|:
literal|1
decl_stmt|;
comment|/**< VC Ordering for Receive Queues                                                          Determines the VC ordering rule for the receive queues, used                                                          only in the segmented-buffer configuration,                                                          writable through PEM(0..1)_CFG_WR:                                                          o 1: Strict ordering, higher numbered VCs have higher priority                                                          o 0: Round robin                                                          However, the application must not change this field. */
name|uint32_t
name|type_ordering
range|:
literal|1
decl_stmt|;
comment|/**< TLP Type Ordering for VC0                                                          Determines the TLP type ordering rule for VC0 receive queues,                                                          used only in the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR:                                                          o 1: Ordering of received TLPs follows the rules in                                                               PCI Express Base Specification                                                          o 0: Strict ordering for received TLPs: Posted, then                                                               Completion, then Non-Posted                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_24_29
range|:
literal|6
decl_stmt|;
name|uint32_t
name|queue_mode
range|:
literal|3
decl_stmt|;
comment|/**< VC0 Posted TLP Queue Mode                                                          The operating mode of the Posted receive queue for VC0, used                                                          only in the segmented-buffer configuration, writable through                                                          PEM(0..1)_CFG_WR.                                                          However, the application must not change this field.                                                          Only one bit can be set at a time:                                                          o Bit 23: Bypass                                                          o Bit 22: Cut-through                                                          o Bit 21: Store-and-forward */
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|header_credits
range|:
literal|8
decl_stmt|;
comment|/**< VC0 Posted Header Credits                                                          The number of initial Posted header credits for VC0, used for                                                          all receive queue buffer configurations.                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|data_credits
range|:
literal|12
decl_stmt|;
comment|/**< VC0 Posted Data Credits                                                          The number of initial Posted data credits for VC0, used for all                                                          receive queue buffer configurations.                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|data_credits
range|:
literal|12
decl_stmt|;
name|uint32_t
name|header_credits
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|queue_mode
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_24_29
range|:
literal|6
decl_stmt|;
name|uint32_t
name|type_ordering
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_queue_order
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg466_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg466_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg466_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg466_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg466_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg466_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg466
name|cvmx_pciercx_cfg466_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg467  *  * PCIE_CFG467 = Four hundred sixty-eighth 32-bits of PCIE type 1 config space  * (VC0 Non-Posted Receive Queue Control)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg467
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg467_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint32_t
name|queue_mode
range|:
literal|3
decl_stmt|;
comment|/**< VC0 Non-Posted TLP Queue Mode                                                          The operating mode of the Non-Posted receive queue for VC0,                                                          used only in the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          Only one bit can be set at a time:                                                          o Bit 23: Bypass                                                          o Bit 22: Cut-through                                                          o Bit 21: Store-and-forward                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|header_credits
range|:
literal|8
decl_stmt|;
comment|/**< VC0 Non-Posted Header Credits                                                          The number of initial Non-Posted header credits for VC0, used                                                          for all receive queue buffer configurations.                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|data_credits
range|:
literal|12
decl_stmt|;
comment|/**< VC0 Non-Posted Data Credits                                                          The number of initial Non-Posted data credits for VC0, used for                                                          all receive queue buffer configurations.                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|data_credits
range|:
literal|12
decl_stmt|;
name|uint32_t
name|header_credits
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|queue_mode
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg467_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg467_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg467_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg467_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg467_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg467_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg467
name|cvmx_pciercx_cfg467_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg468  *  * PCIE_CFG468 = Four hundred sixty-ninth 32-bits of PCIE type 1 config space  * (VC0 Completion Receive Queue Control)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg468
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg468_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint32_t
name|queue_mode
range|:
literal|3
decl_stmt|;
comment|/**< VC0 Completion TLP Queue Mode                                                          The operating mode of the Completion receive queue for VC0,                                                          used only in the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          Only one bit can be set at a time:                                                          o Bit 23: Bypass                                                          o Bit 22: Cut-through                                                          o Bit 21: Store-and-forward                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|header_credits
range|:
literal|8
decl_stmt|;
comment|/**< VC0 Completion Header Credits                                                          The number of initial Completion header credits for VC0, used                                                          for all receive queue buffer configurations.                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|data_credits
range|:
literal|12
decl_stmt|;
comment|/**< VC0 Completion Data Credits                                                          The number of initial Completion data credits for VC0, used for                                                          all receive queue buffer configurations.                                                          This field is writable through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|data_credits
range|:
literal|12
decl_stmt|;
name|uint32_t
name|header_credits
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|queue_mode
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg468_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg468_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg468_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg468_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg468_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg468_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg468
name|cvmx_pciercx_cfg468_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg490  *  * PCIE_CFG490 = Four hundred ninety-first 32-bits of PCIE type 1 config space  * (VC0 Posted Buffer Depth)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg490
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg490_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint32_t
name|header_depth
range|:
literal|10
decl_stmt|;
comment|/**< VC0 Posted Header Queue Depth                                                          Sets the number of entries in the Posted header queue for VC0                                                          when using the segmented-buffer configuration, writable through                                                          PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint32_t
name|data_depth
range|:
literal|14
decl_stmt|;
comment|/**< VC0 Posted Data Queue Depth                                                          Sets the number of entries in the Posted data queue for VC0                                                          when using the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|data_depth
range|:
literal|14
decl_stmt|;
name|uint32_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint32_t
name|header_depth
range|:
literal|10
decl_stmt|;
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg490_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg490_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg490_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg490_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg490_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg490_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg490
name|cvmx_pciercx_cfg490_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg491  *  * PCIE_CFG491 = Four hundred ninety-second 32-bits of PCIE type 1 config space  * (VC0 Non-Posted Buffer Depth)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg491
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg491_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint32_t
name|header_depth
range|:
literal|10
decl_stmt|;
comment|/**< VC0 Non-Posted Header Queue Depth                                                          Sets the number of entries in the Non-Posted header queue for                                                          VC0 when using the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint32_t
name|data_depth
range|:
literal|14
decl_stmt|;
comment|/**< VC0 Non-Posted Data Queue Depth                                                          Sets the number of entries in the Non-Posted data queue for VC0                                                          when using the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|data_depth
range|:
literal|14
decl_stmt|;
name|uint32_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint32_t
name|header_depth
range|:
literal|10
decl_stmt|;
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg491_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg491_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg491_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg491_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg491_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg491_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg491
name|cvmx_pciercx_cfg491_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg492  *  * PCIE_CFG492 = Four hundred ninety-third 32-bits of PCIE type 1 config space  * (VC0 Completion Buffer Depth)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg492
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg492_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint32_t
name|header_depth
range|:
literal|10
decl_stmt|;
comment|/**< VC0 Completion Header Queue Depth                                                          Sets the number of entries in the Completion header queue for                                                          VC0 when using the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
name|uint32_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint32_t
name|data_depth
range|:
literal|14
decl_stmt|;
comment|/**< VC0 Completion Data Queue Depth                                                          Sets the number of entries in the Completion data queue for VC0                                                          when using the segmented-buffer configuration, writable                                                          through PEM(0..1)_CFG_WR.                                                          However, the application must not change this field. */
else|#
directive|else
name|uint32_t
name|data_depth
range|:
literal|14
decl_stmt|;
name|uint32_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint32_t
name|header_depth
range|:
literal|10
decl_stmt|;
name|uint32_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg492_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg492_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg492_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg492_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg492_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg492_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg492
name|cvmx_pciercx_cfg492_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg515  *  * PCIE_CFG515 = Five hundred sixteenth 32-bits of PCIE type 1 config space  * (Port Logic Register (Gen2))  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg515
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg515_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|s_d_e
range|:
literal|1
decl_stmt|;
comment|/**< SEL_DE_EMPHASIS                                                          Used to set the de-emphasis level for upstream ports. */
name|uint32_t
name|ctcrb
range|:
literal|1
decl_stmt|;
comment|/**< Config Tx Compliance Receive Bit                                                          When set to 1, signals LTSSM to transmit TS ordered sets                                                          with the compliance receive bit assert (equal to 1). */
name|uint32_t
name|cpyts
range|:
literal|1
decl_stmt|;
comment|/**< Config PHY Tx Swing                                                          Indicates the voltage level the PHY should drive. When set to                                                          1, indicates Full Swing. When set to 0, indicates Low Swing */
name|uint32_t
name|dsc
range|:
literal|1
decl_stmt|;
comment|/**< Directed Speed Change                                                          Indicates to the LTSSM whether or not to initiate a speed                                                          change. */
name|uint32_t
name|le
range|:
literal|9
decl_stmt|;
comment|/**< Lane Enable                                                          Indicates the number of lanes to check for exit from electrical                                                          idle in Polling.Active and Polling.Compliance. 1 = x1, 2 = x2,                                                          etc. Used to limit the maximum link width to ignore broken                                                          lanes that detect a receiver, but will not exit electrical                                                          idle and                                                          would otherwise prevent a valid link from being configured. */
name|uint32_t
name|n_fts
range|:
literal|8
decl_stmt|;
comment|/**< N_FTS                                                          Sets the Number of Fast Training Sequences (N_FTS) that                                                          the core advertises as its N_FTS during GEN2 Link training.                                                          This value is used to inform the Link partner about the PHYs                                                          ability to recover synchronization after a low power state.                                                          Note: Do not set N_FTS to zero; doing so can cause the                                                                LTSSM to go into the recovery state when exiting from                                                                L0s. */
else|#
directive|else
name|uint32_t
name|n_fts
range|:
literal|8
decl_stmt|;
name|uint32_t
name|le
range|:
literal|9
decl_stmt|;
name|uint32_t
name|dsc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cpyts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ctcrb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|s_d_e
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg515_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg515_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg515
name|cvmx_pciercx_cfg515_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg516  *  * PCIE_CFG516 = Five hundred seventeenth 32-bits of PCIE type 1 config space  * (PHY Status Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg516
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg516_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|phy_stat
range|:
literal|32
decl_stmt|;
comment|/**< PHY Status */
else|#
directive|else
name|uint32_t
name|phy_stat
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg516_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg516_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg516_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg516_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg516_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg516_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg516
name|cvmx_pciercx_cfg516_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcierc#_cfg517  *  * PCIE_CFG517 = Five hundred eighteenth 32-bits of PCIE type 1 config space  * (PHY Control Register)  */
end_comment

begin_union
union|union
name|cvmx_pciercx_cfg517
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pciercx_cfg517_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|phy_ctrl
range|:
literal|32
decl_stmt|;
comment|/**< PHY Control */
else|#
directive|else
name|uint32_t
name|phy_ctrl
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pciercx_cfg517_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg517_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg517_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg517_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg517_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pciercx_cfg517_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pciercx_cfg517
name|cvmx_pciercx_cfg517_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

