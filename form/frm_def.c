begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *   Author:  Juergen Pfeifer, 1995,1997                                    *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"form.priv.h"
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: frm_def.c,v 1.25 2010/01/23 21:14:36 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* this can't be readonly */
end_comment

begin_decl_stmt
specifier|static
name|FORM
name|default_form
init|=
block|{
literal|0
block|,
comment|/* status     */
literal|0
block|,
comment|/* rows       */
literal|0
block|,
comment|/* cols       */
literal|0
block|,
comment|/* currow     */
literal|0
block|,
comment|/* curcol     */
literal|0
block|,
comment|/* toprow     */
literal|0
block|,
comment|/* begincol   */
operator|-
literal|1
block|,
comment|/* maxfield   */
operator|-
literal|1
block|,
comment|/* maxpage    */
operator|-
literal|1
block|,
comment|/* curpage    */
name|ALL_FORM_OPTS
block|,
comment|/* opts       */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* win        */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* sub        */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* w          */
operator|(
name|FIELD
operator|*
operator|*
operator|)
literal|0
block|,
comment|/* field      */
operator|(
name|FIELD
operator|*
operator|)
literal|0
block|,
comment|/* current    */
operator|(
name|_PAGE
operator|*
operator|)
literal|0
block|,
comment|/* page       */
operator|(
name|char
operator|*
operator|)
literal|0
block|,
comment|/* usrptr     */
name|NULL
block|,
comment|/* forminit   */
name|NULL
block|,
comment|/* formterm   */
name|NULL
block|,
comment|/* fieldinit  */
name|NULL
comment|/* fieldterm  */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|FORM *
argument_list|)
end_macro

begin_expr_stmt
name|_nc_Default_Form
operator|=
operator|&
name|default_form
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static FIELD *Insert_Field_By_Position( |                                     FIELD *new_field,  |                                     FIELD *head ) |    |   Description   :  Insert new_field into sorted fieldlist with head "head" |                    and return new head of sorted fieldlist. Sorting |                    criteria is (row,column). This is a circular list. | |   Return Values :  New head of sorted fieldlist +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|FIELD
modifier|*
name|Insert_Field_By_Position
parameter_list|(
name|FIELD
modifier|*
name|newfield
parameter_list|,
name|FIELD
modifier|*
name|head
parameter_list|)
block|{
name|FIELD
modifier|*
name|current
decl_stmt|,
modifier|*
name|newhead
decl_stmt|;
name|assert
argument_list|(
name|newfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
block|{
comment|/* empty list is trivial */
name|newhead
operator|=
name|newfield
operator|->
name|snext
operator|=
name|newfield
operator|->
name|sprev
operator|=
name|newfield
expr_stmt|;
block|}
else|else
block|{
name|newhead
operator|=
name|current
operator|=
name|head
expr_stmt|;
while|while
condition|(
operator|(
name|current
operator|->
name|frow
operator|<
name|newfield
operator|->
name|frow
operator|)
operator|||
operator|(
operator|(
name|current
operator|->
name|frow
operator|==
name|newfield
operator|->
name|frow
operator|)
operator|&&
operator|(
name|current
operator|->
name|fcol
operator|<
name|newfield
operator|->
name|fcol
operator|)
operator|)
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|snext
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|head
condition|)
block|{
comment|/* We cycled through. Reset head to indicate that */
name|head
operator|=
operator|(
name|FIELD
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* we leave the loop with current pointing to the field after newfield */
name|newfield
operator|->
name|snext
operator|=
name|current
expr_stmt|;
name|newfield
operator|->
name|sprev
operator|=
name|current
operator|->
name|sprev
expr_stmt|;
name|newfield
operator|->
name|snext
operator|->
name|sprev
operator|=
name|newfield
expr_stmt|;
name|newfield
operator|->
name|sprev
operator|->
name|snext
operator|=
name|newfield
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|head
condition|)
name|newhead
operator|=
name|newfield
expr_stmt|;
block|}
return|return
operator|(
name|newhead
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static void Disconnect_Fields(FORM *form) |    |   Description   :  Break association between form and array of fields. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|Disconnect_Fields
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
if|if
condition|(
name|form
operator|->
name|field
condition|)
block|{
name|FIELD
modifier|*
modifier|*
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|form
operator|->
name|field
init|;
operator|*
name|fields
condition|;
name|fields
operator|++
control|)
block|{
if|if
condition|(
name|form
operator|==
operator|(
operator|*
name|fields
operator|)
operator|->
name|form
condition|)
operator|(
operator|*
name|fields
operator|)
operator|->
name|form
operator|=
operator|(
name|FORM
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|form
operator|->
name|rows
operator|=
name|form
operator|->
name|cols
operator|=
literal|0
expr_stmt|;
name|form
operator|->
name|maxfield
operator|=
name|form
operator|->
name|maxpage
operator|=
operator|-
literal|1
expr_stmt|;
name|form
operator|->
name|field
operator|=
operator|(
name|FIELD
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|page
condition|)
name|free
argument_list|(
name|form
operator|->
name|page
argument_list|)
expr_stmt|;
name|form
operator|->
name|page
operator|=
operator|(
name|_PAGE
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static int Connect_Fields(FORM *form, FIELD **fields) |    |   Description   :  Set association between form and array of fields. | |   Return Values :  E_OK            - no error |                    E_CONNECTED     - a field is already connected |                    E_BAD_ARGUMENT  - Invalid form pointer or field array |                    E_SYSTEM_ERROR  - not enough memory +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Connect_Fields
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|FIELD
modifier|*
modifier|*
name|fields
parameter_list|)
block|{
name|int
name|field_cnt
decl_stmt|,
name|j
decl_stmt|;
name|int
name|page_nr
decl_stmt|;
name|int
name|maximum_row_in_field
decl_stmt|,
name|maximum_col_in_field
decl_stmt|;
name|_PAGE
modifier|*
name|pg
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"Connect_Fields(%p,%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|form
operator|,
operator|(
name|void
operator|*
operator|)
name|fields
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|form
operator|->
name|field
operator|=
name|fields
expr_stmt|;
name|form
operator|->
name|maxfield
operator|=
literal|0
expr_stmt|;
name|form
operator|->
name|maxpage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
name|RETURN
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
name|page_nr
operator|=
literal|0
expr_stmt|;
comment|/* store formpointer in fields and count pages */
for|for
control|(
name|field_cnt
operator|=
literal|0
init|;
name|fields
index|[
name|field_cnt
index|]
condition|;
name|field_cnt
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|field_cnt
index|]
operator|->
name|form
condition|)
name|RETURN
argument_list|(
name|E_CONNECTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_cnt
operator|==
literal|0
operator|||
operator|(
name|fields
index|[
name|field_cnt
index|]
operator|->
name|status
operator|&
name|_NEWPAGE
operator|)
condition|)
name|page_nr
operator|++
expr_stmt|;
name|fields
index|[
name|field_cnt
index|]
operator|->
name|form
operator|=
name|form
expr_stmt|;
block|}
if|if
condition|(
name|field_cnt
operator|==
literal|0
operator|||
operator|(
name|short
operator|)
name|field_cnt
operator|<
literal|0
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
comment|/* allocate page structures */
if|if
condition|(
operator|(
name|pg
operator|=
name|typeMalloc
argument_list|(
name|_PAGE
argument_list|,
name|page_nr
argument_list|)
operator|)
operator|!=
operator|(
name|_PAGE
operator|*
operator|)
literal|0
condition|)
block|{
name|T
argument_list|(
operator|(
name|T_CREATE
argument_list|(
literal|"_PAGE %p"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|pg
operator|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|page
operator|=
name|pg
expr_stmt|;
block|}
else|else
name|RETURN
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
comment|/* Cycle through fields and calculate page boundaries as well as      size of the form */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|field_cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|pg
operator|->
name|pmin
operator|=
name|j
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fields
index|[
name|j
index|]
operator|->
name|status
operator|&
name|_NEWPAGE
condition|)
block|{
name|pg
operator|->
name|pmax
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|pg
operator|++
expr_stmt|;
name|pg
operator|->
name|pmin
operator|=
name|j
expr_stmt|;
block|}
block|}
name|maximum_row_in_field
operator|=
name|fields
index|[
name|j
index|]
operator|->
name|frow
operator|+
name|fields
index|[
name|j
index|]
operator|->
name|rows
expr_stmt|;
name|maximum_col_in_field
operator|=
name|fields
index|[
name|j
index|]
operator|->
name|fcol
operator|+
name|fields
index|[
name|j
index|]
operator|->
name|cols
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|rows
operator|<
name|maximum_row_in_field
condition|)
name|form
operator|->
name|rows
operator|=
name|maximum_row_in_field
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|cols
operator|<
name|maximum_col_in_field
condition|)
name|form
operator|->
name|cols
operator|=
name|maximum_col_in_field
expr_stmt|;
block|}
name|pg
operator|->
name|pmax
operator|=
name|field_cnt
operator|-
literal|1
expr_stmt|;
name|form
operator|->
name|maxfield
operator|=
name|field_cnt
expr_stmt|;
name|form
operator|->
name|maxpage
operator|=
name|page_nr
expr_stmt|;
comment|/* Sort fields on form pages */
for|for
control|(
name|page_nr
operator|=
literal|0
init|;
name|page_nr
operator|<
name|form
operator|->
name|maxpage
condition|;
name|page_nr
operator|++
control|)
block|{
name|FIELD
modifier|*
name|fld
init|=
operator|(
name|FIELD
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
name|form
operator|->
name|page
index|[
name|page_nr
index|]
operator|.
name|pmin
init|;
name|j
operator|<=
name|form
operator|->
name|page
index|[
name|page_nr
index|]
operator|.
name|pmax
condition|;
name|j
operator|++
control|)
block|{
name|fields
index|[
name|j
index|]
operator|->
name|index
operator|=
name|j
expr_stmt|;
name|fields
index|[
name|j
index|]
operator|->
name|page
operator|=
name|page_nr
expr_stmt|;
name|fld
operator|=
name|Insert_Field_By_Position
argument_list|(
name|fields
index|[
name|j
index|]
argument_list|,
name|fld
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fld
condition|)
block|{
name|form
operator|->
name|page
index|[
name|page_nr
index|]
operator|.
name|smin
operator|=
name|fld
operator|->
name|index
expr_stmt|;
name|form
operator|->
name|page
index|[
name|page_nr
index|]
operator|.
name|smax
operator|=
name|fld
operator|->
name|sprev
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
name|form
operator|->
name|page
index|[
name|page_nr
index|]
operator|.
name|smin
operator|=
literal|0
expr_stmt|;
name|form
operator|->
name|page
index|[
name|page_nr
index|]
operator|.
name|smax
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|RETURN
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static int Associate_Fields(FORM *form, FIELD **fields) |    |   Description   :  Set association between form and array of fields.  |                    If there are fields, position to first active field. | |   Return Values :  E_OK            - success |                    E_BAD_ARGUMENT  - Invalid form pointer or field array |                    E_CONNECTED     - a field is already connected |                    E_SYSTEM_ERROR  - not enough memory +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|int
name|Associate_Fields
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|FIELD
modifier|*
modifier|*
name|fields
parameter_list|)
block|{
name|int
name|res
init|=
name|Connect_Fields
argument_list|(
name|form
argument_list|,
name|fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|E_OK
condition|)
block|{
if|if
condition|(
name|form
operator|->
name|maxpage
operator|>
literal|0
condition|)
block|{
name|form
operator|->
name|curpage
operator|=
literal|0
expr_stmt|;
name|form_driver
argument_list|(
name|form
argument_list|,
name|FIRST_ACTIVE_MAGIC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|form
operator|->
name|curpage
operator|=
operator|-
literal|1
expr_stmt|;
name|form
operator|->
name|current
operator|=
operator|(
name|FIELD
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  FORM *new_form_sp(SCREEN* sp, FIELD** fields ) |    |   Description   :  Create new form with given array of fields. | |   Return Values :  Pointer to form. NULL if error occurred. !                    Set errno: |                    E_OK            - success |                    E_BAD_ARGUMENT  - Invalid form pointer or field array |                    E_CONNECTED     - a field is already connected |                    E_SYSTEM_ERROR  - not enough memory +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_EXPORT
function|(
name|FORM
modifier|*
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|new_form
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|FIELD
modifier|*
modifier|*
name|fields
parameter_list|)
block|{
name|int
name|err
init|=
name|E_SYSTEM_ERROR
decl_stmt|;
name|FORM
modifier|*
name|form
init|=
operator|(
name|FORM
operator|*
operator|)
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"new_form(%p,%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|,
operator|(
name|void
operator|*
operator|)
name|fields
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsValidScreen
argument_list|(
name|SP_PARM
argument_list|)
condition|)
block|{
name|form
operator|=
name|typeMalloc
argument_list|(
name|FORM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
condition|)
block|{
name|T
argument_list|(
operator|(
name|T_CREATE
argument_list|(
literal|"form %p"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|form
operator|)
argument_list|)
expr_stmt|;
operator|*
name|form
operator|=
operator|*
name|_nc_Default_Form
expr_stmt|;
comment|/* This ensures win and sub are always non-null, 	     so we can derive always the SCREEN that this form is 	     running on. */
name|form
operator|->
name|win
operator|=
name|StdScreen
argument_list|(
name|SP_PARM
argument_list|)
expr_stmt|;
name|form
operator|->
name|sub
operator|=
name|StdScreen
argument_list|(
name|SP_PARM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|Associate_Fields
argument_list|(
name|form
argument_list|,
name|fields
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|free_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|form
operator|=
operator|(
name|FORM
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|form
condition|)
name|SET_ERROR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|returnForm
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  FORM* new_form(FIELD** fields ) |    |   Description   :  Create new form with given array of fields. | |   Return Values :  Pointer to form. NULL if error occurred. !                    Set errno: |                    E_OK            - success |                    E_BAD_ARGUMENT  - Invalid form pointer or field array |                    E_CONNECTED     - a field is already connected |                    E_SYSTEM_ERROR  - not enough memory +--------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|FORM *
argument_list|)
end_macro

begin_macro
name|new_form
argument_list|(
argument|FIELD **fields
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|new_form
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|,
name|fields
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  int free_form( FORM *form ) |    |   Description   :  Release internal memory associated with form. | |   Return Values :  E_OK           - no error |                    E_BAD_ARGUMENT - invalid form pointer |                    E_POSTED       - form is posted +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|free_form
argument_list|(
argument|FORM *form
argument_list|)
end_macro

begin_block
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"free_form(%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_POSTED
condition|)
name|RETURN
argument_list|(
name|E_POSTED
argument_list|)
expr_stmt|;
name|Disconnect_Fields
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|page
condition|)
name|free
argument_list|(
name|form
operator|->
name|page
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  int set_form_fields( FORM *form, FIELD **fields ) |    |   Description   :  Set a new association of an array of fields to a form | |   Return Values :  E_OK            - no error |                    E_BAD_ARGUMENT  - Invalid form pointer or field array |                    E_CONNECTED     - a field is already connected |                    E_POSTED        - form is posted |                    E_SYSTEM_ERROR  - not enough memory +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|set_form_fields
argument_list|(
argument|FORM *form
argument_list|,
argument|FIELD **fields
argument_list|)
end_macro

begin_block
block|{
name|FIELD
modifier|*
modifier|*
name|old
decl_stmt|;
name|int
name|res
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"set_form_fields(%p,%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|form
operator|,
operator|(
name|void
operator|*
operator|)
name|fields
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_POSTED
condition|)
name|RETURN
argument_list|(
name|E_POSTED
argument_list|)
expr_stmt|;
name|old
operator|=
name|form
operator|->
name|field
expr_stmt|;
name|Disconnect_Fields
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|Associate_Fields
argument_list|(
name|form
argument_list|,
name|fields
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|Connect_Fields
argument_list|(
name|form
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  FIELD **form_fields( const FORM *form ) |    |   Description   :  Retrieve array of fields | |   Return Values :  Pointer to field array +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|FIELD **
argument_list|)
end_macro

begin_macro
name|form_fields
argument_list|(
argument|const FORM *form
argument_list|)
end_macro

begin_block
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"form_field(%p)"
argument_list|)
operator|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnFieldPtr
argument_list|(
name|Normalize_Form
argument_list|(
name|form
argument_list|)
operator|->
name|field
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  int field_count( const FORM *form ) |    |   Description   :  Retrieve number of fields | |   Return Values :  Number of fields, -1 if none are defined +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|field_count
argument_list|(
argument|const FORM *form
argument_list|)
end_macro

begin_block
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"field_count(%p)"
argument_list|)
operator|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|Normalize_Form
argument_list|(
name|form
argument_list|)
operator|->
name|maxfield
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* frm_def.c ends here */
end_comment

end_unit

