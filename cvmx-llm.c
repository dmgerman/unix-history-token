begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Configuration functions for low latency memory.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-llm.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-csr-db.h"
end_include

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|dfa_memcfg0_base
decl_stmt|;
name|uint32_t
name|dfa_memcfg1_base
decl_stmt|;
name|uint32_t
name|mrs_dat_p0bunk0
decl_stmt|;
name|uint32_t
name|mrs_dat_p0bunk1
decl_stmt|;
name|uint32_t
name|mrs_dat_p1bunk0
decl_stmt|;
name|uint32_t
name|mrs_dat_p1bunk1
decl_stmt|;
name|uint8_t
name|p0_ena
decl_stmt|;
name|uint8_t
name|p1_ena
decl_stmt|;
name|uint8_t
name|bunkport
decl_stmt|;
block|}
name|rldram_csr_config_t
typedef|;
end_typedef

begin_function_decl
name|int
name|rld_csr_config_generate
parameter_list|(
name|llm_descriptor_t
modifier|*
name|llm_desc_ptr
parameter_list|,
name|rldram_csr_config_t
modifier|*
name|cfg_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_rld_cfg
parameter_list|(
name|rldram_csr_config_t
modifier|*
name|cfg_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_rld_cfg
parameter_list|(
name|rldram_csr_config_t
modifier|*
name|cfg_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cn31xx_dfa_memory_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|process_address_map_str
parameter_list|(
name|uint32_t
name|mrs_dat
parameter_list|,
name|char
modifier|*
name|addr_str
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_LLM_NUM_PORTS
end_ifndef

begin_warning
warning|#
directive|warning
warning|WARNING: default CVMX_LLM_NUM_PORTS used.  Defaults deprecated, please set in executive-config.h
end_warning

begin_define
define|#
directive|define
name|CVMX_LLM_NUM_PORTS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|CVMX_LLM_NUM_PORTS
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|CVMX_LLM_NUM_PORTS
operator|!=
literal|2
operator|)
end_if

begin_error
error|#
directive|error
literal|"Invalid CVMX_LLM_NUM_PORTS value: must be 1 or 2\n"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvmx_llm_initialize
parameter_list|()
block|{
if|if
condition|(
name|cvmx_llm_initialize_desc
argument_list|(
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_llm_get_default_descriptor
parameter_list|(
name|llm_descriptor_t
modifier|*
name|llm_desc_ptr
parameter_list|)
block|{
name|cvmx_sysinfo_t
modifier|*
name|sys_ptr
decl_stmt|;
name|sys_ptr
operator|=
name|cvmx_sysinfo_get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|llm_desc_ptr
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|llm_desc_ptr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|llm_descriptor_t
argument_list|)
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|->
name|cpu_hz
operator|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBT3000
condition|)
block|{
comment|// N3K->RLD0 Address Swizzle
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|"22 21 19 20 08 07 06 05 04 03 02 01 00 09 18 17 16 15 14 13 12 11 10"
argument_list|)
expr_stmt|;
comment|// N3K->RLD1 Address Swizzle
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 20 00 08 07 06 05 04 13 02 01 03 09 18 17 16 15 14 10 12 11 19"
argument_list|)
expr_stmt|;
comment|/* NOTE: The ebt3000 has a strange RLDRAM configuration for validation purposes.  It is not recommended to have         ** different amounts of memory on different ports as that renders some memory unusable */
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|128
expr_stmt|;
comment|// RLD0: 4x 32Mx9
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
literal|64
expr_stmt|;
comment|// RLD1: 2x 16Mx18
block|}
elseif|else
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBT5800
condition|)
block|{
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|"22 21 20 00 08 07 06 05 04 13 02 01 03 09 18 17 16 15 14 10 12 11 19"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 20 00 08 07 06 05 04 13 02 01 03 09 18 17 16 15 14 10 12 11 19"
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|128
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
literal|128
expr_stmt|;
name|llm_desc_ptr
operator|->
name|max_rld_clock_mhz
operator|=
literal|400
expr_stmt|;
comment|/* CN58XX needs a max clock speed for selecting optimal divisor */
block|}
elseif|else
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH3000
condition|)
block|{
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|"22 21 19 20 08 07 06 05 04 03 02 01 00 09 18 17 16 15 14 13 12 11 10"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 19 20 08 07 06 05 04 03 02 01 00 09 18 17 16 15 14 13 12 11 10"
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|128
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_THUNDER
condition|)
block|{
if|if
condition|(
name|sys_ptr
operator|->
name|board_rev_major
operator|>=
literal|4
condition|)
block|{
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|"22 21 13 11 01 02 07 19 03 18 10 12 20 06 04 08 17 05 14 16 00 09 15"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|"22 21 11 13 04 08 17 05 14 16 00 09 15 06 01 02 07 19 03 18 10 12 20"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 02 19 18 17 16 09 14 13 20 11 10 01 08 03 06 15 04 07 05 12 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 19 02 08 03 06 15 04 07 05 12 00 01 18 17 16 09 14 13 20 11 10"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
block|}
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|128
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_NICPRO2
condition|)
block|{
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|"22 21 19 20 08 07 06 05 04 03 02 01 00 09 18 17 16 15 14 13 12 11 10"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 19 20 08 07 06 05 04 03 02 01 00 09 18 17 16 15 14 13 12 11 10"
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|256
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
literal|256
expr_stmt|;
name|llm_desc_ptr
operator|->
name|max_rld_clock_mhz
operator|=
literal|400
expr_stmt|;
comment|/* CN58XX needs a max clock speed for selecting optimal divisor */
block|}
elseif|else
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH3100
condition|)
block|{
comment|/* CN31xx DFA memory is DDR based, so it is completely different from the CN38XX DFA memory */
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|1
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|256
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_KBP
condition|)
block|{
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|=
literal|0
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
argument_list|,
literal|"22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|=
literal|2
expr_stmt|;
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"No default LLM configuration available for board %s (%d)\n"
argument_list|,
name|cvmx_board_type_to_string
argument_list|(
name|sys_ptr
operator|->
name|board_type
argument_list|)
argument_list|,
name|sys_ptr
operator|->
name|board_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_llm_initialize_desc
parameter_list|(
name|llm_descriptor_t
modifier|*
name|llm_desc_ptr
parameter_list|)
block|{
name|cvmx_sysinfo_t
modifier|*
name|sys_ptr
decl_stmt|;
name|sys_ptr
operator|=
name|cvmx_sysinfo_get
argument_list|()
expr_stmt|;
name|llm_descriptor_t
name|default_llm_desc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|default_llm_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|default_llm_desc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Skipping llm configuration for simulator.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sys_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH3100
condition|)
block|{
comment|/* CN31xx DFA memory is DDR based, so it is completely different from the CN38XX DFA memory         ** config descriptors are not supported yet.*/
name|cvmx_dprintf
argument_list|(
literal|"Warning: preliminary DFA memory configuration\n"
argument_list|)
expr_stmt|;
name|cn31xx_dfa_memory_init
argument_list|()
expr_stmt|;
return|return
operator|(
literal|256
operator|*
literal|1024
operator|*
literal|1024
operator|)
return|;
block|}
comment|/* If no descriptor passed, generate default descriptor based on board type.     ** Fail if no default available for given board type     */
if|if
condition|(
operator|!
name|llm_desc_ptr
condition|)
block|{
comment|/* Get default descriptor */
if|if
condition|(
literal|0
operator|>
name|cvmx_llm_get_default_descriptor
argument_list|(
operator|&
name|default_llm_desc
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Disable second port depending on CVMX config */
if|if
condition|(
name|CVMX_LLM_NUM_PORTS
operator|==
literal|1
condition|)
name|default_llm_desc
operator|.
name|rld0_bunks
operator|=
literal|0
expr_stmt|;
comment|// For single port: Force RLD0(P1) to appear EMPTY
name|cvmx_dprintf
argument_list|(
literal|"Using default LLM configuration for board %s (%d)\n"
argument_list|,
name|cvmx_board_type_to_string
argument_list|(
name|sys_ptr
operator|->
name|board_type
argument_list|)
argument_list|,
name|sys_ptr
operator|->
name|board_type
argument_list|)
expr_stmt|;
name|llm_desc_ptr
operator|=
operator|&
name|default_llm_desc
expr_stmt|;
block|}
name|rldram_csr_config_t
name|ebt3000_rld_cfg
decl_stmt|;
if|if
condition|(
operator|!
name|rld_csr_config_generate
argument_list|(
name|llm_desc_ptr
argument_list|,
operator|&
name|ebt3000_rld_cfg
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Configuring %d llm port(s).\n"
argument_list|,
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|+
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld1_bunks
argument_list|)
expr_stmt|;
name|write_rld_cfg
argument_list|(
operator|&
name|ebt3000_rld_cfg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Error creating rldram configuration\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Compute how much memory is configured     ** Memory is interleaved, so if one port has more than the other some memory is not usable */
comment|/* If both ports are enabled, handle the case where one port has more than the other.     ** This is an unusual and not recommended configuration that exists on the ebt3000 board */
if|if
condition|(
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|&&
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld1_bunks
condition|)
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|=
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|=
name|MIN
argument_list|(
name|llm_desc_ptr
operator|->
name|rld0_mbytes
argument_list|,
name|llm_desc_ptr
operator|->
name|rld1_mbytes
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld0_bunks
operator|)
operator|*
name|llm_desc_ptr
operator|->
name|rld0_mbytes
operator|+
operator|(
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld1_bunks
operator|)
operator|*
name|llm_desc_ptr
operator|->
name|rld1_mbytes
operator|)
operator|*
literal|1024
operator|*
literal|1024
operator|)
return|;
block|}
end_function

begin_comment
comment|//======================
end_comment

begin_comment
comment|// SUPPORT FUNCTIONS:
end_comment

begin_comment
comment|//======================
end_comment

begin_comment
comment|//======================================================================
end_comment

begin_comment
comment|// Extracts srcvec[srcbitpos] and places it in return int (bit[0])
end_comment

begin_function
name|int
name|bit_extract
parameter_list|(
name|int
name|srcvec
parameter_list|,
comment|// source word (to extract)
name|int
name|srcbitpos
comment|// source bit position
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
literal|1
operator|<<
name|srcbitpos
operator|)
operator|&
name|srcvec
operator|)
operator|>>
name|srcbitpos
operator|)
return|;
block|}
end_function

begin_comment
comment|//======================================================================
end_comment

begin_comment
comment|// Inserts srcvec[0] into dstvec[dstbitpos] (without affecting other bits)
end_comment

begin_function
name|int
name|bit_insert
parameter_list|(
name|int
name|srcvec
parameter_list|,
comment|// srcvec[0] = bit to be inserted
name|int
name|dstbitpos
parameter_list|,
comment|// Bit position to insert into returned int
name|int
name|dstvec
comment|// dstvec (destination vector)
parameter_list|)
block|{
return|return
operator|(
operator|(
name|srcvec
operator|<<
name|dstbitpos
operator|)
operator||
name|dstvec
operator|)
return|;
comment|// Shift bit to insert into bit position/OR with accumulated number
block|}
end_function

begin_comment
comment|//======================================================================
end_comment

begin_function
name|int
name|rld_csr_config_generate
parameter_list|(
name|llm_descriptor_t
modifier|*
name|llm_desc_ptr
parameter_list|,
name|rldram_csr_config_t
modifier|*
name|cfg_ptr
parameter_list|)
block|{
name|char
modifier|*
name|addr_rld0_fb_str
decl_stmt|;
name|char
modifier|*
name|addr_rld0_bb_str
decl_stmt|;
name|char
modifier|*
name|addr_rld1_fb_str
decl_stmt|;
name|char
modifier|*
name|addr_rld1_bb_str
decl_stmt|;
name|int
name|eclk_ps
decl_stmt|;
name|int
name|mtype
init|=
literal|0
decl_stmt|;
comment|// MTYPE (0: RLDRAM/1: FCRAM
name|int
name|trcmin
init|=
literal|20
decl_stmt|;
comment|// tRC(min) - from RLDRAM data sheet
name|int
name|trc_cyc
decl_stmt|;
comment|// TRC(cyc)
name|int
name|trc_mod
decl_stmt|;
name|int
name|trl_cyc
decl_stmt|;
comment|// TRL(cyc)
name|int
name|twl_cyc
decl_stmt|;
comment|// TWL(cyc)
name|int
name|tmrsc_cyc
init|=
literal|6
decl_stmt|;
comment|// tMRSC(cyc)  [2-7]
name|int
name|mclk_ps
decl_stmt|;
comment|// DFA Memory Clock(in ps) = 2x eclk
name|int
name|rldcfg
init|=
literal|99
decl_stmt|;
comment|// RLDRAM-II CFG (1,2,3)
name|int
name|mrs_odt
init|=
literal|0
decl_stmt|;
comment|// RLDRAM MRS A[9]=ODT (default)
name|int
name|mrs_impmatch
init|=
literal|0
decl_stmt|;
comment|// RLDRAM MRS A[8]=Impedance Matching (default)
name|int
name|mrs_dllrst
init|=
literal|1
decl_stmt|;
comment|// RLDRAM MRS A[7]=DLL Reset (default)
name|uint32_t
name|mrs_dat
decl_stmt|;
name|int
name|mrs_dat_p0bunk0
init|=
literal|0
decl_stmt|;
comment|// MRS Register Data After Address Map (for Port0 Bunk0)
name|int
name|mrs_dat_p0bunk1
init|=
literal|0
decl_stmt|;
comment|// MRS Register Data After Address Map (for Port0 Bunk1)
name|int
name|mrs_dat_p1bunk0
init|=
literal|0
decl_stmt|;
comment|// MRS Register Data After Address Map (for Port1 Bunk0)
name|int
name|mrs_dat_p1bunk1
init|=
literal|0
decl_stmt|;
comment|// MRS Register Data After Address Map (for Port1 Bunk1)
name|int
name|p0_ena
init|=
literal|0
decl_stmt|;
comment|// DFA Port#0 Enabled
name|int
name|p1_ena
init|=
literal|0
decl_stmt|;
comment|// DFA Port#1 Enabled
name|int
name|memport
init|=
literal|0
decl_stmt|;
comment|// Memory(MB) per Port [MAX=512]
name|int
name|membunk
decl_stmt|;
comment|// Memory(MB) per Bunk
name|int
name|bunkport
init|=
literal|0
decl_stmt|;
comment|// Bunks/Port [1/2]
name|int
name|pbunk
init|=
literal|0
decl_stmt|;
comment|// Physical Bunk(or Rank) encoding for address bit
name|int
name|tref_ms
init|=
literal|32
decl_stmt|;
comment|// tREF(ms) (RLDRAM-II overall device refresh interval
name|int
name|trefi_ns
decl_stmt|;
comment|// tREFI(ns) = tREF(ns)/#rows/bank
name|int
name|rows
init|=
literal|8
decl_stmt|;
comment|// #rows/bank (K) typically 8K
name|int
name|ref512int
decl_stmt|;
name|int
name|ref512mod
decl_stmt|;
name|int
name|tskw_cyc
init|=
literal|0
decl_stmt|;
name|int
name|fprch
init|=
literal|1
decl_stmt|;
name|int
name|bprch
init|=
literal|0
decl_stmt|;
name|int
name|dfa_memcfg0_base
init|=
literal|0
decl_stmt|;
name|int
name|dfa_memcfg1_base
init|=
literal|0
decl_stmt|;
name|int
name|tbl
init|=
literal|1
decl_stmt|;
comment|// tBL (1: 2-burst /2: 4-burst)
name|int
name|rw_dly
decl_stmt|;
name|int
name|wr_dly
decl_stmt|;
name|int
name|r2r
init|=
literal|1
decl_stmt|;
name|int
name|sil_lat
init|=
literal|1
decl_stmt|;
name|int
name|clkdiv
init|=
literal|2
decl_stmt|;
comment|/* CN38XX is fixed at 2, CN58XX supports 2,3,4 */
name|int
name|clkdiv_enc
init|=
literal|0x0
decl_stmt|;
comment|/* Encoded clock divisor, only used for CN58XX */
if|if
condition|(
operator|!
name|llm_desc_ptr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Setup variables from descriptor */
name|addr_rld0_fb_str
operator|=
name|llm_desc_ptr
operator|->
name|addr_rld0_fb_str
expr_stmt|;
name|addr_rld0_bb_str
operator|=
name|llm_desc_ptr
operator|->
name|addr_rld0_bb_str
expr_stmt|;
name|addr_rld1_fb_str
operator|=
name|llm_desc_ptr
operator|->
name|addr_rld1_fb_str
expr_stmt|;
name|addr_rld1_bb_str
operator|=
name|llm_desc_ptr
operator|->
name|addr_rld1_bb_str
expr_stmt|;
name|p0_ena
operator|=
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld1_bunks
expr_stmt|;
comment|// NOTE: P0 == RLD1
name|p1_ena
operator|=
operator|!
operator|!
name|llm_desc_ptr
operator|->
name|rld0_bunks
expr_stmt|;
comment|// NOTE: P1 == RLD0
comment|// Massage the code, so that if the user had imbalanced memory per-port (or imbalanced bunks/port), we
comment|// at least try to configure 'workable' memory.
if|if
condition|(
name|p0_ena
operator|&&
name|p1_ena
condition|)
comment|// IF BOTH PORTS Enabled (imbalanced memory), select smaller of BOTH
block|{
name|memport
operator|=
name|MIN
argument_list|(
name|llm_desc_ptr
operator|->
name|rld0_mbytes
argument_list|,
name|llm_desc_ptr
operator|->
name|rld1_mbytes
argument_list|)
expr_stmt|;
name|bunkport
operator|=
name|MIN
argument_list|(
name|llm_desc_ptr
operator|->
name|rld0_bunks
argument_list|,
name|llm_desc_ptr
operator|->
name|rld1_bunks
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p0_ena
condition|)
comment|// P0=RLD1 Enabled
block|{
name|memport
operator|=
name|llm_desc_ptr
operator|->
name|rld1_mbytes
expr_stmt|;
name|bunkport
operator|=
name|llm_desc_ptr
operator|->
name|rld1_bunks
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1_ena
condition|)
comment|// P1=RLD0 Enabled
block|{
name|memport
operator|=
name|llm_desc_ptr
operator|->
name|rld0_mbytes
expr_stmt|;
name|bunkport
operator|=
name|llm_desc_ptr
operator|->
name|rld0_bunks
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
name|uint32_t
name|eclk_mhz
init|=
name|llm_desc_ptr
operator|->
name|cpu_hz
operator|/
literal|1000000
decl_stmt|;
comment|/* Tweak skew based on cpu clock */
if|if
condition|(
name|eclk_mhz
operator|<=
literal|367
condition|)
block|{
name|tskw_cyc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tskw_cyc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine clock divider ratio (only required for CN58XX) */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
name|uint32_t
name|max_llm_clock_mhz
init|=
name|llm_desc_ptr
operator|->
name|max_rld_clock_mhz
decl_stmt|;
if|if
condition|(
operator|!
name|max_llm_clock_mhz
condition|)
block|{
name|max_llm_clock_mhz
operator|=
literal|400
expr_stmt|;
comment|/* Default to 400 MHz */
name|cvmx_dprintf
argument_list|(
literal|"Warning, using default max_rld_clock_mhz of: %lu MHz\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|max_llm_clock_mhz
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the divisor, and round up */
name|clkdiv
operator|=
name|eclk_mhz
operator|/
name|max_llm_clock_mhz
expr_stmt|;
if|if
condition|(
name|clkdiv
operator|*
name|max_llm_clock_mhz
operator|<
name|eclk_mhz
condition|)
name|clkdiv
operator|++
expr_stmt|;
if|if
condition|(
name|clkdiv
operator|>
literal|4
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: CN58XX LLM clock divisor out of range\n"
argument_list|)
expr_stmt|;
goto|goto
name|TERMINATE
goto|;
block|}
if|if
condition|(
name|clkdiv
operator|<
literal|2
condition|)
name|clkdiv
operator|=
literal|2
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Using llm clock divisor: %d, llm clock is: %lu MHz\n"
argument_list|,
name|clkdiv
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|eclk_mhz
operator|/
name|clkdiv
argument_list|)
expr_stmt|;
comment|/* Translate divisor into bit encoding for register */
comment|/* 0 -> div 2         ** 1 -> reserved         ** 2 -> div 3         ** 3 -> div 4         */
if|if
condition|(
name|clkdiv
operator|==
literal|2
condition|)
name|clkdiv_enc
operator|=
literal|0
expr_stmt|;
else|else
name|clkdiv_enc
operator|=
name|clkdiv
operator|-
literal|1
expr_stmt|;
comment|/* Odd divisor needs sil_lat to be 2 */
if|if
condition|(
name|clkdiv
operator|==
literal|0x3
condition|)
name|sil_lat
operator|=
literal|2
expr_stmt|;
comment|/* Increment tskw for high clock speeds */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|eclk_mhz
operator|/
name|clkdiv
operator|>=
literal|375
condition|)
name|tskw_cyc
operator|+=
literal|1
expr_stmt|;
block|}
name|eclk_ps
operator|=
operator|(
literal|1000000
operator|+
operator|(
name|eclk_mhz
operator|-
literal|1
operator|)
operator|)
operator|/
name|eclk_mhz
expr_stmt|;
comment|// round up if nonzero remainder
comment|//=======================================================================
comment|//=======================================================================
comment|// Now, Query User for DFA Memory Type
if|if
condition|(
name|mtype
operator|!=
literal|0
condition|)
block|{
goto|goto
name|TERMINATE
goto|;
comment|// Complete this code for FCRAM usage on N3K-P2
block|}
comment|//=======================================================================
comment|// Query what the tRC(min) value is from the data sheets
comment|//=======================================================================
comment|// Now determine the Best CFG based on Memory clock(ps) and tRCmin(ns)
name|mclk_ps
operator|=
name|eclk_ps
operator|*
name|clkdiv
expr_stmt|;
name|trc_cyc
operator|=
operator|(
operator|(
name|trcmin
operator|*
literal|1000
operator|)
operator|/
name|mclk_ps
operator|)
expr_stmt|;
name|trc_mod
operator|=
operator|(
operator|(
name|trcmin
operator|*
literal|1000
operator|)
operator|%
name|mclk_ps
operator|)
expr_stmt|;
comment|// If remainder exists, bump up to the next integer multiple
if|if
condition|(
name|trc_mod
operator|!=
literal|0
condition|)
block|{
name|trc_cyc
operator|=
name|trc_cyc
operator|+
literal|1
expr_stmt|;
block|}
comment|// If tRC is now ODD, then bump it to the next EVEN integer (RLDRAM-II does not support odd tRC values at this time).
if|if
condition|(
name|trc_cyc
operator|&
literal|1
condition|)
block|{
name|trc_cyc
operator|=
name|trc_cyc
operator|+
literal|1
expr_stmt|;
comment|// Bump it to an even #
block|}
comment|// RLDRAM CFG Range Check: If the computed trc_cyc is less than 4, then set it to min CFG1 [tRC=4]
if|if
condition|(
name|trc_cyc
operator|<
literal|4
condition|)
block|{
name|trc_cyc
operator|=
literal|4
expr_stmt|;
comment|// If computed trc_cyc< 4 then clamp to 4
block|}
elseif|else
if|if
condition|(
name|trc_cyc
operator|>
literal|8
condition|)
block|{
comment|// If the computed trc_cyc> 8, then report an error (because RLDRAM cannot support a tRC>8
goto|goto
name|TERMINATE
goto|;
block|}
comment|// Assuming all is ok(up to here)
comment|// At this point the tRC_cyc has been clamped  between 4 and 8 (and is even), So it can only be 4,6,8 which are
comment|// the RLDRAM valid CFG range values.
name|trl_cyc
operator|=
name|trc_cyc
expr_stmt|;
comment|// tRL = tRC (for RLDRAM=II)
name|twl_cyc
operator|=
name|trl_cyc
operator|+
literal|1
expr_stmt|;
comment|// tWL = tRL + 1 (for RLDRAM-II)
comment|// NOTE: RLDRAM-II (as of 4/25/05) only have 3 supported CFG encodings:
if|if
condition|(
name|trc_cyc
operator|==
literal|4
condition|)
block|{
name|rldcfg
operator|=
literal|1
expr_stmt|;
comment|// CFG #1 (tRL=4/tRC=4/tWL=5)
block|}
elseif|else
if|if
condition|(
name|trc_cyc
operator|==
literal|6
condition|)
block|{
name|rldcfg
operator|=
literal|2
expr_stmt|;
comment|// CFG #2 (tRL=6/tRC=6/tWL=7)
block|}
elseif|else
if|if
condition|(
name|trc_cyc
operator|==
literal|8
condition|)
block|{
name|rldcfg
operator|=
literal|3
expr_stmt|;
comment|// CFG #3 (tRL=8/tRC=8/tWL=9)
block|}
else|else
block|{
goto|goto
name|TERMINATE
goto|;
block|}
comment|//=======================================================================
name|mrs_dat
operator|=
operator|(
operator|(
name|mrs_odt
operator|<<
literal|9
operator|)
operator||
operator|(
name|mrs_impmatch
operator|<<
literal|8
operator|)
operator||
operator|(
name|mrs_dllrst
operator|<<
literal|7
operator|)
operator||
name|rldcfg
operator|)
expr_stmt|;
comment|//=======================================================================
comment|// If there is only a single bunk, then skip over address mapping queries (which are not required)
if|if
condition|(
name|bunkport
operator|==
literal|1
condition|)
block|{
goto|goto
name|CALC_PBUNK
goto|;
block|}
comment|/* Process the address mappings */
comment|/* Note that that RLD0 pins corresponds to Port#1, and     **                RLD1 pins corresponds to Port#0.     */
name|mrs_dat_p1bunk0
operator|=
name|process_address_map_str
argument_list|(
name|mrs_dat
argument_list|,
name|addr_rld0_fb_str
argument_list|)
expr_stmt|;
name|mrs_dat_p1bunk1
operator|=
name|process_address_map_str
argument_list|(
name|mrs_dat
argument_list|,
name|addr_rld0_bb_str
argument_list|)
expr_stmt|;
name|mrs_dat_p0bunk0
operator|=
name|process_address_map_str
argument_list|(
name|mrs_dat
argument_list|,
name|addr_rld1_fb_str
argument_list|)
expr_stmt|;
name|mrs_dat_p0bunk1
operator|=
name|process_address_map_str
argument_list|(
name|mrs_dat
argument_list|,
name|addr_rld1_bb_str
argument_list|)
expr_stmt|;
comment|//=======================================================================
name|CALC_PBUNK
label|:
comment|// Determine the PBUNK field (based on Memory/Bunk)
comment|// This determines the addr bit used to distinguish when crossing a bunk.
comment|// NOTE: For RLDRAM, the bunk bit is extracted from 'a' programmably selected high
comment|// order addr bit. [linear address per-bunk]
if|if
condition|(
name|bunkport
operator|==
literal|2
condition|)
block|{
name|membunk
operator|=
operator|(
name|memport
operator|/
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|membunk
operator|=
name|memport
expr_stmt|;
block|}
if|if
condition|(
name|membunk
operator|==
literal|16
condition|)
block|{
comment|// 16MB/bunk MA[19]
name|pbunk
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|membunk
operator|==
literal|32
condition|)
block|{
comment|// 32MB/bunk MA[20]
name|pbunk
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|membunk
operator|==
literal|64
condition|)
block|{
comment|// 64MB/bunk MA[21]
name|pbunk
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|membunk
operator|==
literal|128
condition|)
block|{
comment|// 128MB/bunk MA[22]
name|pbunk
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|membunk
operator|==
literal|256
condition|)
block|{
comment|// 256MB/bunk MA[23]
name|pbunk
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|membunk
operator|==
literal|512
condition|)
block|{
comment|// 512MB/bunk
block|}
comment|//=======================================================================
comment|//=======================================================================
comment|//=======================================================================
comment|// Now determine N3K REFINT
name|trefi_ns
operator|=
operator|(
name|tref_ms
operator|*
literal|1000
operator|*
literal|1000
operator|)
operator|/
operator|(
name|rows
operator|*
literal|1024
operator|)
expr_stmt|;
name|ref512int
operator|=
operator|(
operator|(
name|trefi_ns
operator|*
literal|1000
operator|)
operator|/
operator|(
name|eclk_ps
operator|*
literal|512
operator|)
operator|)
expr_stmt|;
name|ref512mod
operator|=
operator|(
operator|(
name|trefi_ns
operator|*
literal|1000
operator|)
operator|%
operator|(
name|eclk_ps
operator|*
literal|512
operator|)
operator|)
expr_stmt|;
comment|//=======================================================================
comment|// Ask about tSKW
if|#
directive|if
literal|0
block|if (tskw_ps ==  0)     {         tskw_cyc = 0;     }     else     {
comment|// CEILING function
block|tskw_cyc = (tskw_ps / eclk_ps);         tskw_mod = (tskw_ps % eclk_ps);         if (tskw_mod != 0)         {
comment|// If there's a remainder - then bump to next (+1)
block|tskw_cyc = tskw_cyc + 1;         }     }
endif|#
directive|endif
if|if
condition|(
name|tskw_cyc
operator|>
literal|3
condition|)
block|{
goto|goto
name|TERMINATE
goto|;
block|}
name|tbl
operator|=
literal|1
expr_stmt|;
comment|// BLEN=2 (ALWAYs for RLDRAM)
comment|//=======================================================================
comment|// RW_DLY = (ROUND_UP{[[(TRL+TBL)*2 + tSKW + BPRCH] + 1] / 2}) - tWL
name|rw_dly
operator|=
operator|(
operator|(
operator|(
operator|(
name|trl_cyc
operator|+
name|tbl
operator|)
operator|*
literal|2
operator|+
name|tskw_cyc
operator|+
name|bprch
operator|)
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|rw_dly
operator|&
literal|1
condition|)
block|{
comment|// If it's ODD then round up
name|rw_dly
operator|=
name|rw_dly
operator|+
literal|1
expr_stmt|;
block|}
name|rw_dly
operator|=
name|rw_dly
operator|-
name|twl_cyc
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rw_dly
operator|<
literal|0
condition|)
block|{
comment|// range check - is it positive
goto|goto
name|TERMINATE
goto|;
block|}
comment|//=======================================================================
comment|// WR_DLY = (ROUND_UP[[(tWL + tBL)*2 - tSKW + FPRCH] / 2]) - tRL
name|wr_dly
operator|=
operator|(
operator|(
operator|(
name|twl_cyc
operator|+
name|tbl
operator|)
operator|*
literal|2
operator|-
name|tskw_cyc
operator|+
name|fprch
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|wr_dly
operator|&
literal|1
condition|)
block|{
comment|// If it's ODD then round up
name|wr_dly
operator|=
name|wr_dly
operator|+
literal|1
expr_stmt|;
block|}
name|wr_dly
operator|=
name|wr_dly
operator|-
name|trl_cyc
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|wr_dly
operator|<
literal|0
condition|)
block|{
comment|// range check - is it positive
goto|goto
name|TERMINATE
goto|;
block|}
name|dfa_memcfg0_base
operator|=
literal|0
expr_stmt|;
name|dfa_memcfg0_base
operator|=
operator|(
name|p0_ena
operator||
operator|(
name|p1_ena
operator|<<
literal|1
operator|)
operator||
operator|(
name|mtype
operator|<<
literal|3
operator|)
operator||
operator|(
name|sil_lat
operator|<<
literal|4
operator|)
operator||
operator|(
name|rw_dly
operator|<<
literal|6
operator|)
operator||
operator|(
name|wr_dly
operator|<<
literal|10
operator|)
operator||
operator|(
name|fprch
operator|<<
literal|14
operator|)
operator||
operator|(
name|bprch
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0
operator|<<
literal|18
operator|)
operator||
comment|// BLEN=0(2-burst for RLDRAM)
operator|(
name|pbunk
operator|<<
literal|19
operator|)
operator||
operator|(
name|r2r
operator|<<
literal|22
operator|)
operator||
comment|// R2R=1
operator|(
name|clkdiv_enc
operator|<<
literal|28
operator|)
operator|)
expr_stmt|;
name|dfa_memcfg1_base
operator|=
literal|0
expr_stmt|;
name|dfa_memcfg1_base
operator|=
operator|(
name|ref512int
operator||
operator|(
name|tskw_cyc
operator|<<
literal|4
operator|)
operator||
operator|(
name|trl_cyc
operator|<<
literal|8
operator|)
operator||
operator|(
name|twl_cyc
operator|<<
literal|12
operator|)
operator||
operator|(
name|trc_cyc
operator|<<
literal|16
operator|)
operator||
operator|(
name|tmrsc_cyc
operator|<<
literal|20
operator|)
operator|)
expr_stmt|;
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
operator|=
name|dfa_memcfg0_base
expr_stmt|;
name|cfg_ptr
operator|->
name|dfa_memcfg1_base
operator|=
name|dfa_memcfg1_base
expr_stmt|;
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk0
operator|=
name|mrs_dat_p0bunk0
expr_stmt|;
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk0
operator|=
name|mrs_dat_p1bunk0
expr_stmt|;
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk1
operator|=
name|mrs_dat_p0bunk1
expr_stmt|;
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk1
operator|=
name|mrs_dat_p1bunk1
expr_stmt|;
name|cfg_ptr
operator|->
name|p0_ena
operator|=
name|p0_ena
expr_stmt|;
name|cfg_ptr
operator|->
name|p1_ena
operator|=
name|p1_ena
expr_stmt|;
name|cfg_ptr
operator|->
name|bunkport
operator|=
name|bunkport
expr_stmt|;
comment|//=======================================================================
return|return
operator|(
literal|0
operator|)
return|;
name|TERMINATE
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|process_address_map_str
parameter_list|(
name|uint32_t
name|mrs_dat
parameter_list|,
name|char
modifier|*
name|addr_str
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|amap
index|[
literal|23
index|]
decl_stmt|;
name|uint32_t
name|new_mrs_dat
init|=
literal|0
decl_stmt|;
comment|//    cvmx_dprintf("mrs_dat: 0x%x, str: %x\n", mrs_dat, addr_str);
name|char
modifier|*
name|charptr
init|=
name|strtok
argument_list|(
name|addr_str
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|charptr
operator|!=
name|NULL
operator|)
operator|&
operator|(
name|count
operator|<=
literal|22
operator|)
condition|)
block|{
name|amap
index|[
literal|22
operator|-
name|count
index|]
operator|=
name|atoi
argument_list|(
name|charptr
argument_list|)
expr_stmt|;
comment|// Assign the AMAP Array
name|charptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|// Get Next char string (which represents next addr bit mapping)
name|count
operator|++
expr_stmt|;
block|}
comment|// Now do the bit swap of MRSDAT (based on address mapping)
name|uint32_t
name|mrsdat_bit
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<=
literal|22
condition|;
name|count
operator|++
control|)
block|{
name|mrsdat_bit
operator|=
name|bit_extract
argument_list|(
name|mrs_dat
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|new_mrs_dat
operator|=
name|bit_insert
argument_list|(
name|mrsdat_bit
argument_list|,
name|amap
index|[
name|count
index|]
argument_list|,
name|new_mrs_dat
argument_list|)
expr_stmt|;
block|}
return|return
name|new_mrs_dat
return|;
block|}
end_function

begin_comment
comment|//#define PRINT_LLM_CONFIG
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PRINT_LLM_CONFIG
end_ifdef

begin_define
define|#
directive|define
name|ll_printf
value|printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ll_printf
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|cvmx_csr_db_decode
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|cn31xx_dfa_memory_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
condition|)
block|{
name|cvmx_dfa_ddr2_cfg_t
name|dfaCfg
decl_stmt|;
name|cvmx_dfa_eclkcfg_t
name|dfaEcklCfg
decl_stmt|;
name|cvmx_dfa_ddr2_addr_t
name|dfaAddr
decl_stmt|;
name|cvmx_dfa_ddr2_tmg_t
name|dfaTmg
decl_stmt|;
name|cvmx_dfa_ddr2_pll_t
name|dfaPll
decl_stmt|;
name|int
name|mem_freq_hz
init|=
literal|533
operator|*
literal|1000000
decl_stmt|;
name|int
name|ref_freq_hz
init|=
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|dfa_ref_clock_hz
decl_stmt|;
if|if
condition|(
operator|!
name|ref_freq_hz
condition|)
name|ref_freq_hz
operator|=
literal|33
operator|*
literal|1000000
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Configuring DFA memory for %d MHz operation.\n"
argument_list|,
name|mem_freq_hz
operator|/
literal|1000000
argument_list|)
expr_stmt|;
comment|/* Turn on the DFA memory port. */
name|dfaCfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_DDR2_CFG
argument_list|)
expr_stmt|;
name|dfaCfg
operator|.
name|s
operator|.
name|prtena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_CFG
argument_list|,
name|dfaCfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Start the PLL alignment sequence */
name|dfaPll
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|dfaPll
operator|.
name|s
operator|.
name|pll_ratio
operator|=
name|mem_freq_hz
operator|/
name|ref_freq_hz
comment|/*400Mhz / 33MHz*/
expr_stmt|;
name|dfaPll
operator|.
name|s
operator|.
name|pll_div2
operator|=
literal|1
comment|/*400 - 1 */
expr_stmt|;
name|dfaPll
operator|.
name|s
operator|.
name|pll_bypass
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_PLL
argument_list|,
name|dfaPll
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dfaPll
operator|.
name|s
operator|.
name|pll_init
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_PLL
argument_list|,
name|dfaPll
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
comment|//want 150uS
name|dfaPll
operator|.
name|s
operator|.
name|qdll_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_PLL
argument_list|,
name|dfaPll
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
comment|//want 10us
name|dfaEcklCfg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|dfaEcklCfg
operator|.
name|s
operator|.
name|dfa_frstn
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ECLKCFG
argument_list|,
name|dfaEcklCfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Configure the DFA Memory */
name|dfaCfg
operator|.
name|s
operator|.
name|silo_hc
operator|=
literal|1
comment|/*400 - 1 */
expr_stmt|;
name|dfaCfg
operator|.
name|s
operator|.
name|silo_qc
operator|=
literal|0
comment|/*400 - 0 */
expr_stmt|;
name|dfaCfg
operator|.
name|s
operator|.
name|tskw
operator|=
literal|1
comment|/*400 - 1 */
expr_stmt|;
name|dfaCfg
operator|.
name|s
operator|.
name|ref_int
operator|=
literal|0x820
comment|/*533 - 0x820  400 - 0x618*/
expr_stmt|;
name|dfaCfg
operator|.
name|s
operator|.
name|trfc
operator|=
literal|0x1A
comment|/*533 - 0x23   400 - 0x1A*/
expr_stmt|;
name|dfaCfg
operator|.
name|s
operator|.
name|fprch
operator|=
literal|0
expr_stmt|;
comment|/* 1 more conservative*/
name|dfaCfg
operator|.
name|s
operator|.
name|bprch
operator|=
literal|0
expr_stmt|;
comment|/* 1 */
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_CFG
argument_list|,
name|dfaCfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dfaEcklCfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ECLKCFG
argument_list|)
expr_stmt|;
name|dfaEcklCfg
operator|.
name|s
operator|.
name|maxbnk
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ECLKCFG
argument_list|,
name|dfaEcklCfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dfaAddr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_DDR2_ADDR
argument_list|)
expr_stmt|;
name|dfaAddr
operator|.
name|s
operator|.
name|num_cols
operator|=
literal|0x1
expr_stmt|;
name|dfaAddr
operator|.
name|s
operator|.
name|num_colrows
operator|=
literal|0x2
expr_stmt|;
name|dfaAddr
operator|.
name|s
operator|.
name|num_rnks
operator|=
literal|0x1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_ADDR
argument_list|,
name|dfaAddr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dfaTmg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_DDR2_TMG
argument_list|)
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|ddr2t
operator|=
literal|0
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|tmrd
operator|=
literal|0x2
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|caslat
operator|=
literal|0x4
comment|/*400 - 0x3, 500 - 0x4*/
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|pocas
operator|=
literal|0
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|addlat
operator|=
literal|0
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|trcd
operator|=
literal|4
comment|/*400 - 3, 500 - 4*/
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|trrd
operator|=
literal|2
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|tras
operator|=
literal|0xB
comment|/*400 - 8, 500 - 0xB*/
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|trp
operator|=
literal|4
comment|/*400 - 3, 500 - 4*/
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|twr
operator|=
literal|4
comment|/*400 - 3, 500 - 4*/
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|twtr
operator|=
literal|2
comment|/*400 - 2 */
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|tfaw
operator|=
literal|0xE
comment|/*400 - 0xA, 500 - 0xE*/
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|r2r_slot
operator|=
literal|0
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|dic
operator|=
literal|0
expr_stmt|;
comment|/*400 - 0 */
name|dfaTmg
operator|.
name|s
operator|.
name|dqsn_ena
operator|=
literal|0
expr_stmt|;
name|dfaTmg
operator|.
name|s
operator|.
name|odt_rtt
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_TMG
argument_list|,
name|dfaTmg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Turn on the DDR2 interface and wait a bit for the hardware to setup. */
name|dfaCfg
operator|.
name|s
operator|.
name|init
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_DDR2_CFG
argument_list|,
name|dfaCfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
comment|// want at least 64K cycles
block|}
block|}
end_function

begin_function
name|void
name|write_rld_cfg
parameter_list|(
name|rldram_csr_config_t
modifier|*
name|cfg_ptr
parameter_list|)
block|{
name|cvmx_dfa_memcfg0_t
name|memcfg0
decl_stmt|;
name|cvmx_dfa_memcfg2_t
name|memcfg2
decl_stmt|;
name|memcfg0
operator|.
name|u64
operator|=
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
expr_stmt|;
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
block|{
name|uint32_t
name|dfa_memcfg0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
comment|// Set RLDQK90_RST and RDLCK_RST to reset all three DLLs.
name|memcfg0
operator|.
name|s
operator|.
name|rldck_rst
operator|=
literal|1
expr_stmt|;
name|memcfg0
operator|.
name|s
operator|.
name|rldqck90_rst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  clk/qk90 reset\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// Clear RDLCK_RST while asserting RLDQK90_RST to bring RLDCK DLL out of reset.
name|memcfg0
operator|.
name|s
operator|.
name|rldck_rst
operator|=
literal|0
expr_stmt|;
name|memcfg0
operator|.
name|s
operator|.
name|rldqck90_rst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
comment|/* Wait  */
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  qk90 reset\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// Clear both RDLCK90_RST and RLDQK90_RST to bring the RLDQK90 DLL out of reset.
name|memcfg0
operator|.
name|s
operator|.
name|rldck_rst
operator|=
literal|0
expr_stmt|;
name|memcfg0
operator|.
name|s
operator|.
name|rldqck90_rst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
comment|/* Wait  */
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  DLL out of reset\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|memcfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|//=======================================================================
comment|// Now print out the sequence of events:
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  port enables\n"
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
comment|/* Wait  */
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG1
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg1_base
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG1: 0x%08x\n"
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg1_base
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG1
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg1_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_ptr
operator|->
name|p0_ena
operator|==
literal|1
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMRLD
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMRLD : 0x%08x  p0_ena memrld\n"
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMRLD
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk0
argument_list|)
expr_stmt|;
name|dfa_memcfg0
operator|=
operator|(
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
operator||
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
comment|// P0_INIT
operator|(
literal|1
operator|<<
literal|25
operator|)
comment|// BUNK_INIT[1:0]=Bunk#0
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  p0_init/bunk_init\n"
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"Delay.....\n"
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  back to base\n"
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfg_ptr
operator|->
name|p1_ena
operator|==
literal|1
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMRLD
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMRLD : 0x%08x  p1_ena memrld\n"
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMRLD
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk0
argument_list|)
expr_stmt|;
name|dfa_memcfg0
operator|=
operator|(
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
comment|// P1_INIT
operator|(
literal|1
operator|<<
literal|25
operator|)
comment|// BUNK_INIT[1:0]=Bunk#0
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  p1_init/bunk_init\n"
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"Delay.....\n"
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  back to base\n"
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
block|}
comment|// P0 Bunk#1
if|if
condition|(
operator|(
name|cfg_ptr
operator|->
name|p0_ena
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cfg_ptr
operator|->
name|bunkport
operator|==
literal|2
operator|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMRLD
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk1
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMRLD : 0x%08x  p0_ena memrld\n"
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk1
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMRLD
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p0bunk1
argument_list|)
expr_stmt|;
name|dfa_memcfg0
operator|=
operator|(
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
operator||
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
comment|// P0_INIT
operator|(
literal|2
operator|<<
literal|25
operator|)
comment|// BUNK_INIT[1:0]=Bunk#1
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  p0_init/bunk_init\n"
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"Delay.....\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_ptr
operator|->
name|p1_ena
operator|==
literal|1
condition|)
block|{
comment|// Re-arm Px_INIT if P1-B1 init is required
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  px_init rearm\n"
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cfg_ptr
operator|->
name|p1_ena
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cfg_ptr
operator|->
name|bunkport
operator|==
literal|2
operator|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMRLD
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk1
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMRLD : 0x%08x  p1_ena memrld\n"
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk1
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMRLD
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|cfg_ptr
operator|->
name|mrs_dat_p1bunk1
argument_list|)
expr_stmt|;
name|dfa_memcfg0
operator|=
operator|(
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
comment|// P1_INIT
operator|(
literal|2
operator|<<
literal|25
operator|)
comment|// BUNK_INIT[1:0]=10
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  p1_init/bunk_init\n"
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
block|}
name|cvmx_wait
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
comment|// 1/100S, 0.01S, 10mS
name|ll_printf
argument_list|(
literal|"Delay.....\n"
argument_list|)
expr_stmt|;
comment|/* Enable bunks */
name|dfa_memcfg0
operator|=
name|cfg_ptr
operator|->
name|dfa_memcfg0_base
operator||
operator|(
operator|(
name|cfg_ptr
operator|->
name|bunkport
operator|>=
literal|1
operator|)
operator|<<
literal|25
operator|)
operator||
operator|(
operator|(
name|cfg_ptr
operator|->
name|bunkport
operator|==
literal|2
operator|)
operator|<<
literal|26
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG0
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG0: 0x%08x  enable bunks\n"
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|CVMX_DFA_MEMCFG0
operator|&
operator|~
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|dfa_memcfg0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
name|RLD_INIT_DELAY
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"Delay.....\n"
argument_list|)
expr_stmt|;
comment|/* Issue a Silo reset by toggling SILRST in memcfg2. */
name|memcfg2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_MEMCFG2
argument_list|)
expr_stmt|;
name|memcfg2
operator|.
name|s
operator|.
name|silrst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG2
argument_list|,
name|memcfg2
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG2: 0x%08x  silo reset start\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|memcfg2
operator|.
name|u64
argument_list|)
expr_stmt|;
name|memcfg2
operator|.
name|s
operator|.
name|silrst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_MEMCFG2
argument_list|,
name|memcfg2
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ll_printf
argument_list|(
literal|"CVMX_DFA_MEMCFG2: 0x%08x  silo reset done\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|memcfg2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

