begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      *	functions to help pi put out      *	polish postfix binary portable c compiler intermediate code      *	thereby becoming the portable pascal compiler      */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PPC
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"ppc.h"
end_include

begin_comment
comment|/*      *	extract from pi's format      */
end_comment

begin_define
define|#
directive|define
name|FROMPI
parameter_list|(
name|nth
parameter_list|,
name|word
parameter_list|)
value|( ( ( word )>> ( (nth) * 8 ) )& 0377 )
end_define

begin_comment
comment|/*      *	mash into f77's format      */
end_comment

begin_define
define|#
directive|define
name|TOF77
parameter_list|(
name|fop
parameter_list|,
name|val
parameter_list|,
name|rest
parameter_list|)
value|( ( ( (rest)& 0177777 )<< 16 ) \ 					| ( ( (val)& 0377 )<< 8 )	 \ 					| ( (fop)& 0377 ) )
end_define

begin_escape
end_escape

begin_comment
comment|/*      *	this version of put generates stephen c johnson intermediate code      *	as modified for the fortran77 compiler, to be both      *	binary and postfix.      *	it still uses the address of its argument      *	as the address of its (variable length) argument list.      *	the name is changed by a #define for the ctags program.      */
end_comment

begin_define
define|#
directive|define
name|ppcput
value|put
end_define

begin_macro
name|ppcput
argument_list|(
argument|arglist
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|argp
decl_stmt|;
name|int
name|narg
decl_stmt|;
name|int
name|op
decl_stmt|;
name|int
name|subop
decl_stmt|;
comment|/* 	     * are we not generating code? 	     */
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|argp
operator|=
operator|&
name|arglist
expr_stmt|;
name|narg
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|op
operator|=
name|FROMPI
argument_list|(
literal|0
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
name|subop
operator|=
name|FROMPI
argument_list|(
literal|1
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"#		[put] op = 0%o subop = %d argp[1] = %d"
argument_list|,
name|op
argument_list|,
name|subop
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
comment|/* 		 * panic( "[put] op" ); 		 */
name|putprintf
argument_list|(
literal|"#		[put] op ignored"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LV
case|:
name|putLV
argument_list|(
name|subop
operator|>>
literal|1
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|,
name|P2PTR
operator||
name|P2INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RV1
case|:
case|case
name|O_RV2
case|:
case|case
name|O_RV4
case|:
case|case
name|O_RV8
case|:
name|putRV
argument_list|(
name|op
argument_list|,
name|subop
operator|>>
literal|1
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RV
case|:
name|putRV
argument_list|(
name|op
argument_list|,
name|subop
operator|>>
literal|1
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|,
name|argp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CON1
case|:
case|case
name|O_CON2
case|:
case|case
name|O_CON4
case|:
name|putCON
argument_list|(
name|op
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CON8
case|:
name|putCON
argument_list|(
name|op
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
operator|&
name|argp
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_AS21
case|:
case|case
name|O_AS41
case|:
case|case
name|O_AS2
case|:
case|case
name|O_AS42
case|:
case|case
name|O_AS24
case|:
case|case
name|O_AS4
case|:
case|case
name|O_AS28
case|:
case|case
name|O_AS48
case|:
case|case
name|O_AS8
case|:
name|putAS
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_AS
case|:
name|putAS
argument_list|(
name|op
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ADD2
case|:
case|case
name|O_ADD42
case|:
case|case
name|O_ADD82
case|:
case|case
name|O_ADD24
case|:
case|case
name|O_ADD4
case|:
case|case
name|O_ADD84
case|:
case|case
name|O_ADD28
case|:
case|case
name|O_ADD48
case|:
case|case
name|O_ADD8
case|:
name|putADD
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SUB2
case|:
case|case
name|O_SUB42
case|:
case|case
name|O_SUB82
case|:
case|case
name|O_SUB24
case|:
case|case
name|O_SUB4
case|:
case|case
name|O_SUB84
case|:
case|case
name|O_SUB28
case|:
case|case
name|O_SUB48
case|:
case|case
name|O_SUB8
case|:
name|putSUB
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_MUL2
case|:
case|case
name|O_MUL42
case|:
case|case
name|O_MUL82
case|:
case|case
name|O_MUL24
case|:
case|case
name|O_MUL4
case|:
case|case
name|O_MUL84
case|:
case|case
name|O_MUL28
case|:
case|case
name|O_MUL48
case|:
case|case
name|O_MUL8
case|:
name|putMUL
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_DVD2
case|:
case|case
name|O_DVD42
case|:
case|case
name|O_DVD82
case|:
case|case
name|O_DVD24
case|:
case|case
name|O_DVD4
case|:
case|case
name|O_DVD84
case|:
case|case
name|O_DVD28
case|:
case|case
name|O_DVD48
case|:
case|case
name|O_DVD8
case|:
name|putDVD
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_DIV2
case|:
case|case
name|O_DIV42
case|:
case|case
name|O_DIV24
case|:
case|case
name|O_DIV4
case|:
name|putDIV
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_MOD2
case|:
case|case
name|O_MOD42
case|:
case|case
name|O_MOD24
case|:
case|case
name|O_MOD4
case|:
name|putMOD
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|putLV
argument_list|(
argument|level
argument_list|,
argument|offset
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|level
operator|==
name|cbn
condition|)
block|{
name|putleaf
argument_list|(
name|P2REG
argument_list|,
literal|0
argument_list|,
name|P2FP
argument_list|,
name|P2PTR
operator||
name|P2INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
name|level
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|P2PTR
operator||
name|P2INT
argument_list|,
literal|"_display"
argument_list|)
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|P2INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2PLUS
argument_list|,
name|P2PTR
operator||
name|P2INT
argument_list|)
expr_stmt|;
name|putop
argument_list|(
argument|P2UNARY P2MUL
argument_list|,
argument|type
argument_list|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/*      *	an operand, given its level and offset,       *	and its length if it is other than 1, 2, 4, or 8      */
end_comment

begin_macro
name|putRV
argument_list|(
argument|op
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"putRV"
argument_list|)
expr_stmt|;
case|case
name|O_RV
case|:
comment|/* 		 * no structures, yet 		 */
name|panic
argument_list|(
literal|"putRV O_RV"
argument_list|)
expr_stmt|;
case|case
name|O_RV1
case|:
name|type
operator|=
name|P2CHAR
expr_stmt|;
break|break;
case|case
name|O_RV2
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_RV4
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_RV8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
name|putLV
argument_list|(
name|level
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putCON
argument_list|(
argument|op
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_CON1
case|:
name|type
operator|=
name|P2CHAR
expr_stmt|;
break|break;
case|case
name|O_CON2
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_CON4
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_CON8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|!=
name|P2DOUBLE
condition|)
block|{
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"D%d"
argument_list|,
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
name|puttext
argument_list|(
literal|"	.data"
argument_list|)
expr_stmt|;
name|puttext
argument_list|(
literal|"	.align 2"
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"%s:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.double 0d%.20e"
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
operator|&
name|value
operator|)
argument_list|)
expr_stmt|;
name|puttext
argument_list|(
literal|"	.text"
argument_list|)
expr_stmt|;
name|puttext
argument_list|(
literal|"	.align 1"
argument_list|)
expr_stmt|;
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|P2DOUBLE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	generate an assignment      *	given the length of the destination if not 1, 2, 4, or 8      */
end_comment

begin_macro
name|putAS
argument_list|(
argument|op
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"[putAS]"
argument_list|)
expr_stmt|;
case|case
name|O_AS
case|:
comment|/* 		 * no structures, yet 		 */
name|panic
argument_list|(
literal|"[putAS] O_AS"
argument_list|)
expr_stmt|;
case|case
name|O_AS21
case|:
case|case
name|O_AS41
case|:
name|type
operator|=
name|P2CHAR
expr_stmt|;
break|break;
case|case
name|O_AS2
case|:
case|case
name|O_AS42
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_AS24
case|:
case|case
name|O_AS4
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_AS28
case|:
case|case
name|O_AS48
case|:
case|case
name|O_AS8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
name|putop
argument_list|(
name|P2ASSIGN
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	the various additions      */
end_comment

begin_macro
name|putADD
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_ADD2
case|:
case|case
name|O_ADD42
case|:
case|case
name|O_ADD82
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_ADD24
case|:
case|case
name|O_ADD4
case|:
case|case
name|O_ADD84
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_ADD28
case|:
case|case
name|O_ADD48
case|:
case|case
name|O_ADD8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
name|putop
argument_list|(
name|P2PLUS
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	the various subtractions      */
end_comment

begin_macro
name|putSUB
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_SUB2
case|:
case|case
name|O_SUB42
case|:
case|case
name|O_SUB82
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_SUB24
case|:
case|case
name|O_SUB4
case|:
case|case
name|O_SUB84
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_SUB28
case|:
case|case
name|O_SUB48
case|:
case|case
name|O_SUB8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
name|putop
argument_list|(
name|P2MINUS
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	the various multiplications      */
end_comment

begin_macro
name|putMUL
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_MUL2
case|:
case|case
name|O_MUL42
case|:
case|case
name|O_MUL82
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_MUL24
case|:
case|case
name|O_MUL4
case|:
case|case
name|O_MUL84
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_MUL28
case|:
case|case
name|O_MUL48
case|:
case|case
name|O_MUL8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
name|putop
argument_list|(
name|P2MUL
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	the various divisions (floating results)      */
end_comment

begin_macro
name|putDVD
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_DVD2
case|:
case|case
name|O_DVD42
case|:
case|case
name|O_DVD82
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_DVD24
case|:
case|case
name|O_DVD4
case|:
case|case
name|O_DVD84
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
case|case
name|O_DVD28
case|:
case|case
name|O_DVD48
case|:
case|case
name|O_DVD8
case|:
name|type
operator|=
name|P2DOUBLE
expr_stmt|;
break|break;
block|}
comment|/* 	 * convert the right operand to a double to force floating result 	 *	putop( P2SCONV , P2DOUBLE ); 	 * unfortunately, this doesn't work, and both operands have to 	 * be converted, and it's too late to get the left one. (sigh). 	 * that would work if the left operand were already a double, 	 * but for now ... 	 */
if|if
condition|(
name|op
operator|!=
name|O_DVD8
condition|)
name|panic
argument_list|(
literal|"[putDVD]"
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2DIV
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	the various DIVs (truncated integer results)      */
end_comment

begin_macro
name|putDIV
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_DIV2
case|:
case|case
name|O_DIV42
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_DIV24
case|:
case|case
name|O_DIV4
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
block|}
name|putop
argument_list|(
name|P2DIV
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	the various MODs (truncated integer results)      */
end_comment

begin_macro
name|putMOD
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_MOD2
case|:
case|case
name|O_MOD42
case|:
name|type
operator|=
name|P2SHORT
expr_stmt|;
break|break;
case|case
name|O_MOD24
case|:
case|case
name|O_MOD4
case|:
name|type
operator|=
name|P2LONG
expr_stmt|;
break|break;
block|}
name|putop
argument_list|(
name|P2MOD
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*      *	this returns a unique integer to be made into a label      */
end_comment

begin_function
name|int
name|newlabel
parameter_list|()
block|{
specifier|static
name|lastlabel
operator|=
literal|0
expr_stmt|;
return|return
operator|++
name|lastlabel
return|;
block|}
end_function

begin_comment
comment|/*      *	to round string lengths up to 0 mod 4      */
end_comment

begin_macro
name|str4len
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*      *	emits an ftext operator and a string to the ppcstream      */
end_comment

begin_macro
name|puttext
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|str4len
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|P2FTEXT
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2FTEXT | %d | 0\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|emitstring
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	puts out formatted text to the ppcstream.      *	none of arg1 .. arg5 need be present.      *	and you can add more if you need them.      */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|putprintf
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|puttext
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	emit a left bracket operator to ppcstream      *	with function number, the maximum temp register, and total locals      *	from globals ftnno and sizes[ cbn ]      *	until i figure out how to use them, regs 0 .. 11 are free.      *	one idea for one reg is to save the display pointer on block entry      */
end_comment

begin_macro
name|putlbracket
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|MAXTP2REG
value|11
define|#
directive|define
name|BITSPERBYTE
value|8
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|P2FLBRAC
argument_list|,
name|MAXTP2REG
argument_list|,
name|ftnno
argument_list|)
argument_list|)
expr_stmt|;
name|emitword
argument_list|(
name|BITSPERBYTE
operator|*
operator|-
name|sizes
index|[
name|cbn
index|]
operator|.
name|om_off
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2FLBRAC | %d | %d\n"
argument_list|,
name|MAXTP2REG
argument_list|,
name|ftnno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"%d\n"
argument_list|,
name|BITSPERBYTE
operator|*
operator|-
name|sizes
index|[
name|cbn
index|]
operator|.
name|om_off
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit a right bracket operator      *	which for the binary (fortran) interface      *	doesn't have any (label) arguments,      *	it just forces the stack allocate and register mask      */
end_comment

begin_macro
name|putrbracket
argument_list|()
end_macro

begin_block
block|{
name|emitword
argument_list|(
name|P2FRBRAC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2FRBRAC\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit an eof operator      */
end_comment

begin_macro
name|puteof
argument_list|()
end_macro

begin_block
block|{
name|emitword
argument_list|(
name|P2FEOF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2FEOF\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit a dot operator,      *	with a source file line number and name      *	from globals filename and line      */
end_comment

begin_macro
name|putexpr
argument_list|()
end_macro

begin_block
block|{
name|int
name|length
init|=
name|str4len
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|P2FEXPR
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2FEXPR | %d | %d\n"
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|emitstring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out a leaf node      */
end_comment

begin_macro
name|putleaf
argument_list|(
argument|op
argument_list|,
argument|lval
argument_list|,
argument|rval
argument_list|,
argument|type
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"[putleaf]"
argument_list|)
expr_stmt|;
case|case
name|P2ICON
case|:
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|P2ICON
argument_list|,
name|name
operator|!=
name|NIL
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|emitword
argument_list|(
name|lval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2ICON | %d | %d\n"
argument_list|,
name|name
operator|!=
name|NIL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"%d\n"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|name
condition|)
name|emitname
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2NAME
case|:
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|P2NAME
argument_list|,
name|lval
operator|!=
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
name|emitword
argument_list|(
name|lval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2NAME | %d | %d\n"
argument_list|,
name|lval
operator|!=
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"%d\n"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|emitname
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2REG
case|:
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|P2REG
argument_list|,
name|rval
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"P2REG | %d | %d\n"
argument_list|,
name|rval
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
end_block

begin_comment
comment|/*      *	put a typed operator to the ppcstream      */
end_comment

begin_macro
name|putop
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|emitword
argument_list|(
name|TOF77
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"%d | 0 | %d\n"
argument_list|,
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*      *	puts a long word on the ppcstream      */
end_comment

begin_macro
name|emitword
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|long
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putw
argument_list|(
name|word
argument_list|,
name|ppcstream
argument_list|)
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*      *	put a length 0 mod 4 null padded string onto the ppcstream      *	this would use      *		fprintf( ppcstream , "%*s" , -str4len( string ) , string )      *	except that doesn't work, and also it wants to be padded with nulls.      */
end_comment

begin_macro
name|emitstring
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|wlen
init|=
operator|(
name|slen
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|int
name|plen
init|=
operator|(
name|wlen
operator|*
literal|4
operator|)
operator|-
name|slen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|p
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|ppcstream
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|plen
condition|;
name|p
operator|++
control|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|ppcstream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"\"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|plen
condition|;
name|p
operator|++
control|)
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	puts a blank-padded 8 character name on the ppcstream      */
end_comment

begin_macro
name|emitname
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|ppcstream
argument_list|,
literal|"%-8.8s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppcdebug
condition|)
block|{
name|fprintf
argument_list|(
name|ppcdstream
argument_list|,
literal|"<%-8.8s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PPC
end_endif

end_unit

