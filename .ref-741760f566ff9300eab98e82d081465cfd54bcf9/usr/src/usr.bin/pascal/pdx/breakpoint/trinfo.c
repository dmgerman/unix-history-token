begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)trinfo.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Trace information management.  *  * The trace information is a list of variables that are being  * traced or whose value changing should cause a stop.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"tree/tree.rep"
end_include

begin_comment
comment|/*  * When tracing variables we keep a copy of their most recent value  * and compare it to the current one each time a breakpoint occurs.  * MAXTRSIZE is the maximum size variable we allow.  */
end_comment

begin_define
define|#
directive|define
name|MAXTRSIZE
value|512
end_define

begin_comment
comment|/*  * The tracing structure is a list of information about all the  * variables that are being traced.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|trinfo
block|{
name|TRTYPE
name|trtype
decl_stmt|;
name|ADDRESS
name|traddr
decl_stmt|;
name|SYM
modifier|*
name|trblock
decl_stmt|;
name|NODE
modifier|*
name|trvar
decl_stmt|;
name|NODE
modifier|*
name|trcond
decl_stmt|;
name|char
modifier|*
name|trvalue
decl_stmt|;
name|struct
name|trinfo
modifier|*
name|trnext
decl_stmt|;
block|}
name|TRINFO
typedef|;
end_typedef

begin_decl_stmt
name|LOCAL
name|TRINFO
modifier|*
name|trhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * add a variable to be traced  */
end_comment

begin_macro
name|addvar
argument_list|(
argument|trtype
argument_list|,
argument|node
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|TRTYPE
name|trtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|cond
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TRINFO
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|alloc
argument_list|(
literal|1
argument_list|,
name|TRINFO
argument_list|)
expr_stmt|;
name|tp
operator|->
name|trtype
operator|=
name|trtype
expr_stmt|;
name|tp
operator|->
name|traddr
operator|=
operator|(
name|ADDRESS
operator|)
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|trblock
operator|=
name|curfunc
expr_stmt|;
name|tp
operator|->
name|trvar
operator|=
name|node
expr_stmt|;
name|tp
operator|->
name|trcond
operator|=
name|cond
expr_stmt|;
name|tp
operator|->
name|trvalue
operator|=
name|NIL
expr_stmt|;
name|tp
operator|->
name|trnext
operator|=
name|trhead
expr_stmt|;
name|trhead
operator|=
name|tp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove a variable from the trace list  */
end_comment

begin_macro
name|delvar
argument_list|(
argument|trtype
argument_list|,
argument|node
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|TRTYPE
name|trtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|cond
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TRINFO
modifier|*
name|tp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|trhead
init|;
name|tp
operator|!=
name|NIL
condition|;
name|tp
operator|=
name|tp
operator|->
name|trnext
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|trtype
operator|==
name|trtype
operator|&&
name|tr_equal
argument_list|(
name|tp
operator|->
name|trvar
argument_list|,
name|node
argument_list|)
operator|&&
name|tr_equal
argument_list|(
name|tp
operator|->
name|trcond
argument_list|,
name|cond
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|tp
operator|==
name|NIL
condition|)
block|{
name|trerror
argument_list|(
literal|"can't delete term %t"
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NIL
condition|)
block|{
name|trhead
operator|=
name|tp
operator|->
name|trnext
expr_stmt|;
block|}
else|else
block|{
name|last
operator|->
name|trnext
operator|=
name|tp
operator|->
name|trnext
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|trvalue
operator|!=
name|NIL
condition|)
block|{
name|free
argument_list|(
name|tp
operator|->
name|trvalue
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print out any news about variables in the list whose  * values have changed.  */
end_comment

begin_macro
name|prvarnews
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|TRINFO
modifier|*
name|tp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|SYM
modifier|*
name|s
decl_stmt|;
name|char
name|buff
index|[
name|MAXTRSIZE
index|]
decl_stmt|;
specifier|static
name|LINENO
name|prevline
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|trhead
init|;
name|tp
operator|!=
name|NIL
condition|;
name|tp
operator|=
name|tp
operator|->
name|trnext
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|trcond
operator|!=
name|NIL
operator|&&
operator|!
name|cond
argument_list|(
name|tp
operator|->
name|trcond
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|s
operator|=
name|curfunc
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NIL
operator|&&
name|s
operator|!=
name|tp
operator|->
name|trblock
condition|)
block|{
name|s
operator|=
name|container
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|NIL
condition|)
block|{
continue|continue;
block|}
name|p
operator|=
name|tp
operator|->
name|trvar
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|traddr
operator|==
operator|(
name|ADDRESS
operator|)
operator|-
literal|1
condition|)
block|{
name|tp
operator|->
name|traddr
operator|=
name|lval
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|size
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|dread
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|traddr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|trvalue
operator|==
name|NIL
condition|)
block|{
name|tp
operator|->
name|trvalue
operator|=
name|alloc
argument_list|(
name|n
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|trvalue
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|trtype
operator|==
name|TRPRINT
condition|)
block|{
name|printf
argument_list|(
literal|"initially (at "
argument_list|)
expr_stmt|;
name|printwhere
argument_list|(
name|curline
argument_list|,
name|srcfilename
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"):\t"
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmp
argument_list|(
name|tp
operator|->
name|trvalue
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mov
argument_list|(
name|buff
argument_list|,
name|tp
operator|->
name|trvalue
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|buff
argument_list|,
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"after "
argument_list|)
expr_stmt|;
name|printwhere
argument_list|(
name|prevline
argument_list|,
name|srcfilename
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\t"
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|trtype
operator|==
name|TRSTOP
condition|)
block|{
name|isstopped
operator|=
name|TRUE
expr_stmt|;
name|curline
operator|=
name|srcline
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|prevline
operator|=
name|curline
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Free the table.  Note that trvar and trcond fields are not freed,  * this is because they are the same as in the breakpoint table and  * are freed by the bpfree routine.  */
end_comment

begin_macro
name|trfree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|TRINFO
modifier|*
name|tp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|trhead
init|;
name|tp
operator|!=
name|NIL
condition|;
name|tp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tp
operator|->
name|trnext
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|trvalue
operator|!=
name|NIL
condition|)
block|{
name|free
argument_list|(
name|tp
operator|->
name|trvalue
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|trhead
operator|=
name|NIL
expr_stmt|;
block|}
end_block

end_unit

