begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pk0.c	5.7 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|"pk.h"
end_include

begin_comment
comment|/*  * packet driver  */
end_comment

begin_decl_stmt
name|char
name|next
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet sequence numbers */
end_comment

begin_decl_stmt
name|char
name|mask
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|010
block|,
literal|020
block|,
literal|040
block|,
literal|0100
block|,
literal|0200
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pack
modifier|*
name|pklines
index|[
name|NPLINES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Reacks
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PKRTIME
value|4
end_define

begin_define
define|#
directive|define
name|PKWTIME
value|4
end_define

begin_define
define|#
directive|define
name|PKRSKEW
value|3
end_define

begin_define
define|#
directive|define
name|PKWSKEW
value|2
end_define

begin_decl_stmt
specifier|extern
name|int
name|pktimeout
decl_stmt|,
name|pktimeskew
decl_stmt|,
name|Ntimeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * receive control messages  */
end_comment

begin_expr_stmt
name|pkcntl
argument_list|(
name|c
argument_list|,
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|cntl
operator|,
name|val
expr_stmt|;
name|val
operator|=
name|c
operator|&
name|MOD8
expr_stmt|;
name|cntl
operator|=
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
name|MOD8
expr_stmt|;
if|if
condition|(
operator|!
name|ISCNTL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|logent
argument_list|(
literal|"PK0"
argument_list|,
literal|"not cntl"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|cntl
condition|)
block|{
case|case
name|INITB
case|:
name|val
operator|++
expr_stmt|;
name|pk
operator|->
name|p_xsize
operator|=
name|pksizes
index|[
name|val
index|]
expr_stmt|;
name|pk
operator|->
name|p_lpsize
operator|=
name|val
expr_stmt|;
name|pk
operator|->
name|p_bits
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_INITC
expr_stmt|;
break|break;
block|}
name|pk
operator|->
name|p_state
operator||=
name|INITb
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|INITa
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|pk
operator|->
name|p_rmsg
operator|&=
operator|~
name|M_INITA
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_INITC
expr_stmt|;
break|break;
case|case
name|INITC
case|:
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|INITab
operator|)
operator|==
name|INITab
condition|)
block|{
name|pk
operator|->
name|p_state
operator|=
name|LIVE
expr_stmt|;
name|pk
operator|->
name|p_rmsg
operator|&=
operator|~
name|M_INITB
expr_stmt|;
block|}
else|else
name|pk
operator|->
name|p_msg
operator||=
name|M_INITB
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|pk
operator|->
name|p_swindow
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|INITA
case|:
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
name|logent
argument_list|(
literal|"PK0"
argument_list|,
literal|"alloc change not implemented"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
condition|)
block|{
name|pk
operator|->
name|p_state
operator||=
name|INITa
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_INITB
expr_stmt|;
name|pk
operator|->
name|p_rmsg
operator||=
name|M_INITB
expr_stmt|;
name|pk
operator|->
name|p_swindow
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|RJ
case|:
name|pk
operator|->
name|p_state
operator||=
name|RXMIT
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
name|pk
operator|->
name|p_rpr
operator|=
name|val
expr_stmt|;
operator|(
name|void
operator|)
name|pksack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
break|break;
case|case
name|RR
case|:
name|pk
operator|->
name|p_rpr
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_rpr
operator|==
name|pk
operator|->
name|p_ps
condition|)
block|{
name|DEBUG
argument_list|(
literal|9
argument_list|,
literal|"Reack count is %d\n"
argument_list|,
operator|++
name|Reacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|Reacks
operator|>=
literal|4
condition|)
block|{
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"Reack overflow on %d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|RXMIT
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
name|Reacks
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|Reacks
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|pksack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SRJ
case|:
name|logent
argument_list|(
literal|"PK0"
argument_list|,
literal|"srj not implemented"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|pk
operator|->
name|p_state
operator|=
name|DOWN
operator|+
name|RCLOSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pkaccept
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|x
operator|,
name|seq
expr_stmt|;
name|char
name|m
decl_stmt|,
name|cntl
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|imask
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|bad
decl_stmt|,
name|accept
decl_stmt|,
name|skip
decl_stmt|,
name|t
decl_stmt|,
name|cc
decl_stmt|;
name|unsigned
name|short
name|sum
decl_stmt|;
name|bad
operator|=
name|accept
operator|=
name|skip
operator|=
literal|0
expr_stmt|;
comment|/* 	 * wait for input 	 */
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|imask
operator|=
name|pk
operator|->
name|p_imap
operator|)
operator|==
literal|0
operator|&&
name|pk
operator|->
name|p_rcount
operator|==
literal|0
condition|)
block|{
name|pkgetpack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
name|pk
operator|->
name|p_imap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * determine input window in m. 	 */
name|t
operator|=
operator|(
operator|~
operator|(
operator|-
literal|1
operator|<<
call|(
name|int
call|)
argument_list|(
name|pk
operator|->
name|p_rwindow
argument_list|)
operator|)
operator|)
operator|<<
name|x
expr_stmt|;
name|m
operator|=
name|t
expr_stmt|;
name|m
operator||=
name|t
operator|>>
literal|8
expr_stmt|;
comment|/* 	 * mark newly accepted input buffers 	 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|imask
operator|&
name|mask
index|[
name|x
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cntl
operator|=
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|)
operator|&
literal|0200
operator|)
operator|==
literal|0
condition|)
block|{
name|bad
operator|++
expr_stmt|;
name|free
label|:
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
operator|~
operator|(
name|B_COPY
operator|+
name|B_MARK
operator|)
expr_stmt|;
name|sum
operator|=
operator|(
name|unsigned
operator|)
name|chksum
argument_list|(
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
argument_list|,
name|pk
operator|->
name|p_rsize
argument_list|)
operator|^
call|(
name|unsigned
call|)
argument_list|(
name|cntl
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|CHECK
condition|)
block|{
name|seq
operator|=
operator|(
name|cntl
operator|>>
literal|3
operator|)
operator|&
name|MOD8
expr_stmt|;
if|if
condition|(
name|m
operator|&
name|mask
index|[
name|seq
index|]
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
operator|&
operator|(
name|B_COPY
operator||
name|B_MARK
operator|)
condition|)
block|{
name|dup
label|:
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
name|skip
operator|++
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|x
operator|!=
name|seq
condition|)
block|{
name|p
operator|=
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
operator|=
name|pk
operator|->
name|p_ib
index|[
name|seq
index|]
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|seq
index|]
operator|=
name|p
expr_stmt|;
block|}
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
operator|=
name|B_MARK
expr_stmt|;
name|accept
operator|++
expr_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cntl
operator|&
name|B_SHORT
condition|)
block|{
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
operator|=
name|B_MARK
operator|+
name|B_SHORT
expr_stmt|;
name|p
operator|=
name|pk
operator|->
name|p_ib
index|[
name|seq
index|]
expr_stmt|;
name|cc
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
name|cc
operator|&
literal|0200
condition|)
block|{
name|cc
operator|&=
literal|0177
expr_stmt|;
name|cc
operator||=
operator|*
name|p
operator|<<
literal|7
expr_stmt|;
block|}
block|}
name|pk
operator|->
name|p_isum
index|[
name|seq
index|]
operator|=
name|pk
operator|->
name|p_rsize
operator|-
name|cc
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|dup
goto|;
block|}
block|}
else|else
block|{
name|bad
operator|++
expr_stmt|;
goto|goto
name|free
goto|;
block|}
block|}
comment|/* 	 * scan window again turning marked buffers into 	 * COPY buffers and looking for missing sequence 	 * numbers. 	 */
name|accept
operator|=
literal|0
expr_stmt|;
name|t
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
init|;
name|m
operator|&
name|mask
index|[
name|x
index|]
condition|;
name|x
operator|=
name|next
index|[
name|x
index|]
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|&
name|B_MARK
condition|)
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator||=
name|B_COPY
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|&
name|B_COPY
condition|)
block|{
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
else|else
name|accept
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|t
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_RJ
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
block|}
name|pk
operator|->
name|p_rcount
operator|=
name|accept
expr_stmt|;
return|return
name|accept
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|pkread
argument_list|(
name|pk
argument_list|,
name|ibuf
argument_list|,
name|icount
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|x
expr_stmt|;
name|int
name|is
decl_stmt|,
name|cc
decl_stmt|,
name|xfr
decl_stmt|,
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|;
name|xfr
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|pktimeout
operator|=
name|PKRTIME
expr_stmt|;
name|pktimeskew
operator|=
name|PKRSKEW
expr_stmt|;
name|Ntimeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pkaccept
argument_list|(
name|pk
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|icount
condition|)
block|{
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
name|is
operator|=
name|pk
operator|->
name|p_is
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|&
name|B_COPY
condition|)
block|{
name|cc
operator|=
name|MIN
argument_list|(
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
argument_list|,
name|icount
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
operator|&&
name|xfr
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|is
operator|&
name|B_RESID
condition|)
name|cp
operator|=
name|pk
operator|->
name|p_rptr
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|&
name|B_SHORT
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|&
literal|0200
condition|)
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|pkmove
argument_list|(
name|cp
argument_list|,
name|ibuf
argument_list|,
name|cc
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
name|ibuf
operator|+=
name|cc
expr_stmt|;
name|icount
operator|-=
name|cc
expr_stmt|;
name|count
operator|+=
name|cc
expr_stmt|;
name|xfr
operator|++
expr_stmt|;
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|-=
name|cc
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|pk
operator|->
name|p_pr
operator|=
name|x
expr_stmt|;
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_rcount
operator|--
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
block|}
else|else
block|{
name|pk
operator|->
name|p_rptr
operator|=
name|cp
operator|+
name|cc
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator||=
name|B_RESID
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
break|break;
block|}
else|else
break|break;
block|}
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|pkwrite
argument_list|(
name|pk
argument_list|,
name|ibuf
argument_list|,
name|icount
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|x
expr_stmt|;
name|int
name|partial
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|fc
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DOWN
operator|||
operator|!
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|pktimeout
operator|=
name|PKWTIME
expr_stmt|;
name|pktimeskew
operator|=
name|PKWSKEW
expr_stmt|;
name|Ntimeout
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|icount
expr_stmt|;
do|do
block|{
while|while
condition|(
name|pk
operator|->
name|p_xcount
operator|>=
name|pk
operator|->
name|p_swindow
condition|)
block|{
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|pkgetpack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pscopy
index|]
expr_stmt|;
while|while
condition|(
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|!=
name|B_NULL
condition|)
block|{
name|pkgetpack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|=
name|B_MARK
expr_stmt|;
name|pk
operator|->
name|p_pscopy
operator|=
name|x
expr_stmt|;
name|pk
operator|->
name|p_xcount
operator|++
expr_stmt|;
name|cp
operator|=
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|pk
operator|->
name|p_xsize
argument_list|)
expr_stmt|;
name|partial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|icount
operator|<
name|pk
operator|->
name|p_xsize
condition|)
block|{
name|cc
operator|=
name|icount
expr_stmt|;
name|fc
operator|=
name|pk
operator|->
name|p_xsize
operator|-
name|cc
expr_stmt|;
operator|*
name|cp
operator|=
name|fc
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|fc
operator|>
literal|127
condition|)
block|{
operator|*
name|cp
operator|++
operator||=
literal|0200
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|fc
operator|>>
literal|7
expr_stmt|;
block|}
else|else
name|cp
operator|++
expr_stmt|;
name|partial
operator|=
name|B_SHORT
expr_stmt|;
block|}
else|else
name|cc
operator|=
name|pk
operator|->
name|p_xsize
expr_stmt|;
name|pkmove
argument_list|(
name|cp
argument_list|,
name|ibuf
argument_list|,
name|cc
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
name|ibuf
operator|+=
name|cc
expr_stmt|;
name|icount
operator|-=
name|cc
expr_stmt|;
name|pk
operator|->
name|p_osum
index|[
name|x
index|]
operator|=
name|chksum
argument_list|(
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
argument_list|,
name|pk
operator|->
name|p_xsize
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|=
name|B_READY
operator|+
name|partial
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|icount
condition|)
do|;
return|return
name|count
return|;
block|}
end_block

begin_expr_stmt
name|pksack
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|x
operator|,
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|pk
operator|->
name|p_ps
init|;
name|x
operator|!=
name|pk
operator|->
name|p_rpr
condition|;
control|)
block|{
name|x
operator|=
name|next
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|&
name|B_SENT
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|=
name|B_NULL
expr_stmt|;
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|WAITO
expr_stmt|;
name|pk
operator|->
name|p_xcount
operator|--
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_ps
operator|=
name|x
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_block

begin_expr_stmt
name|pkoutput
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|x
expr_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|bstate
decl_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_obusy
operator|++
condition|)
block|{
name|pk
operator|->
name|p_obusy
operator|--
expr_stmt|;
return|return;
block|}
comment|/* 	 * find seq number and buffer state 	 * of next output packet 	 */
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|RXMIT
condition|)
block|{
name|pk
operator|->
name|p_nxtps
operator|=
name|next
index|[
name|pk
operator|->
name|p_rpr
index|]
expr_stmt|;
block|}
name|x
operator|=
name|pk
operator|->
name|p_nxtps
expr_stmt|;
name|bstate
operator|=
name|pk
operator|->
name|p_os
index|[
name|x
index|]
expr_stmt|;
comment|/* 	 * Send control packet if indicated 	 */
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_msg
operator|&
operator|~
name|M_RR
operator|||
operator|!
operator|(
name|bstate
operator|&
name|B_READY
operator|)
condition|)
block|{
name|x
operator|=
name|pk
operator|->
name|p_msg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|x
operator|&
literal|1
condition|)
break|break;
else|else
name|x
operator|>>=
literal|1
expr_stmt|;
name|x
operator|=
name|i
expr_stmt|;
name|x
operator|<<=
literal|3
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|CLOSE
case|:
break|break;
case|case
name|RJ
case|:
case|case
name|RR
case|:
name|x
operator|+=
name|pk
operator|->
name|p_pr
expr_stmt|;
break|break;
case|case
name|SRJ
case|:
break|break;
case|case
name|INITB
case|:
name|x
operator|+=
name|pksize
argument_list|(
name|pk
operator|->
name|p_rsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITC
case|:
name|x
operator|+=
name|pk
operator|->
name|p_rwindow
expr_stmt|;
break|break;
case|case
name|INITA
case|:
name|x
operator|+=
name|pk
operator|->
name|p_rwindow
expr_stmt|;
break|break;
block|}
name|pk
operator|->
name|p_msg
operator|&=
operator|~
name|mask
index|[
name|i
index|]
expr_stmt|;
name|pkxstart
argument_list|(
name|pk
argument_list|,
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Don't send data packets if line is marked dead. 	 */
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DOWN
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Start transmission (or retransmission) of data packets. 	 */
if|if
condition|(
name|bstate
operator|&
operator|(
name|B_READY
operator||
name|B_SENT
operator|)
condition|)
block|{
name|char
name|seq
decl_stmt|;
name|bstate
operator||=
name|B_SENT
expr_stmt|;
name|seq
operator|=
name|x
expr_stmt|;
name|pk
operator|->
name|p_nxtps
operator|=
name|next
index|[
name|x
index|]
expr_stmt|;
name|x
operator|=
literal|0200
operator|+
name|pk
operator|->
name|p_pr
operator|+
operator|(
name|seq
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|bstate
operator|&
name|B_SHORT
condition|)
name|x
operator||=
literal|0100
expr_stmt|;
name|pkxstart
argument_list|(
name|pk
argument_list|,
name|x
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_os
index|[
name|seq
index|]
operator|=
name|bstate
expr_stmt|;
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|RXMIT
expr_stmt|;
name|pk
operator|->
name|p_nout
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * enable timeout if there's nothing to send 	 * and transmission buffers are languishing 	 */
if|if
condition|(
name|pk
operator|->
name|p_xcount
condition|)
block|{
name|pk
operator|->
name|p_timer
operator|=
literal|2
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|WAITO
expr_stmt|;
block|}
else|else
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|WAITO
expr_stmt|;
name|out
label|:
name|pk
operator|->
name|p_obusy
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * shut down line by  *	ignoring new input  *	letting output drain  *	releasing space and turning off line discipline  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|pkclose
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|rcheck
init|=
literal|0
decl_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|DRAINO
expr_stmt|;
comment|/* 	 * try to flush output 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_timer
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|pk
operator|->
name|p_xcount
operator|&&
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
operator|(
name|RCLOSE
operator|+
name|DOWN
operator|)
operator|||
operator|++
name|i
operator|>
literal|2
condition|)
break|break;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
name|pk
operator|->
name|p_timer
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|DOWN
expr_stmt|;
comment|/* 	 * try to exchange CLOSE messages 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|RCLOSE
operator|)
operator|==
literal|0
operator|&&
name|i
operator|<
literal|2
condition|)
block|{
name|pk
operator|->
name|p_msg
operator|=
name|M_CLOSE
expr_stmt|;
name|pk
operator|->
name|p_timer
operator|=
literal|2
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pklines
index|[
name|i
index|]
operator|==
name|pk
condition|)
block|{
name|pklines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * free space 	 */
name|rcheck
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_os
index|[
name|i
index|]
operator|!=
name|B_NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ob
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_xcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|i
index|]
operator|!=
name|B_NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rcheck
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|pk
operator|->
name|p_ipool
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|*
name|bp
expr_stmt|;
name|rcheck
operator|++
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcheck
operator|!=
name|pk
operator|->
name|p_rwindow
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"PK0: rc %d rw %d"
argument_list|,
name|rcheck
argument_list|,
name|pk
operator|->
name|p_rwindow
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|buf
argument_list|,
literal|"pkclose rcheck != p_rwindow"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pk
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pkreset
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|pk
operator|->
name|p_ps
operator|=
name|pk
operator|->
name|p_pr
operator|=
name|pk
operator|->
name|p_rpr
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_nxtps
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_expr_stmt
name|bzero
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|!BSD4_2
end_endif

begin_expr_stmt
name|pksize
argument_list|(
name|n
argument_list|)
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|k
expr_stmt|;
name|n
operator|>>=
literal|5
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|n
operator|>>=
literal|1
condition|;
name|k
operator|++
control|)
empty_stmt|;
return|return
name|k
return|;
block|}
end_block

end_unit

