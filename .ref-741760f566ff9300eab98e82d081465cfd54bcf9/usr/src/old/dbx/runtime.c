begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)runtime.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: runtime.c,v 1.5 84/12/26 10:41:52 linton Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Runtime organization dependent routines, mostly dealing with  * activation records.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|Frame
modifier|*
name|Frame
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NSAVEREG
value|12
end_define

begin_struct
struct|struct
name|Frame
block|{
name|integer
name|condition_handler
decl_stmt|;
name|integer
name|mask
decl_stmt|;
name|Address
name|save_ap
decl_stmt|;
comment|/* argument pointer */
name|Address
name|save_fp
decl_stmt|;
comment|/* frame pointer */
name|Address
name|save_pc
decl_stmt|;
comment|/* program counter */
name|Word
name|save_reg
index|[
name|NSAVEREG
index|]
decl_stmt|;
comment|/* not necessarily there */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|Frame
name|curframe
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|Frame
name|curframerec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|walkingstack
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|frameeq
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
value|((f1)->save_fp == (f2)->save_fp)
end_define

begin_define
define|#
directive|define
name|isstackaddr
parameter_list|(
name|addr
parameter_list|)
define|\
value|(((addr)< 0x80000000) and ((addr)> 0x80000000 - 0x200 * UPAGES))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|Node
name|callnode
decl_stmt|;
name|Node
name|cmdnode
decl_stmt|;
name|boolean
name|isfunc
decl_stmt|;
block|}
name|CallEnv
typedef|;
end_typedef

begin_decl_stmt
name|private
name|CallEnv
name|endproc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a frame to the current activation record.  */
end_comment

begin_function
name|private
name|getcurframe
parameter_list|(
name|frp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|checkref
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|frp
operator|->
name|mask
operator|=
name|reg
argument_list|(
name|NREG
argument_list|)
expr_stmt|;
name|frp
operator|->
name|save_ap
operator|=
name|reg
argument_list|(
name|ARGP
argument_list|)
expr_stmt|;
name|frp
operator|->
name|save_fp
operator|=
name|reg
argument_list|(
name|FRP
argument_list|)
expr_stmt|;
name|frp
operator|->
name|save_pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSAVEREG
condition|;
name|i
operator|++
control|)
block|{
name|frp
operator|->
name|save_reg
index|[
name|i
index|]
operator|=
name|reg
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the saved registers from one frame to another  * given mask specifying which registers were actually saved.  */
end_comment

begin_define
define|#
directive|define
name|bis
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
value|((b& (1<< (n))) != 0)
end_define

begin_function
name|private
name|getsaveregs
parameter_list|(
name|newfrp
parameter_list|,
name|frp
parameter_list|,
name|mask
parameter_list|)
name|Frame
name|newfrp
decl_stmt|,
name|frp
decl_stmt|;
name|integer
name|mask
decl_stmt|;
block|{
name|integer
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSAVEREG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bis
argument_list|(
name|mask
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|newfrp
operator|->
name|save_reg
index|[
name|i
index|]
operator|=
name|frp
operator|->
name|save_reg
index|[
name|j
index|]
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the next activation record up the stack.  * Return nil if there is none.  * Writes over space pointed to by given argument.  */
end_comment

begin_function
name|private
name|Frame
name|nextframe
parameter_list|(
name|frp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
block|{
name|Frame
name|newfrp
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
name|integer
name|mask
decl_stmt|;
name|Address
name|prev_frame
decl_stmt|,
name|callpc
decl_stmt|;
specifier|static
name|integer
name|ntramp
init|=
literal|0
decl_stmt|;
name|newfrp
operator|=
name|frp
expr_stmt|;
name|prev_frame
operator|=
name|frp
operator|->
name|save_fp
expr_stmt|;
comment|/*  *  The check for interrupt generated frames is taken from adb with only  *  partial understanding.  If you're in "sub" and on a sigxxx "sigsub"  *  gets control, then the stack does NOT look like<main, sub, sigsub>.  *  *  As best I can make out it looks like:  *  *<main, (machine check exception block + sub), sysframe, sigsub>.  *  *  When the signal occurs an exception block and a frame for the routine  *  in which it occured are pushed on the user stack.  Then another frame  *  is pushed corresponding to a call from the kernel to sigsub.  *  *  The addr in sub at which the exception occured is not in sub.save_pc  *  but in the machine check exception block.  It is at the magic address  *  fp + 84.  *  *  The current approach ignores the sys_frame (what adb reports as sigtramp)  *  and takes the pc for sub from the exception block.  This allows the  *  "where" command to report<main, sub, sigsub>, which seems reasonable.  */
name|nextf
label|:
name|dread
argument_list|(
operator|&
name|frame
argument_list|,
name|prev_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntramp
operator|==
literal|1
condition|)
block|{
name|dread
argument_list|(
operator|&
name|callpc
argument_list|,
name|prev_frame
operator|+
literal|84
argument_list|,
sizeof|sizeof
argument_list|(
name|callpc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callpc
operator|=
name|frame
operator|.
name|save_pc
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|.
name|save_fp
operator|==
name|nil
name|or
name|frame
operator|.
name|save_pc
operator|==
operator|(
name|Address
operator|)
operator|-
literal|1
condition|)
block|{
name|newfrp
operator|=
name|nil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isstackaddr
argument_list|(
name|callpc
argument_list|)
condition|)
block|{
name|ntramp
operator|++
expr_stmt|;
name|prev_frame
operator|=
name|frame
operator|.
name|save_fp
expr_stmt|;
goto|goto
name|nextf
goto|;
block|}
else|else
block|{
name|frame
operator|.
name|save_pc
operator|=
name|callpc
expr_stmt|;
name|ntramp
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|frame
operator|.
name|mask
operator|>>
literal|16
operator|)
operator|&
literal|0x0fff
operator|)
expr_stmt|;
name|getsaveregs
argument_list|(
name|newfrp
argument_list|,
operator|&
name|frame
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|newfrp
operator|->
name|condition_handler
operator|=
name|frame
operator|.
name|condition_handler
expr_stmt|;
name|newfrp
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|newfrp
operator|->
name|save_ap
operator|=
name|frame
operator|.
name|save_ap
expr_stmt|;
name|newfrp
operator|->
name|save_fp
operator|=
name|frame
operator|.
name|save_fp
expr_stmt|;
name|newfrp
operator|->
name|save_pc
operator|=
name|frame
operator|.
name|save_pc
expr_stmt|;
block|}
return|return
name|newfrp
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current frame information in the given Frame and store the  * associated function in the given value-result parameter.  */
end_comment

begin_function
name|private
name|getcurfunc
parameter_list|(
name|frp
parameter_list|,
name|fp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
name|Symbol
modifier|*
name|fp
decl_stmt|;
block|{
name|getcurframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|=
name|whatblock
argument_list|(
name|frp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the frame associated with the next function up the call stack, or  * nil if there is none.  The function is returned in a value-result parameter.  * For "inline" functions the statically outer function and same frame  * are returned.  */
end_comment

begin_function
name|public
name|Frame
name|nextfunc
parameter_list|(
name|frp
parameter_list|,
name|fp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
name|Symbol
modifier|*
name|fp
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|Frame
name|nfrp
decl_stmt|;
name|t
operator|=
operator|*
name|fp
expr_stmt|;
name|checkref
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinline
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|container
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|nfrp
operator|=
name|frp
expr_stmt|;
block|}
else|else
block|{
name|nfrp
operator|=
name|nextframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfrp
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|whatblock
argument_list|(
name|nfrp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|fp
operator|=
name|t
expr_stmt|;
return|return
name|nfrp
return|;
block|}
end_function

begin_comment
comment|/*  * Return the frame associated with the given function.  * If the function is nil, return the most recently activated frame.  *  * Static allocation for the frame.  */
end_comment

begin_function
name|public
name|Frame
name|findframe
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|Frame
name|frp
decl_stmt|;
specifier|static
name|struct
name|Frame
name|frame
decl_stmt|;
name|Symbol
name|p
decl_stmt|;
name|Boolean
name|done
decl_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|curfunc
name|and
name|curframe
operator|!=
name|nil
condition|)
block|{
operator|*
name|frp
operator|=
operator|*
name|curframe
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
name|false
expr_stmt|;
name|p
operator|=
name|whatblock
argument_list|(
name|frp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|==
name|f
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|program
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|frp
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|not
name|done
condition|)
do|;
block|}
block|}
return|return
name|frp
return|;
block|}
end_function

begin_comment
comment|/*  * Set the registers according to the given frame pointer.  */
end_comment

begin_function
name|public
name|getnewregs
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|struct
name|Frame
name|frame
decl_stmt|;
name|integer
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mask
decl_stmt|;
name|dread
argument_list|(
operator|&
name|frame
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|ARGP
argument_list|,
name|frame
operator|.
name|save_ap
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|FRP
argument_list|,
name|frame
operator|.
name|save_fp
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|frame
operator|.
name|save_pc
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|frame
operator|.
name|mask
operator|>>
literal|16
operator|)
operator|&
literal|0x0fff
operator|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSAVEREG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bis
argument_list|(
name|mask
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|setreg
argument_list|(
name|i
argument_list|,
name|frame
operator|.
name|save_reg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
name|pc
operator|=
name|frame
operator|.
name|save_pc
expr_stmt|;
name|setcurfunc
argument_list|(
name|whatblock
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the return address of the current procedure/function.  */
end_comment

begin_function
name|public
name|Address
name|return_addr
parameter_list|()
block|{
name|Frame
name|frp
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|frp
operator|=
name|nextframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|frp
operator|->
name|save_pc
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Push the value associated with the current function.  */
end_comment

begin_function
name|public
name|pushretval
parameter_list|(
name|len
parameter_list|,
name|isindirect
parameter_list|)
name|integer
name|len
decl_stmt|;
name|boolean
name|isindirect
decl_stmt|;
block|{
name|Word
name|r0
decl_stmt|;
name|r0
operator|=
name|reg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isindirect
condition|)
block|{
name|rpush
argument_list|(
operator|(
name|Address
operator|)
name|r0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|char
argument_list|)
case|:
name|push
argument_list|(
name|char
argument_list|,
name|r0
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|short
argument_list|)
case|:
name|push
argument_list|(
name|short
argument_list|,
name|r0
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|Word
argument_list|,
name|r0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|Word
argument_list|,
name|r0
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Word
argument_list|,
name|reg
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"[internal error: bad size %d in pushretval]"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the base address for locals in the given frame.  */
end_comment

begin_function
name|public
name|Address
name|locals_base
parameter_list|(
name|frp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
block|{
return|return
operator|(
name|frp
operator|==
name|nil
operator|)
condition|?
name|reg
argument_list|(
name|FRP
argument_list|)
else|:
name|frp
operator|->
name|save_fp
return|;
block|}
end_function

begin_comment
comment|/*  * Return the base address for arguments in the given frame.  */
end_comment

begin_function
name|public
name|Address
name|args_base
parameter_list|(
name|frp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
block|{
return|return
operator|(
name|frp
operator|==
name|nil
operator|)
condition|?
name|reg
argument_list|(
name|ARGP
argument_list|)
else|:
name|frp
operator|->
name|save_ap
return|;
block|}
end_function

begin_comment
comment|/*  * Return saved register n from the given frame.  */
end_comment

begin_function
name|public
name|Word
name|savereg
parameter_list|(
name|n
parameter_list|,
name|frp
parameter_list|)
name|integer
name|n
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
block|{
name|Word
name|w
decl_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|w
operator|=
name|reg
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ARGP
case|:
name|w
operator|=
name|frp
operator|->
name|save_ap
expr_stmt|;
break|break;
case|case
name|FRP
case|:
name|w
operator|=
name|frp
operator|->
name|save_fp
expr_stmt|;
break|break;
case|case
name|STKP
case|:
name|w
operator|=
name|reg
argument_list|(
name|STKP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROGCTR
case|:
name|w
operator|=
name|frp
operator|->
name|save_pc
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
argument|n>=
literal|0
argument|and n< NSAVEREG
argument_list|)
empty_stmt|;
name|w
operator|=
name|frp
operator|->
name|save_reg
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
block|}
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Return the nth argument to the current procedure.  */
end_comment

begin_function
name|public
name|Word
name|argn
parameter_list|(
name|n
parameter_list|,
name|frp
parameter_list|)
name|integer
name|n
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
block|{
name|Word
name|w
decl_stmt|;
name|dread
argument_list|(
operator|&
name|w
argument_list|,
name|args_base
argument_list|(
name|frp
argument_list|)
operator|+
operator|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Print a list of currently active blocks starting with most recent.  */
end_comment

begin_function
name|public
name|wherecmd
parameter_list|()
block|{
name|walkstack
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the variables in the given frame or the current one if nil.  */
end_comment

begin_function
name|public
name|dump
parameter_list|(
name|func
parameter_list|)
name|Symbol
name|func
decl_stmt|;
block|{
name|Symbol
name|f
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|nil
condition|)
block|{
name|f
operator|=
name|curfunc
expr_stmt|;
if|if
condition|(
name|curframe
operator|!=
name|nil
condition|)
block|{
name|frp
operator|=
name|curframe
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|findframe
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|f
operator|=
name|func
expr_stmt|;
name|frp
operator|=
name|findframe
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|showaggrs
operator|=
name|true
expr_stmt|;
name|printcallinfo
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|dumpvars
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump all values.  */
end_comment

begin_function
name|public
name|dumpall
parameter_list|()
block|{
name|walkstack
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the stack of active procedures printing information  * about each active procedure.  */
end_comment

begin_function
name|private
name|walkstack
parameter_list|(
name|dumpvariables
parameter_list|)
name|Boolean
name|dumpvariables
decl_stmt|;
block|{
name|Frame
name|frp
decl_stmt|;
name|boolean
name|save
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
if|if
condition|(
name|notstarted
argument_list|(
argument|process
argument_list|)
name|or
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"program is not active"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save
operator|=
name|walkingstack
expr_stmt|;
name|walkingstack
operator|=
name|true
expr_stmt|;
name|showaggrs
operator|=
name|dumpvariables
expr_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printcallinfo
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpvariables
condition|)
block|{
name|dumpvars
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
name|or
name|f
operator|==
name|program
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|dumpvariables
condition|)
block|{
name|printf
argument_list|(
literal|"in \"%s\":\n"
argument_list|,
name|symname
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
name|dumpvars
argument_list|(
name|program
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|walkingstack
operator|=
name|save
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the information about a call, i.e.,  * routine name, parameter values, and source location.  */
end_comment

begin_function
name|private
name|printcallinfo
parameter_list|(
name|f
parameter_list|,
name|frp
parameter_list|)
name|Symbol
name|f
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
block|{
name|Lineno
name|line
decl_stmt|;
name|Address
name|savepc
decl_stmt|;
name|savepc
operator|=
name|frp
operator|->
name|save_pc
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|save_fp
operator|!=
name|reg
argument_list|(
name|FRP
argument_list|)
condition|)
block|{
name|savepc
operator|-=
literal|1
expr_stmt|;
block|}
name|printname
argument_list|(
name|stdout
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isinline
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|printparams
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|srcline
argument_list|(
name|savepc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|", line %d"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" in \"%s\"\n"
argument_list|,
name|srcfilename
argument_list|(
name|savepc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" at 0x%x\n"
argument_list|,
name|savepc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the current function to the given symbol.  * We must adjust "curframe" so that subsequent operations are  * not confused; for simplicity we simply clear it.  */
end_comment

begin_function
name|public
name|setcurfunc
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|curfunc
operator|=
name|f
expr_stmt|;
name|curframe
operator|=
name|nil
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the frame for the current function.  * The space for the frame is allocated statically.  */
end_comment

begin_function
name|public
name|Frame
name|curfuncframe
parameter_list|()
block|{
specifier|static
name|struct
name|Frame
name|frame
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
if|if
condition|(
name|curframe
operator|==
name|nil
condition|)
block|{
name|frp
operator|=
name|findframe
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
name|curframe
operator|=
operator|&
name|curframerec
expr_stmt|;
operator|*
name|curframe
operator|=
operator|*
name|frp
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
operator|*
name|frp
operator|=
operator|*
name|curframe
expr_stmt|;
block|}
return|return
name|frp
return|;
block|}
end_function

begin_comment
comment|/*  * Set curfunc to be N up/down the stack from its current value.  */
end_comment

begin_function
name|public
name|up
parameter_list|(
name|n
parameter_list|)
name|integer
name|n
decl_stmt|;
block|{
name|integer
name|i
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
name|boolean
name|done
decl_stmt|;
if|if
condition|(
name|not
name|isactive
argument_list|(
name|program
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"program is not active"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curfunc
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"no current function"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|curfunc
expr_stmt|;
name|frp
operator|=
name|curfuncframe
argument_list|()
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
do|do
block|{
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"not that many levels"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|n
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|curfunc
operator|=
name|f
expr_stmt|;
name|curframe
operator|=
operator|&
name|curframerec
expr_stmt|;
operator|*
name|curframe
operator|=
operator|*
name|frp
expr_stmt|;
name|showaggrs
operator|=
name|false
expr_stmt|;
name|printcallinfo
argument_list|(
name|curfunc
argument_list|,
name|curframe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
name|program
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"not that many levels"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|not
name|done
condition|)
do|;
block|}
block|}
end_function

begin_function
name|public
name|down
parameter_list|(
name|n
parameter_list|)
name|integer
name|n
decl_stmt|;
block|{
name|integer
name|i
decl_stmt|,
name|depth
decl_stmt|;
name|Frame
name|frp
decl_stmt|,
name|curfrp
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
if|if
condition|(
name|not
name|isactive
argument_list|(
name|program
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"program is not active"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curfunc
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"no current function"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|depth
operator|=
literal|0
expr_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|curframe
operator|==
name|nil
condition|)
block|{
name|curfrp
operator|=
name|findframe
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
name|curframe
operator|=
operator|&
name|curframerec
expr_stmt|;
operator|*
name|curframe
operator|=
operator|*
name|curfrp
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|f
operator|!=
name|curfunc
name|or
operator|!
name|frameeq
argument_list|(
name|frp
argument_list|,
name|curframe
argument_list|)
operator|)
name|and
name|f
operator|!=
name|nil
condition|)
block|{
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
operator|++
name|depth
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|nil
name|or
name|n
operator|>
name|depth
condition|)
block|{
name|error
argument_list|(
literal|"not that many levels"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|depth
operator|-=
name|n
expr_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|frp
operator|=
name|nextfunc
argument_list|(
name|frp
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|frp
operator|!=
name|nil
argument_list|)
expr_stmt|;
block|}
name|curfunc
operator|=
name|f
expr_stmt|;
operator|*
name|curframe
operator|=
operator|*
name|frp
expr_stmt|;
name|showaggrs
operator|=
name|false
expr_stmt|;
name|printcallinfo
argument_list|(
name|curfunc
argument_list|,
name|curframe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find the entry point of a procedure or function.  */
end_comment

begin_function
name|public
name|findbeginning
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
if|if
condition|(
name|isinternal
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|+=
literal|15
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the address corresponding to the first line in a function.  */
end_comment

begin_function
name|public
name|Address
name|firstline
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|codeloc
argument_list|(
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|linelookup
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
name|and
name|addr
operator|<
name|objsize
condition|)
block|{
operator|++
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|objsize
condition|)
block|{
name|addr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Catcher drops strike three ...  */
end_comment

begin_function
name|public
name|runtofirst
parameter_list|()
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|pc
expr_stmt|;
while|while
condition|(
name|linelookup
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
name|and
name|addr
operator|<
name|objsize
condition|)
block|{
operator|++
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|<
name|objsize
condition|)
block|{
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the address corresponding to the end of the program.  *  * We look for the entry to "exit".  */
end_comment

begin_function
name|public
name|Address
name|lastaddr
parameter_list|()
block|{
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"exit"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"can't find exit"
argument_list|)
expr_stmt|;
block|}
return|return
name|codeloc
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide if the given function is currently active.  *  * We avoid calls to "findframe" during a stack trace for efficiency.  * Presumably information evaluated while walking the stack is active.  */
end_comment

begin_function
name|public
name|Boolean
name|isactive
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|Boolean
name|b
decl_stmt|;
if|if
condition|(
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|walkingstack
name|or
name|f
operator|==
name|program
name|or
argument_list|(
argument|ismodule(f) and isactive(container(f))
argument_list|)
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
call|(
name|Boolean
call|)
argument_list|(
name|findframe
argument_list|(
name|f
argument_list|)
operator|!=
name|nil
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a call to a procedure.  */
end_comment

begin_function
name|public
name|callproc
parameter_list|(
name|exprnode
parameter_list|,
name|isfunc
parameter_list|)
name|Node
name|exprnode
decl_stmt|;
name|boolean
name|isfunc
decl_stmt|;
block|{
name|Node
name|procnode
decl_stmt|,
name|arglist
decl_stmt|;
name|Symbol
name|proc
decl_stmt|;
name|integer
name|argc
decl_stmt|;
name|procnode
operator|=
name|exprnode
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|arglist
operator|=
name|exprnode
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|procnode
operator|->
name|op
operator|!=
name|O_SYM
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't call \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|procnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|assert
argument_list|(
name|procnode
operator|->
name|op
operator|==
name|O_SYM
argument_list|)
expr_stmt|;
name|proc
operator|=
name|procnode
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|not
name|isblock
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|symname
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|endproc
operator|.
name|isfunc
operator|=
name|isfunc
expr_stmt|;
name|endproc
operator|.
name|callnode
operator|=
name|exprnode
expr_stmt|;
name|endproc
operator|.
name|cmdnode
operator|=
name|topnode
expr_stmt|;
name|pushenv
argument_list|()
expr_stmt|;
name|pc
operator|=
name|codeloc
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|argc
operator|=
name|pushargs
argument_list|(
name|proc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|beginproc
argument_list|(
name|proc
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|event_once
argument_list|(
name|build
argument_list|(
name|O_EQ
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|pcsym
argument_list|)
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|retaddrsym
argument_list|)
argument_list|)
argument_list|,
name|buildcmdlist
argument_list|(
name|build
argument_list|(
name|O_PROCRTN
argument_list|,
name|proc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|not
name|bpact
argument_list|()
condition|)
block|{
name|isstopped
operator|=
name|true
expr_stmt|;
name|cont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * bpact() won't return true, it will call printstatus() and go back      * to command input if a breakpoint is found.      */
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Push the arguments on the process' stack.  We do this by first  * evaluating them on the "eval" stack, then copying into the process'  * space.  */
end_comment

begin_function
name|private
name|integer
name|pushargs
parameter_list|(
name|proc
parameter_list|,
name|arglist
parameter_list|)
name|Symbol
name|proc
decl_stmt|;
name|Node
name|arglist
decl_stmt|;
block|{
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|args_size
decl_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$unsafecall"
argument_list|)
condition|)
block|{
name|argc
operator|=
name|unsafe_evalargs
argument_list|(
name|proc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argc
operator|=
name|evalargs
argument_list|(
name|proc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
name|args_size
operator|=
name|sp
operator|-
name|savesp
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
operator|-
name|args_size
argument_list|)
expr_stmt|;
name|dwrite
argument_list|(
name|savesp
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
return|return
name|argc
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if an expression is correct for a given parameter.  * If the given parameter is false, don't worry about type inconsistencies.  *  * Return whether or not it is ok.  */
end_comment

begin_function
name|private
name|boolean
name|chkparam
parameter_list|(
name|actual
parameter_list|,
name|formal
parameter_list|,
name|chk
parameter_list|)
name|Node
name|actual
decl_stmt|;
name|Symbol
name|formal
decl_stmt|;
name|boolean
name|chk
decl_stmt|;
block|{
name|boolean
name|b
decl_stmt|;
name|b
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|chk
condition|)
block|{
if|if
condition|(
name|formal
operator|==
name|nil
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|b
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|compatible
argument_list|(
name|formal
operator|->
name|type
argument_list|,
name|actual
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type mismatch for %s"
argument_list|,
name|symname
argument_list|(
name|formal
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
name|and
name|formal
operator|!=
name|nil
name|and
name|isvarparam
argument_list|(
argument|formal
argument_list|)
name|and
name|not
name|isopenarray
argument_list|(
argument|formal->type
argument_list|)
name|and
name|not
argument_list|(
argument|actual->op == O_RVAL or actual->nodetype == t_addr or 	    ( 		actual->op == O_TYPERENAME and 		( 		    actual->value.arg[
literal|0
argument|]->op == O_RVAL or 		    actual->value.arg[
literal|0
argument|]->nodetype == t_addr 		) 	    )
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected variable, found \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|b
operator|=
name|false
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Pass an expression to a particular parameter.  *  * Normally we pass either the address or value, but in some cases  * (such as C strings) we want to copy the value onto the stack and  * pass its address.  *  * Another special case raised by strings is the possibility that  * the actual parameter will be larger than the formal, even with  * appropriate type-checking.  This occurs because we assume during  * evaluation that strings are null-terminated, whereas some languages,  * notably Pascal, do not work under that assumption.  */
end_comment

begin_function
name|private
name|passparam
parameter_list|(
name|actual
parameter_list|,
name|formal
parameter_list|)
name|Node
name|actual
decl_stmt|;
name|Symbol
name|formal
decl_stmt|;
block|{
name|boolean
name|b
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|integer
name|actsize
decl_stmt|,
name|formsize
decl_stmt|;
if|if
condition|(
name|formal
operator|!=
name|nil
name|and
name|isvarparam
argument_list|(
argument|formal
argument_list|)
name|and
argument_list|(
argument|not isopenarray(formal->type)
argument_list|)
condition|)
block|{
name|addr
operator|=
name|lval
argument_list|(
name|actual
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Address
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|passaddr
argument_list|(
name|formal
argument_list|,
name|actual
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|savesp
operator|=
name|sp
expr_stmt|;
name|eval
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|actsize
operator|=
name|sp
operator|-
name|savesp
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
operator|-
operator|(
operator|(
name|actsize
operator|+
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|dwrite
argument_list|(
name|savesp
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|,
name|actsize
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
name|push
argument_list|(
name|Address
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal
operator|!=
name|nil
name|and
name|isopenarray
argument_list|(
name|formal
operator|->
name|type
argument_list|)
condition|)
block|{
name|push
argument_list|(
argument|integer
argument_list|,
argument|actsize div size(formal->type->type)
argument_list|)
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|formal
operator|!=
name|nil
condition|)
block|{
name|formsize
operator|=
name|size
argument_list|(
name|formal
argument_list|)
expr_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|eval
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|actsize
operator|=
name|sp
operator|-
name|savesp
expr_stmt|;
if|if
condition|(
name|actsize
operator|>
name|formsize
condition|)
block|{
name|sp
operator|-=
operator|(
name|actsize
operator|-
name|formsize
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|eval
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Evaluate an argument list left-to-right.  */
end_comment

begin_function
name|private
name|integer
name|evalargs
parameter_list|(
name|proc
parameter_list|,
name|arglist
parameter_list|)
name|Symbol
name|proc
decl_stmt|;
name|Node
name|arglist
decl_stmt|;
block|{
name|Node
name|p
decl_stmt|,
name|actual
decl_stmt|;
name|Symbol
name|formal
decl_stmt|;
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|integer
name|count
decl_stmt|;
name|boolean
name|chk
decl_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|formal
operator|=
name|proc
operator|->
name|chain
expr_stmt|;
name|chk
operator|=
operator|(
name|boolean
operator|)
operator|(
name|not
name|nosource
argument_list|(
name|proc
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|arglist
init|;
name|p
operator|!=
name|nil
condition|;
name|p
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
control|)
block|{
name|assert
argument_list|(
name|p
operator|->
name|op
operator|==
name|O_COMMA
argument_list|)
expr_stmt|;
name|actual
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|not
name|chkparam
argument_list|(
name|actual
argument_list|,
name|formal
argument_list|,
name|chk
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in call to %s"
argument_list|,
name|symname
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|passparam
argument_list|(
name|actual
argument_list|,
name|formal
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal
operator|!=
name|nil
condition|)
block|{
name|formal
operator|=
name|formal
operator|->
name|chain
expr_stmt|;
block|}
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|chk
condition|)
block|{
if|if
condition|(
name|formal
operator|!=
name|nil
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|error
argument_list|(
literal|"not enough parameters to %s"
argument_list|,
name|symname
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate an argument list without concern for matching the formal  * parameters of a function in type or quantity.  Useful for functions  * like C's printf().  */
end_comment

begin_function
name|private
name|integer
name|unsafe_evalargs
parameter_list|(
name|proc
parameter_list|,
name|arglist
parameter_list|)
name|Symbol
name|proc
decl_stmt|;
name|Node
name|arglist
decl_stmt|;
block|{
name|Node
name|p
decl_stmt|;
name|Integer
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|arglist
init|;
name|p
operator|!=
name|nil
condition|;
name|p
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
control|)
block|{
name|assert
argument_list|(
name|p
operator|->
name|op
operator|==
name|O_COMMA
argument_list|)
expr_stmt|;
name|eval
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|public
name|procreturn
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|integer
name|retvalsize
decl_stmt|;
name|Node
name|tmp
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|flushoutput
argument_list|()
expr_stmt|;
name|popenv
argument_list|()
expr_stmt|;
if|if
condition|(
name|endproc
operator|.
name|isfunc
condition|)
block|{
name|retvalsize
operator|=
name|size
argument_list|(
name|f
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|retvalsize
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|pushretval
argument_list|(
name|retvalsize
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|copy
operator|=
name|newarr
argument_list|(
name|char
argument_list|,
name|retvalsize
argument_list|)
expr_stmt|;
name|popn
argument_list|(
name|retvalsize
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build
argument_list|(
name|O_SCON
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
call|(
name|long
call|)
argument_list|(
name|reg
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|->
name|nodetype
operator|=
name|f
operator|->
name|type
expr_stmt|;
name|tfree
argument_list|(
name|endproc
operator|.
name|callnode
argument_list|)
expr_stmt|;
operator|*
operator|(
name|endproc
operator|.
name|callnode
operator|)
operator|=
operator|*
operator|(
name|tmp
operator|)
expr_stmt|;
name|dispose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|eval
argument_list|(
name|endproc
operator|.
name|cmdnode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" returns successfully\n"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Push the current environment.  */
end_comment

begin_function
name|private
name|pushenv
parameter_list|()
block|{
name|push
argument_list|(
name|Address
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Lineno
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|String
argument_list|,
name|cursource
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Boolean
argument_list|,
name|isstopped
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Symbol
argument_list|,
name|curfunc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Frame
argument_list|,
name|curframe
argument_list|)
expr_stmt|;
name|push
argument_list|(
expr|struct
name|Frame
argument_list|,
name|curframerec
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|CallEnv
argument_list|,
name|endproc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Word
argument_list|,
name|reg
argument_list|(
name|PROGCTR
argument_list|)
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Word
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pop back to the real world.  */
end_comment

begin_function
name|public
name|popenv
parameter_list|()
block|{
name|String
name|filename
decl_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|pop
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pop
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
name|endproc
operator|=
name|pop
argument_list|(
name|CallEnv
argument_list|)
expr_stmt|;
name|curframerec
operator|=
name|pop
argument_list|(
expr|struct
name|Frame
argument_list|)
expr_stmt|;
name|curframe
operator|=
name|pop
argument_list|(
name|Frame
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|pop
argument_list|(
name|Symbol
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|pop
argument_list|(
name|Boolean
argument_list|)
expr_stmt|;
name|filename
operator|=
name|pop
argument_list|(
name|String
argument_list|)
expr_stmt|;
name|curline
operator|=
name|pop
argument_list|(
name|Lineno
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pop
argument_list|(
name|Address
argument_list|)
expr_stmt|;
name|setsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the debuggee's standard output.  *  * This is VERY dependent on the use of stdio.  */
end_comment

begin_function
name|public
name|flushoutput
parameter_list|()
block|{
name|Symbol
name|p
decl_stmt|,
name|iob
decl_stmt|;
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|p
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"fflush"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|nil
name|and
name|not
name|isblock
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|next_sym
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
name|iob
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"_iob"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iob
operator|!=
name|nil
condition|)
block|{
name|pushenv
argument_list|()
expr_stmt|;
name|pc
operator|=
name|codeloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|push
argument_list|(
name|long
argument_list|,
name|address
argument_list|(
name|iob
argument_list|,
name|nil
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_iobuf
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dwrite
argument_list|(
name|savesp
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
name|beginproc
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stepto
argument_list|(
name|return_addr
argument_list|()
argument_list|)
expr_stmt|;
name|popenv
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

