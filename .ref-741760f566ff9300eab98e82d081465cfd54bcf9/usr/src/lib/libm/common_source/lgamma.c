begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lgamma.c	4.4 (Berkeley) 9/11/85; 1.2 (ucb.elefunt) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/* 	C program for floating point log Gamma function  	lgamma(x) computes the log of the absolute 	value of the Gamma function. 	The sign of the Gamma function is returned in the 	external quantity signgam.  	The coefficients for expansion around zero 	are #5243 from Hart& Cheney; for expansion 	around infinity they are #5404.  	Calls log, floor and sin. */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|signgam
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|goobie
init|=
literal|0.9189385332046727417803297
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log(2*pi)/2 */
end_comment

begin_decl_stmt
specifier|static
name|double
name|pi
init|=
literal|3.1415926535897932384626434
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M
value|6
end_define

begin_define
define|#
directive|define
name|N
value|8
end_define

begin_decl_stmt
specifier|static
name|double
name|p1
index|[]
init|=
block|{
literal|0.83333333333333101837e-1
block|,
operator|-
literal|.277777777735865004e-2
block|,
literal|0.793650576493454e-3
block|,
operator|-
literal|.5951896861197e-3
block|,
literal|0.83645878922e-3
block|,
operator|-
literal|.1633436431e-2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|p2
index|[]
init|=
block|{
operator|-
literal|.42353689509744089647e5
block|,
operator|-
literal|.20886861789269887364e5
block|,
operator|-
literal|.87627102978521489560e4
block|,
operator|-
literal|.20085274013072791214e4
block|,
operator|-
literal|.43933044406002567613e3
block|,
operator|-
literal|.50108693752970953015e2
block|,
operator|-
literal|.67449507245925289918e1
block|,
literal|0.0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|q2
index|[]
init|=
block|{
operator|-
literal|.42353689509744090010e5
block|,
operator|-
literal|.29803853309256649932e4
block|,
literal|0.99403074150827709015e4
block|,
operator|-
literal|.15286072737795220248e4
block|,
operator|-
literal|.49902852662143904834e3
block|,
literal|0.18949823415702801641e3
block|,
operator|-
literal|.23081551524580124562e2
block|,
literal|0.10000000000000000000e1
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|lgamma
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|log
argument_list|()
decl_stmt|,
name|pos
argument_list|()
decl_stmt|,
name|neg
argument_list|()
decl_stmt|,
name|asym
argument_list|()
decl_stmt|;
name|signgam
operator|=
literal|1.
expr_stmt|;
if|if
condition|(
name|arg
operator|<=
literal|0.
condition|)
return|return
operator|(
name|neg
argument_list|(
name|arg
argument_list|)
operator|)
return|;
if|if
condition|(
name|arg
operator|>
literal|8.
condition|)
return|return
operator|(
name|asym
argument_list|(
name|arg
argument_list|)
operator|)
return|;
return|return
operator|(
name|log
argument_list|(
name|pos
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|asym
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|log
parameter_list|()
function_decl|;
name|double
name|n
decl_stmt|,
name|argsq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|argsq
operator|=
literal|1.
operator|/
operator|(
name|arg
operator|*
name|arg
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|i
operator|=
name|M
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n
operator|=
name|n
operator|*
name|argsq
operator|+
name|p1
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|arg
operator|-
literal|.5
operator|)
operator|*
name|log
argument_list|(
name|arg
argument_list|)
operator|-
name|arg
operator|+
name|goobie
operator|+
name|n
operator|/
name|arg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|neg
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|t
decl_stmt|;
name|double
name|log
argument_list|()
decl_stmt|,
name|sin
argument_list|()
decl_stmt|,
name|floor
argument_list|()
decl_stmt|,
name|pos
argument_list|()
decl_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
comment|/*       * to see if arg were a true integer, the old code used the       * mathematically correct observation:       * sin(n*pi) = 0<=> n is an integer.       * but in finite precision arithmetic, sin(n*PI) will NEVER       * be zero simply because n*PI is a rational number.  hence       *	it failed to work with our newer, more accurate sin()       * which uses true pi to do the argument reduction...       *	temp = sin(pi*arg);       */
name|t
operator|=
name|floor
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|-
name|t
operator|>
literal|0.5e0
condition|)
name|t
operator|+=
literal|1.e0
expr_stmt|;
comment|/* t := integer nearest arg */
ifdef|#
directive|ifdef
name|VAX
if|if
condition|(
name|arg
operator|==
name|t
condition|)
block|{
specifier|extern
name|double
name|infnan
parameter_list|()
function_decl|;
return|return
operator|(
name|infnan
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
comment|/* +INF */
block|}
endif|#
directive|endif
name|signgam
operator|=
call|(
name|int
call|)
argument_list|(
name|t
operator|-
literal|2
operator|*
name|floor
argument_list|(
name|t
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* signgam =  1 if t was odd, */
comment|/*            0 if t was even */
name|signgam
operator|=
name|signgam
operator|-
literal|1
operator|+
name|signgam
expr_stmt|;
comment|/* signgam =  1 if t was odd, */
comment|/*           -1 if t was even */
name|t
operator|=
name|arg
operator|-
name|t
expr_stmt|;
comment|/*  -0.5<= t<= 0.5 */
if|if
condition|(
name|t
operator|<
literal|0.e0
condition|)
block|{
name|t
operator|=
operator|-
name|t
expr_stmt|;
name|signgam
operator|=
operator|-
name|signgam
expr_stmt|;
block|}
return|return
operator|(
operator|-
name|log
argument_list|(
name|arg
operator|*
name|pos
argument_list|(
name|arg
argument_list|)
operator|*
name|sin
argument_list|(
name|pi
operator|*
name|t
argument_list|)
operator|/
name|pi
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|pos
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|n
decl_stmt|,
name|d
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|2.
condition|)
return|return
operator|(
name|pos
argument_list|(
name|arg
operator|+
literal|1.
argument_list|)
operator|/
name|arg
operator|)
return|;
if|if
condition|(
name|arg
operator|>
literal|3.
condition|)
return|return
operator|(
operator|(
name|arg
operator|-
literal|1.
operator|)
operator|*
name|pos
argument_list|(
name|arg
operator|-
literal|1.
argument_list|)
operator|)
return|;
name|s
operator|=
name|arg
operator|-
literal|2.
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|d
operator|=
literal|0
operator|,
name|i
operator|=
name|N
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n
operator|=
name|n
operator|*
name|s
operator|+
name|p2
index|[
name|i
index|]
expr_stmt|;
name|d
operator|=
name|d
operator|*
name|s
operator|+
name|q2
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|/
name|d
operator|)
return|;
block|}
end_function

end_unit

