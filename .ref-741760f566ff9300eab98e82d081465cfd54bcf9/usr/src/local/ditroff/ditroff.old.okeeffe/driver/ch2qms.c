begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	ch2qms.c	1.1	87/02/05  *  * Font translation to qms-style fonts (QUIC format) from character format.  *  *	Use:	ch2qms  [ -i  -s  -b# ]  charfile> qmsfile  *  *		Takes input from charfile (which must be in the format written  *	by one of the xxx2ch programs), converts to qms' QUIC format (with the  *	baseline version of the format) and writes to stdout.  If charfile is  *	missing, stdin is read.  The -i flag tells ch2qms to ignore the  *	character codes at the start of each glyph definition, and pack the  *	glyphs in consecutive code positions starting with 0.  The -s flag  *	forces ch2qms to NOT trim off any white space in the glyph map.  This  *	is useful to make stipples of fixed size.  The -b flag gives ch2qms  *	a glyph number to produce a baseline from, replacing it's default  *	(character #65, `A').  If a "baseline" value isn't given explicitly  *	in the font, one is calculated by searching for the bottom of the  *	baseline character.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|MAXLINE
value|300
end_define

begin_define
define|#
directive|define
name|RES
value|300
end_define

begin_comment
comment|/* resolution, in pixels per inch */
end_comment

begin_define
define|#
directive|define
name|DIRSIZ
value|256
end_define

begin_comment
comment|/* maximum number of characters in font */
end_comment

begin_define
define|#
directive|define
name|HEADER
value|"^PY^-\n^F^-\n^DF"
end_define

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|pwidth
decl_stmt|;
comment|/* printing width of glyph, in bits */
name|int
name|gwidth
decl_stmt|;
comment|/* width of a glyph, in bits */
name|int
name|gheight
decl_stmt|;
comment|/* height of glyph */
name|int
name|hoff
decl_stmt|;
comment|/* from left edge to reference point */
name|int
name|voff
decl_stmt|;
comment|/* from top edge to reference point */
name|char
modifier|*
name|glyph
decl_stmt|;
comment|/* encoded bits of glyph */
block|}
name|glyphentry
typedef|;
end_typedef

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* code of character working on */
end_comment

begin_decl_stmt
name|int
name|width
decl_stmt|,
name|length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dimensions of glyph bit-map */
end_comment

begin_decl_stmt
name|int
name|maxv
decl_stmt|,
name|minv
decl_stmt|,
name|maxh
decl_stmt|,
name|minh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limits of "blackness" in the bit-map */
end_comment

begin_decl_stmt
name|int
name|maxup
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most movement above and */
end_comment

begin_decl_stmt
name|int
name|maxdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   below the reference points */
end_comment

begin_decl_stmt
name|int
name|refv
decl_stmt|,
name|refh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference point found in glyph */
end_comment

begin_decl_stmt
name|int
name|lineok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ignorecode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option:  ignore the character number given */
end_comment

begin_decl_stmt
name|int
name|stipple
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option:  use whitespace in the glyph */
end_comment

begin_decl_stmt
name|int
name|height
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* height of every character in the font */
end_comment

begin_decl_stmt
name|int
name|fontid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the "font number" */
end_comment

begin_decl_stmt
name|int
name|landscape
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag:  is this a landscape font? */
end_comment

begin_decl_stmt
name|int
name|version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version code */
end_comment

begin_decl_stmt
name|int
name|baseline
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* baseline of font (if specified) */
end_comment

begin_decl_stmt
name|int
name|baselinechar
init|=
literal|65
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character to use to figure baseline from */
end_comment

begin_decl_stmt
name|int
name|bitwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|filep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buff
index|[
name|MAXLINE
index|]
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|name
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bitp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|glyphentry
name|g
index|[
name|DIRSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|codeindex
decl_stmt|;
specifier|register
name|char
modifier|*
name|chp
decl_stmt|;
name|float
name|par
decl_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|baselinechar
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|baselinechar
operator|<
literal|0
operator|||
name|baselinechar
operator|>=
name|DIRSIZ
condition|)
name|error
argument_list|(
literal|"baseline character %d out of range"
argument_list|,
name|baselinechar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignorecode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|stipple
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"%s, unknown option flag"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|filep
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"can't open file \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|filep
operator|=
name|stdin
expr_stmt|;
name|codeindex
operator|=
literal|0
expr_stmt|;
name|fgets
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
name|MAXLINE
argument_list|,
name|filep
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
literal|"fontheader\n"
argument_list|)
condition|)
name|error
argument_list|(
literal|"not a character font file"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
name|MAXLINE
argument_list|,
name|filep
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
literal|'\n'
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"input line too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
block|{
name|sscanf
argument_list|(
name|buff
argument_list|,
literal|"%s %f"
argument_list|,
name|buff
index|[
literal|1
index|]
argument_list|,
operator|&
name|par
argument_list|)
expr_stmt|;
name|i
operator|=
name|par
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"rot"
argument_list|)
operator|==
literal|0
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
name|landscape
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|landscape
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"illegal rotation (%d)."
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"version"
argument_list|)
operator|==
literal|0
condition|)
name|version
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
name|sscanf
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
literal|"%s %s"
argument_list|,
name|buff
index|[
literal|1
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"linesp"
argument_list|)
operator|==
literal|0
condition|)
name|height
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"id"
argument_list|)
operator|==
literal|0
condition|)
name|fontid
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"baseline"
argument_list|)
operator|==
literal|0
condition|)
name|baseline
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buff
index|[
literal|1
index|]
argument_list|,
literal|"res"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|RES
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ch2qms: warning, wrong resolution (%d).\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* ignore unrecognized fields */
block|}
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
literal|":%d, width = %f"
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|par
argument_list|)
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"bad glyph header, %s"
argument_list|,
name|buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignorecode
condition|)
name|codeindex
operator|++
expr_stmt|;
else|else
name|codeindex
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|codeindex
operator|>=
name|DIRSIZ
condition|)
name|error
argument_list|(
literal|"glyph number (%d) out of range"
argument_list|,
name|codeindex
argument_list|)
expr_stmt|;
name|g
index|[
name|codeindex
index|]
operator|.
name|pwidth
operator|=
name|par
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
name|MAXLINE
argument_list|,
name|filep
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"unexpected end of input"
argument_list|)
expr_stmt|;
name|width
operator|=
name|strlen
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|minh
operator|=
name|width
expr_stmt|;
name|maxh
operator|=
literal|0
expr_stmt|;
name|refh
operator|=
name|minv
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|length
operator|=
literal|0
init|;
operator|*
operator|(
name|chp
operator|=
operator|&
operator|(
name|buff
index|[
name|length
index|]
index|[
literal|0
index|]
operator|)
operator|)
operator|!=
literal|'\n'
condition|;
name|length
operator|++
control|)
block|{
if|if
condition|(
name|length
operator|>=
name|MAXLINE
condition|)
name|error
argument_list|(
literal|"not enough space to read in glyph"
argument_list|)
expr_stmt|;
name|lineok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|width
condition|;
name|i
operator|++
operator|,
name|chp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|chp
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|lineok
operator|=
operator|(
name|i
operator|==
name|width
operator|)
expr_stmt|;
case|case
literal|'.'
case|:
operator|*
name|chp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|*
name|chp
operator|=
literal|0
expr_stmt|;
case|case
literal|'X'
case|:
if|if
condition|(
name|refh
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"glyph %d - two reference points"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|refh
operator|=
name|i
expr_stmt|;
name|refv
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|chp
condition|)
break|break;
case|case
literal|'@'
case|:
case|case
literal|'*'
case|:
operator|*
name|chp
operator|=
literal|'\1'
expr_stmt|;
if|if
condition|(
name|minv
operator|<
literal|0
condition|)
name|minv
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|minh
condition|)
name|minh
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|maxh
condition|)
name|maxh
operator|=
name|i
expr_stmt|;
name|maxv
operator|=
name|length
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"illegal character '%c' in map."
argument_list|,
operator|*
name|chp
argument_list|)
expr_stmt|;
block|}
comment|/* switch */
block|}
comment|/* for i */
if|if
condition|(
operator|!
name|lineok
condition|)
name|error
argument_list|(
literal|"lines not equal length in glyph %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buff
index|[
name|length
operator|+
literal|1
index|]
argument_list|,
name|MAXLINE
argument_list|,
name|filep
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"unexpected end of input"
argument_list|)
expr_stmt|;
block|}
comment|/* for length */
if|if
condition|(
name|stipple
condition|)
block|{
comment|/* use the whole box to make a */
name|minv
operator|=
literal|0
expr_stmt|;
comment|/* stipple pattern. */
name|minh
operator|=
literal|0
expr_stmt|;
name|maxv
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|maxh
operator|=
name|width
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|refh
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"no reference point in glyph %d."
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|minv
operator|<
literal|0
condition|)
block|{
name|minv
operator|=
name|maxv
operator|=
name|refv
expr_stmt|;
name|minh
operator|=
name|maxh
operator|=
name|refh
expr_stmt|;
block|}
if|if
condition|(
name|landscape
condition|)
block|{
if|if
condition|(
name|maxup
operator|<
name|width
operator|-
name|refh
condition|)
name|maxup
operator|=
name|width
operator|-
name|refh
expr_stmt|;
if|if
condition|(
name|maxdown
operator|<
name|refh
condition|)
name|maxdown
operator|=
name|refh
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|maxup
operator|<
name|refv
condition|)
name|maxup
operator|=
name|refv
expr_stmt|;
if|if
condition|(
name|maxdown
operator|<
name|length
operator|-
name|refv
condition|)
name|maxdown
operator|=
name|length
operator|-
name|refv
expr_stmt|;
block|}
name|g
index|[
name|codeindex
index|]
operator|.
name|gwidth
operator|=
name|maxh
operator|+
literal|1
operator|-
name|minh
expr_stmt|;
name|g
index|[
name|codeindex
index|]
operator|.
name|gheight
operator|=
name|maxv
operator|+
literal|1
operator|-
name|minv
expr_stmt|;
name|g
index|[
name|codeindex
index|]
operator|.
name|hoff
operator|=
name|refh
operator|-
name|minh
expr_stmt|;
name|g
index|[
name|codeindex
index|]
operator|.
name|voff
operator|=
name|refv
operator|-
name|minv
expr_stmt|;
name|bitp
operator|=
name|calloc
argument_list|(
operator|(
operator|(
name|g
index|[
name|codeindex
index|]
operator|.
name|gwidth
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
name|g
index|[
name|codeindex
index|]
operator|.
name|gheight
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|g
index|[
name|codeindex
index|]
operator|.
name|glyph
operator|=
name|bitp
expr_stmt|;
name|bitp
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minv
init|;
name|i
operator|<=
name|maxv
condition|;
name|i
operator|++
control|)
block|{
name|chp
operator|=
operator|&
operator|(
name|buff
index|[
name|i
index|]
index|[
name|minh
index|]
operator|)
expr_stmt|;
name|bitwidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|minh
init|;
name|j
operator|<=
name|maxh
condition|;
name|j
operator|++
operator|,
name|chp
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|bitwidth
operator|<
literal|0
condition|)
block|{
operator|*
operator|++
name|bitp
operator|=
literal|'\0'
expr_stmt|;
name|bitwidth
operator|=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|chp
condition|)
operator|*
name|bitp
operator||=
literal|1
operator|<<
name|bitwidth
expr_stmt|;
block|}
block|}
comment|/* for i */
block|}
comment|/* else */
block|}
comment|/* while */
if|if
condition|(
name|height
operator|<
literal|0
condition|)
block|{
name|height
operator|=
name|maxup
operator|+
name|maxdown
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|baseline
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|g
index|[
name|baselinechar
index|]
operator|.
name|glyph
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"no glyph at baseline character %d"
argument_list|,
name|baselinechar
argument_list|)
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
block|{
name|i
operator|=
name|g
index|[
name|baselinechar
index|]
operator|.
name|hoff
expr_stmt|;
name|j
operator|=
name|g
index|[
name|baselinechar
index|]
operator|.
name|gwidth
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|-
literal|1
operator|||
name|i
operator|>
name|j
operator|/
literal|3
condition|)
block|{
name|baseline
operator|=
name|j
expr_stmt|;
name|baselinechar
operator|=
literal|1
operator|+
name|i
expr_stmt|;
block|}
else|else
block|{
name|baseline
operator|=
name|maxup
operator|+
literal|1
expr_stmt|;
name|baselinechar
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|g
index|[
name|baselinechar
index|]
operator|.
name|voff
expr_stmt|;
name|j
operator|=
name|g
index|[
name|baselinechar
index|]
operator|.
name|gheight
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|j
operator|-
literal|1
operator|||
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|baseline
operator|=
name|j
expr_stmt|;
name|baselinechar
operator|=
name|j
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
name|baseline
operator|=
name|maxup
operator|+
literal|1
expr_stmt|;
name|baselinechar
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|baselinechar
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%05d%c%d%4s%03d%03dT,\n"
argument_list|,
name|fontid
argument_list|,
name|landscape
condition|?
literal|'Y'
else|:
literal|'X'
argument_list|,
name|version
argument_list|,
name|name
argument_list|,
name|height
argument_list|,
name|baseline
argument_list|)
expr_stmt|;
name|baseline
operator|-=
name|baselinechar
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
name|baseline
operator|=
name|height
operator|-
name|baseline
expr_stmt|;
for|for
control|(
name|codeindex
operator|=
literal|0
init|;
name|codeindex
operator|<
name|DIRSIZ
condition|;
name|codeindex
operator|++
control|)
block|{
if|if
condition|(
name|g
index|[
name|codeindex
index|]
operator|.
name|glyph
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|code
operator|=
literal|80
expr_stmt|;
name|outhex
argument_list|(
name|codeindex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%03d%03d%03d"
argument_list|,
name|g
index|[
name|codeindex
index|]
operator|.
name|pwidth
argument_list|,
name|g
index|[
name|codeindex
index|]
operator|.
name|gheight
argument_list|,
name|g
index|[
name|codeindex
index|]
operator|.
name|gwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|landscape
condition|)
block|{
name|i
operator|=
operator|-
name|g
index|[
name|codeindex
index|]
operator|.
name|voff
expr_stmt|;
name|j
operator|=
name|baseline
operator|-
name|g
index|[
name|codeindex
index|]
operator|.
name|hoff
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|baseline
operator|-
name|g
index|[
name|codeindex
index|]
operator|.
name|voff
expr_stmt|;
name|j
operator|=
operator|-
name|g
index|[
name|codeindex
index|]
operator|.
name|hoff
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"%04d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%03d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"%04d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%03d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|chp
operator|=
name|g
index|[
name|codeindex
index|]
operator|.
name|glyph
expr_stmt|;
for|for
control|(
name|j
operator|=
name|g
index|[
name|codeindex
index|]
operator|.
name|gheight
init|;
name|j
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|code
operator|>
literal|72
condition|)
block|{
name|code
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|g
index|[
name|codeindex
index|]
operator|.
name|gwidth
operator|+
literal|7
operator|)
operator|/
literal|8
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|outhex
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|chp
operator|++
operator|)
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|%
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"00"
argument_list|)
expr_stmt|;
name|code
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"^G\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	error (format_string, argument1, argument2.... )  |  | Results:	fprints a message to standard error, then exits with error  |		code 1  |  | Side Efct:	This routine does NOT return  *----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|error
argument_list|(
argument|string
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ch2qms: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*-----------------------------------------------------------------------------  | Routine:	outhex (number)  |  | Results:	prints to standard output, the 2-digit hex value "number"  |		and does so in capital letters (which printf won't)  *----------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
name|char
name|hexness
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_macro
name|outhex
argument_list|(
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|int
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|value
decl_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|hexness
index|[
operator|(
name|i
operator|>>
literal|4
operator|)
operator|&
literal|15
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|hexness
index|[
name|i
operator|&
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

