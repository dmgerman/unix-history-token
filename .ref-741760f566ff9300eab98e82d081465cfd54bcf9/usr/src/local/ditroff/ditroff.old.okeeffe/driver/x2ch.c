begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	x2ch.c	1.1	87/02/05  *  * Font translation for X font-style fonts to character format.  *  *	Use:  x2ch  [ -p# ] fontfile  [ character_list ]  *  *		Reads "fontfile" from current directory (or if not found,  *	from BITDIR defined below) and converts it to a character font format  *	editable by real people, and convertable BACK to X format by the  *	ch2x program.  The -p option specifies the "point size" of the font.  *	If no "-p#" is specified, the pointsize is 10.  Output goes to stdout.  */
end_comment

begin_comment
comment|/* #define DEBUG   	/* if defined, statistics are printed to stderr */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"xfont.h"
end_include

begin_define
define|#
directive|define
name|DIRSIZ
value|256
end_define

begin_define
define|#
directive|define
name|BITDIR
value|"/usr/new/lib/X/font"
end_define

begin_decl_stmt
name|struct
name|FontData
name|FH
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|first
value|FH.firstChar
end_define

begin_define
define|#
directive|define
name|last
value|FH.lastChar
end_define

begin_decl_stmt
name|short
name|bitmapindex
index|[
name|DIRSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit offsets in bitmap */
end_comment

begin_decl_stmt
name|short
name|widths
index|[
name|DIRSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* widths calculated from but offsets */
end_comment

begin_decl_stmt
name|char
modifier|*
name|charbits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to start of bitmap */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|lineptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to start of each line of bitmap */
end_comment

begin_decl_stmt
name|int
name|pointsize
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* can only be changed from command line */
end_comment

begin_decl_stmt
name|int
name|tmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for various short-lived things */
end_comment

begin_decl_stmt
name|int
modifier|*
name|bitcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to hold count of bits on a particular 				   line in bitmap - used to find the baseline */
end_comment

begin_decl_stmt
name|char
name|IName
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name building place */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|defascii
index|[
name|DIRSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default characters to print */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|charswanted
init|=
name|defascii
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|FID
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|argc
operator|>
literal|4
condition|)
block|{
name|usage
label|:
name|error
argument_list|(
literal|"usage: %s [ -p# ] filename [ character-list ]"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'p'
condition|)
goto|goto
name|usage
goto|;
name|pointsize
operator|=
name|atoi
argument_list|(
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRSIZ
condition|;
name|i
operator|++
control|)
block|{
name|bitmapindex
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|widths
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|defascii
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|charswanted
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * find font in BITDIR or current directory, also trying to 	 * tack on the ".onx" extension onto the filename 	 */
operator|++
name|argv
expr_stmt|;
name|sprintf
argument_list|(
name|IName
argument_list|,
literal|"%s/%s.onx"
argument_list|,
name|BITDIR
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FID
operator|=
name|open
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|FID
operator|=
name|open
argument_list|(
name|IName
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|IName
argument_list|,
literal|"%s.onx"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FID
operator|=
name|open
argument_list|(
name|IName
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|IName
argument_list|,
literal|"%s/%s"
argument_list|,
name|BITDIR
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FID
operator|=
name|open
argument_list|(
name|IName
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't find %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
operator|&
name|FH
argument_list|,
sizeof|sizeof
name|FH
argument_list|)
operator|!=
sizeof|sizeof
name|FH
condition|)
name|error
argument_list|(
literal|"no header in Font file."
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
operator|||
name|last
operator|>=
name|DIRSIZ
operator|||
name|last
operator|<=
name|first
condition|)
name|error
argument_list|(
literal|"font boundaries (%d,%d) out of range"
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|FH
operator|.
name|bmWidth
operator|<=
literal|0
operator|||
name|FH
operator|.
name|bmWidth
operator|>=
literal|20000
operator|||
name|FH
operator|.
name|bmHeight
operator|<=
literal|0
operator|||
name|FH
operator|.
name|bmHeight
operator|>=
literal|20000
condition|)
name|error
argument_list|(
literal|"dimensions (%d,%d) out of range"
argument_list|,
name|FH
operator|.
name|bmWidth
argument_list|,
name|FH
operator|.
name|bmHeight
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|(
name|FH
operator|.
name|bmWidth
operator|+
literal|15
operator|)
operator|>>
literal|3
operator|)
operator|&
operator|~
literal|1
operator|)
operator|*
name|FH
operator|.
name|bmHeight
expr_stmt|;
name|charbits
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bit Map Ptr = %d\nBitMap Width = %d\nBit Map Height = %d\nBitsPerPixel = %d\nFirst Character = %d\nLast Character = %d\nLeft Array = %d\nBaseLine = %d\nSpace Index = %d\nFixed Width = %d\nbit map size = %d\n"
argument_list|,
name|FH
operator|.
name|bitmapPtr
argument_list|,
name|FH
operator|.
name|bmWidth
argument_list|,
name|FH
operator|.
name|bmHeight
argument_list|,
name|FH
operator|.
name|bitsPerPixel
argument_list|,
name|FH
operator|.
name|firstChar
argument_list|,
name|FH
operator|.
name|lastChar
argument_list|,
name|FH
operator|.
name|leftArray
argument_list|,
name|FH
operator|.
name|baseline
argument_list|,
name|FH
operator|.
name|spaceIndex
argument_list|,
name|FH
operator|.
name|fixedWidth
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lseek
argument_list|(
name|FID
argument_list|,
operator|(
name|long
operator|)
name|FH
operator|.
name|bitmapPtr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
name|charbits
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|error
argument_list|(
literal|"bit map (%d chars) not in Font file"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|FH
operator|.
name|fixedWidth
operator|==
literal|0
condition|)
block|{
name|i
operator|=
operator|(
name|last
operator|-
name|first
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"width array size = %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lseek
argument_list|(
name|FID
argument_list|,
operator|(
name|long
operator|)
name|FH
operator|.
name|leftArray
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
operator|&
name|bitmapindex
index|[
name|first
index|]
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|error
argument_list|(
literal|"width map not in Font file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|first
operator|+
literal|1
init|;
name|i
operator|<=
name|last
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|bitmapindex
index|[
name|i
index|]
operator|=
name|bitmapindex
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|FH
operator|.
name|fixedWidth
expr_stmt|;
block|}
comment|/* 	 * figure out character widths from "leftarray" 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"left,widths:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|widths
index|[
name|i
index|]
operator|=
name|bitmapindex
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|bitmapindex
index|[
name|i
index|]
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"inconsistent width table"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%03d:%5d,%6d\n"
argument_list|,
name|i
argument_list|,
name|bitmapindex
index|[
name|i
index|]
argument_list|,
name|widths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|lineptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|FH
operator|.
name|bmHeight
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
operator|(
operator|(
name|FH
operator|.
name|bmWidth
operator|+
literal|15
operator|)
operator|>>
literal|3
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|lineptr
index|[
literal|0
index|]
operator|=
name|charbits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|FH
operator|.
name|bmHeight
condition|;
name|i
operator|++
control|)
block|{
name|lineptr
index|[
name|i
index|]
operator|=
name|lineptr
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|j
expr_stmt|;
block|}
comment|/* 	 * If not given a baseline, try to figure one out by counting the 	 * bits in a given row.  When the number falls suddenly, that's the 	 * baseline.  This is not guaranteed to work. 	 */
if|if
condition|(
operator|--
name|FH
operator|.
name|baseline
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|bitcount
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|FH
operator|.
name|bmHeight
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FH
operator|.
name|bmHeight
condition|;
name|i
operator|++
control|)
block|{
name|bitcount
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FH
operator|.
name|bmWidth
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|lineptr
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|bitcount
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
name|tmp
operator|+=
name|bitcount
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bitcount[%d] == %d\n"
argument_list|,
name|i
argument_list|,
name|bitcount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|tmp
operator|/=
name|FH
operator|.
name|bmHeight
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"average == %d\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|FH
operator|.
name|bmHeight
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bitcount
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|tmp
operator|&&
name|bitcount
index|[
name|i
index|]
operator|<
operator|(
name|tmp
operator|>>
literal|1
operator|)
condition|)
name|FH
operator|.
name|baseline
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FH
operator|.
name|baseline
operator|<
literal|0
condition|)
name|FH
operator|.
name|baseline
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"fontheader\ndesiz %d\nmag 1000\n"
argument_list|,
name|pointsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rot 0\ncadv 0\nladv 1\nid 0\nres 75\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRSIZ
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|charswanted
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|j
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|widths
index|[
name|j
index|]
condition|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
name|printf
argument_list|(
literal|":%d, width = %d.00\n"
argument_list|,
name|j
argument_list|,
name|widths
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FH
operator|.
name|bmHeight
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|widths
index|[
name|j
index|]
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|lineptr
index|[
name|k
index|]
argument_list|,
name|bitmapindex
index|[
name|j
index|]
operator|+
name|l
argument_list|)
condition|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|k
operator|==
name|FH
operator|.
name|baseline
condition|)
name|putchar
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|k
operator|==
name|FH
operator|.
name|baseline
condition|)
name|putchar
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	error (format_string, argument1, argument2.... )  |  | Results:	fprints a message to standard error, then exits with error  |		code 1  |  | Side Efct:	This routine does NOT return  *----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|error
argument_list|(
argument|string
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x2ch: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	bitset (bitstream pointer, bit number)  |  | Results:	returns nonzero if a bit is set in a supplied bit stream.  |		No range checking is done on anything.  Bit order is least  |		significant to most significant.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|bitset
argument_list|(
argument|stream
argument_list|,
argument|bit
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|stream
operator|+
operator|(
name|bit
operator|>>
literal|3
operator|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|p
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bit
operator|&
literal|7
operator|)
operator|)
operator|)
return|;
block|}
end_block

end_unit

