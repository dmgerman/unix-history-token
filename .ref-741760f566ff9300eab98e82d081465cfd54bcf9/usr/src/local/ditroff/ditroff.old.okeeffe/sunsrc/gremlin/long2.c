begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)long2.c	1.2	%G%  *  * More routines to implement "long" commands for the SUN Gremlin  * picture editor.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|<suntool/tool_hs.h>
end_include

begin_include
include|#
directive|include
file|<suntool/menu.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* imports from graphics files */
end_comment

begin_extern
extern|extern GRBlankPoints(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRDisplayPoint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRSetTextPos(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from path.c */
end_comment

begin_extern
extern|extern PSetPath(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern PConvertTilde(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|PGetPath
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from display.c */
end_comment

begin_extern
extern|extern DISClearSetDisplay(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DISScreenAdd(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DISScreenErase(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from database files */
end_comment

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBRead
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCreateElt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTMakeTextPoints
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTMakePoint
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern DBAddSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBChangeBrush(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBChangeType(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBChangeTypeStipple(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBClearElt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBClearSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBDelete(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBGravitate(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBXform(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from undodb.c */
end_comment

begin_decl_stmt
specifier|extern
name|UNELT
modifier|*
name|unlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|UNELT
modifier|*
name|unback
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern UNForget(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from short.c */
end_comment

begin_extern
extern|extern SHUpdate(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|adj
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from text.c */
end_comment

begin_extern
extern|extern TxKillLine(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern TxMsgOK(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern TxPutMsg(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from menu.c  */
end_comment

begin_extern
extern|extern MNHighLt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern MNUnHighLt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern HiMode[];
end_extern

begin_comment
comment|/* imports from C */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from sun.c */
end_comment

begin_extern
extern|extern flush_window_input(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern prompt_ok(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|namestripe
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|version
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|tool
modifier|*
name|tool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pixfont
modifier|*
name|text_pf
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern tool_fd;
end_extern

begin_extern
extern|extern menu_fd;
end_extern

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|PICTURE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current PICTURE database      */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|cset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set database          */
end_comment

begin_extern
extern|extern Orientation;
end_extern

begin_comment
comment|/* orientation of workspace      */
end_comment

begin_extern
extern|extern SEARCH;
end_extern

begin_comment
comment|/* flag for path search          */
end_comment

begin_extern
extern|extern Alignment;
end_extern

begin_comment
comment|/* point alignment indicator     */
end_comment

begin_extern
extern|extern CBRUSH;
end_extern

begin_comment
comment|/* current brush                 */
end_comment

begin_extern
extern|extern CSTIPPLE;
end_extern

begin_comment
comment|/* current stipple               */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|PX
decl_stmt|,
name|PY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor coordinates            */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|Lastx
decl_stmt|,
name|Lasty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous cursor coordinates   */
end_comment

begin_extern
extern|extern SEQ;
end_extern

begin_comment
comment|/* point sequence number         */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|POINTLIST
decl_stmt|,
modifier|*
name|BACKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated point list        */
end_comment

begin_extern
extern|extern Gridsize;
end_extern

begin_comment
comment|/* grid spacing                  */
end_comment

begin_extern
extern|extern Adjustment;
end_extern

begin_comment
comment|/* point adjustment mode         */
end_comment

begin_extern
extern|extern CHANGED;
end_extern

begin_comment
comment|/* PICTURE changed flag          */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|MEN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers for user symbols     */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
name|MENPOINT
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers used fo user symbols */
end_comment

begin_extern
extern|extern newfileformat;
end_extern

begin_comment
comment|/* TRUE if using SUN file format */
end_comment

begin_comment
comment|/*  imports from long1.c         */
end_comment

begin_extern
extern|extern CSP(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern CP(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
modifier|*
name|Editfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|eltnames
index|[]
init|=
block|{
literal|"BOTLEFT"
block|,
literal|"BOTRIGHT"
block|,
literal|"CENTCENT"
block|,
literal|"VECTOR"
block|,
literal|"ARC"
block|,
literal|"CURVE"
block|,
literal|"POLYGON"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"TOPLEFT"
block|,
literal|"TOPCENT"
block|,
literal|"TOPRIGHT"
block|,
literal|"CENTLEFT"
block|,
literal|"CENTRIGHT"
block|,
literal|"BOTCENT"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nowrite_msg
index|[]
init|=
literal|"NO WRITE SINCE LAST CHANGE!       Press left button to \ edit new file, middle or right button to cancel."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|filexists_msg
index|[]
init|=
literal|"FILE EXISTS!  Press left button to overwrite, middle \ or right button to cancel."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|quit_msg
index|[]
init|=
literal|"NO WRITE SINCE LAST CHANGE!       Press left button \ to confirm quit, middle or right button to cancel."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|quit2_msg
index|[]
init|=
literal|"Press left button to confirm quit, middle or right \ button to cancel."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BADNUM
value|-1
end_define

begin_define
define|#
directive|define
name|NONUM
value|-2
end_define

begin_decl_stmt
specifier|static
name|char
name|badarg
index|[]
init|=
literal|"bad args"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine creates and displays a POLYGON element from the  * points previously specified.  */
end_comment

begin_expr_stmt
specifier|static
name|LGDrawPolygon
argument_list|(
argument|bordered
argument_list|)
name|int
name|bordered
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|POINT
modifier|*
name|p0
decl_stmt|,
modifier|*
name|plist
decl_stmt|;
name|ELT
modifier|*
name|e1
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|3
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
literal|"need at least 3 points"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p0
operator|=
name|p1
operator|=
name|POINTLIST
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|POLYGON
argument_list|,
name|plist
argument_list|,
name|bordered
condition|?
name|CBRUSH
else|:
literal|0
argument_list|,
name|CSTIPPLE
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGDrawPolygon */
end_comment

begin_macro
name|LGBPolygon
argument_list|()
end_macro

begin_block
block|{
name|LGDrawPolygon
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LGPolygon
argument_list|()
end_macro

begin_block
block|{
name|LGDrawPolygon
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Modify elements in current set to POLYGON type with the indicated  * brush.  POLYGONs, CURVEs and VECTORs can be modified to either  * bordered or unbordered POLYGONs.  */
end_comment

begin_macro
name|LGModifyPolygon
argument_list|(
argument|brush
argument_list|)
end_macro

begin_decl_stmt
name|int
name|brush
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero for unbordered */
end_comment

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no current set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|CSP
argument_list|()
expr_stmt|;
name|elt
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|POLYGON
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBChangeBrush
argument_list|(
name|elt
argument_list|,
name|brush
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|elt
operator|->
name|type
operator|==
name|VECTOR
operator|)
operator|||
operator|(
name|elt
operator|->
name|type
operator|==
name|CURVE
operator|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|brush
operator|!=
literal|0
condition|)
comment|/* bordered polygon */
name|DBChangeTypeStipple
argument_list|(
name|elt
argument_list|,
name|POLYGON
argument_list|,
name|CSTIPPLE
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
else|else
comment|/* unbordered polygon */
name|DBChangeTypeBrushStipple
argument_list|(
name|elt
argument_list|,
name|POLYGON
argument_list|,
literal|0
argument_list|,
name|CSTIPPLE
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGModifyPolygon */
end_comment

begin_comment
comment|/*  * Modify curves, vectors and polygons in the current set  * to bordered polygons.  */
end_comment

begin_macro
name|LGMBPolygon
argument_list|()
end_macro

begin_block
block|{
name|LGModifyPolygon
argument_list|(
name|CBRUSH
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Modify curves, vectors and polygons in the current set  * to unbordered polygons.  */
end_comment

begin_macro
name|LGMPolygon
argument_list|()
end_macro

begin_block
block|{
name|LGModifyPolygon
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Modify curves and polygons in the current set to vectors.  */
end_comment

begin_macro
name|LGMVector
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no current set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|CSP
argument_list|()
expr_stmt|;
name|elt
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|POLYGON
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|brushf
operator|!=
literal|0
condition|)
name|DBChangeTypeStipple
argument_list|(
name|elt
argument_list|,
name|VECTOR
argument_list|,
literal|0
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
else|else
name|DBChangeTypeBrushStipple
argument_list|(
name|elt
argument_list|,
name|VECTOR
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|CURVE
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBChangeType
argument_list|(
name|elt
argument_list|,
name|VECTOR
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Modify vectors and polygons in the current set to curves.  */
end_comment

begin_macro
name|LGMCurve
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no current set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|CSP
argument_list|()
expr_stmt|;
name|elt
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|VECTOR
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBChangeType
argument_list|(
name|elt
argument_list|,
name|CURVE
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|POLYGON
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|brushf
operator|!=
literal|0
condition|)
comment|/* bordered polygon */
name|DBChangeTypeStipple
argument_list|(
name|elt
argument_list|,
name|CURVE
argument_list|,
literal|0
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
else|else
comment|/* unbordered polygon */
name|DBChangeTypeBrushStipple
argument_list|(
name|elt
argument_list|,
name|CURVE
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|LGIncludeSet
argument_list|()
end_macro

begin_comment
comment|/*  * This routine adds all elements selected by points in POINTLIST  * to the current set.  It does not remove previously selected elements.  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|ELT
modifier|*
name|e1
decl_stmt|;
name|float
name|n1
decl_stmt|,
name|n2
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SEQ
operator|==
literal|0
condition|)
block|{
comment|/* no points: entire picture becomes current set */
name|e1
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DBInCset
argument_list|(
name|e1
argument_list|)
condition|)
block|{
comment|/* not now in current set */
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
comment|/* add it to current set */
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|csetmask
argument_list|)
expr_stmt|;
comment|/* and display it */
block|}
name|e1
operator|=
name|DBNextElt
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p1
operator|=
name|POINTLIST
expr_stmt|;
comment|/* for each user point */
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
block|{
comment|/* find closest element */
name|DBGravitate
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|n2
argument_list|,
operator|&
name|p2
argument_list|,
operator|&
name|e1
argument_list|,
name|PICTURE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* if something's close and its not already in the current set */
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
operator|&&
operator|!
name|DBInCset
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
comment|/* add it */
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|csetmask
argument_list|)
expr_stmt|;
comment|/* and display it */
block|}
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
name|CP
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGIncludeSet */
end_comment

begin_comment
comment|/*  * This routine implements the menu command.  The contents of   * the specified user menu item is copied into the PICTURE transformed  * to the positioning point.  */
end_comment

begin_macro
name|LGGet
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|int
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ELT
modifier|*
name|elist
decl_stmt|,
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|int
name|symbol
decl_stmt|,
name|index
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"no positioning point"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|buffer
operator|--
expr_stmt|;
comment|/* users inputs number between 1 and N, actual                      buffer number is between 0 and N-1 */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* create transformation matrix */
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* for copy into PICTURE        */
name|plist
operator|=
name|POINTLIST
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|)
block|{
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|plist
operator|->
name|x
operator|-
operator|(
name|MENPOINT
index|[
name|buffer
index|]
operator|)
operator|.
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|plist
operator|->
name|y
operator|-
operator|(
name|MENPOINT
index|[
name|buffer
index|]
operator|)
operator|.
name|y
expr_stmt|;
name|elist
operator|=
name|MEN
index|[
name|buffer
index|]
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
comment|/* copy buffer to picture */
name|e1
operator|=
name|DBCopy
argument_list|(
name|elist
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|elist
operator|=
name|DBNextElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGGet */
end_comment

begin_macro
name|LGGet1
argument_list|()
end_macro

begin_block
block|{
name|LGGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LGGet2
argument_list|()
end_macro

begin_block
block|{
name|LGGet
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LGGet3
argument_list|()
end_macro

begin_block
block|{
name|LGGet
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LGGet4
argument_list|()
end_macro

begin_block
block|{
name|LGGet
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine reads in the specified filename (command line) to the  * selected user symbol or current set if no user symbol is selected.  If  * no filename is specified, the current set is copied to the user symbol;  */
end_comment

begin_macro
name|LGRead
argument_list|()
end_macro

begin_block
block|{
name|POINT
name|pos
decl_stmt|,
name|ppos
decl_stmt|;
name|ELT
modifier|*
name|elist
decl_stmt|,
modifier|*
name|e1
decl_stmt|;
name|char
name|tname
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
name|int
name|orient
decl_stmt|;
name|text_getvalue
argument_list|(
operator|&
name|tname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tname
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"read from where?"
argument_list|)
expr_stmt|;
return|return;
block|}
name|elist
operator|=
name|DBRead
argument_list|(
name|tname
argument_list|,
operator|&
name|orient
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* read file */
if|if
condition|(
name|elist
operator|==
operator|(
name|ELT
operator|*
operator|)
name|NULL
condition|)
return|return;
name|UNForget
argument_list|()
expr_stmt|;
comment|/* forget changes registered */
comment|/* by DBRead */
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
block|{
comment|/* no positioning point */
name|ppos
operator|.
name|x
operator|=
name|pos
operator|.
name|x
expr_stmt|;
name|ppos
operator|.
name|y
operator|=
name|pos
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|ppos
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|ppos
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up matrix to copy to */
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* appropriate place in */
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|ppos
operator|.
name|x
operator|-
name|pos
operator|.
name|x
expr_stmt|;
comment|/* picture as current set */
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|ppos
operator|.
name|y
operator|-
name|pos
operator|.
name|y
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
name|e1
operator|=
name|DBCopy
argument_list|(
name|elist
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
name|DBClearElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
name|elist
operator|=
name|e1
expr_stmt|;
block|}
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
name|TxKillLine
argument_list|()
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGRead */
end_comment

begin_comment
comment|/*  * This routine reads in a new PICTURE for editing  */
end_comment

begin_macro
name|LGEdit
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|POpen
argument_list|()
decl_stmt|;
name|POINT
name|pos
decl_stmt|;
name|ELT
modifier|*
name|e1
decl_stmt|;
name|char
modifier|*
name|prealname
decl_stmt|,
modifier|*
name|tn
decl_stmt|,
name|tname
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|text_getvalue
argument_list|(
operator|&
name|tname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHANGED
condition|)
block|{
if|if
condition|(
operator|!
name|prompt_ok
argument_list|(
name|menu_fd
argument_list|,
name|nowrite_msg
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
block|{
comment|/* clear current PICTURE */
name|e1
operator|=
name|DBNextElt
argument_list|(
name|PICTURE
argument_list|)
expr_stmt|;
name|DBClearElt
argument_list|(
name|PICTURE
argument_list|)
expr_stmt|;
name|PICTURE
operator|=
name|e1
expr_stmt|;
block|}
name|tn
operator|=
name|tname
expr_stmt|;
name|POINTLIST
operator|=
name|PTInit
argument_list|()
expr_stmt|;
comment|/* initialize globals */
name|SEQ
operator|=
literal|0
expr_stmt|;
name|CHANGED
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|namestripe
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tname
operator|!=
literal|'\0'
condition|)
block|{
comment|/* filename present */
name|fp
operator|=
name|POpen
argument_list|(
name|tname
argument_list|,
operator|&
name|prealname
argument_list|,
name|SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|PICTURE
operator|=
name|DBInit
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|Editfile
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|namestripe
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"creating new file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Editfile
argument_list|,
name|prealname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|namestripe
argument_list|,
name|prealname
argument_list|)
expr_stmt|;
name|PICTURE
operator|=
name|DBRead
argument_list|(
name|tname
argument_list|,
operator|&
name|Orientation
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|prealname
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|strcat
argument_list|(
name|namestripe
argument_list|,
literal|" (read only)"
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* create new file */
name|PICTURE
operator|=
name|DBInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|namestripe
argument_list|,
literal|"new file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Editfile
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tool_display
argument_list|(
name|tool
argument_list|)
expr_stmt|;
name|unlist
operator|=
name|unback
operator|=
name|NULL
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|SHUpdate
argument_list|()
expr_stmt|;
comment|/* display new picture */
name|TxKillLine
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGEdit */
end_comment

begin_comment
comment|/*   * This routine (re) displays the points in the back-up pointlist  */
end_comment

begin_expr_stmt
specifier|static
name|restorepoints
argument_list|()
block|{
specifier|register
name|POINT
operator|*
name|plist
block|,
operator|*
name|pl1
block|;
specifier|register
name|i
block|;
name|GRBlankPoints
argument_list|(
name|POINTLIST
argument_list|)
block|;
name|plist
operator|=
name|BACKPOINT
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|Lastx
operator|=
name|plist
operator|->
name|x
expr_stmt|;
name|Lasty
operator|=
name|plist
operator|->
name|y
expr_stmt|;
name|GRDisplayPoint
argument_list|(
name|plist
operator|->
name|x
argument_list|,
name|plist
operator|->
name|y
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
name|pl1
operator|=
name|POINTLIST
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|POINTLIST
operator|=
name|BACKPOINT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SEQ
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BACKPOINT
operator|=
name|pl1
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* end restorepoints */
end_comment

begin_comment
comment|/*   * This routine uses the information in the undo database to reconstruct  * the PICTURE as it was before the last command.  The undo database is set  * so that the next undo would nullify this one.  * An undo of an Add is to delete the new element.  * Add the old element back to undo a delete.  * Modified elements are undone by copying the old element into the database  * in place of the modified element.  */
end_comment

begin_expr_stmt
unit|LGUndo
operator|(
operator|)
block|{
name|UNELT
operator|*
name|fix
block|,
operator|*
name|temp
block|;
name|ELT
operator|*
operator|(
operator|*
name|e1
operator|)
block|;
name|fix
operator|=
name|unlist
block|;
comment|/* initialize unlist so that undo-ing can */
name|unlist
operator|=
name|NULL
block|;
comment|/* add items to properly undo the undo */
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
block|{
name|fix
operator|=
name|unback
expr_stmt|;
name|unback
operator|=
name|NULL
expr_stmt|;
block|}
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DBClearSet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|fix
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|action
condition|)
block|{
case|case
name|ADD
case|:
name|DISScreenErase
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|pixmask
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|restorepoints
argument_list|()
expr_stmt|;
name|DBDelete
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|fix
operator|->
name|dbase
argument_list|)
expr_stmt|;
name|temp
operator|=
name|fix
operator|->
name|nextun
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fix
argument_list|)
expr_stmt|;
name|fix
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|fix
operator|->
name|action
operator|=
name|ADD
expr_stmt|;
comment|/* create undo unelt */
name|fix
operator|->
name|newelt
operator|=
name|fix
operator|->
name|oldelt
expr_stmt|;
name|fix
operator|->
name|oldelt
operator|=
name|NULL
expr_stmt|;
name|fix
operator|->
name|newelt
operator|->
name|nextelt
operator|=
name|PICTURE
expr_stmt|;
name|restorepoints
argument_list|()
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|fix
operator|->
name|newelt
argument_list|)
expr_stmt|;
name|PICTURE
operator|=
name|fix
operator|->
name|newelt
expr_stmt|;
comment|/* put in database */
name|temp
operator|=
name|fix
operator|->
name|nextun
expr_stmt|;
name|fix
operator|->
name|nextun
operator|=
name|unlist
expr_stmt|;
comment|/* link into unlist */
name|unlist
operator|=
name|fix
expr_stmt|;
name|fix
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|DISScreenErase
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|pixmask
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|restorepoints
argument_list|()
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|fix
operator|->
name|oldelt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|fix
operator|->
name|oldelt
argument_list|)
expr_stmt|;
name|e1
operator|=
name|fix
operator|->
name|dbase
expr_stmt|;
while|while
condition|(
operator|*
name|e1
operator|!=
name|fix
operator|->
name|newelt
condition|)
block|{
comment|/* find elt to replace */
name|e1
operator|=
operator|&
operator|(
name|DBNextElt
argument_list|(
operator|(
operator|*
name|e1
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|fix
operator|->
name|oldelt
operator|->
name|nextelt
operator|=
name|DBNextElt
argument_list|(
operator|(
operator|*
name|e1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|e1
operator|=
name|fix
operator|->
name|oldelt
expr_stmt|;
name|fix
operator|->
name|oldelt
operator|=
name|fix
operator|->
name|newelt
expr_stmt|;
name|fix
operator|->
name|newelt
operator|=
operator|*
name|e1
expr_stmt|;
comment|/* create undo unelt */
name|temp
operator|=
name|fix
operator|->
name|nextun
expr_stmt|;
name|fix
operator|->
name|nextun
operator|=
name|unlist
expr_stmt|;
name|unlist
operator|=
name|fix
expr_stmt|;
comment|/* link into unlist */
name|fix
operator|=
name|temp
expr_stmt|;
break|break;
block|}
block|}
end_while

begin_comment
unit|}
comment|/* end LGUndo */
end_comment

begin_comment
comment|/*   * Write elements from elist to filename.  * If setonly is true, elements are taken from the "setnext"  * pointer; otherwise, elements are taken from "nextelt".  * Ie., the current set is written with setonly = TRUE and  * the complete picture is written with setonly = FALSE.  */
end_comment

begin_macro
unit|static
name|LGWriteSet
argument_list|(
argument|elist
argument_list|,
argument|filename
argument_list|,
argument|setonly
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|,
name|pos
decl_stmt|;
name|char
name|string
index|[
literal|256
index|]
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"can't open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
name|TxPutMsg
argument_list|(
literal|"writing file..."
argument_list|)
expr_stmt|;
name|UNForget
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|SEQ
operator|>
literal|0
condition|)
block|{
comment|/* specified a positioning point */
name|pos
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|elist
operator|->
name|ptlist
operator|->
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|elist
operator|->
name|ptlist
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pos
operator|.
name|y
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newfileformat
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"sungremlinfile\n"
argument_list|)
expr_stmt|;
comment|/* write header */
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"gremlinfile\n"
argument_list|)
expr_stmt|;
comment|/* write header */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %1.2f %1.2f\n"
argument_list|,
name|Orientation
argument_list|,
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
comment|/* write each element */
if|if
condition|(
name|newfileformat
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|eltnames
index|[
name|elist
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|elist
operator|->
name|type
argument_list|)
expr_stmt|;
name|plist
operator|=
name|elist
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|)
block|{
comment|/* write each point */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%1.2f %1.2f\n"
argument_list|,
name|plist
operator|->
name|x
argument_list|,
name|plist
operator|->
name|y
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newfileformat
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"*\n"
argument_list|)
expr_stmt|;
comment|/* end pointlist */
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-1.00 -1.00\n"
argument_list|)
expr_stmt|;
comment|/* end pointlist */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %d\n"
argument_list|,
name|elist
operator|->
name|brushf
argument_list|,
name|elist
operator|->
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %s\n"
argument_list|,
name|strlen
argument_list|(
name|elist
operator|->
name|textpt
argument_list|)
argument_list|,
name|elist
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|elist
operator|=
name|setonly
condition|?
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
else|:
name|DBNextElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-1\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|TxKillLine
argument_list|()
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGWriteSet */
end_comment

begin_comment
comment|/*  * This routine writes the current set into the specified filename  */
end_comment

begin_macro
name|LGSave
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|tname
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|,
name|filename
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|,
modifier|*
name|tn
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
name|int
name|space
decl_stmt|,
name|stat
decl_stmt|;
name|space
operator|=
name|TEXT_BUFMAX
expr_stmt|;
name|text_getvalue
argument_list|(
operator|&
name|tname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tn
operator|=
name|tname
expr_stmt|;
name|fn
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|tname
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"write to where?"
argument_list|)
expr_stmt|;
return|return;
block|}
name|stat
operator|=
name|PConvertTilde
argument_list|(
operator|&
name|tn
argument_list|,
operator|&
name|fn
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
operator|*
name|fn
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|FALSE
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"unknown path %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|prompt_ok
argument_list|(
name|menu_fd
argument_list|,
name|filexists_msg
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|LGWriteSet
argument_list|(
name|cset
argument_list|,
name|filename
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGSave */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * This routine writes the current PICTURE into the specified filename  * or to the current Editfile  */
end_comment

begin_macro
name|LGWrite
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|tname
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|,
name|filename
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|,
modifier|*
name|tn
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
name|int
name|space
decl_stmt|,
name|stat
decl_stmt|;
name|space
operator|=
name|TEXT_BUFMAX
expr_stmt|;
name|text_getvalue
argument_list|(
operator|&
name|tname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tn
operator|=
name|tname
expr_stmt|;
name|fn
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|Editfile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"write to where?"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|filename
argument_list|,
name|Editfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stat
operator|=
name|PConvertTilde
argument_list|(
operator|&
name|tn
argument_list|,
operator|&
name|fn
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
operator|*
name|fn
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|FALSE
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"unknown path %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|prompt_ok
argument_list|(
name|menu_fd
argument_list|,
name|filexists_msg
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|LGWriteSet
argument_list|(
name|PICTURE
argument_list|,
name|filename
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGWrite */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * This routine terminates the editor.  The terminal states for the text  * terminal and the graphics display are restored and an EXIT is performed.  */
end_comment

begin_macro
name|LGQuit
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|prompt_ok
argument_list|(
name|tool_fd
argument_list|,
name|CHANGED
condition|?
name|quit_msg
else|:
name|quit2_msg
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGQuit */
end_comment

begin_comment
comment|/*  * Horizontal Adjust -  * This routine toggles the adjustment mode.  */
end_comment

begin_macro
name|LGHAdjust
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Adjustment
operator|==
name|HORZ
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|HORZ
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Adjustment
operator|!=
name|NOADJ
condition|)
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|HORZ
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|HORZ
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end LGHAdjust */
end_comment

begin_comment
comment|/*  * Vertical Adjust -  * This routine toggles the adjustment mode.  */
end_comment

begin_macro
name|LGVAdjust
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Adjustment
operator|==
name|VERT
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|VERT
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Adjustment
operator|!=
name|NOADJ
condition|)
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|VERT
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|VERT
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end LGVAdjust */
end_comment

begin_comment
comment|/*  * This local routine returns 1 if x>= 0  * otherwise returns -1  */
end_comment

begin_expr_stmt
specifier|static
name|sign
argument_list|(
argument|x
argument_list|)
name|float
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|x
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This routine is called by all mirroring routines to effect the  * transformation specified by xmat.  */
end_comment

begin_expr_stmt
specifier|static
name|mirror
argument_list|(
argument|xmat
argument_list|)
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
name|POINT
name|pt
decl_stmt|,
name|pos
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|UNForget
argument_list|()
expr_stmt|;
name|elt
operator|=
name|cset
expr_stmt|;
name|CSP
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|elt
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|elt
operator|->
name|type
argument_list|)
condition|)
block|{
name|GRSetTextPos
argument_list|(
name|elt
operator|->
name|textpt
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|elt
operator|->
name|ptlist
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|elt
operator|->
name|ptlist
operator|=
name|PTMakeTextPoints
argument_list|(
name|elt
operator|->
name|textpt
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|elt
operator|->
name|ptlist
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|elt
operator|->
name|type
operator|==
name|ARC
operator|)
operator|&&
operator|(
name|elt
operator|->
name|size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* arcs require special handling */
comment|/* but, circles OK and mirror in both directions OK */
comment|/* otherwise, swap starting and ending points of arc */
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|elt
operator|->
name|ptlist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pt
operator|.
name|x
operator|=
name|p1
operator|->
name|x
expr_stmt|;
name|pt
operator|.
name|y
operator|=
name|p1
operator|->
name|y
expr_stmt|;
name|p1
operator|->
name|x
operator|=
name|p2
operator|->
name|x
expr_stmt|;
name|p1
operator|->
name|y
operator|=
name|p2
operator|->
name|y
expr_stmt|;
name|p2
operator|->
name|x
operator|=
name|pt
operator|.
name|x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|pt
operator|.
name|y
expr_stmt|;
block|}
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end mirror */
end_comment

begin_comment
comment|/*  * This routine mirrors the elements in the current set VERTICALLY  * The mirroring is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_macro
name|LGVMirror
argument_list|()
end_macro

begin_block
block|{
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
literal|"not enough points"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no current set"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* create transformation matrix to translate set to origin,         perform the mirroring and translate back */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1.0
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1.0
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|2.0
operator|*
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|mirror
argument_list|(
name|xmat
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGVMirror */
end_comment

begin_comment
comment|/*  * This routine mirrors the elements in the current set HORIZONTALLY  * The mirroring is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_macro
name|LGHMirror
argument_list|()
end_macro

begin_block
block|{
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
literal|"not enough points"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no current set"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* create transformation matrix to translate set to origin,         perform the mirroring and translate back */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|1.0
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|1.0
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|2.0
operator|*
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|mirror
argument_list|(
name|xmat
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGHMirror */
end_comment

begin_comment
comment|/*  * This routine looks at the command line for parameters to set  * the current search path.  */
end_comment

begin_macro
name|LGPath
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|TEXT_BUFMAX
index|]
decl_stmt|;
specifier|register
name|i
operator|,
name|i2
expr_stmt|;
name|i
operator|=
name|i2
operator|=
operator|-
literal|1
expr_stmt|;
name|text_getvalue
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
index|[
operator|++
name|i
index|]
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
name|buf2
index|[
operator|++
name|i2
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
name|buf2
index|[
operator|++
name|i2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|buf2
operator|==
literal|'\0'
condition|)
name|TxPutMsg
argument_list|(
name|PGetPath
argument_list|()
argument_list|)
expr_stmt|;
comment|/* no arguments */
else|else
block|{
name|SEARCH
operator|=
name|TRUE
expr_stmt|;
name|PSetPath
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
name|TxKillLine
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGPath */
end_comment

begin_comment
comment|/*  * Sometimes it's important to do nothing.  */
end_comment

begin_macro
name|nop
argument_list|()
end_macro

begin_block
block|{ }
end_block

end_unit

