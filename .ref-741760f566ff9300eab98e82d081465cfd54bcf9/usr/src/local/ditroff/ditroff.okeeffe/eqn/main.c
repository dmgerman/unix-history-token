begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	2.2 (CWI) 86/04/09"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"e.h"
end_include

begin_define
define|#
directive|define
name|MAXLINE
value|3600
end_define

begin_comment
comment|/* maximum input line */
end_comment

begin_decl_stmt
name|char
name|in
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input buffer */
end_comment

begin_function_decl
name|int
name|eqnexit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|noeqn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmdname
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|eqnexit
argument_list|(
name|eqn
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|eqnexit
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|gcos
if|if
condition|(
name|n
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"run terminated due to eqn error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eqn
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|cmdname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"TYPESETTER"
argument_list|)
condition|)
name|typesetter
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|dbg
operator|++
expr_stmt|;
else|else
block|{
name|lefteq
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|righteq
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|gsize
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|deltaps
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|res
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|minsize
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|strcpy
argument_list|(
name|ftstack
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|noeqn
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|typesetter
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
name|dbg
operator|=
literal|1
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|settype
argument_list|(
name|typesetter
argument_list|)
expr_stmt|;
name|lookup
argument_list|(
name|deftbl
argument_list|,
name|strsave
argument_list|(
name|typesetter
argument_list|)
argument_list|,
name|strsave
argument_list|(
name|typesetter
argument_list|)
argument_list|)
expr_stmt|;
name|init_tbl
argument_list|()
expr_stmt|;
comment|/* install other keywords in tables */
name|curfile
operator|=
name|infile
expr_stmt|;
name|pushsrc
argument_list|(
name|File
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|curfile
operator|->
name|fin
operator|=
name|stdin
expr_stmt|;
name|curfile
operator|->
name|fname
operator|=
name|strsave
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|getdata
argument_list|()
expr_stmt|;
block|}
else|else
while|while
condition|(
name|argc
operator|--
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|curfile
operator|->
name|fin
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curfile
operator|->
name|fin
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open file %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|curfile
operator|->
name|fname
operator|=
name|strsave
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|getdata
argument_list|()
expr_stmt|;
if|if
condition|(
name|curfile
operator|->
name|fin
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|curfile
operator|->
name|fin
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|settype
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* initialize data for particular typesetter */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"202"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|972
expr_stmt|;
name|minsize
operator|=
literal|5
expr_stmt|;
name|ttype
operator|=
name|DEV202
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"aps"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|723
expr_stmt|;
name|minsize
operator|=
literal|5
expr_stmt|;
name|ttype
operator|=
name|DEVAPS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|432
expr_stmt|;
name|minsize
operator|=
literal|6
expr_stmt|;
name|ttype
operator|=
name|DEVCAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"har"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|1445
expr_stmt|;
name|minsize
operator|=
literal|4
expr_stmt|;
name|ttype
operator|=
name|DEVHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ver"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|200
expr_stmt|;
name|minsize
operator|=
literal|6
expr_stmt|;
name|ttype
operator|=
name|DEVVER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"psc"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Postscript printer (Laserwriter) using transcript */
name|res
operator|=
literal|576
expr_stmt|;
comment|/* at least, troff thinks so */
name|minsize
operator|=
literal|4
expr_stmt|;
comment|/* troff believes 2, but that's so small */
name|ttype
operator|=
name|DEVPSC
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|minsize
operator|=
literal|6
expr_stmt|;
name|ttype
operator|=
name|DEVCAT
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getdata
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|type
decl_stmt|,
name|ln
decl_stmt|;
name|char
name|fname
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|fin
operator|=
name|curfile
operator|->
name|fin
expr_stmt|;
name|curfile
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|".lf 1 %s\n"
argument_list|,
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|type
operator|=
name|getline
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|in
index|[
literal|2
index|]
operator|==
literal|'Q'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
name|used
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|markline
condition|)
block|{
comment|/* turn off from last time */
name|printf
argument_list|(
literal|".nr MK 0\n"
argument_list|)
expr_stmt|;
name|markline
operator|=
literal|0
expr_stmt|;
block|}
name|display
operator|=
literal|1
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|eqnreg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|markline
condition|)
name|printf
argument_list|(
literal|".nr MK %d\n"
argument_list|,
name|markline
argument_list|)
expr_stmt|;
comment|/* for -ms macros */
name|printf
argument_list|(
literal|".if %gm>\\n(.v .ne %gm\n"
argument_list|,
name|eqnht
argument_list|,
name|eqnht
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".rn %d 10\n"
argument_list|,
name|eqnreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noeqn
condition|)
name|printf
argument_list|(
literal|"\\*(10\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".EN"
argument_list|)
expr_stmt|;
while|while
condition|(
name|putchar
argument_list|(
name|input
argument_list|()
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|lefteq
condition|)
specifier|inline
operator|(
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|in
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|in
index|[
literal|2
index|]
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|in
operator|+
literal|3
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|ln
argument_list|,
name|fname
argument_list|)
operator|==
literal|2
condition|)
block|{
name|free
argument_list|(
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".lf %d %s\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|=
name|ln
argument_list|,
name|curfile
operator|->
name|fname
operator|=
name|strsave
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|=
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|getline
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
name|lefteq
condition|)
block|{
if|if
condition|(
name|s
operator|>=
name|in
operator|+
name|MAXLINE
condition|)
block|{
name|error
argument_list|(
literal|"input line too long: %.20s\n"
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|in
index|[
name|MAXLINE
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|lefteq
condition|)
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|inline
operator|(
operator|)
block|{
name|int
name|ds
block|,
name|n
block|,
name|sz1
operator|=
literal|0
block|;
name|n
operator|=
name|curfile
operator|->
name|lineno
block|;
if|if
condition|(
name|szstack
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|".nr %d \\n(.s\n"
argument_list|,
name|sz1
operator|=
name|salloc
argument_list|()
argument_list|)
expr_stmt|;
name|ds
operator|=
name|salloc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|".rm %d \n"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|display
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
if|if
condition|(
operator|*
name|in
condition|)
name|printf
argument_list|(
literal|".as %d \"%s\n"
argument_list|,
name|ds
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|eqnreg
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|".as %d \\*(%d\n"
argument_list|,
name|ds
argument_list|,
name|eqnreg
argument_list|)
expr_stmt|;
name|sfree
argument_list|(
name|eqnreg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|getline
argument_list|(
name|in
argument_list|)
operator|==
name|lefteq
condition|)
do|;
end_do

begin_if
if|if
condition|(
operator|*
name|in
condition|)
name|printf
argument_list|(
literal|".as %d \"%s"
argument_list|,
name|ds
argument_list|,
name|in
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sz1
condition|)
name|printf
argument_list|(
literal|"\\s\\n(%d"
argument_list|,
name|sz1
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|printf
argument_list|(
literal|"\\*(%d\n"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|curfile
operator|->
name|lineno
operator|>
name|n
operator|+
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"eqn warning: multi-line %c...%c, lines %d-%d, file %s\n"
argument_list|,
name|lefteq
argument_list|,
name|righteq
argument_list|,
name|n
argument_list|,
name|curfile
operator|->
name|lineno
argument_list|,
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|sfree
argument_list|(
name|ds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|sz1
condition|)
name|sfree
argument_list|(
name|sz1
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}  putout
operator|(
name|p1
operator|)
name|int
name|p1
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|float
name|before
decl_stmt|,
name|after
decl_stmt|;
name|dprintf
argument_list|(
literal|".\tanswer<- S%d, h=%g,b=%g\n"
argument_list|,
name|p1
argument_list|,
name|eht
index|[
name|p1
index|]
argument_list|,
name|ebase
index|[
name|p1
index|]
argument_list|)
expr_stmt|;
name|eqnht
operator|=
name|eht
index|[
name|p1
index|]
expr_stmt|;
name|before
operator|=
name|eht
index|[
name|p1
index|]
operator|-
name|ebase
index|[
name|p1
index|]
operator|-
literal|1.2
expr_stmt|;
comment|/* leave room for sub or superscript */
name|after
operator|=
name|ebase
index|[
name|p1
index|]
operator|-
literal|0.2
expr_stmt|;
if|if
condition|(
name|spaceval
operator|||
name|before
operator|>
literal|0.01
operator|||
name|after
operator|>
literal|0.01
condition|)
block|{
name|printf
argument_list|(
literal|".ds %d "
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* used to be \\x'0' here:  why? */
if|if
condition|(
name|spaceval
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\\x'0-%s'"
argument_list|,
name|spaceval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|before
operator|>
literal|0.01
condition|)
name|printf
argument_list|(
literal|"\\x'0-%gm'"
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\*(%d"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spaceval
operator|==
name|NULL
operator|&&
name|after
operator|>
literal|0.01
condition|)
name|printf
argument_list|(
literal|"\\x'%gm'"
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|szstack
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|".ds %d %s\\*(%d\\s\\n(99\n"
argument_list|,
name|p1
argument_list|,
name|DPS
argument_list|(
name|gsize
argument_list|,
name|gsize
argument_list|)
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|eqnreg
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|spaceval
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|spaceval
argument_list|)
expr_stmt|;
name|spaceval
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
name|synerr
operator|=
literal|0
expr_stmt|;
name|ct
operator|=
literal|0
expr_stmt|;
name|ps
operator|=
name|gsize
expr_stmt|;
name|ftp
operator|=
name|ftstack
expr_stmt|;
name|ft
operator|=
name|ftp
operator|->
name|ft
expr_stmt|;
name|nszstack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|szstack
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
comment|/* absolute gsize in effect */
name|printf
argument_list|(
literal|".nr 99 \\n(.s\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|salloc
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|used
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|used
index|[
name|i
index|]
operator|++
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"no eqn strings left (%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sfree
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|used
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|nrwid
argument_list|(
argument|n1
argument_list|,
argument|p
argument_list|,
argument|n2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n1
decl_stmt|,
name|p
decl_stmt|,
name|n2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|".nr %d 0\\w'%s\\*(%d'\n"
argument_list|,
name|n1
argument_list|,
name|DPS
argument_list|(
name|gsize
argument_list|,
name|p
argument_list|)
argument_list|,
name|n2
argument_list|)
expr_stmt|;
comment|/* 0 defends against - width */
block|}
end_block

begin_function
name|char
modifier|*
name|DPS
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
comment|/* delta ps (t-f) in printable form \s+d or \s-d or \s+-(dd */
name|int
name|f
decl_stmt|,
name|t
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|lb
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dn
decl_stmt|;
if|if
condition|(
name|lb
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|10
condition|)
name|lb
operator|=
name|buf
expr_stmt|;
name|p
operator|=
name|lb
expr_stmt|;
operator|*
name|lb
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|lb
operator|++
operator|=
literal|'s'
expr_stmt|;
name|dn
operator|=
name|EFFPS
argument_list|(
name|t
argument_list|)
operator|-
name|EFFPS
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|szstack
index|[
name|nszstack
index|]
operator|!=
literal|0
condition|)
comment|/* absolute */
name|dn
operator|=
name|EFFPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* should do proper \s(dd */
elseif|else
if|if
condition|(
name|dn
operator|>=
literal|0
condition|)
operator|*
name|lb
operator|++
operator|=
literal|'+'
expr_stmt|;
else|else
block|{
operator|*
name|lb
operator|++
operator|=
literal|'-'
expr_stmt|;
name|dn
operator|=
operator|-
name|dn
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|>=
literal|10
condition|)
block|{
comment|/* \s+(dd only works in new troff */
operator|*
name|lb
operator|++
operator|=
literal|'('
expr_stmt|;
operator|*
name|lb
operator|++
operator|=
name|dn
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|lb
operator|++
operator|=
name|dn
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lb
operator|++
operator|=
name|dn
operator|+
literal|'0'
expr_stmt|;
block|}
operator|*
name|lb
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_macro
name|EFFPS
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* effective value of n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>=
name|minsize
condition|)
return|return
name|n
return|;
else|else
return|return
name|minsize
return|;
block|}
end_block

begin_function
name|double
name|EM
parameter_list|(
name|m
parameter_list|,
name|ps
parameter_list|)
comment|/* convert m to ems in gsize */
name|double
name|m
decl_stmt|;
name|int
name|ps
decl_stmt|;
block|{
name|m
operator|*=
operator|(
name|float
operator|)
name|EFFPS
argument_list|(
name|ps
argument_list|)
operator|/
name|gsize
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0.001
operator|&&
name|m
operator|>=
operator|-
literal|0.001
condition|)
return|return
literal|0
return|;
else|else
return|return
name|m
return|;
block|}
end_function

begin_function
name|double
name|REL
parameter_list|(
name|m
parameter_list|,
name|ps
parameter_list|)
comment|/* convert m to ems in ps */
name|double
name|m
decl_stmt|;
name|int
name|ps
decl_stmt|;
block|{
name|m
operator|*=
operator|(
name|float
operator|)
name|gsize
operator|/
name|EFFPS
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0.001
operator|&&
name|m
operator|>=
operator|-
literal|0.001
condition|)
return|return
literal|0
return|;
else|else
return|return
name|m
return|;
block|}
end_function

end_unit

