begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"../hdr/had.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"@(#)snull.c	4.4	%G%"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|USXALLOC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|packet
name|gpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sid
name|sid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|had
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|Xiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Xcreate
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|deltalist
block|{
name|struct
name|deltalist
modifier|*
name|ds_olderdel
decl_stmt|;
name|struct
name|deltalist
modifier|*
name|ds_youngerdel
decl_stmt|;
name|struct
name|sid
name|ds_sid
decl_stmt|;
name|int
name|ds_origser
decl_stmt|;
name|int
name|ds_ser
decl_stmt|;
name|int
name|ds_pred
decl_stmt|;
name|long
name|ds_datetime
decl_stmt|;
name|char
name|ds_pgmr
index|[
name|SZLNAM
index|]
decl_stmt|;
name|char
name|ds_type
decl_stmt|;
name|struct
name|stats
name|ds_stats
decl_stmt|;
name|int
name|ds_insnull
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|deltalist
modifier|*
name|Dhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|deltalist
modifier|*
name|Dtail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|New_ser_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Max_old_ser
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
extern|extern snull(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|int
name|Fcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Flags for 'fatal'. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
name|FTLEXIT
operator||
name|FTLMSG
operator||
name|FTLCLN
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Process arguments. 	*/
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|fatal
argument_list|(
literal|"unknown key letter (cm1)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had
index|[
name|c
operator|-
literal|'a'
index|]
operator|++
condition|)
name|fatal
argument_list|(
literal|"key letter twice (cm2)"
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|num_files
operator|++
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|num_files
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"missing file arg (cm3)"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|setsig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Reset flags for 'fatal' so that it will return to 'main' 	rather than exiting. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|&=
operator|~
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fflags
operator||=
name|FTLJMP
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Invoke 'snull' for each file argument.  	*/
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|argv
index|[
name|i
index|]
condition|)
name|do_file
argument_list|(
name|p
argument_list|,
name|snull
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   snull
operator|(
name|file
operator|)
block|{
specifier|register
name|char
operator|*
name|p
block|;
specifier|register
name|int
name|ser
block|;
specifier|extern
name|char
name|had_dir
block|,
name|had_standinp
block|;
specifier|extern
name|char
operator|*
name|Sflags
index|[]
block|; 	struct
name|stats
name|stats
block|;
name|int
name|newser
block|;
comment|/* 	Set up to return to caller ('main') from 'fatal'. 	*/
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
return|return;
name|sinit
argument_list|(
operator|&
name|gpkt
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* init packet and open file */
end_comment

begin_if
if|if
condition|(
name|exists
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'p'
argument_list|)
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"p-file exists (sn3)"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|lockit
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'z'
argument_list|)
argument_list|,
literal|2
argument_list|,
name|getpid
argument_list|()
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"cannot create lock file (cm4)"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	Indicate that file is to be re-opened (from beginning) 	after it reaches EOF. 	The file is read once to get the delta table 	(without copying to x-file) and then again to make 	required modifications to it (using x-file). 	*/
end_comment

begin_expr_stmt
name|gpkt
operator|.
name|p_reopen
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dodeltbl
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* get delta table */
end_comment

begin_expr_stmt
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|EUSERNAM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|doflags
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* get flags */
end_comment

begin_comment
comment|/* 	Indicate to 'getline' that EOF is allowable. 	*/
end_comment

begin_expr_stmt
name|gpkt
operator|.
name|p_chkeof
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Flush through rest of file. 	This checks for corruptions. 	*/
end_comment

begin_while
while|while
condition|(
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
condition|)
empty_stmt|;
end_while

begin_if
if|if
condition|(
name|num_files
operator|>
literal|1
operator|||
name|had_dir
operator|||
name|had_standinp
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|gpkt
operator|.
name|p_file
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	Here, file has already been re-opened (by 'getline'). 	Indicate that x-file is to be used. 	*/
end_comment

begin_expr_stmt
name|gpkt
operator|.
name|p_upd
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* skip over old */
end_comment

begin_expr_stmt
name|gpkt
operator|.
name|p_wrttn
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* header record */
end_comment

begin_comment
comment|/* 	Write new header. 	*/
end_comment

begin_expr_stmt
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c00000\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|HEAD
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mkdelt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* insert 'null' deltas */
end_comment

begin_expr_stmt
name|wrtdeltbl
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* write out new delta table */
end_comment

begin_expr_stmt
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|EUSERNAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	If file does not have the 'n' flag, put one in. 	*/
end_comment

begin_if
if|if
condition|(
operator|!
name|Sflags
index|[
name|NULLFLAG
operator|-
literal|'a'
index|]
condition|)
name|putline
argument_list|(
operator|&
name|gpkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
name|NULLFLAG
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|flushto
argument_list|(
operator|&
name|gpkt
argument_list|,
name|EUSERTXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Process body, changing control-line serial numbers 	appropriately. 	*/
end_comment

begin_expr_stmt
name|fixbody
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flushline
argument_list|(
operator|&
name|gpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* flush buffer, fix header, and close */
end_comment

begin_expr_stmt
name|rename
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'x'
argument_list|)
argument_list|,
name|gpkt
operator|.
name|p_file
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clean_up
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   dodeltbl
operator|(
name|pkt
operator|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|deltab
name|dt
decl_stmt|;
name|struct
name|stats
name|stats
decl_stmt|;
name|struct
name|deltalist
modifier|*
name|newp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|Dhead
operator|=
name|Dtail
operator|=
name|newp
operator|=
literal|0
expr_stmt|;
comment|/* 	Read entire delta table. 	*/
while|while
condition|(
name|getstats
argument_list|(
name|pkt
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
name|getadel
argument_list|(
name|pkt
argument_list|,
operator|&
name|dt
argument_list|)
operator|!=
name|BDELTAB
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|newp
operator|=
name|alloc
argument_list|(
name|n
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|Dhead
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|newp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Dhead
condition|)
block|{
name|Dhead
operator|=
name|newp
expr_stmt|;
name|New_ser_ptr
operator|=
name|alloc
argument_list|(
name|n
operator|=
literal|2
operator|*
operator|(
name|dt
operator|.
name|d_serial
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|New_ser_ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Max_old_ser
operator|=
name|dt
operator|.
name|d_serial
expr_stmt|;
block|}
else|else
block|{
name|Dtail
operator|->
name|ds_olderdel
operator|=
name|newp
expr_stmt|;
name|newp
operator|->
name|ds_youngerdel
operator|=
name|Dtail
expr_stmt|;
block|}
name|newp
operator|->
name|ds_sid
operator|.
name|s_rel
operator|=
name|dt
operator|.
name|d_sid
operator|.
name|s_rel
expr_stmt|;
name|newp
operator|->
name|ds_sid
operator|.
name|s_lev
operator|=
name|dt
operator|.
name|d_sid
operator|.
name|s_lev
expr_stmt|;
name|newp
operator|->
name|ds_sid
operator|.
name|s_br
operator|=
name|dt
operator|.
name|d_sid
operator|.
name|s_br
expr_stmt|;
name|newp
operator|->
name|ds_sid
operator|.
name|s_seq
operator|=
name|dt
operator|.
name|d_sid
operator|.
name|s_seq
expr_stmt|;
name|newp
operator|->
name|ds_origser
operator|=
name|dt
operator|.
name|d_serial
expr_stmt|;
name|newp
operator|->
name|ds_ser
operator|=
name|dt
operator|.
name|d_serial
expr_stmt|;
name|newp
operator|->
name|ds_pred
operator|=
name|dt
operator|.
name|d_pred
expr_stmt|;
name|newp
operator|->
name|ds_datetime
operator|=
name|dt
operator|.
name|d_datetime
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dt
operator|.
name|d_pgmr
argument_list|,
name|newp
operator|->
name|ds_pgmr
argument_list|,
sizeof|sizeof
argument_list|(
name|dt
operator|.
name|d_pgmr
argument_list|)
argument_list|)
expr_stmt|;
name|newp
operator|->
name|ds_type
operator|=
name|dt
operator|.
name|d_type
expr_stmt|;
name|newp
operator|->
name|ds_stats
operator|.
name|s_ins
operator|=
name|stats
operator|.
name|s_ins
expr_stmt|;
name|newp
operator|->
name|ds_stats
operator|.
name|s_del
operator|=
name|stats
operator|.
name|s_del
expr_stmt|;
name|newp
operator|->
name|ds_stats
operator|.
name|s_unc
operator|=
name|stats
operator|.
name|s_unc
expr_stmt|;
name|Dtail
operator|=
name|newp
expr_stmt|;
comment|/* 		Skip over rest of delta entry.  		*/
while|while
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|(
name|pkt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
break|break;
else|else
block|{
switch|switch
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EDELTAB
case|:
break|break;
case|case
name|INCLUDE
case|:
case|case
name|EXCLUDE
case|:
case|case
name|IGNORE
case|:
case|case
name|MRNUM
case|:
case|case
name|COMMENTS
case|:
continue|continue;
default|default:
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|getadel
argument_list|(
name|pkt
argument_list|,
name|dt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|deltab
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
operator|==
name|NULL
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|del_ab
argument_list|(
name|pkt
operator|->
name|p_line
argument_list|,
name|dt
argument_list|,
name|pkt
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|getstats
argument_list|(
name|pkt
argument_list|,
name|statp
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|stats
modifier|*
name|statp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pkt
operator|->
name|p_line
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
operator|==
name|NULL
operator|||
operator|*
name|p
operator|++
operator|!=
name|CTLCHAR
operator|||
operator|*
name|p
operator|++
operator|!=
name|STATS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|satoi
argument_list|(
name|p
argument_list|,
operator|&
name|statp
operator|->
name|s_ins
argument_list|)
expr_stmt|;
name|p
operator|=
name|satoi
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|statp
operator|->
name|s_del
argument_list|)
expr_stmt|;
name|satoi
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|statp
operator|->
name|s_unc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|mkdelt
argument_list|()
end_macro

begin_block
block|{
name|struct
name|deltalist
modifier|*
name|ptr
decl_stmt|;
name|struct
name|deltalist
modifier|*
name|nulldel
decl_stmt|;
name|struct
name|deltalist
modifier|*
name|oldp
decl_stmt|;
name|struct
name|deltalist
modifier|*
name|ptrtemp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|currel
decl_stmt|;
name|int
name|reldiff
decl_stmt|,
name|numnull
decl_stmt|;
name|int
name|serhold
decl_stmt|;
comment|/* 	Set current release to that of oldest (first) delta. 	*/
name|currel
operator|=
name|Dtail
operator|->
name|ds_sid
operator|.
name|s_rel
expr_stmt|;
comment|/* 	The following loop processes each delta, starting with the 	oldest one in the file (the last one read). 	*/
name|ptr
operator|=
name|Dtail
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|reldiff
operator|=
name|ptr
operator|->
name|ds_sid
operator|.
name|s_rel
operator|-
name|currel
expr_stmt|;
comment|/* 		Skip removed deltas, branch deltas, or any delta whose 		release number is the same as the current release number. 		*/
if|if
condition|(
name|ptr
operator|->
name|ds_type
operator|==
literal|'R'
operator|||
name|ptr
operator|->
name|ds_sid
operator|.
name|s_br
operator|||
name|ptr
operator|->
name|ds_sid
operator|.
name|s_seq
operator|||
name|reldiff
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|ptr
operator|->
name|ds_youngerdel
expr_stmt|;
continue|continue;
block|}
comment|/* 		Check if delta is the next trunk delta in sequence, and if so 		bump up current release number and continue. 		*/
if|if
condition|(
name|reldiff
operator|==
literal|1
condition|)
block|{
name|currel
operator|++
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|ds_youngerdel
expr_stmt|;
continue|continue;
block|}
comment|/* 		Here, a trunk delta has been found, and its release 		number is greater (by at least 2) than the current 		release number. 		This requires insertion of 'null' deltas. 		First, check that this trunk delta's release 		number is greater than currel. 		(This catches deltas whose SIDs have been changed 		by the user to make them look like trunk deltas.) 		*/
if|if
condition|(
name|reldiff
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"file has invalid trunk delta (sn1)"
argument_list|)
expr_stmt|;
name|currel
operator|+=
name|reldiff
expr_stmt|;
comment|/* update currel */
comment|/* 		Find pointer to ancestor delta. 		*/
name|oldp
operator|=
name|ser_to_ptr
argument_list|(
name|ptr
operator|->
name|ds_pred
argument_list|)
expr_stmt|;
comment|/* 		Retain serial number for later use in fixing 		other deltas' serial numbers. 		*/
name|serhold
operator|=
name|ptr
operator|->
name|ds_ser
expr_stmt|;
name|ptrtemp
operator|=
name|ptr
expr_stmt|;
name|numnull
operator|=
name|reldiff
expr_stmt|;
comment|/* number of null deltas needed */
while|while
condition|(
operator|--
name|numnull
condition|)
block|{
comment|/* insert null deltas */
name|nulldel
operator|=
name|alloc
argument_list|(
name|n
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|Dhead
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nulldel
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nulldel
operator|->
name|ds_youngerdel
operator|=
name|ptrtemp
expr_stmt|;
name|nulldel
operator|->
name|ds_olderdel
operator|=
name|ptrtemp
operator|->
name|ds_olderdel
expr_stmt|;
name|ptrtemp
operator|->
name|ds_olderdel
operator|=
name|nulldel
expr_stmt|;
operator|(
name|nulldel
operator|->
name|ds_olderdel
operator|)
operator|->
name|ds_youngerdel
operator|=
name|nulldel
expr_stmt|;
name|nulldel
operator|->
name|ds_sid
operator|.
name|s_rel
operator|=
name|ptrtemp
operator|->
name|ds_sid
operator|.
name|s_rel
operator|-
literal|1
expr_stmt|;
name|nulldel
operator|->
name|ds_sid
operator|.
name|s_lev
operator|=
literal|1
expr_stmt|;
name|nulldel
operator|->
name|ds_sid
operator|.
name|s_br
operator|=
literal|0
expr_stmt|;
name|nulldel
operator|->
name|ds_sid
operator|.
name|s_seq
operator|=
literal|0
expr_stmt|;
name|nulldel
operator|->
name|ds_ser
operator|=
name|serhold
operator|+
name|numnull
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|numnull
operator|!=
literal|1
condition|)
name|nulldel
operator|->
name|ds_pred
operator|=
name|nulldel
operator|->
name|ds_ser
operator|-
literal|1
expr_stmt|;
else|else
name|nulldel
operator|->
name|ds_pred
operator|=
name|oldp
operator|->
name|ds_ser
expr_stmt|;
name|nulldel
operator|->
name|ds_datetime
operator|=
name|ptr
operator|->
name|ds_datetime
expr_stmt|;
name|substr
argument_list|(
name|logname
argument_list|()
argument_list|,
name|nulldel
operator|->
name|ds_pgmr
argument_list|,
literal|0
argument_list|,
name|LNLNAM
argument_list|)
expr_stmt|;
name|nulldel
operator|->
name|ds_type
operator|=
literal|'D'
expr_stmt|;
name|nulldel
operator|->
name|ds_stats
operator|.
name|s_ins
operator|=
literal|0
expr_stmt|;
name|nulldel
operator|->
name|ds_stats
operator|.
name|s_del
operator|=
literal|0
expr_stmt|;
name|nulldel
operator|->
name|ds_stats
operator|.
name|s_unc
operator|=
name|oldp
operator|->
name|ds_stats
operator|.
name|s_unc
operator|+
name|oldp
operator|->
name|ds_stats
operator|.
name|s_ins
expr_stmt|;
name|nulldel
operator|->
name|ds_insnull
operator|=
literal|1
expr_stmt|;
comment|/* null delta indicator */
name|ptrtemp
operator|=
name|nulldel
expr_stmt|;
block|}
comment|/* 		Fix up sequence and predecessor numbers of those deltas 		which are younger than the ones just processed. 		*/
name|ptrtemp
operator|=
name|ptr
expr_stmt|;
name|reldiff
operator|--
expr_stmt|;
while|while
condition|(
name|ptrtemp
condition|)
block|{
if|if
condition|(
name|ptrtemp
operator|->
name|ds_ser
operator|>=
name|serhold
condition|)
name|ptrtemp
operator|->
name|ds_ser
operator|+=
name|reldiff
expr_stmt|;
if|if
condition|(
name|ptrtemp
operator|->
name|ds_pred
operator|>=
name|serhold
condition|)
name|ptrtemp
operator|->
name|ds_pred
operator|+=
name|reldiff
expr_stmt|;
name|ptrtemp
operator|=
name|ptrtemp
operator|->
name|ds_youngerdel
expr_stmt|;
block|}
comment|/* 		Fix predecessor of current delta. 		*/
name|ptr
operator|->
name|ds_pred
operator|=
name|serhold
operator|+
name|reldiff
operator|-
literal|1
expr_stmt|;
comment|/* 		Point to next (non-null) delta. 		*/
name|ptr
operator|=
name|ptr
operator|->
name|ds_youngerdel
expr_stmt|;
block|}
comment|/* 	Create array of original values of serial numbers of 	the original deltas. 	*/
name|ptr
operator|=
name|Dtail
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|ds_insnull
operator|!=
literal|1
condition|)
name|New_ser_ptr
index|[
name|ptr
operator|->
name|ds_origser
index|]
operator|=
name|ptr
operator|->
name|ds_ser
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|ds_youngerdel
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ser_to_ptr
argument_list|(
argument|ser
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ser
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|deltalist
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|Dtail
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|ds_ser
operator|==
name|ser
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|ptr
operator|->
name|ds_youngerdel
expr_stmt|;
block|}
name|fatal
argument_list|(
literal|"internal error -- ser_to_ptr (sn2)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|wrtdeltbl
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|deltalist
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ser
decl_stmt|;
comment|/* 	The following loop writes out the new delta table. 	*/
name|ptr
operator|=
name|Dhead
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|ds_insnull
condition|)
block|{
comment|/* 'null' delta */
comment|/* 			Write out statistics line. 			*/
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %05u/%05u/%05u\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|STATS
argument_list|,
name|ptr
operator|->
name|ds_stats
operator|.
name|s_ins
argument_list|,
name|ptr
operator|->
name|ds_stats
operator|.
name|s_del
argument_list|,
name|ptr
operator|->
name|ds_stats
operator|.
name|s_unc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			Write 'delta' line, taken from 			in-core list. 			*/
name|putdel
argument_list|(
name|pkt
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|COMMENTS
argument_list|,
literal|"INSERTED BY SNULL"
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EDELTAB
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getline
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* statistics line */
name|getline
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 'delta' line */
comment|/* 			Indicate not to output previously read line. 			*/
name|pkt
operator|->
name|p_wrttn
operator|=
literal|1
expr_stmt|;
comment|/* 			Write 'delta' line from in-core list. 			*/
name|putdel
argument_list|(
name|pkt
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* 			Process rest of entry, changeing serial 			numbers of deltas included, excluded, 			or ignored. 			*/
while|while
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
condition|)
if|if
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
break|break;
else|else
block|{
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|&
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
operator|)
condition|)
block|{
case|case
name|EDELTAB
case|:
name|putline
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCLUDE
case|:
case|case
name|EXCLUDE
case|:
case|case
name|IGNORE
case|:
name|pkt
operator|->
name|p_wrttn
operator|=
literal|1
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c"
argument_list|,
name|CTLCHAR
argument_list|,
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|numeric
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|satoi
argument_list|(
name|p
argument_list|,
operator|&
name|ser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ser
operator|>
literal|0
operator|&&
name|ser
operator|<=
name|Max_old_ser
operator|)
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" %u"
argument_list|,
name|New_ser_ptr
index|[
name|ser
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|putline
argument_list|(
name|pkt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|putline
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
comment|/* 		Point to next delta to be output. 		*/
name|ptr
operator|=
name|ptr
operator|->
name|ds_olderdel
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putdel
argument_list|(
argument|pkt
argument_list|,
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|deltalist
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|deltab
name|dt
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|ptr
operator|->
name|ds_sid
argument_list|,
operator|&
name|dt
operator|.
name|d_sid
argument_list|,
sizeof|sizeof
argument_list|(
name|dt
operator|.
name|d_sid
argument_list|)
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d_serial
operator|=
name|ptr
operator|->
name|ds_ser
expr_stmt|;
name|dt
operator|.
name|d_pred
operator|=
name|ptr
operator|->
name|ds_pred
expr_stmt|;
name|dt
operator|.
name|d_datetime
operator|=
name|ptr
operator|->
name|ds_datetime
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
operator|->
name|ds_pgmr
argument_list|,
operator|&
name|dt
operator|.
name|d_pgmr
argument_list|,
sizeof|sizeof
argument_list|(
name|dt
operator|.
name|d_pgmr
argument_list|)
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d_type
operator|=
name|ptr
operator|->
name|ds_type
expr_stmt|;
name|del_ba
argument_list|(
operator|&
name|dt
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|pkt
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|fixbody
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ser
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|type
decl_stmt|;
while|while
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
condition|)
block|{
name|p
operator|=
name|pkt
operator|->
name|p_line
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|CTLCHAR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|type
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|INS
operator|||
name|type
operator|==
name|DEL
operator|||
name|type
operator|==
name|END
operator|)
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|satoi
argument_list|(
name|p
argument_list|,
operator|&
name|ser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ser
operator|>
literal|0
operator|&&
name|ser
operator|<=
name|Max_old_ser
operator|)
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 			Indicate not to output line just read. 			*/
name|pkt
operator|->
name|p_wrttn
operator|=
literal|1
expr_stmt|;
comment|/* 			Output new value of sequence number. 			*/
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %u\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|type
argument_list|,
name|New_ser_ptr
index|[
name|ser
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|clean_up
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|gpkt
operator|.
name|p_file
index|[
literal|0
index|]
condition|)
name|unlockit
argument_list|(
name|auxf
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|,
literal|'z'
argument_list|)
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpkt
operator|.
name|p_iop
condition|)
name|fclose
argument_list|(
name|gpkt
operator|.
name|p_iop
argument_list|)
expr_stmt|;
name|xrm
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|xfreeall
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

