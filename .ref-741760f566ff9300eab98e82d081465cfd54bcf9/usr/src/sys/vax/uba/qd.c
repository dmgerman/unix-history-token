begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)qd.c	1.40	ULTRIX	10/2/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/************************************************************************  *									*  *			Copyright (c) 1985, 1986 by			* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* *************************************************************************/
end_comment

begin_comment
comment|/*  * qd.c  *  * Modification history  *  * QDSS workstation driver  *  * 26-Aug-86 - rsp (Ricky Palmer)  *  *	Cleaned up devioctl code to (1) zero out devget structure  *	upon entry and (2) use strlen instead of fixed storage  *	for bcopy's.  *  * 21-Jul-86 - Ram Rao  *	allowed cursor rectangle to hang (partially) off the  *	top and left of screen  *  * 11-Jul-86 - ricky palmer  *  *	Added adpt and nexus fields to DEVIOCGET code.  *  * 02-July-86 - Brian Stevens  *  *	added support for console writing to second QDSS display  *  * 20-May-86 - ricky palmer  *  *	Added new DEVIOCGET ioctl request code. V2.0  *  * 16-Apr-86 -- darrell  *	 badaddr is now called via the macro BADADDR  *  * 14-Apr-86 -- afd  *	 Changed UMEMmap to QMEMmap and umem to qmem.  *  *	 v_console() is now refered to as v_consputc, and there is a  *	 corresponding v_consgetc() (defined in /sys/vax/conf.c).  *  *	 Added "qdgetc()" routine for console read.  Needed to read  *	 user's answer to the "root device?" prompt with a generic kernel.  *  * 19-Mar-86 -- pmk  *	 Change DELAY to 20000, because microdelay now in real microsec.  *  * 18-mar-86  -- jaw	 br/cvec changed to NOT use registers.  *  * 11 mar 86  darrell	replaced percpu with cpusw, and removed all but  *			 one global reference  * 19 feb 86  bstevens	no report of motion event on puck/stylus button action  * 18 feb 86  bstevens	put in cursor box support for tablets  * 18-Mar-86 -- jaw  add routines to cpu switch for nexus/unibus addreses  *		      also got rid of some globals like nexnum.  *		      ka8800 cleanup.  * 06 dec 85  longo  added LK-201 error reporting for graphics device ops  * 03 dec 85  longo  made qddint() clear active bit on error  * 02 dec 85  longo  fixed up some crocks in the error messages  * 25 nov 85  longo  added error handling to DMA ISR and single user locking  * 19 nov 85  longo  eliminated "set_defaults()" by breaking out sub-calls.  *		     Changed init_shared to do real init of scroll struct  * 12 nov 85  longo  fixed bug in open that broke alternate console re-direct  * 11 nov 85  longo  changed "_vs_eventqueue" references to "qdinput"  * 08 nov 85  longo  improved select service for read/write select wakeup.  *		     Also set ISR's to ipl4 to allow the interval timer in.  * 04 nov 85  longo  fixed bugs in mouse button reporting and dma request stuff  * 30 oct 85  longo  DMA to/from user space is in place  * 14 oct 85  longo  added kernel msg redirect and QD_RDCURSOR ioctl  * 03 oct 85  longo  added support for multiple QDSS's  * 02 oct 85  longo  added color map loading services in qdioctl()& qdaint()  * 30 sep 85  longo  added DMA interrupt services  * 18 sep 85  longo  added scroll services to "qdaint()" adder intrpt service  *		     and put in supporting ioctl's  * 04 sep 85  longo  initial implementation of DMA is working  * 17 aug 85  longo  added support for the QDSS to be system console  * 05 aug 85  longo  now using qfont (QVSS& QDSS) as linked object  * 12 jun 85  longo  added mouse event loading to "qdiint()"  * 31 may 85  longo  put live interrupts into the probe() routine  * 30 may 85  longo  event queue shared memory implementation is now alive  * 29 may 85  longo  LK-201 input is now interrupt driven  * 25 apr 85  longo  MAPDEVICE works  * 14 mar 85  longo  created  *  *	 todo:	 fix rlogin bug in console stuff  *		 cat -u console redirection  *		 check error return from strategy routine  *		 verify TOY time stuff (what format?)  *		 look at system based macro implementation of VTOP  *  */
end_comment

begin_include
include|#
directive|include
file|"../data/qd_data.c"
end_include

begin_comment
comment|/* include external references to data file */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------- * macro to get system time.  Used to time stamp event queue entries */
end_comment

begin_define
define|#
directive|define
name|TOY
value|((time.tv_sec * 100) + (time.tv_usec / 10000))
end_define

begin_comment
comment|/*-------------------------------------------------------------------------- * the "ioconf.c" program, built and used by auto config, externally refers * to definitions below.  */
end_comment

begin_function_decl
name|int
name|qdprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qdattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qddint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* DMA gate array intrpt service */
end_comment

begin_function_decl
name|int
name|qdaint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Dragon ADDER intrpt service */
end_comment

begin_function_decl
name|int
name|qdiint
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|u_short
name|qdstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|qddriver
init|=
block|{
comment|/* externally referenced: ioconf.c */
name|qdprobe
block|,
comment|/* device probe entry */
literal|0
block|,
comment|/* no slave device */
name|qdattach
block|,
comment|/* device attach entry */
literal|0
block|,
comment|/* no "fill csr/ba to start" */
name|qdstd
block|,
comment|/* device addresses */
literal|"qd"
block|,
comment|/* device name string */
name|qdinfo
comment|/* ptr to QDSS's uba_device struct */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------- * general defines */
end_comment

begin_define
define|#
directive|define
name|QDPRIOR
value|(PZERO-1)
end_define

begin_comment
comment|/* must be negative */
end_comment

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|~FALSE
end_define

begin_define
define|#
directive|define
name|BAD
value|-1
end_define

begin_define
define|#
directive|define
name|GOOD
value|0
end_define

begin_comment
comment|/*----------------------------------------------------------------------- * macro to create a system virtual page number from system virtual adrs */
end_comment

begin_define
define|#
directive|define
name|VTOP
parameter_list|(
name|x
parameter_list|)
value|(((int)x& ~0xC0000000)>> PGSHIFT)
end_define

begin_comment
comment|/* convert qmem adrs */
end_comment

begin_comment
comment|/* to system page # */
end_comment

begin_comment
comment|/*------------------------------------------------------------------ * QDSS register address offsets from start of QDSS address space */
end_comment

begin_define
define|#
directive|define
name|QDSIZE
value|(52 * 1024)
end_define

begin_comment
comment|/* size of entire QDSS foot print */
end_comment

begin_define
define|#
directive|define
name|TMPSIZE
value|(16 * 1024)
end_define

begin_comment
comment|/* template RAM is 8k SHORT WORDS */
end_comment

begin_define
define|#
directive|define
name|TMPSTART
value|0x8000
end_define

begin_comment
comment|/* offset of template RAM from base adrs */
end_comment

begin_define
define|#
directive|define
name|REGSIZE
value|(5 * 512)
end_define

begin_comment
comment|/* regs touch 2.5k (5 pages) of addr space */
end_comment

begin_define
define|#
directive|define
name|REGSTART
value|0xC000
end_define

begin_comment
comment|/* offset of reg pages from base adrs */
end_comment

begin_define
define|#
directive|define
name|ADDER
value|(REGSTART+0x000)
end_define

begin_define
define|#
directive|define
name|DGA
value|(REGSTART+0x200)
end_define

begin_define
define|#
directive|define
name|DUART
value|(REGSTART+0x400)
end_define

begin_define
define|#
directive|define
name|MEMCSR
value|(REGSTART+0x800)
end_define

begin_define
define|#
directive|define
name|CLRSIZE
value|(3 * 512)
end_define

begin_comment
comment|/* color map size */
end_comment

begin_define
define|#
directive|define
name|CLRSTART
value|(REGSTART+0xA00)
end_define

begin_comment
comment|/* color map start offset from base */
end_comment

begin_comment
comment|/*  0x0C00 really */
end_comment

begin_define
define|#
directive|define
name|RED
value|(CLRSTART+0x000)
end_define

begin_define
define|#
directive|define
name|BLUE
value|(CLRSTART+0x200)
end_define

begin_define
define|#
directive|define
name|GREEN
value|(CLRSTART+0x400)
end_define

begin_comment
comment|/*--------------------------------------------------------------- * values used in mapping QDSS hardware into the Q memory space */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|QMEMSIZE
value|(1024 * 1024 * 4)
end_define

begin_comment
comment|/* 4 meg */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------- * QDSS minor device numbers.  The *real* minor device numbers are in * the bottom two bits of the major/minor device spec.  Bits 2 and up are * used to specify the QDSS device number (ie: which one?) */
end_comment

begin_define
define|#
directive|define
name|QDSSMAJOR
value|42
end_define

begin_comment
comment|/* QDSS major device number */
end_comment

begin_define
define|#
directive|define
name|CONS
value|0
end_define

begin_define
define|#
directive|define
name|ALTCONS
value|1
end_define

begin_define
define|#
directive|define
name|GRAPHIC
value|2
end_define

begin_comment
comment|/*---------------------------------------------- * console cursor bitmap (block cursor type)  */
end_comment

begin_decl_stmt
name|short
name|cons_cursor
index|[
literal|32
index|]
init|=
block|{
comment|/* white block cursor */
comment|/* A */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
comment|/* B */
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|,
literal|0x00FF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------- * constants used in font operations */
end_comment

begin_define
define|#
directive|define
name|CHARS
value|95
end_define

begin_comment
comment|/* # of chars in the font */
end_comment

begin_define
define|#
directive|define
name|CHAR_HEIGHT
value|15
end_define

begin_comment
comment|/* char height in pixels */
end_comment

begin_define
define|#
directive|define
name|CHAR_WIDTH
value|8
end_define

begin_comment
comment|/* char width in pixels*/
end_comment

begin_define
define|#
directive|define
name|FONT_WIDTH
value|(CHAR_WIDTH * CHARS)
end_define

begin_comment
comment|/* font width in pixels */
end_comment

begin_define
define|#
directive|define
name|ROWS
value|CHAR_HEIGHT
end_define

begin_define
define|#
directive|define
name|FONT_X
value|0
end_define

begin_comment
comment|/* font's off screen adrs */
end_comment

begin_define
define|#
directive|define
name|FONT_Y
value|(2048 - CHAR_HEIGHT)
end_define

begin_comment
comment|/* #define FONT_Y		200 */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_font
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference font object code */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_key
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference key xlation tables */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|q_shift_key
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|q_special
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-------------------------------------------------- * definitions for cursor acceleration reporting  */
end_comment

begin_define
define|#
directive|define
name|ACC_OFF
value|0x01
end_define

begin_comment
comment|/* acceleration is inactive */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------- * v_consputc is the switch that is used to redirect the console cnputc() to * the virtual console qdputc(). * v_consgetc is the switch that is used to redirect the console getchar() to * the virtual console qdgetc(). */
end_comment

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|v_consputc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qdputc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* used to direct kernel console output */
end_comment

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|v_consgetc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|qdgetc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* used to read kernel console input */
end_comment

begin_function_decl
name|int
name|qdstart
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* used to direct /dev/console output */
end_comment

begin_comment
comment|/*------------------------------------------------------------------------ * LK-201 state storage for input console keyboard conversion to ASCII */
end_comment

begin_struct
struct|struct
name|q_keyboard
block|{
name|int
name|shift
decl_stmt|;
comment|/* state variables	*/
name|int
name|cntrl
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|int
name|lastcode
decl_stmt|;
comment|/* last keycode typed	*/
name|unsigned
name|kup
index|[
literal|8
index|]
decl_stmt|;
comment|/* bits for each keycode*/
name|unsigned
name|dkeys
index|[
literal|8
index|]
decl_stmt|;
comment|/* down/up mode keys	*/
name|char
name|last
decl_stmt|;
comment|/* last character	*/
block|}
name|q_keyboard
struct|;
end_struct

begin_comment
comment|/***************************************************************** ****************************************************************** ****************************************************************** * *	DRIVER FUNCTIONS START HERE: * ****************************************************************** ****************************************************************** *****************************************************************/
end_comment

begin_comment
comment|/********************************************************************* * *	qdcons_init()... init QDSS as console (before probe routine) * *********************************************************************/
end_comment

begin_macro
name|qdcons_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|u_int
name|unit
decl_stmt|;
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
name|caddr_t
name|phys_adr
decl_stmt|;
comment|/* physical QDSS base adrs */
name|u_int
name|mapix
decl_stmt|;
comment|/* index into QMEMmap[] array */
name|struct
name|cpusw
modifier|*
name|cpup
decl_stmt|;
comment|/* pointer to cpusw structure  */
name|u_short
modifier|*
name|qdaddr
decl_stmt|;
comment|/* address of QDSS IO page CSR */
name|u_short
modifier|*
name|devptr
decl_stmt|;
comment|/* vitual device space */
define|#
directive|define
name|QDSSCSR
value|0x1F00
name|unit
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------------------- * find the cpusw entry that matches this machine. */
name|cpup
operator|=
operator|&
name|cpusw
index|[
name|cpu
index|]
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|cpup
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*------------------------------------------------------ * Map the Q-bus memory space into the system memory. */
name|ubaaccess
argument_list|(
operator|(
call|(
modifier|*
name|cpup
operator|->
name|v_umaddr
call|)
argument_list|(
literal|0
argument_list|)
operator|)
argument_list|,
name|QMEMmap
index|[
literal|0
index|]
argument_list|,
name|cpup
operator|->
name|pc_umsize
argument_list|,
name|PG_V
operator||
name|PG_KW
argument_list|)
expr_stmt|;
name|ubaaccess
argument_list|(
operator|(
call|(
modifier|*
name|cpup
operator|->
name|v_udevaddr
call|)
argument_list|(
literal|0
argument_list|)
operator|)
argument_list|,
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|btop
argument_list|(
name|cpup
operator|->
name|pc_umsize
argument_list|)
argument_list|,
name|DEVSPACESIZE
argument_list|,
name|PG_V
operator||
name|PG_KW
argument_list|)
expr_stmt|;
comment|/*--------------------------------------------------------------------- * map the QDSS into the Qbus memory (which is now in system space)  */
name|devptr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|qmem
index|[
literal|0
index|]
operator|+
name|cpup
operator|->
name|pc_umsize
operator|)
expr_stmt|;
name|qdaddr
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|devptr
operator|+
name|ubdevreg
argument_list|(
name|QDSSCSR
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BADADDR
argument_list|(
name|qdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*--------------------------------------------------- 	* tell QDSS which Q memory address base to decode */
name|mapix
operator|=
operator|(
name|int
operator|)
name|VTOP
argument_list|(
name|QMEMSIZE
operator|-
name|CHUNK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
expr_stmt|;
name|phys_adr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|ptep
operator|&
literal|0x001FFFFF
operator|)
operator|<<
name|PGSHIFT
argument_list|)
expr_stmt|;
operator|*
name|qdaddr
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|phys_adr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|qdaddr
expr_stmt|;
comment|/*---------------------------------------------------------------------- * load qdmap struct with the virtual addresses of the QDSS elements */
name|qdbase
index|[
name|unit
index|]
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|qmem
index|[
literal|0
index|]
operator|+
name|QMEMSIZE
operator|-
name|CHUNK
argument_list|)
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|TMPSTART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|ADDER
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DGA
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DUART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|MEMCSR
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|RED
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|BLUE
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|GREEN
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|=
literal|0
expr_stmt|;
comment|/* init shadow variables */
comment|/*------------------ * init the QDSS  */
operator|*
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator||=
name|SYNC_ON
expr_stmt|;
comment|/* once only: turn on sync */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* clear the screen */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
comment|/*---------------------------------------------------- * smash the system's virtual console address table */
name|v_consputc
operator|=
name|qdputc
expr_stmt|;
name|v_consgetc
operator|=
name|qdgetc
expr_stmt|;
name|cdevsw
index|[
literal|0
index|]
operator|=
name|cdevsw
index|[
name|QDSSMAJOR
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdcons_init */
end_comment

begin_comment
comment|/********************************************************************* * *	qdprobe()... configure QDSS into Q memory and make it intrpt * ********************************************************************** * *  calling convention: *			qdprobe(reg, ctlr); *			caddr_t reg; *			int ctlr; * *	where: reg - a character pointer to the QDSS I/O page register *	       ctlr - controller number (?) * *  side effects: QDSS gets mapped into Qbus memory space at the first *		 vacant 64kb boundary counting back from the top of *		 Qbus memory space (qmem+4mb) * *  return: QDSS bus request level and vector address returned in *	   registers by UNIX convention. * *****************/
end_comment

begin_macro
name|qdprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* the variables MUST reside in the first two register declarations 	* by UNIX convention in order that they be loaded and returned 	* properly by the interrupt catching mechanism.  */
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* pointer to gate array structure */
name|struct
name|cpusw
modifier|*
name|cpup
decl_stmt|;
comment|/* pointer to the cpusw structure */
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
name|int
name|vector
decl_stmt|;
name|caddr_t
name|phys_adr
decl_stmt|;
comment|/* physical QDSS base adrs */
name|u_int
name|mapix
decl_stmt|;
comment|/*--------------------------------------------------------------- * calculate board unit number from I/O page register address  */
name|unit
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|reg
operator|>>
literal|1
operator|)
operator|&
literal|0x0007
argument_list|)
expr_stmt|;
comment|/*--------------------------------------------------------------------------- * QDSS regs must be mapped to Qbus memory space at a 64kb physical boundary. * The Qbus memory space is mapped into the system memory space at config * time.  After config runs, "qmem[0]" (ubavar.h) holds the system virtual adrs * of the start of Qbus memory.	The Qbus memory page table is found via * an array of pte ptrs called "QMEMmap[]" (ubavar.h) which is also loaded at * config time.	These are the variables used below to find a vacant 64kb * boundary in Qbus memory, and load it's corresponding physical adrs into * the QDSS's I/O page CSR.  */
comment|/* if this QDSS is NOT the console, then do init here.. */
if|if
condition|(
name|v_consputc
operator|!=
name|qdputc
operator|||
name|unit
operator|!=
literal|0
condition|)
block|{
comment|/*------------------------- 	    * read QDSS config info */
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|reg
expr_stmt|;
comment|/*------------------------------------ 	    * find an empty 64kb adrs boundary */
name|qdbase
index|[
name|unit
index|]
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|qmem
index|[
literal|0
index|]
operator|+
name|QMEMSIZE
operator|-
name|CHUNK
argument_list|)
expr_stmt|;
comment|/*---------------------------------------------------- 	    * find the cpusw entry that matches this machine. */
name|cpup
operator|=
operator|&
name|cpusw
index|[
name|cpu
index|]
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|BADADDR
argument_list|(
name|qdbase
index|[
name|unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
condition|)
name|qdbase
index|[
name|unit
index|]
operator|-=
name|CHUNK
expr_stmt|;
comment|/*--------------------------------------------------- 	    * tell QDSS which Q memory address base to decode */
name|mapix
operator|=
call|(
name|int
call|)
argument_list|(
name|VTOP
argument_list|(
name|qdbase
index|[
name|unit
index|]
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
expr_stmt|;
name|phys_adr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|ptep
operator|&
literal|0x001FFFFF
operator|)
operator|<<
name|PGSHIFT
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|reg
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|int
operator|)
name|phys_adr
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/*----------------------------------------------------------- 	    * load QDSS adrs map with system addresses of device regs */
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|TMPSTART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|ADDER
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DGA
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|DUART
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|MEMCSR
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|RED
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|BLUE
expr_stmt|;
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
operator|=
name|qdbase
index|[
name|unit
index|]
operator|+
name|GREEN
expr_stmt|;
comment|/* device init */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
comment|/* once only: turn on sync */
operator|*
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
operator||=
name|SYNC_ON
expr_stmt|;
block|}
comment|/*-------------------------------------------------------------------------- * the QDSS interrupts at HEX vectors xx0 (DMA) xx4 (ADDER) and xx8 (DUART). * Therefore, we take three vectors from the vector pool, and then continue * to take them until we get a xx0 HEX vector.  The pool provides vectors * in contiguous decending order.  */
name|vector
operator|=
operator|(
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|*
literal|3
operator|)
expr_stmt|;
comment|/* take three vectors */
while|while
condition|(
name|vector
operator|&
literal|0x0F
condition|)
block|{
comment|/* if lo nibble != 0.. */
name|vector
operator|=
operator|(
name|uba_hd
index|[
literal|0
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
comment|/* ..take another vector */
block|}
comment|/*--------------------------------------------------------- 	* setup DGA to do a DMA interrupt (transfer count = 0)	*/
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|=
operator|(
name|short
operator|)
name|HALT
expr_stmt|;
comment|/* disable everything */
name|dga
operator|->
name|ivr
operator|=
operator|(
name|short
operator|)
name|vector
expr_stmt|;
comment|/* load intrpt base vector */
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
comment|/* DMA xfer count = 0 */
name|dga
operator|->
name|bytcnt_hi
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
comment|/* turn on DMA interrupts */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|SET_DONE_FIFO
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
operator||
name|DL_ENB
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* wait for the intrpt */
name|dga
operator|->
name|csr
operator|=
name|HALT
expr_stmt|;
comment|/* stop the wheels */
comment|/*---------- * exits  */
if|if
condition|(
name|cvec
operator|!=
name|vector
condition|)
comment|/* if vector != base vector.. */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..return = 'no device' */
return|return
operator|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
return|;
comment|/* return size of QDSS I/O page reg */
block|}
end_block

begin_comment
comment|/* qdprobe */
end_comment

begin_comment
comment|/***************************************************************** * *	qdattach()... do the one-time initialization * ****************************************************************** * *  calling convention: *			qdattach(ui); *			struct uba_device *ui; * *		where: ui - pointer to the QDSS's uba_device structure * *  side effects: none *	 return: none * *************************/
end_comment

begin_macro
name|qdattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_int
name|unit
decl_stmt|;
comment|/* QDSS module # for this call */
name|unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
comment|/* get QDSS number */
comment|/*---------------------------------- * init "qdflags[]" for this QDSS */
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
comment|/* init inuse variable EARLY! */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|kernel_loop
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|ACC_OFF
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
literal|128
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|tab_res
operator|=
literal|2
expr_stmt|;
comment|/* default tablet resolution factor */
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|=
literal|0
expr_stmt|;
comment|/* init shadow variables */
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------------------------------------- * init structures used in kbd/mouse interrupt service.	This code must * come after the "init_shared()" routine has run since that routine inits * the eq_header[unit] structure used here.   */
comment|/*-------------------------------------------- 	* init the "latest mouse report" structure */
name|last_rep
index|[
name|unit
index|]
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|last_rep
index|[
name|unit
index|]
operator|.
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/*------------------------------------------------ 	* init the event queue (except mouse position) */
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|events
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|eq_header
index|[
name|unit
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|qdinput
argument_list|)
operator|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|size
operator|=
name|MAXEVENTS
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|header
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
comment|/*------------------------------------------ * init single process access lock switch */
name|one_only
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdattach */
end_comment

begin_comment
comment|/*************************************************************** * *	qdopen()... open a minor device * **************************************************************** * *  calling convention: qdopen(dev, flag); *		       dev_t dev; *		       int flag; * *  side effects: none * *********************/
end_comment

begin_macro
name|qdopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
comment|/* ptr to uba structures */
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* ptr to gate array struct */
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|u_int
name|minor_dev
decl_stmt|;
name|int
name|s
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get QDSS minor device number */
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
comment|/*--------------------------------- * check for illegal conditions	*/
name|ui
operator|=
name|qdinfo
index|[
name|unit
index|]
expr_stmt|;
comment|/* get ptr to QDSS device struct */
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* no such device or address */
comment|/*-------------- * init stuff */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/*------------------------------------ * if this is the graphic device... */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|one_only
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
name|one_only
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator||=
name|GRAPHIC_DEV
expr_stmt|;
comment|/* graphics dev is open */
comment|/* enble kbd& mouse intrpts in DUART mask reg */
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x22
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/*------------------------------------------------------------------ * if the open call is to the console or the alternate console... */
block|}
elseif|else
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|2
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator||=
name|CONS_DEV
expr_stmt|;
comment|/* mark console as open */
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x02
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/*------------------------------- 	    * some setup for tty handling */
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|qdstart
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TS_ISOPEN
operator||
name|TS_CARR_ON
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|B9600
expr_stmt|;
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_flags
operator|=
name|XTABS
operator||
name|EVENP
operator||
name|ECHO
operator||
name|CRMOD
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator|=
name|RAW
expr_stmt|;
block|}
comment|/*---------------------------------------- 	    * enable intrpts, open line discipline */
name|dga
operator|->
name|csr
operator||=
name|GLOBAL_IE
expr_stmt|;
comment|/* turn on the interrupts */
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
name|dga
operator|->
name|csr
operator||=
name|GLOBAL_IE
expr_stmt|;
comment|/* turn on the interrupts */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdopen */
end_comment

begin_comment
comment|/*************************************************************** * *	qdclose()... clean up on the way out * **************************************************************** * *  calling convention: qdclose(); * *  side effects: none * *  return: none * *********************/
end_comment

begin_macro
name|qdclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|qdmap
modifier|*
name|qd
decl_stmt|;
specifier|register
name|int
modifier|*
name|ptep
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* SIGNED index */
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* gate array register map pointer */
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|u_int
name|minor_dev
decl_stmt|;
name|u_int
name|mapix
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get minor device number */
name|unit
operator|=
name|minor_dev
operator|>>
literal|2
expr_stmt|;
comment|/* get QDSS number */
name|qd
operator|=
operator|&
name|qdmap
index|[
name|unit
index|]
expr_stmt|;
comment|/*------------------------------------ * if this is the graphic device... */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|==
literal|2
condition|)
block|{
comment|/*----------------- 	    * unlock driver */
if|if
condition|(
name|one_only
index|[
name|unit
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
name|one_only
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------- 	    * re-protect device memory */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPDEV
condition|)
block|{
comment|/*---------------- 		* TEMPLATE RAM */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|template
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|TMPSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
comment|/*--------- 		* ADDER */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|adder
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|REGSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
comment|/*-------------- 		* COLOR MAPS */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|red
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|CLRSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
block|}
comment|/*---------------------------------------------------- 	    * re-protect DMA buffer and free the map registers */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPDMA
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* kill DMA */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* if DMA was running, flush spurious intrpt */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
block|}
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|DMAheader
index|[
name|unit
index|]
operator|*
literal|4
argument_list|)
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|DMAbuf_size
operator|>>
name|PGSHIFT
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
name|ubarelse
argument_list|(
literal|0
argument_list|,
operator|&
name|Qbus_unmap
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*--------------------------------------- 	    * re-protect 1K (2 pages) event queue */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPEQ
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
block|}
comment|/*------------------------------------------------------------ 	    * re-protect scroll param area and disable scroll intrpts  */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPSCR
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* re-protect 512 scroll param area */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
comment|/*----------------------------------------------------------- 	    * re-protect color map write buffer area and kill intrpts */
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPCOLOR
condition|)
block|{
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
comment|/*----------------------------------- 	    * flag that everthing is unmapped */
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buf */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|=
literal|0
expr_stmt|;
comment|/* flag everything now unmapped */
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&=
operator|~
name|GRAPHIC_DEV
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|ACC_OFF
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
literal|128
expr_stmt|;
comment|/*--------------------- 	    * restore the console */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt the DMA! (just in case...) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* if DMA was running, flush spurious intrpt */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
block|}
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init ADDER/VIPER */
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
comment|/* shut off the mouse rcv intrpt and turn on kbd intrpts */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator|&=
operator|~
operator|(
literal|0x20
operator|)
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
operator||=
literal|0x02
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
comment|/*----------------------------------------- 	    * shut off interrupts if all is closed  */
if|if
condition|(
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
operator|(
name|CONS_DEV
operator||
name|ALTCONS_DEV
operator|)
operator|)
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|GLOBAL_IE
operator||
name|DMA_IE
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------- * if this is the console or the alternate console  */
else|else
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&=
operator|~
name|CONS_DEV
expr_stmt|;
comment|/*------------------------------------------------- 	    * if graphics device is closed, kill interrupts */
if|if
condition|(
operator|!
operator|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
operator|)
condition|)
block|{
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|GLOBAL_IE
operator||
name|DMA_IE
operator|)
expr_stmt|;
block|}
block|}
comment|/*-------- * exit */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdclose */
end_comment

begin_comment
comment|/*************************************************************** * *	qdioctl()... provide QDSS control services * **************************************************************** * *  calling convention:	qdioctl(dev, cmd, datap, flags); * *		where:	dev - the major/minor device number *			cmd - the user-passed command argument *			datap - ptr to user input buff (128 bytes max) *			flags - "f_flags" from "struct file" in file.h * * *	- here is the format for the input "cmd" argument * *	31     29 28	23 22	      16 15		8 7		 0 *	+----------------------------------------------------------------+ *	|I/O type|	  | buff length | device ID char |  user command | *	+----------------------------------------------------------------+ * *  Return data is in the data buffer pointed to by "datap" input spec * *********************/
end_comment

begin_macro
name|qdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|datap
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|datap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ptep
decl_stmt|;
comment|/* page table entry pointer */
specifier|register
name|int
name|mapix
decl_stmt|;
comment|/* QMEMmap[] page table index */
specifier|register
name|struct
name|_vs_event
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|qdmap
modifier|*
name|qd
decl_stmt|;
comment|/* pointer to device map struct */
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
comment|/* Gate Array reg structure pntr */
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART reg structure pointer */
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
comment|/* ADDER reg structure pointer */
name|struct
name|prgkbd
modifier|*
name|cmdbuf
decl_stmt|;
name|struct
name|prg_cursor
modifier|*
name|curs
decl_stmt|;
name|struct
name|_vs_cursor
modifier|*
name|pos
decl_stmt|;
name|u_int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|2
decl_stmt|;
comment|/* number of caller's QDSS */
name|u_int
name|minor_dev
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|qdinfo
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|qd_softc
modifier|*
name|sc
init|=
operator|&
name|qd_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|devget
modifier|*
name|devget
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* SIGNED index */
name|int
name|sbr
decl_stmt|;
comment|/* SBR variable (you silly boy) */
name|u_int
name|ix
decl_stmt|;
name|short
name|status
decl_stmt|;
name|short
modifier|*
name|shortp
decl_stmt|;
comment|/* generic pointer to a short */
name|char
modifier|*
name|chrp
decl_stmt|;
comment|/* generic character pointer */
name|short
modifier|*
name|temp
decl_stmt|;
comment|/* a pointer to template RAM */
comment|/*----------------------------------------- * service graphic device ioctl commands */
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/*------------------------------------------------- 	    * extract the oldest event from the event queue */
case|case
name|QD_GETEVENT
case|:
if|if
condition|(
name|ISEMPTY
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|event
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
name|datap
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_NULL
expr_stmt|;
break|break;
block|}
name|event
operator|=
operator|(
expr|struct
name|_vs_event
operator|*
operator|)
name|GETBEGIN
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|GETEND
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|event
argument_list|,
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_vs_event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 	    * init the dragon stuff, DUART, and driver variables  */
case|case
name|QD_RESET
case|:
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init shared memory */
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the ADDER/VIPER stuff */
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|cons_cursor
argument_list|)
expr_stmt|;
comment|/* load default cursor map */
name|ldfont
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* load the console font */
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* init the DUART */
break|break;
comment|/*---------------------------------------- 	    * init the DUART and driver variables  */
case|case
name|QD_SET
case|:
name|init_shared
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|setup_input
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
comment|/*--------------------------------------------------------------- 	    * clear the QDSS screen.  (NOTE that this reinits the dragon) */
case|case
name|QD_CLRSCRN
case|:
name|setup_dragon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|clear_qd_screen
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
comment|/*------------------------------------ 	    * load a cursor into template RAM  */
case|case
name|QD_WTCURSOR
case|:
name|ldcursor
argument_list|(
name|unit
argument_list|,
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|QD_RDCURSOR
case|:
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
expr_stmt|;
comment|/* cursor is 32 WORDS from the end of the 8k WORD... 		*  ...template space */
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
operator|,
name|datap
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
operator|=
operator|*
name|temp
operator|++
expr_stmt|;
break|break;
comment|/*------------------------------ 	    * position the mouse cursor  */
case|case
name|QD_POSCURSOR
case|:
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|pos
operator|=
operator|(
expr|struct
name|_vs_cursor
operator|*
operator|)
name|datap
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|pos
operator|->
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|pos
operator|->
name|y
argument_list|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
operator|=
name|pos
operator|->
name|x
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
operator|=
name|pos
operator|->
name|y
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/*-------------------------------------- 	    * set the cursor acceleration factor */
case|case
name|QD_PRGCURSOR
case|:
name|curs
operator|=
operator|(
expr|struct
name|prg_cursor
operator|*
operator|)
name|datap
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_acc
operator|=
name|curs
operator|->
name|acc_factor
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|curs_thr
operator|=
name|curs
operator|->
name|threshold
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/*--------------------------------------- 	    * enable 'user write' to device pages */
case|case
name|QD_MAPDEVICE
case|:
comment|/*-------------- 		* init stuff */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPDEV
expr_stmt|;
name|qd
operator|=
operator|(
expr|struct
name|qdmap
operator|*
operator|)
operator|&
name|qdmap
index|[
name|unit
index|]
expr_stmt|;
comment|/*------------------------------------- 		* enable user write to template RAM */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|template
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|TMPSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/*---------------------------------- 		* enable user write to registers */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|adder
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|REGSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/*----------------------------------- 		* enable user write to color maps */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|red
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTOP
argument_list|(
name|CLRSIZE
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/*------------------------------ 		* enable user write to DUART */
name|mapix
operator|=
name|VTOP
argument_list|(
operator|(
name|int
operator|)
name|qd
operator|->
name|duart
argument_list|)
operator|-
name|VTOP
argument_list|(
name|qmem
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|QMEMmap
index|[
literal|0
index|]
operator|+
name|mapix
operator|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
comment|/* duart page */
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buffer */
comment|/*------------------------------------------ 		* stuff qdmap structure in return buffer */
name|bcopy
argument_list|(
name|qd
argument_list|,
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qdmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*------------------------------------- 	    * do setup for DMA by user process	*/
case|case
name|QD_MAPIOBUF
case|:
comment|/*------------------------------------------------ 		* set 'user write enable' bits for DMA buffer  */
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPDMA
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|DMAbuf_size
operator|>>
name|PGSHIFT
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
comment|/*------------------------------------- 		* set up QBUS map registers for DMA */
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|=
name|uballoc
argument_list|(
literal|0
argument_list|,
name|DMAheader
index|[
name|unit
index|]
argument_list|,
name|DMAbuf_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|==
literal|0
condition|)
name|mprintf
argument_list|(
literal|"\nqd%d: qdioctl: QBA setup error"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Qbus_unmap
index|[
name|unit
index|]
operator|=
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|&=
literal|0x3FFFF
expr_stmt|;
comment|/*---------------------- 		* return I/O buf adr */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|DMAheader
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*---------------------------------------------------------------- 	    * map the shared scroll param area and enable scroll interpts  */
case|case
name|QD_MAPSCROLL
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPSCR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* allow user write to scroll area */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
name|scroll
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator||=
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
comment|/* return scroll area address */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|scroll
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*------------------------------------------------------------- 	    * unmap shared scroll param area and disable scroll intrpts */
case|case
name|QD_UNMAPSCROLL
case|:
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPSCR
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&=
operator|~
name|MAPSCR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|scroll
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* re-protect 512 scroll param area */
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
break|break;
comment|/*----------------------------------------------------------- 	    * map shared color map write buf and turn on vsync intrpt */
case|case
name|QD_MAPCOLOR
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPCOLOR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* allow user write to color map write buffer */
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator||=
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
comment|/* return scroll area address */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|color_buf
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------- 	    * unmap shared color map write buffer and kill VSYNC intrpts */
case|case
name|QD_UNMAPCOLOR
case|:
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&
name|MAPCOLOR
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator|&=
operator|~
name|MAPCOLOR
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|color_buf
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* re-protect color map write buffer */
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_KW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* smash CPU's translation buf */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
operator|&=
operator|~
name|VSYNC
expr_stmt|;
name|adder
operator|->
name|interrupt_enable
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|adder_ie
expr_stmt|;
block|}
break|break;
comment|/*--------------------------------------------- 	    * give user write access to the event queue */
case|case
name|QD_MAPEVENT
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|mapped
operator||=
name|MAPEQ
expr_stmt|;
name|ptep
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|VTOP
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|mfpr
argument_list|(
name|SBR
argument_list|)
operator||
literal|0x80000000
operator|)
operator|)
expr_stmt|;
comment|/* allow user write to 1K event queue */
operator|*
name|ptep
operator|++
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|PG_UW
operator||
name|PG_V
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clr CPU translation buf */
comment|/* return event queue address */
operator|*
operator|(
name|int
operator|*
operator|)
name|datap
operator|=
operator|(
name|int
operator|)
name|eq_header
index|[
name|unit
index|]
expr_stmt|;
break|break;
comment|/*----------------------------------------------- 	    * pass caller's programming commands to LK201 */
case|case
name|QD_PRGKBD
case|:
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|cmdbuf
operator|=
operator|(
expr|struct
name|prgkbd
operator|*
operator|)
name|datap
expr_stmt|;
comment|/* pnt to kbd cmd buf */
comment|/*---------------- 		* send command */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|cmd
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdioctl: timeout on XMT_RDY [1]"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*---------------- 		* send param1? */
if|if
condition|(
name|cmdbuf
operator|->
name|cmd
operator|&
name|LAST_PARAM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|param1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdioctl: timeout on XMT_RDY [2]"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*---------------- 		* send param2? */
if|if
condition|(
name|cmdbuf
operator|->
name|param1
operator|&
name|LAST_PARAM
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmdbuf
operator|->
name|param2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdioctl: timeout on XMT_RDY [3]"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/*---------------------------------------------------- 	    * pass caller's programming commands to the mouse  */
case|case
name|QD_PRGMOUSE
case|:
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
operator|*
name|datap
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdioctl: timeout on XMT_RDY [4]"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*---------------------------------------------- 	    * get QDSS configuration word and return it  */
case|case
name|QD_RDCONFIG
case|:
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|config
expr_stmt|;
break|break;
comment|/*-------------------------------------------------------------- 	    * re-route kernel console messages to the alternate console  */
case|case
name|QD_KERN_LOOP
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|kernel_loop
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|QD_KERN_UNLOOP
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|kernel_loop
operator|=
literal|0
expr_stmt|;
break|break;
comment|/*---------------------- 	    * program the tablet */
case|case
name|QD_PRGTABLET
case|:
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
operator|*
name|datap
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdioctl: timeout on XMT_RDY [5]"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*----------------------------------------------- 	    * program the tablet report resolution factor */
case|case
name|QD_PRGTABRES
case|:
name|qdflags
index|[
name|unit
index|]
operator|.
name|tab_res
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|datap
expr_stmt|;
break|break;
case|case
name|DEVIOCGET
case|:
comment|/* device status */
name|devget
operator|=
operator|(
expr|struct
name|devget
operator|*
operator|)
name|datap
expr_stmt|;
name|bzero
argument_list|(
name|devget
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|devget
argument_list|)
argument_list|)
expr_stmt|;
name|devget
operator|->
name|category
operator|=
name|DEV_TERMINAL
expr_stmt|;
name|devget
operator|->
name|bus
operator|=
name|DEV_QB
expr_stmt|;
name|bcopy
argument_list|(
name|DEV_VCB02
argument_list|,
name|devget
operator|->
name|interface
argument_list|,
name|strlen
argument_list|(
name|DEV_VCB02
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|DEV_VR290
argument_list|,
name|devget
operator|->
name|device
argument_list|,
name|strlen
argument_list|(
name|DEV_VR290
argument_list|)
argument_list|)
expr_stmt|;
comment|/* terminal */
name|devget
operator|->
name|adpt_num
operator|=
name|ui
operator|->
name|ui_adpt
expr_stmt|;
comment|/* which adapter*/
name|devget
operator|->
name|nexus_num
operator|=
name|ui
operator|->
name|ui_nexus
expr_stmt|;
comment|/* which nexus  */
name|devget
operator|->
name|bus_num
operator|=
name|ui
operator|->
name|ui_ubanum
expr_stmt|;
comment|/* which QB     */
name|devget
operator|->
name|ctlr_num
operator|=
name|unit
expr_stmt|;
comment|/* which interf.*/
name|devget
operator|->
name|slave_num
operator|=
name|unit
expr_stmt|;
comment|/* which line   */
name|bcopy
argument_list|(
name|ui
operator|->
name|ui_driver
operator|->
name|ud_dname
argument_list|,
name|devget
operator|->
name|dev_name
argument_list|,
name|strlen
argument_list|(
name|ui
operator|->
name|ui_driver
operator|->
name|ud_dname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ultrix "qd"  */
name|devget
operator|->
name|unit_num
operator|=
name|unit
expr_stmt|;
comment|/* qd line?     */
name|devget
operator|->
name|soft_count
operator|=
name|sc
operator|->
name|sc_softcnt
expr_stmt|;
comment|/* soft er. cnt.*/
name|devget
operator|->
name|hard_count
operator|=
name|sc
operator|->
name|sc_hardcnt
expr_stmt|;
comment|/* hard er cnt. */
name|devget
operator|->
name|stat
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
comment|/* status	    */
name|devget
operator|->
name|category_stat
operator|=
name|sc
operator|->
name|sc_category_flags
expr_stmt|;
comment|/* cat. stat.   */
break|break;
default|default:
comment|/*----------------------------- 		* service tty type ioctl's  */
if|if
condition|(
operator|!
operator|(
name|minor_dev
operator|&
literal|0x02
operator|)
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|datap
operator|,
name|flags
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|datap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
break|break;
block|}
comment|/*-------------------------------- * clean up and get outta here  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdioctl */
end_comment

begin_comment
comment|/********************************************************************** * *	qdselect()... service select call for event queue input * **********************************************************************/
end_comment

begin_macro
name|qdselect
argument_list|(
argument|dev
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|2
expr_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
comment|/* event available? */
if|if
condition|(
operator|!
operator|(
name|ISEMPTY
argument_list|(
name|eq_header
index|[
name|unit
index|]
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return "1" if event exists */
block|}
name|rsel
index|[
name|unit
index|]
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|selmask
operator||=
name|SEL_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FWRITE
case|:
comment|/* DMA done? */
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return "1" if DMA is done */
block|}
name|rsel
index|[
name|unit
index|]
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|selmask
operator||=
name|SEL_WRITE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* qdselect() */
end_comment

begin_comment
comment|/*************************************************************** * *	qdwrite()... output to the QDSS screen as a TTY * ***************************************************************/
end_comment

begin_extern
extern|extern qd_strategy(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|qdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|minor_dev
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
name|minor_dev
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/*------------------------------ 	* if this is the console...  */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|0x02
operator|&&
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
comment|/*------------------------------------------------ 	* else this must be a DMA xfer from user space */
elseif|else
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|qd_strategy
argument_list|,
operator|&
name|qdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*************************************************************** * *	qdread()... read from QDSS keyboard as a TTY * ***************************************************************/
end_comment

begin_macro
name|qdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|minor_dev
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|minor_dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
operator|(
name|minor_dev
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/*------------------------------ 	* if this is the console...  */
if|if
condition|(
operator|(
name|minor_dev
operator|&
literal|0x03
operator|)
operator|!=
literal|0x02
operator|&&
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|CONS_DEV
condition|)
block|{
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|minor_dev
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
comment|/*------------------------------------------------ 	* else this must be a bitmap-to-processor xfer */
elseif|else
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|qd_strategy
argument_list|,
operator|&
name|qdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*************************************************************** * *	qd_strategy()... strategy routine to do DMA * ***************************************************************/
end_comment

begin_expr_stmt
name|qd_strategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|char
modifier|*
name|DMAbufp
decl_stmt|;
name|int
name|QBAreg
decl_stmt|;
name|int
name|bytcnt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|cookie
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unit
operator|=
operator|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|>>
literal|2
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/*----------------- * init pointers */
if|if
condition|(
operator|(
name|QBAreg
operator|=
name|ubasetup
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qd_strategy: QBA setup error"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|STRAT_ERR
goto|;
block|}
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
operator|=
operator|-
literal|1
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|cookie
operator|=
name|QBAreg
operator|&
literal|0x3FFFF
expr_stmt|;
name|dga
operator|->
name|adrs_lo
operator|=
operator|(
name|short
operator|)
name|cookie
expr_stmt|;
name|dga
operator|->
name|adrs_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|cookie
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|bp
operator|->
name|b_bcount
operator|>>
literal|16
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qdflags
index|[
name|unit
index|]
operator|.
name|user_dma
argument_list|,
name|QDPRIOR
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ubarelse
argument_list|(
literal|0
argument_list|,
operator|&
name|QBAreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
operator|)
condition|)
block|{
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|STRAT_ERR
label|:
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|DMA_IE
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag an error to physio() */
comment|/* if DMA was running, flush spurious intrpt */
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|DMAheader
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
block|}
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qd_strategy */
end_comment

begin_comment
comment|/******************************************************************* * *	qdstart()... startup output to the console screen * ******************************************************************** * *	calling convention: * *		qdstart(tp); *		struct tty *tp; 	;pointer to tty structure * ********/
end_comment

begin_expr_stmt
name|qdstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|which_unit
decl_stmt|,
name|unit
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|curs_on
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|tp0
operator|=
operator|&
name|qd_tty
index|[
operator|(
name|unit
operator|&
literal|0x0FC
operator|)
operator|+
literal|1
index|]
expr_stmt|;
name|which_unit
operator|=
operator|(
name|unit
operator|>>
literal|2
operator|)
operator|&
literal|0x3
expr_stmt|;
name|unit
operator|&=
literal|0x03
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/*------------------------------------------------------------------ * If it's currently active, or delaying, no need to do anything. */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/*------------------------------------------------------------------- * Display chars until the queue is empty, if the alternate console device * is open direct chars there.  Drop input from anything but the console * device on the floor.	*/
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp0
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp0
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp0
operator|)
expr_stmt|;
else|else
name|blitc
argument_list|(
name|which_unit
argument_list|,
name|c
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*-------------------------------------------------------- * If there are sleepers, and output has drained below low * water mark, wake up the sleepers. */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* qdstart */
end_comment

begin_comment
comment|/******************************************************************* * *	qdstop()... stop the tty * *******************************************************************/
end_comment

begin_expr_stmt
name|qdstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
comment|/* block intrpts during state modification */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************* * *	blitc()... output a character to the QDSS screen * ******************************************************************** * *	calling convention: * *		blitc(chr); *		char chr;		;character to be displayed * ********/
end_comment

begin_macro
name|blitc
argument_list|(
argument|unit
argument_list|,
argument|chr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|short
name|x
decl_stmt|;
comment|/*--------------- * init stuff  */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/*--------------------------- * non display character?  */
name|chr
operator|&=
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|chr
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* return char */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\t'
case|:
comment|/* tab char */
for|for
control|(
name|i
operator|=
literal|8
operator|-
operator|(
operator|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>>
literal|3
operator|)
operator|&
literal|0x07
operator|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|blitc
argument_list|(
name|unit
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\n'
case|:
comment|/* line feed char */
if|if
condition|(
operator|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|+=
name|CHAR_HEIGHT
operator|)
operator|>
operator|(
literal|863
operator|-
name|CHAR_HEIGHT
operator|)
condition|)
block|{
if|if
condition|(
name|qdflags
index|[
name|unit
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|y
operator|-=
name|CHAR_HEIGHT
expr_stmt|;
name|scroll_up
argument_list|(
name|adder
argument_list|)
expr_stmt|;
block|}
block|}
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\b'
case|:
comment|/* backspace char */
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
literal|0
condition|)
block|{
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|-=
name|CHAR_WIDTH
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|-=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|chr
operator|<
literal|' '
operator|||
name|chr
operator|>
literal|'~'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*------------------------------------------ * setup VIPER operand control registers  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* select plane #0 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FE
argument_list|)
expr_stmt|;
comment|/* select other planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- * load DESTINATION origin and vectors  */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|cursor
index|[
name|unit
index|]
operator|.
name|x
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|cursor
index|[
name|unit
index|]
operator|.
name|y
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/*----------------------------------- * load SOURCE origin and vectors  */
name|adder
operator|->
name|source_1_x
operator|=
name|FONT_X
operator|+
operator|(
operator|(
name|chr
operator|-
literal|' '
operator|)
operator|*
name|CHAR_WIDTH
operator|)
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
name|FONT_Y
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
name|CHAR_WIDTH
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/*------------------------------------- * update console cursor coordinates */
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|+=
name|CHAR_WIDTH
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
index|[
name|unit
index|]
operator|.
name|x
operator|>
operator|(
literal|1024
operator|-
name|CHAR_WIDTH
operator|)
condition|)
block|{
name|blitc
argument_list|(
name|unit
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|blitc
argument_list|(
name|unit
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* blitc */
end_comment

begin_macro
name|qdreset
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|qd_init
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/****************************************************************** ******************************************************************* ******************************************************************* * *	INTERRUPT SERVICE ROUTINES START HERE: * ******************************************************************* ******************************************************************* ******************************************************************/
end_comment

begin_comment
comment|/***************************************************************** * *	qddint()... service "DMA DONE" interrupt condition * *****************************************************************/
end_comment

begin_macro
name|qddint
argument_list|(
argument|qd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|qd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|DMAreq_header
modifier|*
name|header
decl_stmt|;
specifier|register
name|struct
name|DMAreq
modifier|*
name|request
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|cookie
decl_stmt|;
comment|/* DMA adrs for QDSS */
name|int
name|i
decl_stmt|;
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
comment|/*----------------- * init pointers */
name|header
operator|=
name|DMAheader
index|[
name|qd
index|]
expr_stmt|;
comment|/* register for optimization */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|adder
expr_stmt|;
comment|/*------------------------------------------------------------------------ * if this interrupt flagged as bogus for interrupt flushing purposes.. */
if|if
condition|(
name|DMA_ISIGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|DMA_CLRIGNORE
argument_list|(
name|header
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*---------------------------------------------------- * dump a DMA hardware error message if appropriate */
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
condition|)
block|{
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|PARITY_ERR
condition|)
name|mprintf
argument_list|(
literal|"\nqd%d: qddint: DMA hardware parity fault."
argument_list|,
name|qd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|BUS_ERR
condition|)
name|mprintf
argument_list|(
literal|"\nqd%d: qddint: DMA hardware bus error."
argument_list|,
name|qd
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------- * if this was a DMA from user space... */
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
condition|)
block|{
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qdflags
index|[
name|qd
index|]
operator|.
name|user_dma
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*------------------------------------------------------------------------ * if we're doing DMA request queue services, field the error condition */
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|DMA_ERR
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
literal|0x0600
expr_stmt|;
comment|/* halt DMA (reset fifo) */
name|dga
operator|->
name|csr
operator||=
name|DMA_ERR
expr_stmt|;
comment|/* clear error condition */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/* cancel adder activity */
name|DMA_SETERROR
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag error in header status word */
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAdone
operator||=
name|HARD_ERROR
expr_stmt|;
name|header
operator|->
name|newest
operator|=
name|header
operator|->
name|oldest
expr_stmt|;
name|header
operator|->
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|dga
operator|->
name|bytcnt_lo
operator|!=
literal|0
condition|)
block|{
name|dga
operator|->
name|bytcnt_lo
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
literal|0
expr_stmt|;
name|DMA_SETIGNORE
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*---------------------------------------------------------------------------- * if the DMA request queue is now becoming non-full, wakeup "select" client */
if|if
condition|(
name|DMA_ISFULL
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
block|}
name|header
operator|->
name|DMAreq
index|[
name|header
operator|->
name|oldest
index|]
operator|.
name|DMAdone
operator||=
name|REQUEST_DONE
expr_stmt|;
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qddint: unexpected interrupt"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
return|return;
block|}
name|DMA_GETEND
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* update request queue indices */
comment|/*------------------------------------------------------------ * if no more DMA pending, wake up "select" client and exit */
if|if
condition|(
name|DMA_ISEMPTY
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_WRITE
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_WRITE
expr_stmt|;
block|}
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag DMA done */
return|return;
block|}
comment|/*--------------------------- * initiate next DMA xfer  */
name|request
operator|=
name|DMA_GETBEGIN
argument_list|(
name|header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request
operator|->
name|DMAtype
condition|)
block|{
case|case
name|DISPLIST
case|:
name|dga
operator|->
name|csr
operator||=
name|DL_ENB
expr_stmt|;
break|break;
case|case
name|PTOB
case|:
name|dga
operator|->
name|csr
operator||=
name|PTOB_ENB
expr_stmt|;
break|break;
case|case
name|BTOP
case|:
name|dga
operator|->
name|csr
operator||=
name|BTOP_ENB
expr_stmt|;
break|break;
default|default:
name|mprintf
argument_list|(
literal|"\nqd%d: qddint: illegal DMAtype parameter."
argument_list|,
name|qd
argument_list|)
expr_stmt|;
name|DMA_CLRACTIVE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* flag DMA done */
return|return;
block|}
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|COUNT_ZERO
condition|)
block|{
name|dga
operator|->
name|csr
operator|&=
operator|~
name|SET_DONE_FIFO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|FIFO_EMPTY
condition|)
block|{
name|dga
operator|->
name|csr
operator||=
name|SET_DONE_FIFO
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|WORD_PACK
condition|)
name|dga
operator|->
name|csr
operator|&=
operator|~
name|BYTE_DMA
expr_stmt|;
elseif|else
if|if
condition|(
name|request
operator|->
name|DMAdone
operator|&
name|BYTE_PACK
condition|)
name|dga
operator|->
name|csr
operator||=
name|BYTE_DMA
expr_stmt|;
name|dga
operator|->
name|csr
operator||=
name|DMA_IE
expr_stmt|;
name|cookie
operator|=
operator|(
operator|(
name|int
operator|)
name|request
operator|->
name|bufp
operator|-
operator|(
name|int
operator|)
name|header
operator|)
operator|+
operator|(
name|int
operator|)
name|header
operator|->
name|QBAreg
expr_stmt|;
name|dga
operator|->
name|adrs_lo
operator|=
operator|(
name|short
operator|)
name|cookie
expr_stmt|;
name|dga
operator|->
name|adrs_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|cookie
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dga
operator|->
name|bytcnt_lo
operator|=
operator|(
name|short
operator|)
name|request
operator|->
name|length
expr_stmt|;
name|dga
operator|->
name|bytcnt_hi
operator|=
call|(
name|short
call|)
argument_list|(
name|request
operator|->
name|length
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***************************************************************** * *	qdaint()... ADDER interrupt service * *****************************************************************/
end_comment

begin_expr_stmt
name|qdaint
argument_list|(
name|qd
argument_list|)
specifier|register
name|int
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|struct
name|color_buf
modifier|*
name|cbuf
decl_stmt|;
name|short
name|stat
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|rgb
modifier|*
name|rgbp
decl_stmt|;
specifier|register
name|short
modifier|*
name|red
decl_stmt|;
specifier|register
name|short
modifier|*
name|green
decl_stmt|;
specifier|register
name|short
modifier|*
name|blue
decl_stmt|;
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|adder
expr_stmt|;
comment|/*------------------------------------------------------------------------ * service the vertical blank interrupt (VSYNC bit) by loading any pending * color map load request  */
if|if
condition|(
name|adder
operator|->
name|status
operator|&
name|VSYNC
condition|)
block|{
name|adder
operator|->
name|status
operator|&=
operator|~
name|VSYNC
expr_stmt|;
comment|/* clear the interrupt */
name|cbuf
operator|=
name|color_buf
index|[
name|qd
index|]
expr_stmt|;
if|if
condition|(
name|cbuf
operator|->
name|status
operator|&
name|LOAD_COLOR_MAP
condition|)
block|{
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|blue
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cbuf
operator|->
name|count
operator|,
name|rgbp
operator|=
name|cbuf
operator|->
name|rgb
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|rgbp
operator|++
control|)
block|{
name|red
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|red
expr_stmt|;
name|green
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|green
expr_stmt|;
name|blue
index|[
name|rgbp
operator|->
name|offset
index|]
operator|=
operator|(
name|short
operator|)
name|rgbp
operator|->
name|blue
expr_stmt|;
block|}
name|cbuf
operator|->
name|status
operator|&=
operator|~
name|LOAD_COLOR_MAP
expr_stmt|;
block|}
block|}
comment|/*------------------------------------------------- * service the scroll interrupt (FRAME_SYNC bit) */
if|if
condition|(
name|adder
operator|->
name|status
operator|&
name|FRAME_SYNC
condition|)
block|{
name|adder
operator|->
name|status
operator|&=
operator|~
name|FRAME_SYNC
expr_stmt|;
comment|/* clear the interrupt */
if|if
condition|(
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|&
name|LOAD_REGS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|stat
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ID_SCROLL_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdaint: timeout on ID_SCROLL_READY"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
return|return;
block|}
name|adder
operator|->
name|ID_scroll_data
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|viper_constant
expr_stmt|;
name|adder
operator|->
name|ID_scroll_command
operator|=
name|ID_LOAD
operator||
name|SCROLL_CONSTANT
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_scroll_constant
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_offset
expr_stmt|;
if|if
condition|(
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|&
name|LOAD_INDEX
condition|)
block|{
name|adder
operator|->
name|x_index_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|x_index_pending
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|scroll
index|[
name|qd
index|]
operator|->
name|y_index_pending
expr_stmt|;
block|}
name|scroll
index|[
name|qd
index|]
operator|->
name|status
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/***************************************************************** * *	qdiint()... DUART input interrupt service routine * *****************************************************************/
end_comment

begin_expr_stmt
name|qdiint
argument_list|(
name|qd
argument_list|)
specifier|register
name|int
name|qd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|_vs_event
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|qdinput
modifier|*
name|eqh
decl_stmt|;
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|struct
name|mouse_report
modifier|*
name|new_rep
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|char
name|chr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|k
decl_stmt|,
name|l
decl_stmt|;
name|u_short
name|status
decl_stmt|;
name|u_short
name|data
decl_stmt|;
name|u_short
name|key
decl_stmt|;
name|char
name|do_wakeup
init|=
literal|0
decl_stmt|;
comment|/* flag to do a select wakeup call */
name|char
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
comment|/* mouse button test variables */
name|spl4
argument_list|()
expr_stmt|;
comment|/* allow interval timer in */
name|eqh
operator|=
name|eq_header
index|[
name|qd
index|]
expr_stmt|;
comment|/* optimized as a register */
name|new_rep
operator|=
operator|&
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|duart
expr_stmt|;
comment|/*----------------------------------------- * if the graphic device is turned on..	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|inuse
operator|&
name|GRAPHIC_DEV
condition|)
block|{
comment|/*--------------- 	    * empty DUART */
while|while
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
operator|||
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
comment|/*--------------------------------- 		* pick up LK-201 input (if any) */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
comment|/* if error condition, then reset it */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdA
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: event queue overflow"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*-------------------------------------- 		    * Check for various keyboard errors  */
name|key
operator|=
name|duart
operator|->
name|dataA
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: keyboard error, code = %x"
argument_list|,
name|qd
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|event
operator|->
name|vse_key
operator|=
name|key
expr_stmt|;
name|event
operator|->
name|vse_key
operator|&=
literal|0x00FF
expr_stmt|;
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTRAW
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_DKB
expr_stmt|;
block|}
comment|/*------------------------------------- 		* pick up the mouse input (if any)  */
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|pntr_id
operator|==
name|MOUSE_ID
condition|)
block|{
if|if
condition|(
name|status
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdB
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: event queue overflow"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* get report byte */
operator|++
name|new_rep
operator|->
name|bytcnt
expr_stmt|;
comment|/* bump report byte count */
comment|/*--------------------------- 		    * if 1st byte of report.. */
if|if
condition|(
name|data
operator|&
name|START_FRAME
condition|)
block|{
name|new_rep
operator|->
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|>
literal|1
condition|)
block|{
name|new_rep
operator|->
name|bytcnt
operator|=
literal|1
expr_stmt|;
comment|/* start of new frame */
continue|continue;
comment|/* ..continue looking */
block|}
block|}
comment|/*--------------------------- 		    * if 2nd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|2
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
name|data
operator|&
literal|0x00FF
expr_stmt|;
block|}
comment|/*------------------------------------------------- 		    * if 3rd byte of report, load input event queue */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|3
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
name|data
operator|&
literal|0x00FF
expr_stmt|;
name|new_rep
operator|->
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/*----------------------------------- 			* if mouse position has changed.. */
if|if
condition|(
name|new_rep
operator|->
name|dx
operator|!=
literal|0
operator|||
name|new_rep
operator|->
name|dy
operator|!=
literal|0
condition|)
block|{
comment|/*--------------------------------------------- 			    * calculate acceleration factor, if needed	*/
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
operator|>
name|ACC_OFF
condition|)
block|{
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|<=
name|new_rep
operator|->
name|dx
condition|)
name|new_rep
operator|->
name|dx
operator|+=
operator|(
name|new_rep
operator|->
name|dx
operator|-
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|)
operator|*
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
expr_stmt|;
if|if
condition|(
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|<=
name|new_rep
operator|->
name|dy
condition|)
name|new_rep
operator|->
name|dy
operator|+=
operator|(
name|new_rep
operator|->
name|dy
operator|-
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_thr
operator|)
operator|*
name|qdflags
index|[
name|qd
index|]
operator|.
name|curs_acc
expr_stmt|;
block|}
comment|/*------------------------------------- 			    * update cursor position coordinates */
if|if
condition|(
name|new_rep
operator|->
name|state
operator|&
name|X_SIGN
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|+=
name|new_rep
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>
literal|1023
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
literal|1023
expr_stmt|;
block|}
else|else
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|-=
name|new_rep
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<
operator|-
literal|15
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
operator|-
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|new_rep
operator|->
name|state
operator|&
name|Y_SIGN
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|-=
name|new_rep
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<
operator|-
literal|15
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
operator|-
literal|15
expr_stmt|;
block|}
else|else
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|+=
name|new_rep
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>
literal|863
condition|)
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
literal|863
expr_stmt|;
block|}
comment|/*--------------------------------- 			    * update cursor screen position */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/*-------------------------------------------- 			    * if cursor is in the box, no event report */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|right
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|left
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|top
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|bottom
condition|)
block|{
goto|goto
name|GET_MBUTTON
goto|;
block|}
comment|/*--------------------------------- 			    * report the mouse motion event */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
comment|/* mouse */
name|event
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
comment|/* pos changed */
name|event
operator|->
name|vse_key
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
block|}
name|GET_MBUTTON
label|:
comment|/*------------------------------- 			* if button state has changed */
name|a
operator|=
name|new_rep
operator|->
name|state
operator|&
literal|0x07
expr_stmt|;
comment|/*mask nonbutton bits */
name|b
operator|=
name|last_rep
index|[
name|qd
index|]
operator|.
name|state
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|a
operator|^
name|b
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|&
operator|(
name|a
operator|^
name|b
operator|)
operator|)
condition|)
comment|/* this button change? */
continue|continue;
comment|/* event queue full? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: event queue overflow"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
comment|/* get new event */
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request select wakeup */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_MOUSE
expr_stmt|;
comment|/* mouse */
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
comment|/* new button */
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
comment|/* flag changed button and if up or down */
if|if
condition|(
name|c
operator|==
name|RIGHT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_RIGHT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|MIDDLE_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_MIDDLE_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|LEFT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_LEFT_BUTTON
expr_stmt|;
comment|/* set bit = button depressed */
if|if
condition|(
name|c
operator|&
name|a
condition|)
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
block|}
block|}
comment|/* refresh last report */
name|last_rep
index|[
name|qd
index|]
operator|=
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
block|}
comment|/* get last byte of report */
block|}
comment|/* pickup mouse input */
comment|/*-------------------------------- 		* pickup tablet input, if any  */
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|pntr_id
operator|==
name|TABLET_ID
condition|)
block|{
if|if
condition|(
name|status
operator|&
literal|0x70
condition|)
block|{
name|duart
operator|->
name|cmdB
operator|=
literal|0x40
expr_stmt|;
continue|continue;
block|}
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: event queue overflow"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/* get report byte */
operator|++
name|new_rep
operator|->
name|bytcnt
expr_stmt|;
comment|/* bump report byte count */
comment|/*--------------------------- 		    * if 1st byte of report.. */
if|if
condition|(
name|data
operator|&
name|START_FRAME
condition|)
block|{
name|new_rep
operator|->
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|>
literal|1
condition|)
block|{
name|new_rep
operator|->
name|bytcnt
operator|=
literal|1
expr_stmt|;
comment|/* start of new frame */
continue|continue;
comment|/* ..continue looking */
block|}
block|}
comment|/*--------------------------- 		    * if 2nd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|2
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
name|data
operator|&
literal|0x3F
expr_stmt|;
block|}
comment|/*--------------------------- 		    * if 3rd byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|3
condition|)
block|{
name|new_rep
operator|->
name|dx
operator||=
operator|(
name|data
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
comment|/*--------------------------- 		    * if 4th byte of report.. */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|4
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
name|data
operator|&
literal|0x3F
expr_stmt|;
block|}
comment|/*------------------------------------------------- 		    * if 5th byte of report, load input event queue */
elseif|else
if|if
condition|(
name|new_rep
operator|->
name|bytcnt
operator|==
literal|5
condition|)
block|{
name|new_rep
operator|->
name|dy
operator||=
operator|(
name|data
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
expr_stmt|;
name|new_rep
operator|->
name|bytcnt
operator|=
literal|0
expr_stmt|;
comment|/*------------------------------------- 			* update cursor position coordinates */
name|new_rep
operator|->
name|dx
operator|/=
name|qdflags
index|[
name|qd
index|]
operator|.
name|tab_res
expr_stmt|;
name|new_rep
operator|->
name|dy
operator|=
operator|(
literal|2200
operator|-
name|new_rep
operator|->
name|dy
operator|)
operator|/
name|qdflags
index|[
name|qd
index|]
operator|.
name|tab_res
expr_stmt|;
if|if
condition|(
name|new_rep
operator|->
name|dx
operator|>
literal|1023
condition|)
block|{
name|new_rep
operator|->
name|dx
operator|=
literal|1023
expr_stmt|;
block|}
if|if
condition|(
name|new_rep
operator|->
name|dy
operator|>
literal|863
condition|)
block|{
name|new_rep
operator|->
name|dy
operator|=
literal|863
expr_stmt|;
block|}
comment|/* 			 * report an event if the puck/stylus has moved 			 */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|!=
name|new_rep
operator|->
name|dx
operator|||
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|!=
name|new_rep
operator|->
name|dy
condition|)
block|{
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|=
name|new_rep
operator|->
name|dx
expr_stmt|;
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|=
name|new_rep
operator|->
name|dy
expr_stmt|;
comment|/*--------------------------------- 			    * update cursor screen position */
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|qd
index|]
operator|.
name|dga
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eqh
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* 			     * if cursor is in the box, no event report 			     */
if|if
condition|(
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|right
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|x
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|left
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|>=
name|eqh
operator|->
name|curs_box
operator|.
name|top
operator|&&
name|eqh
operator|->
name|curs_pos
operator|.
name|y
operator|<=
name|eqh
operator|->
name|curs_box
operator|.
name|bottom
condition|)
block|{
goto|goto
name|GET_TBUTTON
goto|;
block|}
comment|/*--------------------------------- 			    * report the tablet motion event */
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_TABLET
expr_stmt|;
comment|/* tablet */
comment|/* 			     * right now, X handles tablet motion the same 			     * as mouse motion 			     */
name|event
operator|->
name|vse_type
operator|=
name|VSE_MMOTION
expr_stmt|;
comment|/* pos changed */
name|event
operator|->
name|vse_key
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_direction
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
block|}
name|GET_TBUTTON
label|:
comment|/*------------------------------- 			* if button state has changed */
name|a
operator|=
name|new_rep
operator|->
name|state
operator|&
literal|0x1E
expr_stmt|;
comment|/* mask nonbutton bits */
name|b
operator|=
name|last_rep
index|[
name|qd
index|]
operator|.
name|state
operator|&
literal|0x1E
expr_stmt|;
if|if
condition|(
name|a
operator|^
name|b
condition|)
block|{
comment|/* event queue full now? (overflow condition) */
if|if
condition|(
name|ISFULL
argument_list|(
name|eqh
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: event queue overflow"
argument_list|,
name|qd
argument_list|)
expr_stmt|;
break|break;
block|}
name|event
operator|=
name|PUTBEGIN
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
comment|/* get new event */
name|PUTEND
argument_list|(
name|eqh
argument_list|)
expr_stmt|;
operator|++
name|do_wakeup
expr_stmt|;
comment|/* request a select wakeup call */
name|event
operator|->
name|vse_x
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|x
expr_stmt|;
name|event
operator|->
name|vse_y
operator|=
name|eqh
operator|->
name|curs_pos
operator|.
name|y
expr_stmt|;
name|event
operator|->
name|vse_device
operator|=
name|VSE_TABLET
expr_stmt|;
comment|/* tablet */
name|event
operator|->
name|vse_type
operator|=
name|VSE_BUTTON
expr_stmt|;
comment|/* button changed */
name|event
operator|->
name|vse_time
operator|=
name|TOY
expr_stmt|;
comment|/* time stamp */
comment|/* define the changed button and if up or down */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<=
literal|0x10
condition|;
name|c
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|c
operator|&
operator|(
name|a
operator|^
name|b
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|T_LEFT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_LEFT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_FRONT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_FRONT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_RIGHT_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_RIGHT_BUTTON
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|T_BACK_BUTTON
condition|)
name|event
operator|->
name|vse_key
operator|=
name|VSE_T_BACK_BUTTON
expr_stmt|;
break|break;
block|}
block|}
comment|/* set bit = button depressed */
if|if
condition|(
name|c
operator|&
name|a
condition|)
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|event
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
block|}
comment|/* refresh last report */
name|last_rep
index|[
name|qd
index|]
operator|=
name|current_rep
index|[
name|qd
index|]
expr_stmt|;
block|}
comment|/* get last byte of report */
block|}
comment|/* pick up tablet input */
block|}
comment|/* while input available.. */
comment|/*--------------------- 	    * do select wakeup	*/
if|if
condition|(
name|rsel
index|[
name|qd
index|]
operator|&&
name|do_wakeup
operator|&&
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&
name|SEL_READ
condition|)
block|{
name|selwakeup
argument_list|(
name|rsel
index|[
name|qd
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsel
index|[
name|qd
index|]
operator|=
literal|0
expr_stmt|;
name|qdflags
index|[
name|qd
index|]
operator|.
name|selmask
operator|&=
operator|~
name|SEL_READ
expr_stmt|;
name|do_wakeup
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*----------------------------------------------------------------- * if the graphic device is not turned on, this is console input */
else|else
block|{
name|ui
operator|=
name|qdinfo
index|[
name|qd
index|]
expr_stmt|;
if|if
condition|(
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tp
operator|=
operator|&
name|qd_tty
index|[
name|qd
operator|<<
literal|2
index|]
expr_stmt|;
comment|/*-------------------------------------- 	    * Get a character from the keyboard. */
while|while
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/*-------------------------------------- 		* Check for various keyboard errors  */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd%d: qdiint: Keyboard error, code = %x"
argument_list|,
name|qd
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*--------------------------------- 		* See if its a state change key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
name|led_control
argument_list|(
name|qd
argument_list|,
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
name|led_control
argument_list|(
name|qd
argument_list|,
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
return|return;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
return|return;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 		    * Test for cntrl characters. If set, see if the character 		    * is elligible to become a control character. */
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/*----------------------------------- 		* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x80
condition|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|q_special
index|[
name|chr
operator|&
literal|0x7F
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|string
operator|++
operator|,
name|tp
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|chr
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/*---------------------- * cleanup and exit  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdiint */
end_comment

begin_comment
comment|/****************************************************************** ******************************************************************* ******************************************************************* * *	THE SUBROUTINES START HERE: * ******************************************************************/
end_comment

begin_comment
comment|/***************************************************************** * *	clear_qd_screen()... clear the QDSS screen * ****************************************************************** * *>>> NOTE<<< * *   This code requires that certain adder initialization be valid.  To *   assure that this requirement is satisfied, this routine should be *   called only after calling the "setup_dragon()" function. * *   Clear the bitmap a piece at a time. Since the fast scroll clear *   only clears the current displayed portion of the bitmap put a *   temporary value in the y limit register so we can access whole *   bitmap * ****************/
end_comment

begin_macro
name|clear_qd_screen
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
literal|2048
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|864
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|1728
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_scroll_constant
operator|=
name|SCROLL_ERASE
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|y_offset_pending
operator|=
literal|0
expr_stmt|;
comment|/* back to normal */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_limit
operator|=
name|MAX_SCREEN_X
expr_stmt|;
name|adder
operator|->
name|y_limit
operator|=
name|MAX_SCREEN_Y
operator|+
name|FONT_HEIGHT
expr_stmt|;
block|}
end_block

begin_comment
comment|/* clear_qd_screen */
end_comment

begin_comment
comment|/********************************************************************** * *	qdputc()... route kernel console output to display destination * *********************************************************************** * *	calling convention: * *		qdputc(chr); * *	where:	char chr;	 ;character for output * ****************/
end_comment

begin_expr_stmt
name|qdputc
argument_list|(
name|chr
argument_list|)
specifier|register
name|char
name|chr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp0
decl_stmt|;
comment|/*--------------------------------------------------------- * if system is now physical, forget it (ie: crash DUMP) */
if|if
condition|(
operator|(
name|mfpr
argument_list|(
name|MAPEN
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/*-------------------------------------------------- * direct kernel output char to the proper place  */
name|tp0
operator|=
operator|&
name|qd_tty
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|qdflags
index|[
literal|0
index|]
operator|.
name|kernel_loop
operator|!=
literal|0
operator|&&
name|tp0
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp0
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|chr
operator|,
name|tp0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|blitc
argument_list|(
literal|0
argument_list|,
name|chr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* qdputc */
end_comment

begin_comment
comment|/******************************************************************* * *	qdgetc()... get a character from the LK201 * ******************************************************************* * *	calling convention: * *		qdgetc(); * *	returns:  the character read. * ****************/
end_comment

begin_macro
name|qdgetc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|short
name|key
decl_stmt|;
specifier|register
name|char
name|chr
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
literal|0
index|]
operator|.
name|duart
expr_stmt|;
comment|/*-------------------------------------- 	* Get a character from the keyboard. */
name|LOOP
label|:
while|while
condition|(
operator|!
operator|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
operator|)
condition|)
empty_stmt|;
name|key
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
name|key
operator|&=
literal|0xFF
expr_stmt|;
comment|/*-------------------------------------- 	* Check for various keyboard errors  */
if|if
condition|(
name|key
operator|==
name|LK_POWER_ERROR
operator|||
name|key
operator|==
name|LK_KDOWN_ERROR
operator|||
name|key
operator|==
name|LK_INPUT_ERROR
operator|||
name|key
operator|==
name|LK_OUTPUT_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard error, code = %x\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|key
operator|<
name|LK_LOWEST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*--------------------------------- 	* See if its a state change key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|LOCK
case|:
name|q_keyboard
operator|.
name|lock
operator|^=
literal|0xffff
expr_stmt|;
comment|/* toggle */
if|if
condition|(
name|q_keyboard
operator|.
name|lock
condition|)
name|led_control
argument_list|(
name|LK_LED_ENABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
else|else
name|led_control
argument_list|(
name|LK_LED_DISABLE
argument_list|,
name|LK_LED_LOCK
argument_list|)
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|SHIFT
case|:
name|q_keyboard
operator|.
name|shift
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|CNTRL
case|:
name|q_keyboard
operator|.
name|cntrl
operator|^=
literal|0xFFFF
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|ALLUP
case|:
name|q_keyboard
operator|.
name|cntrl
operator|=
literal|0
expr_stmt|;
name|q_keyboard
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
goto|goto
name|LOOP
goto|;
case|case
name|REPEAT
case|:
name|chr
operator|=
name|q_keyboard
operator|.
name|last
expr_stmt|;
break|break;
comment|/*------------------------------------------------------- 	    * Test for cntrl characters. If set, see if the character 	    * is elligible to become a control character. */
default|default:
if|if
condition|(
name|q_keyboard
operator|.
name|cntrl
condition|)
block|{
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|chr
operator|>=
literal|' '
operator|&&
name|chr
operator|<=
literal|'~'
condition|)
name|chr
operator|&=
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_keyboard
operator|.
name|lock
operator|||
name|q_keyboard
operator|.
name|shift
condition|)
name|chr
operator|=
name|q_shift_key
index|[
name|key
index|]
expr_stmt|;
else|else
name|chr
operator|=
name|q_key
index|[
name|key
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chr
operator|<
literal|' '
operator|&&
name|chr
operator|>
literal|'~'
condition|)
comment|/* if input is non-displayable */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ..then pitch it! */
name|q_keyboard
operator|.
name|last
operator|=
name|chr
expr_stmt|;
comment|/*----------------------------------- 	* Check for special function keys */
if|if
condition|(
name|chr
operator|&
literal|0x80
condition|)
comment|/* pitch the function keys */
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|chr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* qdgetc */
end_comment

begin_comment
comment|/********************************************************************** * *	ldcursor()... load the mouse cursor's template RAM bitmap * ********************************************************************* * *	calling convention: * *		ldcursor(unit, bitmap); *		u_int unit; *		short *bitmap; * ****************/
end_comment

begin_macro
name|ldcursor
argument_list|(
argument|unit
argument_list|,
argument|bitmap
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|bitmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
specifier|register
name|short
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|cursor
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|temp
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|template
expr_stmt|;
if|if
condition|(
name|dga
operator|->
name|csr
operator|&
name|CURS_ENB
condition|)
block|{
comment|/* if the cursor is enabled.. */
name|cursor
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ..note that.. */
name|dga
operator|->
name|csr
operator|&=
operator|~
name|CURS_ENB
expr_stmt|;
comment|/* ..and shut it off */
block|}
else|else
block|{
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
name|dga
operator|->
name|csr
operator|&=
operator|~
name|CURS_ENB
expr_stmt|;
comment|/* shut off the cursor */
name|temp
operator|+=
operator|(
literal|8
operator|*
literal|1024
operator|)
operator|-
literal|32
expr_stmt|;
comment|/* cursor is 32 WORDS from the end */
comment|/* ..of the 8k WORD template space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
operator|*
name|temp
operator|++
operator|=
operator|*
name|bitmap
operator|++
expr_stmt|;
if|if
condition|(
name|cursor
condition|)
block|{
comment|/* if cursor was enabled.. */
name|dga
operator|->
name|csr
operator||=
name|CURS_ENB
expr_stmt|;
comment|/* ..turn it back on */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ldcursor */
end_comment

begin_comment
comment|/********************************************************************** * *	ldfont()... put the console font in the QDSS off-screen memory * *********************************************************************** * *	calling convention: * *		ldfont(unit); *		u_int unit;	;QDSS unit number * ****************/
end_comment

begin_macro
name|ldfont
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* scratch variables */
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|short
name|packed
decl_stmt|;
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
comment|/*------------------------------------------ * setup VIPER operand control registers  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_SOURCE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/*-------------------------- * load destination data  */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
name|FONT_X
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
name|FONT_Y
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
name|FONT_WIDTH
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/*--------------------------------------- * setup for processor to bitmap xfer  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|PBT
operator||
name|OCRB
operator||
literal|2
operator||
name|DTE
operator||
literal|2
expr_stmt|;
comment|/*----------------------------------------------- * iteratively do the processor to bitmap xfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
operator|++
name|i
control|)
block|{
comment|/* PTOB a scan line */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|j
operator|<
literal|48
condition|;
operator|++
name|j
control|)
block|{
comment|/* PTOB one scan of a char cell */
name|packed
operator|=
name|q_font
index|[
name|k
index|]
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|packed
operator||=
operator|(
operator|(
name|short
operator|)
name|q_font
index|[
name|k
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|k
operator|+=
name|ROWS
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|TX_READY
argument_list|)
expr_stmt|;
name|adder
operator|->
name|id_data
operator|=
name|packed
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* ldfont */
end_comment

begin_comment
comment|/********************************************************************* * *	led_control()... twiddle LK-201 LED's * ********************************************************************** * *	led_control(unit, cmd, led_mask); *	u_int unit;	QDSS number *	int cmd;	LED enable/disable command *	int led_mask;	which LED(s) to twiddle * *************/
end_comment

begin_macro
name|led_control
argument_list|(
argument|unit
argument_list|,
argument|cmd
argument_list|,
argument|led_mask
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|led_mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|cmd
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|led_mask
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|BAD
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* led_control */
end_comment

begin_comment
comment|/******************************************************************* * *	scroll_up()... move the screen up one character height * ******************************************************************** * *	calling convention: * *		scroll_up(adder); *		struct adder *adder;	;address of adder * ********/
end_comment

begin_expr_stmt
name|scroll_up
argument_list|(
name|adder
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*------------------------------------------ * setup VIPER operand control registers  */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|ADDRESS_COMPLETE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* select all planes */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|ID
operator||
name|BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- * load DESTINATION origin and vectors  */
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|NORMAL
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
comment|/*----------------------------------- * load SOURCE origin and vectors  */
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_dx
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
operator|+
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
name|RASTEROP
operator||
name|OCRB
operator||
literal|0
operator||
name|S1E
operator||
name|DTE
expr_stmt|;
comment|/*-------------------------------------------- * do a rectangle clear of last screen line */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
operator|(
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_BAR_SHIFT_DELAY
operator|)
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
comment|/* set up the width of	*/
name|adder
operator|->
name|slow_dest_dy
operator|=
name|CHAR_HEIGHT
expr_stmt|;
comment|/* rectangle */
name|adder
operator|->
name|rasterop_mode
operator|=
operator|(
name|NORMAL
operator||
name|DST_WRITE_ENABLE
operator|)
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|RASTEROP_COMPLETE
argument_list|)
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|864
operator|-
name|CHAR_HEIGHT
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1024
expr_stmt|;
comment|/* set up the height	*/
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
comment|/* of rectangle 	*/
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
operator|(
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator|)
argument_list|)
expr_stmt|;
name|adder
operator|->
name|cmd
operator|=
operator|(
name|RASTEROP
operator||
name|OCRB
operator||
name|LF_R2
operator||
name|DTE
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scroll_up */
end_comment

begin_comment
comment|/******************************************************************** * *	init_shared()... init shared memory pointers and structures * ********************************************************************* * *	calling convention: * *		init_shared(unit); *		u_int unit; * ****************/
end_comment

begin_expr_stmt
name|init_shared
argument_list|(
name|unit
argument_list|)
specifier|register
name|u_int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
comment|/*-------------------------------------------------- * initialize the event queue pointers and header */
name|eq_header
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|qdinput
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|event_shared
operator|&
operator|~
operator|(
literal|0x01FF
operator|)
operator|)
operator|+
literal|512
operator|)
operator|+
operator|(
name|EVENT_BUFSIZE
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|dga
operator|->
name|x_cursor
operator|=
name|TRANX
argument_list|(
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|x
argument_list|)
expr_stmt|;
name|dga
operator|->
name|y_cursor
operator|=
name|TRANY
argument_list|(
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_pos
operator|.
name|y
argument_list|)
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|top
operator|=
literal|0
expr_stmt|;
name|eq_header
index|[
name|unit
index|]
operator|->
name|curs_box
operator|.
name|bottom
operator|=
literal|0
expr_stmt|;
comment|/*--------------------------------------------------------- * assign a pointer to the DMA I/O buffer for this QDSS. */
name|DMAheader
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|DMAreq_header
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|DMA_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
name|DMAbuf_size
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|DMAreq
operator|=
operator|(
expr|struct
name|DMAreq
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|DMAheader
index|[
name|unit
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|DMAreq_header
argument_list|)
operator|)
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|QBAreg
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|shared_size
operator|=
name|DMAbuf_size
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|size
operator|=
literal|10
expr_stmt|;
comment|/* default = 10 requests */
name|DMAheader
index|[
name|unit
index|]
operator|->
name|oldest
operator|=
literal|0
expr_stmt|;
name|DMAheader
index|[
name|unit
index|]
operator|->
name|newest
operator|=
literal|0
expr_stmt|;
comment|/*----------------------------------------------------------- * assign a pointer to the scroll structure for this QDSS. */
name|scroll
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|scroll
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|scroll_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scroll
argument_list|)
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|viper_constant
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_scroll_constant
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_offset
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|scroll
index|[
name|unit
index|]
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------------------------------- * assign a pointer to the color map write buffer for this QDSS */
name|color_buf
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|color_buf
operator|*
operator|)
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|&
name|color_shared
index|[
literal|0
index|]
operator|+
literal|512
argument_list|)
operator|&
operator|~
literal|0x1FF
operator|)
operator|+
operator|(
name|COLOR_BUFSIZ
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|color_buf
index|[
name|unit
index|]
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* init_shared */
end_comment

begin_comment
comment|/********************************************************************* * *	setup_dragon()... init the ADDER, VIPER, bitmaps,& color map * ********************************************************************** * *	calling convention: * *		setup_dragon(); * *	return: NONE * ************************/
end_comment

begin_macro
name|setup_dragon
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|adder
modifier|*
name|adder
decl_stmt|;
specifier|register
name|struct
name|dga
modifier|*
name|dga
decl_stmt|;
name|short
modifier|*
name|memcsr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* general purpose variables */
name|int
name|status
decl_stmt|;
name|short
name|top
decl_stmt|;
comment|/* clipping/scrolling boundaries */
name|short
name|bottom
decl_stmt|;
name|short
name|right
decl_stmt|;
name|short
name|left
decl_stmt|;
name|short
modifier|*
name|red
decl_stmt|;
comment|/* color map pointers */
name|short
modifier|*
name|green
decl_stmt|;
name|short
modifier|*
name|blue
decl_stmt|;
comment|/*------------------ * init for setup */
name|adder
operator|=
operator|(
expr|struct
name|adder
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|adder
expr_stmt|;
name|dga
operator|=
operator|(
expr|struct
name|dga
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|dga
expr_stmt|;
name|memcsr
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|memcsr
expr_stmt|;
name|dga
operator|->
name|csr
operator|&=
operator|~
operator|(
name|DMA_IE
operator||
literal|0x700
operator|)
expr_stmt|;
comment|/* halt DMA and kill the intrpts */
operator|*
name|memcsr
operator|=
name|SYNC_ON
expr_stmt|;
comment|/* blank screen and turn off LED's */
name|adder
operator|->
name|command
operator|=
name|CANCEL
expr_stmt|;
comment|/*---------------------- * set monitor timing */
name|adder
operator|->
name|x_scan_count_0
operator|=
literal|0x2800
expr_stmt|;
name|adder
operator|->
name|x_scan_count_1
operator|=
literal|0x1020
expr_stmt|;
name|adder
operator|->
name|x_scan_count_2
operator|=
literal|0x003A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_3
operator|=
literal|0x38F0
expr_stmt|;
name|adder
operator|->
name|x_scan_count_4
operator|=
literal|0x6128
expr_stmt|;
name|adder
operator|->
name|x_scan_count_5
operator|=
literal|0x093A
expr_stmt|;
name|adder
operator|->
name|x_scan_count_6
operator|=
literal|0x313C
expr_stmt|;
name|adder
operator|->
name|sync_phase_adj
operator|=
literal|0x0100
expr_stmt|;
name|adder
operator|->
name|x_scan_conf
operator|=
literal|0x00C8
expr_stmt|;
comment|/*--------------------------------------------------------- * got a bug in secound pass ADDER! lets take care of it */
comment|/* normally, just use the code in the following bug fix code, but to 	* make repeated demos look pretty, load the registers as if there was 	* no bug and then test to see if we are getting sync */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
comment|/* if no sync, do the bug fix code */
if|if
condition|(
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
operator|==
name|BAD
condition|)
block|{
comment|/* first load all Y scan registers with very short frame and 	    * wait for scroll service.	This guarantees at least one SYNC 	    * to fix the pass 2 Adder initialization bug (synchronizes 	    * XCINCH with DMSEEDH) */
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x01
expr_stmt|;
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x01
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* delay at least 1 full frame time */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* now load the REAL sync values (in reverse order just to 	    *  be safe.  */
name|adder
operator|->
name|y_scan_count_3
operator|=
literal|0x0388
expr_stmt|;
name|adder
operator|->
name|y_scan_count_2
operator|=
literal|0x2366
expr_stmt|;
name|adder
operator|->
name|y_scan_count_1
operator|=
literal|0x3363
expr_stmt|;
name|adder
operator|->
name|y_scan_count_0
operator|=
literal|0x135F
expr_stmt|;
block|}
operator|*
name|memcsr
operator|=
name|SYNC_ON
operator||
name|UNBLANK
expr_stmt|;
comment|/* turn off leds and turn on video */
comment|/*---------------------------- * zero the index registers */
name|adder
operator|->
name|x_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|pause
operator|=
literal|0
expr_stmt|;
comment|/*---------------------------------------- * set rasterop mode to normal pen down */
name|adder
operator|->
name|rasterop_mode
operator|=
name|DST_WRITE_ENABLE
operator||
name|DST_INDEX_ENABLE
operator||
name|NORMAL
expr_stmt|;
comment|/*-------------------------------------------------- * set the rasterop registers to a default values */
name|adder
operator|->
name|source_1_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|source_1_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_1_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|destination_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|fast_dest_dx
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|fast_dest_dy
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dx
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|slow_dest_dy
operator|=
literal|1
expr_stmt|;
name|adder
operator|->
name|error_1
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|error_2
operator|=
literal|0
expr_stmt|;
comment|/*------------------------ * scale factor = unity */
name|adder
operator|->
name|fast_scale
operator|=
name|UNITY
expr_stmt|;
name|adder
operator|->
name|slow_scale
operator|=
name|UNITY
expr_stmt|;
comment|/*------------------------------- * set the source 2 parameters */
name|adder
operator|->
name|source_2_x
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_y
operator|=
literal|0
expr_stmt|;
name|adder
operator|->
name|source_2_size
operator|=
literal|0x0022
expr_stmt|;
comment|/*----------------------------------------------- * initialize plane addresses for eight vipers */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0040
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|PLANE_ADDRESS
argument_list|,
literal|0x0007
argument_list|)
expr_stmt|;
comment|/* initialize the external registers. */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_UPDATE_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|CS_SCROLL_MASK
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/* initialize resolution mode */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MEMORY_BUS_WIDTH
argument_list|,
literal|0x000C
argument_list|)
expr_stmt|;
comment|/* bus width = 16 */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RESOLUTION_MODE
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* one bit/pixel */
comment|/* initialize viper registers */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_CONSTANT
argument_list|,
name|SCROLL_ENABLE
operator||
name|VIPER_LEFT
operator||
name|VIPER_UP
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SCROLL_FILL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/*---------------------------------------------------- * set clipping and scrolling limits to full screen */
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|mprintf
argument_list|(
literal|"\nqd%d: setup_dragon: timeout on ADDRESS_COMPLETE"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|bottom
operator|=
literal|2048
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|1024
expr_stmt|;
name|adder
operator|->
name|x_clip_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|x_clip_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|y_clip_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|y_clip_max
operator|=
name|bottom
expr_stmt|;
name|adder
operator|->
name|scroll_x_min
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|scroll_x_max
operator|=
name|right
expr_stmt|;
name|adder
operator|->
name|scroll_y_min
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|scroll_y_max
operator|=
name|bottom
expr_stmt|;
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
comment|/* wait at LEAST 1 full frame */
name|wait_status
argument_list|(
name|adder
argument_list|,
name|VSYNC
argument_list|)
expr_stmt|;
name|adder
operator|->
name|x_index_pending
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_pending
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_new
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_new
operator|=
name|top
expr_stmt|;
name|adder
operator|->
name|x_index_old
operator|=
name|left
expr_stmt|;
name|adder
operator|->
name|y_index_old
operator|=
name|top
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|mprintf
argument_list|(
literal|"\nqd%d: setup_dragon: timeout on ADDRESS_COMPLETE"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LEFT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|RIGHT_SCROLL_MASK
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------------------ * set source and the mask register to all ones (ie: white) */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SOURCE
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|MASK_1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|FOREGROUND_COLOR_Z
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|VIPER_Z_LOAD
operator||
name|BACKGROUND_COLOR_Z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*-------------------------------------------------------------- * initialize Operand Control Register banks for fill command */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_A
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC1_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_SOURCE
operator||
name|NO_ID
operator||
name|WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|SRC2_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_M1_M2
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|DST_OCR_B
argument_list|,
name|EXT_NONE
operator||
name|INT_NONE
operator||
name|NO_ID
operator||
name|NO_WAIT
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------------------------ * init Logic Unit Function registers, (these are just common values, * and may be changed as required).  */
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R1
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R2
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_SOURCE
operator||
name|INV_M1_M2
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R3
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_OR_S
argument_list|)
expr_stmt|;
name|write_ID
argument_list|(
name|adder
argument_list|,
name|LU_FUNCTION_R4
argument_list|,
name|FULL_SRC_RESOLUTION
operator||
name|LF_D_XOR_S
argument_list|)
expr_stmt|;
comment|/*---------------------------------------- * load the color map for black& white */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|VSYNC
operator|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|mprintf
argument_list|(
literal|"\nqd%d: setup_dragon: timeout on VSYNC"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|red
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|red
expr_stmt|;
name|green
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|green
expr_stmt|;
name|blue
operator|=
operator|(
name|short
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|blue
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|--
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|--
operator|=
literal|0xFF
expr_stmt|;
comment|/*---------------------------------- 	* set color map for mouse cursor */
name|red
operator|+=
literal|254
expr_stmt|;
name|green
operator|+=
literal|254
expr_stmt|;
name|blue
operator|+=
literal|254
expr_stmt|;
operator|*
name|red
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* black */
operator|*
name|green
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|blue
operator|++
operator|=
literal|0x00
expr_stmt|;
operator|*
name|red
operator|=
literal|0xFF
expr_stmt|;
comment|/* white */
operator|*
name|green
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|blue
operator|=
literal|0xFF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* setup_dragon */
end_comment

begin_comment
comment|/****************************************************************** * *	setup_input()... init the DUART and set defaults in input *			 devices * ******************************************************************* * *	calling convention: * *		setup_input(unit); * *	where: unit - is the QDSS unit number to be setup * *********/
end_comment

begin_macro
name|setup_input
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|duart
modifier|*
name|duart
decl_stmt|;
comment|/* DUART register structure pointer */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* scratch variable */
specifier|register
name|int
name|bits
decl_stmt|;
name|char
name|id_byte
decl_stmt|;
name|short
name|status
decl_stmt|;
comment|/*--------------- * init stuff */
name|duart
operator|=
operator|(
expr|struct
name|duart
operator|*
operator|)
name|qdmap
index|[
name|unit
index|]
operator|.
name|duart
expr_stmt|;
name|duart
operator|->
name|imask
operator|=
literal|0
expr_stmt|;
comment|/*--------------------------------------------- * setup the DUART for kbd& pointing device */
name|duart
operator|->
name|cmdA
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg ptr for kbd */
name|duart
operator|->
name|modeA
operator|=
literal|0x13
expr_stmt|;
comment|/* 8 bits, no parity, rcv IE, */
comment|/* no RTS control,char error mode */
name|duart
operator|->
name|modeA
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|cmdB
operator|=
name|RESET_M
expr_stmt|;
comment|/* reset mode reg pntr for host */
name|duart
operator|->
name|modeB
operator|=
literal|0x07
expr_stmt|;
comment|/* 8 bits, odd parity, rcv IE.. */
comment|/* ..no RTS cntrl, char error mode */
name|duart
operator|->
name|modeB
operator|=
literal|0x07
expr_stmt|;
comment|/* 1 stop bit,CTS does not IE XMT */
comment|/* no RTS control,no echo or loop */
name|duart
operator|->
name|auxctl
operator|=
literal|0x00
expr_stmt|;
comment|/* baud rate set 1 */
name|duart
operator|->
name|clkselA
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for kbd */
name|duart
operator|->
name|clkselB
operator|=
literal|0x99
expr_stmt|;
comment|/* 4800 baud for mouse */
comment|/* reset everything for keyboard */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdA
operator|=
name|bits
expr_stmt|;
comment|/* reset everything for host */
for|for
control|(
name|bits
operator|=
name|RESET_M
init|;
name|bits
operator|<
name|START_BREAK
condition|;
name|bits
operator|+=
literal|0x10
control|)
name|duart
operator|->
name|cmdB
operator|=
name|bits
expr_stmt|;
name|duart
operator|->
name|cmdA
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for kbd */
name|duart
operator|->
name|cmdB
operator|=
name|EN_RCV
operator||
name|EN_XMT
expr_stmt|;
comment|/* enbl xmt& rcv for pointer device */
comment|/*-------------------------------------------- * init keyboard defaults (DUART channel A) */
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataA
operator|=
name|LK_DEFAULTS
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusA
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
name|status
operator|=
name|duart
operator|->
name|dataA
expr_stmt|;
comment|/* flush the ACK */
comment|/*-------------------------------- * identify the pointing device */
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|SELF_TEST
expr_stmt|;
break|break;
block|}
block|}
comment|/*----------------------------------------- 	* wait for 1st byte of self test report */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd[%d]: setup_input: timeout on 1st byte of self test"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
name|status
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/*----------------------------------------- 	* wait for ID byte of self test report	*/
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd[%d]: setup_input: timeout on 2nd byte of self test"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
name|id_byte
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
comment|/*------------------------------------ 	* wait for other bytes to come in  */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
name|status
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd[%d]: setup_input: timeout on 3rd byte of self test"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|RCV_RDY
condition|)
block|{
name|status
operator|=
name|duart
operator|->
name|dataB
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nqd[%d]: setup_input: timeout on 4th byte of self test\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|OUT
goto|;
block|}
comment|/*---------------------------------------------- 	* flag pointing device type and set defaults */
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|id_byte
operator|&
literal|0x0F
operator|)
operator|!=
name|TABLET_ID
condition|)
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|pntr_id
operator|=
name|MOUSE_ID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|INC_STREAM_MODE
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|qdflags
index|[
name|unit
index|]
operator|.
name|pntr_id
operator|=
name|TABLET_ID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|duart
operator|->
name|statusB
operator|)
operator|&
name|XMT_RDY
condition|)
block|{
name|duart
operator|->
name|dataB
operator|=
name|T_STREAM
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*-------- * exit */
name|OUT
label|:
name|duart
operator|->
name|imask
operator|=
name|qdflags
index|[
name|unit
index|]
operator|.
name|duart_imask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* setup_input */
end_comment

begin_comment
comment|/********************************************************************** * *	wait_status()... delay for at least one display frame time * *********************************************************************** * *	calling convention: * *		wait_status(adder, mask); *		struct *adder adder; *		int mask; * *	return: BAD means that we timed out without ever seeing the *		      vertical sync status bit *		GOOD otherwise * **************/
end_comment

begin_expr_stmt
name|wait_status
argument_list|(
name|adder
argument_list|,
name|mask
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|10000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|mask
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"\nwait_status: timeout polling for 0x%x in adder->status"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* wait_status */
end_comment

begin_comment
comment|/********************************************************************** * *	write_ID()... write out onto the ID bus * *********************************************************************** * *	calling convention: * *		struct *adder adder;	;pntr to ADDER structure *		short adrs;		;VIPER address *		short data;		;data to be written *		write_ID(adder); * *	return: BAD means that we timed out waiting for status bits *		      VIPER-access-specific status bits *		GOOD otherwise * **************/
end_comment

begin_expr_stmt
name|write_ID
argument_list|(
name|adder
argument_list|,
name|adrs
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|adder
operator|*
name|adder
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
name|adrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|short
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|ADDRESS_COMPLETE
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|ERR
goto|;
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|adder
operator|->
name|status
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|adder
operator|->
name|status
operator|)
operator|&
name|TX_READY
operator|)
condition|;
operator|--
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|adder
operator|->
name|id_data
operator|=
name|data
expr_stmt|;
name|adder
operator|->
name|command
operator|=
name|ID_LOAD
operator||
name|adrs
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|ERR
label|:
name|mprintf
argument_list|(
literal|"\nwrite_ID: timeout trying to write to VIPER"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BAD
operator|)
return|;
block|}
end_block

begin_comment
comment|/* write_ID */
end_comment

end_unit

