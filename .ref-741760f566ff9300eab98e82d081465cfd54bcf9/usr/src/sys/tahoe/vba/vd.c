begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vd.c	1.15	87/02/28	*/
end_comment

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_if
if|#
directive|if
name|NVD
operator|>
literal|0
end_if

begin_comment
comment|/*  * Versabus VDDC/SMDE driver.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vdreg.h"
end_include

begin_define
define|#
directive|define
name|COMPAT_42
end_define

begin_define
define|#
directive|define
name|VDMAXIO
value|(MAXBPTE*NBPG)
end_define

begin_define
define|#
directive|define
name|vdunit
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 3)
end_define

begin_define
define|#
directive|define
name|vdpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x07)
end_define

begin_define
define|#
directive|define
name|vdminor
parameter_list|(
name|unit
parameter_list|,
name|part
parameter_list|)
value|(((unit)<< 3) | (part))
end_define

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vdminfo
index|[
name|NVD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vddinfo
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vdprobe
argument_list|()
decl_stmt|,
name|vdslave
argument_list|()
decl_stmt|,
name|vdattach
argument_list|()
decl_stmt|,
name|vddgo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|vdaddr
index|[]
init|=
block|{
literal|0xffff2000
block|,
literal|0xffff2100
block|,
literal|0xffff2200
block|,
literal|0xffff2300
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|vddriver
init|=
block|{
name|vdprobe
block|,
name|vdslave
block|,
name|vdattach
block|,
name|vddgo
block|,
name|vdaddr
block|,
literal|"dk"
block|,
name|vddinfo
block|,
literal|"vd"
block|,
name|vdminfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-controller state.  */
end_comment

begin_struct
struct|struct
name|vdsoftc
block|{
name|u_short
name|vd_flags
decl_stmt|;
define|#
directive|define
name|VD_INIT
value|0x1
comment|/* controller initialized */
define|#
directive|define
name|VD_STARTED
value|0x2
comment|/* start command issued */
define|#
directive|define
name|VD_DOSEEKS
value|0x4
comment|/* should overlap seeks */
name|u_short
name|vd_type
decl_stmt|;
comment|/* controller type */
name|u_short
name|vd_wticks
decl_stmt|;
comment|/* timeout */
name|u_short
name|vd_offcyl
decl_stmt|;
comment|/* off cylinder bitmask */
name|struct
name|mdcb
name|vd_mdcb
decl_stmt|;
comment|/* master command block */
name|u_long
name|vd_mdcbphys
decl_stmt|;
comment|/* physical address of vd_mdcb */
name|struct
name|dcb
name|vd_dcb
decl_stmt|;
comment|/* i/o command block */
name|u_long
name|vd_dcbphys
decl_stmt|;
comment|/* physical address of vd_dcb */
name|struct
name|pte
modifier|*
name|vd_map
decl_stmt|;
comment|/* i/o page map */
name|caddr_t
name|vd_utl
decl_stmt|;
comment|/* mapped i/o space */
name|caddr_t
name|vd_rawbuf
decl_stmt|;
comment|/* buffer for raw+swap i/o */
block|}
name|vdsoftc
index|[
name|NVD
index|]
struct|;
end_struct

begin_comment
comment|/*  * Per-drive state.  */
end_comment

begin_struct
struct|struct
name|dksoftc
block|{
name|u_short
name|dk_state
decl_stmt|;
comment|/* open fsm */
name|u_short
name|dk_openpart
decl_stmt|;
comment|/* units open on this drive */
name|u_short
name|dk_curdaddr
decl_stmt|;
comment|/* last selected track& sector */
name|u_int
name|dk_curcyl
decl_stmt|;
comment|/* last selected cylinder */
name|struct
name|dcb
name|dk_dcb
decl_stmt|;
comment|/* seek command block */
name|u_long
name|dk_dcbphys
decl_stmt|;
comment|/* physical address of dk_dcb */
block|}
name|dksoftc
index|[
name|NDK
index|]
struct|;
end_struct

begin_comment
comment|/*  * Drive states.  Used during steps of open/initialization.  * States< OPEN (> 0) are transient, during an open operation.  * OPENRAW is used for unabeled disks, to allow format operations.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|WANTOPENRAW
value|2
end_define

begin_comment
comment|/* open requested, no label */
end_comment

begin_define
define|#
directive|define
name|RDLABEL
value|3
end_define

begin_comment
comment|/* reading pack label */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|4
end_define

begin_comment
comment|/* intialized and ready */
end_comment

begin_define
define|#
directive|define
name|OPENRAW
value|5
end_define

begin_comment
comment|/* open, no label */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rdkbuf
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw i/o buffer headers */
end_comment

begin_decl_stmt
name|struct
name|buf
name|dkutab
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o queue headers */
end_comment

begin_decl_stmt
name|struct
name|disklabel
name|dklabel
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pack labels */
end_comment

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|b_daddr
value|b_error
end_define

begin_decl_stmt
name|int
name|vdwstart
decl_stmt|,
name|vdwatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * See if the controller is really there; if so, initialize it.  */
end_comment

begin_macro
name|vdprobe
argument_list|(
argument|reg
argument_list|,
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|br
operator|,
name|cvec
expr_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|reg
decl_stmt|;
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vdintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|reg
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|vdaddr
operator|->
name|vdreset
operator|=
literal|0xffffffff
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdaddr
operator|->
name|vdreset
operator|!=
operator|(
name|unsigned
operator|)
literal|0xffffffff
condition|)
block|{
name|vd
operator|->
name|vd_type
operator|=
name|VDTYPE_VDDC
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator|&=
operator|~
name|VD_DOSEEKS
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vd
operator|->
name|vd_type
operator|=
name|VDTYPE_SMDE
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VD_DOSEEKS
expr_stmt|;
name|vdaddr
operator|->
name|vdrstclr
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|3000000
argument_list|)
expr_stmt|;
name|vdaddr
operator|->
name|vdcsr
operator|=
literal|0
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_mdcb
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_dcb
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_trail
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_data
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdccf
operator|=
name|CCF_SEN
operator||
name|CCF_DER
operator||
name|CCF_STS
operator||
name|XMD_32BIT
operator||
name|BSZ_16WRD
operator||
name|CCF_ENP
operator||
name|CCF_EPE
operator||
name|CCF_EDE
operator||
name|CCF_ECE
operator||
name|CCF_ERR
expr_stmt|;
block|}
name|vd
operator|->
name|vd_mdcbphys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|vd
operator|->
name|vd_mdcb
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcbphys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
name|vm
operator|->
name|um_addr
operator|=
name|reg
expr_stmt|;
comment|/* XXX */
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_INIT
argument_list|,
literal|10
argument_list|)
operator|||
operator|!
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_DIAG
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: %s cmd failed\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|,
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|==
name|VDOP_INIT
condition|?
literal|"init"
else|:
literal|"diag"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate page tables and i/o buffer. 	 */
name|vbmapalloc
argument_list|(
name|btoc
argument_list|(
name|VDMAXIO
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|vd
operator|->
name|vd_map
argument_list|,
operator|&
name|vd
operator|->
name|vd_utl
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_rawbuf
operator|=
name|calloc
argument_list|(
name|VDMAXIO
argument_list|)
expr_stmt|;
name|br
operator|=
literal|0x17
operator|,
name|cvec
operator|=
literal|0xe0
operator|+
name|vm
operator|->
name|um_ctlr
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vddevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * See if a drive is really there.  *  * Can't read pack label here as various data structures  * aren't setup for doing a read in a straightforward  * manner.  Instead just probe for the drive and leave  * the pack label stuff to the attach routine.  */
end_comment

begin_expr_stmt
name|vdslave
argument_list|(
name|vi
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|vddevice
modifier|*
name|vdaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: %s controller\n"
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_VDDC
condition|?
literal|"VDDC"
else|:
literal|"SMDE"
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VD_INIT
expr_stmt|;
block|}
comment|/* 	 * Initialize label enough to do a reset on 	 * the drive.  The remainder of the default 	 * label values will be filled in in vdinit 	 * at attach time. 	 */
name|lp
operator|->
name|d_secsize
operator|=
name|DEV_BSIZE
operator|/
literal|2
expr_stmt|;
comment|/* XXX */
name|lp
operator|->
name|d_nsectors
operator|=
literal|32
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
literal|24
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
literal|711
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
literal|32
operator|*
literal|24
expr_stmt|;
return|return
operator|(
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read pack label.  */
end_comment

begin_expr_stmt
name|vdattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vi
operator|->
name|ui_unit
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
init|=
operator|&
name|dksoftc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
comment|/* 	 * Try to initialize device and read pack label. 	 */
if|if
condition|(
name|vdinit
argument_list|(
name|vdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|": unknown drive type"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Initialize invariant portion of 	 * dcb used for overlapped seeks. 	 */
name|dk
operator|->
name|dk_dcb
operator|.
name|opcode
operator|=
name|VDOP_SEEK
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
operator||
name|DCBINT_PBA
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|devselect
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
name|trseek
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
name|dk
operator|->
name|dk_dcbphys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|dk
operator|->
name|dk_dcb
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|printf
argument_list|(
literal|": %s<ntrak %d, ncyl %d, nsec %d>"
argument_list|,
name|lp
operator|->
name|d_typename
argument_list|,
name|lp
operator|->
name|d_ntracks
argument_list|,
name|lp
operator|->
name|d_ncylinders
argument_list|,
name|lp
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
comment|/* 	 * (60 / rpm) / (sectors per track * (bytes per sector / 2)) 	 */
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_mspw
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|=
literal|120.0
operator|/
operator|(
name|lp
operator|->
name|d_rpm
operator|*
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_secsize
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|addswap
argument_list|(
name|makedev
argument_list|(
name|VDMAJOR
argument_list|,
name|vdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit
operator|=
name|vdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|part
init|=
name|vdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|daddr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
operator|||
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
while|while
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|CLOSED
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
condition|)
if|if
condition|(
name|error
operator|=
name|vdinit
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vdwstart
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|vdwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|vdwstart
operator|++
expr_stmt|;
block|}
comment|/* 	 * Warn if a partion is opened 	 * that overlaps another partition which is open 	 * unless one is the "raw" partition (whole disk). 	 */
define|#
directive|define
name|RAWPART
value|2
comment|/* 'c' partition */
comment|/* XXX */
if|if
condition|(
operator|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
name|part
operator|)
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|RAWPART
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|lp
operator|->
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|lp
operator|->
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|==
name|RAWPART
condition|)
continue|continue;
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dk%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|lp
operator|->
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dk
operator|->
name|dk_openpart
operator||=
literal|1
operator|<<
name|part
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
init|=
operator|&
name|dksoftc
index|[
name|unit
index|]
decl_stmt|;
name|dk
operator|->
name|dk_openpart
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vdpart
argument_list|(
name|dev
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Should wait for i/o to complete on this partition 	 * even if others are open, but wait for work on blkflush(). 	 */
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|==
literal|0
condition|)
block|{
name|int
name|s
init|=
name|spl7
argument_list|()
decl_stmt|;
while|while
condition|(
name|dkutab
index|[
name|unit
index|]
operator|.
name|b_actf
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|vdinit
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|cold
decl_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
block|{
name|dk
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Initialize portion of the label 	 * not set up in the slave routine. 	 */
name|dk
operator|->
name|dk_state
operator|=
name|RDLABEL
expr_stmt|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|->
name|d_secperunit
operator|=
literal|0x1fffffff
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
literal|0x1fffffff
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|geteblk
argument_list|(
name|DEV_BSIZE
argument_list|)
expr_stmt|;
comment|/* max sector size */
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|LABELSECTOR
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|DEV_BSIZE
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
name|LABELSECTOR
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|vdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|error
operator|=
name|u
operator|.
name|u_error
expr_stmt|;
comment|/* XXX */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
expr_stmt|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|LABELOFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|dlp
operator|->
name|d_magic
operator|==
name|DISKMAGIC
operator|&&
name|dlp
operator|->
name|d_magic2
operator|==
name|DISKMAGIC
operator|&&
name|dkcksum
argument_list|(
name|dlp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|lp
operator|=
operator|*
name|dlp
expr_stmt|;
comment|/* 		 * Now that we have the label, configure 		 * the correct drive parameters. 		 */
if|if
condition|(
operator|!
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
else|else
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cold
condition|)
name|printf
argument_list|(
literal|": no disk label"
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk%d: no disk label\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_42
if|if
condition|(
operator|!
name|vdmaptype
argument_list|(
name|vi
argument_list|,
name|lp
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
block|}
else|else
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
else|#
directive|else
name|dk
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
endif|#
directive|endif
block|}
name|done
label|:
if|if
condition|(
name|bp
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vddgo
argument_list|(
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_expr_stmt
name|vdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|daddr_t
name|sn
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|daddr_t
name|sz
decl_stmt|,
name|maxsz
decl_stmt|;
name|int
name|part
decl_stmt|,
name|s
decl_stmt|;
name|sz
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|sz
operator|=
operator|(
name|sz
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
name|unit
operator|=
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>
name|NDK
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
goto|goto
name|q
goto|;
name|part
operator|=
name|vdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
name|part
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|maxsz
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|sn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|sn
operator|<
literal|0
operator|||
name|sn
operator|+
name|sz
operator|>
name|maxsz
condition|)
block|{
if|if
condition|(
name|sn
operator|==
name|maxsz
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sz
operator|=
name|maxsz
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|sz
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|)
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|q
label|:
name|vbasetup
argument_list|(
name|bp
argument_list|,
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|dp
operator|=
operator|&
name|dkutab
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|b_active
condition|)
block|{
operator|(
name|void
operator|)
name|vdustart
argument_list|(
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|ui_mi
operator|->
name|um_tab
operator|.
name|b_active
condition|)
name|vdstart
argument_list|(
name|vi
operator|->
name|ui_mi
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|vdustart
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|vi
operator|->
name|ui_unit
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|dp
operator|=
operator|&
name|dkutab
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * If queue empty, nothing to do. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If drive is off-cylinder, mark unit to force 	 * overlap seek with next transfer on this controller. 	 */
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|dk
operator|->
name|dk_curcyl
operator|&&
name|vd
operator|->
name|vd_flags
operator|&
name|VD_DOSEEKS
condition|)
block|{
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_daddr
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|%
name|lp
operator|->
name|d_secpercyl
operator|)
operator|/
name|lp
operator|->
name|d_nsectors
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_daddr
operator|!=
name|dk
operator|->
name|dk_curdaddr
condition|)
name|vd
operator|->
name|vd_offcyl
operator||=
literal|1
operator|<<
name|vi
operator|->
name|ui_slave
expr_stmt|;
block|}
comment|/* 	 * If controller is not busy, place request on the 	 * controller's ready queue). 	 */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
name|vm
operator|=
name|vi
operator|->
name|ui_mi
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start next transfer on a controller.  */
end_comment

begin_expr_stmt
name|vdstart
argument_list|(
name|vm
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|;
specifier|register
name|struct
name|dcb
modifier|*
modifier|*
name|dcbp
decl_stmt|;
name|struct
name|mdcb
modifier|*
name|mdcb
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|sn
decl_stmt|,
name|tn
decl_stmt|;
name|loop
label|:
comment|/* 	 * Pull a request off the controller queue. 	 */
if|if
condition|(
operator|(
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * Mark controller busy, and determine 	 * destination of this request. 	 */
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|vi
operator|=
name|vddinfo
index|[
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|sn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|tn
operator|=
name|sn
operator|/
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
comment|/* 	 * Construct dcb for read/write command. 	 */
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|slave
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|VDOP_RD
else|:
name|VDOP_WD
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_DONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|slave
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
operator|(
name|char
operator|*
operator|)
name|vbastart
argument_list|(
name|bp
argument_list|,
name|vd
operator|->
name|vd_rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|vd
operator|->
name|vd_map
argument_list|,
name|vd
operator|->
name|vd_utl
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|tn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|sn
expr_stmt|;
comment|/* 	 * Look for any seeks to be performed on other drives on this 	 * controller.  If overlapped seeks exist, insert seek commands 	 * on the controller's command queue before the transfer. 	 */
name|dcbp
operator|=
operator|&
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_offcyl
operator|&
operator|~
operator|(
literal|1
operator|<<
name|slave
operator|)
condition|)
block|{
specifier|register
name|struct
name|dksoftc
modifier|*
name|tdk
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|dp
operator|->
name|b_forw
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|b_forw
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|slave
operator|=
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|vdunit
argument_list|(
name|tp
operator|->
name|b_dev
argument_list|)
index|]
operator|)
operator|->
name|ui_slave
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_offcyl
operator|&
operator|(
literal|1
operator|<<
name|slave
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|vd
operator|->
name|vd_offcyl
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slave
operator|)
expr_stmt|;
name|tdk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|tdk
operator|->
name|dk_curcyl
operator|!=
name|tp
operator|->
name|b_cylin
condition|)
block|{
name|tdk
operator|->
name|dk_curcyl
operator|=
name|tp
operator|->
name|b_cylin
expr_stmt|;
name|dk_seek
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
block|}
name|tdk
operator|->
name|dk_curdaddr
operator|=
name|tp
operator|->
name|b_daddr
expr_stmt|;
name|tdk
operator|->
name|dk_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|tdk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|cylinder
operator|=
name|tp
operator|->
name|b_cylin
expr_stmt|;
name|tdk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|track
operator|=
name|tp
operator|->
name|b_daddr
operator|>>
literal|8
expr_stmt|;
name|tdk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|sector
operator|=
name|tp
operator|->
name|b_daddr
operator|&
literal|0xff
expr_stmt|;
operator|*
name|dcbp
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|tdk
operator|->
name|dk_dcbphys
expr_stmt|;
name|dcbp
operator|=
operator|&
name|tdk
operator|->
name|dk_dcb
operator|.
name|nxtdcb
expr_stmt|;
block|}
block|}
else|else
block|{
name|dk
operator|->
name|dk_curcyl
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|dk
operator|->
name|dk_curdaddr
operator|=
operator|(
name|tn
operator|<<
literal|8
operator|)
operator||
name|sn
expr_stmt|;
name|vd
operator|->
name|vd_offcyl
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|dcbp
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
comment|/* 	 * Initiate operation. 	 */
name|bp
operator|->
name|b_daddr
operator|=
literal|0
expr_stmt|;
comment|/* init overloaded field */
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|vi
operator|->
name|ui_dk
expr_stmt|;
name|dk_xfer
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|DONTCARE
value|(DCBS_DSE|DCBS_DSL|DCBS_TOP|DCBS_TOM|DCBS_FAIL|DCBS_DONE)
end_define

begin_comment
comment|/*  * Handle a disk interrupt.  */
end_comment

begin_expr_stmt
name|vdintr
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|status
expr_stmt|;
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|vd
operator|->
name|vd_wticks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|vm
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: stray interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get device and block structures, and a pointer 	 * to the vba_device for the drive. 	 */
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|vi
operator|=
name|vddinfo
index|[
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vi
operator|->
name|ui_dk
operator|)
expr_stmt|;
comment|/* 	 * Check for and process errors on 	 * either the drive or the controller. 	 */
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|)
expr_stmt|;
name|status
operator|=
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|VDERR_HARD
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|DCBS_WPT
condition|)
block|{
comment|/* 			 * Give up on write locked devices immediately. 			 */
name|printf
argument_list|(
literal|"dk%d: write locked\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|VDERR_RETRY
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|VDERR_DRIVE
condition|)
block|{
if|if
condition|(
operator|!
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
condition|)
name|vi
operator|->
name|ui_alive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|VDERR_CTLR
condition|)
name|vdreset_ctlr
argument_list|(
name|vm
argument_list|)
expr_stmt|;
comment|/* 			 * Retry transfer once, unless reset failed. 			 */
if|if
condition|(
operator|!
name|vi
operator|->
name|ui_alive
operator|||
name|bp
operator|->
name|b_errcnt
operator|++
operator|>=
literal|2
condition|)
goto|goto
name|hard
goto|;
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* force retry */
block|}
else|else
block|{
name|hard
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* NEED TO ADJUST b_blkno to failed sector */
name|harderr
argument_list|(
name|bp
argument_list|,
literal|"dk"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status %x (%b)"
argument_list|,
name|status
argument_list|,
name|status
operator|&
operator|~
name|DONTCARE
argument_list|,
name|VDERRBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ecode %x"
argument_list|,
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|DCBS_SOFT
condition|)
name|vdsofterr
argument_list|(
name|vd
argument_list|,
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|vbadone
argument_list|(
name|bp
argument_list|,
name|vd
operator|->
name|vd_rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|vd
operator|->
name|vd_map
argument_list|,
name|vd
operator|->
name|vd_utl
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If this unit has more work to do, 		 * then start it up right away. 		 */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|vdustart
argument_list|(
name|vi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|)
operator|->
name|dk_openpart
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are devices ready to 	 * transfer, start the controller. 	 */
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
condition|)
name|vdstart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vdsofterr
argument_list|(
argument|vd
argument_list|,
argument|bp
argument_list|,
argument|dcb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dcb
modifier|*
name|dcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|,
name|status
init|=
name|dcb
operator|->
name|operrsta
decl_stmt|;
name|char
name|part
init|=
literal|'a'
operator|+
name|vdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
operator|(
name|DCBS_DCE
operator||
name|DCBS_CCD
operator||
name|DCBS_SOFT
operator||
name|DCBS_ERR
operator|)
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dk%d%c: soft error sn%d status %b ecode %x\n"
argument_list|,
name|unit
argument_list|,
name|part
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|status
argument_list|,
name|VDERRBITS
argument_list|,
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dk%d%c: soft ecc sn%d\n"
argument_list|,
name|unit
argument_list|,
name|part
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|vdstrategy
argument_list|,
operator|&
name|rdkbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|vdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|vdstrategy
argument_list|,
operator|&
name|rdkbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|vdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|unit
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
operator|*
name|lp
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|part
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
operator|*
name|lp
operator|=
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
operator|*
name|lp
operator|=
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
expr_stmt|;
name|bp
operator|=
name|geteblk
argument_list|(
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|LABELSECTOR
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_READ
expr_stmt|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|LABELOFFSET
operator|)
expr_stmt|;
name|vdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|error
operator|=
name|u
operator|.
name|u_error
expr_stmt|;
comment|/* XXX */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|dlp
operator|=
operator|*
name|lp
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_WRITE
expr_stmt|;
name|vdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|error
operator|=
name|u
operator|.
name|u_error
expr_stmt|;
comment|/* XXX */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
block|}
name|bad
label|:
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Watch for lost interrupts.  */
end_comment

begin_macro
name|vdwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
name|timeout
argument_list|(
name|vdwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NVD
condition|;
name|ctlr
operator|++
control|)
block|{
name|vm
operator|=
name|vdminfo
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
name|vm
operator|==
literal|0
operator|||
name|vm
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vm
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NDK
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|dkutab
index|[
name|unit
index|]
operator|.
name|b_active
operator|&&
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_mi
operator|==
name|vm
condition|)
goto|goto
name|active
goto|;
name|vd
operator|->
name|vd_wticks
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|active
label|:
name|vd
operator|->
name|vd_wticks
operator|++
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_wticks
operator|>=
literal|20
condition|)
block|{
name|vd
operator|->
name|vd_wticks
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"vd%d: lost interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
comment|/* abort pending dcb's and restart controller */
block|}
block|}
block|}
end_block

begin_define
define|#
directive|define
name|DBSIZE
value|64
end_define

begin_comment
comment|/* controller limit with 1K sectors */
end_comment

begin_comment
comment|/*  * Crash dump.  */
end_comment

begin_macro
name|vddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|int
name|part
decl_stmt|,
name|unit
decl_stmt|,
name|num
decl_stmt|;
name|caddr_t
name|start
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|vdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>
name|NDK
operator|||
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|part
operator|=
name|vdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|>=
name|lp
operator|->
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vm
operator|=
name|vdminfo
index|[
name|vi
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|vdreset_ctlr
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumplo
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Dumplo and maxfree are in pages. 	 */
name|num
operator|=
name|maxfree
operator|*
operator|(
name|NBPG
operator|/
name|lp
operator|->
name|d_secsize
operator|)
expr_stmt|;
name|dumplo
operator|*=
name|NBPG
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
if|if
condition|(
name|dumplo
operator|+
name|num
operator|>=
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
condition|)
name|num
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|-
name|dumplo
expr_stmt|;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|VDOP_WD
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|int
name|nsec
decl_stmt|,
name|cn
decl_stmt|,
name|sn
decl_stmt|,
name|tn
decl_stmt|;
name|nsec
operator|=
name|MIN
argument_list|(
name|num
argument_list|,
name|DBSIZE
argument_list|)
expr_stmt|;
name|sn
operator|=
name|dumplo
operator|+
operator|(
name|unsigned
operator|)
name|start
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|cn
operator|=
operator|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_offset
operator|)
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|tn
operator|=
name|sn
operator|/
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
name|start
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
operator|(
name|nsec
operator|*
name|lp
operator|->
name|d_secsize
operator|)
operator|>>
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|cn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|tn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|sn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during dump\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
condition|)
block|{
name|printf
argument_list|(
literal|"dk%d: hard error, status=%b\n"
argument_list|,
name|unit
argument_list|,
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|,
name|VDERRBITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|start
operator|+=
name|nsec
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|num
operator|-=
name|nsec
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vdsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
operator|||
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
operator|||
operator|(
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
operator|)
operator|->
name|dk_state
operator|!=
name|OPEN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a controller reset.  */
end_comment

begin_expr_stmt
name|vdreset_ctlr
argument_list|(
name|vm
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|VDRESET
argument_list|(
name|vdaddr
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|vdaddr
operator|->
name|vdcsr
operator|=
literal|0
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_mdcb
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_dcb
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_trail
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_data
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdccf
operator|=
name|CCF_STS
operator||
name|XMD_32BIT
operator||
name|BSZ_16WRD
operator||
name|CCF_ENP
operator||
name|CCF_EPE
operator||
name|CCF_EDE
operator||
name|CCF_ECE
operator||
name|CCF_ERR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_INIT
argument_list|,
literal|10
argument_list|)
operator|||
operator|!
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_DIAG
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s cmd failed\n"
argument_list|,
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|==
name|VDOP_INIT
condition|?
literal|"init"
else|:
literal|"diag"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NDK
condition|;
name|unit
operator|++
control|)
if|if
condition|(
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|->
name|ui_mi
operator|==
name|vm
operator|&&
name|vi
operator|->
name|ui_alive
condition|)
operator|(
name|void
operator|)
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|top
label|:
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|VDOP_CONFIG
expr_stmt|;
comment|/* command */
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|ncyl
operator|=
name|lp
operator|->
name|d_ncylinders
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|nsurfaces
operator|=
name|lp
operator|->
name|d_ntracks
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
name|treset
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|nsectors
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|slip_sec
operator|=
name|lp
operator|->
name|d_trackskew
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|recovery
operator|=
literal|0x18f
expr_stmt|;
block|}
else|else
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
literal|2
expr_stmt|;
comment|/* XXX */
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vdaddr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
operator|&&
operator|(
name|vdaddr
operator|->
name|vdstatus
index|[
name|vi
operator|->
name|ui_slave
index|]
operator|&
name|STA_US
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
operator|(
name|DCBS_OCYL
operator||
name|DCBS_NRDY
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"dk%d: config error\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_STARTED
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|started
decl_stmt|;
name|printf
argument_list|(
literal|"vd%d: starting drives, wait ... "
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VD_STARTED
expr_stmt|;
name|started
operator|=
operator|(
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_START
argument_list|,
literal|10
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|62000000
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|started
condition|)
goto|goto
name|top
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a command w/o trailer.  */
end_comment

begin_expr_stmt
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|cmd
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|cmd
expr_stmt|;
comment|/* command */
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during init\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Poll controller until operation  * completes or timeout expires.  */
end_comment

begin_expr_stmt
name|vdpoll
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
name|t
operator|*=
literal|1000
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
operator|(
name|DCBS_DONE
operator||
name|DCBS_ABORT
operator|)
condition|)
break|break;
if|if
condition|(
operator|--
name|t
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: controller timeout"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|VDABORT
argument_list|(
name|vdaddr
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
do|do
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vdaddr
operator|->
name|vdcsr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|vdaddr
operator|->
name|vdcsr
operator|&
name|CS_GO
condition|)
do|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_42
end_ifdef

begin_struct
struct|struct
name|vdst
block|{
name|int
name|nsec
decl_stmt|;
comment|/* sectors/track */
name|int
name|ntrack
decl_stmt|;
comment|/* tracks/cylinder */
name|int
name|ncyl
decl_stmt|;
comment|/* cylinders */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* type name */
struct|struct
block|{
name|int
name|off
decl_stmt|;
comment|/* partition offset in sectors */
name|int
name|size
decl_stmt|;
comment|/* partition size in sectors */
block|}
name|parts
index|[
literal|8
index|]
struct|;
block|}
name|vdst
index|[]
init|=
block|{
block|{
literal|48
block|,
literal|24
block|,
literal|711
block|,
literal|"xsd"
block|,
block|{
literal|0
block|,
literal|30528
block|}
block|,
comment|/* a cyl   0 - 52 */
block|{
literal|30528
block|,
literal|30528
block|}
block|,
comment|/* b cyl  53 - 105 */
block|{
literal|61056
block|,
literal|345600
block|}
block|,
comment|/* c cyl 106 - 705 */
block|{
literal|118656
block|,
literal|288000
block|}
block|,
comment|/* d cyl 206 - 705 */
block|{
literal|176256
block|,
literal|230400
block|}
block|,
comment|/* e cyl 306 - 705 */
block|{
literal|233856
block|,
literal|172800
block|}
block|,
comment|/* f cyl 406 - 705 */
block|{
literal|291456
block|,
literal|115200
block|}
block|,
comment|/* g cyl 506 - 705 */
block|{
literal|349056
block|,
literal|57600
block|}
comment|/* h cyl 606 - 705 */
block|}
block|,
block|{
literal|44
block|,
literal|20
block|,
literal|842
block|,
literal|"egl"
block|,
block|{
literal|0
block|,
literal|26400
block|}
block|,
comment|/* egl0a cyl   0 - 59 */
block|{
literal|26400
block|,
literal|33000
block|}
block|,
comment|/* egl0b cyl  60 - 134 */
block|{
literal|59400
block|,
literal|308880
block|}
block|,
comment|/* egl0c cyl 135 - 836 */
block|{
literal|368280
block|,
literal|2640
block|}
block|,
comment|/* egl0d cyl 837 - 842 */
block|{
literal|0
block|,
literal|368280
block|}
block|,
comment|/* egl0e cyl 0 - 836 */
block|{
literal|0
block|,
literal|370920
block|}
block|,
comment|/* egl0f cyl 0 - 842 */
block|{
literal|59400
block|,
literal|155320
block|}
block|,
comment|/* egl0g cyl 135 - 487 */
block|{
literal|214720
block|,
literal|153560
block|}
comment|/* egl0h cyl 488 - 836 */
block|}
block|,
block|{
literal|64
block|,
literal|10
block|,
literal|823
block|,
literal|"fuj"
block|,
block|{
literal|0
block|,
literal|19200
block|}
block|,
comment|/* fuj0a cyl   0 - 59 */
block|{
literal|19200
block|,
literal|24000
block|}
block|,
comment|/* fuj0b cyl  60 - 134 */
block|{
literal|43200
block|,
literal|218560
block|}
block|,
comment|/* fuj0c cyl 135 - 817 */
block|{
literal|79680
block|,
literal|182080
block|}
block|,
comment|/* fuj0d cyl 249 - 817 */
block|{
literal|116160
block|,
literal|145600
block|}
block|,
comment|/* fuj0e cyl 363 - 817 */
block|{
literal|152640
block|,
literal|109120
block|}
block|,
comment|/* fuj0f cyl 477 - 817 */
block|{
literal|189120
block|,
literal|72640
block|}
block|,
comment|/* fuj0g cyl 591 - 817 */
block|{
literal|225600
block|,
literal|36160
block|}
comment|/* fug0h cyl 705 - 817 */
block|}
block|,
block|{
literal|32
block|,
literal|24
block|,
literal|711
block|,
literal|"xfd"
block|,
block|{
literal|0
block|,
literal|20352
block|}
block|,
comment|/* a cyl   0 - 52 */
block|{
literal|20352
block|,
literal|20352
block|}
block|,
comment|/* b cyl  53 - 105 */
block|{
literal|40704
block|,
literal|230400
block|}
block|,
comment|/* c cyl 106 - 705 */
block|{
literal|0
block|,
literal|40704
block|}
block|,
comment|/* d cyl 709 - 710 (a& b) */
block|{
literal|0
block|,
literal|271104
block|}
block|,
comment|/* e cyl   0 - 705 */
block|{
literal|20352
block|,
literal|250752
block|}
block|,
comment|/* f cyl  53 - 705 (b& c) */
block|{
literal|40704
block|,
literal|115200
block|}
block|,
comment|/* g cyl 106 - 405 (1/2 of c) */
block|{
literal|155904
block|,
literal|115200
block|}
comment|/* h cyl 406 - 705 (1/2 of c) */
block|}
block|,
block|{
literal|32
block|,
literal|19
block|,
literal|823
block|,
literal|"smd"
block|,
block|{
literal|0
block|,
literal|20064
block|}
block|,
comment|/* a cyl   0-65 */
block|{
literal|20064
block|,
literal|13680
block|}
block|,
comment|/* b cyl  66-110 */
block|{
literal|33744
block|,
literal|214928
block|}
block|,
comment|/* c cyl 111-817 */
block|{
literal|69616
block|,
literal|179056
block|}
block|,
comment|/* d cyl 229 - 817 */
block|{
literal|105488
block|,
literal|143184
block|}
block|,
comment|/* e cyl 347 - 817 */
block|{
literal|141360
block|,
literal|107312
block|}
block|,
comment|/* f cyl 465 - 817 */
block|{
literal|177232
block|,
literal|71440
block|}
block|,
comment|/* g cyl 583 - 817 */
block|{
literal|213104
block|,
literal|35568
block|}
comment|/* h cyl 701 - 817 */
block|}
block|,
block|{
literal|32
block|,
literal|10
block|,
literal|823
block|,
literal|"fsd"
block|,
block|{
literal|0
block|,
literal|9600
block|}
block|,
comment|/* a cyl   0 -  59 */
block|{
literal|9600
block|,
literal|12000
block|}
block|,
comment|/* b cyl  60 - 134 */
block|{
literal|21600
block|,
literal|109280
block|}
block|,
comment|/* c cyl 135 - 817 */
block|{
literal|39840
block|,
literal|91040
block|}
block|,
comment|/* d cyl 249 - 817 */
block|{
literal|58080
block|,
literal|72800
block|}
block|,
comment|/* e cyl 363 - 817 */
block|{
literal|76320
block|,
literal|54560
block|}
block|,
comment|/* f cyl 477 - 817 */
block|{
literal|94560
block|,
literal|36320
block|}
block|,
comment|/* g cyl 591 - 817 */
block|{
literal|112800
block|,
literal|18080
block|}
comment|/* h cyl 705 - 817 */
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NVDST
value|(sizeof (vdst) / sizeof (vdst[0]))
end_define

begin_comment
comment|/*  * Construct a label for an unlabeled pack.  We  * deduce the drive type by reading from the last  * track on successively smaller drives until we  * don't get an error.  */
end_comment

begin_expr_stmt
name|vdmaptype
argument_list|(
name|vi
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
specifier|register
name|struct
name|vdst
modifier|*
name|p
decl_stmt|;
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vdst
init|;
name|p
operator|<
operator|&
name|vdst
index|[
name|NVDST
index|]
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_VDDC
operator|&&
name|p
operator|->
name|nsec
operator|!=
literal|32
condition|)
continue|continue;
name|lp
operator|->
name|d_nsectors
operator|=
name|p
operator|->
name|nsec
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|p
operator|->
name|ntrack
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|p
operator|->
name|ncyl
expr_stmt|;
if|if
condition|(
operator|!
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|VDOP_RD
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
operator|(
name|char
operator|*
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|vd
operator|->
name|vd_rawbuf
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
literal|512
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|p
operator|->
name|ncyl
operator|-
literal|2
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|p
operator|->
name|ntrack
operator|-
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|p
operator|->
name|nsec
operator|-
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
literal|60
argument_list|)
condition|)
name|printf
argument_list|(
literal|" during probe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|>=
operator|&
name|vdst
index|[
name|NVDST
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"dk%d: unknown drive type\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_offset
operator|=
name|p
operator|->
name|parts
index|[
name|i
index|]
operator|.
name|off
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
name|p
operator|->
name|parts
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
name|lp
operator|->
name|d_npartitions
operator|=
literal|8
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_ntracks
expr_stmt|;
name|lp
operator|->
name|d_rpm
operator|=
literal|3600
expr_stmt|;
name|lp
operator|->
name|d_secsize
operator|=
literal|512
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|lp
operator|->
name|d_typename
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|COMPAT_42
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

