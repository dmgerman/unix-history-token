begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Log:	rdp_states.c,v $  * Revision 2.14  85/06/18  14:38:50  walsh  * eliminated inpcb flags.  *   * Revision 2.13  85/05/31  14:39:06  walsh  * copy sequential delivery desires when fork off a new socket.  *   * Revision 2.12  84/12/03  09:42:20  walsh  * Keep no route messages from flooding console.  *   * Revision 2.11  84/11/29  13:06:17  walsh  * Have the NULL message retransmission back off so that don't load  * a jammed network and so that don't wake user up so often when  * some intermediary hop has gone down on a (normally) fast connection.  *   * Revision 2.10  84/11/15  09:56:14  walsh  * redid how we deal with compiler padding in the RDP header structure.  *   * Revision 2.9  84/11/08  16:12:06  walsh  * Added code to gather statistics on RDP traffic.  This makes the RDPCB  * too big unles you make mbufs 512 bytes large.  RDP_CS should be turned off  * unless you do.  *   * Revision 2.8  84/11/06  15:24:54  walsh  * *** empty log message ***  *   * Revision 2.7  84/11/05  15:54:34  walsh  * update_nulltimer() macro began to look inappropriate with recent  * changes, so its been stripped out and put in-line.  *   * Revision 2.6  84/11/05  12:42:34  walsh  * Set things up so can debug RDP connections just like can debug TCP  * connections.  *   * Revision 2.5  84/11/05  11:34:36  walsh  * Don't let round trip time estimate drift upward on lossy networks.  * Check for retransmissions of packets used to measure round trip time.  *   * Revision 2.4  84/11/05  10:47:38  walsh  * More changes to go with NULL messages getting their own sequence  * number.  *   * Revision 2.3  84/11/02  18:24:20  walsh  * Protocol specifiers want NULL message to have own sequence number in  * case of slow (t>NULL msg timeout) packets.  I don't see this as a problem,  * and even if happened (dubious) would only delay discovery, but I  * didn't win this one.  Initially not designed for this, but fixes are  * in almost neatly.  *   * Revision 2.2  84/11/02  15:29:32  walsh  * Allow for RDP header fields not on natural boundries.  (Protocol  * specifiers say will be part of next version in 6-12 months).  * Until then, there goes the speed...  Yucho modifications.  *   * Revision 2.1  84/11/02  10:14:11  walsh  * Fixed to include RCS comments in checked out source.  *   *  * description:  * The state transition functions for the Reliable Datagram Protocol.  *   * revision 1.17          * date: 84/07/24 16:58:17;  author: walsh;  state: Exp;  lines added/del: 2/2  * When had gone to making retransmit took too long advisory,  * had forgotten to change RDP_sCLOSED to RDP_sSAME.  *   * revision 1.16          * date: 84/07/23 12:58:31;  author: walsh;  state: Exp;  lines added/del: 27/6  * Clear all timers when enter close state.  Updates to protocol had not  * been complete in this respect.  *   * Retransmission and acceptance in CLOSEWAIT do not seem to be in the cards  * in dealing with protocol specifiers, so removed ### markers and commented.  *   * revision 1.15          * date: 84/07/22 19:45:31;  author: walsh;  state: Exp;  lines added/del: 19/0  * Added a state transition function rdp_closew_rcv() to compensate for  * socket code's dropping of system priority level for a brief period of time.  *   * revision 1.14          * date: 84/07/19 10:21:42;  author: walsh;  state: Exp;  lines added/del: 14/85  * Organized macros and classified their definitions in rdp_macros.h.  *   * revision 1.13          * date: 84/07/19 08:54:01;  author: walsh;  state: Exp;  lines added/del: 4/0  * NULL message processing should start before receive a packet in ESTAB,  * so start up NULL timer when enter ESTAB.  *   * revision 1.12          * date: 84/07/18 18:50:55;  author: walsh;  state: Exp;  lines added/del: 36/5  * Added provision for sending of NULL messages.  These are sent on an idle  * connection to determine that the other side still exists.  *   * revision 1.11          * date: 84/07/18 13:35:36;  author: walsh;  state: Exp;  lines added/del: 6/6  * made provisions for user-adjustable RTTL time period.  *   * revision 1.10          * date: 84/07/13 09:50:33;  author: walsh;  state: Exp;  lines added/del: 22/19  * When first send datagram, we determine its length.  * Might as wellsave that length in m_act for retransmission.  *   * revision 1.9          * date: 84/07/12 13:48:22;  author: walsh;  state: Exp;  lines added/del: 1/0  * Rather than in-line stuffing of IP/RDP headers, at least half of which are  * constant, copy headers in from a template of what the headers are like.  The  * bcopy() call is turned into a movc3 instruction on the VAX by a sed script  * run over the assembler output of the C compiler.  Marginal speed-up.  *   * revision 1.8          * date: 84/07/12 09:55:02;  author: walsh;  state: Exp;  lines added/del: 5/13  * some small optimizations.  *   * revision 1.7          * date: 84/07/10 14:48:13;  author: walsh;  state: Exp;  lines added/del: 1/1  * Reduced amount of unnecessary wakeup action.  *   * revision 1.6          * date: 84/07/10 10:28:33;  author: walsh;  state: Exp;  lines added/del: 35/35  * Added register declarations.  *   * revision 1.5          * date: 84/07/09 14:31:33;  author: walsh;  state: Exp;  lines added/del: 11/2  * Added an ACK-delay algorithm to reduce cpu and network loading.  *   * revision 1.4          * date: 84/07/08 21:36:47;  author: walsh;  state: Exp;  lines added/del: 3/3  * changed some references to r_sendq.rq_baseseq to r_snduna for clarity.  *   * revision 1.3          * date: 84/07/06 15:13:50;  author: wjacobso;  state: Exp;  lines added/del: 17/17  * add register var definitions; use sndnxt-baseseq instead of maxqlen  * to determine number of passes  *   * revision 1.2          * date: 84/07/06 09:49:52;  author: root;  state: Exp;  lines added/del: 93/35  * This version seems to run bug-free.  *   * revision 1.1          * date: 84/06/26 14:18:09;  author: walsh;  state: Exp;    * Initial revision  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RDP
end_ifdef

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/seq.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp_macros.h"
end_include

begin_function_decl
specifier|extern
name|struct
name|rtentry
modifier|*
name|ip_route
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Since a message just got through, re-associating rttl (retransmit  * took too long) with some other current outstanding datagram (cf. wait  * until some new dgram) is a little paranoid, but let's be careful  * in case that new dgram doesn't come along for a while.  This also  * allows us to decide that the check-for-retransmit and  * retransmit-took-too-long timers can be cancelled.  */
end_comment

begin_expr_stmt
name|clear_rxtimer
argument_list|(
name|rdpcb
argument_list|,
name|N
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|Xi
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|rdpcb
operator|->
name|r_rxtimers
index|[
name|N
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|->
name|r_rttlindex
operator|==
name|N
condition|)
block|{
comment|/* 	 * look for new dgram of which to check rttl 	 */
name|Xi
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
expr_stmt|;
name|pass
operator|=
name|rdpcb
operator|->
name|r_sndnxt
operator|-
name|rdpcb
operator|->
name|r_snduna
expr_stmt|;
while|while
condition|(
operator|--
name|pass
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rdpcb
operator|->
name|r_rxtimers
index|[
name|Xi
index|]
condition|)
block|{
name|rdpcb
operator|->
name|r_rttlindex
operator|=
name|Xi
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tRTTL
index|]
operator|=
name|rdpcb
operator|->
name|r_rttl
expr_stmt|;
return|return;
block|}
name|Xi
operator|=
operator|(
name|Xi
operator|+
literal|1
operator|)
operator|%
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
block|}
comment|/* 	 * No outstanding dgrams left. 	 */
name|rdpcb
operator|->
name|r_rttlindex
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tRTTL
index|]
operator|=
literal|0
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tRXMIT
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * set up things to discover the rtt (round trip time) for this  * DATA-containing packet.  */
end_comment

begin_define
define|#
directive|define
name|time_rtt
parameter_list|(
name|rdpcb
parameter_list|,
name|seqnum
parameter_list|)
define|\
value|if (! (rdpcb)->r_rttiming){            \ 		(rdpcb)->r_rttiming = TRUE;    \ 		(rdpcb)->r_rtt = 0;            \ 		(rdpcb)->r_rttimed = (seqnum); \ 	}
end_define

begin_comment
comment|/*  * Since we play with sb_cc for the socket send buffer to prevent the  * user process from sending packets we can't buffer, must ensure it  * is restored to a reasonable value before call upon socket code to clean  * up or we'll get a "panic: sbdrop".  Socket code is called by  * in_pcbdetach().  */
end_comment

begin_macro
name|trash_pcbs
argument_list|(
argument|rdpcb
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockbuf
modifier|*
name|sosnd
decl_stmt|;
name|sosnd
operator|=
operator|&
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
operator|->
name|so_snd
expr_stmt|;
if|if
condition|(
operator|(
name|sosnd
operator|->
name|sb_cc
operator|==
name|sosnd
operator|->
name|sb_hiwat
operator|)
operator|&&
operator|(
name|sosnd
operator|->
name|sb_mb
operator|==
name|NULL
operator|)
condition|)
name|sosnd
operator|->
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|in_pcbdetach
argument_list|(
name|rdpcb
operator|->
name|r_inpcb
argument_list|,
name|rdp_pcbdisconnect
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cancel_timers
argument_list|(
name|rdpcb
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RDP_NTIMERS
condition|;
name|i
operator|++
control|)
name|rdpcb
operator|->
name|r_timers
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sUNOPENED  *	input: RDP_iCONNECT  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rdp_unop_connect
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*      * Send a SYN      * and set re-transmission timer to ensure SYN eventually gets there      */
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_iss
argument_list|)
expr_stmt|;
name|set_rxtimer
argument_list|(
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSYNSENT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sUNOPENED  *	input: RDP_iLISTEN  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_unop_listen
argument_list|(
argument|rdpcb
argument_list|,
argument|nil
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|RDP_sLISTEN
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sUNOPENED  *	input: RDP_iNETR  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_unop_netr
argument_list|(
argument|rdpcb
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
operator|(
name|RDP_fACK
operator||
name|RDP_fEACK
operator||
name|RDP_fNULL
operator|)
condition|)
comment|/* 	 * We haven't sent anything to (e)ack.  Nor have we 	 * established a connection and received something 	 * that we should ack (null).  The sender is very mixed 	 * up, so we'll send him a reset. 	 */
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
else|else
comment|/* 	 * ignore packet in hope user connect(2)s or listen(2)s before 	 * it's re-transmission comes in. 	 */
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sUNOPENED  *	input: RDP_iUCLOSE  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_unop_close
argument_list|(
argument|rdpcb
argument_list|,
argument|nil
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sLISTEN  *	input: RDP_iLISTEN  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_lis_listen
argument_list|(
argument|rdpcb
argument_list|,
argument|nil
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sLISTEN  *	input: RDP_iNETR  */
end_comment

begin_macro
name|rdp_lis_netr
argument_list|(
argument|rdpcb
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INPCB
modifier|*
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|RDPCB
modifier|*
name|newrdpcb
decl_stmt|;
specifier|register
name|INPCB
modifier|*
name|newinp
decl_stmt|;
name|struct
name|socket
modifier|*
name|newso
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|SYNOPTIONS
modifier|*
name|synopt
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
operator|(
name|RDP_fRST
operator||
name|RDP_fACK
operator||
name|RDP_fEACK
operator||
name|RDP_fNULL
operator|)
condition|)
block|{
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fRST
condition|)
comment|/* 	     * Ignore resets since we haven't sent anything to 	     * reset.  The packet may be a slow arrival meant to 	     * close a child socket of ours that has already 	     * finished close protocol with this sender.  We 	     * ignore it and the other end closes/closed on its own. 	     */
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* 	     * We haven't sent anything to (e)ack.  Nor have we 	     * established a connection and received something 	     * that we should ack (null).  The sender is very mixed 	     * up, so we'll send him a reset. 	     */
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fSYN
condition|)
block|{
comment|/* normal case, someone is trying to connect to us. */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|pkt
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * O.k., let's get a route back to him 	 */
if|if
condition|(
operator|!
operator|(
name|rt
operator|=
name|ip_route
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
operator|&
name|ip
operator|->
name|ip_src
argument_list|)
operator|)
condition|)
block|{
comment|/* 	     * Can't talk to him.  Leave socket in receive state 	     * so we can connect to someone else, since we haven't 	     * been committed to anything yet anyway. 	     * Drop his info on the floor. 	     * Let the other machine figure out on it's own 	     * that it can't reach us that way. 	     */
name|no_route
argument_list|(
literal|"rdp"
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
name|inp
operator|=
name|rdpcb
operator|->
name|r_inpcb
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
comment|/* 	 * This socket is in the listen state, so the socket should have 	 * so_options& SO_ACCEPTCONN set (solisten()). 	 * 	 * The order of sonewconn() and soisconnected() is 	 * important, in order for the process to be woken up 	 * at a time when the sleep condition is fulfilled. 	 * sonewconn() is done here on the original socket, and 	 * soisconnected() is done later in rdp_lsynrcvd_netr() on 	 * the new socket. 	 */
if|if
condition|(
name|newso
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|newinp
operator|=
operator|(
name|INPCB
operator|*
operator|)
name|newso
operator|->
name|so_pcb
expr_stmt|;
name|newrdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|newinp
operator|->
name|inp_ppcb
expr_stmt|;
comment|/* 	     * Remember our peer for this connection. 	     */
name|newinp
operator|->
name|inp_faddr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|newinp
operator|->
name|inp_fport
operator|=
name|pkt
operator|->
name|rh_sport
expr_stmt|;
name|newinp
operator|->
name|inp_laddr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
comment|/* 	     * and copy fields into the new inpcb 	     */
name|newinp
operator|->
name|inp_lport
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|newinp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
name|rt
expr_stmt|;
comment|/* 	     * and copy fields into the new rdpcb.  In particular, 	     * the user's desired buffering allocations should be 	     * propogated. 	     */
name|newrdpcb
operator|->
name|r_ournbuf
operator|=
name|rdpcb
operator|->
name|r_ournbuf
expr_stmt|;
name|sbreserve
argument_list|(
operator|&
name|newrdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
operator|->
name|so_rcv
argument_list|,
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
name|pick_ourmaxlen
argument_list|(
name|newrdpcb
argument_list|)
expr_stmt|;
comment|/* 	     * Sequential delivery is a combination of both side's 	     * desires, and must be copied from server socket since 	     * user does not have a handle on the child socket in 	     * it's early states. 	     */
name|newrdpcb
operator|->
name|r_sequential
operator|=
name|rdpcb
operator|->
name|r_sequential
expr_stmt|;
comment|/* 	     * and stuff new information 	     */
name|got_syn
argument_list|(
name|newrdpcb
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|synopt
operator|=
name|RDP_OPT
argument_list|(
name|pkt
argument_list|,
name|SYNOPTIONS
operator|*
argument_list|)
expr_stmt|;
name|process_synopt
argument_list|(
name|newrdpcb
argument_list|,
name|synopt
argument_list|)
expr_stmt|;
comment|/* 	     * So can debug connection problems without having to 	     * change every program or apply debugging flag to each 	     * program every time run it. 	     */
name|dowedebug
argument_list|(
name|newinp
argument_list|,
name|newso
argument_list|,
operator|&
name|rdp_dfilter
argument_list|)
expr_stmt|;
comment|/* 	     * send other guy our SYN and ACK his syn. 	     * set re-transmission timer to ensure eventually gets 	     * to him. 	     */
name|rdp_template
argument_list|(
name|newrdpcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|newrdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|newrdpcb
operator|->
name|r_iss
argument_list|)
expr_stmt|;
name|set_rxtimer
argument_list|(
name|newrdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrdpcb
operator|->
name|r_state
operator|=
name|RDP_sLSYNRCVD
expr_stmt|;
block|}
else|else
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sLISTEN  *	input: RDP_iUCLOSE  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_lis_close
argument_list|(
argument|rdpcb
argument_list|,
argument|nil
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sSYNSENT  *	input: RDP_iNETR  */
end_comment

begin_expr_stmt
name|rdp_synsent_netr
argument_list|(
name|rdpcb
argument_list|,
name|pkt
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|rdpstate
name|newstate
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fACK
condition|)
block|{
if|if
condition|(
name|RDP_ACKNO
argument_list|(
name|pkt
argument_list|)
operator|!=
name|rdpcb
operator|->
name|r_iss
condition|)
block|{
comment|/* 	     * We haven't sent any data yet, only SYNs. 	     * He's confused. 	     */
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fRST
condition|)
block|{
comment|/* 	 * Require (rst, ack, ackno) to know rst meant for this, not 	 * a previous, incarnation of the socket.  Is an "in window" 	 * check.  Avoids problems with "slow" packets. 	 */
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fACK
condition|)
block|{
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|newstate
operator|=
name|RDP_sCLOSED
expr_stmt|;
block|}
else|else
name|newstate
operator|=
name|RDP_sSAME
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstate
operator|)
return|;
block|}
name|newstate
operator|=
name|RDP_sSAME
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fSYN
condition|)
block|{
specifier|register
name|SYNOPTIONS
modifier|*
name|synopt
decl_stmt|;
name|rdpsequence
name|seqnum
decl_stmt|;
name|got_syn
argument_list|(
name|rdpcb
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|synopt
operator|=
name|RDP_OPT
argument_list|(
name|pkt
argument_list|,
name|SYNOPTIONS
operator|*
argument_list|)
expr_stmt|;
name|process_synopt
argument_list|(
name|rdpcb
argument_list|,
name|synopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fACK
condition|)
block|{
name|rdpcb
operator|->
name|r_synacked
operator|=
name|TRUE
expr_stmt|;
name|rdpisconnected
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|newstate
operator|=
name|RDP_sESTAB
expr_stmt|;
name|seqnum
operator|=
name|rdpcb
operator|->
name|r_iss
operator|+
literal|1
expr_stmt|;
comment|/* clear re-xmit syn timer set in rdp_unop_connect() */
name|clear_rxtimer
argument_list|(
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start up connection loss detection */
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tNULL
index|]
operator|=
name|rdpcb
operator|->
name|r_tvnull
expr_stmt|;
block|}
else|else
block|{
name|newstate
operator|=
name|RDP_sSYNRCVD
expr_stmt|;
name|seqnum
operator|=
name|rdpcb
operator|->
name|r_iss
expr_stmt|;
comment|/* keep sending syn until he acks it */
name|set_rxtimer
argument_list|(
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* and ack his syn, retransmit ours if necessary */
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|seqnum
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstate
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sSYNSENT  *	input: RDP_iUCLOSE  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rdp_synsent_close
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* send RST */
name|rdpcb
operator|->
name|r_sendrst
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sSYNSENT  *	input: RDP_iTIMER  */
end_comment

begin_expr_stmt
name|rdp_synsent_timer
argument_list|(
name|rdpcb
argument_list|,
name|timer
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|timer
condition|)
block|{
case|case
name|RDP_tRTTL
case|:
comment|/* retransmission took too long */
name|rttl
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
case|case
name|RDP_tRXMIT
case|:
comment|/* 	 * re-transmit our SYN.  Not every 0.5 second, though, 	 * but every RDP_tvRXMIN units. 	 */
name|rdpcb
operator|->
name|r_rxtimers
index|[
literal|0
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|->
name|r_rxtimers
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_iss
argument_list|)
expr_stmt|;
name|set_rxtimer
argument_list|(
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_retrans
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* 	     * ensure keep checking even if no packet goes 	     * out this time.  ACK will stop this. 	     */
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tRXMIT
index|]
operator|=
name|RDP_tvRXCHECK
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rdp_synsent_timer:  timer %d\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sLSYNRCVD  *	input: RDP_iNETR  */
end_comment

begin_expr_stmt
name|rdp_lsynrcvd_netr
argument_list|(
name|rdpcb
argument_list|,
name|pkt
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*      * If it's a duplicate syn (seqno == irs), re-send ack since he must      * have missed our ack.  If it's out of the window, well, let's give      * him the benefit of the doubt and assume it's junk from an old      * connection/window that took a while to get to us.      */
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|rdpcb
operator|->
name|r_irs
argument_list|)
operator|||
name|SEQ_GEQ
argument_list|(
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
operator|+
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_maxqlen
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_rcvd
operator|.
name|r_retrans
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* try to synchronize again */
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_iss
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
operator|(
name|RDP_fRST
operator||
name|RDP_fEACK
operator||
name|RDP_fSYN
operator|)
condition|)
block|{
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fRST
condition|)
block|{
comment|/* 	     * User closed while his socket was in synsent state. 	     */
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fEACK
condition|)
block|{
comment|/* 	     * shouldn't be EACK, since we haven't sent anything yet 	     */
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* frees mbufs for pkt */
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fSYN
condition|)
block|{
comment|/* 	     * Boy, is the other end confused!  His syn has changed 	     * sequence numbers. 	     */
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fACK
condition|)
block|{
if|if
condition|(
name|RDP_ACKNO
argument_list|(
name|pkt
argument_list|)
operator|!=
name|rdpcb
operator|->
name|r_iss
condition|)
block|{
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* frees mbufs for pkt */
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
block|}
else|else
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
comment|/*      * clear timer for re-transmission of syn that we set in      * rdp_lis_netr().      */
name|clear_rxtimer
argument_list|(
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_synacked
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_dlen
operator|>
name|rdpcb
operator|->
name|r_ourmaxlen
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"RDP too large packet %d> %d\n"
argument_list|,
name|pkt
operator|->
name|rh_dlen
argument_list|,
name|rdpcb
operator|->
name|r_ourmaxlen
argument_list|)
expr_stmt|;
name|theygoofed
label|:
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tCLOSEWAIT
index|]
operator|=
name|rdpcb
operator|->
name|r_closewait
expr_stmt|;
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSEWAIT
operator|)
return|;
block|}
comment|/*      * zero length packets can be NULL messages or (E)ACKs,      * but all NULL messages must be zero length      */
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fNULL
condition|)
block|{
if|if
condition|(
name|pkt
operator|->
name|rh_dlen
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"RDP %d length NULL packet\n"
argument_list|,
name|pkt
operator|->
name|rh_dlen
argument_list|)
expr_stmt|;
goto|goto
name|theygoofed
goto|;
block|}
if|if
condition|(
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
operator|!=
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"RDP NULL 0x%x rcvq baseseq 0x%x\n"
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
argument_list|)
expr_stmt|;
goto|goto
name|theygoofed
goto|;
block|}
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_msgs
index|[
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_front
index|]
operator|=
name|NULL
expr_stmt|;
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_front
operator|=
operator|(
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_front
operator|+
literal|1
operator|)
operator|%
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_maxqlen
expr_stmt|;
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkt
operator|->
name|rh_dlen
condition|)
block|{
ifdef|#
directive|ifdef
name|RDP_CS
if|if
condition|(
name|rdp_qinsert
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|,
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|rdpcb
operator|->
name|r_rcvd
operator|.
name|r_retrans
operator|++
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|rdp_qinsert
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|,
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No (e)ack now.  Wait til gets to user */
block|}
else|else
comment|/* Was an ACK-only packet */
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|rdpisconnected
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
comment|/* start up connection loss detection */
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tNULL
index|]
operator|=
name|rdpcb
operator|->
name|r_tvnull
expr_stmt|;
return|return
operator|(
name|RDP_sESTAB
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sLSYNRCVD  *	input: RDP_iUCLOSE  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rdp_lsynrcvd_close
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* send RST */
name|rdpcb
operator|->
name|r_sendrst
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sLSYNRCVD  *	input: RDP_iTIMER  */
end_comment

begin_macro
name|rdp_lsynrcvd_timer
argument_list|(
argument|rdpcb
argument_list|,
argument|timer
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* whether connecting via connect(2) (SYNSENT) or child of      * or via child of a listen(2)ing socket (LSYNRCVD), need to      * retransmit out syn until it gets acked.      */
return|return
operator|(
name|rdp_synsent_timer
argument_list|(
name|rdpcb
argument_list|,
name|timer
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sSYNRCVD  *	input: RDP_iNETR  */
end_comment

begin_macro
name|rdp_synrcvd_netr
argument_list|(
argument|rdpcb
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rdp_lsynrcvd_netr
argument_list|(
name|rdpcb
argument_list|,
name|pkt
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sSYNRCVD  *	input: RDP_iUCLOSE  */
end_comment

begin_macro
name|rdp_synrcvd_close
argument_list|(
argument|rdpcb
argument_list|,
argument|nil
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rdp_lsynrcvd_close
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sSYNRCVD  *	input: RDP_iTIMER  */
end_comment

begin_macro
name|rdp_synrcvd_timer
argument_list|(
argument|rdpcb
argument_list|,
argument|timer
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rdp_lsynrcvd_timer
argument_list|(
name|rdpcb
argument_list|,
name|timer
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sESTAB  *	input: RDP_iNETR  */
end_comment

begin_expr_stmt
name|rdp_estab_netr
argument_list|(
name|rdpcb
argument_list|,
name|pkt
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*      * ensure packet is in window.  If not, ack him to straighten things      * out.      */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
argument_list|)
operator|||
name|SEQ_GEQ
argument_list|(
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
operator|+
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_maxqlen
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_rcvd
operator|.
name|r_retrans
operator|++
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
comment|/*      * Whenever we receive a packet and we're not already waiting for      * an ack of a NULL we sent, reset NULL timer.  Connection is alive.      *      * Don't reset for any packet if have an outstanding NULL since want      * to keep timer at zero and not generate a new NULL segment until      * current one is acknowledged.  (This might be a new message, not      * the NULL's ack.  Send and receive paths may differ?)      *      * Don't reset NULL timer on datagram transmissions since those imply      * receiving ACKs.  Besides, we want to know if he is up, not if we're      * up.      */
if|if
condition|(
name|rdpcb
operator|->
name|r_nullsent
operator|==
literal|0
condition|)
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tNULL
index|]
operator|=
name|rdpcb
operator|->
name|r_tvnull
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
operator|(
name|RDP_fSYN
operator||
name|RDP_fRST
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fSYN
condition|)
block|{
comment|/* 	     * We've gotten past the syn stage.  He's confused. 	     * His syn has also changed sequence numbers. 	     */
name|rdpcb
operator|->
name|r_sendrst
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
comment|/* 	 * Since we've been reset, the user cannot send anymore 	 * datagrams.  user_cantsendmore() also wakes writers up 	 * in case he is doing synchronous i/o and is waiting for 	 * buffering space at the (socket) level. 	 */
name|user_cantsendmore
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
comment|/* 	 * User can't read anymore either, per specification. 	 * Reliable delivery and acceptance must be determined 	 * by the application before closing. 	 */
name|user_cantreadmore
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|cancel_timers
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tCLOSEWAIT
index|]
operator|=
name|rdpcb
operator|->
name|r_closewait
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSEWAIT
operator|)
return|;
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fACK
condition|)
name|he_acked
argument_list|(
name|rdpcb
argument_list|,
name|RDP_ACKNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fEACK
condition|)
block|{
specifier|register
name|int
name|neacks
decl_stmt|;
specifier|register
name|EACKOPTIONS
modifier|*
name|eackopt
decl_stmt|;
name|neacks
operator|=
operator|(
name|hdrlen
argument_list|(
name|pkt
argument_list|)
operator|-
name|RDPHDRSZ
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|EACKOPTIONS
argument_list|)
expr_stmt|;
name|eackopt
operator|=
name|RDP_OPT
argument_list|(
name|pkt
argument_list|,
name|EACKOPTIONS
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|neacks
operator|>=
literal|0
condition|)
block|{
name|he_eacked
argument_list|(
name|rdpcb
argument_list|,
name|ntohl
argument_list|(
name|eackopt
operator|->
name|rh_eackno
argument_list|)
argument_list|)
expr_stmt|;
name|eackopt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_dlen
operator|>
name|rdpcb
operator|->
name|r_ourmaxlen
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"RDP pkt too large %d> %d\n"
argument_list|,
name|pkt
operator|->
name|rh_dlen
argument_list|,
name|rdpcb
operator|->
name|r_ourmaxlen
argument_list|)
expr_stmt|;
name|theygoofed
label|:
name|rdp_uncon_rst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|user_cantsendmore
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|user_cantreadmore
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|cancel_timers
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tCLOSEWAIT
index|]
operator|=
name|rdpcb
operator|->
name|r_closewait
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSEWAIT
operator|)
return|;
block|}
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fNULL
condition|)
block|{
if|if
condition|(
name|pkt
operator|->
name|rh_dlen
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"RDP %d length NULL pkt\n"
argument_list|,
name|pkt
operator|->
name|rh_dlen
argument_list|)
expr_stmt|;
goto|goto
name|theygoofed
goto|;
block|}
if|if
condition|(
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
operator|!=
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"RDP NULL 0x%x rcvq baseseq 0x%x\n"
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
argument_list|)
expr_stmt|;
goto|goto
name|theygoofed
goto|;
block|}
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_msgs
index|[
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_front
index|]
operator|=
name|NULL
expr_stmt|;
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_front
operator|=
operator|(
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_front
operator|+
literal|1
operator|)
operator|%
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_maxqlen
expr_stmt|;
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_baseseq
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkt
operator|->
name|rh_dlen
condition|)
block|{
ifdef|#
directive|ifdef
name|RDP_CS
if|if
condition|(
name|rdp_qinsert
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|,
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|rdpcb
operator|->
name|r_rcvd
operator|.
name|r_retrans
operator|++
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|rdp_qinsert
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|,
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|,
name|RDP_SEQNO
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* Was an ACK-only packet */
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usr_rbuf_is_empty
argument_list|(
name|rdpcb
argument_list|)
condition|)
block|{
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|m
operator|=
name|rdp_qremove
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|,
operator|!
name|rdpcb
operator|->
name|r_sequential
argument_list|)
condition|)
block|{
comment|/* 	     * IP and RDP headers should be in the first mbuf. 	     * User does not see them. 	     */
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_rcvd
operator|.
name|r_nbytes
operator|+=
name|pkt
operator|->
name|rh_dlen
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|hdrlen
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|hdrlen
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|usr_rbuf_append
argument_list|(
name|rdpcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|wakeup_reader
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * datagrams go straight out in response to the send(2) PRU_SEND,      * so getting (e)acks doesn't cause an outgoing datagram.      * Hold off on (e)ack of incoming packet until user receives it      * and we know that by PRU_RCV.      */
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sESTAB  *	input: RDP_iUCLOSE  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rdp_estab_close
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* send RST */
name|rdpcb
operator|->
name|r_sendrst
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
comment|/*      * Don't retransmit unacked datagrams, since user can't pick them      * up anymore once he's been reset (according to specification).      * Reliable delivery and acceptance must be determined by the      * application before closing.      */
name|cancel_timers
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tCLOSEWAIT
index|]
operator|=
name|rdpcb
operator|->
name|r_closewait
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSEWAIT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sESTAB  *	input: RDP_iTIMER  */
end_comment

begin_expr_stmt
name|rdp_estab_timer
argument_list|(
name|rdpcb
argument_list|,
name|timer
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|MBUF
modifier|*
name|rxmit_data
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|,
name|passes
decl_stmt|;
name|rdpsequence
name|seqno
decl_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
case|case
name|RDP_tRTTL
case|:
comment|/* retransmission took too long */
name|rttl
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
case|case
name|RDP_tRXMIT
case|:
comment|/* 	 * ensure keep checking even if no packet goes 	 * out this time.  ACK will stop this. 	 */
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tRXMIT
index|]
operator|=
name|RDP_tvRXCHECK
expr_stmt|;
name|index
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
expr_stmt|;
name|passes
operator|=
name|rdpcb
operator|->
name|r_sndnxt
operator|-
name|rdpcb
operator|->
name|r_snduna
expr_stmt|;
name|seqno
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_baseseq
expr_stmt|;
comment|/* == r_snduna */
while|while
condition|(
operator|--
name|passes
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rdpcb
operator|->
name|r_rxtimers
index|[
name|index
index|]
condition|)
block|{
name|rdpcb
operator|->
name|r_rxtimers
index|[
name|index
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|rdpcb
operator|->
name|r_rxtimers
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
name|MBUF
modifier|*
name|m
decl_stmt|;
comment|/* 		     * Over lossy networks, do not let 		     * the round trip time estimate 		     * drift unecessarily high.  If we're 		     * considering the round-trip-time- 		     * measuring packet lost, and are 		     * retransmitting it, then we should 		     * reset the round trip time measurment 		     */
if|if
condition|(
name|rdpcb
operator|->
name|r_rttiming
condition|)
if|if
condition|(
name|seqno
operator|==
name|rdpcb
operator|->
name|r_rttimed
condition|)
name|rdpcb
operator|->
name|r_rttiming
operator|=
name|FALSE
expr_stmt|;
name|m
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|RDP_NULLMSG
condition|)
block|{
name|rdpcb
operator|->
name|r_sendnull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|seqno
argument_list|)
operator|==
literal|0
condition|)
name|time_rtt
argument_list|(
name|rdpcb
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
comment|/* 			 * Back off on retransmissions, 			 * because the host might be 			 * down or the network could be 			 * jammed.  rxmitime will drop 			 * to normal when we get the ACK 			 */
name|rdpcb
operator|->
name|r_rxmitime
operator|=
name|MIN
argument_list|(
name|RDP_tvRXMAX
argument_list|,
name|rdpcb
operator|->
name|r_rxmitime
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|rdpcb
operator|->
name|r_nullsent
operator|>
name|RDP_MAXNULL
condition|)
block|{
comment|/* advisory only */
name|set_error
argument_list|(
name|rdpcb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
name|wakeup_reader
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
comment|/* writer timeout via rttl */
comment|/* avoid rollover to zero 			     * 			     * NOTE: user will get 			     * ETIMEDOUT on every 			     * rxmit, another reason 			     * to back off above. 			     */
name|rdpcb
operator|->
name|r_nullsent
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rxmit_data
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
condition|)
comment|/* 			     * When we 1st sent it, we 			     * remembered the len in m_act 			     */
if|if
condition|(
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
name|rxmit_data
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|m_act
argument_list|,
name|seqno
argument_list|)
operator|==
literal|0
condition|)
name|time_rtt
argument_list|(
name|rdpcb
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
comment|/* 			 * We aren't backing off here, 			 * since the single number is 			 * used for all datagrams, 			 * each of which may be at a 			 * different nth rxmission 			 */
block|}
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_sent
operator|.
name|r_retrans
operator|++
expr_stmt|;
endif|#
directive|endif
name|set_rxtimer
argument_list|(
name|rdpcb
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|index
operator|=
operator|(
name|index
operator|+
literal|1
operator|)
operator|%
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
name|seqno
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|RDP_tACKDELAY
case|:
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDP_tNULL
case|:
comment|/* 	 * If we're retransmitting, then we don't need to 	 * send NULL messages.  The NULL timer drops to zero 	 * and gets restarted when we get some packet from 	 * them (rdp_estab_netr).  User will get ETIMEDOUT 	 * from retransmit took too long if we don't get a 	 * packet. 	 */
if|if
condition|(
name|rdpcb
operator|->
name|r_rttlindex
operator|<
literal|0
condition|)
block|{
comment|/* are not retransmitting */
comment|/* 	     * Idea:  The connection has been idle for too 	     * long. send a NULL packet which has its own 	     * sequence number (so can distinguish slow to 	     * arrive ack from ack of this NULL) and 	     * retransmit it via normal packet 	     * retransmission algorithm. 	     */
if|if
condition|(
name|rdp_qinsert
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_sendq
argument_list|,
name|RDP_NULLMSG
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"rdp RDP_tNULL"
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_sendnull
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|index
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
operator|+
operator|(
name|rdpcb
operator|->
name|r_sndnxt
operator|-
name|rdpcb
operator|->
name|r_snduna
operator|)
expr_stmt|;
name|index
operator|%=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
name|set_rxtimer
argument_list|(
name|rdpcb
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_sndnxt
operator|++
expr_stmt|;
name|rdpcb
operator|->
name|r_nullsent
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rdp_estab_timer:  timer %d\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sESTAB  *	input: RDP_iRCV  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rdp_estab_rcv
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|MBUF
modifier|*
name|m
decl_stmt|;
comment|/*      * Now that user has received the packet, bump the front so that      * we can ACK it and move the window along.      */
name|rdp_received
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|)
expr_stmt|;
comment|/*      * user picked up the packet we left on the socket for him.      * Let's put another one there.      */
if|if
condition|(
name|m
operator|=
name|rdp_qremove
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_rcvq
argument_list|,
operator|!
name|rdpcb
operator|->
name|r_sequential
argument_list|)
condition|)
block|{
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
comment|/* 	 * IP and RDP headers should be in the first mbuf. 	 * User does not see them. 	 */
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_rcvd
operator|.
name|r_nbytes
operator|+=
name|pkt
operator|->
name|rh_dlen
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|hdrlen
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|hdrlen
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|usr_rbuf_append
argument_list|(
name|rdpcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* wakeup_reader(rdpcb); is awake, performing read(2) */
block|}
comment|/*      * Send an ACK, but apply an ACK-delay algorithm in order to      * reduce CPU loading on both hosts involved.  Reduces network      * load, too.  Skip at most one ACK.      */
if|if
condition|(
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tACKDELAY
index|]
condition|)
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
else|else
name|rdpcb
operator|->
name|r_timers
index|[
name|RDP_tACKDELAY
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sESTAB  *	input: RDP_iSEND  */
end_comment

begin_expr_stmt
name|rdp_estab_send
argument_list|(
name|rdpcb
argument_list|,
name|m
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|MBUF
modifier|*
name|copym
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
comment|/*      * q message on send q.      */
if|if
condition|(
name|rdp_qinsert
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_sendq
argument_list|,
name|m
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"rdp_estab_send"
argument_list|)
expr_stmt|;
comment|/*      * Remember the length of the datagram for sending now,      * and for retransmissions later.      */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|copym
operator|=
name|m
init|;
name|copym
condition|;
name|copym
operator|=
name|copym
operator|->
name|m_next
control|)
name|len
operator|+=
name|copym
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
operator|(
operator|(
name|MBUF
operator|*
operator|)
name|len
operator|)
expr_stmt|;
comment|/*      * if reached end of window, block socket code from allowing      * sends until get an ACK      */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|rdpcb
operator|->
name|r_sndnxt
argument_list|,
name|rdpcb
operator|->
name|r_snduna
operator|+
name|rdpcb
operator|->
name|r_hisnbuf
operator|-
literal|1
argument_list|)
condition|)
name|sendbufisfull
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
comment|/*      * send a copy of the datagram      */
if|if
condition|(
name|copym
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
condition|)
if|if
condition|(
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
name|copym
argument_list|,
name|len
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
operator|==
literal|0
condition|)
name|time_rtt
argument_list|(
name|rdpcb
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|index
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_front
operator|+
operator|(
name|rdpcb
operator|->
name|r_sndnxt
operator|-
name|rdpcb
operator|->
name|r_snduna
operator|)
expr_stmt|;
name|index
operator|%=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_maxqlen
expr_stmt|;
name|set_rxtimer
argument_list|(
name|rdpcb
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_sndnxt
operator|++
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  *	state: RDP_sCLOSEWAIT  *	input: RDP_iNETR  */
end_comment

begin_macro
name|rdp_closew_netr
argument_list|(
argument|rdpcb
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rdpstate
name|newstate
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|rh_flags
operator|&
name|RDP_fRST
condition|)
block|{
comment|/* 	 * We've both agreed to shut down the connection 	 */
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|newstate
operator|=
name|RDP_sCLOSED
expr_stmt|;
block|}
else|else
name|newstate
operator|=
name|RDP_sSAME
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstate
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sCLOSEWAIT  *	input: RDP_iUCLOSE  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rdp_closew_close
argument_list|(
name|rdpcb
argument_list|,
name|nil
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*      * rdp_usrreq() only allows one close call to the finite state machine.      * Therefore, we entered CLOSEWAIT in response to a RST, not a close.      * So, now both sides agree to close co-operatively.      */
name|rdpcb
operator|->
name|r_sendrst
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|rdp_sendpkt
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|rdpcb
operator|->
name|r_sndnxt
argument_list|)
expr_stmt|;
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sCLOSEWAIT  *	input: RDP_iTIMER  */
end_comment

begin_macro
name|rdp_closew_timer
argument_list|(
argument|rdpcb
argument_list|,
argument|timer
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|timer
operator|!=
name|RDP_tCLOSEWAIT
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rdp_closew_timer:  timer %d\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sSAME
operator|)
return|;
block|}
name|trash_pcbs
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|RDP_sCLOSED
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	state: RDP_sCLOSEWAIT  *	input: RDP_iRCV  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_closew_rcv
argument_list|(
argument|rdpcb
argument_list|,
argument|nil
argument_list|)
end_macro

begin_block
block|{
comment|/*      * Technically, an illegal transition.  However, socket code drops      * system priority level, allowing processing of a network packet      * containing RDP reset to cause ESTAB -> CLOSEWAIT in the middle of      * passing the user a packet.      *      * ESTAB ... user receives packet, priority dropped for uiomove()      *      --- network packet processed ---      * CLOSEWAIT ... socket code continues, causing this action.      *      * ### This can be a serious problem in general.      */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

