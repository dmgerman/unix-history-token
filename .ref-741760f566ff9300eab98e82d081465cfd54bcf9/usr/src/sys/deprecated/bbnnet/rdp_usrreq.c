begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Log:	rdp_usrreq.c,v $  * Revision 2.8  85/05/30  11:54:12  walsh  * initialize r_srtt.  *   * Revision 2.7  85/02/26  08:27:02  walsh  * First pass at using IP source routing information to establish connections  * (possibly with hosts not known by the Internet gateways.)  The hooks with  * TCP could be better done - particularly dealing with IP addresses in the  * header for checksums and tcpdb lookups.  *   * Revision 2.6  84/11/29  12:51:00  walsh  * changed references to currentrtt into references to srtt, a better  * and less misleading mnemonic.  *   * Revision 2.5  84/11/08  16:13:17  walsh  * Added code to gather statistics on RDP traffic.  This makes the RDPCB  * too big unles you make mbufs 512 bytes large.  RDP_CS should be turned off  * unless you do.  *   * Revision 2.4  84/11/05  12:41:29  walsh  * Set things up so can debug RDP connections just like can debug TCP  * connections.  *   * Revision 2.3  84/11/05  11:05:42  walsh  * comment and adjust number for rdp_iss in a mathematically correct way  * as a result of benchmarks (cf. operationally correct).  *   * Revision 2.2  84/11/05  10:49:01  walsh  * More changes to go with NULL messages getting their own sequence  * number.  *   * Revision 2.1  84/11/02  10:16:02  walsh  * Fixed to include RCS comments in checked out source.  *   *  * description:  * The user system call interface to RDP.  *   * revision 1.11          * date: 84/07/20 12:35:26;  author: root;  state: Exp;  lines added/del: 2/2  * fix syntax error.  *   * revision 1.10          * date: 84/07/20 11:25:53;  author: walsh;  state: Exp;  lines added/del: 3/2  * Don't let user use unreasonable (too small) retranmit took too long timers.  *   * revision 1.9          * date: 84/07/19 10:22:59;  author: walsh;  state: Exp;  lines added/del: 2/1  * Organized macros and classified their definitions in rdp_macros.h.  *   * revision 1.8          * date: 84/07/18 18:51:41;  author: walsh;  state: Exp;  lines added/del: 29/1  * Added provision for sending of NULL messages.  These are sent on an idle  * connection to determine that the other side still exists.  *   * revision 1.7          * date: 84/07/18 13:49:19;  author: walsh;  state: Exp;  lines added/del: 19/1  * RTTL timer is now user alterable.  *   * revision 1.6          * date: 84/07/17 22:42:08;  author: walsh;  state: Exp;  lines added/del: 7/3  * Can't connect to port numbers greater than RDP_pMAX.  *  * revision 1.5          * date: 84/07/12 13:48:38;  author: walsh;  state: Exp;  lines added/del: 2/1  * Rather than in-line stuffing of IP/RDP headers, at least half of which are  * constant, copy headers in from a template of what the headers are like.  The  * bcopy() call is turned into a movc3 instruction on the VAX by a sed script  * run over the assembler output of the C compiler.  Marginal speed-up.  *   * revision 1.4          * date: 84/07/10 10:45:38;  author: walsh;  state: Exp;  lines added/del: 20/19  * neatened up some formatting.  *   * revision 1.3          * date: 84/07/06 14:41:15;  author: wjacobso;  state: Exp;  lines added/del: 11/3  * use RSP_ACTION macro instead of rdp_action  *   * revision 1.2          * date: 84/07/06 09:51:35;  author: root;  state: Exp;  lines added/del: 56/17  * This version seems to run bug-free.  *   * revision 1.1          * date: 84/06/26 14:18:47;  author: walsh;  state: Exp;    * Initial revision  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RDP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: rdp_usrreq.c,v 2.8 85/05/30 11:54:12 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/rdp_macros.h"
end_include

begin_comment
comment|/*  * RDP protocol interface to socket abstraction.  */
end_comment

begin_comment
comment|/*  * misc data structures  */
end_comment

begin_decl_stmt
name|struct
name|inpcb
name|rdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rdp_stat
name|rdpstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfilter
name|rdp_dfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rdpsequence
name|rdp_iss
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * RDP port allocation information  */
end_comment

begin_extern
extern|extern rdp_binding_used(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|pr_advice
name|rdp_advice
init|=
block|{
name|RDP_RESERVED
block|,
name|RDP_USERRESERVED
block|,
name|RDP_MAXPORT
block|,
name|RDP_USERRESERVED
operator|+
literal|1
block|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
block|,
name|rdp_binding_used
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate and initialize a new RDPCB  * rdp_usrreq calls rdp_attach calls us.  rdp_usrreq splnet()'s  *  * Default allocation for kernel receive buffering is  * (rdp_ournbuf * rdp_ourmaxlen) bytes.  */
end_comment

begin_decl_stmt
name|int
name|rdp_ournbuf
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rdp_ourmaxlen
init|=
name|IPMAX
operator|-
name|HDRSLOP
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|rdp_newrdpcb
argument_list|(
name|inp
argument_list|)
specifier|register
name|INPCB
operator|*
name|inp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
name|MBUF
modifier|*
name|mrq
decl_stmt|,
modifier|*
name|msq
decl_stmt|;
name|m
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
name|mrq
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
name|msq
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mrq
operator|==
name|NULL
operator|)
operator|||
operator|(
name|msq
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|m
condition|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrq
condition|)
name|m_free
argument_list|(
name|mrq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msq
condition|)
name|m_free
argument_list|(
name|msq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|rdpcb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|RDPCB
operator|*
argument_list|)
expr_stmt|;
comment|/* initialize non-zero tcb fields */
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
operator|=
name|mtod
argument_list|(
name|msq
argument_list|,
name|MBUF
operator|*
operator|*
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_msgs
operator|=
name|mtod
argument_list|(
name|mrq
argument_list|,
name|MBUF
operator|*
operator|*
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_state
operator|=
name|RDP_sUNOPENED
expr_stmt|;
ifdef|#
directive|ifdef
name|RDP_CS
name|rdpcb
operator|->
name|r_entered
index|[
name|RDP_sUNOPENED
index|]
operator|=
name|iptime
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|rdpcb
operator|->
name|r_ournbuf
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|MIN
argument_list|(
name|RDP_MAXDGRAMS
argument_list|,
name|rdp_ournbuf
argument_list|)
argument_list|)
expr_stmt|;
name|rdpcb
operator|->
name|r_hisnbuf
operator|=
literal|1
expr_stmt|;
comment|/*  rdpcb->r_synrcvd	= FALSE;	*/
comment|/*  rdpcb->r_synacked	= FALSE;	*/
comment|/*  rdpcb->r_usrclosed	= FALSE;	*/
comment|/*  rdpcb->r_rttiming	= FALSE;	*/
name|rdpcb
operator|->
name|r_sequential
operator|=
name|TRUE
expr_stmt|;
name|rdpcb
operator|->
name|r_closewait
operator|=
name|RDP_tvCLOSEWAIT
expr_stmt|;
name|rdpcb
operator|->
name|r_rttl
operator|=
name|RDP_tvRTTL
expr_stmt|;
name|rdpcb
operator|->
name|r_tvnull
operator|=
name|RDP_tvNULL
expr_stmt|;
name|rdpcb
operator|->
name|r_srtt
operator|=
name|RDP_tvRXMIN
expr_stmt|;
comment|/*###*/
name|rdpcb
operator|->
name|r_rxmitime
operator|=
name|rdpcb
operator|->
name|r_srtt
operator|+
literal|1
expr_stmt|;
name|rdpcb
operator|->
name|r_rttlindex
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|->
name|r_iss
operator|=
name|rdp_iss
expr_stmt|;
name|rdpcb
operator|->
name|r_sndnxt
operator|=
name|rdpcb
operator|->
name|r_snduna
operator|=
name|rdpcb
operator|->
name|r_iss
operator|+
literal|1
expr_stmt|;
name|rdp_iss
operator|+=
name|RDP_ISSINCR
expr_stmt|;
comment|/* attach the protocol specific pcb to the generic internet pcb */
name|inp
operator|->
name|inp_ppcb
operator|=
operator|(
name|caddr_t
operator|)
name|rdpcb
expr_stmt|;
name|rdpcb
operator|->
name|r_inpcb
operator|=
name|inp
expr_stmt|;
comment|/*      * User has until listen(2) or connect(2) to increase max dgram      * size we will accept.  He does this by adjusting his socket's      * amount of receive buffering.      */
name|sbreserve
argument_list|(
operator|&
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
operator|->
name|so_rcv
argument_list|,
name|rdp_ourmaxlen
argument_list|)
expr_stmt|;
name|pick_ourmaxlen
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rdp_pcbdisconnect
argument_list|(
argument|inp
argument_list|)
end_macro

begin_decl_stmt
name|INPCB
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
specifier|register
name|MBUF
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|inp
operator|->
name|inp_ppcb
condition|)
block|{
name|inp
operator|->
name|inp_ppcb
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
comment|/* 	 * free all data on receive and send qs 	 * Remember, due to EACKS, send q may contain non-NULL 	 * RDP_DELIVERED pointers. 	 * If we close while we're retransmitting a NULL message, 	 * may have one of those on our send queue. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RDP_MAXDGRAMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|=
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|(
name|m
operator|!=
name|RDP_DELIVERED
operator|)
operator|&&
operator|(
name|m
operator|!=
name|RDP_NULLMSG
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_msgs
index|[
name|i
index|]
condition|)
if|if
condition|(
name|m
operator|!=
name|RDP_DELIVERED
condition|)
comment|/* just in case */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|dtom
argument_list|(
name|rdpcb
operator|->
name|r_sendq
operator|.
name|rq_msgs
argument_list|)
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|dtom
argument_list|(
name|rdpcb
operator|->
name|r_rcvq
operator|.
name|rq_msgs
argument_list|)
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|dtom
argument_list|(
name|rdpcb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Is a rdp port/address pair already in use by some socket on this machine?  * Passed to in_pcbbind() to help it find a port/address binding  * that is unique for rdp.  */
end_comment

begin_function
name|int
name|rdp_binding_used
parameter_list|(
name|inp
parameter_list|,
name|lport
parameter_list|,
name|laddr
parameter_list|,
name|reuselocal
parameter_list|)
name|INPCB
modifier|*
name|inp
decl_stmt|;
name|rdpportnum
name|lport
decl_stmt|;
name|u_long
name|laddr
decl_stmt|;
block|{
specifier|register
name|INPCB
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rdp
operator|.
name|inp_next
init|;
name|i
operator|!=
operator|&
name|rdp
condition|;
name|i
operator|=
name|i
operator|->
name|inp_next
control|)
block|{
comment|/* 	 * Since our inpcb is in this linked list, don't want to know 	 * if we, ourselves, are already using this binding. 	 */
if|if
condition|(
name|i
operator|!=
name|inp
condition|)
if|if
condition|(
name|i
operator|->
name|inp_lport
operator|==
name|lport
condition|)
comment|/* 		 * Our/His address is unbound (INADDR_ANY) iff 		 * not yet connected to foreign host. 		 */
if|if
condition|(
operator|(
name|i
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|laddr
operator|)
operator|||
operator|(
name|i
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|laddr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reuselocal
condition|)
break|break;
if|if
condition|(
name|i
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
comment|/* 			 * We're both waiting for foreign 			 * connection.  Could only re-use if 			 * he was already connected. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|!=
operator|&
name|rdp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rdp_conn_used
parameter_list|(
name|inp
parameter_list|,
name|lport
parameter_list|,
name|laddr
parameter_list|,
name|fport
parameter_list|,
name|faddr
parameter_list|)
name|INPCB
modifier|*
name|inp
decl_stmt|;
name|rdpportnum
name|lport
decl_stmt|;
name|u_long
name|laddr
decl_stmt|;
name|rdpportnum
name|fport
decl_stmt|;
name|u_long
name|faddr
decl_stmt|;
block|{
specifier|register
name|INPCB
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rdp
operator|.
name|inp_next
init|;
name|i
operator|!=
operator|&
name|rdp
condition|;
name|i
operator|=
name|i
operator|->
name|inp_next
control|)
block|{
comment|/* 	 * Since our inpcb is in this linked list, don't want to know 	 * if we, ourselves, are already using this connetion. 	 */
if|if
condition|(
name|i
operator|!=
name|inp
condition|)
if|if
condition|(
operator|(
name|i
operator|->
name|inp_lport
operator|==
name|lport
operator|)
operator|&&
operator|(
name|i
operator|->
name|inp_fport
operator|==
name|fport
operator|)
operator|&&
operator|(
name|i
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|laddr
operator|)
operator|&&
operator|(
name|i
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|faddr
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|i
operator|->
name|inp_ppcb
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|rdp_ioctl
argument_list|(
argument|rdpcb
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCGNDGRAMS
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|rdpcb
operator|->
name|r_ournbuf
expr_stmt|;
break|break;
case|case
name|SIOCSNDGRAMS
case|:
if|if
condition|(
operator|(
name|rdpcb
operator|->
name|r_state
operator|==
name|RDP_sUNOPENED
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|>
literal|0
operator|)
condition|)
name|rdpcb
operator|->
name|r_ournbuf
operator|=
name|MIN
argument_list|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|,
name|RDP_MAXDGRAMS
argument_list|)
expr_stmt|;
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|SIOCGSEQ
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|rdpcb
operator|->
name|r_sequential
expr_stmt|;
break|break;
case|case
name|SIOCSSEQ
case|:
if|if
condition|(
name|rdpcb
operator|->
name|r_state
operator|==
name|RDP_sUNOPENED
condition|)
name|rdpcb
operator|->
name|r_sequential
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|SIOCGRTTL
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|rdpcb
operator|->
name|r_rttl
expr_stmt|;
break|break;
case|case
name|SIOCSRTTL
case|:
block|{
comment|/* 	     * Allow user to set r_rttl to 0 to disable. 	     */
name|unsigned
name|int
name|newvalue
decl_stmt|;
name|newvalue
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|newvalue
operator|>
name|RDP_MAXTIMERVAL
operator|)
operator|||
operator|(
name|newvalue
operator|&&
operator|(
name|newvalue
operator|<
name|MIN
argument_list|(
name|rdpcb
operator|->
name|r_srtt
argument_list|,
name|rdpcb
operator|->
name|r_rxmitime
argument_list|)
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
else|else
name|rdpcb
operator|->
name|r_rttl
operator|=
name|newvalue
expr_stmt|;
block|}
break|break;
comment|/* 	 * Problem with socket level KEEPALIVES is that timer 	 * would be constant for all connections. 	 */
case|case
name|SIOCGNULL
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|rdpcb
operator|->
name|r_tvnull
expr_stmt|;
break|break;
case|case
name|SIOCSNULL
case|:
block|{
comment|/* 	     * Allow user to set to 0 to disable. 	     */
name|unsigned
name|int
name|newvalue
decl_stmt|;
name|newvalue
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|newvalue
operator|>
name|RDP_MAXTIMERVAL
operator|)
operator|||
operator|(
name|newvalue
operator|&&
operator|(
name|newvalue
operator|<
name|rdpcb
operator|->
name|r_rttl
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
else|else
name|rdpcb
operator|->
name|r_tvnull
operator|=
name|newvalue
expr_stmt|;
block|}
break|break;
default|default:
comment|/* not our ioctl, let lower level try ioctl */
return|return
name|ip_ioctl
argument_list|(
name|rdpcb
operator|->
name|r_inpcb
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process a RDP user request (system call).  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rdp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|rights
operator|&&
name|rights
operator|->
name|m_len
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*      * When an RDPCB is attached to a socket, then there will be      * an INPCB pointed at by the socket, and this      * structure will point at a subsidary RDPCB.      */
if|if
condition|(
name|inp
operator|==
literal|0
operator|&&
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX */
block|}
if|if
condition|(
name|inp
condition|)
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|inp
operator|->
name|inp_ppcb
expr_stmt|;
comment|/*      * This switch becomes a 'caseb', so put common ones at top.      */
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_RCVD
case|:
comment|/* 	 * After user has received message, ack the message. read(2) 	 */
block|{
specifier|register
name|rdpstate
name|newstate
decl_stmt|;
name|RDP_ACTION
argument_list|(
name|RDP_iRCV
argument_list|,
name|rdpcb
argument_list|,
literal|0
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRU_SEND
case|:
comment|/* 	 * Send this message. write(2) 	 */
block|{
specifier|register
name|rdpstate
name|newstate
decl_stmt|;
name|RDP_ACTION
argument_list|(
name|RDP_iSEND
argument_list|,
name|rdpcb
argument_list|,
operator|(
operator|(
name|int
operator|)
name|m
operator|)
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRU_ATTACH
case|:
comment|/* 	 * set up protocol control blocks.  socket(2) 	 */
if|if
condition|(
name|inp
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|=
name|rdp_attach
argument_list|(
name|so
argument_list|)
condition|)
break|break;
comment|/* 	 * so_linger doesn't affect anything I know of in the socket level 	 * -- see soclose().  Maybe this is one of those someday things. 	 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
name|so
operator|->
name|so_linger
operator|==
literal|0
condition|)
name|so
operator|->
name|so_linger
operator|=
literal|120
expr_stmt|;
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
operator|(
operator|(
name|INPCB
operator|*
operator|)
name|so
operator|->
name|so_pcb
operator|)
operator|->
name|inp_ppcb
expr_stmt|;
break|break;
case|case
name|PRU_DETACH
case|:
comment|/* 	 * close(2) the connection 	 */
name|rdp_close
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
comment|/* 	 * Give the socket an address.  bind(2) 	 */
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|,
operator|&
name|rdp_advice
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_LISTEN
case|:
comment|/* 	 * Prepare to accept connections.  Passive open.  listen(2) 	 */
if|if
condition|(
name|inp
operator|->
name|inp_lport
operator|==
literal|0
condition|)
if|if
condition|(
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rdp_advice
argument_list|)
condition|)
break|break;
name|pick_ourmaxlen
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdp_action
argument_list|(
name|RDP_iLISTEN
argument_list|,
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_CONNECT
case|:
comment|/* 	 * Active open.  connect(2).  Initiate connection to peer. 	 * Bind the local end if not already.  Set the routing. 	 * Crank up the state machine. 	 */
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* 	     * ensure foreign address might be valid. 	     * Can't connect to broadcast address... 	     */
name|sin
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in_broadcast
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
operator|||
operator|(
name|sin
operator|->
name|sin_port
operator|>
name|RDP_MAXPORT
operator|)
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_lport
operator|==
literal|0
condition|)
if|if
condition|(
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
operator|(
name|MBUF
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rdp_advice
argument_list|)
condition|)
break|break;
if|if
condition|(
name|error
operator|=
name|in_pcbconnect
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|,
name|rdp_conn_used
argument_list|)
condition|)
break|break;
comment|/* 	     * So can debug connection problems without having to change 	     * every program or apply debugging flag to each program every 	     * time run it. 	     */
name|dowedebug
argument_list|(
name|inp
argument_list|,
name|so
argument_list|,
operator|&
name|rdp_dfilter
argument_list|)
expr_stmt|;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|pick_ourmaxlen
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdp_template
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
name|rdp_action
argument_list|(
name|RDP_iCONNECT
argument_list|,
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Create a TCP connection between two sockets. 	 */
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|PRU_DISCONNECT
case|:
comment|/* 	 * close(2) 	 */
name|rdp_close
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ACCEPT
case|:
comment|/* 	 * accept(2).  Socket code has waited until a new connection 	 * is available for the listener/server.  Now that there is 	 * one, we just tell them who it is. 	 */
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
block|}
break|break;
case|case
name|PRU_SHUTDOWN
case|:
comment|/* 	 * user has shutdown(2) for writing.  This is a friendly close; 	 * the user may still want to read. 	 */
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
comment|/* 	 * abort un-accept(2)ed connections when close listening socket 	 * act as if it was accepted and closed.  Remove socket from 	 * parent socket's qs so that not hang in soclose() 	 */
comment|/* accept */
if|if
condition|(
operator|!
name|soqremque
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* SYNSENT, LSYNRCVD */
if|if
condition|(
operator|!
name|soqremque
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* ESTAB */
name|panic
argument_list|(
literal|"rdp ABORT"
argument_list|)
expr_stmt|;
comment|/* close */
name|rdp_close
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_CONTROL
case|:
name|error
operator|=
name|rdp_ioctl
argument_list|(
name|rdpcb
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|)
expr_stmt|;
break|break;
comment|/* SOME AS YET UNIMPLEMENTED HOOKS */
case|case
name|PRU_SENSE
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
comment|/* END UNIMPLEMENTED HOOKS */
case|case
name|PRU_RCVOOB
case|:
case|case
name|PRU_SENDOOB
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|PRU_SOCKADDR
case|:
comment|/* 	 * Tell user his (local) address/binding 	 */
name|in_setsockaddr
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_PEERADDR
case|:
name|in_setpeeraddr
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|neverdef
case|case
name|PRU_SLOWTIMO
case|:
name|rdp_timeo
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"rdp_usrreq"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * get/setsockopt() handler  */
end_comment

begin_macro
name|rdp_ctloutput
argument_list|(
argument|req
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|optname
argument_list|,
argument|optval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|,
name|optname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|optval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* like PRU/packet/timer entry into net code */
name|int
name|error
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/*      * See comments by tcp_ctloutput()      */
if|if
condition|(
name|level
operator|==
name|IPPROTO_RDP
condition|)
block|{
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|PRCO_GETOPT
case|:
name|error
operator|=
name|rdp_getopt
argument_list|(
name|inp
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRCO_SETOPT
case|:
name|error
operator|=
name|rdp_setopt
argument_list|(
name|inp
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rdp_ctloutput"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|ip_ctloutput
argument_list|(
name|req
argument_list|,
name|so
argument_list|,
name|level
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|rdp_setopt
argument_list|(
argument|inp
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* no RDP specific options accessed by setsockopt() as yet */
return|return
name|EOPNOTSUPP
return|;
block|}
end_block

begin_macro
name|rdp_getopt
argument_list|(
argument|inp
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* no RDP specific options accessed by getsockopt() as yet */
return|return
name|EOPNOTSUPP
return|;
block|}
end_block

begin_comment
comment|/*  * attach rdp protocol to socket  */
end_comment

begin_macro
name|rdp_attach
argument_list|(
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|rdp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|rdp_newrdpcb
argument_list|(
name|inp
argument_list|)
condition|)
name|in_pcbdetach
argument_list|(
name|inp
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initiate (or continue) disconnect.  close(2).  */
end_comment

begin_expr_stmt
name|rdp_close
argument_list|(
name|rdpcb
argument_list|)
specifier|register
name|RDPCB
operator|*
name|rdpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
operator|!
name|rdpcb
operator|->
name|r_usrclosed
condition|)
block|{
name|rdpcb
operator|->
name|r_usrclosed
operator|=
name|TRUE
expr_stmt|;
name|so
operator|=
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
expr_stmt|;
name|soisdisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sbflush
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|rdp_action
argument_list|(
name|RDP_iUCLOSE
argument_list|,
name|rdpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rdp_init
argument_list|()
end_macro

begin_block
block|{
comment|/*      * Leave these checks in!  It's a pain in the ass to find out      * problems caused by too small mbufs if someone changes the      * size of an mbuf.      */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|RDPCB
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"rdpcb too big"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|R_DEBUG
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"r_debug too big"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|RDPHDR
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"rdphdr too big"
argument_list|)
expr_stmt|;
comment|/*      * When send a packet, we allocate an mbuf for options and assume      * they'll always fit.      */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|EACKOPTIONS
argument_list|)
operator|*
name|RDP_MAXDGRAMS
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"RDP_MAXDGRAMS too big"
argument_list|)
expr_stmt|;
comment|/*      * rq_msgs is assumed to fit within a single mbuf.      */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|MBUF
operator|*
argument_list|)
operator|*
name|RDP_MAXDGRAMS
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"RDP_MAXDGRAMS too big 2"
argument_list|)
expr_stmt|;
comment|/*      * When receive a packet, IP hdr + RDP hdr + RDP options pulled up      * into a single mbuf and later assumed to be contiguous.  We'd like      * to avoid deadlock on a connection leading to a timeout failure of      * the connection.  Also, later just before we pass the packet to the      * user, we trim off the headers assuming they're in one mbuf.      *      * This superceeds a few of the above, but if we change things, the      * separate listing will make things easier.      */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RDPHDR
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|EACKOPTIONS
argument_list|)
operator|*
name|RDP_MAXDGRAMS
operator|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"RDP_MAXDGRAMS too big 3"
argument_list|)
expr_stmt|;
name|rdp_iss
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|rdp
operator|.
name|inp_next
operator|=
name|rdp
operator|.
name|inp_prev
operator|=
operator|&
name|rdp
expr_stmt|;
comment|/* are only 4 things to match. turn off for now */
name|rdp_dfilter
operator|.
name|matches
operator|=
literal|5
expr_stmt|;
name|ipsw
index|[
name|IPPROTO_RDP
index|]
operator|.
name|ipsw_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|RDPHDRSZ
expr_stmt|;
block|}
end_block

begin_macro
name|rdp_ctlinput
argument_list|(
argument|prc_code
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|inetctlerrmap
index|[
name|prc_code
index|]
expr_stmt|;
switch|switch
condition|(
name|prc_code
condition|)
block|{
case|case
name|PRC_UNREACH_PROTOCOL
case|:
comment|/* icmp message */
case|case
name|PRC_UNREACH_PORT
case|:
case|case
name|PRC_MSGSIZE
case|:
block|{
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|rdp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|NULL
argument_list|,
name|pkt
operator|->
name|rh_sport
argument_list|,
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|pkt
operator|->
name|rh_dport
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdpcb
condition|)
block|{
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
name|rdp_close
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_UNREACH_HOST
case|:
block|{
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|rdp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|NULL
argument_list|,
name|pkt
operator|->
name|rh_sport
argument_list|,
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|pkt
operator|->
name|rh_dport
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdpcb
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|rdpcb
operator|->
name|r_inpcb
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
condition|)
name|advise_user
argument_list|(
name|so
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
block|{
name|so
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
name|rdp_close
argument_list|(
name|rdpcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PRC_GWDOWN
case|:
name|in_gdown
argument_list|(
operator|&
name|rdp
argument_list|,
operator|(
name|u_long
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_REDIRECT_NET
case|:
comment|/* icmp message */
case|case
name|PRC_REDIRECT_HOST
case|:
block|{
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|rdp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|NULL
argument_list|,
name|pkt
operator|->
name|rh_sport
argument_list|,
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|pkt
operator|->
name|rh_dport
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdpcb
condition|)
name|icmp_redirect_inp
argument_list|(
name|rdpcb
operator|->
name|r_inpcb
argument_list|,
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
argument_list|,
name|prc_code
operator|==
name|PRC_REDIRECT_NET
condition|?
name|rtnet
else|:
name|rthost
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRC_TIMXCEED_INTRANS
case|:
comment|/* icmp message */
case|case
name|PRC_TIMXCEED_REASS
case|:
case|case
name|PRC_PARAMPROB
case|:
break|break;
case|case
name|PRC_QUENCH
case|:
comment|/* icmp message */
comment|/* 	     * Reduce the traffic on this connection, so the gateway is happy. 	     * Since can't change message size, must change frequency.  If continue 	     * to send it straight out in response to write(2), can only tweak 	     * retransmission period. 	     * 	     * This will allow the gateway to relax until things flow again and we 	     * calculate another round trip time. 	     */
block|{
name|RDPHDR
modifier|*
name|pkt
decl_stmt|;
name|RDPCB
modifier|*
name|rdpcb
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|pkt
operator|=
operator|(
name|RDPHDR
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|rdpcb
operator|=
operator|(
name|RDPCB
operator|*
operator|)
name|rdp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|NULL
argument_list|,
name|pkt
operator|->
name|rh_sport
argument_list|,
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|pkt
operator|->
name|rh_dport
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdpcb
condition|)
name|rdpcb
operator|->
name|r_rxmitime
operator|=
name|MIN
argument_list|(
name|rdpcb
operator|->
name|r_rxmitime
operator|+
literal|1
argument_list|,
name|RDP_tvRXMAX
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRC_IFDOWN
case|:
block|{
name|u_long
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|arg
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|inpcb_notify
argument_list|(
operator|&
name|rdp
argument_list|,
name|addr
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|inpcb_notify
argument_list|(
operator|&
name|rdp
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRC_HOSTDEAD
case|:
comment|/* from imp interface */
case|case
name|PRC_HOSTUNREACH
case|:
comment|/* 	     * get same message for destination hosts and gateways. 	     */
block|{
name|u_long
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|arg
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|in_gdown
argument_list|(
operator|&
name|rdp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|inpcb_notify
argument_list|(
operator|&
name|rdp
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"rdp_ctlinput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

