begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1984, 1985, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)spp_usrreq.c	7.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/tcp_fsm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/tcp_timer.h"
end_include

begin_include
include|#
directive|include
file|"ns.h"
end_include

begin_include
include|#
directive|include
file|"ns_pcb.h"
end_include

begin_include
include|#
directive|include
file|"idp.h"
end_include

begin_include
include|#
directive|include
file|"idp_var.h"
end_include

begin_include
include|#
directive|include
file|"ns_error.h"
end_include

begin_include
include|#
directive|include
file|"sp.h"
end_include

begin_include
include|#
directive|include
file|"spidp.h"
end_include

begin_include
include|#
directive|include
file|"spp_var.h"
end_include

begin_include
include|#
directive|include
file|"spp_debug.h"
end_include

begin_comment
comment|/*  * SP protocol implementation.  */
end_comment

begin_macro
name|spp_init
argument_list|()
end_macro

begin_block
block|{
name|spp_iss
operator|=
literal|1
expr_stmt|;
comment|/* WRONG !! should fish it out of TODR */
block|}
end_block

begin_decl_stmt
name|struct
name|spidp
name|spp_savesi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|traceallspps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sppconsdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spp_hardnosed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spp_use_delack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|spp_input
argument_list|(
name|m
argument_list|,
name|nsp
argument_list|,
name|ifp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|short
name|ostate
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nsp
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"No nspcb in spp_input\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|spp_istat
operator|.
name|hdrops
operator|++
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
block|}
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|so
operator|=
name|nsp
operator|->
name|nsp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
block|{
name|ostate
operator|=
name|cb
operator|->
name|s_state
expr_stmt|;
name|spp_savesi
operator|=
operator|*
name|si
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
literal|0
condition|)
block|{
name|spp_istat
operator|.
name|nonucn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * This is ugly, but .... 		 * 		 * Mark socket as temporary until we're 		 * committed to keeping it.  The code at 		 * ``drop'' and ``dropwithreset'' check the 		 * flag dropsocket to see if the temporary 		 * socket created here should be discarded. 		 * We mark the socket as discardable until 		 * we're committed to it below in TCPS_LISTEN. 		 */
name|dropsocket
operator|++
expr_stmt|;
name|nsp
operator|=
operator|(
expr|struct
name|nspcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|nsp
operator|->
name|nsp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
comment|/* 	 * Packet received on connection. 	 * reset idle time and keep-alive timer; 	 */
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
switch|switch
condition|(
name|cb
operator|->
name|s_state
condition|)
block|{
case|case
name|TCPS_LISTEN
case|:
block|{
name|struct
name|mbuf
modifier|*
name|am
decl_stmt|;
specifier|register
name|struct
name|sockaddr_ns
modifier|*
name|sns
decl_stmt|;
name|struct
name|ns_addr
name|laddr
decl_stmt|;
comment|/* 		 * If somebody here was carying on a conversation 		 * and went away, and his pen pal thinks he can 		 * still talk, we get the misdirected packet. 		 */
if|if
condition|(
name|spp_hardnosed
operator|&&
operator|(
name|si
operator|->
name|si_did
operator|!=
literal|0
operator|||
name|si
operator|->
name|si_seq
operator|!=
literal|0
operator|)
condition|)
block|{
name|spp_istat
operator|.
name|gonawy
operator|++
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|am
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
name|am
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
expr_stmt|;
name|sns
operator|=
name|mtod
argument_list|(
name|am
argument_list|,
expr|struct
name|sockaddr_ns
operator|*
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_family
operator|=
name|AF_NS
expr_stmt|;
name|sns
operator|->
name|sns_addr
operator|=
name|si
operator|->
name|si_sna
expr_stmt|;
name|laddr
operator|=
name|nsp
operator|->
name|nsp_laddr
expr_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
name|laddr
argument_list|)
condition|)
name|nsp
operator|->
name|nsp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
if|if
condition|(
name|ns_pcbconnect
argument_list|(
name|nsp
argument_list|,
name|am
argument_list|)
condition|)
block|{
name|nsp
operator|->
name|nsp_laddr
operator|=
name|laddr
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|spp_istat
operator|.
name|noconn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|spp_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* committed to socket */
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
define|#
directive|define
name|THREEWAYSHAKE
ifdef|#
directive|ifdef
name|THREEWAYSHAKE
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|TCPT_REXMT
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|2
operator|*
name|TCPTV_MIN
expr_stmt|;
block|}
break|break;
comment|/* 	 * This state means that we have heard a response 	 * to our acceptance of their connection 	 * It is probably logically unnecessary in this 	 * implementation. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spp_istat
operator|.
name|wrncon
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
endif|#
directive|endif
name|nsp
operator|->
name|nsp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
break|break;
comment|/* 	 * This state means that we have gotten a response 	 * to our attempt to establish a connection. 	 * We fill in the data from the other side, 	 * telling us which port to respond to, instead of the well- 	 * known one we might have sent to in the first place. 	 * We also require that this is a response to our 	 * connection id. 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spp_istat
operator|.
name|notme
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_dport
operator|=
name|nsp
operator|->
name|nsp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_AK
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_INPUT
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
name|spp_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
if|if
condition|(
name|dropsocket
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|NS_ERR_NOSOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|bad
label|:
if|if
condition|(
name|cb
operator|==
literal|0
operator|||
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This is structurally similar to the tcp reassembly routine  * but its function is somewhat different:  It merely queues  * packets up, and suppresses duplicates.  */
end_comment

begin_expr_stmt
name|spp_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
specifier|register
expr|struct
name|sppcb
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|spidp
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spidp_q
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|so
operator|->
name|so_rcv
operator|)
decl_stmt|;
name|char
name|packetp
init|=
name|cb
operator|->
name|s_flags
operator|&
name|SF_HI
decl_stmt|;
name|char
name|wakeup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|si
operator|==
name|SI
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|present
goto|;
comment|/* 	 * Update our news from them. 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SA
condition|)
name|cb
operator|->
name|s_flags
operator||=
operator|(
name|spp_use_delack
condition|?
name|SF_DELACK
else|:
name|SF_AK
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
comment|/* 		 * If there are other packets outstanding, 		 * restart the timer for them. 		 */
if|if
condition|(
name|SSEQ_GEQ
argument_list|(
name|cb
operator|->
name|s_snt
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
condition|)
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|tcp_beta
operator|*
name|cb
operator|->
name|s_srtt
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If transmit timer is running and timed sequence 		 * number was acked, update smoothed round trip time. 		 */
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|&&
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rtseq
argument_list|)
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_srtt
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
expr_stmt|;
else|else
name|cb
operator|->
name|s_srtt
operator|=
name|tcp_alpha
operator|*
name|cb
operator|->
name|s_srtt
operator|+
operator|(
literal|1
operator|-
name|tcp_alpha
operator|)
operator|*
name|cb
operator|->
name|s_rtt
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_alo
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If this is a system packet, we don't need to 	 * queue it up, and won't update acknowledge # 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If this packet number has a sequence number less 	 * than that of the first packet not yet seen coming 	 * from them, this must be a duplicate, so drop. 	 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_ack
argument_list|)
condition|)
block|{
name|spp_istat
operator|.
name|bdreas
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
operator|-
literal|1
condition|)
name|spp_istat
operator|.
name|lstdup
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If this packet number is higher than that which 	 * we have allocated refuse it, unless urgent 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
operator|+
literal|60
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|NS_ERR_FULLUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else queue this packet; */
block|}
else|else
block|{
name|spp_istat
operator|.
name|notyet
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Loop through all packets queued up to insert in 	 * appropriate sequence. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*duplicate */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
argument_list|)
condition|)
break|break;
block|}
name|insque
argument_list|(
name|si
argument_list|,
name|q
operator|->
name|si_prev
argument_list|)
expr_stmt|;
comment|/* 	 * If this packet is urgent, inform process 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
name|cb
operator|->
name|s_iobc
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|si
operator|)
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
index|]
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_IOOB
expr_stmt|;
block|}
name|present
label|:
define|#
directive|define
name|SPINC
value|sizeof(struct sphdr)
comment|/* 	 * Loop through all packets queued up to update acknowledge 	 * number, and present all acknowledged data to user; 	 * If in packet interface mode, show packet headers. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
condition|)
block|{
name|cb
operator|->
name|s_ack
operator|++
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_IOOB
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_cc
condition|)
name|so
operator|->
name|so_oobmark
operator|=
name|sb
operator|->
name|sb_cc
expr_stmt|;
else|else
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
block|}
name|q
operator|=
name|q
operator|->
name|si_prev
expr_stmt|;
name|remque
argument_list|(
name|q
operator|->
name|si_next
argument_list|)
expr_stmt|;
name|wakeup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|packetp
condition|)
block|{
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_rhdr
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|sbappend
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|wakeup
condition|)
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|spp_ctlinput
argument_list|(
argument|cmd
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ns_addr
modifier|*
name|na
decl_stmt|;
specifier|extern
name|u_char
name|nsctlerrmap
index|[]
decl_stmt|;
extern|extern spp_abort(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|struct
name|nspcb
modifier|*
name|idp_drop
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|ns_errp
modifier|*
name|errp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_ns
modifier|*
name|sns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return;
end_if

begin_expr_stmt
name|type
operator|=
name|NS_ERR_UNREACH_HOST
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_ROUTEDEAD
case|:
case|case
name|PRC_QUENCH
case|:
break|break;
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
case|case
name|PRC_HOSTUNREACH
case|:
name|sns
operator|=
operator|(
expr|struct
name|sockaddr_ns
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sns
operator|->
name|sns_family
operator|!=
name|AF_NS
condition|)
return|return;
name|na
operator|=
operator|&
name|sns
operator|->
name|sns_addr
expr_stmt|;
break|break;
default|default:
name|errp
operator|=
operator|(
expr|struct
name|ns_errp
operator|*
operator|)
name|arg
expr_stmt|;
name|na
operator|=
operator|&
name|errp
operator|->
name|ns_err_idp
operator|.
name|idp_dna
expr_stmt|;
name|type
operator|=
name|errp
operator|->
name|ns_err_num
expr_stmt|;
name|type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|type
argument_list|)
expr_stmt|;
block|}
end_switch

begin_switch
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NS_ERR_UNREACH_HOST
case|:
name|ns_pcbnotify
argument_list|(
name|na
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|spp_abort
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ERR_TOO_BIG
case|:
case|case
name|NS_ERR_NOSOCK
case|:
name|nsp
operator|=
name|ns_pcblookup
argument_list|(
name|na
argument_list|,
name|errp
operator|->
name|ns_err_idp
operator|.
name|idp_sna
operator|.
name|x_port
argument_list|,
name|NS_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
condition|)
block|{
if|if
condition|(
name|nsp
operator|->
name|nsp_pcb
condition|)
operator|(
name|void
operator|)
name|spp_drop
argument_list|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|idp_drop
argument_list|(
name|nsp
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_switch

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_expr_stmt
unit|int
name|spp_fixmtu
argument_list|(
name|nsp
argument_list|)
specifier|register
expr|struct
name|nspcb
operator|*
name|nsp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
init|=
operator|(
expr|struct
name|sppcb
operator|*
operator|)
operator|(
name|nsp
operator|->
name|nsp_pcb
operator|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
decl_stmt|;
name|struct
name|ns_errp
modifier|*
name|ep
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|badseq
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|firstbad
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
name|cb
condition|)
block|{
comment|/*  		 * The notification that we have sent 		 * too much is bad news -- we will 		 * have to go through queued up so far 		 * splitting ones which are too big and 		 * reassigning sequence numbers and checksums. 		 * we should then retransmit all packets from 		 * one above the offending packet to the last one 		 * we had sent (or our allocation) 		 * then the offending one so that the any queued 		 * data at our destination will be discarded. 		 */
name|ep
operator|=
operator|(
expr|struct
name|ns_errp
operator|*
operator|)
name|nsp
operator|->
name|nsp_notify_param
expr_stmt|;
name|sb
operator|=
operator|&
name|nsp
operator|->
name|nsp_socket
operator|->
name|so_snd
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ep
operator|->
name|ns_err_param
expr_stmt|;
name|badseq
operator|=
name|SI
argument_list|(
operator|&
name|ep
operator|->
name|ns_err_idp
argument_list|)
operator|->
name|si_seq
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|badseq
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|firstbad
operator|=
name|m
expr_stmt|;
comment|/*for (;;) {*/
comment|/* calculate length */
for|for
control|(
name|m0
operator|=
name|m
operator|,
name|len
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cb
operator|->
name|s_mtu
condition|)
block|{ 			}
comment|/* FINISH THIS 		} */
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|spp_output_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m0
argument_list|)
specifier|register
expr|struct
name|sppcb
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
init|=
operator|(
expr|struct
name|spidp
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|so
operator|->
name|so_snd
operator|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_short
name|lookfor
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
specifier|extern
name|int
name|idpcksum
decl_stmt|;
if|if
condition|(
name|m0
condition|)
block|{
name|int
name|mtu
init|=
name|cb
operator|->
name|s_mtu
decl_stmt|;
name|int
name|datalen
decl_stmt|;
comment|/* 		 * Make sure that packet isn't too big. 		 */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|mprev
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|datalen
operator|=
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|?
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
else|:
name|len
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|mtu
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
else|else
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|oldEM
init|=
name|cb
operator|->
name|s_cc
operator|&
name|SP_EM
decl_stmt|;
name|cb
operator|->
name|s_cc
operator|&=
operator|~
name|SP_EM
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|mtu
condition|)
block|{
name|m
operator|=
name|m_copy
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad_copy
goto|;
block|}
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bad_copy
label|:
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m0
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|len
operator|-=
name|mtu
expr_stmt|;
block|}
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
block|}
block|}
comment|/* 		 * Force length even, by adding a "garbage byte" if 		 * necessary. 		 */
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|m
operator|=
name|mprev
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|+
name|m
operator|->
name|m_off
operator|<
name|MMAXOFF
condition|)
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
name|m1
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m1
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
name|m1
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 * Long align so prepended ip headers will work on Gould. 		 */
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
operator|-
literal|2
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
operator|*
name|si
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|)
block|{
specifier|register
name|struct
name|sphdr
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
name|sh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_dt
operator|=
name|sh
operator|->
name|sp_dt
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|sh
operator|->
name|sp_cc
operator|&
name|SP_EM
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 			 * Per jqj@cornell: 			 * make sure OB packets convey exactly 1 byte. 			 * If the packet is 1 byte or larger, we 			 * have already guaranted there to be at least 			 * one garbage byte for the checksum, and 			 * extra bytes shouldn't hurt! 			 */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SP_OB
expr_stmt|;
name|len
operator|=
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * queue stuff up for output 		 */
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_seq
operator|++
expr_stmt|;
block|}
comment|/* 	 * update window 	 */
block|{
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb2
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|int
name|credit
init|=
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|sb2
operator|->
name|sb_mbmax
operator|)
operator|-
operator|(
name|int
operator|)
name|sb2
operator|->
name|sb_mbcnt
operator|)
operator|/
operator|(
operator|(
name|short
operator|)
name|cb
operator|->
name|s_mtu
operator|)
operator|)
decl_stmt|;
name|int
name|alo
init|=
name|cb
operator|->
name|s_ack
operator|+
operator|(
name|credit
operator|>
literal|0
condition|?
name|credit
else|:
literal|0
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_alo
operator|<
name|alo
condition|)
block|{
comment|/* If the amount we are raising the window 			   is more than his remaining headroom, tell 			   him about it.  In particular, if he is at 			   his limit, any amount at all will do! */
name|u_short
name|raise
init|=
name|alo
operator|-
name|cb
operator|->
name|s_alo
decl_stmt|;
name|u_short
name|headroom
init|=
literal|1
operator|+
name|cb
operator|->
name|s_alo
operator|-
name|cb
operator|->
name|s_ack
decl_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|headroom
argument_list|,
name|raise
argument_list|)
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|SF_AK
expr_stmt|;
name|cb
operator|->
name|s_alo
operator|=
name|alo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 		 * must transmit this out of band packet 		 */
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_SOOB
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Decide what to transmit: 		 * If it is time to retransmit a packet, 		 * send that. 		 * If we have a new packet, send that 		 * (So long as it is in our allocation) 		 * Otherwise, see if it time to bang on them 		 * to ask for our current allocation. 		 */
if|if
condition|(
name|cb
operator|->
name|s_force
operator|==
operator|(
literal|1
operator|+
name|TCPT_REXMT
operator|)
condition|)
block|{
name|lookfor
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snt
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
block|{
name|lookfor
operator|=
name|cb
operator|->
name|s_snt
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|cb
operator|->
name|s_seq
argument_list|)
condition|)
block|{
name|lookfor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
comment|/* tcp has cb->s_rxtshift = 0; here */
block|}
block|}
name|m
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_WAIT
operator|)
operator|||
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
condition|)
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sbdroprecord
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|si
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|lookfor
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|si
operator|&&
operator|(
name|si
operator|->
name|si_seq
operator|!=
name|lookfor
operator|)
condition|)
name|si
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|->
name|s_want
operator|=
name|lookfor
expr_stmt|;
if|if
condition|(
name|si
condition|)
block|{
comment|/* 		 * must make a copy of this packet for 		 * idp_output to monkey with 		 */
name|m
operator|=
name|m_copy
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m0
operator|=
name|m
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
name|cb
operator|->
name|s_flags
operator|&
name|SF_AK
condition|)
block|{
comment|/* 		 * Must send an acknowledgement or a probe 		 */
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
operator|*
name|si
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|cb
operator|->
name|s_snt
operator|+
literal|1
expr_stmt|;
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SP_SP
expr_stmt|;
block|}
comment|/* 	 * Stuff checksum and output datagram. 	 */
if|if
condition|(
name|si
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
operator|(
name|SF_AK
operator||
name|SF_DELACK
operator|)
condition|)
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_AK
operator||
name|SF_DELACK
operator|)
expr_stmt|;
comment|/* 		 * If we are almost out of allocation 		 * or one of the timers has gone off 		 * request an ack. 		 */
if|if
condition|(
name|SSEQ_GEQ
argument_list|(
name|cb
operator|->
name|s_seq
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_force
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If this is a new packet (and not a system packet), 		 * and we are not currently timing anything, 		 * time this one and ask for an ack. 		 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snt
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
operator|)
operator|)
condition|)
block|{
name|cb
operator|->
name|s_snt
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_rtseq
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
block|}
comment|/* 			 * If the retransmit timer has not been set 			 * and this is a real packet 			 * then start the retransmit timer 			 */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|==
literal|0
condition|)
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|tcp_beta
operator|*
name|cb
operator|->
name|s_srtt
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_seq
operator|=
name|htons
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_alo
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|idpcksum
condition|)
block|{
name|si
operator|->
name|si_sum
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
name|si
operator|->
name|si_sum
operator|=
name|ns_cksum
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|si
operator|->
name|si_sum
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spp_output_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
condition|)
name|error
operator|=
name|ns_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
literal|0
argument_list|,
name|NS_ROUTETOIF
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ns_output
argument_list|(
name|m
argument_list|,
operator|&
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_route
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceallspps
operator|&&
name|sppconsdebug
condition|)
block|{
name|printf
argument_list|(
literal|"spp_out: %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|spp_ctloutput
argument_list|(
argument|req
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|name
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|level
operator|!=
name|NSPROTO_SPP
condition|)
block|{
comment|/* This will have to be changed when we do more general 		   stacking of protocols */
return|return
operator|(
name|idp_ctloutput
argument_list|(
name|req
argument_list|,
name|so
argument_list|,
name|level
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
else|else
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRCO_GETOPT
case|:
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|get_flags
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|get_flags
label|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_flags
operator|&
name|mask
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_mtu
expr_stmt|;
break|break;
case|case
name|SO_LAST_HEADER
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_rhdr
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_shdr
operator|.
name|si_s
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|*
name|value
operator|=
name|m
expr_stmt|;
break|break;
case|case
name|PRCO_SETOPT
case|:
if|if
condition|(
name|value
operator|==
literal|0
operator|||
operator|*
name|value
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|name
condition|)
block|{
name|int
modifier|*
name|ok
decl_stmt|;
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|set_head
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|set_head
label|:
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|ok
operator|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ok
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|mask
expr_stmt|;
else|else
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|cb
operator|->
name|s_mtu
operator|=
operator|*
operator|(
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
block|{
specifier|register
name|struct
name|sphdr
modifier|*
name|sp
init|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
decl_stmt|;
name|cb
operator|->
name|s_dt
operator|=
name|sp
operator|->
name|sp_dt
expr_stmt|;
name|cb
operator|->
name|s_cc
operator|=
name|sp
operator|->
name|sp_cc
operator|&
name|SP_EM
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|m_freem
argument_list|(
operator|*
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|release
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|spp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ostate
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_CONTROL
condition|)
return|return
operator|(
name|ns_control
argument_list|(
name|so
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|,
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|rights
argument_list|)
operator|)
return|;
if|if
condition|(
name|rights
operator|&&
name|rights
operator|->
name|m_len
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|else
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|ostate
operator|=
name|cb
condition|?
name|cb
operator|->
name|s_state
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|nsp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ns_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|nspcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
literal|2048
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|nsp
operator|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_PCB
argument_list|)
decl_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sppcb
operator|*
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
name|cb
operator|->
name|s_snt
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_q
operator|.
name|si_next
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_prev
operator|=
operator|&
name|cb
operator|->
name|s_q
expr_stmt|;
name|cb
operator|->
name|s_nspcb
operator|=
name|nsp
expr_stmt|;
name|nsp
operator|->
name|nsp_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|cb
expr_stmt|;
block|}
break|break;
case|case
name|PRU_DETACH
case|:
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cb
operator|->
name|s_state
operator|>
name|TCPS_LISTEN
condition|)
name|cb
operator|=
name|spp_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
else|else
name|cb
operator|=
name|spp_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|nsp
operator|->
name|nsp_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
break|break;
comment|/* 	 * Initiate connection to peer. 	 * Enter SYN_SENT state, and mark socket as connecting. 	 * Start keep-alive timer, setup prototype header, 	 * Send initial system packet requesting connection. 	 */
case|case
name|PRU_CONNECT
case|:
if|if
condition|(
name|nsp
operator|->
name|nsp_lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
name|ns_pcbconnect
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
literal|0
expr_stmt|;
name|spp_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|TCPTV_KEEP
expr_stmt|;
comment|/* 		 * Other party is required to respond to 		 * the port I send from, but he is not 		 * required to answer from where I am sending to, 		 * so allow wildcarding. 		 * original port I am sending to is still saved in 		 * cb->s_dport. 		 */
name|nsp
operator|->
name|nsp_fport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
comment|/* 	 * We may decide later to implement connection closing 	 * handshaking at the spp level optionally. 	 * here is the hook to do it: 	 */
case|case
name|PRU_DISCONNECT
case|:
name|cb
operator|=
name|spp_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Accept a connection.  Essentially all the work is 	 * done at higher levels; just return the address 	 * of the peer, storing through addr. 	 */
case|case
name|PRU_ACCEPT
case|:
block|{
name|struct
name|sockaddr_ns
modifier|*
name|sns
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_ns
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_family
operator|=
name|AF_NS
expr_stmt|;
name|sns
operator|->
name|sns_addr
operator|=
name|nsp
operator|->
name|nsp_faddr
expr_stmt|;
break|break;
block|}
case|case
name|PRU_SHUTDOWN
case|:
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|spp_usrclosed
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * After a receive, possibly send acknowledgment 	 * updating allocation. 	 */
case|case
name|PRU_RCVD
case|:
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
operator|(
name|void
operator|)
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SENSE
case|:
case|case
name|PRU_CONTROL
case|:
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|PRU_RCVOOB
case|:
if|if
condition|(
operator|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_IOOB
operator|)
operator|||
name|so
operator|->
name|so_oobmark
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_RCVATMARK
operator|)
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|=
name|cb
operator|->
name|s_iobc
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|PRU_SENDOOB
case|:
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|-
literal|512
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_SOOB
expr_stmt|;
comment|/* fall into */
case|case
name|PRU_SEND
case|:
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PRU_SOCKADDR
case|:
name|ns_setsockaddr
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_PEERADDR
case|:
name|ns_setpeeraddr
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SLOWTIMO
case|:
name|cb
operator|=
name|spp_timers
argument_list|(
name|cb
argument_list|,
operator|(
name|int
operator|)
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_FASTTIMO
case|:
case|case
name|PRU_PROTORCV
case|:
case|case
name|PRU_PROTOSEND
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"sp_usrreq"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
operator|)
condition|)
name|spp_trace
argument_list|(
name|SA_USER
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|(
expr|struct
name|spidp
operator|*
operator|)
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|spp_usrreq_sp
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
name|spp_usrreq
argument_list|(
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|rights
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_ATTACH
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
operator|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
operator|)
operator|->
name|s_flags
operator||=
operator|(
name|SF_HI
operator||
name|SF_HO
operator||
name|SF_PI
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create template to be used to send spp packets on a connection.  * Called after host entry created, fills  * in a skeletal spp header (choosing connection id),  * minimizing the amount of work necessary when the connection is used.  */
end_comment

begin_macro
name|spp_template
argument_list|(
argument|cb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|cb
operator|->
name|s_nspcb
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|n
init|=
operator|&
operator|(
name|cb
operator|->
name|s_shdr
operator|)
decl_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
literal|576
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|n
operator|->
name|si_pt
operator|=
name|NSPROTO_SPP
expr_stmt|;
name|n
operator|->
name|si_sna
operator|=
name|nsp
operator|->
name|nsp_laddr
expr_stmt|;
name|n
operator|->
name|si_dna
operator|=
name|nsp
operator|->
name|nsp_faddr
expr_stmt|;
name|n
operator|->
name|si_sid
operator|=
name|htons
argument_list|(
name|spp_iss
argument_list|)
expr_stmt|;
name|spp_iss
operator|+=
name|SPP_ISSINCR
operator|/
literal|2
expr_stmt|;
name|n
operator|->
name|si_alo
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Close a SPIP control block:  *	discard spp control block itself  *	discard ns protocol control block  *	wake up any sleepers  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_close
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|struct
name|spidp_q
modifier|*
name|s
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|cb
operator|->
name|s_nspcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|nsp
operator|->
name|nsp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|s
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|&
operator|(
name|cb
operator|->
name|s_q
operator|)
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|si_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|->
name|nsp_pcb
operator|=
literal|0
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ns_pcbdetach
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Someday we may do level 3 handshaking  *	to close a connection or send a xerox style error.  *	For now, just close.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_usrclosed
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sppcb
modifier|*
name|spp_disconnect
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop connection, reporting  * the specified error.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_drop
parameter_list|(
name|cb
parameter_list|,
name|errno
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
comment|/* 	 * someday, in the xerox world 	 * we will generate error protocol packets 	 * announcing that the socket has gone away. 	 */
comment|/*if (TCPS_HAVERCVDSYN(tp->t_state)) { 		tp->t_state = TCPS_CLOSED; 		(void) tcp_output(tp); 	}*/
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|spp_abort
argument_list|(
argument|nsp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|spp_close
argument_list|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
specifier|register
expr|struct
name|sppcb
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*if (cb->s_timer[TCPT_REXMT]) 		panic("spp_output REXMT");*/
comment|/* 	 * Start/restart persistance timer. 	 */
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_PERSIST
index|]
argument_list|,
operator|(
call|(
name|int
call|)
argument_list|(
name|tcp_beta
operator|*
name|cb
operator|->
name|s_srtt
argument_list|)
operator|)
operator|<<
name|cb
operator|->
name|s_rxtshift
argument_list|,
name|TCPTV_PERSMIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>=
name|TCP_MAXRXTSHIFT
condition|)
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fast timeout routine for processing delayed acks  */
end_comment

begin_decl_stmt
name|int
name|spp_ftcnt
decl_stmt|;
end_decl_stmt

begin_macro
name|spp_fasttimo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|nsp
operator|=
name|nspcb
operator|.
name|nsp_next
expr_stmt|;
name|spp_ftcnt
operator|++
expr_stmt|;
if|if
condition|(
name|nsp
condition|)
for|for
control|(
init|;
name|nsp
operator|!=
operator|&
name|nspcb
condition|;
name|nsp
operator|=
name|nsp
operator|->
name|nsp_next
control|)
if|if
condition|(
operator|(
name|cb
operator|=
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_DELACK
operator|)
condition|)
block|{
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_DELACK
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_AK
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * spp protocol timeout routine called every 500 ms.  * Updates the timers in all active pcb's and  * causes finite state machine actions if timers expire.  */
end_comment

begin_macro
name|spp_slowtimo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|ip
decl_stmt|,
modifier|*
name|ipnxt
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Search through tcb's and update active timers. 	 */
name|ip
operator|=
name|nspcb
operator|.
name|nsp_next
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ip
operator|!=
operator|&
name|nspcb
condition|)
block|{
name|cb
operator|=
name|nstosppcb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ipnxt
operator|=
name|ip
operator|->
name|nsp_next
expr_stmt|;
if|if
condition|(
name|cb
operator|==
literal|0
condition|)
goto|goto
name|tpgone
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TCPT_NTIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|&&
operator|--
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|spp_usrreq
argument_list|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
argument_list|,
name|PRU_SLOWTIMO
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipnxt
operator|->
name|nsp_prev
operator|!=
name|ip
condition|)
goto|goto
name|tpgone
goto|;
block|}
block|}
name|cb
operator|->
name|s_idle
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
name|cb
operator|->
name|s_rtt
operator|++
expr_stmt|;
name|tpgone
label|:
name|ip
operator|=
name|ipnxt
expr_stmt|;
block|}
name|spp_iss
operator|+=
name|SPP_ISSINCR
operator|/
name|PR_SLOWHZ
expr_stmt|;
comment|/* increment iss */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|float
name|spp_backoff
index|[
name|TCP_MAXRXTSHIFT
index|]
init|=
block|{
literal|1.0
block|,
literal|1.2
block|,
literal|1.4
block|,
literal|1.7
block|,
literal|2.0
block|,
literal|3.0
block|,
literal|5.0
block|,
literal|8.0
block|,
literal|16.0
block|,
literal|32.0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sppexprexmtbackoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SPP timer processing.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_timers
parameter_list|(
name|cb
parameter_list|,
name|timer
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|timer
decl_stmt|;
block|{
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|timer
expr_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
comment|/* 	 * 2 MSL timeout in shutdown went off.  Delete connection 	 * control block. 	 */
case|case
name|TCPT_2MSL
case|:
name|cb
operator|=
name|spp_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Retransmission timer went off.  Message has not 	 * been acked within retransmit interval.  Back off 	 * to a longer retransmit interval and retransmit all 	 * unacknowledged messages in the window. 	 */
case|case
name|TCPT_REXMT
case|:
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>
name|TCP_MAXRXTSHIFT
condition|)
block|{
name|cb
operator|=
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|->
name|s_srtt
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sppexprexmtbackoff
condition|)
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|<<
name|cb
operator|->
name|s_rxtshift
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TCPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
argument_list|,
name|cb
operator|->
name|s_timer
index|[
name|TCPT_REXMT
index|]
operator|*
name|spp_backoff
index|[
name|cb
operator|->
name|s_rxtshift
operator|-
literal|1
index|]
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_MAX
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Persistance timer into zero window. 	 * Force a probe to be sent. 	 */
case|case
name|TCPT_PERSIST
case|:
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Keep-alive timer went off; send something 	 * or drop connection if idle for too long. 	 */
case|case
name|TCPT_KEEP
case|:
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_idle
operator|>=
name|TCPTV_MAXIDLE
condition|)
goto|goto
name|dropit
goto|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP
expr_stmt|;
break|break;
name|dropit
label|:
name|cb
operator|=
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|cb
operator|)
return|;
block|}
end_function

end_unit

