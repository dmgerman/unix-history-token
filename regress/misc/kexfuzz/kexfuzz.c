begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	$OpenBSD: kexfuzz.c,v 1.3 2016/10/11 21:49:54 djm Exp $ */
end_comment

begin_comment
comment|/*  * Fuzz harness for KEX code  *  * Placed in the public domain  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ssherr.h"
end_include

begin_include
include|#
directive|include
file|"ssh_api.h"
end_include

begin_include
include|#
directive|include
file|"sshbuf.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"myproposal.h"
end_include

begin_include
include|#
directive|include
file|"authfile.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_decl_stmt
name|struct
name|ssh
modifier|*
name|active_state
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX - needed for linking */
end_comment

begin_function_decl
name|void
name|kex_tests
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|do_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|direction
block|{
name|S2C
block|,
name|C2S
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hook_ctx
block|{
name|struct
name|ssh
modifier|*
name|client
decl_stmt|,
modifier|*
name|server
decl_stmt|,
modifier|*
name|server2
decl_stmt|;
name|int
modifier|*
name|c2s
decl_stmt|,
modifier|*
name|s2c
decl_stmt|;
name|int
name|trigger_direction
decl_stmt|,
name|packet_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|dump_path
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|replace_data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|packet_hook
parameter_list|(
name|struct
name|ssh
modifier|*
name|ssh
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|packet
parameter_list|,
name|u_char
modifier|*
name|typep
parameter_list|,
name|void
modifier|*
name|_ctx
parameter_list|)
block|{
name|struct
name|hook_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|hook_ctx
operator|*
operator|)
name|_ctx
decl_stmt|;
name|int
name|mydirection
init|=
name|ssh
operator|==
name|ctx
operator|->
name|client
condition|?
name|S2C
else|:
name|C2S
decl_stmt|;
name|int
modifier|*
name|packet_count
init|=
name|mydirection
operator|==
name|S2C
condition|?
name|ctx
operator|->
name|s2c
else|:
name|ctx
operator|->
name|c2s
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|do_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s packet %d type %u:\n"
argument_list|,
name|mydirection
operator|==
name|S2C
condition|?
literal|"s2c"
else|:
literal|"c2s"
argument_list|,
operator|*
name|packet_count
argument_list|,
operator|*
name|typep
argument_list|)
expr_stmt|;
name|sshbuf_dump
argument_list|(
name|packet
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mydirection
operator|==
name|ctx
operator|->
name|trigger_direction
operator|&&
name|ctx
operator|->
name|packet_index
operator|==
operator|*
name|packet_count
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|replace_data
operator|!=
name|NULL
condition|)
block|{
name|sshbuf_reset
argument_list|(
name|packet
argument_list|)
expr_stmt|;
comment|/* Type is first byte of packet */
if|if
condition|(
operator|(
name|r
operator|=
name|sshbuf_get_u8
argument_list|(
name|ctx
operator|->
name|replace_data
argument_list|,
name|typep
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|r
operator|=
name|sshbuf_putb
argument_list|(
name|packet
argument_list|,
name|ctx
operator|->
name|replace_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|do_debug
condition|)
block|{
name|printf
argument_list|(
literal|"***** replaced packet type %u\n"
argument_list|,
operator|*
name|typep
argument_list|)
expr_stmt|;
name|sshbuf_dump
argument_list|(
name|packet
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|dump_path
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dumpfile
operator|=
name|fopen
argument_list|(
name|ctx
operator|->
name|dump_path
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fopen %s"
argument_list|,
name|ctx
operator|->
name|dump_path
argument_list|)
expr_stmt|;
comment|/* Write { type, packet } */
if|if
condition|(
name|fwrite
argument_list|(
name|typep
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|dumpfile
argument_list|)
operator|!=
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fwrite type %s"
argument_list|,
name|ctx
operator|->
name|dump_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|sshbuf_len
argument_list|(
name|packet
argument_list|)
operator|!=
literal|0
operator|&&
name|fwrite
argument_list|(
name|sshbuf_ptr
argument_list|(
name|packet
argument_list|)
argument_list|,
name|sshbuf_len
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dumpfile
argument_list|)
operator|!=
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fwrite body %s"
argument_list|,
name|ctx
operator|->
name|dump_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_debug
condition|)
block|{
name|printf
argument_list|(
literal|"***** dumped packet type %u len %zu\n"
argument_list|,
operator|*
name|typep
argument_list|,
name|sshbuf_len
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|dumpfile
argument_list|)
expr_stmt|;
comment|/* No point in continuing */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|packet_count
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_send_and_receive
parameter_list|(
name|struct
name|ssh
modifier|*
name|from
parameter_list|,
name|struct
name|ssh
modifier|*
name|to
parameter_list|)
block|{
name|u_char
name|type
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_packet_next
argument_list|(
name|from
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ssh_packet_next: %s\n"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|buf
operator|=
name|ssh_output_ptr
argument_list|(
name|from
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_input_append
argument_list|(
name|to
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"ssh_input_append: %s"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|ssh_output_consume
argument_list|(
name|from
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"ssh_output_consume: %s"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Minimal test_helper.c scaffholding to make this standalone */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|in_test
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEST_START
parameter_list|(
name|a
parameter_list|)
define|\
value|do { \ 		in_test = (a); \ 		if (do_debug) \ 			fprintf(stderr, "test %s starting\n", in_test); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|TEST_DONE
parameter_list|()
define|\
value|do { \ 		if (do_debug) \ 			fprintf(stderr, "test %s done\n", \ 			    in_test ? in_test : "???"); \ 		in_test = NULL; \ 	} while(0)
end_define

begin_define
define|#
directive|define
name|ASSERT_INT_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do { \ 		if ((int)(a) != (int)(b)) { \ 			fprintf(stderr, "%s %s:%d " \ 			    "%s (%d) != expected %s (%d)\n", \ 			    in_test ? in_test : "(none)", \ 			    __func__, __LINE__, #a, (int)(a), #b, (int)(b)); \ 			exit(2); \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ASSERT_INT_GE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do { \ 		if ((int)(a)< (int)(b)) { \ 			fprintf(stderr, "%s %s:%d " \ 			    "%s (%d)< expected %s (%d)\n", \ 			    in_test ? in_test : "(none)", \ 			    __func__, __LINE__, #a, (int)(a), #b, (int)(b)); \ 			exit(2); \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ASSERT_PTR_NE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do { \ 		if ((a) == (b)) { \ 			fprintf(stderr, "%s %s:%d " \ 			    "%s (%p) != expected %s (%p)\n", \ 			    in_test ? in_test : "(none)", \ 			    __func__, __LINE__, #a, (a), #b, (b)); \ 			exit(2); \ 		} \ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|run_kex
parameter_list|(
name|struct
name|ssh
modifier|*
name|client
parameter_list|,
name|struct
name|ssh
modifier|*
name|server
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|server
operator|->
name|kex
operator|->
name|done
operator|||
operator|!
name|client
operator|->
name|kex
operator|->
name|done
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|do_send_and_receive
argument_list|(
name|server
argument_list|,
name|client
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"do_send_and_receive S2C: %s"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|do_send_and_receive
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"do_send_and_receive C2S: %s"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|do_debug
condition|)
name|printf
argument_list|(
literal|"done: %s\n"
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|server
operator|->
name|kex
operator|->
name|done
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|client
operator|->
name|kex
operator|->
name|done
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_kex_with_key
parameter_list|(
specifier|const
name|char
modifier|*
name|kex
parameter_list|,
name|struct
name|sshkey
modifier|*
name|prvkey
parameter_list|,
name|int
modifier|*
name|c2s
parameter_list|,
name|int
modifier|*
name|s2c
parameter_list|,
name|int
name|direction
parameter_list|,
name|int
name|packet_index
parameter_list|,
specifier|const
name|char
modifier|*
name|dump_path
parameter_list|,
name|struct
name|sshbuf
modifier|*
name|replace_data
parameter_list|)
block|{
name|struct
name|ssh
modifier|*
name|client
init|=
name|NULL
decl_stmt|,
modifier|*
name|server
init|=
name|NULL
decl_stmt|,
modifier|*
name|server2
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|state
decl_stmt|;
name|struct
name|kex_params
name|kex_params
decl_stmt|;
name|char
modifier|*
name|myproposal
index|[
name|PROPOSAL_MAX
index|]
init|=
block|{
name|KEX_CLIENT
block|}
decl_stmt|;
name|char
modifier|*
name|keyname
init|=
name|NULL
decl_stmt|;
name|struct
name|hook_ctx
name|hook_ctx
decl_stmt|;
name|TEST_START
argument_list|(
literal|"sshkey_from_private"
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|sshkey_from_private
argument_list|(
name|prvkey
argument_list|,
operator|&
name|pubkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"ssh_init"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|kex_params
operator|.
name|proposal
argument_list|,
name|myproposal
argument_list|,
sizeof|sizeof
argument_list|(
name|myproposal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kex
operator|!=
name|NULL
condition|)
name|kex_params
operator|.
name|proposal
index|[
name|PROPOSAL_KEX_ALGS
index|]
operator|=
name|strdup
argument_list|(
name|kex
argument_list|)
expr_stmt|;
name|keyname
operator|=
name|strdup
argument_list|(
name|sshkey_ssh_name
argument_list|(
name|prvkey
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_PTR_NE
argument_list|(
name|keyname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kex_params
operator|.
name|proposal
index|[
name|PROPOSAL_SERVER_HOST_KEY_ALGS
index|]
operator|=
name|keyname
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_init
argument_list|(
operator|&
name|client
argument_list|,
literal|0
argument_list|,
operator|&
name|kex_params
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_init
argument_list|(
operator|&
name|server
argument_list|,
literal|1
argument_list|,
operator|&
name|kex_params
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_init
argument_list|(
operator|&
name|server2
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_PTR_NE
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_PTR_NE
argument_list|(
name|server
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_PTR_NE
argument_list|(
name|server2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|hook_ctx
operator|.
name|c2s
operator|=
name|c2s
expr_stmt|;
name|hook_ctx
operator|.
name|s2c
operator|=
name|s2c
expr_stmt|;
name|hook_ctx
operator|.
name|trigger_direction
operator|=
name|direction
expr_stmt|;
name|hook_ctx
operator|.
name|packet_index
operator|=
name|packet_index
expr_stmt|;
name|hook_ctx
operator|.
name|dump_path
operator|=
name|dump_path
expr_stmt|;
name|hook_ctx
operator|.
name|replace_data
operator|=
name|replace_data
expr_stmt|;
name|hook_ctx
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|hook_ctx
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|hook_ctx
operator|.
name|server2
operator|=
name|server2
expr_stmt|;
name|ssh_packet_set_input_hook
argument_list|(
name|client
argument_list|,
name|packet_hook
argument_list|,
operator|&
name|hook_ctx
argument_list|)
expr_stmt|;
name|ssh_packet_set_input_hook
argument_list|(
name|server
argument_list|,
name|packet_hook
argument_list|,
operator|&
name|hook_ctx
argument_list|)
expr_stmt|;
name|ssh_packet_set_input_hook
argument_list|(
name|server2
argument_list|,
name|packet_hook
argument_list|,
operator|&
name|hook_ctx
argument_list|)
expr_stmt|;
name|TEST_START
argument_list|(
literal|"ssh_add_hostkey"
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_add_hostkey
argument_list|(
name|server
argument_list|,
name|prvkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_add_hostkey
argument_list|(
name|client
argument_list|,
name|pubkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"kex"
argument_list|)
expr_stmt|;
name|run_kex
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"rekeying client"
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|kex_send_kexinit
argument_list|(
name|client
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_kex
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"rekeying server"
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|kex_send_kexinit
argument_list|(
name|server
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_kex
argument_list|(
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"ssh_packet_get_state"
argument_list|)
expr_stmt|;
name|state
operator|=
name|sshbuf_new
argument_list|()
expr_stmt|;
name|ASSERT_PTR_NE
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_packet_get_state
argument_list|(
name|server
argument_list|,
name|state
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_INT_GE
argument_list|(
name|sshbuf_len
argument_list|(
name|state
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"ssh_packet_set_state"
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|ssh_add_hostkey
argument_list|(
name|server2
argument_list|,
name|prvkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kex_free
argument_list|(
name|server2
operator|->
name|kex
argument_list|)
expr_stmt|;
comment|/* XXX or should ssh_packet_set_state()? */
name|ASSERT_INT_EQ
argument_list|(
name|ssh_packet_set_state
argument_list|(
name|server2
argument_list|,
name|state
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|sshbuf_len
argument_list|(
name|state
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|ASSERT_PTR_NE
argument_list|(
name|server2
operator|->
name|kex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX we need to set the callbacks */
ifdef|#
directive|ifdef
name|WITH_OPENSSL
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP1_SHA1
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP14_SHA1
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP14_SHA256
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP16_SHA512
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GRP18_SHA512
index|]
operator|=
name|kexdh_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GEX_SHA1
index|]
operator|=
name|kexgex_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_DH_GEX_SHA256
index|]
operator|=
name|kexgex_server
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_HAS_ECC
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_ECDH_SHA2
index|]
operator|=
name|kexecdh_server
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|server2
operator|->
name|kex
operator|->
name|kex
index|[
name|KEX_C25519_SHA256
index|]
operator|=
name|kexc25519_server
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|load_host_public_key
operator|=
name|server
operator|->
name|kex
operator|->
name|load_host_public_key
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|load_host_private_key
operator|=
name|server
operator|->
name|kex
operator|->
name|load_host_private_key
expr_stmt|;
name|server2
operator|->
name|kex
operator|->
name|sign
operator|=
name|server
operator|->
name|kex
operator|->
name|sign
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"rekeying server2"
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|kex_send_kexinit
argument_list|(
name|server2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_kex
argument_list|(
name|client
argument_list|,
name|server2
argument_list|)
expr_stmt|;
name|ASSERT_INT_EQ
argument_list|(
name|kex_send_kexinit
argument_list|(
name|client
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_kex
argument_list|(
name|client
argument_list|,
name|server2
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
name|TEST_START
argument_list|(
literal|"cleanup"
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|ssh_free
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ssh_free
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|ssh_free
argument_list|(
name|server2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
name|TEST_DONE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\n"
literal|"               [-K kex_alg] [-k private_key] [-i packet_index]\n"
literal|"\n"
literal|"Options:\n"
literal|"    -h               Display this help\n"
literal|"    -c               Count packets sent during KEX\n"
literal|"    -d               Dump mode: record KEX packet to data file\n"
literal|"    -r               Replace mode: replace packet with data file\n"
literal|"    -v               Turn on verbose logging\n"
literal|"    -D S2C|C2S       Packet direction for replacement or dump\n"
literal|"    -f data_file     Path to data file for replacement or dump\n"
literal|"    -K kex_alg       Name of KEX algorithm to test (see below)\n"
literal|"    -k private_key   Path to private key file\n"
literal|"    -i packet_index  Index of packet to replace or dump (from 0)\n"
literal|"\n"
literal|"Available KEX algorithms: %s\n"
argument_list|,
name|kex_alg_list
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badusage
parameter_list|(
specifier|const
name|char
modifier|*
name|bad
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid options\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|bad
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|fd
decl_stmt|,
name|r
decl_stmt|;
name|int
name|count_flag
init|=
literal|0
decl_stmt|,
name|dump_flag
init|=
literal|0
decl_stmt|,
name|replace_flag
init|=
literal|0
decl_stmt|;
name|int
name|packet_index
init|=
operator|-
literal|1
decl_stmt|,
name|direction
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|s2c
init|=
literal|0
decl_stmt|,
name|c2s
init|=
literal|0
decl_stmt|;
comment|/* packet counts */
specifier|const
name|char
modifier|*
name|kex
init|=
name|NULL
decl_stmt|,
modifier|*
name|kpath
init|=
name|NULL
decl_stmt|,
modifier|*
name|data_path
init|=
name|NULL
decl_stmt|;
name|struct
name|sshkey
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|struct
name|sshbuf
modifier|*
name|replace_data
init|=
name|NULL
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hcdrvD:f:K:k:i:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|usage
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'c'
case|:
name|count_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dump_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|replace_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|do_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"s2c"
argument_list|)
operator|==
literal|0
condition|)
name|direction
operator|=
name|S2C
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"c2s"
argument_list|)
operator|==
literal|0
condition|)
name|direction
operator|=
name|C2S
expr_stmt|;
else|else
name|badusage
argument_list|(
literal|"Invalid direction (-D)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|data_path
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|kex
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|kpath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|packet_index
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_index
operator|<
literal|0
condition|)
name|badusage
argument_list|(
literal|"Invalid packet index"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badusage
argument_list|(
literal|"unsupported flag"
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|log_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|do_debug
condition|?
name|SYSLOG_LEVEL_DEBUG3
else|:
name|SYSLOG_LEVEL_INFO
argument_list|,
name|SYSLOG_FACILITY_USER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Must select a single mode */
if|if
condition|(
operator|(
name|count_flag
operator|+
name|dump_flag
operator|+
name|replace_flag
operator|)
operator|!=
literal|1
condition|)
name|badusage
argument_list|(
literal|"Must select one mode: -c, -d or -r"
argument_list|)
expr_stmt|;
comment|/* KEX type is mandatory */
if|if
condition|(
name|kex
operator|==
name|NULL
operator|||
operator|!
name|kex_names_valid
argument_list|(
name|kex
argument_list|)
operator|||
name|strchr
argument_list|(
name|kex
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
name|badusage
argument_list|(
literal|"Missing or invalid kex type (-K flag)"
argument_list|)
expr_stmt|;
comment|/* Valid key is mandatory */
if|if
condition|(
name|kpath
operator|==
name|NULL
condition|)
name|badusage
argument_list|(
literal|"Missing private key (-k flag)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|kpath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open %s"
argument_list|,
name|kpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_load_private_type_fd
argument_list|(
name|fd
argument_list|,
name|KEY_UNSPEC
argument_list|,
name|NULL
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to load key %s: %s"
argument_list|,
name|kpath
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* XXX check that it is a private key */
comment|/* XXX support certificates */
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
name|key
operator|->
name|type
operator|==
name|KEY_UNSPEC
operator|||
name|key
operator|->
name|type
operator|==
name|KEY_RSA1
condition|)
name|badusage
argument_list|(
literal|"Invalid key file (-k flag)"
argument_list|)
expr_stmt|;
comment|/* Replace (fuzz) mode */
if|if
condition|(
name|replace_flag
condition|)
block|{
if|if
condition|(
name|packet_index
operator|==
operator|-
literal|1
operator|||
name|direction
operator|==
operator|-
literal|1
operator|||
name|data_path
operator|==
name|NULL
condition|)
name|badusage
argument_list|(
literal|"Replace (-r) mode must specify direction "
literal|"(-D) packet index (-i) and data path (-f)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|data_path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open %s"
argument_list|,
name|data_path
argument_list|)
expr_stmt|;
name|replace_data
operator|=
name|sshbuf_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sshkey_load_file
argument_list|(
name|fd
argument_list|,
name|replace_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"read %s: %s"
argument_list|,
name|data_path
argument_list|,
name|ssh_err
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* Dump mode */
if|if
condition|(
name|dump_flag
condition|)
block|{
if|if
condition|(
name|packet_index
operator|==
operator|-
literal|1
operator|||
name|direction
operator|==
operator|-
literal|1
operator|||
name|data_path
operator|==
name|NULL
condition|)
name|badusage
argument_list|(
literal|"Dump (-d) mode must specify direction "
literal|"(-D), packet index (-i) and data path (-f)"
argument_list|)
expr_stmt|;
block|}
comment|/* Count mode needs no further flags */
name|do_kex_with_key
argument_list|(
name|kex
argument_list|,
name|key
argument_list|,
operator|&
name|c2s
argument_list|,
operator|&
name|s2c
argument_list|,
name|direction
argument_list|,
name|packet_index
argument_list|,
name|dump_flag
condition|?
name|data_path
else|:
name|NULL
argument_list|,
name|replace_flag
condition|?
name|replace_data
else|:
name|NULL
argument_list|)
expr_stmt|;
name|sshkey_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|sshbuf_free
argument_list|(
name|replace_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_flag
condition|)
block|{
name|printf
argument_list|(
literal|"S2C: %d\n"
argument_list|,
name|s2c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"C2S: %d\n"
argument_list|,
name|c2s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

