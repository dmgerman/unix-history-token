begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * FreeBSD install - a package for the installation and maintainance  * of non-core utilities.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * Jeremy D. Lea.  * 11 May 2002  *  * This is the version module. Based on pkg_version.pl by Bruce A. Mah.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"lib.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fetch.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|FILE
modifier|*
name|IndexFile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|index_head
name|Index
init|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|Index
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pkg_do
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_version
parameter_list|(
name|Package
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is the traditional pkg_perform, except that the argument is _not_  * a list of packages. It is the index file from the command line.  *  * We loop over the installed packages, matching them with the -s flag  * if needed and calling pkg_do(). Before hand we set up a few things,  * and after we tear them down...  */
end_comment

begin_function
name|int
name|pkg_perform
parameter_list|(
name|char
modifier|*
modifier|*
name|indexarg
parameter_list|)
block|{
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|,
modifier|*
modifier|*
name|pkgs
decl_stmt|,
modifier|*
name|pat
index|[
literal|2
index|]
decl_stmt|,
modifier|*
modifier|*
name|patterns
decl_stmt|;
name|struct
name|index_entry
modifier|*
name|ie
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err_cnt
init|=
literal|0
decl_stmt|;
name|int
name|MatchType
decl_stmt|;
comment|/*      * Try to find and open the INDEX. We only check IndexFile != NULL      * later, if we actually need the INDEX.      */
if|if
condition|(
operator|*
name|indexarg
operator|==
name|NULL
condition|)
name|snprintf
argument_list|(
name|tmp
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s/%s"
argument_list|,
name|PORTS_DIR
argument_list|,
name|INDEX_FNAME
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|tmp
argument_list|,
operator|*
name|indexarg
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|isURL
argument_list|(
name|tmp
argument_list|)
condition|)
name|IndexFile
operator|=
name|fetchGetURL
argument_list|(
name|tmp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|IndexFile
operator|=
name|fopen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* Get either a list of matching or all packages */
if|if
condition|(
name|MatchName
operator|!=
name|NULL
condition|)
block|{
name|pat
index|[
literal|0
index|]
operator|=
name|MatchName
expr_stmt|;
name|pat
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|MatchType
operator|=
name|RegexExtended
condition|?
name|MATCH_EREGEX
else|:
name|MATCH_REGEX
expr_stmt|;
name|patterns
operator|=
name|pat
expr_stmt|;
block|}
else|else
block|{
name|MatchType
operator|=
name|MATCH_ALL
expr_stmt|;
name|patterns
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|LookUpOrigin
operator|!=
name|NULL
condition|)
name|pkgs
operator|=
name|matchbyorigin
argument_list|(
name|LookUpOrigin
argument_list|,
operator|&
name|err_cnt
argument_list|)
expr_stmt|;
else|else
name|pkgs
operator|=
name|matchinstalled
argument_list|(
name|MatchType
argument_list|,
name|patterns
argument_list|,
operator|&
name|err_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_cnt
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to find package database directory!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkgs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LookUpOrigin
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"no packages recorded with this origin"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|MatchType
condition|)
block|{
case|case
name|MATCH_ALL
case|:
name|warnx
argument_list|(
literal|"no packages installed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MATCH_EREGEX
case|:
case|case
name|MATCH_REGEX
case|:
name|warnx
argument_list|(
literal|"no packages match pattern"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pkgs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|err_cnt
operator|+=
name|pkg_do
argument_list|(
name|pkgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* If we opened the INDEX in pkg_do(), clean up. */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|Index
argument_list|)
condition|)
block|{
name|ie
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|Index
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|Index
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ie
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|origin
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ie
operator|->
name|origin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IndexFile
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|IndexFile
argument_list|)
expr_stmt|;
return|return
name|err_cnt
return|;
block|}
end_function

begin_comment
comment|/*  * Traditional pkg_do(). We take the package name we are passed and  * first slurp in the CONTENTS file, getting name and origin, then  * we look for it's corresponding Makefile. If that fails we pull in  * the INDEX, and check there.  */
end_comment

begin_function
specifier|static
name|int
name|pkg_do
parameter_list|(
name|char
modifier|*
name|pkg
parameter_list|)
block|{
name|char
modifier|*
name|ch
decl_stmt|,
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|tmp2
index|[
name|PATH_MAX
index|]
decl_stmt|,
modifier|*
name|latest
init|=
name|NULL
decl_stmt|;
name|Package
name|plist
decl_stmt|;
name|struct
name|index_entry
modifier|*
name|ie
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Suck in the contents list. */
name|plist
operator|.
name|head
operator|=
name|plist
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
name|plist
operator|.
name|name
operator|=
name|plist
operator|.
name|origin
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|LOG_DIR
argument_list|,
name|pkg
argument_list|,
name|CONTENTS_FNAME
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|warnx
argument_list|(
literal|"the package info for package '%s' is corrupt"
argument_list|,
name|pkg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|read_plist
argument_list|(
operator|&
name|plist
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|plist
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s does not appear to be a valid package!"
argument_list|,
name|pkg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * First we check if the installed package has an origin, and try      * looking for it's Makefile. If we find the Makefile we get the      * latest version from there. If we fail, we start looking in the      * INDEX, first matching the origin and then the package name.      */
if|if
condition|(
name|plist
operator|.
name|origin
operator|!=
name|NULL
operator|&&
operator|!
name|UseINDEXOnly
condition|)
block|{
name|snprintf
argument_list|(
name|tmp
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s/%s"
argument_list|,
name|PORTS_DIR
argument_list|,
name|plist
operator|.
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|tmp
argument_list|)
operator|&&
name|chdir
argument_list|(
name|tmp
argument_list|)
operator|!=
name|FAIL
operator|&&
name|isfile
argument_list|(
literal|"Makefile"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|latest
operator|=
name|vpipe
argument_list|(
literal|"/usr/bin/make -V PKGNAME"
argument_list|,
name|tmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"Failed to get PKGNAME from %s/Makefile!"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
name|show_version
argument_list|(
name|plist
argument_list|,
name|latest
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
block|{
comment|/* Report package as not found in INDEX if the INDEX is not required. */
if|if
condition|(
name|IndexFile
operator|==
name|NULL
operator|&&
operator|!
name|UseINDEXOnly
condition|)
name|show_version
argument_list|(
name|plist
argument_list|,
name|NULL
argument_list|,
name|plist
operator|.
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We only pull in the INDEX once, if needed. */
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|Index
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IndexFile
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to open INDEX in %s."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetln
argument_list|(
name|IndexFile
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Don't use strlcpy() because fgetln() doesn't 		 * return a valid C string. 		 */
name|strncpy
argument_list|(
name|tmp
argument_list|,
name|ch
argument_list|,
name|MIN
argument_list|(
name|len
argument_list|,
name|PATH_MAX
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
index|[
name|PATH_MAX
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* The INDEX has pkgname|portdir|... */
if|if
condition|(
operator|(
name|ch
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|NULL
operator|&&
operator|(
name|ch
operator|=
name|strchr
argument_list|(
operator|&
name|ch
index|[
literal|1
index|]
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look backwards for the last two dirs = origin */
while|while
condition|(
name|ch
operator|!=
name|NULL
operator|&&
operator|*
operator|--
name|ch
operator|!=
literal|'/'
condition|)
if|if
condition|(
name|ch
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ch
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|NULL
operator|&&
operator|*
operator|--
name|ch
operator|!=
literal|'/'
condition|)
if|if
condition|(
name|ch
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"The INDEX does not appear to be valid!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ie
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|index_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to allocate memory in %s."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ie
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|index_entry
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ie
operator|->
name|origin
operator|=
name|strdup
argument_list|(
operator|&
name|ch
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Who really cares if we reverse the index... */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|Index
argument_list|,
name|ie
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now that we've slurped in the INDEX... */
name|SLIST_FOREACH
argument_list|(
argument|ie
argument_list|,
argument|&Index
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|plist
operator|.
name|origin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|plist
operator|.
name|origin
argument_list|,
name|ie
operator|->
name|origin
argument_list|)
operator|==
literal|0
condition|)
name|latest
operator|=
name|strdup
argument_list|(
name|ie
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|ie
operator|->
name|name
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tmp2
argument_list|,
name|plist
operator|.
name|name
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Chop off the versions and compare. */
if|if
condition|(
operator|(
name|ch
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"The INDEX does not appear to be valid!"
argument_list|)
expr_stmt|;
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|strrchr
argument_list|(
name|tmp2
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"%s is not a valid package!"
argument_list|,
name|plist
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp2
argument_list|,
name|tmp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|latest
operator|!=
name|NULL
condition|)
block|{
comment|/* Multiple matches */
name|snprintf
argument_list|(
name|tmp
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s|%s"
argument_list|,
name|latest
argument_list|,
name|ie
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|latest
argument_list|)
expr_stmt|;
name|latest
operator|=
name|strdup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|latest
operator|=
name|strdup
argument_list|(
name|ie
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
name|show_version
argument_list|(
name|plist
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|show_version
argument_list|(
name|plist
argument_list|,
name|latest
argument_list|,
literal|"index"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|latest
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|latest
argument_list|)
expr_stmt|;
name|free_plist
argument_list|(
operator|&
name|plist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OUTPUT
parameter_list|(
name|c
parameter_list|)
value|((PreventChars != NULL&& !strchr(PreventChars, (c))) || \ 			(LimitChars != NULL&& strchr(LimitChars, (c))) || \ 			(PreventChars == NULL&& LimitChars == NULL))
end_define

begin_comment
comment|/*  * Do the work of comparing and outputing. Ugly, but well that's what  * You get when you try to match perl output in C ;-).  */
end_comment

begin_function
name|void
name|show_version
parameter_list|(
name|Package
name|plist
parameter_list|,
specifier|const
name|char
modifier|*
name|latest
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|char
modifier|*
name|ch
decl_stmt|,
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ver
decl_stmt|;
name|int
name|cmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|plist
operator|.
name|name
operator|||
name|strlen
argument_list|(
name|plist
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ShowOrigin
operator|!=
name|FALSE
condition|)
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|plist
operator|.
name|origin
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
else|else
block|{
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|plist
operator|.
name|name
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Verbose
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|source
operator|==
name|NULL
operator|&&
name|OUTPUT
argument_list|(
literal|'!'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-34s  !"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"   Comparison failed"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|==
name|NULL
operator|&&
name|OUTPUT
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-34s  ?"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"   orphaned: %s"
argument_list|,
name|plist
operator|.
name|origin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|latest
argument_list|,
literal|'|'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|OUTPUT
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-34s  *"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|latest
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|ch
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ver
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|ver
operator|=
name|ver
condition|?
operator|&
name|ver
index|[
literal|1
index|]
else|:
name|tmp
expr_stmt|;
name|printf
argument_list|(
literal|"   multiple versions (index has %s"
argument_list|,
name|ver
argument_list|)
expr_stmt|;
do|do
block|{
name|ver
operator|=
name|strrchr
argument_list|(
operator|&
name|ch
index|[
literal|1
index|]
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|ver
operator|=
name|ver
condition|?
operator|&
name|ver
index|[
literal|1
index|]
else|:
operator|&
name|ch
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|strchr
argument_list|(
operator|&
name|ch
index|[
literal|1
index|]
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|ver
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|NULL
condition|)
do|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmp
operator|=
name|version_cmp
argument_list|(
name|plist
operator|.
name|name
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|ver
operator|=
name|strrchr
argument_list|(
name|latest
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|ver
operator|=
name|ver
condition|?
operator|&
name|ver
index|[
literal|1
index|]
else|:
name|latest
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
operator|&&
name|OUTPUT
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-34s  %c"
argument_list|,
name|tmp
argument_list|,
name|Quiet
condition|?
literal|'\0'
else|:
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"   needs updating (%s has %s)"
argument_list|,
name|source
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|OUTPUT
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-34s  %c"
argument_list|,
name|tmp
argument_list|,
name|Quiet
condition|?
literal|'\0'
else|:
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"   up-to-date with %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
operator|&&
name|OUTPUT
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-34s  %c"
argument_list|,
name|tmp
argument_list|,
name|Quiet
condition|?
literal|'\0'
else|:
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"   succeeds %s (%s has %s)"
argument_list|,
name|source
argument_list|,
name|source
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|version_match
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|pkgname
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|matchstream
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|Boolean
name|isTMP
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|isURL
argument_list|(
name|pkgname
argument_list|)
condition|)
block|{
name|fp
operator|=
name|fetchGetURL
argument_list|(
name|pkgname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|isTMP
operator|=
name|TRUE
expr_stmt|;
name|matchstream
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to open %s."
argument_list|,
name|pkgname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkgname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|pkgname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|isTMP
operator|=
name|TRUE
expr_stmt|;
name|matchstream
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to open %s."
argument_list|,
name|pkgname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pkgname
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
name|matchstream
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isURL
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
name|fp
operator|=
name|fetchGetURL
argument_list|(
name|pattern
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|isTMP
operator|=
name|TRUE
expr_stmt|;
name|matchstream
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to open %s."
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|pattern
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|isTMP
operator|=
name|TRUE
expr_stmt|;
name|matchstream
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"Unable to open %s."
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pattern
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
name|matchstream
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|pattern_match
argument_list|(
name|MATCH_GLOB
argument_list|,
name|pattern
argument_list|,
name|pkgname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|fp
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|match
decl_stmt|;
name|char
modifier|*
name|ch
decl_stmt|,
name|ln
index|[
literal|2048
index|]
decl_stmt|;
name|size_t
name|lnlen
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|len
operator|--
expr_stmt|;
name|lnlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|lnlen
operator|>
sizeof|sizeof
argument_list|(
name|ln
argument_list|)
operator|-
literal|1
condition|)
name|lnlen
operator|=
sizeof|sizeof
argument_list|(
name|ln
argument_list|)
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|ln
argument_list|,
name|line
argument_list|,
name|lnlen
argument_list|)
expr_stmt|;
name|ln
index|[
name|lnlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|strchr
argument_list|(
name|ln
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|matchstream
operator|>
literal|0
condition|)
name|match
operator|=
name|pattern_match
argument_list|(
name|MATCH_GLOB
argument_list|,
name|pattern
argument_list|,
name|ln
argument_list|)
expr_stmt|;
else|else
name|match
operator|=
name|pattern_match
argument_list|(
name|MATCH_GLOB
argument_list|,
name|ln
argument_list|,
name|pkgname
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|1
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isTMP
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|cleanup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|sig
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

