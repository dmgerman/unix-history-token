begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1995-1997 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	8.258 (Berkeley) 10/20/97"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_if
if|#
directive|if
name|NAMED_BIND
end_if

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by settings read in from /etc/sendmail.cf **	(read by readcf.c). ** **	Usage: **		/usr/lib/sendmail [flags] addr ... ** **		See the associated documentation for details. ** **	Author: **		Eric Allman, UCB/INGRES (until 10/81). **			     Britton-Lee, Inc., purveyors of fine **				database computers (11/81 - 10/88). **			     International Computer Science Institute **				(11/88 - 9/89). **			     UCB/Mammoth Project (10/89 - 7/95). **			     InReference, Inc. (8/95 - 1/97). **		The support of the my employers is gratefully acknowledged. **			Few of them (Britton-Lee in particular) have had **			anything to gain from my involvement in this project. */
end_comment

begin_decl_stmt
name|int
name|NextMailer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "free" index into Mailer struct */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a "blank" envelope */
end_comment

begin_decl_stmt
name|ENVELOPE
name|MainEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the envelope around the basic letter */
end_comment

begin_decl_stmt
name|ADDRESS
name|NullAddress
init|=
comment|/* a null address */
block|{
literal|""
block|,
literal|""
block|,
name|NULL
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CommandLineArgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command line args for pid file */
end_comment

begin_decl_stmt
name|bool
name|Warn_Q_option
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* warn about Q option use */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|SaveArgv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argument vector for re-execing */
end_comment

begin_decl_stmt
name|int
name|MissingFds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit map of fds missing on startup */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NGROUPS_MAX
end_ifdef

begin_decl_stmt
name|GIDSET_T
name|InitialGidSet
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|obsolete
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
name|printmailer
name|__P
argument_list|(
operator|(
name|MAILER
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|tTflag
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DAEMON
operator|&&
operator|!
name|SMTP
end_if

begin_expr_stmt
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|DAEMON
name|mode
name|without
name|SMTP
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
comment|/* DAEMON&& !SMTP */
if|#
directive|if
name|SMTP
operator|&&
operator|!
name|QUEUE
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|SMTP
name|mode
name|without
name|QUEUE
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
comment|/* DAEMON&& !SMTP */
define|#
directive|define
name|MAXCONFIGLEVEL
value|7
comment|/* highest config version level known */
name|int
expr|main
operator|(
name|argc
operator|,
name|argv
operator|,
name|envp
operator|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|from
decl_stmt|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|bool
name|queuemode
init|=
name|FALSE
decl_stmt|;
comment|/* process queue requests */
name|bool
name|safecf
init|=
name|TRUE
decl_stmt|;
name|bool
name|warn_C_flag
init|=
name|FALSE
decl_stmt|;
name|char
name|warn_f_flag
init|=
literal|'\0'
decl_stmt|;
name|bool
name|run_in_foreground
init|=
name|FALSE
decl_stmt|;
comment|/* -bD mode */
specifier|static
name|bool
name|reenter
init|=
name|FALSE
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|bool
name|nullserver
init|=
name|FALSE
decl_stmt|;
name|char
name|jbuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* holds MyHostName */
specifier|static
name|char
name|rnamebuf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* holds RealUserName */
name|char
modifier|*
name|emptyenviron
index|[
literal|1
index|]
decl_stmt|;
specifier|extern
name|int
name|DtableSize
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|int
name|opterr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|extern
name|time_t
name|convtime
parameter_list|()
function_decl|;
specifier|extern
name|SIGFUNC_DECL
name|intsig
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|hostent
modifier|*
name|myhostname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getauthinfo
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getcfname
parameter_list|()
function_decl|;
specifier|extern
name|SIGFUNC_DECL
name|sigusr1
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|SIGFUNC_DECL
name|sighup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|initmacros
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|init_md
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|getdtsize
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|tTsetup
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|setdefaults
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|initsetproctitle
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|init_vendor_macros
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|load_if_names
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|vendor_pre_defaults
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|vendor_post_defaults
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|readcf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|printqueue
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|sendtoargv
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|resetlimits
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* 	**  Check to see if we reentered. 	**	This would normally happen if e_putheader or e_putbody 	**	were NULL when invoked. 	*/
if|if
condition|(
name|reenter
condition|)
block|{
name|syserr
argument_list|(
literal|"main: reentered!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|reenter
operator|=
name|TRUE
expr_stmt|;
comment|/* avoid null pointer dereferences */
name|TermEscape
operator|.
name|te_rv_on
operator|=
name|TermEscape
operator|.
name|te_rv_off
operator|=
literal|""
expr_stmt|;
comment|/* do machine-dependent initializations */
name|init_md
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* in 4.4BSD, the table can be huge; impose a reasonable limit */
name|DtableSize
operator|=
name|getdtsize
argument_list|()
expr_stmt|;
if|if
condition|(
name|DtableSize
operator|>
literal|256
condition|)
name|DtableSize
operator|=
literal|256
expr_stmt|;
comment|/* 	**  Be sure we have enough file descriptors. 	**	But also be sure that 0, 1,& 2 are open. 	*/
name|fill_fd
argument_list|(
name|STDIN_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fill_fd
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fill_fd
argument_list|(
name|STDERR_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i
operator|=
name|DtableSize
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|STDIN_FILENO
operator|&&
name|i
operator|!=
name|STDOUT_FILENO
operator|&&
name|i
operator|!=
name|STDERR_FILENO
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|LOG
ifdef|#
directive|ifdef
name|LOG_MAIL
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|MissingFds
operator|!=
literal|0
condition|)
block|{
name|char
name|mbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDIN_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
name|strcat
argument_list|(
name|mbuf
argument_list|,
literal|", stdin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDOUT_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
name|strcat
argument_list|(
name|mbuf
argument_list|,
literal|", stdout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDERR_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
name|strcat
argument_list|(
name|mbuf
argument_list|,
literal|", stderr"
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"File descriptors missing on startup: %s"
argument_list|,
operator|&
name|mbuf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* reset status from syserr() calls for missing file descriptors */
name|Errors
operator|=
literal|0
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"after openlog"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
comment|/* save initial group set for future checks */
name|i
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|InitialGidSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|InitialGidSet
index|[
literal|0
index|]
operator|=
operator|(
name|GID_T
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NGROUPS_MAX
condition|)
name|InitialGidSet
index|[
name|i
operator|++
index|]
operator|=
name|InitialGidSet
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* drop group id privileges (RunAsUser not yet set) */
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
comment|/* arrange to dump state on user-1 signal */
name|setsignal
argument_list|(
name|SIGUSR1
argument_list|,
name|sigusr1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Handle any non-getoptable constructions. */
name|obsolete
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* 	**  Do a quick prescan of the argument list. 	*/
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX3
argument_list|)
define|#
directive|define
name|OPTIONS
value|"B:b:C:cd:e:F:f:h:IiM:mN:nO:o:p:q:R:r:sTtUV:vX:x"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
define|#
directive|define
name|OPTIONS
value|"B:b:C:cd:E:e:F:f:h:IiJ:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPTIONS
define|#
directive|define
name|OPTIONS
value|"B:b:C:cd:e:F:f:h:IiM:mN:nO:o:p:q:R:r:sTtUV:vX:"
endif|#
directive|endif
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* hack attack -- see if should use ANSI mode */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ANSI"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TermEscape
operator|.
name|te_rv_on
operator|=
literal|"\033[7m"
expr_stmt|;
name|TermEscape
operator|.
name|te_rv_off
operator|=
literal|"\033[0m"
expr_stmt|;
break|break;
block|}
name|tTflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|opterr
operator|=
literal|1
expr_stmt|;
comment|/* set up the blank envelope */
name|BlankEnvelope
operator|.
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_putbody
operator|=
name|putbody
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_xfp
operator|=
name|NULL
expr_stmt|;
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|BlankEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|MainEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
comment|/* 	**  Set default values for variables. 	**	These cannot be in initialized data space. 	*/
name|setdefaults
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|RealUid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RealGid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|pw
operator|=
name|sm_getpwuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"%s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"Unknown UID %d"
argument_list|,
name|RealUid
argument_list|)
expr_stmt|;
name|RealUserName
operator|=
name|rnamebuf
expr_stmt|;
comment|/* if running non-setuid binary, pretend we are the RunAsUid */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
name|RealUid
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Non-setuid binary: RunAsUid = RealUid = %d\n"
argument_list|,
name|RealUid
argument_list|)
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
expr_stmt|;
block|}
if|if
condition|(
name|getegid
argument_list|()
operator|==
name|RealGid
condition|)
name|RunAsGid
operator|=
name|RealGid
expr_stmt|;
comment|/* save command line arguments */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
control|)
name|i
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SaveArgv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|CommandLineArgs
operator|=
name|xalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|CommandLineArgs
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
control|)
block|{
name|SaveArgv
index|[
name|i
operator|++
index|]
operator|=
name|newstr
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|!=
name|argv
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|av
operator|++
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|SaveArgv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|int
name|ll
decl_stmt|;
specifier|extern
name|char
modifier|*
name|CompileOptions
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"Version %s\n Compiled with:"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|av
operator|=
name|CompileOptions
expr_stmt|;
name|ll
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ll
operator|+
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|>
literal|63
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|ll
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ll
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|int
name|ll
decl_stmt|;
specifier|extern
name|char
modifier|*
name|OsCompileOptions
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"    OS Defines:"
argument_list|)
expr_stmt|;
name|av
operator|=
name|OsCompileOptions
expr_stmt|;
name|ll
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ll
operator|+
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|>
literal|63
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|ll
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ll
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_UNIX
name|printf
argument_list|(
literal|"Kernel symbols:\t%s\n"
argument_list|,
name|_PATH_UNIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|" Def Conf file:\t%s\n"
argument_list|,
name|getcfname
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Pid file:\t%s\n"
argument_list|,
name|PidFile
argument_list|)
expr_stmt|;
block|}
name|InChannel
operator|=
name|stdin
expr_stmt|;
name|OutChannel
operator|=
name|stdout
expr_stmt|;
comment|/* initialize for setproctitle */
name|initsetproctitle
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
comment|/* clear sendmail's environment */
name|ExternalEnviron
operator|=
name|environ
expr_stmt|;
name|emptyenviron
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|environ
operator|=
name|emptyenviron
expr_stmt|;
comment|/* prime the child environment */
name|setuserenv
argument_list|(
literal|"AGENT"
argument_list|,
literal|"sendmail"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|OldUmask
operator|=
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
name|FullName
operator|=
name|getextenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
comment|/* 	**  Initialize name server if it is going to be used. 	*/
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|res_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
else|else
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG
expr_stmt|;
ifdef|#
directive|ifdef
name|RES_NOALIASES
name|_res
operator|.
name|options
operator||=
name|RES_NOALIASES
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|NULL
expr_stmt|;
comment|/* initialize some macros, etc. */
name|initmacros
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|init_vendor_macros
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* version */
name|define
argument_list|(
literal|'v'
argument_list|,
name|Version
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* hostname */
name|hp
operator|=
name|myhostname
argument_list|(
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|utsname
name|utsname
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"canonical name: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'w'
argument_list|,
name|newstr
argument_list|(
name|jbuf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* must be new string */
name|define
argument_list|(
literal|'j'
argument_list|,
name|newstr
argument_list|(
name|jbuf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|jbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|define
argument_list|(
literal|'m'
argument_list|,
name|newstr
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|>=
literal|0
condition|)
name|p
operator|=
name|utsname
operator|.
name|nodename
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|22
argument_list|)
condition|)
name|printf
argument_list|(
literal|"uname failed (%s)\n"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|jbuf
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|" UUCP nodename: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'k'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'k'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|av
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NETINET
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET
operator|&&
name|hp
operator|->
name|h_length
operator|==
name|INADDRSZ
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ipbuf
index|[
literal|103
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
name|ipbuf
argument_list|,
literal|"[%.100s]"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* current time */
name|define
argument_list|(
literal|'b'
argument_list|,
name|arpadate
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* 	** Crack argv. 	*/
name|av
operator|=
name|argv
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|++
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|av
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"newaliases"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"mailq"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PRINT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"smtpd"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"hoststat"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_HOSTSTAT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"purgestat"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PURGESTAT
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* operations mode */
switch|switch
condition|(
name|j
operator|=
operator|*
name|optarg
condition|)
block|{
case|case
name|MD_DAEMON
case|:
case|case
name|MD_FGDAEMON
case|:
if|#
directive|if
operator|!
name|DAEMON
name|usrerr
argument_list|(
literal|"Daemon mode not implemented"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DAEMON */
case|case
name|MD_SMTP
case|:
if|#
directive|if
operator|!
name|SMTP
name|usrerr
argument_list|(
literal|"I don't speak SMTP"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SMTP */
case|case
name|MD_INITALIAS
case|:
case|case
name|MD_DELIVER
case|:
case|case
name|MD_VERIFY
case|:
case|case
name|MD_TEST
case|:
case|case
name|MD_PRINT
case|:
case|case
name|MD_HOSTSTAT
case|:
case|case
name|MD_PURGESTAT
case|:
case|case
name|MD_ARPAFTP
case|:
name|OpMode
operator|=
name|j
expr_stmt|;
break|break;
case|case
name|MD_FREEZE
case|:
name|usrerr
argument_list|(
literal|"Frozen configurations unsupported"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
default|default:
name|usrerr
argument_list|(
literal|"Invalid operation mode %c"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
name|CurEnv
operator|->
name|e_bodytype
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* select configuration file (already done) */
if|if
condition|(
name|RealUid
operator|!=
literal|0
condition|)
name|warn_C_flag
operator|=
name|TRUE
expr_stmt|;
name|ConfFile
operator|=
name|optarg
expr_stmt|;
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|safecf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* debugging -- already done */
break|break;
case|case
literal|'f'
case|:
comment|/* from address */
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|RealUserName
argument_list|,
name|from
argument_list|)
operator|!=
literal|0
condition|)
name|warn_f_flag
operator|=
name|j
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|FullName
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|CurEnv
operator|->
name|e_hopcount
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
block|{
name|usrerr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* delivery status notifications */
name|DefaultNotify
operator||=
name|QHASNOTIFY
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|p
operator|=
name|optarg
init|;
name|p
operator|!=
name|NULL
condition|;
name|optarg
operator|=
name|p
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONSUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONFAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"delay"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONDELAY
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"Invalid -N argument"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* set option */
name|setoption
argument_list|(
operator|*
name|optarg
argument_list|,
name|optarg
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* set option (long form) */
name|setoption
argument_list|(
literal|' '
argument_list|,
name|optarg
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* set protocol */
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cleanstrcpy
argument_list|(
name|ep
argument_list|,
name|p
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'s'
argument_list|,
name|ep
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cleanstrcpy
argument_list|(
name|ep
argument_list|,
name|optarg
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'r'
argument_list|,
name|ep
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* run queue files at intervals */
if|#
directive|if
name|QUEUE
name|FullName
operator|=
name|NULL
expr_stmt|;
name|queuemode
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'I'
case|:
name|QueueLimitId
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|QueueLimitRecipient
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|QueueLimitSender
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|QueueIntvl
operator|=
name|convtime
argument_list|(
name|optarg
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* QUEUE */
name|usrerr
argument_list|(
literal|"I don't know about queues"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
endif|#
directive|endif
comment|/* QUEUE */
break|break;
case|case
literal|'R'
case|:
comment|/* DSN RET: what to return */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Duplicate -R flag"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"hdrs"
argument_list|)
operator|==
literal|0
condition|)
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"full"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid -R value"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|GrabTo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* initial (user) submission */
name|UserSubmission
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* DSN ENVID: set "original" envelope id */
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid syntax in -V flag"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
else|else
name|CurEnv
operator|->
name|e_envid
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* traffic log file */
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|TrafficLogFile
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CANTCREAT
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|HASSETVBUF
name|setvbuf
argument_list|(
name|TrafficLogFile
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|TrafficLogFile
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* compatibility flags */
case|case
literal|'c'
case|:
comment|/* connect to non-local mailers */
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
case|case
literal|'m'
case|:
comment|/* send to me too */
case|case
literal|'T'
case|:
comment|/* set timeout interval */
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|setoption
argument_list|(
name|j
argument_list|,
literal|"T"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* error message disposition */
case|case
literal|'M'
case|:
comment|/* define macro */
name|setoption
argument_list|(
name|j
argument_list|,
name|optarg
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|setoption
argument_list|(
literal|'f'
argument_list|,
literal|"T"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DBM */
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX3
argument_list|)
case|case
literal|'x'
case|:
comment|/* random flag that OSF/1& AIX mailx passes */
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
case|case
literal|'E'
case|:
case|case
literal|'J'
case|:
comment|/* ignore flags for Japanese code conversion 				   impremented on Sony NEWS */
break|break;
endif|#
directive|endif
default|default:
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|av
operator|+=
name|optind
expr_stmt|;
comment|/* 	**  Do basic initialization. 	**	Read system control file. 	**	Extract special fields for local use. 	*/
comment|/* set up ${opMode} for use in config file */
block|{
name|char
name|mbuf
index|[
literal|2
index|]
decl_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
name|OpMode
expr_stmt|;
name|mbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|MID_OPMODE
argument_list|,
name|newstr
argument_list|(
name|mbuf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before readcf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vendor_pre_defaults
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|readcf
argument_list|(
name|getcfname
argument_list|()
argument_list|,
name|safecf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|ConfigFileRead
operator|=
name|TRUE
expr_stmt|;
name|vendor_post_defaults
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* Enforce use of local time (null string overrides this) */
if|if
condition|(
name|TimeZoneSpec
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TimeZoneSpec
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setuserenv
argument_list|(
literal|"TZ"
argument_list|,
name|TimeZoneSpec
argument_list|)
expr_stmt|;
else|else
name|setuserenv
argument_list|(
literal|"TZ"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tzset
argument_list|()
expr_stmt|;
comment|/* avoid denial-of-service attacks */
name|resetlimits
argument_list|()
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_FGDAEMON
condition|)
block|{
comment|/* drop privileges -- daemon mode done after socket/bind */
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Find our real host name for future logging. 	*/
name|p
operator|=
name|getauthinfo
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'_'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* suppress error printing if errors mailed back or whatever */
if|if
condition|(
name|CurEnv
operator|->
name|e_errormode
operator|!=
name|EM_PRINT
condition|)
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
comment|/* set up the $=m class now, after .cf has a chance to redefine $m */
name|expand
argument_list|(
literal|"\201m"
argument_list|,
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'m'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
comment|/* probe interfaces and locate any additional names */
if|if
condition|(
operator|!
name|DontProbeInterfaces
condition|)
name|load_if_names
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n============ SYSTEM IDENTITY (after readcf) ============"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n      (short domain name) $w = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'w'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  (canonical domain name) $j = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         (subdomain name) $m = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'m'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n              (node name) $k = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'k'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n========================================================\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do more command line checking -- these are things that 	**  have to modify the results of reading the config file. 	*/
comment|/* process authorization warnings from command line */
if|if
condition|(
name|warn_C_flag
condition|)
name|auth_warning
argument_list|(
name|CurEnv
argument_list|,
literal|"Processed by %s with -C %s"
argument_list|,
name|RealUserName
argument_list|,
name|ConfFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Warn_Q_option
condition|)
name|auth_warning
argument_list|(
name|CurEnv
argument_list|,
literal|"Processed from queue %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
comment|/* check body type for legality */
if|if
condition|(
name|CurEnv
operator|->
name|e_bodytype
operator|==
name|NULL
condition|)
comment|/* nothing */
empty_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|CurEnv
operator|->
name|e_bodytype
argument_list|,
literal|"7BIT"
argument_list|)
operator|==
literal|0
condition|)
name|SevenBitInput
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|CurEnv
operator|->
name|e_bodytype
argument_list|,
literal|"8BITMIME"
argument_list|)
operator|==
literal|0
condition|)
name|SevenBitInput
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"Illegal body type %s"
argument_list|,
name|CurEnv
operator|->
name|e_bodytype
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_bodytype
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* tweak default DSN notifications */
if|if
condition|(
name|DefaultNotify
operator|==
literal|0
condition|)
name|DefaultNotify
operator|=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
comment|/* be sure we don't pick up bogus HOSTALIASES environment variable */
if|if
condition|(
name|queuemode
operator|&&
name|RealUid
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|unsetenv
argument_list|(
literal|"HOSTALIASES"
argument_list|)
expr_stmt|;
comment|/* check for sane configuration level */
if|if
condition|(
name|ConfigLevel
operator|>
name|MAXCONFIGLEVEL
condition|)
block|{
name|syserr
argument_list|(
literal|"Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)"
argument_list|,
name|ConfigLevel
argument_list|,
name|Version
argument_list|,
name|MAXCONFIGLEVEL
argument_list|)
expr_stmt|;
block|}
comment|/* need MCI cache to have persistence */
if|if
condition|(
name|HostStatDir
operator|!=
name|NULL
operator|&&
name|MaxMciCache
operator|==
literal|0
condition|)
block|{
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n"
argument_list|)
expr_stmt|;
block|}
comment|/* need HostStatusDir in order to have SingleThreadDelivery */
if|if
condition|(
name|SingleThreadDelivery
operator|&&
name|HostStatDir
operator|==
name|NULL
condition|)
block|{
name|SingleThreadDelivery
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: HostStatusDirectory required for SingleThreadDelivery\n"
argument_list|)
expr_stmt|;
block|}
comment|/* check for permissions */
if|if
condition|(
operator|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_PURGESTAT
operator|)
operator|&&
name|RealUid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"user %d attempted to %s"
argument_list|,
name|RealUid
argument_list|,
name|OpMode
operator|==
name|MD_DAEMON
condition|?
literal|"run daemon"
else|:
literal|"purge host status"
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MeToo
condition|)
name|BlankEnvelope
operator|.
name|e_flags
operator||=
name|EF_METOO
expr_stmt|;
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_TEST
case|:
comment|/* don't have persistent host status in test mode */
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
name|Verbose
operator|=
literal|2
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
break|break;
case|case
name|MD_FGDAEMON
case|:
name|run_in_foreground
operator|=
name|TRUE
expr_stmt|;
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
comment|/* fall through ... */
case|case
name|MD_DAEMON
case|:
name|vendor_daemon_setup
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* remove things that don't make sense in daemon mode */
name|FullName
operator|=
name|NULL
expr_stmt|;
name|GrabTo
operator|=
name|FALSE
expr_stmt|;
comment|/* arrange to restart on hangup signal */
if|if
condition|(
name|SaveArgv
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|SaveArgv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"daemon invoked without full pathname; kill -1 won't work"
argument_list|)
expr_stmt|;
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
comment|/* workaround: can't seem to release the signal in the parent */
name|releasesignal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_INITALIAS
case|:
name|Verbose
operator|=
literal|2
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
comment|/* fall through... */
case|case
name|MD_PRINT
case|:
comment|/* to handle sendmail -bp -qSfoobar properly */
name|queuemode
operator|=
name|FALSE
expr_stmt|;
comment|/* fall through... */
default|default:
comment|/* arrange to exit cleanly on hangup signal */
if|if
condition|(
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
operator|(
name|sigfunc_t
operator|)
name|SIG_DFL
condition|)
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* full names can't have newlines */
if|if
condition|(
name|FullName
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|FullName
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
name|FullName
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|FullName
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do heuristic mode adjustment */
if|if
condition|(
name|Verbose
condition|)
block|{
comment|/* turn off noconnect option */
name|setoption
argument_list|(
literal|'c'
argument_list|,
literal|"F"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* turn on interactive delivery */
name|setoption
argument_list|(
literal|'d'
argument_list|,
literal|""
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|<
literal|3
condition|)
block|{
name|UseErrorsTo
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* set options that were previous macros */
if|if
condition|(
name|SmtpGreeting
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
operator|&&
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'e'
argument_list|,
name|CurEnv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SmtpGreeting
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|SmtpGreeting
operator|=
literal|"\201j Sendmail \201v ready at \201b"
expr_stmt|;
block|}
if|if
condition|(
name|UnixFromLine
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
operator|&&
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'l'
argument_list|,
name|CurEnv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|UnixFromLine
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|UnixFromLine
operator|=
literal|"From \201g  \201d"
expr_stmt|;
block|}
comment|/* our name for SMTP codes */
name|expand
argument_list|(
literal|"\201j"
argument_list|,
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|MyHostName
operator|=
name|jbuf
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|jbuf
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
name|message
argument_list|(
literal|"WARNING: local host name (%s) is not qualified; fix $j in config file"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
comment|/* make certain that this name is part of the $=w class */
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* the indices of built-in mailers */
name|st
operator|=
name|stab
argument_list|(
literal|"local"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
name|LocalMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
elseif|else
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
operator|||
operator|!
name|warn_C_flag
condition|)
name|syserr
argument_list|(
literal|"No local mailer defined"
argument_list|)
expr_stmt|;
name|st
operator|=
name|stab
argument_list|(
literal|"prog"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No prog mailer defined"
argument_list|)
expr_stmt|;
else|else
block|{
name|ProgMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|clrbitn
argument_list|(
name|M_MUSER
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|stab
argument_list|(
literal|"*file*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *file* mailer defined"
argument_list|)
expr_stmt|;
else|else
block|{
name|FileMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|clrbitn
argument_list|(
name|M_MUSER
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|stab
argument_list|(
literal|"*include*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *include* mailer defined"
argument_list|)
expr_stmt|;
else|else
name|InclMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|<
literal|6
condition|)
block|{
comment|/* heuristic tweaking of local mailer for back compat */
if|if
condition|(
name|LocalMailer
operator|!=
name|NULL
condition|)
block|{
name|setbitn
argument_list|(
name|M_ALIASABLE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_HASPWENT
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_TRYRULESET5
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKINCLUDE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKPROG
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKFILE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKUDB
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ProgMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|LocalMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ProgMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
comment|/* MIME Content-Types that cannot be transfer encoded */
name|setclass
argument_list|(
literal|'n'
argument_list|,
literal|"multipart/signed"
argument_list|)
expr_stmt|;
comment|/* MIME message/xxx subtypes that can be treated as messages */
name|setclass
argument_list|(
literal|'s'
argument_list|,
literal|"rfc822"
argument_list|)
expr_stmt|;
comment|/* MIME Content-Transfer-Encodings that can be encoded */
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"7bit"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"8bit"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_B_CLASS
comment|/* MIME Content-Types that should be treated as binary */
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"image"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"audio"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"video"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"application/octet-stream"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* operate in queue directory */
if|if
condition|(
name|QueueDir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory (Q) option must be set"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* test path to get warning messages */
operator|(
name|void
operator|)
name|safedirpath
argument_list|(
name|QueueDir
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
name|SFF_ANYFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
operator|&&
name|chdir
argument_list|(
name|QueueDir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot chdir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
block|}
comment|/* check host status directory for validity */
if|if
condition|(
name|HostStatDir
operator|!=
name|NULL
operator|&&
operator|!
name|path_is_dir
argument_list|(
name|HostStatDir
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* cannot use this value */
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Cannot use HostStatusDirectory = %s: %s\n"
argument_list|,
name|HostStatDir
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|QUEUE
if|if
condition|(
name|queuemode
operator|&&
name|RealUid
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|PRIV_RESTRICTQRUN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* check to see if we own the queue directory */
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"main: cannot stat %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_uid
operator|!=
name|RealUid
condition|)
block|{
comment|/* nope, really a botch */
name|usrerr
argument_list|(
literal|"You do not have permission to process the queue"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOPERM
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* QUEUE */
comment|/* if we've had errors so far, exit now */
if|if
condition|(
name|ExitStat
operator|!=
name|EX_OK
operator|&&
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before main() initmaps"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  Do operation-mode-dependent initialization. 	*/
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_PRINT
case|:
comment|/* print the queue */
if|#
directive|if
name|QUEUE
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printqueue
argument_list|()
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* QUEUE */
name|usrerr
argument_list|(
literal|"No queue to print"
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* QUEUE */
case|case
name|MD_HOSTSTAT
case|:
name|mci_traverse_persistent
argument_list|(
name|mci_print_persistent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_PURGESTAT
case|:
name|mci_traverse_persistent
argument_list|(
name|mci_purge_persistent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_INITALIAS
case|:
comment|/* initialize alias database */
name|initmaps
argument_list|(
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
case|case
name|MD_SMTP
case|:
name|nullserver
operator|=
name|FALSE
expr_stmt|;
comment|/* fall through... */
case|case
name|MD_DAEMON
case|:
comment|/* reset DSN parameters */
name|DefaultNotify
operator|=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
name|CurEnv
operator|->
name|e_envid
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_RET_PARAM
operator||
name|EF_NO_BODY_RETN
operator|)
expr_stmt|;
comment|/* don't open alias database -- done in srvrsmtp */
break|break;
default|default:
comment|/* open the alias database */
name|initmaps
argument_list|(
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
condition|)
block|{
specifier|extern
name|void
name|printrules
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* print configuration table (or at least part of it) */
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|90
argument_list|)
condition|)
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printmailer
argument_list|(
name|Mailer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Switch to the main envelope. 	*/
name|CurEnv
operator|=
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
comment|/* 	**  If test mode, read addresses from stdin and process. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|SIGFUNC_DECL
name|intindebug
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Enter<ruleset><address>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|intindebug
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|extern
name|void
name|testmodeline
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|finis
argument_list|()
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|Verbose
condition|)
name|printf
argument_list|(
literal|"> %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|testmodeline
argument_list|(
name|buf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|QUEUE
comment|/* 	**  If collecting stuff from the queue, go start doing that. 	*/
if|if
condition|(
name|queuemode
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|QueueIntvl
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|FALSE
argument_list|,
name|Verbose
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* QUEUE */
comment|/* 	**  If a daemon, wait for a request. 	**	getrequests will always return in a child. 	**	If we should also be processing the queue, start 	**		doing it in background. 	**	We check for any errors that might have happened 	**		during startup. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
name|char
name|dtype
index|[
literal|200
index|]
decl_stmt|;
specifier|extern
name|void
name|getrequests
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|run_in_foreground
operator|&&
operator|!
name|tTd
argument_list|(
literal|99
argument_list|,
literal|100
argument_list|)
condition|)
block|{
comment|/* put us in background */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"daemon: cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* disconnect from our controlling tty */
name|disconnect
argument_list|(
literal|2
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|dtype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
name|strcat
argument_list|(
name|dtype
argument_list|,
literal|"+SMTP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|dtype
argument_list|,
literal|"+queueing@"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dtype
argument_list|,
name|pintvl
argument_list|(
name|QueueIntvl
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|strcat
argument_list|(
name|dtype
argument_list|,
literal|"+debugging"
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"starting daemon (%s): %s"
argument_list|,
name|Version
argument_list|,
name|dtype
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XLA
name|xla_create_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|QUEUE
if|if
condition|(
name|queuemode
condition|)
block|{
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|pause
argument_list|()
expr_stmt|;
if|if
condition|(
name|DoQueueRun
condition|)
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* QUEUE */
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|DAEMON
name|getrequests
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* drop privileges */
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* at this point we are in a child: reset state */
operator|(
name|void
operator|)
name|newenvelope
argument_list|(
name|CurEnv
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* 		**  Get authentication data 		*/
name|p
operator|=
name|getauthinfo
argument_list|(
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'_'
argument_list|,
name|p
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* validate the connection */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|nullserver
operator|=
operator|!
name|validate_connection
argument_list|(
operator|&
name|RealHostAddr
argument_list|,
name|RealHostName
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* DAEMON */
block|}
if|#
directive|if
name|SMTP
comment|/* 	**  If running SMTP protocol, start collecting and executing 	**  commands.  This will never return. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
name|void
name|smtp
name|__P
argument_list|(
operator|(
name|bool
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* 		**  Save some macros for check_* rulesets. 		*/
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_name}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|RealHostName
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|RealHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|RealHostAddr
operator|.
name|sin
operator|.
name|sin_port
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_port}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|pbuf
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|smtp
argument_list|(
name|nullserver
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SMTP */
name|clearenvelope
argument_list|(
name|CurEnv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
block|{
name|CurEnv
operator|->
name|e_sendmode
operator|=
name|SM_VERIFY
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|PostMasterCopy
operator|=
name|NULL
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* interactive -- all errors are global */
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
operator||
name|EF_LOGSENDER
expr_stmt|;
block|}
comment|/* 	**  Do basic system initialization and set the sender 	*/
name|initsys
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_f_flag
operator|!=
literal|'\0'
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
condition|)
name|auth_warning
argument_list|(
name|CurEnv
argument_list|,
literal|"%s set sender to %s using -%c"
argument_list|,
name|RealUserName
argument_list|,
name|from
argument_list|,
name|warn_f_flag
argument_list|)
expr_stmt|;
name|setsender
argument_list|(
name|from
argument_list|,
name|CurEnv
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
name|define
argument_list|(
literal|'s'
argument_list|,
name|RealHostName
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|usrerr
argument_list|(
literal|"Recipient names must be specified"
argument_list|)
expr_stmt|;
comment|/* collect body for UUCP return */
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|collect
argument_list|(
name|InChannel
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* 	**  Scan argv and deliver the message to everyone. 	*/
name|sendtoargv
argument_list|(
name|av
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* if we have had errors sofar, arrange a meaningful exit stat */
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
comment|/* 	**  Read the input mail. 	*/
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
operator|||
name|GrabTo
condition|)
block|{
name|long
name|savedflags
init|=
name|CurEnv
operator|->
name|e_flags
operator|&
name|EF_FATALERRS
decl_stmt|;
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|collect
argument_list|(
name|InChannel
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* bail out if message too large */
if|if
condition|(
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|finis
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|-
literal|1
return|;
block|}
name|CurEnv
operator|->
name|e_flags
operator||=
name|savedflags
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
name|CurEnv
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"main: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|CurrentLA
operator|=
name|getla
argument_list|()
expr_stmt|;
name|sendall
argument_list|(
name|CurEnv
argument_list|,
name|SM_DEFAULT
argument_list|)
expr_stmt|;
comment|/* 	**  All done. 	**	Don't send return error message if in VERIFY mode. 	*/
name|finis
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|SIGFUNC_DECL
name|intindebug
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|TopFrame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		none ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_function
name|void
name|finis
parameter_list|()
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|extern
name|void
name|printenvflags
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"\n====finis: stat %d e_id=%s e_flags="
argument_list|,
name|ExitStat
argument_list|,
name|CurEnv
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|CurEnv
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|9
argument_list|)
condition|)
name|printopenfds
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* if we fail in finis(), just exit */
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* failed -- just give it up */
goto|goto
name|forceexit
goto|;
block|}
comment|/* clean up temp files */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|CurEnv
operator|->
name|e_id
operator|!=
name|NULL
condition|)
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* flush any cached connections */
name|mci_flush
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XLA
comment|/* clean up extended load average stuff */
name|xla_all_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* and exit */
name|forceexit
label|:
if|if
condition|(
name|LogLevel
operator|>
literal|78
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"finis, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ExitStat
operator|==
name|EX_TEMPFAIL
operator|||
name|CurEnv
operator|->
name|e_errormode
operator|==
name|EM_BERKNET
condition|)
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
comment|/* reset uid for process accounting */
name|endpwent
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INTSIG -- clean up on interrupt ** **	This just arranges to exit.  It pessimises in that it **	may resend a message. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Unlocks the current job. */
end_comment

begin_function
name|SIGFUNC_DECL
name|intsig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"interrupt"
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|NULL
expr_stmt|;
name|unlockqueue
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XLA
name|xla_all_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* reset uid for process accounting */
name|endpwent
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INITMACROS -- initialize the macro system ** **	This just involves defining some macros that are actually **	used internally as metasymbols to be themselves. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes several macros to be themselves. */
end_comment

begin_decl_stmt
name|struct
name|metamac
name|MetaMacros
index|[]
init|=
block|{
comment|/* LHS pattern matching characters */
block|{
literal|'*'
block|,
name|MATCHZANY
block|}
block|,
block|{
literal|'+'
block|,
name|MATCHANY
block|}
block|,
block|{
literal|'-'
block|,
name|MATCHONE
block|}
block|,
block|{
literal|'='
block|,
name|MATCHCLASS
block|}
block|,
block|{
literal|'~'
block|,
name|MATCHNCLASS
block|}
block|,
comment|/* these are RHS metasymbols */
block|{
literal|'#'
block|,
name|CANONNET
block|}
block|,
block|{
literal|'@'
block|,
name|CANONHOST
block|}
block|,
block|{
literal|':'
block|,
name|CANONUSER
block|}
block|,
block|{
literal|'>'
block|,
name|CALLSUBR
block|}
block|,
comment|/* the conditional operations */
block|{
literal|'?'
block|,
name|CONDIF
block|}
block|,
block|{
literal|'|'
block|,
name|CONDELSE
block|}
block|,
block|{
literal|'.'
block|,
name|CONDFI
block|}
block|,
comment|/* the hostname lookup characters */
block|{
literal|'['
block|,
name|HOSTBEGIN
block|}
block|,
block|{
literal|']'
block|,
name|HOSTEND
block|}
block|,
block|{
literal|'('
block|,
name|LOOKUPBEGIN
block|}
block|,
block|{
literal|')'
block|,
name|LOOKUPEND
block|}
block|,
comment|/* miscellaneous control characters */
block|{
literal|'&'
block|,
name|MACRODEXPAND
block|}
block|,
block|{
literal|'\0'
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MACBINDING
parameter_list|(
name|name
parameter_list|,
name|mid
parameter_list|)
define|\
value|stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \ 		MacroName[mid] = name;
end_define

begin_function
name|void
name|initmacros
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|struct
name|metamac
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|MacroName
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|m
operator|=
name|MetaMacros
init|;
name|m
operator|->
name|metaname
operator|!=
literal|'\0'
condition|;
name|m
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|metaval
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|m
operator|->
name|metaname
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|MATCHREPL
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|define
argument_list|(
name|c
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* set defaults for some macros sendmail will use later */
name|define
argument_list|(
literal|'n'
argument_list|,
literal|"MAILER-DAEMON"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* set up external names for some internal macros */
name|MACBINDING
argument_list|(
literal|"opMode"
argument_list|,
name|MID_OPMODE
argument_list|)
expr_stmt|;
comment|/*XXX should probably add equivalents for all short macros here XXX*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DISCONNECT -- remove our connection with any foreground process ** **	Parameters: **		droplev -- how "deeply" we should drop the line. **			0 -- ignore signals, mail back errors, make sure **			     output goes to stdout. **			1 -- also, make stdout go to transcript. **			2 -- also, disconnect from controlling terminal **			     (only for daemon mode). **		e -- the current envelope. ** **	Returns: **		none ** **	Side Effects: **		Trys to insure that we are immune to vagaries of **		the controlling tty. */
end_comment

begin_function
name|void
name|disconnect
parameter_list|(
name|droplev
parameter_list|,
name|e
parameter_list|)
name|int
name|droplev
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"disconnect: In %d Out %d, e=%lx\n"
argument_list|,
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"don't\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|93
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect level %d"
argument_list|,
name|droplev
argument_list|)
expr_stmt|;
comment|/* be sure we don't get nasty signals */
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* we can't communicate with our caller, so.... */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|Verbose
operator|=
literal|0
expr_stmt|;
name|DisConnected
operator|=
name|TRUE
expr_stmt|;
comment|/* all input from /dev/null */
if|if
condition|(
name|InChannel
operator|!=
name|stdin
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|InChannel
argument_list|)
expr_stmt|;
name|InChannel
operator|=
name|stdin
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* output to the transcript */
if|if
condition|(
name|OutChannel
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|OutChannel
argument_list|)
expr_stmt|;
name|OutChannel
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|droplev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|fileno
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* drop our controlling TTY completely if possible */
if|if
condition|(
name|droplev
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"disconnect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|LogLevel
operator|>
literal|71
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"in background, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obsolete
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|op
decl_stmt|;
while|while
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Return if "--" or not an option of any form. */
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|ap
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
return|return;
comment|/* skip over options that do have a value */
name|op
operator|=
name|strchr
argument_list|(
name|OPTIONS
argument_list|,
name|ap
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|op
operator|==
literal|':'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|ap
index|[
literal|1
index|]
operator|!=
literal|'d'
operator|&&
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
name|ap
index|[
literal|1
index|]
operator|!=
literal|'E'
operator|&&
name|ap
index|[
literal|1
index|]
operator|!=
literal|'J'
operator|&&
endif|#
directive|endif
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* If -C doesn't have an argument, use sendmail.cf. */
define|#
directive|define
name|__DEFPATH
value|"sendmail.cf"
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|argv
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__DEFPATH
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|'C'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|__DEFPATH
argument_list|)
expr_stmt|;
block|}
comment|/* If -q doesn't have an argument, run it once. */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'q'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-q0"
expr_stmt|;
comment|/* if -d doesn't have an argument, use 0-99.1 */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'d'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-d0-99.1"
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
comment|/* if -E doesn't have an argument, use -EC */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-EC"
expr_stmt|;
comment|/* if -J doesn't have an argument, use -JJ */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'J'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-JJ"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  AUTH_WARNING -- specify authorization warning ** **	Parameters: **		e -- the current envelope. **		msg -- the text of the message. **		args -- arguments to the message. ** **	Returns: **		none. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|auth_warning
parameter_list|(
specifier|register
name|ENVELOPE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|auth_warning
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|VA_LOCAL_DECL
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_AUTHWARNINGS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
literal|48
index|]
decl_stmt|;
specifier|extern
name|struct
name|hostent
modifier|*
name|myhostname
parameter_list|()
function_decl|;
if|if
condition|(
name|hostbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|myhostname
argument_list|(
name|hostbuf
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|hostbuf
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|VA_START
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
name|addheader
argument_list|(
literal|"X-Authentication-Warning"
argument_list|,
name|buf
argument_list|,
operator|&
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Authentication-Warning: %.400s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETEXTENV -- get from external environment ** **	Parameters: **		envar -- the name of the variable to retrieve ** **	Returns: **		The value, if any. */
end_comment

begin_function
name|char
modifier|*
name|getextenv
parameter_list|(
name|envar
parameter_list|)
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|envar
argument_list|)
expr_stmt|;
for|for
control|(
name|envp
operator|=
name|ExternalEnviron
init|;
operator|*
name|envp
operator|!=
name|NULL
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|envp
argument_list|,
name|envar
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|envp
operator|)
index|[
name|l
index|]
operator|==
literal|'='
condition|)
return|return
operator|&
operator|(
operator|*
name|envp
operator|)
index|[
name|l
operator|+
literal|1
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SETUSERENV -- set an environment in the propogated environment ** **	Parameters: **		envar -- the name of the environment variable. **		value -- the value to which it should be set.  If **			null, this is extracted from the incoming **			environment.  If that is not set, the call **			to setuserenv is ignored. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|setuserenv
parameter_list|(
name|envar
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|evp
init|=
name|UserEnviron
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|value
operator|=
name|getextenv
argument_list|(
name|envar
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|envar
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|envar
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|++
index|]
operator|=
literal|'='
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|p
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|evp
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
operator|*
name|evp
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|evp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|evp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|evp
operator|++
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evp
operator|<
operator|&
name|UserEnviron
index|[
name|MAXUSERENVIRON
index|]
condition|)
block|{
operator|*
name|evp
operator|++
operator|=
name|p
expr_stmt|;
operator|*
name|evp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* make sure it is in our environment as well */
if|if
condition|(
name|putenv
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"setuserenv: putenv(%s) failed"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DUMPSTATE -- dump state ** **	For debugging. */
end_comment

begin_function
name|void
name|dumpstate
parameter_list|(
name|when
parameter_list|)
name|char
modifier|*
name|when
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|j
init|=
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
decl_stmt|;
name|int
name|rs
decl_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- dumping state on %s: $j = %s ---"
argument_list|,
name|when
argument_list|,
name|j
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|wordinclass
argument_list|(
name|j
argument_list|,
literal|'w'
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"*** $j not in $=w ***"
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"CurChildren = %d"
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- open file descriptors: ---"
argument_list|)
expr_stmt|;
name|printopenfds
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- connection cache: ---"
argument_list|)
expr_stmt|;
name|mci_dump_all
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|rs
operator|=
name|strtorwset
argument_list|(
literal|"debug_dumpstate"
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|>
literal|0
condition|)
block|{
name|int
name|stat
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|pv
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|pv
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|stat
operator|=
name|rewrite
argument_list|(
name|pv
argument_list|,
name|rs
argument_list|,
literal|0
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- ruleset debug_dumpstate returns stat %d, pv: ---"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
for|for
control|(
name|pvp
operator|=
name|pv
init|;
operator|*
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|++
control|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|pvp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- end of state dump ---"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGFUNC_DECL
name|sigusr1
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|dumpstate
argument_list|(
literal|"user signal"
argument_list|)
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_function
name|SIGFUNC_DECL
name|sighup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|SaveArgv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"could not restart: need full path"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"restarting %s on signal"
argument_list|,
name|SaveArgv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|releasesignal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_privileges
argument_list|(
name|TRUE
argument_list|)
operator|!=
name|EX_OK
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"could not set[ug]id(%d, %d): %m"
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|execve
argument_list|(
name|SaveArgv
index|[
literal|0
index|]
argument_list|,
operator|(
name|ARGV_T
operator|)
name|SaveArgv
argument_list|,
operator|(
name|ARGV_T
operator|)
name|ExternalEnviron
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"could not exec %s: %m"
argument_list|,
name|SaveArgv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option ** **	Parameters: **		to_real_uid -- if set, drop to the real uid instead **			of the RunAsUser. ** **	Returns: **		EX_OSERR if the setuid failed. **		EX_OK otherwise. */
end_comment

begin_function
name|int
name|drop_privileges
parameter_list|(
name|to_real_uid
parameter_list|)
name|bool
name|to_real_uid
decl_stmt|;
block|{
name|int
name|rval
init|=
name|EX_OK
decl_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
name|GIDSET_T
name|emptygidset
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"drop_privileges(%d): Real[UG]id=%d:%d, RunAs[UG]id=%d:%d\n"
argument_list|,
name|to_real_uid
argument_list|,
name|RealUid
argument_list|,
name|RealGid
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real_uid
condition|)
block|{
name|RunAsUserName
operator|=
name|RealUserName
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
expr_stmt|;
name|RunAsGid
operator|=
name|RealGid
expr_stmt|;
block|}
comment|/* make sure no one can grab open descriptors for secret files */
name|endpwent
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
comment|/* reset group permissions; these can be set later */
name|emptygidset
index|[
literal|0
index|]
operator|=
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
condition|?
name|RunAsGid
else|:
name|getegid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setgroups
argument_list|(
literal|1
argument_list|,
name|emptygidset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* reset primary group and user id */
if|if
condition|(
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
operator|&&
name|setgid
argument_list|(
name|RunAsGid
argument_list|)
operator|<
literal|0
condition|)
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
if|if
condition|(
operator|(
name|to_real_uid
operator|||
name|RunAsUid
operator|!=
literal|0
operator|)
operator|&&
name|setuid
argument_list|(
name|RunAsUid
argument_list|)
operator|<
literal|0
condition|)
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FILL_FD -- make sure a file descriptor has been properly allocated ** **	Used to make sure that stdin/out/err are allocated on startup ** **	Parameters: **		fd -- the file descriptor to be filled. **		where -- a string used for logging.  If NULL, this is **			being called on startup, and logging should **			not be done. ** **	Returns: **		none */
end_comment

begin_function
name|void
name|fill_fd
parameter_list|(
name|fd
parameter_list|,
name|where
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|EBADF
condition|)
return|return;
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
name|syserr
argument_list|(
literal|"fill_fd: %s: fd %d not open"
argument_list|,
name|where
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|MissingFds
operator||=
literal|1
operator|<<
name|fd
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|fd
operator|==
literal|0
condition|?
name|O_RDONLY
else|:
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"!fill_fd: %s: cannot open /dev/null"
argument_list|,
name|where
operator|==
name|NULL
condition|?
literal|"startup"
else|:
name|where
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|i
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TESTMODELINE -- process a test mode input line ** **	Parameters: **		line -- the input line. **		e -- the current environment. **	Syntax: **		#  a comment **		.X process X as a configuration line **		=X dump a configuration item (such as mailers) **		$X dump a macro or class **		/X try an activity **		X  normal process through rule set X */
end_comment

begin_function
name|void
name|testmodeline
parameter_list|(
name|line
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rs
decl_stmt|;
name|STAB
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|struct
name|rewrite
modifier|*
name|rw
decl_stmt|;
name|ADDRESS
name|a
decl_stmt|;
specifier|static
name|int
name|tryflags
init|=
name|RF_COPYNONE
decl_stmt|;
name|char
name|exbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|bool
name|invalidaddr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|crackaddr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|dump_class
name|__P
argument_list|(
operator|(
name|STAB
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|translate_dollars
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|help
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|0
case|:
return|return;
case|case
literal|'?'
case|:
name|help
argument_list|(
literal|"-bt"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'.'
case|:
comment|/* config-style settings */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'D'
case|:
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|'\0'
condition|)
return|return;
name|translate_dollars
argument_list|(
name|delimptr
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|mid
argument_list|,
name|newstr
argument_list|(
name|delimptr
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|line
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
comment|/* not to call syserr() */
return|return;
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|'\0'
condition|)
return|return;
name|translate_dollars
argument_list|(
name|delimptr
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|delimptr
argument_list|,
name|exbuf
argument_list|,
sizeof|sizeof
name|exbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|exbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|wd
decl_stmt|;
name|char
name|delim
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|wd
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|delim
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|wd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setclass
argument_list|(
name|mid
argument_list|,
name|wd
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|delim
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Usage: .[DC]macro value(s)\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown \".\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'='
case|:
comment|/* config-style settings */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
comment|/* dump rule set */
name|rs
operator|=
name|strtorwset
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Undefined ruleset %s\n"
argument_list|,
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|rw
operator|=
name|RewriteRules
index|[
name|rs
index|]
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
name|putchar
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
name|s
operator|=
name|rw
operator|->
name|r_lhs
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
name|xputs
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|s
operator|=
name|rw
operator|->
name|r_rhs
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
name|xputs
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rw
operator|=
name|rw
operator|->
name|r_next
operator|)
operator|!=
name|NULL
condition|)
do|;
break|break;
case|case
literal|'M'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printmailer
argument_list|(
name|Mailer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Usage: =Sruleset or =M\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown \"=\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'-'
case|:
comment|/* set command-line-like opts */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|tTflag
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Usage: -d{debug arguments}\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown \"-\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'$'
case|:
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|!=
literal|'\0'
condition|)
name|stabapply
argument_list|(
name|dump_class
argument_list|,
name|mid
argument_list|)
expr_stmt|;
return|return;
block|}
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|'\0'
condition|)
return|return;
name|p
operator|=
name|macvalue
argument_list|(
name|mid
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Undefined\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|xputs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'/'
case|:
comment|/* miscellaneous commands */
name|p
operator|=
operator|&
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|line
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /[canon|map|mx|parse|try|tryflags]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"mx"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|NAMED_BIND
comment|/* look up MX records */
name|int
name|nmx
decl_stmt|;
specifier|auto
name|int
name|rcode
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /mx address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nmx
operator|=
name|getmxrr
argument_list|(
name|p
argument_list|,
name|mxhosts
argument_list|,
name|FALSE
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"getmxrr(%s) returns %d value(s):\n"
argument_list|,
name|p
argument_list|,
name|nmx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|mxhosts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No MX code compiled in\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"canon"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|host
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /canon address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
sizeof|sizeof
name|host
condition|)
block|{
name|printf
argument_list|(
literal|"Name too long\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|host
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getcanonname
argument_list|(
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|,
name|HasWildcardMX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"getcanonname(%s) returns %s\n"
argument_list|,
name|p
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"map"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|auto
name|int
name|rcode
init|=
name|EX_OK
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /map mapname key\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No key specified\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|map
operator|=
name|stab
argument_list|(
name|p
argument_list|,
name|ST_MAP
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Map named \"%s\" not found\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MF_OPEN
argument_list|,
name|map
operator|->
name|s_map
operator|.
name|map_mflags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Map named \"%s\" not open\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"map_lookup: %s (%s) "
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|=
call|(
modifier|*
name|map
operator|->
name|s_map
operator|.
name|map_class
operator|->
name|map_lookup
call|)
argument_list|(
operator|&
name|map
operator|->
name|s_map
argument_list|,
name|q
argument_list|,
name|NULL
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"no match (%d)\n"
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"returns %s (%d)\n"
argument_list|,
name|p
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"try"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|MAILER
modifier|*
name|m
decl_stmt|;
name|STAB
modifier|*
name|s
decl_stmt|;
specifier|auto
name|int
name|rcode
init|=
name|EX_OK
decl_stmt|;
name|q
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
operator|||
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /try mailer address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|stab
argument_list|(
name|p
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown mailer %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|s
operator|->
name|s_mailer
expr_stmt|;
name|printf
argument_list|(
literal|"Trying %s %s address %s for mailer %s\n"
argument_list|,
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"header"
else|:
literal|"envelope"
argument_list|,
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"sender"
else|:
literal|"recipient"
argument_list|,
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|remotename
argument_list|(
name|q
argument_list|,
name|m
argument_list|,
name|tryflags
argument_list|,
operator|&
name|rcode
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rcode = %d, addr = %s\n"
argument_list|,
name|rcode
argument_list|,
name|p
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|p
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"tryflags"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /tryflags [Hh|Ee][Ss|Rr]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|tryflags
operator||=
name|RF_HEADERADDR
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|tryflags
operator|&=
operator|~
name|RF_HEADERADDR
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|tryflags
operator||=
name|RF_SENDERADDR
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|tryflags
operator|&=
operator|~
name|RF_SENDERADDR
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"parse"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /parse address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|crackaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cracked address = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nParsing %s %s address\n"
argument_list|,
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"header"
else|:
literal|"envelope"
argument_list|,
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"sender"
else|:
literal|"recipient"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|p
argument_list|,
operator|&
name|a
argument_list|,
name|tryflags
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Cannot parse\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|.
name|q_host
operator|!=
name|NULL
operator|&&
name|a
operator|.
name|q_host
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"mailer %s, host %s, user %s\n"
argument_list|,
name|a
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|.
name|q_host
argument_list|,
name|a
operator|.
name|q_user
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"mailer %s, user %s\n"
argument_list|,
name|a
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|.
name|q_user
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unknown \"/\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|p
operator|=
name|line
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No address!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|invalidaddr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
do|do
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
operator|++
name|p
argument_list|,
literal|','
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
operator|&
name|delimptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|stat
decl_stmt|;
name|int
name|rs
init|=
name|strtorwset
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Undefined ruleset %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|stat
operator|=
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|rs
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|EX_OK
condition|)
name|printf
argument_list|(
literal|"== Ruleset %s (%d) status %d\n"
argument_list|,
name|p
argument_list|,
name|rs
argument_list|,
name|stat
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
continue|continue;
block|}
block|}
do|while
condition|(
operator|*
operator|(
name|p
operator|=
name|delimptr
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
end_function

begin_function
name|void
name|dump_class
parameter_list|(
name|s
parameter_list|,
name|id
parameter_list|)
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|int
name|id
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|s_type
operator|!=
name|ST_CLASS
condition|)
return|return;
if|if
condition|(
name|bitnset
argument_list|(
name|id
operator|&
literal|0xff
argument_list|,
name|s
operator|->
name|s_class
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

