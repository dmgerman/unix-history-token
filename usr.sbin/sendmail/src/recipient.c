begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)recipient.c	8.21 (Berkeley) 10/29/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/* **  SENDTOLIST -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	Parameters: **		list -- the send list. **		ctladdr -- the address template for the person to **			send to -- effective uid/gid are important. **			This is typically the alias that caused this **			expansion. **		sendq -- a pointer to the head of a queue to put **			these people into. **		e -- the envelope in which to add these recipients. ** **	Returns: **		The number of addresses actually on the list. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|MAXRCRSN
value|10
end_define

begin_macro
name|sendtolist
argument_list|(
argument|list
argument_list|,
argument|ctladdr
argument_list|,
argument|sendq
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|al
decl_stmt|;
comment|/* list of addresses to send to */
name|bool
name|firstone
decl_stmt|;
comment|/* set on first address sent */
name|char
name|delimiter
decl_stmt|;
comment|/* the address delimiter */
name|int
name|naddrs
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"sendtolist: null list"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendto: %s\n   ctladdr="
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* heuristic to determine old versus new style addresses */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|list
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
name|delimiter
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|ctladdr
operator|!=
name|NULL
condition|)
name|delimiter
operator|=
literal|','
expr_stmt|;
name|firstone
operator|=
name|TRUE
expr_stmt|;
name|al
operator|=
name|NULL
expr_stmt|;
name|naddrs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
comment|/* parse the address */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
name|delimiter
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|a
operator|->
name|q_next
operator|=
name|al
expr_stmt|;
name|a
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
comment|/* see if this should be marked as a primary address */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|||
operator|(
name|firstone
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|sameaddr
argument_list|(
name|ctladdr
argument_list|,
name|a
argument_list|)
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QSELFREF
expr_stmt|;
name|al
operator|=
name|a
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* arrange to send to everyone on the local send list */
while|while
condition|(
name|al
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
init|=
name|al
decl_stmt|;
name|al
operator|=
name|a
operator|->
name|q_next
expr_stmt|;
name|a
operator|=
name|recipient
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* arrange to inherit full name */
if|if
condition|(
name|a
operator|->
name|q_fullname
operator|==
name|NULL
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|ctladdr
operator|->
name|q_fullname
expr_stmt|;
name|naddrs
operator|++
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
return|return
operator|(
name|naddrs
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient ** **	Saves the named person for future mailing. ** **	Parameters: **		a -- the (preparsed) address header for the recipient. **		sendq -- a pointer to the head of a queue to put the **			recipient in.  Duplicate supression is done **			in this queue. **		e -- the current envelope. ** **	Returns: **		The actual address in the queue.  This will be "a" if **		the address is not a duplicate, else the original address. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|recipient
parameter_list|(
name|a
parameter_list|,
name|sendq
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|quoted
init|=
name|FALSE
decl_stmt|;
comment|/* set if the addr has a quote bit */
name|int
name|findusercount
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* unquoted image of the user name */
specifier|extern
name|int
name|safefile
parameter_list|()
function_decl|;
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nrecipient: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* if this is primary, add it to the original recipient list */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_origrcpt
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|e
operator|->
name|e_origrcpt
operator|=
literal|""
expr_stmt|;
block|}
comment|/* break aliasing loops */
if|if
condition|(
name|AliasLevel
operator|>
name|MAXRCRSN
condition|)
block|{
name|usrerr
argument_list|(
literal|"554 aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
comment|/* 	**  Finish setting up address structure. 	*/
comment|/* set the queue timeout */
name|a
operator|->
name|q_timeout
operator|=
name|TimeOuts
operator|.
name|to_q_return
expr_stmt|;
comment|/* get unquoted user for file, program or user.name check */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|quoted
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|quoted
operator|=
name|TRUE
expr_stmt|;
block|}
name|stripquotes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* check for direct mailing to restricted mailers */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
name|m
operator|==
name|ProgMailer
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot mail directly to programs"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Look up this person in the recipient list. 	**	If they are there already, return, otherwise continue. 	**	If the list is empty, just add it.  Notice the cute 	**	hack to make from addresses suppress things correctly: 	**	the QDONTSEND bit will be set in the send list. 	**	[Please note: the emphasis is on "hack."] 	*/
for|for
control|(
name|pq
operator|=
name|sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s in sendq: "
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|message
argument_list|(
literal|"duplicate suppressed"
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
expr_stmt|;
block|}
name|a
operator|=
name|q
expr_stmt|;
goto|goto
name|testselfdestruct
goto|;
block|}
block|}
comment|/* add address on list */
operator|*
name|pq
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Alias the name and handle special mailer types. 	*/
name|trylocaluser
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"at trylocaluser %s\n"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
goto|goto
name|testselfdestruct
goto|;
if|if
condition|(
name|m
operator|==
name|InclMailer
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot mail directly to :include:s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ret
decl_stmt|;
name|message
argument_list|(
literal|"including file %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|ret
operator|=
name|include
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|FALSE
argument_list|,
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|transienterror
argument_list|(
name|ret
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: include %s: transient error: %e"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 Cannot open %s: %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot open %s: %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|FileMailer
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
specifier|extern
name|bool
name|writable
parameter_list|()
function_decl|;
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* check if writable or creatable */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot mail directly to files"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|stb
argument_list|)
operator|>=
literal|0
operator|)
condition|?
operator|(
operator|!
name|writable
argument_list|(
operator|&
name|stb
argument_list|)
operator|)
else|:
operator|(
operator|*
name|p
operator|=
literal|'\0'
operator|,
name|safefile
argument_list|(
name|buf
argument_list|,
name|RealUid
argument_list|,
name|RealGid
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|S_IWRITE
operator||
name|S_IEXEC
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_CANTCREAT
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|LocalMailer
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
goto|goto
name|testselfdestruct
goto|;
block|}
comment|/* try aliasing */
name|alias
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERDB
comment|/* if not aliased, look it up in the user database */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QNOTREMOTE
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|udbexpand
parameter_list|()
function_decl|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|udbexpand
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_message
operator|=
name|newstr
argument_list|(
literal|"Deferred: user database error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: deferred: udbexpand: %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|message
argument_list|(
literal|"queued (user database error): %s"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
goto|goto
name|testselfdestruct
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* if it was an alias or a UDB expansion, just return now */
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QQUEUEUP
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
goto|goto
name|testselfdestruct
goto|;
comment|/* 	**  If we have a level two config file, then pass the name through 	**  Ruleset 5 before sending it off.  Ruleset 5 has the right 	**  to send rewrite it to another mailer.  This gives us a hook 	**  after local aliasing has been done. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"recipient: testing local?  cl=%d, rr5=%x\n\t"
argument_list|,
name|ConfigLevel
argument_list|,
name|RewriteRules
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QNOTREMOTE
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|ConfigLevel
operator|>=
literal|2
operator|&&
name|RewriteRules
index|[
literal|5
index|]
operator|!=
name|NULL
condition|)
block|{
name|maplocaluser
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If it didn't get rewritten to another mailer, go ahead 	**  and deliver it. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QQUEUEUP
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
specifier|auto
name|bool
name|fuzzy
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|()
function_decl|;
comment|/* warning -- finduser may trash buf */
name|pw
operator|=
name|finduser
argument_list|(
name|buf
argument_list|,
operator|&
name|fuzzy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|fuzzy
condition|)
block|{
comment|/* name was a fuzzy match */
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|findusercount
operator|++
operator|>
literal|3
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"554 aliasing/forwarding loop for %s broken"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
comment|/* see if it aliases */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
goto|goto
name|trylocaluser
goto|;
block|}
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_ruser
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quoted
condition|)
name|forward
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
name|testselfdestruct
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"testselfdestruct: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
name|a
operator|!=
operator|&
name|e
operator|->
name|e_from
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|q
operator|=
operator|*
name|sendq
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"554 aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINDUSER -- find the password entry for a user. ** **	This looks a lot like getpwnam, except that it may want to **	do some fancier pattern matching in /etc/passwd. ** **	This routine contains most of the time of many sendmail runs. **	It deserves to be optimized. ** **	Parameters: **		name -- the name to match against. **		fuzzyp -- an outarg that is set to TRUE if this entry **			was found using the fuzzy matching algorithm; **			set to FALSE otherwise. ** **	Returns: **		A pointer to a pw struct. **		NULL if name is unknown or ambiguous. ** **	Side Effects: **		may modify name. */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|(
name|name
parameter_list|,
name|fuzzyp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|bool
modifier|*
name|fuzzyp
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"finduser(%s): "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|fuzzyp
operator|=
name|FALSE
expr_stmt|;
comment|/* DEC Hesiod getpwnam accepts numeric strings -- short circuit it */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"failed (numeric input)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* look up this login name using fast path */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"found (non-fuzzy)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MATCHGECOS
comment|/* see if fuzzy matching allowed */
if|if
condition|(
operator|!
name|MatchGecos
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* search for a matching full name instead */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|SpaceSub
operator|&
literal|0177
operator|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"fuzzy matches %s\n"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"sending to login name %s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|*
name|fuzzyp
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"no fuzzy match found\n"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WRITABLE -- predicate returning if the file is writable. ** **	This routine must duplicate the algorithm in sys/fio.c. **	Unfortunately, we cannot use the access call since we **	won't necessarily be the real uid when we try to **	actually open the file. ** **	Notice that ANY file with ANY execute bit is automatically **	not writable.  This is also enforced by mailfile. ** **	Parameters: **		s -- pointer to a stat struct for the file. ** **	Returns: **		TRUE -- if we will be able to write this file. **		FALSE -- if we cannot write this file. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|writable
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
block|{
name|uid_t
name|euid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|0111
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|euid
operator|=
name|RealUid
expr_stmt|;
name|egid
operator|=
name|RealGid
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
name|euid
operator|=
name|s
operator|->
name|st_uid
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
name|egid
operator|=
name|s
operator|->
name|st_gid
expr_stmt|;
block|}
if|if
condition|(
name|euid
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|bits
operator|=
name|S_IWRITE
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
name|s
operator|->
name|st_uid
condition|)
block|{
name|bits
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
name|s
operator|->
name|st_gid
condition|)
name|bits
operator|>>=
literal|3
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|s
operator|->
name|st_mode
operator|&
name|bits
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INCLUDE -- handle :include: specification. ** **	Parameters: **		fname -- filename to include. **		forwarding -- if TRUE, we are reading a .forward file. **			if FALSE, it's a :include: file. **		ctladdr -- address template to use to fill in these **			addresses -- effective user/group id are **			the important things. **		sendq -- a pointer to the head of the send queue **			to put these addresses in. ** **	Returns: **		open error status ** **	Side Effects: **		reads the :include: file and sends to everyone **		listed in that file. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|CtxIncludeTimeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|includetimeout
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|include
parameter_list|(
name|fname
parameter_list|,
name|forwarding
parameter_list|,
name|ctladdr
parameter_list|,
name|sendq
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|bool
name|forwarding
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|oldfilename
init|=
name|FileName
decl_stmt|;
name|int
name|oldlinenumber
init|=
name|LineNumber
decl_stmt|;
specifier|register
name|EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|int
name|nincludes
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|ca
decl_stmt|;
name|uid_t
name|saveduid
decl_stmt|,
name|uid
decl_stmt|;
name|gid_t
name|savedgid
decl_stmt|,
name|gid
decl_stmt|;
name|char
modifier|*
name|uname
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"   ruid=%d euid=%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ctladdr "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: old uid = %d/%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|ca
operator|=
name|getctladdr
argument_list|(
name|ctladdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|==
name|NULL
condition|)
block|{
name|uid
operator|=
literal|0
expr_stmt|;
name|gid
operator|=
literal|0
expr_stmt|;
name|uname
operator|=
name|NULL
expr_stmt|;
name|saveduid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|uid
operator|=
name|ca
operator|->
name|q_uid
expr_stmt|;
name|gid
operator|=
name|ca
operator|->
name|q_gid
expr_stmt|;
name|uname
operator|=
name|ca
operator|->
name|q_user
expr_stmt|;
ifdef|#
directive|ifdef
name|HASSETREUID
name|saveduid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|savedgid
operator|=
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|saveduid
operator|==
literal|0
condition|)
block|{
name|initgroups
argument_list|(
name|uname
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|setreuid
argument_list|(
literal|0
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: new uid = %d/%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	**  If home directory is remote mounted but server is down, 	**  this can hang or give errors; use a timeout to avoid this 	*/
if|if
condition|(
name|setjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctladdr
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 open timeout on %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* return pseudo-error code */
name|rval
operator|=
name|EOPENTIMEOUT
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
name|ev
operator|=
name|setevent
argument_list|(
operator|(
name|time_t
operator|)
literal|60
argument_list|,
name|includetimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* the input file must be marked safe */
name|rval
operator|=
name|safefile
argument_list|(
name|fname
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|uname
argument_list|,
name|forwarding
argument_list|,
name|S_IREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
block|{
comment|/* don't use this :include: file */
name|clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: not safe (uid=%d): %s\n"
argument_list|,
name|uid
argument_list|,
name|errstring
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: open: %s\n"
argument_list|,
name|errstring
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ca
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|errno
expr_stmt|;
name|syserr
argument_list|(
literal|"Cannot fstat %s!"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctladdr
operator|->
name|q_uid
operator|=
name|st
operator|.
name|st_uid
expr_stmt|;
name|ctladdr
operator|->
name|q_gid
operator|=
name|st
operator|.
name|st_gid
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
block|}
name|clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|resetuid
label|:
ifdef|#
directive|ifdef
name|HASSETREUID
if|if
condition|(
name|saveduid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
if|if
condition|(
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|setreuid
argument_list|(
name|RealUid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"setreuid(%d, 0) failure (real=%d, eff=%d)"
argument_list|,
name|RealUid
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|savedgid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: reset uid = %d/%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_VRFYONLY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* don't do any more now */
name|ctladdr
operator|->
name|q_flags
operator||=
name|QVERIFIED
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
name|xfclose
argument_list|(
name|fp
argument_list|,
literal|"include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* read the file -- each line is a comma-separated list. */
name|FileName
operator|=
name|fname
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator|&=
operator|~
name|QSELFREF
expr_stmt|;
name|nincludes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|LineNumber
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|message
argument_list|(
literal|"%s to %s"
argument_list|,
name|forwarding
condition|?
literal|"forwarding"
else|:
literal|"sending"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|forwarding
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: forward %s => %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|oldto
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AliasLevel
operator|++
expr_stmt|;
name|nincludes
operator|+=
name|sendtolist
argument_list|(
name|buf
argument_list|,
name|ctladdr
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|AliasLevel
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|tTd
argument_list|(
literal|27
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: read error: %s\n"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nincludes
operator|>
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|QSELFREF
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"include: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ctladdr
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|fp
argument_list|,
literal|"include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|oldfilename
expr_stmt|;
name|LineNumber
operator|=
name|oldlinenumber
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|includetimeout
argument_list|()
block|{
name|longjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|,
literal|1
argument_list|)
block|; }
comment|/* **  SENDTOARGV -- send to an argument vector. ** **	Parameters: **		argv -- argument vector to send to. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		puts all addresses on the argument vector onto the **			send queue. */
name|sendtoargv
argument_list|(
name|argv
argument_list|,
name|e
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETCTLADDR -- get controlling address from an address header. ** **	If none, get one corresponding to the effective userid. ** **	Parameters: **		a -- the address to find the controller of. ** **	Returns: **		the controlling address. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

end_unit

