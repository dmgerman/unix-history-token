begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)queue.c	8.36 (Berkeley) 1/9/94 (with queueing)"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)queue.c	8.36 (Berkeley) 1/9/94 (without queueing)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_comment
comment|/* **  Work queue. */
end_comment

begin_struct
struct|struct
name|work
block|{
name|char
modifier|*
name|w_name
decl_stmt|;
comment|/* name of control file */
name|long
name|w_pri
decl_stmt|;
comment|/* priority of message, see below */
name|time_t
name|w_ctime
decl_stmt|;
comment|/* creation time of message */
name|struct
name|work
modifier|*
name|w_next
decl_stmt|;
comment|/* next in queue */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|work
name|WORK
typedef|;
end_typedef

begin_decl_stmt
name|WORK
modifier|*
name|WorkQ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of things to be done */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  QUEUEUP -- queue a message up for future transmission. ** **	Parameters: **		e -- the envelope to queue up. **		queueall -- if TRUE, queue all addresses, rather than **			just those with the QQUEUEUP flag set. **		announce -- if TRUE, tell when you are queueing up. ** **	Returns: **		none. ** **	Side Effects: **		The current request are saved in a control file. **		The queue file is left locked. */
end_comment

begin_expr_stmt
name|queueup
argument_list|(
name|e
argument_list|,
name|queueall
argument_list|,
name|announce
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|queueall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|announce
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|qf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|newid
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|MAILER
name|nullmailer
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|,
name|tf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Create control file. 	*/
name|newid
operator|=
operator|(
name|e
operator|->
name|e_id
operator|==
name|NULL
operator|)
operator|||
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
comment|/* if newid, queuename will create a locked qf file in e->lockfp */
name|strcpy
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'t'
argument_list|)
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|e
operator|->
name|e_lockfp
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
condition|)
name|newid
operator|=
name|FALSE
expr_stmt|;
comment|/* if newid, just write the qf file directly (instead of tf file) */
if|if
condition|(
operator|!
name|newid
condition|)
block|{
comment|/* get a locked tf file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|tf
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_EXCL
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
break|break;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|0
operator|&&
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"queueup: cannot create %s, uid=%d: %s"
argument_list|,
name|tf
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|lockfile
argument_list|(
name|fd
argument_list|,
name|tf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|LOG
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|0
operator|&&
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"queueup: cannot lock %s: %s"
argument_list|,
name|tf
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|31
condition|)
block|{
comment|/* save the old temp file away */
operator|(
name|void
operator|)
name|rename
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'T'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sleep
argument_list|(
name|i
operator|%
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
operator|(
name|tfp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printopenfds
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"!queueup: cannot create queue temp file %s, uid=%d"
argument_list|,
name|tf
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n>>>>> queueing %s%s>>>>>\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|newid
condition|?
literal|" (new id)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  tfp="
argument_list|)
expr_stmt|;
name|dumpfd
argument_list|(
name|fileno
argument_list|(
name|tfp
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  lockfp="
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
else|else
name|dumpfd
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If there is no data file yet, create one. 	*/
if|if
condition|(
name|e
operator|->
name|e_df
operator|==
name|NULL
condition|)
block|{
specifier|register
name|FILE
modifier|*
name|dfp
decl_stmt|;
extern|extern putbody(
block|)
empty_stmt|;
name|e
operator|->
name|e_df
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_df
operator|=
name|newstr
argument_list|(
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|e
operator|->
name|e_df
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
operator|(
name|dfp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot create data temp file %s, uid=%d"
argument_list|,
name|e
operator|->
name|e_df
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
name|dfp
argument_list|,
name|FileMailer
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|dfp
argument_list|,
literal|"queueup dfp"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_putbody
operator|=
name|putbody
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	**  Output future work requests. 	**	Priority and creation time should be first, since 	**	they are required by orderq. 	*/
end_comment

begin_comment
comment|/* output message priority */
end_comment

begin_expr_stmt
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"P%ld\n"
argument_list|,
name|e
operator|->
name|e_msgpriority
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* output creation time */
end_comment

begin_expr_stmt
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"T%ld\n"
argument_list|,
name|e
operator|->
name|e_ctime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* output type and name of data file */
end_comment

begin_if
if|if
condition|(
name|e
operator|->
name|e_bodytype
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"B%s\n"
argument_list|,
name|e
operator|->
name|e_bodytype
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"D%s\n"
argument_list|,
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* message from envelope, if it exists */
end_comment

begin_if
if|if
condition|(
name|e
operator|->
name|e_message
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"M%s\n"
argument_list|,
name|e
operator|->
name|e_message
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* send various flag bits through */
end_comment

begin_expr_stmt
name|p
operator|=
name|buf
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'w'
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'r'
expr_stmt|;
end_if

begin_expr_stmt
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"F%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* $r and $s and $_ macro values */
end_comment

begin_if
if|if
condition|(
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'r'
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"$r%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"$s%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"$_%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* output name of sender */
end_comment

begin_expr_stmt
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"S%s\n"
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* output list of error recipients */
end_comment

begin_expr_stmt
name|printctladdr
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_errorqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|printctladdr
argument_list|(
name|q
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"E%s\n"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_comment
comment|/* output list of recipient addresses */
end_comment

begin_for
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
operator|(
name|queueall
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
operator||
name|QSENT
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
block|{
name|printctladdr
argument_list|(
name|q
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"R%s\n"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|announce
condition|)
block|{
name|e
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
name|message
argument_list|(
literal|"queued"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|logdelivery
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"queued"
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"queueing "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_for

begin_comment
comment|/* 	**  Output headers for this message. 	**	Expand macros completely here.  Queue run will deal with 	**	everything as absolute headers. 	**		All headers that must be relative to the recipient 	**		can be cracked later. 	**	We set up a "null mailer" -- i.e., a mailer that will have 	**	no effect on the addresses as they are output. 	*/
end_comment

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nullmailer
argument_list|,
sizeof|sizeof
name|nullmailer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nullmailer
operator|.
name|m_re_rwset
operator|=
name|nullmailer
operator|.
name|m_rh_rwset
operator|=
name|nullmailer
operator|.
name|m_se_rwset
operator|=
name|nullmailer
operator|.
name|m_sh_rwset
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nullmailer
operator|.
name|m_eol
operator|=
literal|"\n"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|define
argument_list|(
literal|'g'
argument_list|,
literal|"\201f"
argument_list|,
name|e
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
specifier|extern
name|bool
name|bitzerop
parameter_list|()
function_decl|;
comment|/* don't output null headers */
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
operator|||
name|h
operator|->
name|h_value
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* don't output resent headers on non-resent messages */
if|if
condition|(
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
continue|continue;
comment|/* expand macros; if null, don't output header at all */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|expand
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
comment|/* output this header */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"H"
argument_list|)
expr_stmt|;
comment|/* if conditional, output the set of conditions */
if|if
condition|(
operator|!
name|bitzerop
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'?'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|'\0'
init|;
name|j
operator|<=
literal|'\177'
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitnset
argument_list|(
name|j
argument_list|,
name|h
operator|->
name|h_mflags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|j
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'?'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
block|}
comment|/* output the header: expand macros, convert addresses */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
operator||
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|bool
name|oldstyle
init|=
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|savetrace
init|=
name|TrafficLogFile
decl_stmt|;
name|TrafficLogFile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|oldstyle
operator|=
name|FALSE
expr_stmt|;
name|commaize
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|h_value
argument_list|,
name|tfp
argument_list|,
name|oldstyle
argument_list|,
operator|&
name|nullmailer
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TrafficLogFile
operator|=
name|savetrace
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|/* 	**  Clean up. 	*/
end_comment

begin_if
if|if
condition|(
name|fflush
argument_list|(
name|tfp
argument_list|)
operator|<
literal|0
operator|||
name|fsync
argument_list|(
name|fileno
argument_list|(
name|tfp
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|ferror
argument_list|(
name|tfp
argument_list|)
condition|)
block|{
if|if
condition|(
name|newid
condition|)
name|syserr
argument_list|(
literal|"!552 Error writing control file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"!452 Error writing control file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|newid
condition|)
block|{
comment|/* rename (locked) tf to be (locked) qf */
name|qf
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tf
argument_list|,
name|qf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"cannot rename(%s, %s), df=%s, uid=%d"
argument_list|,
name|tf
argument_list|,
name|qf
argument_list|,
name|e
operator|->
name|e_df
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* close and unlock old (locked) qf */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
literal|"queueup lockfp"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|tfp
expr_stmt|;
block|}
else|else
name|qf
operator|=
name|tf
expr_stmt|;
end_if

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_comment
comment|/* save log info */
end_comment

begin_if
if|if
condition|(
name|LogLevel
operator|>
literal|79
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: queueup, qf=%s, df=%s\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|qf
argument_list|,
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOG */
end_comment

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"<<<<< done queueing %s<<<<<\n\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
end_if

begin_return
return|return;
end_return

begin_expr_stmt
unit|}  printctladdr
operator|(
name|a
operator|,
name|tfp
operator|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tfp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|uname
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
specifier|static
name|ADDRESS
modifier|*
name|lastctladdr
decl_stmt|;
specifier|static
name|uid_t
name|lastuid
decl_stmt|;
comment|/* initialization */
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|||
name|tfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lastctladdr
operator|!=
name|NULL
operator|&&
name|tfp
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"C\n"
argument_list|)
expr_stmt|;
name|lastctladdr
operator|=
name|NULL
expr_stmt|;
name|lastuid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* find the active uid */
name|q
operator|=
name|getctladdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|uid
operator|=
literal|0
expr_stmt|;
else|else
name|uid
operator|=
name|q
operator|->
name|q_uid
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
comment|/* check to see if this is the same as last time */
if|if
condition|(
name|lastctladdr
operator|!=
name|NULL
operator|&&
name|uid
operator|==
name|lastuid
operator|&&
name|strcmp
argument_list|(
name|lastctladdr
operator|->
name|q_paddr
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|lastuid
operator|=
name|uid
expr_stmt|;
name|lastctladdr
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|||
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|uname
operator|=
literal|""
expr_stmt|;
else|else
name|uname
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"C%s:%s\n"
argument_list|,
name|uname
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RUNQUEUE -- run the jobs in the queue. ** **	Gets the stuff out of the queue in some presumably logical **	order and processes them. ** **	Parameters: **		forkflag -- TRUE if the queue scanning should be done in **			a child process.  We double-fork so it is not our **			child and we don't have to clean up after it. ** **	Returns: **		none. ** **	Side Effects: **		runs things in the mail queue. */
end_comment

begin_decl_stmt
name|ENVELOPE
name|QueueEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the queue run envelope */
end_comment

begin_macro
name|runqueue
argument_list|(
argument|forkflag
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
comment|/* 	**  If no work will ever be selected, don't even bother reading 	**  the queue. 	*/
name|CurrentLA
operator|=
name|getla
argument_list|()
expr_stmt|;
comment|/* get load average */
if|if
condition|(
name|shouldqueue
argument_list|(
literal|0L
argument_list|,
name|curtime
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"Skipping queue run -- load average too high\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkflag
operator|&&
name|QueueIntvl
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|setevent
argument_list|(
name|QueueIntvl
argument_list|,
name|runqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  See if we want to go off and do other useful work. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
name|int
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
specifier|extern
name|void
name|reapchild
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* parent -- pick up intermediate zombie */
ifndef|#
directive|ifndef
name|SIGCHLD
operator|(
name|void
operator|)
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCHLD */
if|if
condition|(
name|QueueIntvl
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|setevent
argument_list|(
name|QueueIntvl
argument_list|,
name|runqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* child -- double fork */
ifndef|#
directive|ifndef
name|SIGCHLD
if|if
condition|(
name|fork
argument_list|()
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SIGCHLD */
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCHLD */
block|}
name|setproctitle
argument_list|(
literal|"running queue: %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|69
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"runqueue %s, pid=%d, forkflag=%d"
argument_list|,
name|QueueDir
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
comment|/* 	**  Release any resources used by the daemon code. 	*/
ifdef|#
directive|ifdef
name|DAEMON
name|clrdaemon
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DAEMON */
comment|/* force it to run expensive jobs */
name|NoConnect
operator|=
name|FALSE
expr_stmt|;
comment|/* 	**  Create ourselves an envelope 	*/
name|CurEnv
operator|=
operator|&
name|QueueEnvelope
expr_stmt|;
name|e
operator|=
name|newenvelope
argument_list|(
operator|&
name|QueueEnvelope
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
comment|/* 	**  Make sure the alias database is open. 	*/
name|initmaps
argument_list|(
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  Start making passes through the queue. 	**	First, read and sort the entire queue. 	**	Then, process the work in that order. 	**		But if you take too long, start over. 	*/
comment|/* order the existing work requests */
operator|(
name|void
operator|)
name|orderq
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* process them once at a time */
while|while
condition|(
name|WorkQ
operator|!=
name|NULL
condition|)
block|{
name|WORK
modifier|*
name|w
init|=
name|WorkQ
decl_stmt|;
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
comment|/* 		**  Ignore jobs that are too expensive for the moment. 		*/
if|if
condition|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\nSkipping %s\n"
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pid_t
name|pid
decl_stmt|;
specifier|extern
name|pid_t
name|dowork
parameter_list|()
function_decl|;
name|pid
operator|=
name|dowork
argument_list|(
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|ForkQueueRuns
argument_list|,
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
comment|/* exit without the usual cleanup */
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ORDERQ -- order the work queue. ** **	Parameters: **		doall -- if set, include everything in the queue (even **			the jobs that cannot be run because the load **			average is too high).  Otherwise, exclude those **			jobs. ** **	Returns: **		The number of request in the queue (not necessarily **		the number of requests in WorkQ however). ** **	Side Effects: **		Sets WorkQ to the queue of available work, in order. */
end_comment

begin_define
define|#
directive|define
name|NEED_P
value|001
end_define

begin_define
define|#
directive|define
name|NEED_T
value|002
end_define

begin_define
define|#
directive|define
name|NEED_R
value|004
end_define

begin_define
define|#
directive|define
name|NEED_S
value|010
end_define

begin_macro
name|orderq
argument_list|(
argument|doall
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|doall
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
name|DIR
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|WORK
name|wlist
index|[
name|QUEUESIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|wn
init|=
operator|-
literal|1
decl_stmt|;
extern|extern workcmpf(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"orderq:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueLimitId
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\tQueueLimitId = %s\n"
argument_list|,
name|QueueLimitId
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueLimitSender
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\tQueueLimitSender = %s\n"
argument_list|,
name|QueueLimitSender
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueLimitRecipient
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\tQueueLimitRecipient = %s\n"
argument_list|,
name|QueueLimitRecipient
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* clear out old WorkQ */
end_comment

begin_for
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
control|)
block|{
specifier|register
name|WORK
modifier|*
name|nw
init|=
name|w
operator|->
name|w_next
decl_stmt|;
name|WorkQ
operator|=
name|nw
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|nw
expr_stmt|;
block|}
end_for

begin_comment
comment|/* open the queue directory */
end_comment

begin_expr_stmt
name|f
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"orderq: cannot open \"%s\" as \".\""
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_comment
comment|/* 	**  Read the work directory. 	*/
end_comment

begin_while
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|cf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|extern
name|bool
name|strcontainedin
parameter_list|()
function_decl|;
comment|/* is this an interesting entry? */
if|if
condition|(
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'q'
operator|||
name|d
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'f'
condition|)
continue|continue;
if|if
condition|(
name|QueueLimitId
operator|!=
name|NULL
operator|&&
operator|!
name|strcontainedin
argument_list|(
name|QueueLimitId
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
comment|/* 		**  Check queue name for plausibility.  This handles 		**  both old and new type ids. 		*/
name|p
operator|=
name|d
operator|->
name|d_name
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isupper
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
name|p
operator|=
name|d
operator|->
name|d_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
operator|||
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"orderq: bogus qf name %s\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"orderq: bogus qf name %s"
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|>=
name|MAXNAME
condition|)
name|d
operator|->
name|d_name
index|[
name|MAXNAME
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|0
index|]
operator|=
literal|'Q'
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* yes -- open control file (if not too many files) */
if|if
condition|(
operator|++
name|wn
operator|>=
name|QUEUESIZE
condition|)
continue|continue;
name|cf
operator|=
name|fopen
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
block|{
comment|/* this may be some random person sending hir msgs */
comment|/* syserr("orderq: cannot open %s", cbuf); */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"orderq: cannot open %s (%d)\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
name|w
operator|=
operator|&
name|wlist
index|[
name|wn
index|]
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* make sure jobs in creation don't clog queue */
name|w
operator|->
name|w_pri
operator|=
literal|0x7fffffff
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
literal|0
expr_stmt|;
comment|/* extract useful information */
name|i
operator|=
name|NEED_P
operator||
name|NEED_T
expr_stmt|;
if|if
condition|(
name|QueueLimitSender
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_S
expr_stmt|;
if|if
condition|(
name|QueueLimitRecipient
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_R
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
operator|&&
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|,
name|cf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|long
name|atol
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|strcontainedin
parameter_list|()
function_decl|;
switch|switch
condition|(
name|lbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'P'
case|:
name|w
operator|->
name|w_pri
operator|=
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_P
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|w
operator|->
name|w_ctime
operator|=
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_T
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|QueueLimitRecipient
operator|!=
name|NULL
operator|&&
name|strcontainedin
argument_list|(
name|QueueLimitRecipient
argument_list|,
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
condition|)
name|i
operator|&=
operator|~
name|NEED_R
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|QueueLimitSender
operator|!=
name|NULL
operator|&&
name|strcontainedin
argument_list|(
name|QueueLimitSender
argument_list|,
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
condition|)
name|i
operator|&=
operator|~
name|NEED_S
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|doall
operator|&&
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
operator|)
operator|||
name|bitset
argument_list|(
name|NEED_R
operator||
name|NEED_S
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* don't even bother sorting this job in */
name|wn
operator|--
expr_stmt|;
block|}
block|}
end_while

begin_expr_stmt
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|f
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wn
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Sort the work directory. 	*/
end_comment

begin_expr_stmt
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wlist
argument_list|,
name|min
argument_list|(
name|wn
argument_list|,
name|QUEUESIZE
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|wlist
argument_list|,
name|workcmpf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Convert the work list into canonical form. 	**	Should be turning it into a list of envelopes here perhaps. 	*/
end_comment

begin_expr_stmt
name|WorkQ
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
name|min
argument_list|(
name|wn
argument_list|,
name|QUEUESIZE
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|w
operator|=
operator|(
name|WORK
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|wlist
index|[
name|i
index|]
operator|.
name|w_name
expr_stmt|;
name|w
operator|->
name|w_pri
operator|=
name|wlist
index|[
name|i
index|]
operator|.
name|w_pri
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
name|wlist
index|[
name|i
index|]
operator|.
name|w_ctime
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|WorkQ
expr_stmt|;
name|WorkQ
operator|=
name|w
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
name|printf
argument_list|(
literal|"%32s: pri=%ld\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|wn
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  WORKCMPF -- compare function for ordering work. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
unit|workcmpf
operator|(
name|a
operator|,
name|b
operator|)
specifier|register
name|WORK
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|pa
init|=
name|a
operator|->
name|w_pri
decl_stmt|;
name|long
name|pb
init|=
name|b
operator|->
name|w_pri
decl_stmt|;
if|if
condition|(
name|pa
operator|==
name|pb
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|pa
operator|>
name|pb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DOWORK -- do a work request. ** **	Parameters: **		id -- the ID of the job to run. **		forkflag -- if set, run this in background. **		requeueflag -- if set, reinstantiate the queue quickly. **			This is used when expanding aliases in the queue. **			If forkflag is also set, it doesn't wait for the **			child. **		e - the envelope in which to run it. ** **	Returns: **		process id of process that is running the queue job. ** **	Side Effects: **		The work request is satisfied if possible. */
end_comment

begin_function
name|pid_t
name|dowork
parameter_list|(
name|id
parameter_list|,
name|forkflag
parameter_list|,
name|requeueflag
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|bool
name|forkflag
decl_stmt|;
name|bool
name|requeueflag
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|pid_t
name|pid
decl_stmt|;
specifier|extern
name|bool
name|readqf
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"dowork(%s)\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	**  Fork for work. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dowork: cannot fork"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* parent -- clean out connection cache */
name|mci_flush
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* 		**  CHILD 		**	Lock the control file to avoid duplicate deliveries. 		**		Then run the file as though we had just read it. 		**	We save an idea of the temporary name so we 		**		can recover on interrupt. 		*/
comment|/* set basic modes, etc. */
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_QUEUERUN
operator||
name|EF_GLOBALERRS
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|id
expr_stmt|;
name|GrabTo
operator|=
name|UseErrorsTo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|76
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: dowork, pid=%d"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
comment|/* don't use the headers from sendmail.cf... */
name|e
operator|->
name|e_header
operator|=
name|NULL
expr_stmt|;
comment|/* read the queue control file -- return if locked */
if|if
condition|(
operator|!
name|readqf
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"readqf(%s) failed\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|eatheader
argument_list|(
name|e
argument_list|,
name|requeueflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|requeueflag
condition|)
name|queueup
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* do the delivery */
name|sendall
argument_list|(
name|e
argument_list|,
name|SM_DELIVER
argument_list|)
expr_stmt|;
comment|/* finish up and exit */
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|()
expr_stmt|;
else|else
name|dropenvelope
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  READQF -- read queue file and set up environment. ** **	Parameters: **		e -- the envelope of the job to run. ** **	Returns: **		TRUE if it successfully read the queue file. **		FALSE otherwise. ** **	Side Effects: **		The queue file is returned locked. */
end_comment

begin_function
name|bool
name|readqf
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|qfp
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|qf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|long
name|atol
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|setctluser
parameter_list|()
function_decl|;
comment|/* 	**  Read and process the file. 	*/
name|strcpy
argument_list|(
name|qf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
argument_list|)
expr_stmt|;
name|qfp
operator|=
name|fopen
argument_list|(
name|qf
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"readqf(%s): fopen failure (%s)\n"
argument_list|,
name|qf
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|syserr
argument_list|(
literal|"readqf: no control file %s"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|lockfile
argument_list|(
name|fileno
argument_list|(
name|qfp
argument_list|)
argument_list|,
name|qf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
comment|/* being processed by another queuer */
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"readqf(%s): locked\n"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%s: locked\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: locked"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	**  Check the queue file for plausibility to avoid attacks. 	*/
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|qfp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* must have been being processed by someone else */
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"readqf(%s): fstat failure (%s)\n"
argument_list|,
name|qf
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|geteuid
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"%s: bogus queue file, uid=%d, mode=%o"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOG */
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"readqf(%s): bogus file\n"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|qf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'Q'
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
comment|/* must be a bogus file -- just remove it */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|qf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
comment|/* 		**  Race condition -- we got a file just as it was being 		**  unlinked.  Just assume it is zero length. 		*/
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* good file -- save this lock */
name|e
operator|->
name|e_lockfp
operator|=
name|qfp
expr_stmt|;
comment|/* do basic system initialization */
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\nRunning %s\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|ctladdr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|fgetfolded
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|qfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"+++++ %s\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
comment|/* specify controlling user */
name|ctladdr
operator|=
name|setctluser
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* specify recipient */
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|ctladdr
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* specify error recipient */
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|ctladdr
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* header */
operator|(
name|void
operator|)
name|chompheader
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* message */
comment|/* ignore this; we want a new message next time */
break|break;
case|case
literal|'S'
case|:
comment|/* sender */
name|setsender
argument_list|(
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
name|e
operator|->
name|e_bodytype
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* data file name */
name|e
operator|->
name|e_df
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|fopen
argument_list|(
name|e
operator|->
name|e_df
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"readqf: cannot open %s"
argument_list|,
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
name|e
operator|->
name|e_msgsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* init time */
name|e
operator|->
name|e_ctime
operator|=
name|atol
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* message priority */
name|e
operator|->
name|e_msgpriority
operator|=
name|atol
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
operator|+
name|WkTimeFact
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* flag bits */
for|for
control|(
name|p
operator|=
operator|&
name|bp
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'w'
case|:
comment|/* warning sent */
name|e
operator|->
name|e_flags
operator||=
name|EF_WARNING
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* response */
name|e
operator|->
name|e_flags
operator||=
name|EF_RESPONSE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'$'
case|:
comment|/* define macro */
name|define
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|,
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* blank line; ignore */
break|break;
default|default:
name|syserr
argument_list|(
literal|"readqf: %s: line %s: bad line \"%s\""
argument_list|,
name|qf
argument_list|,
name|LineNumber
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|qf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'Q'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bp
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If we haven't read any lines, this queue file is empty. 	**  Arrange to remove it without referencing any null pointers. 	*/
if|if
condition|(
name|LineNumber
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
operator||
name|EF_FATALERRS
operator||
name|EF_RESPONSE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTQUEUE -- print out a representation of the mail queue ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Prints a listing of the mail queue on the standard output. */
end_comment

begin_macro
name|printqueue
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|nrequests
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Check for permission to print the queue 	*/
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_RESTRICTMAILQ
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
name|RealUid
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS
name|int
name|n
decl_stmt|;
name|GIDSET_T
name|gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|QueueDir
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot stat %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|NGROUPS
name|n
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gidset
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|gidset
index|[
name|n
index|]
operator|==
name|st
operator|.
name|st_gid
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|RealGid
operator|!=
name|st
operator|.
name|st_gid
condition|)
endif|#
directive|endif
block|{
name|usrerr
argument_list|(
literal|"510 You are not permitted to see the queue"
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|EX_NOPERM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	**  Read and order the queue. 	*/
name|nrequests
operator|=
name|orderq
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	**  Print the work list that we have read. 	*/
comment|/* first see if there is anything */
if|if
condition|(
name|nrequests
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Mail queue is empty\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|CurrentLA
operator|=
name|getla
argument_list|()
expr_stmt|;
comment|/* get load average */
name|printf
argument_list|(
literal|"\t\tMail Queue (%d request%s"
argument_list|,
name|nrequests
argument_list|,
name|nrequests
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrequests
operator|>
name|QUEUESIZE
condition|)
name|printf
argument_list|(
literal|", only %d printed"
argument_list|,
name|QUEUESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|")\n--Q-ID-- --Size-- -Priority- ---Q-Time--- -----------Sender/Recipient-----------\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|")\n--Q-ID-- --Size-- -----Q-Time----- ------------Sender/Recipient------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|auto
name|time_t
name|submittime
init|=
literal|0
decl_stmt|;
name|long
name|dfsize
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|char
name|message
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|bodytype
index|[
name|MAXNAME
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%8s"
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|w
operator|->
name|w_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" (job completed)\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|lockfile
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|NULL
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
condition|)
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
condition|)
name|printf
argument_list|(
literal|"X"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|message
index|[
literal|0
index|]
operator|=
name|bodytype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|fixcrlf
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'M'
case|:
comment|/* error message */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|message
condition|)
name|i
operator|=
sizeof|sizeof
name|message
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|message
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|message
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|bodytype
condition|)
name|i
operator|=
sizeof|sizeof
name|bodytype
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|bodytype
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bodytype
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* sender name */
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%8ld %10ld%c%.12s %.38s"
argument_list|,
name|dfsize
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|flags
argument_list|)
condition|?
literal|'+'
else|:
literal|' '
argument_list|,
name|ctime
argument_list|(
operator|&
name|submittime
argument_list|)
operator|+
literal|4
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%8ld %.16s %.45s"
argument_list|,
name|dfsize
argument_list|,
name|ctime
argument_list|(
operator|&
name|submittime
argument_list|)
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|bodytype
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"\n    %10.10s"
argument_list|,
name|bodytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"   (%.60s)"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* controlling user */
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t\t      (---%.34s---)"
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* recipient name */
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t\t\t  %.38s"
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n\t\t\t\t   %.45s"
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* creation time */
name|submittime
operator|=
name|atol
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* data file name */
if|if
condition|(
name|stat
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
name|dfsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* flag bits */
for|for
control|(
name|p
operator|=
operator|&
name|buf
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'w'
case|:
name|flags
operator||=
name|EF_WARNING
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|submittime
operator|==
operator|(
name|time_t
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|" (no control file)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUEUE */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  QUEUENAME -- build a file name in the queue directory for this envelope. ** **	Assigns an id code if one does not already exist. **	This code is very careful to avoid trashing existing files **	under any circumstances. ** **	Parameters: **		e -- envelope to build it in/from. **		type -- the file type, used as the first character **			of the file name. ** **	Returns: **		a pointer to the new file name (in a static buffer). ** **	Side Effects: **		If no id code is already assigned, queuename will **		assign an id code, create a qf file, and leave a **		locked, open-for-write file pointer in the envelope. */
end_comment

begin_function
name|char
modifier|*
name|queuename
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|static
name|int
name|pid
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|char
name|c0
decl_stmt|;
specifier|static
name|char
name|c1
decl_stmt|;
specifier|static
name|char
name|c2
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
block|{
name|char
name|qf
index|[
literal|20
index|]
decl_stmt|;
comment|/* find a unique id */
if|if
condition|(
name|pid
operator|!=
name|getpid
argument_list|()
condition|)
block|{
comment|/* new process -- start back at "AA" */
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|c0
operator|=
literal|'A'
operator|+
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|c1
operator|=
literal|'A'
expr_stmt|;
name|c2
operator|=
literal|'A'
operator|-
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|qf
argument_list|,
literal|"qf%cAA%05d"
argument_list|,
name|c0
argument_list|,
name|pid
argument_list|)
expr_stmt|;
while|while
condition|(
name|c1
operator|<
literal|'~'
operator|||
name|c2
operator|<
literal|'Z'
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c2
operator|>=
literal|'Z'
condition|)
block|{
name|c1
operator|++
expr_stmt|;
name|c2
operator|=
literal|'A'
operator|-
literal|1
expr_stmt|;
block|}
name|qf
index|[
literal|3
index|]
operator|=
name|c1
expr_stmt|;
name|qf
index|[
literal|4
index|]
operator|=
operator|++
name|c2
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|20
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: trying \"%s\"\n"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|qf
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
continue|continue;
name|syserr
argument_list|(
literal|"queuename: Cannot create \"%s\" in \"%s\" (euid=%d)"
argument_list|,
name|qf
argument_list|,
name|QueueDir
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lockfile
argument_list|(
name|i
argument_list|,
name|qf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
name|e
operator|->
name|e_lockfp
operator|=
name|fdopen
argument_list|(
name|i
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* a reader got the file; abandon it and try again */
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|>=
literal|'~'
operator|&&
name|c2
operator|>=
literal|'Z'
condition|)
block|{
name|syserr
argument_list|(
literal|"queuename: Cannot create \"%s\" in \"%s\" (euid=%d)"
argument_list|,
name|qf
argument_list|,
name|QueueDir
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_id
operator|=
name|newstr
argument_list|(
operator|&
name|qf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: assigned id %s, env=%x\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  lockfd="
argument_list|)
expr_stmt|;
name|dumpfd
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|93
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: assigned id"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
block|}
if|if
condition|(
name|type
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%cf%s"
argument_list|,
name|type
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  UNLOCKQUEUE -- unlock the queue entry for a specified envelope ** **	Parameters: **		e -- the envelope to unlock. ** **	Returns: **		none ** **	Side Effects: **		unlocks the queue for `e'. */
end_comment

begin_macro
name|unlockqueue
argument_list|(
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|51
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"unlockqueue(%s)\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
comment|/* if there is a lock file in the envelope, close it */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
name|xfclose
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
literal|"unlockqueue"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
comment|/* don't create a queue id if we don't already have one */
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
return|return;
comment|/* remove the transcript */
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|87
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: unlock"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|51
argument_list|,
literal|104
argument_list|)
condition|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'x'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SETCTLUSER -- create a controlling address ** **	Create a fake "address" given only a local login name; this is **	used as a "controlling user" for future recipient addresses. ** **	Parameters: **		user -- the user name of the controlling user. ** **	Returns: **		An address descriptor for the controlling user. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|setctluser
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	**  See if this clears our concept of controlling user. 	*/
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
operator|*
name|user
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
comment|/* 	**  Set up addr fields for controlling user. 	*/
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|user
operator|!=
literal|'\0'
operator|&&
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|DefUser
argument_list|)
expr_stmt|;
block|}
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
comment|/* flag as a "ctladdr"  */
name|a
operator|->
name|q_mailer
operator|=
name|LocalMailer
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|a
operator|->
name|q_user
expr_stmt|;
else|else
name|a
operator|->
name|q_paddr
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

end_unit

