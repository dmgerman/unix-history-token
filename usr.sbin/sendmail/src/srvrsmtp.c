begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1995-1997 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
name|SMTP
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)srvrsmtp.c	8.159 (Berkeley) 10/19/97 (with SMTP)"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)srvrsmtp.c	8.159 (Berkeley) 10/19/97 (without SMTP)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|SMTP
end_if

begin_comment
comment|/* **  SMTP -- run the SMTP protocol. ** **	Parameters: **		none. ** **	Returns: **		never. ** **	Side Effects: **		Reads commands from the input channel and processes **			them. */
end_comment

begin_struct
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmdname
decl_stmt|;
comment|/* command name */
name|int
name|cmdcode
decl_stmt|;
comment|/* internal code, see below */
block|}
struct|;
end_struct

begin_comment
comment|/* values for cmdcode */
end_comment

begin_define
define|#
directive|define
name|CMDERROR
value|0
end_define

begin_comment
comment|/* bad command */
end_comment

begin_define
define|#
directive|define
name|CMDMAIL
value|1
end_define

begin_comment
comment|/* mail -- designate sender */
end_comment

begin_define
define|#
directive|define
name|CMDRCPT
value|2
end_define

begin_comment
comment|/* rcpt -- designate recipient */
end_comment

begin_define
define|#
directive|define
name|CMDDATA
value|3
end_define

begin_comment
comment|/* data -- send message text */
end_comment

begin_define
define|#
directive|define
name|CMDRSET
value|4
end_define

begin_comment
comment|/* rset -- reset state */
end_comment

begin_define
define|#
directive|define
name|CMDVRFY
value|5
end_define

begin_comment
comment|/* vrfy -- verify address */
end_comment

begin_define
define|#
directive|define
name|CMDEXPN
value|6
end_define

begin_comment
comment|/* expn -- expand address */
end_comment

begin_define
define|#
directive|define
name|CMDNOOP
value|7
end_define

begin_comment
comment|/* noop -- do nothing */
end_comment

begin_define
define|#
directive|define
name|CMDQUIT
value|8
end_define

begin_comment
comment|/* quit -- close connection and die */
end_comment

begin_define
define|#
directive|define
name|CMDHELO
value|9
end_define

begin_comment
comment|/* helo -- be polite */
end_comment

begin_define
define|#
directive|define
name|CMDHELP
value|10
end_define

begin_comment
comment|/* help -- give usage info */
end_comment

begin_define
define|#
directive|define
name|CMDEHLO
value|11
end_define

begin_comment
comment|/* ehlo -- extended helo (RFC 1425) */
end_comment

begin_define
define|#
directive|define
name|CMDETRN
value|12
end_define

begin_comment
comment|/* etrn -- flush queue */
end_comment

begin_comment
comment|/* non-standard commands */
end_comment

begin_define
define|#
directive|define
name|CMDONEX
value|16
end_define

begin_comment
comment|/* onex -- sending one transaction only */
end_comment

begin_define
define|#
directive|define
name|CMDVERB
value|17
end_define

begin_comment
comment|/* verb -- go into verbose mode */
end_comment

begin_define
define|#
directive|define
name|CMDXUSR
value|18
end_define

begin_comment
comment|/* xusr -- initial (user) submission */
end_comment

begin_comment
comment|/* use this to catch and log "door handle" attempts on your system */
end_comment

begin_define
define|#
directive|define
name|CMDLOGBOGUS
value|23
end_define

begin_comment
comment|/* bogus command that should be logged */
end_comment

begin_comment
comment|/* debugging-only commands, only enabled if SMTPDEBUG is defined */
end_comment

begin_define
define|#
directive|define
name|CMDDBGQSHOW
value|24
end_define

begin_comment
comment|/* showq -- show send queue */
end_comment

begin_define
define|#
directive|define
name|CMDDBGDEBUG
value|25
end_define

begin_comment
comment|/* debug -- set debug mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd
name|CmdTab
index|[]
init|=
block|{
block|{
literal|"mail"
block|,
name|CMDMAIL
block|}
block|,
block|{
literal|"rcpt"
block|,
name|CMDRCPT
block|}
block|,
block|{
literal|"data"
block|,
name|CMDDATA
block|}
block|,
block|{
literal|"rset"
block|,
name|CMDRSET
block|}
block|,
block|{
literal|"vrfy"
block|,
name|CMDVRFY
block|}
block|,
block|{
literal|"expn"
block|,
name|CMDEXPN
block|}
block|,
block|{
literal|"help"
block|,
name|CMDHELP
block|}
block|,
block|{
literal|"noop"
block|,
name|CMDNOOP
block|}
block|,
block|{
literal|"quit"
block|,
name|CMDQUIT
block|}
block|,
block|{
literal|"helo"
block|,
name|CMDHELO
block|}
block|,
block|{
literal|"ehlo"
block|,
name|CMDEHLO
block|}
block|,
block|{
literal|"etrn"
block|,
name|CMDETRN
block|}
block|,
block|{
literal|"verb"
block|,
name|CMDVERB
block|}
block|,
block|{
literal|"onex"
block|,
name|CMDONEX
block|}
block|,
block|{
literal|"xusr"
block|,
name|CMDXUSR
block|}
block|,
comment|/* remaining commands are here only to trap and log attempts to use them */
block|{
literal|"showq"
block|,
name|CMDDBGQSHOW
block|}
block|,
block|{
literal|"debug"
block|,
name|CMDDBGDEBUG
block|}
block|,
block|{
literal|"wiz"
block|,
name|CMDLOGBOGUS
block|}
block|,
block|{
name|NULL
block|,
name|CMDERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|OneXact
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one xaction only this run */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CurSmtpClient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* who's at the other end of channel */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|skipword
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAXBADCOMMANDS
value|25
end_define

begin_comment
comment|/* maximum number of bad commands */
end_comment

begin_define
define|#
directive|define
name|MAXNOOPCOMMANDS
value|20
end_define

begin_comment
comment|/* max "noise" commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXHELOCOMMANDS
value|3
end_define

begin_comment
comment|/* max HELO/EHLO commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXVRFYCOMMANDS
value|6
end_define

begin_comment
comment|/* max VRFY/EXPN commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXETRNCOMMANDS
value|8
end_define

begin_comment
comment|/* max ETRN commands before slowdown */
end_comment

begin_function
name|void
name|smtp
parameter_list|(
name|nullserver
parameter_list|,
name|e
parameter_list|)
name|bool
name|nullserver
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
specifier|volatile
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
specifier|volatile
name|p
decl_stmt|;
specifier|register
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|auto
name|ADDRESS
modifier|*
name|vrfyqueue
decl_stmt|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|volatile
name|bool
name|gotmail
decl_stmt|;
comment|/* mail command received */
specifier|volatile
name|bool
name|gothello
decl_stmt|;
comment|/* helo command received */
name|bool
name|vrfy
decl_stmt|;
comment|/* set if this is a vrfy command */
name|char
modifier|*
specifier|volatile
name|protocol
decl_stmt|;
comment|/* sending protocol */
name|char
modifier|*
specifier|volatile
name|sendinghost
decl_stmt|;
comment|/* sending hostname */
name|char
modifier|*
specifier|volatile
name|peerhostname
decl_stmt|;
comment|/* name of SMTP peer or "localhost" */
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
specifier|volatile
name|int
name|nrcpts
init|=
literal|0
decl_stmt|;
comment|/* number of RCPT commands */
name|bool
name|doublequeue
decl_stmt|;
specifier|volatile
name|int
name|badcommands
init|=
literal|0
decl_stmt|;
comment|/* count of bad commands */
specifier|volatile
name|int
name|nverifies
init|=
literal|0
decl_stmt|;
comment|/* count of VRFY/EXPN commands */
specifier|volatile
name|int
name|n_etrn
init|=
literal|0
decl_stmt|;
comment|/* count of ETRN commands */
specifier|volatile
name|int
name|n_noop
init|=
literal|0
decl_stmt|;
comment|/* count of NOOP/VERB/ONEX etc cmds */
specifier|volatile
name|int
name|n_helo
init|=
literal|0
decl_stmt|;
comment|/* count of HELO/EHLO commands */
name|bool
name|ok
decl_stmt|;
specifier|volatile
name|int
name|lognullconnection
init|=
name|TRUE
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|inp
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|cmdbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
specifier|extern
name|void
name|help
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|settime
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|bool
name|enoughdiskspace
name|__P
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|runinchild
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|checksmtpattack
name|__P
argument_list|(
operator|(
specifier|volatile
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
operator|!=
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
comment|/* arrange for debugging output to go to remote host */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|settime
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|peerhostname
operator|=
name|RealHostName
expr_stmt|;
if|if
condition|(
name|peerhostname
operator|==
name|NULL
condition|)
name|peerhostname
operator|=
literal|"localhost"
expr_stmt|;
name|CurHostName
operator|=
name|peerhostname
expr_stmt|;
name|CurSmtpClient
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurSmtpClient
operator|==
name|NULL
condition|)
name|CurSmtpClient
operator|=
name|CurHostName
expr_stmt|;
name|setproctitle
argument_list|(
literal|"server %s startup"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|#
directive|if
name|DAEMON
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
block|{
comment|/* log connection information */
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"SMTP connect from %.100s (%.100s)"
argument_list|,
name|CurSmtpClient
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* output the first line, inserting "ESMTP" as second word */
name|expand
argument_list|(
name|SmtpGreeting
argument_list|,
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|inp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|id
operator|=
name|strchr
argument_list|(
name|inp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
name|id
operator|=
operator|&
name|inp
index|[
name|strlen
argument_list|(
name|inp
argument_list|)
index|]
expr_stmt|;
name|cmd
operator|=
name|p
operator|==
name|NULL
condition|?
literal|"220 %.*s ESMTP%s"
else|:
literal|"220-%.*s ESMTP%s"
expr_stmt|;
name|message
argument_list|(
name|cmd
argument_list|,
name|id
operator|-
name|inp
argument_list|,
name|inp
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* output remaining lines */
while|while
condition|(
operator|(
name|id
operator|=
name|p
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|id
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
name|id
operator|++
expr_stmt|;
name|message
argument_list|(
literal|"220-%s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
name|id
operator|++
expr_stmt|;
name|message
argument_list|(
literal|"220 %s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|protocol
operator|=
name|NULL
expr_stmt|;
name|sendinghost
operator|=
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|gothello
operator|=
name|FALSE
expr_stmt|;
name|gotmail
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* arrange for backout */
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|FALSE
expr_stmt|;
name|LogUsrErrs
operator|=
name|FALSE
expr_stmt|;
name|OnlyOneError
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_VRFYONLY
operator||
name|EF_GLOBALERRS
operator|)
expr_stmt|;
comment|/* setup for the read */
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* read the input line */
name|SmtpPhase
operator|=
literal|"server cmd read"
expr_stmt|;
name|setproctitle
argument_list|(
literal|"server %s cmd read"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|p
operator|=
name|sfgets
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|InChannel
argument_list|,
name|TimeOuts
operator|.
name|to_nextcommand
argument_list|,
name|SmtpPhase
argument_list|)
expr_stmt|;
comment|/* handle errors */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* end of file, just die */
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"421 %s Lost input channel from %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
operator|(
name|gotmail
condition|?
literal|1
else|:
literal|19
operator|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"lost input channel from %.100s"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|if
condition|(
name|lognullconnection
operator|&&
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NULL
argument_list|,
literal|"Null connection from %.100s"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
comment|/* 			** If have not accepted mail (DATA), do not bounce 			** bad addresses back to sender. 			*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|ExitStat
operator|=
name|EX_QUIT
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* clean up end of line */
name|fixcrlf
argument_list|(
name|inp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* echo command to transcript */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>=
literal|15
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"<-- %s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|setproctitle
argument_list|(
literal|"%s: %.80s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
else|else
name|setproctitle
argument_list|(
literal|"%s %s: %.80s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* break off command */
for|for
control|(
name|p
operator|=
name|inp
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|cmd
operator|=
name|cmdbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
name|cmd
operator|<
operator|&
name|cmdbuf
index|[
sizeof|sizeof
name|cmdbuf
operator|-
literal|2
index|]
condition|)
operator|*
name|cmd
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|cmd
operator|=
literal|'\0'
expr_stmt|;
comment|/* throw away leading whitespace */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* decode command */
for|for
control|(
name|c
operator|=
name|CmdTab
init|;
name|c
operator|->
name|cmdname
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|c
operator|->
name|cmdname
argument_list|,
name|cmdbuf
argument_list|)
condition|)
break|break;
block|}
comment|/* reset errors */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 		**  Process command. 		** 		**	If we are running as a null server, return 550 		**	to everything. 		*/
if|if
condition|(
name|nullserver
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|cmdcode
condition|)
block|{
case|case
name|CMDQUIT
case|:
case|case
name|CMDHELO
case|:
case|case
name|CMDEHLO
case|:
case|case
name|CMDNOOP
case|:
comment|/* process normally */
break|break;
default|default:
if|if
condition|(
operator|++
name|badcommands
operator|>
name|MAXBADCOMMANDS
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Access denied"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* non-null server */
switch|switch
condition|(
name|c
operator|->
name|cmdcode
condition|)
block|{
case|case
name|CMDMAIL
case|:
case|case
name|CMDEXPN
case|:
case|case
name|CMDVRFY
case|:
case|case
name|CMDETRN
case|:
name|lognullconnection
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|cmdcode
condition|)
block|{
case|case
name|CMDHELO
case|:
comment|/* hello -- introduce yourself */
case|case
name|CMDEHLO
case|:
comment|/* extended hello */
if|if
condition|(
name|c
operator|->
name|cmdcode
operator|==
name|CMDEHLO
condition|)
block|{
name|protocol
operator|=
literal|"ESMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server EHLO"
expr_stmt|;
block|}
else|else
block|{
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server HELO"
expr_stmt|;
block|}
comment|/* avoid denial-of-service */
name|checksmtpattack
argument_list|(
operator|&
name|n_helo
argument_list|,
name|MAXHELOCOMMANDS
argument_list|,
literal|"HELO/EHLO"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
if|if
condition|(
name|gothello
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 %s Duplicate HELO/EHLO"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for valid domain name (re 1123 5.2.5) */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|!
name|AllowBogusHELO
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 %s requires domain address"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"[].-_#"
argument_list|,
operator|*
name|q
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|q
operator|=
literal|"pleased to meet you"
expr_stmt|;
name|sendinghost
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|AllowBogusHELO
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Invalid domain name"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|q
operator|=
literal|"accepting invalid domain name"
expr_stmt|;
block|}
name|gothello
operator|=
name|TRUE
expr_stmt|;
comment|/* print HELO response message */
if|if
condition|(
name|c
operator|->
name|cmdcode
operator|!=
name|CMDEHLO
condition|)
block|{
name|message
argument_list|(
literal|"250 %s Hello %s, %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
name|message
argument_list|(
literal|"250-%s Hello %s, %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* print EHLO features list */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"250-EXPN"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250-VERB"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MIME8TO7
name|message
argument_list|(
literal|"250-8BITMIME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
condition|)
name|message
argument_list|(
literal|"250-SIZE %ld"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250-SIZE"
argument_list|)
expr_stmt|;
if|#
directive|if
name|DSN
if|if
condition|(
name|SendMIMEErrors
condition|)
name|message
argument_list|(
literal|"250-DSN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|message
argument_list|(
literal|"250-ONEX"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250-ETRN"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250-XUSR"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 HELP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDMAIL
case|:
comment|/* mail -- designate sender */
name|SmtpPhase
operator|=
literal|"server MAIL"
expr_stmt|;
comment|/* check for validity of this command */
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|PRIV_NEEDMAILHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 Polite people say HELO first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 Sender already specified"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|InChild
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"503 Nested MAIL command: MAIL %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* make sure we know who the sending host is */
if|if
condition|(
name|sendinghost
operator|==
name|NULL
condition|)
name|sendinghost
operator|=
name|peerhostname
expr_stmt|;
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
comment|/* fork a subprocess to process this command */
if|if
condition|(
name|runinchild
argument_list|(
literal|"SMTP-MAIL"
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
if|if
condition|(
operator|!
name|gothello
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"%s didn't use HELO protocol"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PICKY_HELO_CHECK
if|if
condition|(
name|strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|peerhostname
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|peerhostname
argument_list|,
literal|"localhost"
argument_list|)
operator|!=
literal|0
operator|||
name|strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|MyHostName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"Host %s claimed to be %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|sendinghost
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|define
argument_list|(
literal|'r'
argument_list|,
name|protocol
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'s'
argument_list|,
name|sendinghost
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
name|nrcpts
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_LOGSENDER
operator||
name|EF_CLRQUEUE
expr_stmt|;
name|setproctitle
argument_list|(
literal|"%s %s: %.80s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* child -- go do the processing */
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* this failed -- undo work */
name|undo_subproc_no_pm
label|:
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PM_NOTIFY
expr_stmt|;
name|undo_subproc
label|:
if|if
condition|(
name|InChild
condition|)
block|{
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
comment|/* must parse sender first */
name|delimptr
operator|=
name|NULL
expr_stmt|;
name|setsender
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
operator|&
name|delimptr
argument_list|,
literal|' '
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
operator|*
name|delimptr
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
comment|/* do config file checking of the sender */
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_mail"
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
comment|/* check for possible spoofing */
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|OpMode
operator|==
name|MD_SMTP
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|RealUserName
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"%s owned process doing -bs"
argument_list|,
name|RealUserName
argument_list|)
expr_stmt|;
block|}
comment|/* now parse ESMTP arguments */
name|e
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
specifier|extern
name|void
name|mail_esmtp_args
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* locate the beginning of the keyword */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"MAIL: got arg %s=\"%s\"\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
name|mail_esmtp_args
argument_list|(
name|kp
argument_list|,
name|vp
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_msgsize
operator|>
name|MaxMessageSize
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 Message size exceeds fixed maximum message size (%ld)"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
goto|goto
name|undo_subproc_no_pm
goto|;
block|}
if|if
condition|(
operator|!
name|enoughdiskspace
argument_list|(
name|e
operator|->
name|e_msgsize
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"452 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
goto|goto
name|undo_subproc_no_pm
goto|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
name|message
argument_list|(
literal|"250 Sender ok"
argument_list|)
expr_stmt|;
name|gotmail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CMDRCPT
case|:
comment|/* rcpt -- designate recipient */
if|if
condition|(
operator|!
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 Need MAIL before RCPT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|SmtpPhase
operator|=
literal|"server RCPT"
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
break|break;
block|}
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
name|LogUsrErrs
operator|=
name|TRUE
expr_stmt|;
comment|/* limit flooding of our machine */
if|if
condition|(
name|MaxRcptPerMsg
operator|>
literal|0
operator|&&
name|nrcpts
operator|>=
name|MaxRcptPerMsg
condition|)
block|{
name|usrerr
argument_list|(
literal|"452 Too many recipients"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DELIVER
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
literal|' '
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|Errors
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
operator|*
name|delimptr
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* do config file checking of the recipient */
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_rcpt"
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* now parse ESMTP arguments */
name|p
operator|=
name|delimptr
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
specifier|extern
name|void
name|rcpt_esmtp_args
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* locate the beginning of the keyword */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"RCPT: got arg %s=\"%s\"\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
name|rcpt_esmtp_args
argument_list|(
name|a
argument_list|,
name|kp
argument_list|,
name|vp
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* save in recipient list after ESMTP mods */
name|a
operator|=
name|recipient
argument_list|(
name|a
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* no errors during parsing, but might be a duplicate */
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"250 Recipient ok%s"
argument_list|,
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|?
literal|" (will queue)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|nrcpts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* punt -- should keep message in ADDRESS.... */
name|usrerr
argument_list|(
literal|"550 Addressee unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMDDATA
case|:
comment|/* data -- text of mail */
name|SmtpPhase
operator|=
literal|"server DATA"
expr_stmt|;
if|if
condition|(
operator|!
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 Need MAIL command"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|nrcpts
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 Need RCPT (recipient)"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check to see if we need to re-expand aliases */
comment|/* also reset QBADADDR on already-diagnosted addrs */
name|doublequeue
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* need to re-expand aliases */
name|doublequeue
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* make this "go away" */
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
name|a
operator|->
name|q_flags
operator|&=
operator|~
name|QBADADDR
expr_stmt|;
block|}
block|}
comment|/* collect the text of the message */
name|SmtpPhase
operator|=
literal|"collect"
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
name|collect
argument_list|(
name|InChannel
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
block|{
name|flush_errors
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
goto|goto
name|abortmessage
goto|;
block|}
comment|/* make sure we actually do delivery */
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_CLRQUEUE
expr_stmt|;
comment|/* from now on, we have to operate silently */
name|buffer_errors
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
comment|/* 			**  Arrange to send to everyone. 			**	If sending to multiple people, mail back 			**		errors rather than reporting directly. 			**	In any case, don't mail back errors for 			**		anything that has happened up to 			**		now (the other end will do this). 			**	Truncate our transcript -- the mail has gotten 			**		to us successfully, and if we have 			**		to mail this back, it will be easier 			**		on the reader. 			**	Then send to everyone. 			**	Finally give a reply code.  If an error has 			**		already been given, don't mail a 			**		message back. 			**	We goose error returns by clearing error bit. 			*/
name|SmtpPhase
operator|=
literal|"delivery"
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|freopen
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'x'
argument_list|)
argument_list|,
literal|"w"
argument_list|,
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
name|id
operator|=
name|e
operator|->
name|e_id
expr_stmt|;
if|if
condition|(
name|doublequeue
condition|)
block|{
comment|/* make sure it is in the queue */
name|queueup
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send to all recipients */
name|sendall
argument_list|(
name|e
argument_list|,
name|SM_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
comment|/* issue success message */
name|message
argument_list|(
literal|"250 %s Message accepted for delivery"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* if we just queued, poke it */
if|if
condition|(
name|doublequeue
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_QUEUE
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DEFER
condition|)
block|{
name|CurrentLA
operator|=
name|getla
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|shouldqueue
argument_list|(
name|e
operator|->
name|e_msgpriority
argument_list|,
name|e
operator|->
name|e_ctime
argument_list|)
condition|)
block|{
specifier|extern
name|pid_t
name|dowork
parameter_list|()
function_decl|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dowork
argument_list|(
name|id
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|abortmessage
label|:
comment|/* if in a child, pop back to our parent */
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|()
expr_stmt|;
comment|/* clean up a bit */
name|gotmail
operator|=
name|FALSE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|e
operator|=
name|newenvelope
argument_list|(
name|e
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
break|break;
case|case
name|CMDRSET
case|:
comment|/* rset -- reset state */
if|if
condition|(
name|tTd
argument_list|(
literal|94
argument_list|,
literal|100
argument_list|)
condition|)
name|message
argument_list|(
literal|"451 Test failure"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250 Reset state"
argument_list|)
expr_stmt|;
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|()
expr_stmt|;
comment|/* clean up a bit */
name|gotmail
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|e
operator|=
name|newenvelope
argument_list|(
name|e
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDVRFY
case|:
comment|/* vrfy -- verify address */
case|case
name|CMDEXPN
case|:
comment|/* expn -- expand address */
name|checksmtpattack
argument_list|(
operator|&
name|nverifies
argument_list|,
name|MAXVRFYCOMMANDS
argument_list|,
name|c
operator|->
name|cmdcode
operator|==
name|CMDVRFY
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|vrfy
operator|=
name|c
operator|->
name|cmdcode
operator|==
name|CMDVRFY
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NOVRFY
else|:
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
if|if
condition|(
name|vrfy
condition|)
name|message
argument_list|(
literal|"252 Cannot VRFY user; try RCPT to attempt delivery (or try finger)"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"502 Sorry, we do not allow this operation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: %s [rejected]"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NEEDVRFYHELO
else|:
name|PRIV_NEEDEXPNHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 I demand that you introduce yourself first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|runinchild
argument_list|(
name|vrfy
condition|?
literal|"SMTP-VRFY"
else|:
literal|"SMTP-EXPN"
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
name|vrfyqueue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vrfy
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Argument required"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|vrfyqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
if|if
condition|(
name|vrfyqueue
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"554 Nothing to %s"
argument_list|,
name|vrfy
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|vrfyqueue
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|void
name|printvrfyaddr
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|vrfyqueue
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|a
operator|->
name|q_next
operator|)
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|vrfyqueue
operator|->
name|q_flags
argument_list|)
condition|)
name|printvrfyaddr
argument_list|(
name|vrfyqueue
argument_list|,
name|a
operator|==
name|NULL
argument_list|,
name|vrfy
argument_list|)
expr_stmt|;
name|vrfyqueue
operator|=
name|vrfyqueue
operator|->
name|q_next
expr_stmt|;
block|}
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMDETRN
case|:
comment|/* etrn -- force queue flush */
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"500 Parameter required"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* crude way to avoid denial-of-service attacks */
name|checksmtpattack
argument_list|(
operator|&
name|n_etrn
argument_list|,
name|MAXETRNCOMMANDS
argument_list|,
literal|"ETRN"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: ETRN %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|p
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|id
operator|==
literal|'@'
condition|)
name|id
operator|++
expr_stmt|;
else|else
operator|*
operator|--
name|id
operator|=
literal|'@'
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|id
expr_stmt|;
name|ok
operator|=
name|runqueue
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ok
operator|&&
name|Errors
operator|==
literal|0
condition|)
name|message
argument_list|(
literal|"250 Queuing for node %s started"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDHELP
case|:
comment|/* help -- give user info */
name|help
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDNOOP
case|:
comment|/* noop -- do nothing */
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
literal|"NOOP"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 OK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDQUIT
case|:
comment|/* quit -- leave mail */
name|message
argument_list|(
literal|"221 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|doquit
label|:
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
comment|/* avoid future 050 messages */
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|ExitStat
operator|=
name|EX_QUIT
expr_stmt|;
if|if
condition|(
name|lognullconnection
operator|&&
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NULL
argument_list|,
literal|"Null connection from %.100s"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
case|case
name|CMDVERB
case|:
comment|/* set verbose mode */
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
comment|/* this would give out the same info */
name|message
argument_list|(
literal|"502 Verbose unavailable"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
literal|"VERB"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Verbose
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|e_sendmode
operator|=
name|SM_DELIVER
expr_stmt|;
name|message
argument_list|(
literal|"250 Verbose mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDONEX
case|:
comment|/* doing one transaction only */
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
literal|"ONEX"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|OneXact
operator|=
name|TRUE
expr_stmt|;
name|message
argument_list|(
literal|"250 Only one transaction"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDXUSR
case|:
comment|/* initial (user) submission */
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
literal|"XUSR"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|UserSubmission
operator|=
name|TRUE
expr_stmt|;
name|message
argument_list|(
literal|"250 Initial submission"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|SMTPDEBUG
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
name|printf
argument_list|(
literal|"Send Queue="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"200 Debug set"
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* not SMTPDEBUG */
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
endif|#
directive|endif
comment|/* SMTPDEBUG */
case|case
name|CMDLOGBOGUS
case|:
comment|/* bogus command */
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"\"%s\" command from %.100s (%.100s)"
argument_list|,
name|c
operator|->
name|cmdname
argument_list|,
name|CurSmtpClient
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|CMDERROR
case|:
comment|/* unknown command */
if|if
condition|(
operator|++
name|badcommands
operator|>
name|MAXBADCOMMANDS
condition|)
block|{
name|message
argument_list|(
literal|"421 %s Too many bad commands; closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
name|usrerr
argument_list|(
literal|"500 Command unrecognized: \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"500 smtp: unknown code %d"
argument_list|,
name|c
operator|->
name|cmdcode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CHECKSMTPATTACK -- check for denial-of-service attack by repetition ** **	Parameters: **		pcounter -- pointer to a counter for this command. **		maxcount -- maximum value for this counter before we **			slow down. **		cname -- command name for logging. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		Slows down if we seem to be under attack. */
end_comment

begin_function
name|void
name|checksmtpattack
parameter_list|(
name|pcounter
parameter_list|,
name|maxcount
parameter_list|,
name|cname
parameter_list|,
name|e
parameter_list|)
specifier|volatile
name|int
modifier|*
name|pcounter
decl_stmt|;
name|int
name|maxcount
decl_stmt|;
name|char
modifier|*
name|cname
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
operator|++
operator|(
operator|*
name|pcounter
operator|)
operator|>=
name|maxcount
condition|)
block|{
if|if
condition|(
operator|*
name|pcounter
operator|==
name|maxcount
operator|&&
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: %.40s attack?"
argument_list|,
name|CurSmtpClient
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
operator|*
name|pcounter
operator|/
name|maxcount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SKIPWORD -- skip a fixed word. ** **	Parameters: **		p -- place to start looking. **		w -- word to skip. ** **	Returns: **		p following w. **		NULL on error. ** **	Side Effects: **		clobbers the p data area. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipword
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|firstp
init|=
name|p
decl_stmt|;
comment|/* find beginning of word */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* find end of word */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|syntax
label|:
name|usrerr
argument_list|(
literal|"501 Syntax error in parameters scanning \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|firstp
argument_list|,
literal|203
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|syntax
goto|;
comment|/* see if the input word matches desired word */
if|if
condition|(
name|strcasecmp
argument_list|(
name|q
argument_list|,
name|w
argument_list|)
condition|)
goto|goto
name|syntax
goto|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line ** **	Parameters: **		kp -- the parameter key. **		vp -- the value of that parameter. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|mail_esmtp_args
parameter_list|(
name|kp
parameter_list|,
name|vp
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 SIZE requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BROKEN_ANSI_LIBRARY
argument_list|)
name|e
operator|->
name|e_msgsize
operator|=
name|strtoul
argument_list|(
name|vp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
name|e
operator|->
name|e_msgsize
operator|=
name|strtol
argument_list|(
name|vp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"body"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 BODY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"8bitmime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SevenBitInput
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"7bit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SevenBitInput
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 Unknown BODY type %s"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_bodytype
operator|=
name|newstr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"envid"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 ENVID requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Syntax error in ENVID parameter value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Duplicate ENVID parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_envid
operator|=
name|newstr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"ret"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 RET requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Duplicate RET parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"hdrs"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"full"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Bad argument \"%s\" to RET"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RCPT_ESMTP_ARGS -- process ESMTP arguments from RCPT line ** **	Parameters: **		a -- the address corresponding to the To: parameter. **		kp -- the parameter key. **		vp -- the value of that parameter. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|rcpt_esmtp_args
parameter_list|(
name|a
parameter_list|,
name|kp
parameter_list|,
name|vp
parameter_list|,
name|e
parameter_list|)
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"notify"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 NOTIFY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|a
operator|->
name|q_flags
operator|&=
operator|~
operator|(
name|QPINGONSUCCESS
operator||
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
operator|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QHASNOTIFY
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|vp
init|;
name|p
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|p
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONSUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONFAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"delay"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONDELAY
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"501 Bad argument \"%s\"  to NOTIFY"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"orcpt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 ORCPT requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|strchr
argument_list|(
name|vp
argument_list|,
literal|';'
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|xtextok
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Syntax error in ORCPT parameter value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|a
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Duplicate ORCPT parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|a
operator|->
name|q_orcpt
operator|=
name|newstr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTVRFYADDR -- print an entry in the verify queue ** **	Parameters: **		a -- the address to print **		last -- set if this is the last one. **		vrfy -- set if this is a VRFY command. ** **	Returns: **		none. ** **	Side Effects: **		Prints the appropriate 250 codes. */
end_comment

begin_function
name|void
name|printvrfyaddr
parameter_list|(
name|a
parameter_list|,
name|last
parameter_list|,
name|vrfy
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|bool
name|vrfy
decl_stmt|;
block|{
name|char
name|fmtbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|vrfy
operator|&&
name|a
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_VRFY250
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|strcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"252"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"250"
argument_list|)
expr_stmt|;
name|fmtbuf
index|[
literal|3
index|]
operator|=
name|last
condition|?
literal|' '
else|:
literal|'-'
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_fullname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"<%s@%s>"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"<%s>"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"%s<%s@%s>"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"%s<%s>"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_fullname
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RUNINCHILD -- return twice -- once in the child, then in the parent again ** **	Parameters: **		label -- a string used in error messages ** **	Returns: **		zero in the child **		one in the parent ** **	Side Effects: **		none. */
end_comment

begin_function
name|int
name|runinchild
parameter_list|(
name|label
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|pid_t
name|childpid
decl_stmt|;
if|if
condition|(
operator|!
name|OneXact
condition|)
block|{
comment|/* 		**  Disable child process reaping, in case ETRN has preceeded 		**  MAIL command, and then fork. 		*/
operator|(
name|void
operator|)
name|blocksignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
name|childpid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"451 %s: cannot fork"
argument_list|,
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|childpid
operator|>
literal|0
condition|)
block|{
specifier|auto
name|int
name|st
decl_stmt|;
comment|/* parent -- wait for child to complete */
name|setproctitle
argument_list|(
literal|"server %s child wait"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|st
operator|=
name|waitfor
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"451 %s: lost child"
argument_list|,
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"451 %s: died on signal %d"
argument_list|,
name|label
argument_list|,
name|st
operator|&
literal|0177
argument_list|)
expr_stmt|;
comment|/* if we exited on a QUIT command, complete the process */
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|st
argument_list|)
operator|==
name|EX_QUIT
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* restore the child signal */
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* child */
name|InChild
operator|=
name|TRUE
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* open alias database */
name|initmaps
argument_list|(
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  HELP -- implement the HELP command. ** **	Parameters: **		topic -- the topic we want help for. ** **	Returns: **		none. ** **	Side Effects: **		outputs the help file to message output. */
end_comment

begin_function
name|void
name|help
parameter_list|(
name|topic
parameter_list|)
name|char
modifier|*
name|topic
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|hf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bool
name|noinfo
decl_stmt|;
name|int
name|sff
init|=
name|SFF_OPENASROOT
operator||
name|SFF_REGONLY
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|if
condition|(
name|HelpFile
operator|==
name|NULL
operator|||
operator|(
name|hf
operator|=
name|safefopen
argument_list|(
name|HelpFile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0444
argument_list|,
name|sff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no help */
name|errno
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"502 Sendmail %s -- HELP not implemented"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|topic
operator|==
name|NULL
operator|||
operator|*
name|topic
operator|==
literal|'\0'
condition|)
block|{
name|topic
operator|=
literal|"smtp"
expr_stmt|;
name|message
argument_list|(
literal|"214-This is Sendmail version %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|makelower
argument_list|(
name|topic
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|TRUE
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|topic
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|hf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|topic
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|fixcrlf
argument_list|(
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"214-%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noinfo
condition|)
name|message
argument_list|(
literal|"504 HELP topic \"%.10s\" unknown"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"214 End of HELP info"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

