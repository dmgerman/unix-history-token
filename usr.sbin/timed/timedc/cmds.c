begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)cmds.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"timedc.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|TSPTYPES
end_define

begin_include
include|#
directive|include
file|<protocols/timed.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_include
include|#
directive|include
file|<bstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SECHR
value|(60*60)
end_define

begin_define
define|#
directive|define
name|SECDAY
value|(24*SECHR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_define
define|#
directive|define
name|DATE_PROTO
value|"udp"
end_define

begin_define
define|#
directive|define
name|DATE_PORT
value|"time"
end_define

begin_decl_stmt
name|int
name|sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sock_raw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|dayaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|measure_delta
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|bytenetorder
parameter_list|(
name|struct
name|tsp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bytehostorder
parameter_list|(
name|struct
name|tsp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BU
value|(2208988800UL)
end_define

begin_comment
comment|/* seconds before UNIX epoch */
end_comment

begin_comment
comment|/* compute the difference between our date and another machine  */
end_comment

begin_function
specifier|static
name|int
comment|/* difference in days from our time */
name|daydiff
parameter_list|(
name|hostname
parameter_list|)
name|char
modifier|*
name|hostname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|trials
decl_stmt|;
name|struct
name|timeval
name|tout
decl_stmt|,
name|now
decl_stmt|;
name|fd_set
name|ready
decl_stmt|;
name|struct
name|sockaddr
name|from
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
name|unsigned
name|long
name|sec
decl_stmt|;
comment|/* wait 2 seconds between 10 tries */
name|tout
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|tout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|trials
operator|=
literal|0
init|;
name|trials
operator|<
literal|10
condition|;
name|trials
operator|++
control|)
block|{
comment|/* ask for the time */
name|sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|&
name|sec
argument_list|,
sizeof|sizeof
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dayaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|dayaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sendto(sock)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|ready
argument_list|)
expr_stmt|;
name|i
operator|=
name|select
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
operator|&
name|ready
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|warn
argument_list|(
literal|"select(date read)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
literal|0
operator|==
name|i
condition|)
break|break;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvfrom
argument_list|(
name|sock
argument_list|,
operator|&
name|sec
argument_list|,
sizeof|sizeof
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"recvfrom(date read)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sec
operator|=
name|ntohl
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|<
name|BU
condition|)
block|{
name|warnx
argument_list|(
literal|"%s says it is before 1970: %lu"
argument_list|,
name|hostname
argument_list|,
name|sec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sec
operator|-=
name|BU
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|sec
operator|-
name|now
operator|.
name|tv_sec
operator|)
return|;
block|}
block|}
comment|/* if we get here, we tried too many times */
name|warnx
argument_list|(
literal|"%s will not tell us the date"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Clockdiff computes the difference between the time of the machine on  * which it is called and the time of the machines given as argument.  * The time differences measured by clockdiff are obtained using a sequence  * of ICMP TSTAMP messages which are returned to the sender by the IP module  * in the remote machine.  * In order to compare clocks of machines in different time zones, the time  * is transmitted (as a 32-bit value) in milliseconds since midnight UT.  * If a hosts uses a different time format, it should set the high order  * bit of the 32-bit quantity it transmits.  * However, VMS apparently transmits the time in milliseconds since midnight  * local time (rather than GMT) without setting the high order bit.  * Furthermore, it does not understand daylight-saving time.  This makes  * clockdiff behaving inconsistently with hosts running VMS.  *  * In order to reduce the sensitivity to the variance of message transmission  * time, clockdiff sends a sequence of messages.  Yet, measures between  * two `distant' hosts can be affected by a small error. The error can,  * however, be reduced by increasing the number of messages sent in each  * measurement.  */
end_comment

begin_function
name|void
name|clockdiff
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|measure_status
decl_stmt|;
specifier|extern
name|int
name|measure
argument_list|(
name|u_long
argument_list|,
name|u_long
argument_list|,
name|char
operator|*
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
name|avg_cnt
decl_stmt|;
specifier|register
name|long
name|avg
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"usage: timedc clockdiff host ...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gethostname
argument_list|(
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gethostname"
argument_list|)
expr_stmt|;
comment|/* get the address for the date ready */
name|sp
operator|=
name|getservbyname
argument_list|(
name|DATE_PORT
argument_list|,
name|DATE_PROTO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
block|{
name|warnx
argument_list|(
literal|"%s/%s is an unknown service"
argument_list|,
name|DATE_PORT
argument_list|,
name|DATE_PROTO
argument_list|)
expr_stmt|;
name|dayaddr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dayaddr
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
operator|*
name|argv
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|server
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
for|for
control|(
name|avg_cnt
operator|=
literal|0
operator|,
name|avg
operator|=
literal|0
init|;
name|avg_cnt
operator|<
literal|16
condition|;
name|avg_cnt
operator|++
control|)
block|{
name|measure_status
operator|=
name|measure
argument_list|(
literal|10000
argument_list|,
literal|100
argument_list|,
operator|*
name|argv
argument_list|,
operator|&
name|server
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|measure_status
operator|!=
name|GOOD
condition|)
break|break;
name|avg
operator|+=
name|measure_delta
expr_stmt|;
block|}
if|if
condition|(
name|measure_status
operator|==
name|GOOD
condition|)
name|measure_delta
operator|=
name|avg
operator|/
name|avg_cnt
expr_stmt|;
switch|switch
condition|(
name|measure_status
condition|)
block|{
case|case
name|HOSTDOWN
case|:
name|printf
argument_list|(
literal|"%s is down\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NONSTDTIME
case|:
name|printf
argument_list|(
literal|"%s transmitts a non-standard time format\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|UNREACHABLE
case|:
name|printf
argument_list|(
literal|"%s is unreachable\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try to get the date only after using ICMP timestamps to 		 * get the time.  This is because the date protocol 		 * is optional. 		 */
if|if
condition|(
name|dayaddr
operator|.
name|sin_port
operator|!=
literal|0
condition|)
block|{
name|dayaddr
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|dayaddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|avg
operator|=
name|daydiff
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|avg
operator|>
name|SECDAY
condition|)
block|{
name|printf
argument_list|(
literal|"time on %s is %ld days ahead %s\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|avg
operator|/
name|SECDAY
argument_list|,
name|myname
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|avg
operator|<
operator|-
name|SECDAY
condition|)
block|{
name|printf
argument_list|(
literal|"time on %s is %ld days behind %s\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
operator|-
name|avg
operator|/
name|SECDAY
argument_list|,
name|myname
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|measure_delta
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"time on %s is %d ms. ahead of time on %s\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|measure_delta
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|measure_delta
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s and %s have the same time\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"time on %s is %d ms. behind time on %s\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
operator|-
name|measure_delta
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * finds location of master timedaemon  */
end_comment

begin_function
name|void
name|msite
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
name|fd_set
name|ready
decl_stmt|;
name|struct
name|sockaddr_in
name|dest
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|struct
name|timeval
name|tout
decl_stmt|;
name|struct
name|tsp
name|msg
decl_stmt|;
name|struct
name|servent
modifier|*
name|srvp
decl_stmt|;
name|char
modifier|*
name|tgtname
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"usage: timedc msite [host ...]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|srvp
operator|=
name|getservbyname
argument_list|(
literal|"timed"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srvp
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"udp/timed: unknown service"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dest
operator|.
name|sin_port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|dest
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gethostname"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|tgtname
operator|=
operator|(
name|i
operator|>=
name|argc
operator|)
condition|?
name|myname
else|:
name|argv
index|[
name|i
index|]
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|tgtname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
name|tgtname
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|dest
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|msg
operator|.
name|tsp_name
argument_list|,
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|tsp_name
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|tsp_type
operator|=
name|TSP_MSITE
expr_stmt|;
name|msg
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tout
operator|.
name|tv_sec
operator|=
literal|15
expr_stmt|;
name|tout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|ready
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tout
argument_list|)
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|cc
operator|=
name|recvfrom
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * The 4.3BSD protocol spec had a 32-byte tsp_name field, and 			 * this is still OS-dependent.  Demand that the packet is at 			 * least long enough to hold a 4.3BSD packet. 			 */
if|if
condition|(
name|cc
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
operator|-
name|MAXHOSTNAMELEN
operator|+
literal|32
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"short packet (%u/%u bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
operator|-
name|MAXHOSTNAMELEN
operator|+
literal|32
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bytehostorder
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|tsp_type
operator|==
name|TSP_ACK
condition|)
block|{
name|printf
argument_list|(
literal|"master timedaemon at %s is %s\n"
argument_list|,
name|tgtname
argument_list|,
name|msg
operator|.
name|tsp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msg
operator|.
name|tsp_type
operator|>=
name|TSPTYPENUMBER
condition|)
name|printf
argument_list|(
literal|"unknown ack received: %u\n"
argument_list|,
name|msg
operator|.
name|tsp_type
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"wrong ack received: %s\n"
argument_list|,
name|tsptype
index|[
name|msg
operator|.
name|tsp_type
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"communication error with %s\n"
argument_list|,
name|tgtname
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * quits timedc  */
end_comment

begin_function
name|void
name|quit
parameter_list|()
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Causes the election timer to expire on the selected hosts  * It sends just one udp message per machine, relying on  * reliability of communication channel.  */
end_comment

begin_function
name|void
name|testing
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|servent
modifier|*
name|srvp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|tsp
name|msg
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"usage: timedc election host1 [host2 ...]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|srvp
operator|=
name|getservbyname
argument_list|(
literal|"timed"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srvp
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"udp/timed: unknown service"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
operator|*
name|argv
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
name|sin
operator|.
name|sin_port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|msg
operator|.
name|tsp_type
operator|=
name|TSP_TEST
expr_stmt|;
name|msg
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gethostname"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|msg
operator|.
name|tsp_name
argument_list|,
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|tsp_name
argument_list|)
argument_list|)
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Enables or disables tracing on local timedaemon  */
end_comment

begin_function
name|void
name|tracing
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|onflag
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|fd_set
name|ready
decl_stmt|;
name|struct
name|sockaddr_in
name|dest
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|struct
name|timeval
name|tout
decl_stmt|;
name|struct
name|tsp
name|msg
decl_stmt|;
name|struct
name|servent
modifier|*
name|srvp
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"usage: timedc trace { on | off }\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|srvp
operator|=
name|getservbyname
argument_list|(
literal|"timed"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srvp
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"udp/timed: unknown service"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dest
operator|.
name|sin_port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|dest
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gethostname"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|dest
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msg
operator|.
name|tsp_type
operator|=
name|TSP_TRACEON
expr_stmt|;
name|onflag
operator|=
name|ON
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|.
name|tsp_type
operator|=
name|TSP_TRACEOFF
expr_stmt|;
name|onflag
operator|=
name|OFF
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
operator|.
name|tsp_name
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|msg
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tout
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|tout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|ready
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tout
argument_list|)
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|cc
operator|=
name|recvfrom
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * The 4.3BSD protocol spec had a 32-byte tsp_name field, and 		 * this is still OS-dependent.  Demand that the packet is at 		 * least long enough to hold a 4.3BSD packet. 		 */
if|if
condition|(
name|cc
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
operator|-
name|MAXHOSTNAMELEN
operator|+
literal|32
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"short packet (%u/%u bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
operator|-
name|MAXHOSTNAMELEN
operator|+
literal|32
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytehostorder
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|tsp_type
operator|==
name|TSP_ACK
condition|)
if|if
condition|(
name|onflag
condition|)
name|printf
argument_list|(
literal|"timed tracing enabled\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"timed tracing disabled\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|msg
operator|.
name|tsp_type
operator|>=
name|TSPTYPENUMBER
condition|)
name|printf
argument_list|(
literal|"unknown ack received: %u\n"
argument_list|,
name|msg
operator|.
name|tsp_type
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"wrong ack received: %s\n"
argument_list|,
name|tsptype
index|[
name|msg
operator|.
name|tsp_type
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"communication error\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|priv_resources
parameter_list|()
block|{
name|int
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"opening socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|port
operator|=
name|IPPORT_RESERVED
operator|-
literal|1
init|;
name|port
operator|>
name|IPPORT_RESERVED
operator|/
literal|2
condition|;
name|port
operator|--
control|)
block|{
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
operator|&&
name|errno
operator|!=
name|EADDRNOTAVAIL
condition|)
block|{
name|warn
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|port
operator|==
name|IPPORT_RESERVED
operator|/
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"all reserved ports in use"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sock_raw
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_raw
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"opening raw socket"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

