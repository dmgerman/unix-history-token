begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)master.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_include
include|#
directive|include
file|<sys/schedctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|measure_delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Mflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|justquit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dictate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slvcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* slaves listening to our clock */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mchgdate
name|__P
argument_list|(
operator|(
expr|struct
name|tsp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|logwtmp
name|__P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|void
name|logwtmp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_comment
comment|/*  * The main function of `master' is to periodically compute the differences  * (deltas) between its clock and the clocks of the slaves, to compute the  * network average delta, and to send to the slaves the differences between  * their individual deltas and the network delta.  * While waiting, it receives messages from the slaves (i.e. requests for  * master's name, remote requests to set the network time, ...), and  * takes the appropriate action.  */
end_comment

begin_function
name|int
name|master
parameter_list|()
block|{
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|long
name|pollingtime
decl_stmt|;
define|#
directive|define
name|POLLRATE
value|4
name|int
name|polls
decl_stmt|;
name|struct
name|timeval
name|wait
decl_stmt|,
name|ntime
decl_stmt|;
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|,
modifier|*
name|answer
decl_stmt|,
name|to
decl_stmt|;
name|char
name|newdate
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|taddr
decl_stmt|;
name|char
name|tname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"This machine is master"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"This machine is master\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|justquit
condition|)
name|polls
operator|=
literal|0
expr_stmt|;
else|else
name|polls
operator|=
name|POLLRATE
operator|-
literal|1
expr_stmt|;
comment|/* Process all outstanding messages before spending the long time necessary  *	to update all timers.  */
name|loop
label|:
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
name|pollingtime
operator|-
name|ntime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|readmsg
argument_list|(
name|TSP_ANY
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntime
operator|.
name|tv_sec
operator|>=
name|pollingtime
condition|)
block|{
name|pollingtime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
expr_stmt|;
name|get_goodgroup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If a bogus master told us to quit, we can have decided to ignore a  * network.  Therefore, periodically try to take over everything.  */
name|polls
operator|=
operator|(
name|polls
operator|+
literal|1
operator|)
operator|%
name|POLLRATE
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|polls
operator|&&
name|nignorednets
operator|>
literal|0
condition|)
block|{
name|trace_msg
argument_list|(
literal|"Looking for nets to re-master\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|IGNORE
operator|||
name|ntp
operator|->
name|status
operator|==
name|NOMASTER
condition|)
block|{
name|lookformaster
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|polls
operator|=
name|POLLRATE
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
operator|&&
operator|--
name|ntp
operator|->
name|quit_count
operator|<
literal|0
condition|)
name|ntp
operator|->
name|quit_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|polls
operator|!=
literal|0
condition|)
name|setstatus
argument_list|()
expr_stmt|;
block|}
name|synch
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_LOOP
expr_stmt|;
name|to
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
name|to
operator|.
name|tsp_seq
operator|=
name|sequence
operator|++
expr_stmt|;
name|to
operator|.
name|tsp_hopcnt
operator|=
name|MAX_HOPCNT
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ntp
operator|->
name|dest_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|trace_sendto_err
argument_list|(
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|msg
operator|->
name|tsp_type
condition|)
block|{
case|case
name|TSP_MASTERREQ
case|:
break|break;
case|case
name|TSP_SLAVEUP
case|:
name|newslave
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_SETDATE
case|:
comment|/* 			 * XXX check to see it is from ourself 			 */
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|newdate
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|newdate
argument_list|,
name|ctime
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
argument_list|,
sizeof|sizeof
name|newdate
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newdate
index|[
sizeof|sizeof
name|newdate
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"attempted date change by %s to %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
name|spreadtime
argument_list|()
expr_stmt|;
break|break;
block|}
name|mchgdate
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
expr_stmt|;
break|break;
case|case
name|TSP_SETDATEREQ
case|:
if|if
condition|(
operator|!
name|fromnet
operator|||
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
condition|)
break|break;
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|newdate
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|newdate
argument_list|,
name|ctime
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
argument_list|,
sizeof|sizeof
name|newdate
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newdate
index|[
sizeof|sizeof
name|newdate
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
name|htp
operator|=
name|findhost
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|htp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempted SET DATEREQ by uncontrolled %s to %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|htp
operator|->
name|seq
operator|==
name|msg
operator|->
name|tsp_seq
condition|)
break|break;
name|htp
operator|->
name|seq
operator|=
name|msg
operator|->
name|tsp_seq
expr_stmt|;
if|if
condition|(
operator|!
name|htp
operator|->
name|good
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"attempted SET DATEREQ by untrusted %s to %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
name|spreadtime
argument_list|()
expr_stmt|;
break|break;
block|}
name|mchgdate
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
expr_stmt|;
break|break;
case|case
name|TSP_MSITE
case|:
name|xmit
argument_list|(
name|TSP_ACK
argument_list|,
name|msg
operator|->
name|tsp_seq
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_MSITEREQ
case|:
break|break;
case|case
name|TSP_TRACEON
case|:
name|traceon
argument_list|()
expr_stmt|;
break|break;
case|case
name|TSP_TRACEOFF
case|:
name|traceoff
argument_list|(
literal|"Tracing ended at %s\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_ELECTION
case|:
if|if
condition|(
operator|!
name|fromnet
condition|)
break|break;
if|if
condition|(
name|fromnet
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
name|pollingtime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
block|}
name|taddr
operator|=
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tname
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
sizeof|sizeof
name|tname
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tname
index|[
sizeof|sizeof
name|tname
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|taddr
argument_list|,
name|tname
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"election error by %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TSP_CONFLICT
case|:
comment|/* 			 * After a network partition, there can be 			 * more than one master: the first slave to 			 * come up will notify here the situation. 			 */
if|if
condition|(
operator|!
name|fromnet
operator|||
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
condition|)
break|break;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* The other master often gets into the same state, 			 * with boring results if we stay at it forever. 			 */
name|ntp
operator|=
name|fromnet
expr_stmt|;
comment|/* (acksend() can leave fromnet=0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_RESOLVE
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|ntp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
break|break;
name|htp
operator|=
name|addmach
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
name|msg
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
name|htp
operator|->
name|noanswer
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no response from %s to CONFLICT-QUIT"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TSP_RESOLVE
case|:
if|if
condition|(
operator|!
name|fromnet
operator|||
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
condition|)
break|break;
comment|/* 			 * do not want to call synch() while waiting 			 * to be killed! 			 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
expr_stmt|;
break|break;
case|case
name|TSP_QUIT
case|:
name|doquit
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* become a slave */
break|break;
case|case
name|TSP_LOOP
case|:
if|if
condition|(
operator|!
name|fromnet
operator|||
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
operator|||
operator|!
name|strcmp
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
name|hostname
argument_list|)
condition|)
break|break;
comment|/* 			 * We should not have received this from a net 			 * we are master on.  There must be two masters. 			 */
name|htp
operator|=
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"loop breakage: no reply from %s=%s to QUIT"
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|htp
operator|->
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
case|case
name|TSP_TEST
case|:
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\tnets = %d, masters = %d, slaves = %d, ignored = %d\n"
argument_list|,
name|nnets
argument_list|,
name|nmasternets
argument_list|,
name|nslavenets
argument_list|,
name|nignorednets
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
block|}
name|pollingtime
operator|=
literal|0
expr_stmt|;
name|polls
operator|=
name|POLLRATE
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"garbage message: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|msg
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_function

begin_comment
comment|/*  * change the system date on the master  */
end_comment

begin_function
specifier|static
name|void
name|mchgdate
parameter_list|(
name|msg
parameter_list|)
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|;
block|{
name|char
name|tname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|char
name|olddate
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|timeval
name|otime
decl_stmt|,
name|ntime
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tname
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
sizeof|sizeof
name|tname
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tname
index|[
sizeof|sizeof
name|tname
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xmit
argument_list|(
name|TSP_DATEACK
argument_list|,
name|msg
operator|->
name|tsp_seq
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|olddate
argument_list|,
name|date
argument_list|()
argument_list|,
sizeof|sizeof
name|olddate
operator|-
literal|1
argument_list|)
expr_stmt|;
name|olddate
index|[
sizeof|sizeof
name|olddate
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* adjust time for residence on the queue */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|otime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adj_msg_time
argument_list|(
name|msg
argument_list|,
operator|&
name|otime
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ntime
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
argument_list|,
operator|&
name|otime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntime
operator|.
name|tv_sec
operator|<
name|MAXADJ
operator|&&
name|ntime
operator|.
name|tv_sec
operator|>
operator|-
name|MAXADJ
condition|)
block|{
comment|/* 		 * do not change the clock if we can adjust it 		 */
name|dictate
operator|=
literal|3
expr_stmt|;
name|synch
argument_list|(
name|tvtomsround
argument_list|(
name|ntime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|sgi
if|if
condition|(
literal|0
operator|>
name|settimeofday
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"settimeofday(): %m"
argument_list|)
expr_stmt|;
block|}
name|logwtmp
argument_list|(
operator|&
name|otime
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
argument_list|)
expr_stmt|;
else|#
directive|else
name|logwtmp
argument_list|(
literal|"|"
argument_list|,
literal|"date"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|settimeofday
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|logwtmp
argument_list|(
literal|"{"
argument_list|,
literal|"date"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
name|spreadtime
argument_list|()
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"date changed by %s from %s"
argument_list|,
name|tname
argument_list|,
name|olddate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * synchronize all of the slaves  */
end_comment

begin_function
name|void
name|synch
parameter_list|(
name|mydelta
parameter_list|)
name|long
name|mydelta
decl_stmt|;
block|{
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|int
name|measure_status
decl_stmt|;
name|struct
name|timeval
name|check
decl_stmt|,
name|stop
decl_stmt|,
name|wait
decl_stmt|;
ifdef|#
directive|ifdef
name|sgi
name|int
name|pri
decl_stmt|;
endif|#
directive|endif
comment|/* sgi */
if|if
condition|(
name|slvcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"measurements starting at %s\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|check
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
comment|/* run fast to get good time */
name|pri
operator|=
name|schedctl
argument_list|(
name|NDPRI
argument_list|,
literal|0
argument_list|,
name|NDPHIMIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"schedctl(): %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
for|for
control|(
name|htp
operator|=
name|self
operator|.
name|l_fwd
init|;
name|htp
operator|!=
operator|&
name|self
condition|;
name|htp
operator|=
name|htp
operator|->
name|l_fwd
control|)
block|{
if|if
condition|(
name|htp
operator|->
name|noanswer
operator|!=
literal|0
condition|)
block|{
name|measure_status
operator|=
name|measure
argument_list|(
literal|500
argument_list|,
literal|100
argument_list|,
name|htp
operator|->
name|name
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|measure_status
operator|=
name|measure
argument_list|(
literal|3000
argument_list|,
literal|100
argument_list|,
name|htp
operator|->
name|name
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|measure_status
operator|!=
name|GOOD
condition|)
block|{
comment|/* The slave did not respond.  We have 				 * just wasted lots of time on it. 				 */
name|htp
operator|->
name|delta
operator|=
name|HOSTDOWN
expr_stmt|;
if|if
condition|(
operator|++
name|htp
operator|->
name|noanswer
operator|>=
name|LOSTHOST
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"purging %s for not answering ICMP\n"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|htp
operator|=
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|htp
operator|->
name|delta
operator|=
name|measure_delta
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|stop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|stop
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop
operator|.
name|tv_sec
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 				 * ack messages periodically 				 */
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|readmsg
argument_list|(
name|TSP_TRACEON
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|wait
argument_list|,
literal|0
argument_list|)
condition|)
name|traceon
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|check
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|sgi
if|if
condition|(
name|pri
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|schedctl
argument_list|(
name|NDPRI
argument_list|,
literal|0
argument_list|,
name|pri
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"measurements finished at %s\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|SLAVE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|dictate
condition|)
block|{
name|mydelta
operator|=
name|networkdelta
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dictate
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trace
operator|&&
operator|(
name|mydelta
operator|!=
literal|0
operator|||
operator|(
name|status
operator|&
name|SLAVE
operator|)
operator|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"local correction of %ld ms.\n"
argument_list|,
name|mydelta
argument_list|)
expr_stmt|;
name|correct
argument_list|(
name|mydelta
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sends the time to each slave after the master  * has received the command to set the network time  */
end_comment

begin_function
name|void
name|spreadtime
parameter_list|()
block|{
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|struct
name|tsp
name|to
decl_stmt|;
name|struct
name|tsp
modifier|*
name|answer
decl_stmt|;
comment|/* Do not listen to the consensus after forcing the time.  This is because  *	the consensus takes a while to reach the time we are dictating.  */
name|dictate
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|htp
operator|=
name|self
operator|.
name|l_fwd
init|;
name|htp
operator|!=
operator|&
name|self
condition|;
name|htp
operator|=
name|htp
operator|->
name|l_fwd
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_SETTIME
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|to
operator|.
name|tsp_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
name|htp
operator|->
name|noanswer
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|0
condition|)
block|{
comment|/* We client does not respond, then we have 			 * just wasted lots of time on it. 			 */
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no reply to SETTIME from %s"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|htp
operator|->
name|noanswer
operator|>=
name|LOSTHOST
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"purging %s for not answering"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|htp
operator|=
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|prthp
parameter_list|(
name|delta
parameter_list|)
name|clock_t
name|delta
decl_stmt|;
block|{
specifier|static
name|time_t
name|next_time
decl_stmt|;
name|time_t
name|this_time
decl_stmt|;
name|struct
name|tms
name|tm
decl_stmt|;
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|int
name|length
decl_stmt|,
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
comment|/* quit if tracing already off */
return|return;
name|this_time
operator|=
name|times
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_time
operator|+
name|delta
operator|<
name|next_time
condition|)
return|return;
name|next_time
operator|=
name|this_time
operator|+
name|CLK_TCK
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"host table: %d entries at %s\n"
argument_list|,
name|slvcount
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
name|htp
operator|=
name|self
operator|.
name|l_fwd
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|slvcount
condition|;
name|i
operator|++
operator|,
name|htp
operator|=
name|htp
operator|->
name|l_fwd
control|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|htp
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|+
name|l
operator|>=
literal|80
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
name|length
operator|+=
name|l
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" %s"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|hosttbl
modifier|*
name|newhost_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hosttbl
modifier|*
name|lasthfree
init|=
operator|&
name|hosttbl
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|hosttbl
modifier|*
comment|/* answer or 0 */
name|findhost
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|j
operator|=
operator|(
name|j
operator|<<
literal|2
operator|)
operator|^
operator|*
name|p
expr_stmt|;
name|newhost_hash
operator|=
operator|&
name|hosttbl
index|[
name|j
operator|%
name|NHOSTS
index|]
expr_stmt|;
name|htp
operator|=
name|newhost_hash
expr_stmt|;
if|if
condition|(
name|htp
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|htp
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|htp
operator|)
return|;
name|htp
operator|=
name|htp
operator|->
name|h_fwd
expr_stmt|;
block|}
do|while
condition|(
name|htp
operator|!=
name|newhost_hash
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add a host to the list of controlled machines if not already there  */
end_comment

begin_function
name|struct
name|hosttbl
modifier|*
name|addmach
parameter_list|(
name|name
parameter_list|,
name|addr
parameter_list|,
name|ntp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
block|{
name|struct
name|hosttbl
modifier|*
name|ret
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|ret
operator|=
name|findhost
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slvcount
operator|>=
name|NHOSTS
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"no more slots in host table\n"
argument_list|)
expr_stmt|;
name|prthp
argument_list|(
name|CLK_TCK
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no more slots in host table"
argument_list|)
expr_stmt|;
name|Mflag
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* give up and be a slave */
block|}
comment|/* if our home hash slot is occupied, find a free entry 		 * in the hash table 		 */
if|if
condition|(
name|newhost_hash
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|lasthfree
expr_stmt|;
if|if
condition|(
operator|++
name|lasthfree
operator|>
operator|&
name|hosttbl
index|[
name|NHOSTS
index|]
condition|)
name|lasthfree
operator|=
operator|&
name|hosttbl
index|[
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
operator|!
name|newhost_hash
operator|->
name|head
condition|)
block|{
comment|/* Move an interloper using our home.  Use 				 * scratch pointers in case the new head is 				 * pointing to itself. 				 */
name|f
operator|=
name|newhost_hash
operator|->
name|h_fwd
expr_stmt|;
name|b
operator|=
name|newhost_hash
operator|->
name|h_bak
expr_stmt|;
name|f
operator|->
name|h_bak
operator|=
name|ret
expr_stmt|;
name|b
operator|->
name|h_fwd
operator|=
name|ret
expr_stmt|;
name|f
operator|=
name|newhost_hash
operator|->
name|l_fwd
expr_stmt|;
name|b
operator|=
name|newhost_hash
operator|->
name|l_bak
expr_stmt|;
name|f
operator|->
name|l_bak
operator|=
name|ret
expr_stmt|;
name|b
operator|->
name|l_fwd
operator|=
name|ret
expr_stmt|;
name|bcopy
argument_list|(
name|newhost_hash
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|newhost_hash
expr_stmt|;
name|ret
operator|->
name|head
operator|=
literal|1
expr_stmt|;
name|ret
operator|->
name|h_fwd
operator|=
name|ret
expr_stmt|;
name|ret
operator|->
name|h_bak
operator|=
name|ret
expr_stmt|;
block|}
else|else
block|{
comment|/* link to an existing chain in our home 				 */
name|ret
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|newhost_hash
operator|->
name|h_bak
expr_stmt|;
name|ret
operator|->
name|h_fwd
operator|=
name|newhost_hash
expr_stmt|;
name|ret
operator|->
name|h_bak
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|h_fwd
operator|=
name|ret
expr_stmt|;
name|newhost_hash
operator|->
name|h_bak
operator|=
name|ret
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|newhost_hash
expr_stmt|;
name|ret
operator|->
name|head
operator|=
literal|1
expr_stmt|;
name|ret
operator|->
name|h_fwd
operator|=
name|ret
expr_stmt|;
name|ret
operator|->
name|h_bak
operator|=
name|ret
expr_stmt|;
block|}
name|ret
operator|->
name|addr
operator|=
operator|*
name|addr
expr_stmt|;
name|ret
operator|->
name|ntp
operator|=
name|ntp
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|good
operator|=
name|good_host_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|l_fwd
operator|=
operator|&
name|self
expr_stmt|;
name|ret
operator|->
name|l_bak
operator|=
name|self
operator|.
name|l_bak
expr_stmt|;
name|self
operator|.
name|l_bak
operator|->
name|l_fwd
operator|=
name|ret
expr_stmt|;
name|self
operator|.
name|l_bak
operator|=
name|ret
expr_stmt|;
name|slvcount
operator|++
expr_stmt|;
name|ret
operator|->
name|noanswer
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|need_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|->
name|noanswer
operator|=
operator|(
name|ret
operator|->
name|noanswer
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* need to clear sequence number anyhow */
name|ret
operator|->
name|seq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * remove the machine with the given index in the host table.  */
end_comment

begin_function
name|struct
name|hosttbl
modifier|*
name|remmach
parameter_list|(
name|htp
parameter_list|)
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
block|{
name|struct
name|hosttbl
modifier|*
name|lprv
decl_stmt|,
modifier|*
name|hnxt
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"remove %s\n"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* get out of the lists */
name|htp
operator|->
name|l_fwd
operator|->
name|l_bak
operator|=
name|lprv
operator|=
name|htp
operator|->
name|l_bak
expr_stmt|;
name|htp
operator|->
name|l_bak
operator|->
name|l_fwd
operator|=
name|htp
operator|->
name|l_fwd
expr_stmt|;
name|htp
operator|->
name|h_fwd
operator|->
name|h_bak
operator|=
name|htp
operator|->
name|h_bak
expr_stmt|;
name|htp
operator|->
name|h_bak
operator|->
name|h_fwd
operator|=
name|hnxt
operator|=
name|htp
operator|->
name|h_fwd
expr_stmt|;
comment|/* If we are in the home slot, pull up the chain */
if|if
condition|(
name|htp
operator|->
name|head
operator|&&
name|hnxt
operator|!=
name|htp
condition|)
block|{
if|if
condition|(
name|lprv
operator|==
name|hnxt
condition|)
name|lprv
operator|=
name|htp
expr_stmt|;
comment|/* Use scratch pointers in case the new head is pointing to 		 * itself. 		 */
name|f
operator|=
name|hnxt
operator|->
name|h_fwd
expr_stmt|;
name|b
operator|=
name|hnxt
operator|->
name|h_bak
expr_stmt|;
name|f
operator|->
name|h_bak
operator|=
name|htp
expr_stmt|;
name|b
operator|->
name|h_fwd
operator|=
name|htp
expr_stmt|;
name|f
operator|=
name|hnxt
operator|->
name|l_fwd
expr_stmt|;
name|b
operator|=
name|hnxt
operator|->
name|l_bak
expr_stmt|;
name|f
operator|->
name|l_bak
operator|=
name|htp
expr_stmt|;
name|b
operator|->
name|l_fwd
operator|=
name|htp
expr_stmt|;
name|hnxt
operator|->
name|head
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|hnxt
argument_list|,
name|htp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|htp
argument_list|)
argument_list|)
expr_stmt|;
name|lasthfree
operator|=
name|hnxt
expr_stmt|;
block|}
else|else
block|{
name|lasthfree
operator|=
name|htp
expr_stmt|;
block|}
name|lasthfree
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lasthfree
operator|->
name|h_fwd
operator|=
literal|0
expr_stmt|;
name|lasthfree
operator|->
name|l_fwd
operator|=
literal|0
expr_stmt|;
name|slvcount
operator|--
expr_stmt|;
return|return
name|lprv
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all the machines from the host table that exist on the given  * network.  This is called when a master transitions to a slave on a  * given network.  */
end_comment

begin_function
name|void
name|rmnetmachs
parameter_list|(
name|ntp
parameter_list|)
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
block|{
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|prthp
argument_list|(
name|CLK_TCK
argument_list|)
expr_stmt|;
for|for
control|(
name|htp
operator|=
name|self
operator|.
name|l_fwd
init|;
name|htp
operator|!=
operator|&
name|self
condition|;
name|htp
operator|=
name|htp
operator|->
name|l_fwd
control|)
block|{
if|if
condition|(
name|ntp
operator|==
name|htp
operator|->
name|ntp
condition|)
name|htp
operator|=
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
name|prthp
argument_list|(
name|CLK_TCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|masterup
parameter_list|(
name|net
parameter_list|)
name|struct
name|netinfo
modifier|*
name|net
decl_stmt|;
block|{
name|xmit
argument_list|(
name|TSP_MASTERUP
argument_list|,
literal|0
argument_list|,
operator|&
name|net
operator|->
name|dest_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Do not tell new slaves our time for a while.  This ensures 	 * we do not tell them to start using our time, before we have 	 * found a good master. 	 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|net
operator|->
name|slvwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|newslave
parameter_list|(
name|msg
parameter_list|)
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|;
block|{
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|struct
name|tsp
modifier|*
name|answer
decl_stmt|,
name|to
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
operator|!
name|fromnet
operator|||
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
condition|)
return|return;
name|htp
operator|=
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
name|htp
operator|->
name|seq
operator|=
name|msg
operator|->
name|tsp_seq
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|prthp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If we are stable, send our time to the slave. 	 * Do not go crazy if the date has been changed. 	 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|>=
name|fromnet
operator|->
name|slvwait
operator|.
name|tv_sec
operator|+
literal|3
operator|||
name|now
operator|.
name|tv_sec
operator|<
name|fromnet
operator|->
name|slvwait
operator|.
name|tv_sec
condition|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_SETTIME
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_name
index|[
sizeof|sizeof
name|to
operator|.
name|tsp_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|to
operator|.
name|tsp_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
name|htp
operator|->
name|noanswer
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
condition|)
block|{
name|htp
operator|->
name|need_set
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no reply to initial SETTIME from %s"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
name|htp
operator|->
name|noanswer
operator|=
name|LOSTHOST
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * react to a TSP_QUIT:  */
end_comment

begin_function
name|void
name|doquit
parameter_list|(
name|msg
parameter_list|)
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|fromnet
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|fromnet
operator|->
name|quit_count
operator|<=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"untrusted %s told us QUIT"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
name|fromnet
operator|->
name|quit_count
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"untrusted %s told us QUIT twice"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|fromnet
operator|->
name|quit_count
operator|=
literal|2
expr_stmt|;
name|fromnet
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
block|}
else|else
block|{
name|fromnet
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
block|}
name|rmnetmachs
argument_list|(
name|fromnet
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* give up and be a slave */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"untrusted %s told us QUIT"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|fromnet
operator|->
name|quit_count
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|traceon
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|fd
operator|=
name|fopen
argument_list|(
name|_PATH_TIMEDLOG
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|trace
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Tracing started at %s\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|trace
operator|=
literal|1
expr_stmt|;
name|get_goodgroup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|prthp
argument_list|(
name|CLK_TCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|traceoff
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|get_goodgroup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|prthp
argument_list|(
name|CLK_TCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
name|msg
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GPROF
name|moncontrol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_mcleanup
argument_list|()
expr_stmt|;
name|moncontrol
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trace
operator|=
name|OFF
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_function
name|void
name|logwtmp
parameter_list|(
name|otime
parameter_list|,
name|ntime
parameter_list|)
name|struct
name|timeval
modifier|*
name|otime
decl_stmt|,
decl|*
name|ntime
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|struct
name|utmp
name|wtmp
index|[
literal|2
index|]
init|=
block|{
block|{
literal|""
block|,
literal|""
block|,
name|OTIME_MSG
block|,
literal|0
block|,
name|OLD_TIME
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
name|NTIME_MSG
block|,
literal|0
block|,
name|NEW_TIME
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|wtmpfile
init|=
name|WTMP_FILE
decl_stmt|;
name|int
name|f
decl_stmt|;
name|wtmp
index|[
literal|0
index|]
operator|.
name|ut_time
operator|=
name|otime
operator|->
name|tv_sec
operator|+
operator|(
name|otime
operator|->
name|tv_usec
operator|+
literal|500000
operator|)
operator|/
literal|1000000
expr_stmt|;
name|wtmp
index|[
literal|1
index|]
operator|.
name|ut_time
operator|=
name|ntime
operator|->
name|tv_sec
operator|+
operator|(
name|ntime
operator|->
name|tv_usec
operator|+
literal|500000
operator|)
operator|/
literal|1000000
expr_stmt|;
if|if
condition|(
name|wtmp
index|[
literal|0
index|]
operator|.
name|ut_time
operator|==
name|wtmp
index|[
literal|1
index|]
operator|.
name|ut_time
condition|)
return|return;
name|setutent
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|pututline
argument_list|(
operator|&
name|wtmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pututline
argument_list|(
operator|&
name|wtmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|wtmpfile
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

end_unit

