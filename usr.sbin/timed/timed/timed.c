begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1985, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)timed.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|TSPTYPES
end_define

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/syssgi.h>
end_include

begin_include
include|#
directive|include
file|<sys/schedctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_decl_stmt
name|int
name|trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sock
decl_stmt|,
name|sock_raw
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sequence number */
end_comment

begin_decl_stmt
name|long
name|delay1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|delay2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nslavenets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nets were I could be a slave */
end_comment

begin_decl_stmt
name|int
name|nmasternets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nets were I could be a master */
end_comment

begin_decl_stmt
name|int
name|nignorednets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignored nets */
end_comment

begin_decl_stmt
name|int
name|nnets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nets I am connected to */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace file FD */
end_comment

begin_decl_stmt
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|nettab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|slavenet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Mflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|justquit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|nets
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|net
decl_stmt|;
name|struct
name|nets
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|nets
init|=
literal|0
struct|;
end_struct

begin_decl_stmt
name|struct
name|hosttbl
name|hosttbl
index|[
name|NHOSTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* known hosts */
end_comment

begin_struct
specifier|static
struct|struct
name|goodhost
block|{
comment|/* hosts that we trust */
name|char
name|name
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|goodhost
modifier|*
name|next
decl_stmt|;
name|char
name|perm
decl_stmt|;
block|}
modifier|*
name|goodhosts
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|goodgroup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* net group of trusted hosts */
end_comment

begin_decl_stmt
specifier|static
name|void
name|checkignorednets
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pickslavenet
name|__P
argument_list|(
operator|(
expr|struct
name|netinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_good_host
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|timetrim_fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|timetrim_wpat
init|=
literal|"long timetrim = %ld;\ndouble tot_adj = %.0f;\ndouble tot_ticks = %.0f;\n/* timed version 2 */\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|timetrim_rpat
init|=
literal|"long timetrim = %ld;\ndouble tot_adj = %lf;\ndouble tot_ticks = %lf;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|timetrim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|tot_adj
decl_stmt|,
name|hr_adj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* totals in nsec */
end_comment

begin_decl_stmt
name|double
name|tot_ticks
decl_stmt|,
name|hr_ticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bufspace
init|=
literal|60
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The timedaemons synchronize the clocks of hosts in a local area network.  * One daemon runs as master, all the others as slaves. The master  * performs the task of computing clock differences and sends correction  * values to the slaves.  * Slaves start an election to choose a new master when the latter disappears  * because of a machine crash, network partition, or when killed.  * A resolution protocol is used to kill all but one of the masters  * that happen to exist in segments of a partitioned network when the  * network partition is fixed.  *  * Authors: Riccardo Gusella& Stefano Zatti  *  * overhauled at Silicon Graphics  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|on
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|nflag
decl_stmt|,
name|iflag
decl_stmt|;
name|struct
name|timeval
name|ntime
decl_stmt|;
name|struct
name|servent
modifier|*
name|srvp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cplim
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|,
name|ifreqf
decl_stmt|,
modifier|*
name|ifr
decl_stmt|;
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|ntip
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|savefromnet
decl_stmt|;
name|struct
name|netent
modifier|*
name|nentp
decl_stmt|;
name|struct
name|nets
modifier|*
name|nt
decl_stmt|;
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|sgi
name|FILE
modifier|*
name|timetrim_st
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sgi
name|struct
name|tms
name|tms
decl_stmt|;
endif|#
directive|endif
comment|/* sgi */
ifdef|#
directive|ifdef
name|lint
name|ntip
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|on
operator|=
literal|1
expr_stmt|;
name|nflag
operator|=
name|OFF
expr_stmt|;
name|iflag
operator|=
name|OFF
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
if|if
condition|(
literal|0
operator|>
name|syssgi
argument_list|(
name|SGI_GETTIMETRIM
argument_list|,
operator|&
name|timetrim
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"syssgi(GETTIMETRIM)"
argument_list|)
expr_stmt|;
name|timetrim
operator|=
literal|0
expr_stmt|;
block|}
name|tot_ticks
operator|=
name|hr_ticks
operator|=
name|times
argument_list|(
operator|&
name|tms
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Mtdn:i:F:G:P:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|Mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|iflag
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-i and -n make no sense together"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nflag
operator|=
name|ON
expr_stmt|;
name|addnetname
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|nflag
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-i and -n make no sense together"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iflag
operator|=
name|ON
expr_stmt|;
name|addnetname
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
name|add_good_host
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|add_good_host
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|goodgroup
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"only one net group"
argument_list|)
expr_stmt|;
name|goodgroup
operator|=
name|optarg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|sgi
case|case
literal|'P'
case|:
name|timetrim_fn
operator|=
name|optarg
expr_stmt|;
name|timetrim_st
operator|=
name|fopen
argument_list|(
name|timetrim_fn
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|timetrim_st
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|timetrim_fn
argument_list|)
expr_stmt|;
name|timetrim_fn
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|long
name|trim
decl_stmt|;
name|double
name|adj
decl_stmt|,
name|ticks
decl_stmt|;
name|i
operator|=
name|fscanf
argument_list|(
name|timetrim_st
argument_list|,
name|timetrim_rpat
argument_list|,
operator|&
name|trim
argument_list|,
operator|&
name|adj
argument_list|,
operator|&
name|ticks
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|trim
operator|>
name|MAX_TRIM
operator|||
name|trim
operator|<
operator|-
name|MAX_TRIM
operator|||
name|i
operator|==
literal|2
operator|||
operator|(
name|i
operator|==
literal|3
operator|&&
name|trim
operator|!=
name|rint
argument_list|(
name|adj
operator|*
name|CLK_TCK
operator|/
name|ticks
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|trace
operator|&&
name|i
operator|!=
name|EOF
condition|)
name|warn
argument_list|(
literal|"unrecognized contents in %s"
argument_list|,
name|timetrim_fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|0
operator|>
name|syssgi
argument_list|(
name|SGI_SETTIMETRIM
argument_list|,
name|trim
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"syssgi(SETTIMETRIM)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timetrim
operator|=
name|trim
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|tot_adj
operator|=
name|adj
expr_stmt|;
name|tot_ticks
operator|-=
name|ticks
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|timetrim_st
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* sgi */
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* If we care about which machine is the master, then we must 	 *	be willing to be a master 	 */
if|if
condition|(
literal|0
operator|!=
name|goodgroup
operator|||
literal|0
operator|!=
name|goodhosts
condition|)
name|Mflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gethostname"
argument_list|)
expr_stmt|;
name|self
operator|.
name|l_bak
operator|=
operator|&
name|self
expr_stmt|;
name|self
operator|.
name|l_fwd
operator|=
operator|&
name|self
expr_stmt|;
name|self
operator|.
name|h_bak
operator|=
operator|&
name|self
expr_stmt|;
name|self
operator|.
name|h_fwd
operator|=
operator|&
name|self
expr_stmt|;
name|self
operator|.
name|head
operator|=
literal|1
expr_stmt|;
name|self
operator|.
name|good
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|goodhosts
operator|!=
literal|0
condition|)
comment|/* trust ourself */
name|add_good_host
argument_list|(
name|hostname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|srvp
operator|=
name|getservbyname
argument_list|(
literal|"timed"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srvp
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown service 'timed/udp'"
argument_list|)
expr_stmt|;
name|port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|warnx
argument_list|(
literal|"time daemon already running"
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|sgi
comment|/* 	 * handle many slaves with our buffer 	 */
if|if
condition|(
literal|0
operator|>
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bufspace
argument_list|,
sizeof|sizeof
argument_list|(
name|bufspace
argument_list|)
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
comment|/* choose a unique seed for random number generation */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|ntime
operator|.
name|tv_sec
operator|+
name|ntime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|random
argument_list|()
expr_stmt|;
comment|/* initial seq number */
ifndef|#
directive|ifndef
name|sgi
comment|/* rounds kernel variable time to multiple of 5 ms. */
name|ntime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntime
operator|.
name|tv_usec
operator|=
operator|-
operator|(
operator|(
name|ntime
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|%
literal|5
operator|)
operator|*
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|adjtime
argument_list|(
operator|&
name|ntime
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
for|for
control|(
name|nt
operator|=
name|nets
init|;
name|nt
condition|;
name|nt
operator|=
name|nt
operator|->
name|next
control|)
block|{
name|nentp
operator|=
name|getnetbyname
argument_list|(
name|nt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentp
operator|==
literal|0
condition|)
block|{
name|nt
operator|->
name|net
operator|=
name|inet_network
argument_list|(
name|nt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|net
operator|!=
name|INADDR_NONE
condition|)
name|nentp
operator|=
name|getnetbyaddr
argument_list|(
name|nt
operator|->
name|net
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nentp
operator|!=
literal|0
condition|)
block|{
name|nt
operator|->
name|net
operator|=
name|nentp
operator|->
name|n_net
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|->
name|net
operator|==
name|INADDR_NONE
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown net %s"
argument_list|,
name|nt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|->
name|net
operator|==
name|INADDR_ANY
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"bad net %s"
argument_list|,
name|nt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"warning: %s unknown in /etc/networks"
argument_list|,
name|nt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
operator|(
name|nt
operator|->
name|net
operator|&
literal|0xff000000
operator|)
condition|)
name|nt
operator|->
name|net
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|nt
operator|->
name|net
operator|&
literal|0xff000000
operator|)
condition|)
name|nt
operator|->
name|net
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|nt
operator|->
name|net
operator|&
literal|0xff000000
operator|)
condition|)
name|nt
operator|->
name|net
operator|<<=
literal|8
expr_stmt|;
block|}
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"get interface configuration"
argument_list|)
expr_stmt|;
name|ntp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
define|#
directive|define
name|size
parameter_list|(
name|p
parameter_list|)
value|(sizeof(*ifr) - sizeof(ifr->ifr_name))
comment|/* XXX hack. kludge */
else|#
directive|else
define|#
directive|define
name|size
parameter_list|(
name|p
parameter_list|)
value|max((p).sa_len, sizeof(p))
endif|#
directive|endif
name|cplim
operator|=
name|buf
operator|+
name|ifc
operator|.
name|ifc_len
expr_stmt|;
comment|/*skip over if's with big ifr_addr's */
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|cplim
condition|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|size
argument_list|(
name|ifr
operator|->
name|ifr_addr
argument_list|)
control|)
block|{
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ntp
condition|)
name|ntp
operator|=
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ntp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ntp
argument_list|)
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|my_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
name|ifreq
operator|=
operator|*
name|ifr
expr_stmt|;
name|ifreqf
operator|=
operator|*
name|ifr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreqf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get interface flags"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifreqf
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifreqf
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifreqf
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get netmask"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|mask
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ifreqf
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFBRDADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get broadaddr"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|dest_addr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_broadaddr
expr_stmt|;
comment|/* What if the broadcast address is all ones? 			 * So we cannot just mask ntp->dest_addr.  */
name|ntp
operator|->
name|net
operator|=
name|ntp
operator|->
name|my_addr
expr_stmt|;
name|ntp
operator|->
name|net
operator|.
name|s_addr
operator|&=
name|ntp
operator|->
name|mask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get destaddr"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|dest_addr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_dstaddr
expr_stmt|;
name|ntp
operator|->
name|net
operator|=
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_addr
expr_stmt|;
block|}
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
for|for
control|(
name|nt
operator|=
name|nets
init|;
name|nt
condition|;
name|nt
operator|=
name|nt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|net
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|nt
operator|->
name|net
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|nflag
operator|&&
operator|!
name|nt
operator|)
operator|||
operator|(
name|iflag
operator|&&
name|nt
operator|)
condition|)
continue|continue;
name|ntp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nettab
operator|==
name|NULL
condition|)
block|{
name|nettab
operator|=
name|ntp
expr_stmt|;
block|}
else|else
block|{
name|ntip
operator|->
name|next
operator|=
name|ntp
expr_stmt|;
block|}
name|ntip
operator|=
name|ntp
expr_stmt|;
name|ntp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ntp
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nettab
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no network usable"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|schedctl
argument_list|(
name|RENICE
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* run fast to get good time */
comment|/* ticks to delay before responding to a broadcast */
name|delay1
operator|=
name|casual
argument_list|(
literal|0
argument_list|,
name|CLK_TCK
operator|/
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* microseconds to delay before responding to a broadcast */
name|delay1
operator|=
name|casual
argument_list|(
literal|1
argument_list|,
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
comment|/* election timer delay in secs. */
name|delay2
operator|=
name|casual
argument_list|(
name|MINTOUT
argument_list|,
name|MAXTOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|_daemonize
argument_list|(
name|debug
condition|?
name|_DF_NOFORK
operator||
name|_DF_NOCHDIR
else|:
literal|0
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|debug
condition|)
name|daemon
argument_list|(
name|debug
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
if|if
condition|(
name|trace
condition|)
name|traceon
argument_list|()
expr_stmt|;
name|openlog
argument_list|(
literal|"timed"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
comment|/* 	 * keep returning here 	 */
name|ret
operator|=
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
expr_stmt|;
name|savefromnet
operator|=
name|fromnet
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|Mflag
condition|)
block|{
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
name|checkignorednets
argument_list|()
expr_stmt|;
name|pickslavenet
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Just lost our master */
if|if
condition|(
name|slavenet
operator|!=
literal|0
condition|)
name|slavenet
operator|->
name|status
operator|=
name|election
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slavenet
operator|||
name|slavenet
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
name|checkignorednets
argument_list|()
expr_stmt|;
name|pickslavenet
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|makeslave
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
comment|/* prune extras */
block|}
break|break;
case|case
literal|2
case|:
comment|/* Just been told to quit */
name|justquit
operator|=
literal|1
expr_stmt|;
name|pickslavenet
argument_list|(
name|savefromnet
argument_list|)
expr_stmt|;
break|break;
block|}
name|setstatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MASTER
operator|)
operator|&&
name|sock_raw
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* sock_raw is not being used now */
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock_raw
argument_list|)
expr_stmt|;
name|sock_raw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|MASTER
condition|)
name|master
argument_list|()
expr_stmt|;
else|else
name|slave
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sock_raw
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock_raw
argument_list|)
expr_stmt|;
name|sock_raw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
comment|/* we just lost our master or were told to quit */
name|justquit
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
name|rmnetmachs
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
block|}
name|checkignorednets
argument_list|()
expr_stmt|;
name|pickslavenet
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|slave
argument_list|()
expr_stmt|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|sgi
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: timed [-dtM] [-i net|-n net] [-F host1 host2 ...]"
argument_list|,
literal|"             [-G netgp] [-P trimfile]"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVENIS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: timed [-dtM] [-i net|-n net] [-F host1 host2 ...] [-G netgp]\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: timed [-dtM] [-i net|-n net] [-F host1 host2 ...]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVENIS */
endif|#
directive|endif
comment|/* sgi */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * suppress an upstart, untrustworthy, self-appointed master  */
end_comment

begin_function
name|void
name|suppress
parameter_list|(
name|addr
parameter_list|,
name|name
parameter_list|,
name|net
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|net
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|tgt
decl_stmt|;
name|char
name|tname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|tsp
name|msg
decl_stmt|;
specifier|static
name|struct
name|timeval
name|wait
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"suppress: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tgt
operator|=
operator|*
name|addr
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
name|readmsg
argument_list|(
name|TSP_ANY
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|wait
argument_list|,
name|net
argument_list|)
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"suppress:\tdiscarded packet from %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"suppressing false master %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|msg
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|acksend
argument_list|(
operator|&
name|msg
argument_list|,
operator|&
name|tgt
argument_list|,
name|tname
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lookformaster
parameter_list|(
name|ntp
parameter_list|)
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
block|{
name|struct
name|tsp
name|resp
decl_stmt|,
name|conflict
decl_stmt|,
modifier|*
name|answer
decl_stmt|;
name|struct
name|timeval
name|ntime
decl_stmt|;
name|char
name|mastername
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|masteraddr
decl_stmt|;
name|get_goodgroup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
comment|/* look for master */
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_MASTERREQ
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|resp
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|ntp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|0
operator|&&
operator|!
name|good_host_name
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
name|answer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|answer
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Various conditions can cause conflict: races between 		 * two just started timedaemons when no master is 		 * present, or timedaemons started during an election. 		 * A conservative approach is taken.  Give up and became a 		 * slave, postponing election of a master until first 		 * timer expires. 		 */
name|ntime
operator|.
name|tv_sec
operator|=
name|ntime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERREQ
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|ntime
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
block|}
return|return;
block|}
name|ntime
operator|.
name|tv_sec
operator|=
name|ntime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERUP
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|ntime
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
block|}
return|return;
block|}
name|ntime
operator|.
name|tv_sec
operator|=
name|ntime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_ELECTION
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|ntime
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|Mflag
condition|)
name|ntp
operator|->
name|status
operator|=
name|MASTER
expr_stmt|;
else|else
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
return|return;
block|}
name|ntp
operator|->
name|status
operator|=
name|SLAVE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mastername
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|masteraddr
operator|=
name|from
expr_stmt|;
comment|/* 	 * If network has been partitioned, there might be other 	 * masters; tell the one we have just acknowledged that 	 * it has to gain control over the others. 	 */
name|ntime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntime
operator|.
name|tv_usec
operator|=
literal|300000
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERACK
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|ntime
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
comment|/* 	 * checking also not to send CONFLICT to ack'ed master 	 * due to duplicated MASTERACKs 	 */
if|if
condition|(
name|answer
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
name|mastername
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|conflict
operator|.
name|tsp_type
operator|=
name|TSP_CONFLICT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|conflict
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acksend
argument_list|(
operator|&
name|conflict
argument_list|,
operator|&
name|masteraddr
argument_list|,
name|mastername
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error on sending TSP_CONFLICT"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * based on the current network configuration, set the status, and count  * networks;  */
end_comment

begin_function
name|void
name|setstatus
parameter_list|()
block|{
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|nmasternets
operator|=
name|nslavenets
operator|=
name|nnets
operator|=
name|nignorednets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Net status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ntp
operator|->
name|status
condition|)
block|{
case|case
name|MASTER
case|:
name|nmasternets
operator|++
expr_stmt|;
break|break;
case|case
name|SLAVE
case|:
name|nslavenets
operator|++
expr_stmt|;
break|break;
case|case
name|NOMASTER
case|:
case|case
name|IGNORE
case|:
name|nignorednets
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t%-16s"
argument_list|,
name|inet_ntoa
argument_list|(
name|ntp
operator|->
name|net
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ntp
operator|->
name|status
condition|)
block|{
case|case
name|NOMASTER
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"NOMASTER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MASTER
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"MASTER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLAVE
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"SLAVE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"IGNORE\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"invalid state %d\n"
argument_list|,
operator|(
name|int
operator|)
name|ntp
operator|->
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nnets
operator|++
expr_stmt|;
name|status
operator||=
name|ntp
operator|->
name|status
expr_stmt|;
block|}
name|status
operator|&=
operator|~
name|IGNORE
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\tnets=%d masters=%d slaves=%d ignored=%d delay2=%d\n"
argument_list|,
name|nnets
argument_list|,
name|nmasternets
argument_list|,
name|nslavenets
argument_list|,
name|nignorednets
argument_list|,
name|delay2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makeslave
parameter_list|(
name|net
parameter_list|)
name|struct
name|netinfo
modifier|*
name|net
decl_stmt|;
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|SLAVE
operator|&&
name|ntp
operator|!=
name|net
condition|)
name|ntp
operator|->
name|status
operator|=
name|IGNORE
expr_stmt|;
block|}
name|slavenet
operator|=
name|net
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to become master over ignored nets..  */
end_comment

begin_function
specifier|static
name|void
name|checkignorednets
parameter_list|()
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|Mflag
operator|&&
name|ntp
operator|->
name|status
operator|==
name|SLAVE
condition|)
break|break;
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|IGNORE
operator|||
name|ntp
operator|->
name|status
operator|==
name|NOMASTER
condition|)
block|{
name|lookformaster
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Mflag
operator|&&
name|ntp
operator|->
name|status
operator|==
name|SLAVE
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * choose a good network on which to be a slave  *	The ignored networks must have already been checked.  *	Take a hint about for a good network.  */
end_comment

begin_function
specifier|static
name|void
name|pickslavenet
parameter_list|(
name|ntp
parameter_list|)
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
block|{
if|if
condition|(
name|slavenet
operator|!=
literal|0
operator|&&
name|slavenet
operator|->
name|status
operator|==
name|SLAVE
condition|)
block|{
name|makeslave
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
comment|/* prune extras */
return|return;
block|}
if|if
condition|(
name|ntp
operator|==
literal|0
operator|||
name|ntp
operator|->
name|status
operator|!=
name|SLAVE
condition|)
block|{
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
literal|0
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|SLAVE
condition|)
break|break;
block|}
block|}
name|makeslave
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * returns a random number in the range [inf, sup]  */
end_comment

begin_function
name|long
name|casual
parameter_list|(
name|inf
parameter_list|,
name|sup
parameter_list|)
name|long
name|inf
decl_stmt|,
name|sup
decl_stmt|;
block|{
name|double
name|value
decl_stmt|;
name|value
operator|=
operator|(
call|(
name|double
call|)
argument_list|(
name|random
argument_list|()
operator|&
literal|0x7fffffff
argument_list|)
operator|)
operator|/
operator|(
literal|0x7fffffff
operator|*
literal|1.0
operator|)
expr_stmt|;
return|return
operator|(
name|inf
operator|+
operator|(
name|sup
operator|-
name|inf
operator|)
operator|*
name|value
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|date
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|sgi
name|struct
name|timeval
name|tv
decl_stmt|;
specifier|static
name|char
name|tm
index|[
literal|32
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|tm
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
return|return
operator|(
name|tm
operator|)
return|;
else|#
directive|else
name|struct
name|timeval
name|tv
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctime
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* sgi */
block|}
end_function

begin_function
name|void
name|addnetname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|nets
modifier|*
modifier|*
name|netlist
init|=
operator|&
name|nets
decl_stmt|;
while|while
condition|(
operator|*
name|netlist
condition|)
name|netlist
operator|=
operator|&
operator|(
operator|(
operator|*
name|netlist
operator|)
operator|->
name|next
operator|)
expr_stmt|;
operator|*
name|netlist
operator|=
operator|(
expr|struct
name|nets
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|netlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|netlist
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|netlist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|netlist
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|netlist
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* note a host as trustworthy */
end_comment

begin_function
specifier|static
name|void
name|add_good_host
parameter_list|(
name|name
parameter_list|,
name|perm
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|perm
decl_stmt|;
comment|/* 1=not part of the netgroup */
block|{
specifier|register
name|struct
name|goodhost
modifier|*
name|ghp
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hentp
decl_stmt|;
name|ghp
operator|=
operator|(
expr|struct
name|goodhost
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ghp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ghp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ghp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ghp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|&
name|ghp
operator|->
name|name
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ghp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ghp
operator|->
name|next
operator|=
name|goodhosts
expr_stmt|;
name|ghp
operator|->
name|perm
operator|=
name|perm
expr_stmt|;
name|goodhosts
operator|=
name|ghp
expr_stmt|;
name|hentp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|hentp
operator|&&
name|perm
condition|)
name|warnx
argument_list|(
literal|"unknown host %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* update our image of the net-group of trustworthy hosts  */
end_comment

begin_function
name|void
name|get_goodgroup
parameter_list|(
name|force
parameter_list|)
name|int
name|force
decl_stmt|;
block|{
define|#
directive|define
name|NG_DELAY
value|(30*60*CLK_TCK)
comment|/* 30 minutes */
specifier|static
name|unsigned
name|long
name|last_update
init|=
operator|-
name|NG_DELAY
decl_stmt|;
name|unsigned
name|long
name|new_update
decl_stmt|;
name|struct
name|goodhost
modifier|*
name|ghp
decl_stmt|,
modifier|*
modifier|*
name|ghpp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVENIS
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|mach
decl_stmt|,
modifier|*
name|usr
decl_stmt|,
modifier|*
name|dom
decl_stmt|;
endif|#
directive|endif
comment|/* HAVENIS */
name|struct
name|tms
name|tm
decl_stmt|;
comment|/* if no netgroup, then we are finished */
if|if
condition|(
name|goodgroup
operator|==
literal|0
operator|||
operator|!
name|Mflag
condition|)
return|return;
comment|/* Do not chatter with the netgroup master too often. 	 */
name|new_update
operator|=
name|times
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_update
operator|<
name|last_update
operator|+
name|NG_DELAY
operator|&&
operator|!
name|force
condition|)
return|return;
name|last_update
operator|=
name|new_update
expr_stmt|;
comment|/* forget the old temporary entries */
name|ghpp
operator|=
operator|&
name|goodhosts
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|ghp
operator|=
operator|*
name|ghpp
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ghp
operator|->
name|perm
condition|)
block|{
operator|*
name|ghpp
operator|=
name|ghp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ghp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ghpp
operator|=
operator|&
name|ghp
operator|->
name|next
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVENIS
comment|/* quit now if we are not one of the trusted masters 	 */
if|if
condition|(
operator|!
name|innetgr
argument_list|(
name|goodgroup
argument_list|,
operator|&
name|hostname
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"get_goodgroup: %s not in %s\n"
argument_list|,
operator|&
name|hostname
index|[
literal|0
index|]
argument_list|,
name|goodgroup
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"get_goodgroup: %s in %s\n"
argument_list|,
operator|&
name|hostname
index|[
literal|0
index|]
argument_list|,
name|goodgroup
argument_list|)
expr_stmt|;
comment|/* mark the entire netgroup as trusted */
operator|(
name|void
operator|)
name|setnetgrent
argument_list|(
name|goodgroup
argument_list|)
expr_stmt|;
while|while
condition|(
name|getnetgrent
argument_list|(
operator|&
name|mach
argument_list|,
operator|&
name|usr
argument_list|,
operator|&
name|dom
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|!=
name|mach
condition|)
name|add_good_host
argument_list|(
name|mach
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|endnetgrent
argument_list|()
expr_stmt|;
comment|/* update list of slaves */
for|for
control|(
name|htp
operator|=
name|self
operator|.
name|l_fwd
init|;
name|htp
operator|!=
operator|&
name|self
condition|;
name|htp
operator|=
name|htp
operator|->
name|l_fwd
control|)
block|{
name|htp
operator|->
name|good
operator|=
name|good_host_name
argument_list|(
operator|&
name|htp
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVENIS */
block|}
end_function

begin_comment
comment|/* see if a machine is trustworthy  */
end_comment

begin_function
name|int
comment|/* 1=trust hp to change our date */
name|good_host_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|goodhost
modifier|*
name|ghp
init|=
name|goodhosts
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|ghp
operator|||
operator|!
name|Mflag
condition|)
comment|/* trust everyone if no one named */
return|return
literal|1
return|;
name|c
operator|=
operator|*
name|name
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|==
name|ghp
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ghp
operator|->
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* found him, so say so */
block|}
do|while
condition|(
literal|0
operator|!=
operator|(
name|ghp
operator|=
name|ghp
operator|->
name|next
operator|)
condition|)
do|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|hostname
argument_list|)
condition|)
comment|/* trust ourself */
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* did not find him */
block|}
end_function

end_unit

