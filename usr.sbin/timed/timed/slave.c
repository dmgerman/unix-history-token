begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)slave.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: slave.c,v 1.5 1997/10/31 12:33:06 charnier Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|extern
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Mflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|justquit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|master_name
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|netinfo
modifier|*
name|old_slavenet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schgdate
name|__P
argument_list|(
operator|(
expr|struct
name|tsp
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setmaster
name|__P
argument_list|(
operator|(
expr|struct
name|tsp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|answerdelay
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|logwtmp
name|__P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|void
name|logwtmp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_function
name|int
name|slave
parameter_list|()
block|{
name|int
name|tries
decl_stmt|;
name|long
name|electiontime
decl_stmt|,
name|refusetime
decl_stmt|,
name|looktime
decl_stmt|,
name|looptime
decl_stmt|,
name|adjtime
decl_stmt|;
name|u_short
name|seq
decl_stmt|;
name|long
name|fastelection
decl_stmt|;
define|#
directive|define
name|FASTTOUT
value|3
name|struct
name|in_addr
name|cadr
decl_stmt|;
name|struct
name|timeval
name|otime
decl_stmt|;
name|struct
name|sockaddr_in
name|taddr
decl_stmt|;
name|char
name|tname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|,
name|to
decl_stmt|;
name|struct
name|timeval
name|ntime
decl_stmt|,
name|wait
decl_stmt|;
name|struct
name|tsp
modifier|*
name|answer
decl_stmt|;
name|int
name|timeout
parameter_list|()
function_decl|;
name|char
name|olddate
index|[
literal|32
index|]
decl_stmt|;
name|char
name|newdate
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|struct
name|hosttbl
modifier|*
name|htp
decl_stmt|;
name|old_slavenet
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
literal|0
expr_stmt|;
name|refusetime
operator|=
literal|0
expr_stmt|;
name|adjtime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|electiontime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
name|fastelection
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
if|if
condition|(
name|justquit
condition|)
name|looktime
operator|=
name|electiontime
expr_stmt|;
else|else
name|looktime
operator|=
name|fastelection
expr_stmt|;
name|looptime
operator|=
name|fastelection
expr_stmt|;
if|if
condition|(
name|slavenet
condition|)
name|xmit
argument_list|(
name|TSP_SLAVEUP
argument_list|,
literal|0
argument_list|,
operator|&
name|slavenet
operator|->
name|dest_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MASTER
condition|)
block|{
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
block|}
name|loop
label|:
name|get_goodgroup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntime
operator|.
name|tv_sec
operator|>
name|electiontime
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"election timer expired\n"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntime
operator|.
name|tv_sec
operator|>=
name|looktime
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Looking for nets to master\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mflag
operator|&&
name|nignorednets
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|IGNORE
operator|||
name|ntp
operator|->
name|status
operator|==
name|NOMASTER
condition|)
block|{
name|lookformaster
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
name|ntp
operator|->
name|status
operator|=
name|NOMASTER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
operator|&&
operator|--
name|ntp
operator|->
name|quit_count
operator|<
literal|0
condition|)
name|ntp
operator|->
name|quit_count
operator|=
literal|0
expr_stmt|;
block|}
name|makeslave
argument_list|(
name|slavenet
argument_list|)
expr_stmt|;
comment|/* prune extras */
name|setstatus
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|looktime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
block|}
if|if
condition|(
name|ntime
operator|.
name|tv_sec
operator|>=
name|looptime
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Looking for loops\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_LOOP
expr_stmt|;
name|to
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
name|to
operator|.
name|tsp_seq
operator|=
name|sequence
operator|++
expr_stmt|;
name|to
operator|.
name|tsp_hopcnt
operator|=
name|MAX_HOPCNT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ntp
operator|->
name|dest_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|trace_sendto_err
argument_list|(
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|looptime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
block|}
name|wait
operator|.
name|tv_sec
operator|=
name|min
argument_list|(
name|electiontime
argument_list|,
name|min
argument_list|(
name|looktime
argument_list|,
name|looptime
argument_list|)
argument_list|)
operator|-
name|ntime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|+=
name|FASTTOUT
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|readmsg
argument_list|(
name|TSP_ANY
argument_list|,
name|ANYADDR
argument_list|,
operator|&
name|wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * filter stuff not for us 		 */
switch|switch
condition|(
name|msg
operator|->
name|tsp_type
condition|)
block|{
case|case
name|TSP_SETDATE
case|:
case|case
name|TSP_TRACEOFF
case|:
case|case
name|TSP_TRACEON
case|:
comment|/* 			 * XXX check to see they are from ourself 			 */
break|break;
case|case
name|TSP_TEST
case|:
case|case
name|TSP_MSITE
case|:
break|break;
case|case
name|TSP_MASTERUP
case|:
if|if
condition|(
operator|!
name|fromnet
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"slave ignored: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|msg
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|fromnet
operator|||
name|fromnet
operator|->
name|status
operator|==
name|IGNORE
operator|||
name|fromnet
operator|->
name|status
operator|==
name|NOMASTER
condition|)
block|{
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"slave ignored: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|msg
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
break|break;
block|}
comment|/* 		 * now process the message 		 */
switch|switch
condition|(
name|msg
operator|->
name|tsp_type
condition|)
block|{
case|case
name|TSP_ADJTIME
case|:
if|if
condition|(
name|fromnet
operator|!=
name|slavenet
condition|)
break|break;
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"attempted time adjustment by %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Speed up loop detection in case we have a loop. 			 * Otherwise the clocks can race until the loop 			 * is found. 			 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|otime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjtime
operator|<
name|otime
operator|.
name|tv_sec
condition|)
name|looptime
operator|-=
operator|(
name|looptime
operator|-
name|otime
operator|.
name|tv_sec
operator|)
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
name|setmaster
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|!=
name|msg
operator|->
name|tsp_seq
condition|)
block|{
name|seq
operator|=
name|msg
operator|->
name|tsp_seq
expr_stmt|;
name|synch
argument_list|(
name|tvtomsround
argument_list|(
name|msg
operator|->
name|tsp_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|electiontime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
name|fastelection
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
name|adjtime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|TSP_SETTIME
case|:
if|if
condition|(
name|fromnet
operator|!=
name|slavenet
condition|)
break|break;
if|if
condition|(
name|seq
operator|==
name|msg
operator|->
name|tsp_seq
condition|)
break|break;
name|seq
operator|=
name|msg
operator|->
name|tsp_seq
expr_stmt|;
comment|/* adjust time for residence on the queue */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|otime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adj_msg_time
argument_list|(
name|msg
argument_list|,
operator|&
name|otime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|newdate
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|olddate
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|otime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 			 * the following line is necessary due to syslog 			 * calling ctime() which clobbers the static buffer 			 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|olddate
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newdate
argument_list|,
name|ctime
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"attempted time setting by untrusted %s to %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
break|break;
block|}
name|setmaster
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ntime
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
argument_list|,
operator|&
name|otime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntime
operator|.
name|tv_sec
operator|<
name|MAXADJ
operator|&&
name|ntime
operator|.
name|tv_sec
operator|>
operator|-
name|MAXADJ
condition|)
block|{
comment|/* 				 * do not change the clock if we can adjust it 				 */
name|synch
argument_list|(
name|tvtomsround
argument_list|(
name|ntime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|sgi
if|if
condition|(
literal|0
operator|>
name|settimeofday
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"settimeofdate(): %m"
argument_list|)
expr_stmt|;
break|break;
block|}
name|logwtmp
argument_list|(
operator|&
name|otime
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
argument_list|)
expr_stmt|;
else|#
directive|else
name|logwtmp
argument_list|(
literal|"|"
argument_list|,
literal|"date"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|settimeofday
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|logwtmp
argument_list|(
literal|"{"
argument_list|,
literal|"date"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"date changed by %s from %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|olddate
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MASTER
condition|)
name|spreadtime
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|electiontime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
name|fastelection
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
comment|/* This patches a bad protocol bug.  Imagine a system with several networks,  * where there are a pair of redundant gateways between a pair of networks,  * each running timed.  Assume that we start with a third machine mastering  * one of the networks, and one of the gateways mastering the other.  * Imagine that the third machine goes away and the non-master gateway  * decides to replace it.  If things are timed just 'right,' we will have  * each gateway mastering one network for a little while.  If a SETTIME  * message gets into the network at that time, perhaps from the newly  * masterful gateway as it was taking control, the SETTIME will loop  * forever.  Each time a gateway receives it on its slave side, it will  * call spreadtime to forward it on its mastered network.  We are now in  * a permanent loop, since the SETTIME msgs will keep any clock  * in the network from advancing.  Normally, the 'LOOP' stuff will detect  * and correct the situation.  However, with the clocks stopped, the  * 'looptime' timer cannot expire.  While they are in this state, the  * masters will try to saturate the network with SETTIME packets.  */
name|looptime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
operator|(
name|looptime
operator|-
name|otime
operator|.
name|tv_sec
operator|)
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TSP_MASTERUP
case|:
if|if
condition|(
name|slavenet
operator|&&
name|fromnet
operator|!=
name|slavenet
condition|)
break|break;
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|suppress
argument_list|(
operator|&
name|from
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|electiontime
operator|>
name|fastelection
condition|)
name|electiontime
operator|=
name|fastelection
expr_stmt|;
break|break;
block|}
name|makeslave
argument_list|(
name|fromnet
argument_list|)
expr_stmt|;
name|setmaster
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|setstatus
argument_list|()
expr_stmt|;
name|answerdelay
argument_list|()
expr_stmt|;
name|xmit
argument_list|(
name|TSP_SLAVEUP
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|electiontime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
name|fastelection
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
name|refusetime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TSP_MASTERREQ
case|:
if|if
condition|(
name|fromnet
operator|->
name|status
operator|!=
name|SLAVE
condition|)
break|break;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|electiontime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
break|break;
case|case
name|TSP_SETDATE
case|:
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|newdate
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newdate
argument_list|,
name|ctime
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
name|schgdate
argument_list|(
name|msg
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_SETDATEREQ
case|:
if|if
condition|(
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
condition|)
break|break;
ifdef|#
directive|ifdef
name|sgi
operator|(
name|void
operator|)
name|cftime
argument_list|(
name|newdate
argument_list|,
literal|"%D %T"
argument_list|,
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newdate
argument_list|,
name|ctime
argument_list|(
operator|&
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi */
name|htp
operator|=
name|findhost
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|htp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"DATEREQ from uncontrolled machine"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|htp
operator|->
name|good
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"attempted date change by untrusted %s to %s"
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
name|spreadtime
argument_list|()
expr_stmt|;
break|break;
block|}
name|schgdate
argument_list|(
name|msg
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_TRACEON
case|:
name|traceon
argument_list|()
expr_stmt|;
break|break;
case|case
name|TSP_TRACEOFF
case|:
name|traceoff
argument_list|(
literal|"Tracing ended at %s\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_SLAVEUP
case|:
name|newslave
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_ELECTION
case|:
if|if
condition|(
name|fromnet
operator|->
name|status
operator|==
name|SLAVE
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|electiontime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|delay2
expr_stmt|;
name|fastelection
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
name|seq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|good_host_name
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"suppress election of %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
name|electiontime
operator|=
name|fastelection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cadr
operator|.
name|s_addr
operator|!=
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&&
name|ntime
operator|.
name|tv_sec
operator|<
name|refusetime
condition|)
block|{
comment|/* if the candidate has to repeat itself, the old code would refuse it  * the second time.  That would prevent elections.  */
name|to
operator|.
name|tsp_type
operator|=
name|TSP_REFUSE
expr_stmt|;
block|}
else|else
block|{
name|cadr
operator|.
name|s_addr
operator|=
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_ACCEPT
expr_stmt|;
name|refusetime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
literal|30
expr_stmt|;
block|}
name|taddr
operator|=
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|answerdelay
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|taddr
argument_list|,
name|tname
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no answer from candidate %s\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fromnet->status == MASTER */
name|htp
operator|=
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
name|htp
operator|->
name|noanswer
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no reply from %s to ELECTION-QUIT"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TSP_CONFLICT
case|:
if|if
condition|(
name|fromnet
operator|->
name|status
operator|!=
name|MASTER
condition|)
break|break;
comment|/* 			 * After a network partition, there can be 			 * more than one master: the first slave to 			 * come up will notify here the situation. 			 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
comment|/* The other master often gets into the same state, 			 * with boring results. 			 */
name|ntp
operator|=
name|fromnet
expr_stmt|;
comment|/* (acksend() can leave fromnet=0 */
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_RESOLVE
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|ntp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
break|break;
name|htp
operator|=
name|addmach
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
name|htp
operator|->
name|noanswer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"conflict error: no reply from %s to QUIT"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
block|}
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_MSITE
case|:
if|if
condition|(
operator|!
name|slavenet
condition|)
break|break;
name|taddr
operator|=
name|from
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_MSITEREQ
expr_stmt|;
name|to
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
name|to
operator|.
name|tsp_seq
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|slavenet
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_ACK
argument_list|,
name|slavenet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
operator|&&
name|good_host_name
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|)
condition|)
block|{
name|setmaster
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_ACK
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|taddr
argument_list|,
sizeof|sizeof
argument_list|(
name|taddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|trace_sendto_err
argument_list|(
name|taddr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TSP_MSITEREQ
case|:
break|break;
case|case
name|TSP_ACCEPT
case|:
case|case
name|TSP_REFUSE
case|:
case|case
name|TSP_RESOLVE
case|:
break|break;
case|case
name|TSP_QUIT
case|:
name|doquit
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* become a slave */
break|break;
case|case
name|TSP_TEST
case|:
name|electiontime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TSP_LOOP
case|:
comment|/* looking for loops of masters */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|MASTER
operator|)
condition|)
break|break;
if|if
condition|(
name|fromnet
operator|->
name|status
operator|==
name|SLAVE
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
name|hostname
argument_list|)
condition|)
block|{
comment|/* 				 * Someone forwarded our message back to 				 * us.  There must be a loop.  Tell the 				 * master of this network to quit. 				 * 				 * The other master often gets into 				 * the same state, with boring results. 				 */
name|ntp
operator|=
name|fromnet
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_RESOLVE
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|ntp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
break|break;
name|taddr
operator|=
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|taddr
argument_list|,
name|tname
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no reply from %s to slave LOOP-QUIT"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|electiontime
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|looptime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msg
operator|->
name|tsp_hopcnt
operator|--
operator|<
literal|1
condition|)
break|break;
name|bytenetorder
argument_list|(
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
literal|0
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
operator|&&
literal|0
operator|>
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ntp
operator|->
name|dest_addr
argument_list|)
argument_list|)
condition|)
name|trace_sendto_err
argument_list|(
name|ntp
operator|->
name|dest_addr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* fromnet->status == MASTER */
comment|/* 			     * We should not have received this from a net 			     * we are master on.  There must be two masters, 			     * unless the packet was really from us. 			     */
if|if
condition|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|fromnet
operator|->
name|my_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"discarding forwarded LOOP\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			     * The other master often gets into the same 			     * state, with boring results. 			     */
name|ntp
operator|=
name|fromnet
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_RESOLVE
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|ntp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
break|break;
name|htp
operator|=
name|addmach
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|htp
operator|->
name|addr
argument_list|,
name|htp
operator|->
name|name
argument_list|,
name|TSP_ACK
argument_list|,
literal|0
argument_list|,
name|htp
operator|->
name|noanswer
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no reply from %s to master LOOP-QUIT"
argument_list|,
name|htp
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remmach
argument_list|(
name|htp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|ntime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|looptime
operator|=
name|ntime
operator|.
name|tv_sec
operator|+
name|FASTTOUT
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"garbage message: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|msg
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_function

begin_comment
comment|/*  * tell the world who our master is  */
end_comment

begin_function
specifier|static
name|void
name|setmaster
parameter_list|(
name|msg
parameter_list|)
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|slavenet
operator|&&
operator|(
name|slavenet
operator|!=
name|old_slavenet
operator|||
name|strcmp
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
name|master_name
argument_list|)
operator|||
name|old_status
operator|!=
name|status
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|master_name
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|old_slavenet
operator|=
name|slavenet
expr_stmt|;
name|old_status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MASTER
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"submaster to %s"
argument_list|,
name|master_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"submaster to %s\n"
argument_list|,
name|master_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"slave to %s"
argument_list|,
name|master_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"slave to %s\n"
argument_list|,
name|master_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * handle date change request on a slave  */
end_comment

begin_function
specifier|static
name|void
name|schgdate
parameter_list|(
name|msg
parameter_list|,
name|newdate
parameter_list|)
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|newdate
decl_stmt|;
block|{
name|struct
name|tsp
name|to
decl_stmt|;
name|u_short
name|seq
decl_stmt|;
name|struct
name|sockaddr_in
name|taddr
decl_stmt|;
name|struct
name|timeval
name|otime
decl_stmt|;
if|if
condition|(
operator|!
name|slavenet
condition|)
return|return;
comment|/* no where to forward */
name|taddr
operator|=
name|from
expr_stmt|;
name|seq
operator|=
name|msg
operator|->
name|tsp_seq
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"forwarding date change by %s to %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|newdate
argument_list|)
expr_stmt|;
comment|/* adjust time for residence on the queue */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|otime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adj_msg_time
argument_list|(
name|msg
argument_list|,
operator|&
name|otime
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_SETDATEREQ
expr_stmt|;
name|to
operator|.
name|tsp_time
operator|=
name|msg
operator|->
name|tsp_time
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|slavenet
operator|->
name|dest_addr
argument_list|,
name|ANYADDR
argument_list|,
name|TSP_DATEACK
argument_list|,
name|slavenet
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* no answer */
name|xmit
argument_list|(
name|TSP_DATEACK
argument_list|,
name|seq
argument_list|,
operator|&
name|taddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used before answering a broadcast message to avoid network  * contention and likely collisions.  */
end_comment

begin_function
specifier|static
name|void
name|answerdelay
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|sgi
name|sginap
argument_list|(
name|delay1
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|delay1
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* sgi */
block|}
end_function

end_unit

