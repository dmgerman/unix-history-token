begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012, Fabien Thomas  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Process hwpmc(4) samples as calltree.  *  * Output file format compatible with Kcachegrind (kdesdk).  * Handle top mode with a sorted tree display.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pmc.h>
end_include

begin_include
include|#
directive|include
file|<pmclog.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|"pmcstat.h"
end_include

begin_include
include|#
directive|include
file|"pmcstat_log.h"
end_include

begin_include
include|#
directive|include
file|"pmcstat_top.h"
end_include

begin_include
include|#
directive|include
file|"pmcpl_calltree.h"
end_include

begin_define
define|#
directive|define
name|PMCPL_CT_GROWSIZE
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|pmcstat_skiplink
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|pmcpl_ct_node
struct_decl|;
end_struct_decl

begin_comment
comment|/* Get the sample value for PMC a. */
end_comment

begin_define
define|#
directive|define
name|PMCPL_CT_SAMPLE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|((a)< (b)->npmcs ? (b)->sb[a] : 0)
end_define

begin_comment
comment|/* Get the sample value in percent related to rsamples. */
end_comment

begin_define
define|#
directive|define
name|PMCPL_CT_SAMPLEP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|(PMCPL_CT_SAMPLE(a, b) * 100.0 / rsamples->sb[a])
end_define

begin_struct
struct|struct
name|pmcpl_ct_sample
block|{
name|int
name|npmcs
decl_stmt|;
comment|/* Max pmc index available. */
name|unsigned
modifier|*
name|sb
decl_stmt|;
comment|/* Sample buffer for 0..npmcs. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pmcpl_ct_arc
block|{
name|struct
name|pmcpl_ct_sample
name|pcta_samples
decl_stmt|;
name|struct
name|pmcpl_ct_sample
name|pcta_callid
decl_stmt|;
name|unsigned
name|pcta_call
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|pcta_child
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pmcpl_ct_instr
block|{
name|uintfptr_t
name|pctf_func
decl_stmt|;
name|struct
name|pmcpl_ct_sample
name|pctf_samples
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Each calltree node is tracked by a pmcpl_ct_node struct.  */
end_comment

begin_struct
struct|struct
name|pmcpl_ct_node
block|{
name|struct
name|pmcstat_image
modifier|*
name|pct_image
decl_stmt|;
name|uintfptr_t
name|pct_func
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|pct_sym
decl_stmt|;
name|pmcstat_interned_string
name|pct_ifl
decl_stmt|;
name|pmcstat_interned_string
name|pct_ifn
decl_stmt|;
name|struct
name|pmcpl_ct_sample
name|pct_samples
decl_stmt|;
name|int
name|pct_narc
decl_stmt|;
name|int
name|pct_arc_c
decl_stmt|;
name|struct
name|pmcpl_ct_arc
modifier|*
name|pct_arc
decl_stmt|;
comment|/* TODO: optimize for large number of items. */
name|int
name|pct_ninstr
decl_stmt|;
name|int
name|pct_instr_c
decl_stmt|;
name|struct
name|pmcpl_ct_instr
modifier|*
name|pct_instr
decl_stmt|;
define|#
directive|define
name|PMCPL_PCT_ADDR
value|0
define|#
directive|define
name|PMCPL_PCT_NAME
value|1
name|char
name|pct_type
decl_stmt|;
define|#
directive|define
name|PMCPL_PCT_WHITE
value|0
define|#
directive|define
name|PMCPL_PCT_GREY
value|1
define|#
directive|define
name|PMCPL_PCT_BLACK
value|2
name|char
name|pct_color
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pmcpl_ct_node_hash
block|{
name|struct
name|pmcpl_ct_node
modifier|*
name|pch_ctnode
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|pmcpl_ct_node_hash
argument_list|)
name|pch_next
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pmcpl_ct_sample
name|pmcpl_ct_callid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PMCPL_CT_MAXCOL
value|PMC_CALLCHAIN_DEPTH_MAX
end_define

begin_define
define|#
directive|define
name|PMCPL_CT_MAXLINE
value|1024
end_define

begin_comment
comment|/* TODO: dynamic. */
end_comment

begin_struct
struct|struct
name|pmcpl_ct_line
block|{
name|unsigned
name|ln_sum
decl_stmt|;
name|unsigned
name|ln_index
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pmcpl_ct_line
name|pmcpl_ct_topmax
index|[
name|PMCPL_CT_MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmcpl_ct_node
modifier|*
name|pmcpl_ct_topscreen
index|[
name|PMCPL_CT_MAXCOL
operator|+
literal|1
index|]
index|[
name|PMCPL_CT_MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All nodes indexed by function/image name are placed in a hash table.  */
end_comment

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|pmcpl_ct_node_hash
argument_list|)
name|pmcpl_ct_node_hash
index|[
name|PMCSTAT_NHASH
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Root node for the graph.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pmcpl_ct_node
modifier|*
name|pmcpl_ct_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_comment
comment|/*  * Initialize a samples.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_samples_init
parameter_list|(
name|struct
name|pmcpl_ct_sample
modifier|*
name|samples
parameter_list|)
block|{
name|samples
operator|->
name|npmcs
operator|=
literal|0
expr_stmt|;
name|samples
operator|->
name|sb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a samples.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_samples_free
parameter_list|(
name|struct
name|pmcpl_ct_sample
modifier|*
name|samples
parameter_list|)
block|{
name|samples
operator|->
name|npmcs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|samples
operator|->
name|sb
argument_list|)
expr_stmt|;
name|samples
operator|->
name|sb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow a sample block to store pmcstat_npmcs PMCs.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_samples_grow
parameter_list|(
name|struct
name|pmcpl_ct_sample
modifier|*
name|samples
parameter_list|)
block|{
name|int
name|npmcs
decl_stmt|;
comment|/* Enough storage. */
if|if
condition|(
name|pmcstat_npmcs
operator|<=
name|samples
operator|->
name|npmcs
condition|)
return|return;
name|npmcs
operator|=
name|samples
operator|->
name|npmcs
operator|+
name|max
argument_list|(
name|pmcstat_npmcs
operator|-
name|samples
operator|->
name|npmcs
argument_list|,
name|PMCPL_CT_GROWSIZE
argument_list|)
expr_stmt|;
name|samples
operator|->
name|sb
operator|=
name|realloc
argument_list|(
name|samples
operator|->
name|sb
argument_list|,
name|npmcs
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|->
name|sb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"ERROR: out of memory"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|samples
operator|->
name|sb
operator|+
name|samples
operator|->
name|npmcs
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|,
operator|(
name|npmcs
operator|-
name|samples
operator|->
name|npmcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|samples
operator|->
name|npmcs
operator|=
name|npmcs
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the sum of all root arcs.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_samples_root
parameter_list|(
name|struct
name|pmcpl_ct_sample
modifier|*
name|samples
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pmcin
decl_stmt|;
name|pmcpl_ct_samples_init
argument_list|(
name|samples
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_grow
argument_list|(
name|samples
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmcpl_ct_root
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
for|for
control|(
name|pmcin
operator|=
literal|0
init|;
name|pmcin
operator|<
name|pmcstat_npmcs
condition|;
name|pmcin
operator|++
control|)
name|samples
operator|->
name|sb
index|[
name|pmcin
index|]
operator|+=
name|PMCPL_CT_SAMPLE
argument_list|(
name|pmcin
argument_list|,
operator|&
name|pmcpl_ct_root
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_samples
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the arc table.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_arc_grow
parameter_list|(
name|int
name|cursize
parameter_list|,
name|int
modifier|*
name|maxsize
parameter_list|,
name|struct
name|pmcpl_ct_arc
modifier|*
modifier|*
name|items
parameter_list|)
block|{
name|int
name|nmaxsize
decl_stmt|;
if|if
condition|(
name|cursize
operator|<
operator|*
name|maxsize
condition|)
return|return;
name|nmaxsize
operator|=
operator|*
name|maxsize
operator|+
name|max
argument_list|(
name|cursize
operator|+
literal|1
operator|-
operator|*
name|maxsize
argument_list|,
name|PMCPL_CT_GROWSIZE
argument_list|)
expr_stmt|;
operator|*
name|items
operator|=
name|realloc
argument_list|(
operator|*
name|items
argument_list|,
name|nmaxsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmcpl_ct_arc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|items
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"ERROR: out of memory"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|items
operator|+
operator|*
name|maxsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmcpl_ct_arc
argument_list|)
argument_list|,
operator|(
name|nmaxsize
operator|-
operator|*
name|maxsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmcpl_ct_arc
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|maxsize
operator|=
name|nmaxsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the instr table.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_instr_grow
parameter_list|(
name|int
name|cursize
parameter_list|,
name|int
modifier|*
name|maxsize
parameter_list|,
name|struct
name|pmcpl_ct_instr
modifier|*
modifier|*
name|items
parameter_list|)
block|{
name|int
name|nmaxsize
decl_stmt|;
if|if
condition|(
name|cursize
operator|<
operator|*
name|maxsize
condition|)
return|return;
name|nmaxsize
operator|=
operator|*
name|maxsize
operator|+
name|max
argument_list|(
name|cursize
operator|+
literal|1
operator|-
operator|*
name|maxsize
argument_list|,
name|PMCPL_CT_GROWSIZE
argument_list|)
expr_stmt|;
operator|*
name|items
operator|=
name|realloc
argument_list|(
operator|*
name|items
argument_list|,
name|nmaxsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmcpl_ct_instr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|items
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"ERROR: out of memory"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|items
operator|+
operator|*
name|maxsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmcpl_ct_instr
argument_list|)
argument_list|,
operator|(
name|nmaxsize
operator|-
operator|*
name|maxsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmcpl_ct_instr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|maxsize
operator|=
name|nmaxsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a new instruction sample to given node.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_instr_add
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|,
name|int
name|pmcin
parameter_list|,
name|uintfptr_t
name|pc
parameter_list|,
name|unsigned
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pmcpl_ct_instr
modifier|*
name|in
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_ninstr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_func
operator|==
name|pc
condition|)
block|{
name|in
operator|=
operator|&
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
expr_stmt|;
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|in
operator|->
name|pctf_samples
argument_list|)
expr_stmt|;
name|in
operator|->
name|pctf_samples
operator|.
name|sb
index|[
name|pmcin
index|]
operator|+=
name|v
expr_stmt|;
return|return;
block|}
block|}
name|pmcpl_ct_instr_grow
argument_list|(
name|ct
operator|->
name|pct_ninstr
argument_list|,
operator|&
name|ct
operator|->
name|pct_instr_c
argument_list|,
operator|&
name|ct
operator|->
name|pct_instr
argument_list|)
expr_stmt|;
name|in
operator|=
operator|&
name|ct
operator|->
name|pct_instr
index|[
name|ct
operator|->
name|pct_ninstr
index|]
expr_stmt|;
name|in
operator|->
name|pctf_func
operator|=
name|pc
expr_stmt|;
name|pmcpl_ct_samples_init
argument_list|(
operator|&
name|in
operator|->
name|pctf_samples
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|in
operator|->
name|pctf_samples
argument_list|)
expr_stmt|;
name|in
operator|->
name|pctf_samples
operator|.
name|sb
index|[
name|pmcin
index|]
operator|=
name|v
expr_stmt|;
name|ct
operator|->
name|pct_ninstr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new node.  */
end_comment

begin_function
specifier|static
name|struct
name|pmcpl_ct_node
modifier|*
name|pmcpl_ct_node_allocate
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
decl_stmt|;
if|if
condition|(
operator|(
name|ct
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ct
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot allocate callgraph node"
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_init
argument_list|(
operator|&
name|ct
operator|->
name|pct_samples
argument_list|)
expr_stmt|;
name|ct
operator|->
name|pct_sym
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|pct_image
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|pct_func
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|pct_narc
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|pct_arc_c
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|pct_arc
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|pct_ninstr
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|pct_instr_c
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|pct_instr
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_WHITE
expr_stmt|;
return|return
operator|(
name|ct
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a node.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_node_free
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
block|{
name|pmcpl_ct_samples_free
argument_list|(
operator|&
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_samples
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_free
argument_list|(
operator|&
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_callid
argument_list|)
expr_stmt|;
block|}
name|pmcpl_ct_samples_free
argument_list|(
operator|&
name|ct
operator|->
name|pct_samples
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ct
operator|->
name|pct_arc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ct
operator|->
name|pct_instr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the graph tag on each node.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_node_cleartag
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pmcpl_ct_node_hash
modifier|*
name|pch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMCSTAT_NHASH
condition|;
name|i
operator|++
control|)
name|STAILQ_FOREACH
argument_list|(
argument|pch
argument_list|,
argument|&pmcpl_ct_node_hash[i]
argument_list|,
argument|pch_next
argument_list|)
name|pch
operator|->
name|pch_ctnode
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_WHITE
expr_stmt|;
name|pmcpl_ct_root
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_WHITE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the callchain line by line with maximum cost at top.  */
end_comment

begin_function
specifier|static
name|int
name|pmcpl_ct_node_dumptop
parameter_list|(
name|int
name|pmcin
parameter_list|,
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|,
name|struct
name|pmcpl_ct_sample
modifier|*
name|rsamples
parameter_list|,
name|int
name|x
parameter_list|,
name|int
modifier|*
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|terminal
decl_stmt|;
name|struct
name|pmcpl_ct_arc
modifier|*
name|arc
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|pct_color
operator|==
name|PMCPL_PCT_GREY
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|>=
name|PMCPL_CT_MAXCOL
condition|)
block|{
name|pmcpl_ct_topscreen
index|[
name|x
index|]
index|[
operator|*
name|y
index|]
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
name|pmcpl_ct_topscreen
index|[
name|x
index|]
index|[
operator|*
name|y
index|]
operator|=
name|ct
expr_stmt|;
comment|/* 	 * Check if this is a terminal node. 	 * We need to check that some samples exist 	 * for at least one arc for that PMC. 	 */
name|terminal
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
block|{
name|arc
operator|=
operator|&
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|arc
operator|->
name|pcta_child
operator|->
name|pct_color
operator|!=
name|PMCPL_PCT_GREY
operator|&&
name|PMCPL_CT_SAMPLE
argument_list|(
name|pmcin
argument_list|,
operator|&
name|arc
operator|->
name|pcta_samples
argument_list|)
operator|!=
literal|0
operator|&&
name|PMCPL_CT_SAMPLEP
argument_list|(
name|pmcin
argument_list|,
operator|&
name|arc
operator|->
name|pcta_samples
argument_list|)
operator|>
name|pmcstat_threshold
condition|)
block|{
name|terminal
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ct
operator|->
name|pct_narc
operator|==
literal|0
operator|||
name|terminal
condition|)
block|{
name|pmcpl_ct_topscreen
index|[
name|x
operator|+
literal|1
index|]
index|[
operator|*
name|y
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|>=
name|PMCPL_CT_MAXLINE
condition|)
return|return
literal|1
return|;
operator|*
name|y
operator|=
operator|*
name|y
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
name|pmcpl_ct_topscreen
index|[
name|i
index|]
index|[
operator|*
name|y
index|]
operator|=
name|pmcpl_ct_topscreen
index|[
name|i
index|]
index|[
operator|*
name|y
operator|-
literal|1
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ct
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_GREY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PMCPL_CT_SAMPLE
argument_list|(
name|pmcin
argument_list|,
operator|&
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_samples
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|PMCPL_CT_SAMPLEP
argument_list|(
name|pmcin
argument_list|,
operator|&
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_samples
argument_list|)
operator|>
name|pmcstat_threshold
condition|)
block|{
if|if
condition|(
name|pmcpl_ct_node_dumptop
argument_list|(
name|pmcin
argument_list|,
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_child
argument_list|,
name|rsamples
argument_list|,
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|ct
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_BLACK
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
name|ct
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_BLACK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two top line by sum.  */
end_comment

begin_function
specifier|static
name|int
name|pmcpl_ct_line_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|pmcpl_ct_line
modifier|*
name|ct1
decl_stmt|,
modifier|*
name|ct2
decl_stmt|;
name|ct1
operator|=
operator|(
specifier|const
expr|struct
name|pmcpl_ct_line
operator|*
operator|)
name|a
expr_stmt|;
name|ct2
operator|=
operator|(
specifier|const
expr|struct
name|pmcpl_ct_line
operator|*
operator|)
name|b
expr_stmt|;
comment|/* Sort in reverse order */
if|if
condition|(
name|ct1
operator|->
name|ln_sum
operator|<
name|ct2
operator|->
name|ln_sum
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ct1
operator|->
name|ln_sum
operator|>
name|ct2
operator|->
name|ln_sum
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format and display given PMC index.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_node_printtop
parameter_list|(
name|struct
name|pmcpl_ct_sample
modifier|*
name|rsamples
parameter_list|,
name|int
name|pmcin
parameter_list|,
name|int
name|maxy
parameter_list|)
block|{
undef|#
directive|undef
name|TS
undef|#
directive|undef
name|TSI
define|#
directive|define
name|TS
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(pmcpl_ct_topscreen[x][y])
define|#
directive|define
name|TSI
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(pmcpl_ct_topscreen[x][pmcpl_ct_topmax[y].ln_index])
name|int
name|v_attrs
decl_stmt|,
name|ns_len
decl_stmt|,
name|vs_len
decl_stmt|,
name|is_len
decl_stmt|,
name|width
decl_stmt|,
name|indentwidth
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|float
name|v
decl_stmt|;
name|char
name|ns
index|[
literal|30
index|]
decl_stmt|,
name|vs
index|[
literal|10
index|]
decl_stmt|,
name|is
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
decl_stmt|;
specifier|const
name|char
modifier|*
name|space
init|=
literal|" "
decl_stmt|;
comment|/* 	 * Sort by line cost. 	 */
for|for
control|(
name|y
operator|=
literal|0
init|;
condition|;
name|y
operator|++
control|)
block|{
name|ct
operator|=
name|TS
argument_list|(
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
break|break;
name|pmcpl_ct_topmax
index|[
name|y
index|]
operator|.
name|ln_sum
operator|=
literal|0
expr_stmt|;
name|pmcpl_ct_topmax
index|[
name|y
index|]
operator|.
name|ln_index
operator|=
name|y
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|TS
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
block|{
name|pmcpl_ct_topmax
index|[
name|y
index|]
operator|.
name|ln_sum
operator|+=
name|PMCPL_CT_SAMPLE
argument_list|(
name|pmcin
argument_list|,
operator|&
name|TS
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|->
name|pct_samples
argument_list|)
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|pmcpl_ct_topmax
argument_list|,
name|y
argument_list|,
sizeof|sizeof
argument_list|(
name|pmcpl_ct_topmax
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|pmcpl_ct_line_compare
argument_list|)
expr_stmt|;
name|pmcpl_ct_topmax
index|[
name|y
index|]
operator|.
name|ln_index
operator|=
name|y
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|maxy
condition|;
name|y
operator|++
control|)
block|{
name|ct
operator|=
name|TSI
argument_list|(
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|PMCSTAT_PRINTW
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Output sum. */
name|v
operator|=
name|pmcpl_ct_topmax
index|[
name|y
index|]
operator|.
name|ln_sum
operator|*
literal|100.0
operator|/
name|rsamples
operator|->
name|sb
index|[
name|pmcin
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|,
literal|"%.1f"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v_attrs
operator|=
name|PMCSTAT_ATTRPERCENT
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTRON
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"%5.5s "
argument_list|,
name|vs
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTROFF
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|width
operator|=
name|indentwidth
operator|=
literal|5
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
operator|(
name|ct
operator|=
name|TSI
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
block|{
name|vs
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vs_len
operator|=
literal|0
expr_stmt|;
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|is_len
operator|=
literal|0
expr_stmt|;
comment|/* Format value. */
name|v
operator|=
name|PMCPL_CT_SAMPLEP
argument_list|(
name|pmcin
argument_list|,
operator|&
name|ct
operator|->
name|pct_samples
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|pmcstat_threshold
condition|)
name|vs_len
operator|=
name|snprintf
argument_list|(
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|,
literal|"(%.1f%%)"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v_attrs
operator|=
name|PMCSTAT_ATTRPERCENT
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcstat_skiplink
operator|&&
name|v
operator|<=
name|pmcstat_threshold
condition|)
block|{
name|strlcpy
argument_list|(
name|ns
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|ns_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ct
operator|->
name|pct_sym
operator|!=
name|NULL
condition|)
block|{
name|ns_len
operator|=
name|snprintf
argument_list|(
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|ct
operator|->
name|pct_sym
operator|->
name|ps_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ns_len
operator|=
name|snprintf
argument_list|(
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|"%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ct
operator|->
name|pct_func
argument_list|)
expr_stmt|;
comment|/* Format image. */
if|if
condition|(
name|x
operator|==
literal|1
operator|||
name|TSI
argument_list|(
name|x
operator|-
literal|1
argument_list|,
name|y
argument_list|)
operator|->
name|pct_image
operator|!=
name|ct
operator|->
name|pct_image
condition|)
name|is_len
operator|=
name|snprintf
argument_list|(
name|is
argument_list|,
sizeof|sizeof
argument_list|(
name|is
argument_list|)
argument_list|,
literal|"@%s"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|ct
operator|->
name|pct_image
operator|->
name|pi_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for line wrap. */
name|width
operator|+=
name|ns_len
operator|+
name|is_len
operator|+
name|vs_len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>=
name|pmcstat_displaywidth
condition|)
block|{
name|maxy
operator|--
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|maxy
condition|)
break|break;
name|PMCSTAT_PRINTW
argument_list|(
literal|"\n%*s"
argument_list|,
name|indentwidth
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|width
operator|=
name|indentwidth
operator|+
name|ns_len
operator|+
name|is_len
operator|+
name|vs_len
expr_stmt|;
block|}
name|PMCSTAT_ATTRON
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"%s%s%s "
argument_list|,
name|ns
argument_list|,
name|is
argument_list|,
name|vs
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTROFF
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Output top mode snapshot.  */
end_comment

begin_function
name|void
name|pmcpl_ct_topdisplay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|y
decl_stmt|;
name|struct
name|pmcpl_ct_sample
name|r
decl_stmt|,
modifier|*
name|rsamples
decl_stmt|;
name|rsamples
operator|=
operator|&
name|r
expr_stmt|;
name|pmcpl_ct_samples_root
argument_list|(
name|rsamples
argument_list|)
expr_stmt|;
name|pmcpl_ct_node_cleartag
argument_list|()
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"%5.5s %s\n"
argument_list|,
literal|"%SAMP"
argument_list|,
literal|"CALLTREE"
argument_list|)
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pmcpl_ct_node_dumptop
argument_list|(
name|pmcstat_pmcinfilter
argument_list|,
name|pmcpl_ct_root
argument_list|,
name|rsamples
argument_list|,
literal|0
argument_list|,
operator|&
name|y
argument_list|)
condition|)
name|PMCSTAT_PRINTW
argument_list|(
literal|"...\n"
argument_list|)
expr_stmt|;
name|pmcpl_ct_topscreen
index|[
literal|1
index|]
index|[
name|y
index|]
operator|=
name|NULL
expr_stmt|;
name|pmcpl_ct_node_printtop
argument_list|(
name|rsamples
argument_list|,
name|pmcstat_pmcinfilter
argument_list|,
name|pmcstat_displayheight
operator|-
literal|2
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_free
argument_list|(
name|rsamples
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle top mode keypress.  */
end_comment

begin_function
name|int
name|pmcpl_ct_topkeypress
parameter_list|(
name|int
name|c
parameter_list|,
name|WINDOW
modifier|*
name|w
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|pmcstat_skiplink
operator|=
operator|!
name|pmcstat_skiplink
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"skip empty link %s"
argument_list|,
name|pmcstat_skiplink
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look for a callgraph node associated with pmc `pmcid' in the global  * hash table that corresponds to the given `pc' value in the process map  * `ppm'.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_node_update
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|parent
parameter_list|,
name|struct
name|pmcpl_ct_node
modifier|*
name|child
parameter_list|,
name|int
name|pmcin
parameter_list|,
name|unsigned
name|v
parameter_list|,
name|int
name|cd
parameter_list|)
block|{
name|struct
name|pmcpl_ct_arc
modifier|*
name|arc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find related arc in parent node and 	 * increment the sample count. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parent
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parent
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_child
operator|==
name|child
condition|)
block|{
name|arc
operator|=
operator|&
name|parent
operator|->
name|pct_arc
index|[
name|i
index|]
expr_stmt|;
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|arc
operator|->
name|pcta_samples
argument_list|)
expr_stmt|;
name|arc
operator|->
name|pcta_samples
operator|.
name|sb
index|[
name|pmcin
index|]
operator|+=
name|v
expr_stmt|;
comment|/* Estimate call count. */
if|if
condition|(
name|cd
condition|)
block|{
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|arc
operator|->
name|pcta_callid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcpl_ct_callid
operator|.
name|sb
index|[
name|pmcin
index|]
operator|-
name|arc
operator|->
name|pcta_callid
operator|.
name|sb
index|[
name|pmcin
index|]
operator|>
literal|1
condition|)
name|arc
operator|->
name|pcta_call
operator|++
expr_stmt|;
name|arc
operator|->
name|pcta_callid
operator|.
name|sb
index|[
name|pmcin
index|]
operator|=
name|pmcpl_ct_callid
operator|.
name|sb
index|[
name|pmcin
index|]
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* 	 * No arc found for us, add ourself to the parent. 	 */
name|pmcpl_ct_arc_grow
argument_list|(
name|parent
operator|->
name|pct_narc
argument_list|,
operator|&
name|parent
operator|->
name|pct_arc_c
argument_list|,
operator|&
name|parent
operator|->
name|pct_arc
argument_list|)
expr_stmt|;
name|arc
operator|=
operator|&
name|parent
operator|->
name|pct_arc
index|[
name|parent
operator|->
name|pct_narc
index|]
expr_stmt|;
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|arc
operator|->
name|pcta_samples
argument_list|)
expr_stmt|;
name|arc
operator|->
name|pcta_samples
operator|.
name|sb
index|[
name|pmcin
index|]
operator|=
name|v
expr_stmt|;
name|arc
operator|->
name|pcta_call
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cd
condition|)
block|{
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|arc
operator|->
name|pcta_callid
argument_list|)
expr_stmt|;
name|arc
operator|->
name|pcta_callid
operator|.
name|sb
index|[
name|pmcin
index|]
operator|=
name|pmcpl_ct_callid
operator|.
name|sb
index|[
name|pmcin
index|]
expr_stmt|;
block|}
name|arc
operator|->
name|pcta_child
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|pct_narc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup by image/pc.  */
end_comment

begin_function
specifier|static
name|struct
name|pmcpl_ct_node
modifier|*
name|pmcpl_ct_node_hash_lookup
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|pc
parameter_list|,
name|struct
name|pmcstat_symbol
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|fl
parameter_list|,
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
decl_stmt|;
name|struct
name|pmcpl_ct_node_hash
modifier|*
name|h
decl_stmt|;
name|pmcstat_interned_string
name|ifl
decl_stmt|,
name|ifn
decl_stmt|;
if|if
condition|(
name|fn
operator|!=
name|NULL
condition|)
block|{
name|ifl
operator|=
name|pmcstat_string_intern
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|ifn
operator|=
name|pmcstat_string_intern
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifl
operator|=
literal|0
expr_stmt|;
name|ifn
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|hash
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash
operator|+=
operator|(
name|pc
operator|>>
name|i
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|hash
operator|&=
name|PMCSTAT_HASH_MASK
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|h
argument_list|,
argument|&pmcpl_ct_node_hash[hash]
argument_list|,
argument|pch_next
argument_list|)
block|{
name|ct
operator|=
name|h
operator|->
name|pch_ctnode
expr_stmt|;
name|assert
argument_list|(
name|ct
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|pct_image
operator|==
name|image
operator|&&
name|ct
operator|->
name|pct_func
operator|==
name|pc
condition|)
block|{
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
operator|(
name|ct
operator|)
return|;
if|if
condition|(
name|ct
operator|->
name|pct_type
operator|==
name|PMCPL_PCT_NAME
operator|&&
name|ct
operator|->
name|pct_ifl
operator|==
name|ifl
operator|&&
name|ct
operator|->
name|pct_ifn
operator|==
name|ifn
condition|)
return|return
operator|(
name|ct
operator|)
return|;
block|}
block|}
comment|/* 	 * We haven't seen this (pmcid, pc) tuple yet, so allocate a 	 * new callgraph node and a new hash table entry for it. 	 */
name|ct
operator|=
name|pmcpl_ct_node_allocate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Could not allocate callgraph node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|!=
name|NULL
condition|)
block|{
name|ct
operator|->
name|pct_type
operator|=
name|PMCPL_PCT_NAME
expr_stmt|;
name|ct
operator|->
name|pct_ifl
operator|=
name|ifl
expr_stmt|;
name|ct
operator|->
name|pct_ifn
operator|=
name|ifn
expr_stmt|;
block|}
else|else
name|ct
operator|->
name|pct_type
operator|=
name|PMCPL_PCT_ADDR
expr_stmt|;
name|ct
operator|->
name|pct_image
operator|=
name|image
expr_stmt|;
name|ct
operator|->
name|pct_func
operator|=
name|pc
expr_stmt|;
name|ct
operator|->
name|pct_sym
operator|=
name|sym
expr_stmt|;
name|h
operator|->
name|pch_ctnode
operator|=
name|ct
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmcpl_ct_node_hash
index|[
name|hash
index|]
argument_list|,
name|h
argument_list|,
name|pch_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record a callchain.  */
end_comment

begin_function
name|void
name|pmcpl_ct_process
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcr
parameter_list|,
name|uint32_t
name|nsamples
parameter_list|,
name|uintfptr_t
modifier|*
name|cc
parameter_list|,
name|int
name|usermode
parameter_list|,
name|uint32_t
name|cpu
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|pmcin
decl_stmt|;
name|uintfptr_t
name|pc
decl_stmt|,
name|loadaddress
decl_stmt|;
name|struct
name|pmcstat_image
modifier|*
name|image
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pmcstat_pcmap
modifier|*
name|ppm
index|[
name|PMC_CALLCHAIN_DEPTH_MAX
index|]
decl_stmt|;
name|struct
name|pmcstat_process
modifier|*
name|km
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|ctl
index|[
name|PMC_CALLCHAIN_DEPTH_MAX
operator|+
literal|1
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|cpu
expr_stmt|;
name|assert
argument_list|(
name|nsamples
operator|>
literal|0
operator|&&
name|nsamples
operator|<=
name|PMC_CALLCHAIN_DEPTH_MAX
argument_list|)
expr_stmt|;
comment|/* Get the PMC index. */
name|pmcin
operator|=
name|pmcr
operator|->
name|pr_pmcin
expr_stmt|;
comment|/* 	 * Validate mapping for the callchain. 	 * Go from bottom to first invalid entry. 	 */
name|km
operator|=
name|pmcstat_kernproc
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|nsamples
condition|;
name|n
operator|++
control|)
block|{
name|ppm
index|[
name|n
index|]
operator|=
name|pmcstat_process_find_map
argument_list|(
name|usermode
condition|?
name|pp
else|:
name|km
argument_list|,
name|cc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppm
index|[
name|n
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Detect full frame capture (kernel + user). */
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
name|ppm
index|[
name|n
index|]
operator|=
name|pmcstat_process_find_map
argument_list|(
name|pp
argument_list|,
name|cc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppm
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|km
operator|=
name|pp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ppm
index|[
name|n
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|--
operator|==
literal|0
condition|)
block|{
name|pmcstat_stats
operator|.
name|ps_callchain_dubious_frames
operator|++
expr_stmt|;
name|pmcr
operator|->
name|pr_dubious_frames
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Increase the call generation counter. */
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|pmcpl_ct_callid
argument_list|)
expr_stmt|;
name|pmcpl_ct_callid
operator|.
name|sb
index|[
name|pmcin
index|]
operator|++
expr_stmt|;
comment|/* 	 * Build node list. 	 */
name|ctl
index|[
literal|0
index|]
operator|=
name|pmcpl_ct_root
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|image
operator|=
name|ppm
index|[
name|n
index|]
operator|->
name|ppm_image
expr_stmt|;
name|loadaddress
operator|=
name|ppm
index|[
name|n
index|]
operator|->
name|ppm_lowpc
operator|+
name|image
operator|->
name|pi_vaddr
operator|-
name|image
operator|->
name|pi_start
expr_stmt|;
comment|/* Convert to an offset in the image. */
name|pc
operator|=
name|cc
index|[
name|n
index|]
operator|-
name|loadaddress
expr_stmt|;
comment|/* 		 * Try determine the function at this offset.  If we can't 		 * find a function round leave the `pc' value alone. 		 */
if|if
condition|(
operator|(
name|sym
operator|=
name|pmcstat_symbol_search
argument_list|(
name|image
argument_list|,
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pc
operator|=
name|sym
operator|->
name|ps_start
expr_stmt|;
else|else
name|pmcstat_stats
operator|.
name|ps_samples_unknown_function
operator|++
expr_stmt|;
name|ct
operator|=
name|pmcpl_ct_node_hash_lookup
argument_list|(
name|image
argument_list|,
name|pc
argument_list|,
name|sym
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|NULL
condition|)
block|{
name|pmcstat_stats
operator|.
name|ps_callchain_dubious_frames
operator|++
expr_stmt|;
continue|continue;
block|}
name|ctl
index|[
name|i
operator|++
index|]
operator|=
name|ct
expr_stmt|;
block|}
comment|/* No valid node found. */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return;
name|n
operator|=
name|i
expr_stmt|;
name|ct
operator|=
name|ctl
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|pmcpl_ct_node_update
argument_list|(
name|ctl
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|ctl
index|[
name|i
index|]
argument_list|,
name|pmcin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Increment the sample count for this PMC. 	 */
name|pmcpl_ct_samples_grow
argument_list|(
operator|&
name|ctl
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|pct_samples
argument_list|)
expr_stmt|;
name|ctl
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|pct_samples
operator|.
name|sb
index|[
name|pmcin
index|]
operator|++
expr_stmt|;
comment|/* Update per instruction sample if required. */
if|if
condition|(
name|args
operator|.
name|pa_ctdumpinstr
condition|)
name|pmcpl_ct_instr_add
argument_list|(
name|ctl
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|pmcin
argument_list|,
name|cc
index|[
literal|0
index|]
operator|-
operator|(
name|ppm
index|[
literal|0
index|]
operator|->
name|ppm_lowpc
operator|+
name|ppm
index|[
literal|0
index|]
operator|->
name|ppm_image
operator|->
name|pi_vaddr
operator|-
name|ppm
index|[
literal|0
index|]
operator|->
name|ppm_image
operator|->
name|pi_start
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print node child cost.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_node_printchild
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|,
name|uintfptr_t
name|paddr
parameter_list|,
name|int
name|pline
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|line
decl_stmt|;
name|uintfptr_t
name|addr
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|child
decl_stmt|;
name|char
name|sourcefile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|funcname
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* 	 * Child cost. 	 * TODO: attach child cost to the real position in the funtion. 	 * TODO: cfn=<fn> / call<ncall> addr(<fn>) / addr(call<fn>)<arccost> 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_child
expr_stmt|;
comment|/* Object binary. */
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"cob=%s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|child
operator|->
name|pct_image
operator|->
name|pi_fullpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Child function name. */
name|addr
operator|=
name|child
operator|->
name|pct_image
operator|->
name|pi_vaddr
operator|+
name|child
operator|->
name|pct_func
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Child function source file. */
if|if
condition|(
name|child
operator|->
name|pct_type
operator|==
name|PMCPL_PCT_NAME
condition|)
block|{
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"cfi=%s\ncfn=%s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|child
operator|->
name|pct_ifl
argument_list|)
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|child
operator|->
name|pct_ifn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmcstat_image_addr2line
argument_list|(
name|child
operator|->
name|pct_image
argument_list|,
name|addr
argument_list|,
name|sourcefile
argument_list|,
sizeof|sizeof
argument_list|(
name|sourcefile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
name|funcname
argument_list|,
sizeof|sizeof
argument_list|(
name|funcname
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"cfi=%s\ncfn=%s\n"
argument_list|,
name|sourcefile
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|child
operator|->
name|pct_sym
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"cfi=???\ncfn=%s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|child
operator|->
name|pct_sym
operator|->
name|ps_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"cfi=???\ncfn=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Child function address, line and call count. */
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"calls=%u %p %u\n"
argument_list|,
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_call
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 		 * Call address, line, sample. 		 * TODO: Associate call address to the right location. 		 */
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%p %u"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|paddr
argument_list|,
name|pline
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pmcstat_npmcs
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" %u"
argument_list|,
name|PMCPL_CT_SAMPLE
argument_list|(
name|j
argument_list|,
operator|&
name|ct
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_samples
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print node self cost.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_node_printself
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|fline
decl_stmt|,
name|line
decl_stmt|;
name|uintfptr_t
name|faddr
decl_stmt|,
name|addr
decl_stmt|;
name|char
name|sourcefile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|funcname
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* 	 * Object binary. 	 */
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"ob=%s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|ct
operator|->
name|pct_image
operator|->
name|pi_fullpath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Function name. 	 */
name|faddr
operator|=
name|ct
operator|->
name|pct_image
operator|->
name|pi_vaddr
operator|+
name|ct
operator|->
name|pct_func
expr_stmt|;
name|fline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|pct_type
operator|==
name|PMCPL_PCT_NAME
condition|)
block|{
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"fl=%s\nfn=%s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|ct
operator|->
name|pct_ifl
argument_list|)
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|ct
operator|->
name|pct_ifn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmcstat_image_addr2line
argument_list|(
name|ct
operator|->
name|pct_image
argument_list|,
name|faddr
argument_list|,
name|sourcefile
argument_list|,
sizeof|sizeof
argument_list|(
name|sourcefile
argument_list|)
argument_list|,
operator|&
name|fline
argument_list|,
name|funcname
argument_list|,
sizeof|sizeof
argument_list|(
name|funcname
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"fl=%s\nfn=%s\n"
argument_list|,
name|sourcefile
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ct
operator|->
name|pct_sym
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"fl=???\nfn=%s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|ct
operator|->
name|pct_sym
operator|->
name|ps_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"fl=???\nfn=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|ct
operator|->
name|pct_image
operator|->
name|pi_vaddr
operator|+
name|ct
operator|->
name|pct_func
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Self cost. 	 */
if|if
condition|(
name|ct
operator|->
name|pct_ninstr
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Per location cost. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_ninstr
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|ct
operator|->
name|pct_image
operator|->
name|pi_vaddr
operator|+
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_func
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
name|pmcstat_image_addr2line
argument_list|(
name|ct
operator|->
name|pct_image
argument_list|,
name|addr
argument_list|,
name|sourcefile
argument_list|,
sizeof|sizeof
argument_list|(
name|sourcefile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
name|funcname
argument_list|,
sizeof|sizeof
argument_list|(
name|funcname
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%p %u"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pmcstat_npmcs
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" %u"
argument_list|,
name|PMCPL_CT_SAMPLE
argument_list|(
name|j
argument_list|,
operator|&
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_samples
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Global cost function cost. */
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%p %u"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|faddr
argument_list|,
name|fline
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmcstat_npmcs
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" %u"
argument_list|,
name|PMCPL_CT_SAMPLE
argument_list|(
name|i
argument_list|,
operator|&
name|ct
operator|->
name|pct_samples
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|pmcpl_ct_node_printchild
argument_list|(
name|ct
argument_list|,
name|faddr
argument_list|,
name|fline
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmcpl_ct_printnode
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ct
operator|==
name|pmcpl_ct_root
condition|)
block|{
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"fn=root\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"0x0 1"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmcstat_npmcs
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" 0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|pmcpl_ct_node_printchild
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|pmcpl_ct_node_printself
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Breadth first traversal.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_bfs
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pmcpl_ct_node_hash
modifier|*
name|pch
decl_stmt|,
modifier|*
name|pchc
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|child
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|pmcpl_ct_node_hash
argument_list|)
name|q
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pch
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pch
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot allocate queue"
argument_list|)
expr_stmt|;
name|pch
operator|->
name|pch_ctnode
operator|=
name|ct
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|q
argument_list|,
name|pch
argument_list|,
name|pch_next
argument_list|)
expr_stmt|;
name|ct
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_BLACK
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|q
argument_list|)
condition|)
block|{
name|pch
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|q
argument_list|,
name|pch_next
argument_list|)
expr_stmt|;
name|pmcpl_ct_printnode
argument_list|(
name|pch
operator|->
name|pch_ctnode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pch
operator|->
name|pch_ctnode
operator|->
name|pct_narc
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|pch
operator|->
name|pch_ctnode
operator|->
name|pct_arc
index|[
name|i
index|]
operator|.
name|pcta_child
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|pct_color
operator|==
name|PMCPL_PCT_WHITE
condition|)
block|{
name|child
operator|->
name|pct_color
operator|=
name|PMCPL_PCT_BLACK
expr_stmt|;
if|if
condition|(
operator|(
name|pchc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pchc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot allocate queue"
argument_list|)
expr_stmt|;
name|pchc
operator|->
name|pch_ctnode
operator|=
name|child
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|q
argument_list|,
name|pchc
argument_list|,
name|pch_next
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Detect and fix inlined location.  */
end_comment

begin_function
specifier|static
name|void
name|_pmcpl_ct_expand_inline
parameter_list|(
name|struct
name|pmcpl_ct_node
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|fline
decl_stmt|,
name|line
decl_stmt|,
name|v
decl_stmt|;
name|uintfptr_t
name|faddr
decl_stmt|,
name|addr
decl_stmt|,
name|pc
decl_stmt|;
name|char
name|sourcefile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|ffuncname
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|funcname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|buffer
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|pmcpl_ct_node
modifier|*
name|child
decl_stmt|;
comment|/* 	 * Child cost. 	 * TODO: attach child cost to the real position in the funtion. 	 * TODO: cfn=<fn> / call<ncall> addr(<fn>) / addr(call<fn>)<arccost> 	 * Resolve parent and compare to each instr location. 	 */
name|faddr
operator|=
name|ct
operator|->
name|pct_image
operator|->
name|pi_vaddr
operator|+
name|ct
operator|->
name|pct_func
expr_stmt|;
name|fline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pmcstat_image_addr2line
argument_list|(
name|ct
operator|->
name|pct_image
argument_list|,
name|faddr
argument_list|,
name|sourcefile
argument_list|,
sizeof|sizeof
argument_list|(
name|sourcefile
argument_list|)
argument_list|,
operator|&
name|fline
argument_list|,
name|ffuncname
argument_list|,
sizeof|sizeof
argument_list|(
name|ffuncname
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ct
operator|->
name|pct_ninstr
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|ct
operator|->
name|pct_image
operator|->
name|pi_vaddr
operator|+
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_func
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pmcstat_image_addr2line
argument_list|(
name|ct
operator|->
name|pct_image
argument_list|,
name|addr
argument_list|,
name|sourcefile
argument_list|,
sizeof|sizeof
argument_list|(
name|sourcefile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
name|funcname
argument_list|,
sizeof|sizeof
argument_list|(
name|funcname
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|funcname
argument_list|,
name|ffuncname
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * - Lookup/create inline node by function name. 		 * - Move instr PMCs to the inline node. 		 * - Link nodes. 		 * The lookup create a specific node per image/pc. 		 */
if|if
condition|(
name|args
operator|.
name|pa_verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_printfile
argument_list|,
literal|"WARNING: inlined function at %p %s in %s\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|funcname
argument_list|,
name|ffuncname
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|funcname
argument_list|,
name|ffuncname
argument_list|)
expr_stmt|;
name|child
operator|=
name|pmcpl_ct_node_hash_lookup
argument_list|(
name|ct
operator|->
name|pct_image
argument_list|,
name|ct
operator|->
name|pct_func
argument_list|,
name|ct
operator|->
name|pct_sym
argument_list|,
name|sourcefile
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pc
operator|=
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_func
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pmcstat_npmcs
condition|;
name|j
operator|++
control|)
block|{
name|v
operator|=
name|PMCPL_CT_SAMPLE
argument_list|(
name|j
argument_list|,
operator|&
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_samples
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
continue|continue;
name|pmcpl_ct_instr_add
argument_list|(
name|child
argument_list|,
name|j
argument_list|,
name|pc
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|pmcpl_ct_node_update
argument_list|(
name|ct
argument_list|,
name|child
argument_list|,
name|j
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|ct
operator|->
name|pct_samples
operator|.
name|npmcs
condition|)
name|ct
operator|->
name|pct_samples
operator|.
name|sb
index|[
name|j
index|]
operator|-=
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_samples
operator|.
name|sb
index|[
name|j
index|]
expr_stmt|;
name|ct
operator|->
name|pct_instr
index|[
name|i
index|]
operator|.
name|pctf_samples
operator|.
name|sb
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pmcpl_ct_expand_inline
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pmcpl_ct_node_hash
modifier|*
name|pch
decl_stmt|;
if|if
condition|(
operator|!
name|args
operator|.
name|pa_ctdumpinstr
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMCSTAT_NHASH
condition|;
name|i
operator|++
control|)
name|STAILQ_FOREACH
argument_list|(
argument|pch
argument_list|,
argument|&pmcpl_ct_node_hash[i]
argument_list|,
argument|pch_next
argument_list|)
if|if
condition|(
name|pch
operator|->
name|pch_ctnode
operator|->
name|pct_type
operator|==
name|PMCPL_PCT_ADDR
condition|)
name|_pmcpl_ct_expand_inline
argument_list|(
name|pch
operator|->
name|pch_ctnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean the PMC name for Kcachegrind formula  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_fixup_pmcname
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a calltree (KCachegrind) for all PMCs.  */
end_comment

begin_function
specifier|static
name|void
name|pmcpl_ct_print
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|name
index|[
literal|40
index|]
decl_stmt|;
name|struct
name|pmcpl_ct_sample
name|rsamples
decl_stmt|;
name|pmcpl_ct_samples_root
argument_list|(
operator|&
name|rsamples
argument_list|)
expr_stmt|;
name|pmcpl_ct_expand_inline
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"version: 1\n"
literal|"creator: pmcstat\n"
literal|"positions: instr line\n"
literal|"events:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmcstat_npmcs
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s_%d"
argument_list|,
name|pmcstat_pmcindex_to_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pmcpl_ct_fixup_pmcname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\nsummary:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pmcstat_npmcs
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" %u"
argument_list|,
name|PMCPL_CT_SAMPLE
argument_list|(
name|i
argument_list|,
operator|&
name|rsamples
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|pmcpl_ct_bfs
argument_list|(
name|pmcpl_ct_root
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_free
argument_list|(
operator|&
name|rsamples
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmcpl_ct_configure
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opt
argument_list|,
literal|"skiplink="
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pmcstat_skiplink
operator|=
name|atoi
argument_list|(
name|opt
operator|+
literal|9
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmcpl_ct_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pmcpl_ct_root
operator|=
name|pmcpl_ct_node_allocate
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMCSTAT_NHASH
condition|;
name|i
operator|++
control|)
name|STAILQ_INIT
argument_list|(
operator|&
name|pmcpl_ct_node_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pmcpl_ct_samples_init
argument_list|(
operator|&
name|pmcpl_ct_callid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmcpl_ct_shutdown
parameter_list|(
name|FILE
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pmcpl_ct_node_hash
modifier|*
name|pch
decl_stmt|,
modifier|*
name|pchtmp
decl_stmt|;
operator|(
name|void
operator|)
name|mf
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|pa_flags
operator|&
name|FLAG_DO_CALLGRAPHS
condition|)
name|pmcpl_ct_print
argument_list|()
expr_stmt|;
comment|/* 	 * Free memory. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMCSTAT_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|pch
argument_list|,
argument|&pmcpl_ct_node_hash[i]
argument_list|,
argument|pch_next
argument_list|,
argument|pchtmp
argument_list|)
block|{
name|pmcpl_ct_node_free
argument_list|(
name|pch
operator|->
name|pch_ctnode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pch
argument_list|)
expr_stmt|;
block|}
block|}
name|pmcpl_ct_node_free
argument_list|(
name|pmcpl_ct_root
argument_list|)
expr_stmt|;
name|pmcpl_ct_root
operator|=
name|NULL
expr_stmt|;
name|pmcpl_ct_samples_free
argument_list|(
operator|&
name|pmcpl_ct_callid
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

