begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2007, Joseph Koshy  * Copyright (c) 2007 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by A. Joseph Koshy under  * sponsorship from the FreeBSD Foundation and Google, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Transform a hwpmc(4) log into human readable form, and into  * gprof(1) compatible profiles.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pmc.h>
end_include

begin_include
include|#
directive|include
file|<pmclog.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pmcstat.h"
end_include

begin_include
include|#
directive|include
file|"pmcstat_log.h"
end_include

begin_include
include|#
directive|include
file|"pmcstat_top.h"
end_include

begin_comment
comment|/*  * PUBLIC INTERFACES  *  * pmcstat_initialize_logging()	initialize this module, called first  * pmcstat_shutdown_logging()		orderly shutdown, called last  * pmcstat_open_log()			open an eventlog for processing  * pmcstat_process_log()		print/convert an event log  * pmcstat_display_log()		top mode display for the log  * pmcstat_close_log()			finish processing an event log  *  * IMPLEMENTATION NOTES  *  * We correlate each 'callchain' or 'sample' entry seen in the event  * log back to an executable object in the system. Executable objects  * include:  * 	- program executables,  *	- shared libraries loaded by the runtime loader,  *	- dlopen()'ed objects loaded by the program,  *	- the runtime loader itself,  *	- the kernel and kernel modules.  *  * Each process that we know about is treated as a set of regions that  * map to executable objects.  Processes are described by  * 'pmcstat_process' structures.  Executable objects are tracked by  * 'pmcstat_image' structures.  The kernel and kernel modules are  * common to all processes (they reside at the same virtual addresses  * for all processes).  Individual processes can have their text  * segments and shared libraries loaded at process-specific locations.  *  * A given executable object can be in use by multiple processes  * (e.g., libc.so) and loaded at a different address in each.  * pmcstat_pcmap structures track per-image mappings.  *  * The sample log could have samples from multiple PMCs; we  * generate one 'gmon.out' profile per PMC.  *  * IMPLEMENTATION OF GMON OUTPUT  *  * Each executable object gets one 'gmon.out' profile, per PMC in  * use.  Creation of 'gmon.out' profiles is done lazily.  The  * 'gmon.out' profiles generated for a given sampling PMC are  * aggregates of all the samples for that particular executable  * object.  *  * IMPLEMENTATION OF SYSTEM-WIDE CALLGRAPH OUTPUT  *  * Each active pmcid has its own callgraph structure, described by a  * 'struct pmcstat_callgraph'.  Given a process id and a list of pc  * values, we map each pc value to a tuple (image, symbol), where  * 'image' denotes an executable object and 'symbol' is the closest  * symbol that precedes the pc value.  Each pc value in the list is  * also given a 'rank' that reflects its depth in the call stack.  */
end_comment

begin_decl_stmt
name|struct
name|pmcstat_pmcs
name|pmcstat_pmcs
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|pmcstat_pmcs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All image descriptors are kept in a hash table.  */
end_comment

begin_decl_stmt
name|struct
name|pmcstat_image_hash_list
name|pmcstat_image_hash
index|[
name|PMCSTAT_NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All process descriptors are kept in a hash table.  */
end_comment

begin_decl_stmt
name|struct
name|pmcstat_process_hash_list
name|pmcstat_process_hash
index|[
name|PMCSTAT_NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmcstat_stats
name|pmcstat_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ps_samples_period
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* samples count between top refresh. */
end_comment

begin_decl_stmt
name|struct
name|pmcstat_process
modifier|*
name|pmcstat_kernproc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kernel 'process' */
end_comment

begin_include
include|#
directive|include
file|"pmcpl_gprof.h"
end_include

begin_include
include|#
directive|include
file|"pmcpl_callgraph.h"
end_include

begin_include
include|#
directive|include
file|"pmcpl_annotate.h"
end_include

begin_include
include|#
directive|include
file|"pmcpl_annotate_cg.h"
end_include

begin_include
include|#
directive|include
file|"pmcpl_calltree.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|pmc_plugins
name|plugins
index|[]
init|=
block|{
block|{
operator|.
name|pl_name
operator|=
literal|"none"
block|, 	}
block|,
block|{
operator|.
name|pl_name
operator|=
literal|"callgraph"
block|,
operator|.
name|pl_init
operator|=
name|pmcpl_cg_init
block|,
operator|.
name|pl_shutdown
operator|=
name|pmcpl_cg_shutdown
block|,
operator|.
name|pl_process
operator|=
name|pmcpl_cg_process
block|,
operator|.
name|pl_topkeypress
operator|=
name|pmcpl_cg_topkeypress
block|,
operator|.
name|pl_topdisplay
operator|=
name|pmcpl_cg_topdisplay
block|}
block|,
block|{
operator|.
name|pl_name
operator|=
literal|"gprof"
block|,
operator|.
name|pl_shutdown
operator|=
name|pmcpl_gmon_shutdown
block|,
operator|.
name|pl_process
operator|=
name|pmcpl_gmon_process
block|,
operator|.
name|pl_initimage
operator|=
name|pmcpl_gmon_initimage
block|,
operator|.
name|pl_shutdownimage
operator|=
name|pmcpl_gmon_shutdownimage
block|,
operator|.
name|pl_newpmc
operator|=
name|pmcpl_gmon_newpmc
block|}
block|,
block|{
operator|.
name|pl_name
operator|=
literal|"annotate"
block|,
operator|.
name|pl_process
operator|=
name|pmcpl_annotate_process
block|}
block|,
block|{
operator|.
name|pl_name
operator|=
literal|"calltree"
block|,
operator|.
name|pl_configure
operator|=
name|pmcpl_ct_configure
block|,
operator|.
name|pl_init
operator|=
name|pmcpl_ct_init
block|,
operator|.
name|pl_shutdown
operator|=
name|pmcpl_ct_shutdown
block|,
operator|.
name|pl_process
operator|=
name|pmcpl_ct_process
block|,
operator|.
name|pl_topkeypress
operator|=
name|pmcpl_ct_topkeypress
block|,
operator|.
name|pl_topdisplay
operator|=
name|pmcpl_ct_topdisplay
block|}
block|,
block|{
operator|.
name|pl_name
operator|=
literal|"annotate_cg"
block|,
operator|.
name|pl_process
operator|=
name|pmcpl_annotate_cg_process
block|}
block|,
block|{
operator|.
name|pl_name
operator|=
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmcstat_mergepmc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmcstat_pmcinfilter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PMC filter for top mode. */
end_comment

begin_decl_stmt
name|float
name|pmcstat_threshold
init|=
literal|0.5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost filter for top mode. */
end_comment

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|pmcstat_stats_reset
parameter_list|(
name|int
name|_reset_global
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * PMC count.  */
end_comment

begin_decl_stmt
name|int
name|pmcstat_npmcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PMC Top mode pause state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmcstat_pause
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pmcstat_stats_reset
parameter_list|(
name|int
name|reset_global
parameter_list|)
block|{
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pr
decl_stmt|;
comment|/* Flush PMCs stats. */
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&pmcstat_pmcs
argument_list|,
argument|pr_next
argument_list|)
block|{
name|pr
operator|->
name|pr_samples
operator|=
literal|0
expr_stmt|;
name|pr
operator|->
name|pr_dubious_frames
operator|=
literal|0
expr_stmt|;
block|}
name|ps_samples_period
operator|=
literal|0
expr_stmt|;
comment|/* Flush global stats. */
if|if
condition|(
name|reset_global
condition|)
name|bzero
argument_list|(
operator|&
name|pmcstat_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resolve file name and line number for the given address.  */
end_comment

begin_function
name|int
name|pmcstat_image_addr2line
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|addr
parameter_list|,
name|char
modifier|*
name|sourcefile
parameter_list|,
name|size_t
name|sourcefile_len
parameter_list|,
name|unsigned
modifier|*
name|sourceline
parameter_list|,
name|char
modifier|*
name|funcname
parameter_list|,
name|size_t
name|funcname_len
parameter_list|)
block|{
specifier|static
name|int
name|addr2line_warn
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|,
name|cmdline
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|imagepath
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|pi_addr2line
operator|==
name|NULL
condition|)
block|{
comment|/* Try default debug file location. */
name|snprintf
argument_list|(
name|imagepath
argument_list|,
sizeof|sizeof
argument_list|(
name|imagepath
argument_list|)
argument_list|,
literal|"/usr/lib/debug/%s%s.debug"
argument_list|,
name|args
operator|.
name|pa_fsroot
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_fullpath
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|imagepath
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* Old kernel symbol path. */
name|snprintf
argument_list|(
name|imagepath
argument_list|,
sizeof|sizeof
argument_list|(
name|imagepath
argument_list|)
argument_list|,
literal|"%s%s.symbols"
argument_list|,
name|args
operator|.
name|pa_fsroot
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_fullpath
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|imagepath
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|imagepath
argument_list|,
sizeof|sizeof
argument_list|(
name|imagepath
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|args
operator|.
name|pa_fsroot
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_fullpath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 		 * New addr2line support recursive inline function with -i 		 * but the format does not add a marker when no more entries 		 * are available. 		 */
name|snprintf
argument_list|(
name|cmdline
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdline
argument_list|)
argument_list|,
literal|"addr2line -Cfe \"%s\""
argument_list|,
name|imagepath
argument_list|)
expr_stmt|;
name|image
operator|->
name|pi_addr2line
operator|=
name|popen
argument_list|(
name|cmdline
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|pi_addr2line
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|addr2line_warn
condition|)
block|{
name|addr2line_warn
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"WARNING: addr2line is needed for source code information."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|feof
argument_list|(
name|image
operator|->
name|pi_addr2line
argument_list|)
operator|||
name|ferror
argument_list|(
name|image
operator|->
name|pi_addr2line
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: addr2line pipe error"
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|image
operator|->
name|pi_addr2line
argument_list|)
expr_stmt|;
name|image
operator|->
name|pi_addr2line
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|image
operator|->
name|pi_addr2line
argument_list|,
literal|"%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|funcname
argument_list|,
name|funcname_len
argument_list|,
name|image
operator|->
name|pi_addr2line
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: addr2line function name read error"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sep
operator|=
name|strchr
argument_list|(
name|funcname
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
name|NULL
condition|)
operator|*
name|sep
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|sourcefile
argument_list|,
name|sourcefile_len
argument_list|,
name|image
operator|->
name|pi_addr2line
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: addr2line source file read error"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sep
operator|=
name|strchr
argument_list|(
name|sourcefile
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: addr2line source line separator missing"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|sep
operator|=
literal|'\0'
expr_stmt|;
name|l
operator|=
name|atoi
argument_list|(
name|sep
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|sourceline
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a pmcid in use, find its human-readable name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pmcstat_pmcid_to_name
parameter_list|(
name|pmc_id_t
name|pmcid
parameter_list|)
block|{
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&pmcstat_pmcs
argument_list|,
argument|pr_next
argument_list|)
if|if
condition|(
name|pr
operator|->
name|pr_pmcid
operator|==
name|pmcid
condition|)
return|return
operator|(
name|pmcstat_string_unintern
argument_list|(
name|pr
operator|->
name|pr_pmcname
argument_list|)
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Convert PMC index to name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pmcstat_pmcindex_to_name
parameter_list|(
name|int
name|pmcin
parameter_list|)
block|{
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&pmcstat_pmcs
argument_list|,
argument|pr_next
argument_list|)
if|if
condition|(
name|pr
operator|->
name|pr_pmcin
operator|==
name|pmcin
condition|)
return|return
name|pmcstat_string_unintern
argument_list|(
name|pr
operator|->
name|pr_pmcname
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Return PMC record with given index.  */
end_comment

begin_function
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcstat_pmcindex_to_pmcr
parameter_list|(
name|int
name|pmcin
parameter_list|)
block|{
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&pmcstat_pmcs
argument_list|,
argument|pr_next
argument_list|)
if|if
condition|(
name|pr
operator|->
name|pr_pmcin
operator|==
name|pmcin
condition|)
return|return
name|pr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Print log entries as text.  */
end_comment

begin_function
specifier|static
name|int
name|pmcstat_print_log
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pmclog_ev
name|ev
decl_stmt|;
name|uint32_t
name|npc
decl_stmt|;
while|while
condition|(
name|pmclog_read
argument_list|(
name|args
operator|.
name|pa_logparser
argument_list|,
operator|&
name|ev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|ev
operator|.
name|pl_state
operator|==
name|PMCLOG_OK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|.
name|pl_type
condition|)
block|{
case|case
name|PMCLOG_TYPE_CALLCHAIN
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"callchain"
argument_list|,
literal|"%d 0x%x %d %d %c"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|pl_pid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|pl_pmcid
argument_list|,
name|PMC_CALLCHAIN_CPUFLAGS_TO_CPU
argument_list|(
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|\
name|pl_cpuflags
argument_list|)
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|pl_npc
argument_list|,
name|PMC_CALLCHAIN_CPUFLAGS_TO_USERMODE
argument_list|(
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|\
name|pl_cpuflags
argument_list|)
condition|?
literal|'u'
else|:
literal|'s'
argument_list|)
expr_stmt|;
for|for
control|(
name|npc
operator|=
literal|0
init|;
name|npc
operator|<
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|pl_npc
condition|;
name|npc
operator|++
control|)
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"..."
argument_list|,
literal|"%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ev
operator|.
name|pl_u
operator|.
name|pl_cc
operator|.
name|pl_pc
index|[
name|npc
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_CLOSELOG
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"closelog"
argument_list|,)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_DROPNOTIFY
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"drop"
argument_list|,)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_INITIALIZE
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"initlog"
argument_list|,
literal|"0x%x \"%s\""
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_i
operator|.
name|pl_version
argument_list|,
name|pmc_name_of_cputype
argument_list|(
name|ev
operator|.
name|pl_u
operator|.
name|pl_i
operator|.
name|pl_arch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ev
operator|.
name|pl_u
operator|.
name|pl_i
operator|.
name|pl_version
operator|&
literal|0xFF000000
operator|)
operator|!=
name|PMC_VERSION_MAJOR
operator|<<
literal|24
operator|&&
name|args
operator|.
name|pa_verbosity
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: Log version 0x%x != expected version 0x%x."
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_i
operator|.
name|pl_version
argument_list|,
name|PMC_VERSION
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_MAP_IN
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"map-in"
argument_list|,
literal|"%d %p \"%s\""
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_mi
operator|.
name|pl_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ev
operator|.
name|pl_u
operator|.
name|pl_mi
operator|.
name|pl_start
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_mi
operator|.
name|pl_pathname
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_MAP_OUT
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"map-out"
argument_list|,
literal|"%d %p %p"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_mo
operator|.
name|pl_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ev
operator|.
name|pl_u
operator|.
name|pl_mo
operator|.
name|pl_start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ev
operator|.
name|pl_u
operator|.
name|pl_mo
operator|.
name|pl_end
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PCSAMPLE
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"sample"
argument_list|,
literal|"0x%x %d %p %c"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_s
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_s
operator|.
name|pl_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ev
operator|.
name|pl_u
operator|.
name|pl_s
operator|.
name|pl_pc
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_s
operator|.
name|pl_usermode
condition|?
literal|'u'
else|:
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PMCALLOCATE
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"allocate"
argument_list|,
literal|"0x%x \"%s\" 0x%x"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_a
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_a
operator|.
name|pl_evname
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_a
operator|.
name|pl_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PMCALLOCATEDYN
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"allocatedyn"
argument_list|,
literal|"0x%x \"%s\" 0x%x"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_ad
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_ad
operator|.
name|pl_evname
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_ad
operator|.
name|pl_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PMCATTACH
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"attach"
argument_list|,
literal|"0x%x %d \"%s\""
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_t
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_t
operator|.
name|pl_pid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_t
operator|.
name|pl_pathname
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PMCDETACH
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"detach"
argument_list|,
literal|"0x%x %d"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_d
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_d
operator|.
name|pl_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PROCCSW
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"cswval"
argument_list|,
literal|"0x%x %d %jd"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_c
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_c
operator|.
name|pl_pid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_c
operator|.
name|pl_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PROCEXEC
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"exec"
argument_list|,
literal|"0x%x %d %p \"%s\""
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_x
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_x
operator|.
name|pl_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ev
operator|.
name|pl_u
operator|.
name|pl_x
operator|.
name|pl_entryaddr
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_x
operator|.
name|pl_pathname
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PROCEXIT
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"exitval"
argument_list|,
literal|"0x%x %d %jd"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_e
operator|.
name|pl_pmcid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_e
operator|.
name|pl_pid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_e
operator|.
name|pl_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_PROCFORK
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"fork"
argument_list|,
literal|"%d %d"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_f
operator|.
name|pl_oldpid
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_f
operator|.
name|pl_newpid
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_USERDATA
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"userdata"
argument_list|,
literal|"0x%x"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_u
operator|.
name|pl_userdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCLOG_TYPE_SYSEXIT
case|:
name|PMCSTAT_PRINT_ENTRY
argument_list|(
literal|"exit"
argument_list|,
literal|"%d"
argument_list|,
name|ev
operator|.
name|pl_u
operator|.
name|pl_se
operator|.
name|pl_pid
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|args
operator|.
name|pa_printfile
argument_list|,
literal|"unknown event (type %d).\n"
argument_list|,
name|ev
operator|.
name|pl_type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ev
operator|.
name|pl_state
operator|==
name|PMCLOG_EOF
condition|)
return|return
operator|(
name|PMCSTAT_FINISHED
operator|)
return|;
elseif|else
if|if
condition|(
name|ev
operator|.
name|pl_state
operator|==
name|PMCLOG_REQUIRE_DATA
condition|)
return|return
operator|(
name|PMCSTAT_RUNNING
operator|)
return|;
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"ERROR: event parsing failed (record %jd, offset 0x%jx)."
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ev
operator|.
name|pl_count
operator|+
literal|1
argument_list|,
name|ev
operator|.
name|pl_offset
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * Public Interfaces.  */
end_comment

begin_comment
comment|/*  * Process a log file in offline analysis mode.  */
end_comment

begin_function
name|int
name|pmcstat_process_log
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * If analysis has not been asked for, just print the log to 	 * the current output file. 	 */
if|if
condition|(
name|args
operator|.
name|pa_flags
operator|&
name|FLAG_DO_PRINT
condition|)
return|return
operator|(
name|pmcstat_print_log
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|pmcstat_analyze_log
argument_list|(
operator|&
name|args
argument_list|,
name|plugins
argument_list|,
operator|&
name|pmcstat_stats
argument_list|,
name|pmcstat_kernproc
argument_list|,
name|pmcstat_mergepmc
argument_list|,
operator|&
name|pmcstat_npmcs
argument_list|,
operator|&
name|ps_samples_period
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Refresh top display.  */
end_comment

begin_function
specifier|static
name|void
name|pmcstat_refresh_top
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|v_attrs
decl_stmt|;
name|float
name|v
decl_stmt|;
name|char
name|pmcname
index|[
literal|40
index|]
decl_stmt|;
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcpr
decl_stmt|;
comment|/* If in pause mode do not refresh display. */
if|if
condition|(
name|pmcstat_pause
condition|)
return|return;
comment|/* Wait until PMC pop in the log. */
name|pmcpr
operator|=
name|pmcstat_pmcindex_to_pmcr
argument_list|(
name|pmcstat_pmcinfilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcpr
operator|==
name|NULL
condition|)
return|return;
comment|/* Format PMC name. */
if|if
condition|(
name|pmcstat_mergepmc
condition|)
name|snprintf
argument_list|(
name|pmcname
argument_list|,
sizeof|sizeof
argument_list|(
name|pmcname
argument_list|)
argument_list|,
literal|"[%s]"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|pmcpr
operator|->
name|pr_pmcname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|pmcname
argument_list|,
sizeof|sizeof
argument_list|(
name|pmcname
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|pmcpr
operator|->
name|pr_pmcname
argument_list|)
argument_list|,
name|pmcstat_pmcinfilter
argument_list|)
expr_stmt|;
comment|/* Format samples count. */
if|if
condition|(
name|ps_samples_period
operator|>
literal|0
condition|)
name|v
operator|=
operator|(
name|pmcpr
operator|->
name|pr_samples
operator|*
literal|100.0
operator|)
operator|/
name|ps_samples_period
expr_stmt|;
else|else
name|v
operator|=
literal|0.
expr_stmt|;
name|v_attrs
operator|=
name|PMCSTAT_ATTRPERCENT
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTBEGIN
argument_list|()
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"PMC: %s Samples: %u "
argument_list|,
name|pmcname
argument_list|,
name|pmcpr
operator|->
name|pr_samples
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTRON
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"(%.1f%%) "
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTROFF
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|", %u unresolved\n\n"
argument_list|,
name|pmcpr
operator|->
name|pr_dubious_frames
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_topdisplay
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_topdisplay
argument_list|()
expr_stmt|;
name|PMCSTAT_PRINTEND
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the next pmc index to display.  */
end_comment

begin_function
specifier|static
name|void
name|pmcstat_changefilter
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pmcin
decl_stmt|;
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcr
decl_stmt|;
comment|/* 	 * Find the next merge target. 	 */
if|if
condition|(
name|pmcstat_mergepmc
condition|)
block|{
name|pmcin
operator|=
name|pmcstat_pmcinfilter
expr_stmt|;
do|do
block|{
name|pmcr
operator|=
name|pmcstat_pmcindex_to_pmcr
argument_list|(
name|pmcstat_pmcinfilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcr
operator|==
name|NULL
operator|||
name|pmcr
operator|==
name|pmcr
operator|->
name|pr_merge
condition|)
break|break;
name|pmcstat_pmcinfilter
operator|++
expr_stmt|;
if|if
condition|(
name|pmcstat_pmcinfilter
operator|>=
name|pmcstat_npmcs
condition|)
name|pmcstat_pmcinfilter
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|pmcstat_pmcinfilter
operator|!=
name|pmcin
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*  * Top mode keypress.  */
end_comment

begin_function
name|int
name|pmcstat_keypress_log
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|newwin
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|wgetch
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"Key: %c => "
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"enter mode 'd' or 'a' => "
argument_list|)
expr_stmt|;
name|c
operator|=
name|wgetch
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|args
operator|.
name|pa_topmode
operator|=
name|PMCSTAT_TOP_DELTA
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"switching to delta mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|.
name|pa_topmode
operator|=
name|PMCSTAT_TOP_ACCUM
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"switching to accumulation mode"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
name|pmcstat_mergepmc
operator|=
operator|!
name|pmcstat_mergepmc
expr_stmt|;
comment|/* 		 * Changing merge state require data reset. 		 */
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_shutdown
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_shutdown
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|pmcstat_stats_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_init
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_init
argument_list|()
expr_stmt|;
comment|/* Update filter to be on a merge target. */
name|pmcstat_changefilter
argument_list|()
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"merge PMC %s"
argument_list|,
name|pmcstat_mergepmc
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Close current plugin. */
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_shutdown
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_shutdown
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find next top display available. */
do|do
block|{
name|args
operator|.
name|pa_plugin
operator|++
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_name
operator|==
name|NULL
condition|)
name|args
operator|.
name|pa_plugin
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_topdisplay
operator|==
name|NULL
condition|)
do|;
comment|/* Open new plugin. */
name|pmcstat_stats_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_init
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_init
argument_list|()
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"switching to plugin %s"
argument_list|,
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pmcstat_pmcinfilter
operator|++
expr_stmt|;
if|if
condition|(
name|pmcstat_pmcinfilter
operator|>=
name|pmcstat_npmcs
condition|)
name|pmcstat_pmcinfilter
operator|=
literal|0
expr_stmt|;
name|pmcstat_changefilter
argument_list|()
expr_stmt|;
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"switching to PMC %s.%d"
argument_list|,
name|pmcstat_pmcindex_to_name
argument_list|(
name|pmcstat_pmcinfilter
argument_list|)
argument_list|,
name|pmcstat_pmcinfilter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|pmcstat_pause
operator|=
operator|!
name|pmcstat_pause
expr_stmt|;
if|if
condition|(
name|pmcstat_pause
condition|)
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"pause => press space again to continue"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|wprintw
argument_list|(
name|w
argument_list|,
literal|"exiting..."
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_topkeypress
operator|!=
name|NULL
condition|)
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_topkeypress
argument_list|(
name|c
argument_list|,
operator|(
name|void
operator|*
operator|)
name|w
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Top mode display.  */
end_comment

begin_function
name|void
name|pmcstat_display_log
parameter_list|(
name|void
parameter_list|)
block|{
name|pmcstat_refresh_top
argument_list|()
expr_stmt|;
comment|/* Reset everythings if delta mode. */
if|if
condition|(
name|args
operator|.
name|pa_topmode
operator|==
name|PMCSTAT_TOP_DELTA
condition|)
block|{
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_shutdown
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_shutdown
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|pmcstat_stats_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_init
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_init
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure a plugins.  */
end_comment

begin_function
name|void
name|pmcstat_pluginconfigure_log
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opt
argument_list|,
literal|"threshold="
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pmcstat_threshold
operator|=
name|atof
argument_list|(
name|opt
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_configure
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|plugins
index|[
name|args
operator|.
name|pa_plugin
index|]
operator|.
name|pl_configure
argument_list|(
name|opt
argument_list|)
condition|)
name|err
argument_list|(
name|EX_USAGE
argument_list|,
literal|"ERROR: unknown option<%s>."
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pmcstat_log_shutdown_logging
parameter_list|(
name|void
parameter_list|)
block|{
name|pmcstat_shutdown_logging
argument_list|(
operator|&
name|args
argument_list|,
name|plugins
argument_list|,
operator|&
name|pmcstat_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmcstat_log_initialize_logging
parameter_list|(
name|void
parameter_list|)
block|{
name|pmcstat_initialize_logging
argument_list|(
operator|&
name|pmcstat_kernproc
argument_list|,
operator|&
name|args
argument_list|,
name|plugins
argument_list|,
operator|&
name|pmcstat_npmcs
argument_list|,
operator|&
name|pmcstat_mergepmc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

