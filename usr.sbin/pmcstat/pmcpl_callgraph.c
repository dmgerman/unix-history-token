begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2007, Joseph Koshy  * Copyright (c) 2007 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by A. Joseph Koshy under  * sponsorship from the FreeBSD Foundation and Google, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Transform a hwpmc(4) log into human readable form, and into  * gprof(1) compatible profiles.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pmc.h>
end_include

begin_include
include|#
directive|include
file|<pmclog.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pmcstat.h"
end_include

begin_include
include|#
directive|include
file|"pmcstat_log.h"
end_include

begin_include
include|#
directive|include
file|"pmcstat_top.h"
end_include

begin_include
include|#
directive|include
file|"pmcpl_callgraph.h"
end_include

begin_comment
comment|/* Get the sample value in percent related to nsamples. */
end_comment

begin_define
define|#
directive|define
name|PMCPL_CG_COUNTP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)->pcg_count * 100.0 / nsamples)
end_define

begin_comment
comment|/*  * The toplevel CG nodes (i.e., with rank == 0) are placed in a hash table.  */
end_comment

begin_decl_stmt
name|struct
name|pmcstat_cgnode_hash_list
name|pmcstat_cgnode_hash
index|[
name|PMCSTAT_NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmcstat_cgnode_hash_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pmcstat_interned_string
name|pmcstat_previous_filename_printed
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|pmcstat_cgnode
modifier|*
name|pmcstat_cgnode_allocate
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|pc
parameter_list|)
block|{
name|struct
name|pmcstat_cgnode
modifier|*
name|cg
decl_stmt|;
if|if
condition|(
operator|(
name|cg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cg
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot allocate callgraph node"
argument_list|)
expr_stmt|;
name|cg
operator|->
name|pcg_image
operator|=
name|image
expr_stmt|;
name|cg
operator|->
name|pcg_func
operator|=
name|pc
expr_stmt|;
name|cg
operator|->
name|pcg_count
operator|=
literal|0
expr_stmt|;
name|cg
operator|->
name|pcg_nchildren
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|cg
operator|->
name|pcg_children
argument_list|)
expr_stmt|;
return|return
operator|(
name|cg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a node and its children.  */
end_comment

begin_function
specifier|static
name|void
name|pmcstat_cgnode_free
parameter_list|(
name|struct
name|pmcstat_cgnode
modifier|*
name|cg
parameter_list|)
block|{
name|struct
name|pmcstat_cgnode
modifier|*
name|cgc
decl_stmt|,
modifier|*
name|cgtmp
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|cgc
argument_list|,
argument|&cg->pcg_children
argument_list|,
argument|pcg_sibling
argument_list|,
argument|cgtmp
argument_list|)
name|pmcstat_cgnode_free
argument_list|(
name|cgc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for a callgraph node associated with pmc `pmcid' in the global  * hash table that corresponds to the given `pc' value in the process  * `pp'.  */
end_comment

begin_function
specifier|static
name|struct
name|pmcstat_cgnode
modifier|*
name|pmcstat_cgnode_hash_lookup_pc
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|pmc_id_t
name|pmcid
parameter_list|,
name|uintfptr_t
name|pc
parameter_list|,
name|int
name|usermode
parameter_list|)
block|{
name|struct
name|pmcstat_pcmap
modifier|*
name|ppm
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pmcstat_image
modifier|*
name|image
decl_stmt|;
name|struct
name|pmcstat_cgnode
modifier|*
name|cg
decl_stmt|;
name|struct
name|pmcstat_cgnode_hash
modifier|*
name|h
decl_stmt|;
name|uintfptr_t
name|loadaddress
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|hash
decl_stmt|;
name|ppm
operator|=
name|pmcstat_process_find_map
argument_list|(
name|usermode
condition|?
name|pp
else|:
name|pmcstat_kernproc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppm
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|image
operator|=
name|ppm
operator|->
name|ppm_image
expr_stmt|;
name|loadaddress
operator|=
name|ppm
operator|->
name|ppm_lowpc
operator|+
name|image
operator|->
name|pi_vaddr
operator|-
name|image
operator|->
name|pi_start
expr_stmt|;
name|pc
operator|-=
name|loadaddress
expr_stmt|;
comment|/* Convert to an offset in the image. */
comment|/* 	 * Try determine the function at this offset.  If we can't 	 * find a function round leave the `pc' value alone. 	 */
if|if
condition|(
operator|(
name|sym
operator|=
name|pmcstat_symbol_search
argument_list|(
name|image
argument_list|,
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pc
operator|=
name|sym
operator|->
name|ps_start
expr_stmt|;
for|for
control|(
name|hash
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|uintfptr_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash
operator|+=
operator|(
name|pc
operator|>>
name|i
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|hash
operator|&=
name|PMCSTAT_HASH_MASK
expr_stmt|;
name|cg
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|h
argument_list|,
argument|&pmcstat_cgnode_hash[hash]
argument_list|,
argument|pch_next
argument_list|)
block|{
if|if
condition|(
name|h
operator|->
name|pch_pmcid
operator|!=
name|pmcid
condition|)
continue|continue;
name|cg
operator|=
name|h
operator|->
name|pch_cgnode
expr_stmt|;
name|assert
argument_list|(
name|cg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cg
operator|->
name|pcg_image
operator|==
name|image
operator|&&
name|cg
operator|->
name|pcg_func
operator|==
name|pc
condition|)
return|return
operator|(
name|cg
operator|)
return|;
block|}
comment|/* 	 * We haven't seen this (pmcid, pc) tuple yet, so allocate a 	 * new callgraph node and a new hash table entry for it. 	 */
name|cg
operator|=
name|pmcstat_cgnode_allocate
argument_list|(
name|image
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Could not allocate callgraph node"
argument_list|)
expr_stmt|;
name|h
operator|->
name|pch_pmcid
operator|=
name|pmcid
expr_stmt|;
name|h
operator|->
name|pch_cgnode
operator|=
name|cg
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pmcstat_cgnode_hash
index|[
name|hash
index|]
argument_list|,
name|h
argument_list|,
name|pch_next
argument_list|)
expr_stmt|;
name|pmcstat_cgnode_hash_count
operator|++
expr_stmt|;
return|return
operator|(
name|cg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two callgraph nodes for sorting.  */
end_comment

begin_function
specifier|static
name|int
name|pmcstat_cgnode_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|pmcstat_cgnode
modifier|*
specifier|const
modifier|*
name|pcg1
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|pcg2
decl_stmt|,
modifier|*
name|cg1
decl_stmt|,
modifier|*
name|cg2
decl_stmt|;
name|pcg1
operator|=
operator|(
specifier|const
expr|struct
name|pmcstat_cgnode
operator|*
specifier|const
operator|*
operator|)
name|a
expr_stmt|;
name|cg1
operator|=
operator|*
name|pcg1
expr_stmt|;
name|pcg2
operator|=
operator|(
specifier|const
expr|struct
name|pmcstat_cgnode
operator|*
specifier|const
operator|*
operator|)
name|b
expr_stmt|;
name|cg2
operator|=
operator|*
name|pcg2
expr_stmt|;
comment|/* Sort in reverse order */
if|if
condition|(
name|cg1
operator|->
name|pcg_count
operator|<
name|cg2
operator|->
name|pcg_count
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cg1
operator|->
name|pcg_count
operator|>
name|cg2
operator|->
name|pcg_count
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find (allocating if a needed) a callgraph node in the given  * parent with the same (image, pcoffset) pair.  */
end_comment

begin_function
specifier|static
name|struct
name|pmcstat_cgnode
modifier|*
name|pmcstat_cgnode_find
parameter_list|(
name|struct
name|pmcstat_cgnode
modifier|*
name|parent
parameter_list|,
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|pcoffset
parameter_list|)
block|{
name|struct
name|pmcstat_cgnode
modifier|*
name|child
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&parent->pcg_children
argument_list|,
argument|pcg_sibling
argument_list|)
block|{
if|if
condition|(
name|child
operator|->
name|pcg_image
operator|==
name|image
operator|&&
name|child
operator|->
name|pcg_func
operator|==
name|pcoffset
condition|)
return|return
operator|(
name|child
operator|)
return|;
block|}
comment|/* 	 * Allocate a new structure. 	 */
name|child
operator|=
name|pmcstat_cgnode_allocate
argument_list|(
name|image
argument_list|,
name|pcoffset
argument_list|)
expr_stmt|;
comment|/* 	 * Link it into the parent. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|pcg_children
argument_list|,
name|child
argument_list|,
name|pcg_sibling
argument_list|)
expr_stmt|;
name|parent
operator|->
name|pcg_nchildren
operator|++
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print one callgraph node.  The output format is:  *  * indentation %(parent's samples) #nsamples function@object  */
end_comment

begin_function
specifier|static
name|void
name|pmcstat_cgnode_print
parameter_list|(
name|struct
name|pmcstat_cgnode
modifier|*
name|cg
parameter_list|,
name|int
name|depth
parameter_list|,
name|uint32_t
name|total
parameter_list|)
block|{
name|uint32_t
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|space
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pmcstat_cgnode
modifier|*
modifier|*
name|sortbuffer
decl_stmt|,
modifier|*
modifier|*
name|cgn
decl_stmt|,
modifier|*
name|pcg
decl_stmt|;
name|space
operator|=
literal|" "
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%*s"
argument_list|,
name|depth
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|cg
operator|->
name|pcg_count
operator|==
name|total
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"100.0%% "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%05.2f%% "
argument_list|,
literal|100.0
operator|*
name|cg
operator|->
name|pcg_count
operator|/
name|total
argument_list|)
expr_stmt|;
name|n
operator|=
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" [%u] "
argument_list|,
name|cg
operator|->
name|pcg_count
argument_list|)
expr_stmt|;
comment|/* #samples is a 12 character wide field. */
if|if
condition|(
name|n
operator|<
literal|12
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%*s"
argument_list|,
literal|12
operator|-
name|n
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%*s"
argument_list|,
name|depth
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|sym
operator|=
name|pmcstat_symbol_search
argument_list|(
name|cg
operator|->
name|pcg_image
argument_list|,
name|cg
operator|->
name|pcg_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%s"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|sym
operator|->
name|ps_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|cg
operator|->
name|pcg_image
operator|->
name|pi_vaddr
operator|+
name|cg
operator|->
name|pcg_func
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcstat_previous_filename_printed
operator|!=
name|cg
operator|->
name|pcg_image
operator|->
name|pi_fullpath
condition|)
block|{
name|pmcstat_previous_filename_printed
operator|=
name|cg
operator|->
name|pcg_image
operator|->
name|pi_fullpath
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|" @ %s\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|pmcstat_previous_filename_printed
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cg
operator|->
name|pcg_nchildren
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sortbuffer
operator|=
operator|(
expr|struct
name|pmcstat_cgnode
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
operator|*
name|cg
operator|->
name|pcg_nchildren
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot print callgraph"
argument_list|)
expr_stmt|;
name|cgn
operator|=
name|sortbuffer
expr_stmt|;
name|LIST_FOREACH
argument_list|(
name|pcg
argument_list|,
operator|&
name|cg
operator|->
name|pcg_children
argument_list|,
name|pcg_sibling
argument_list|)
operator|*
name|cgn
operator|++
operator|=
name|pcg
expr_stmt|;
name|assert
argument_list|(
name|cgn
operator|-
name|sortbuffer
operator|==
operator|(
name|int
operator|)
name|cg
operator|->
name|pcg_nchildren
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sortbuffer
argument_list|,
name|cg
operator|->
name|pcg_nchildren
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
argument_list|,
name|pmcstat_cgnode_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|sortbuffer
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cg
operator|->
name|pcg_nchildren
condition|;
name|n
operator|++
operator|,
name|cgn
operator|++
control|)
name|pmcstat_cgnode_print
argument_list|(
operator|*
name|cgn
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|cg
operator|->
name|pcg_count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sortbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record a callchain.  */
end_comment

begin_function
name|void
name|pmcpl_cg_process
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcr
parameter_list|,
name|uint32_t
name|nsamples
parameter_list|,
name|uintfptr_t
modifier|*
name|cc
parameter_list|,
name|int
name|usermode
parameter_list|,
name|uint32_t
name|cpu
parameter_list|)
block|{
name|uintfptr_t
name|pc
decl_stmt|,
name|loadaddress
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|struct
name|pmcstat_image
modifier|*
name|image
decl_stmt|;
name|struct
name|pmcstat_pcmap
modifier|*
name|ppm
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pmcstat_cgnode
modifier|*
name|parent
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|struct
name|pmcstat_process
modifier|*
name|km
decl_stmt|;
name|pmc_id_t
name|pmcid
decl_stmt|;
operator|(
name|void
operator|)
name|cpu
expr_stmt|;
comment|/* 	 * Find the callgraph node recorded in the global hash table 	 * for this (pmcid, pc). 	 */
name|pc
operator|=
name|cc
index|[
literal|0
index|]
expr_stmt|;
name|pmcid
operator|=
name|pmcr
operator|->
name|pr_pmcid
expr_stmt|;
name|parent
operator|=
name|pmcstat_cgnode_hash_lookup_pc
argument_list|(
name|pp
argument_list|,
name|pmcid
argument_list|,
name|pc
argument_list|,
name|usermode
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
name|pmcstat_stats
operator|.
name|ps_callchain_dubious_frames
operator|++
expr_stmt|;
name|pmcr
operator|->
name|pr_dubious_frames
operator|++
expr_stmt|;
return|return;
block|}
name|parent
operator|->
name|pcg_count
operator|++
expr_stmt|;
comment|/* 	 * For each return address in the call chain record, subject 	 * to the maximum depth desired. 	 * - Find the image associated with the sample.  Stop if there 	 *   there is no valid image at that address. 	 * - Find the function that overlaps the return address. 	 * - If found: use the start address of the function. 	 *   If not found (say an object's symbol table is not present or 	 *   is incomplete), round down to th gprof bucket granularity. 	 * - Convert return virtual address to an offset in the image. 	 * - Look for a child with the same {offset,image} tuple, 	 *   inserting one if needed. 	 * - Increment the count of occurrences of the child. 	 */
name|km
operator|=
name|pmcstat_kernproc
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
operator|(
name|uint32_t
operator|)
name|args
operator|.
name|pa_graphdepth
operator|&&
name|n
operator|<
name|nsamples
condition|;
name|n
operator|++
operator|,
name|parent
operator|=
name|child
control|)
block|{
name|pc
operator|=
name|cc
index|[
name|n
index|]
expr_stmt|;
name|ppm
operator|=
name|pmcstat_process_find_map
argument_list|(
name|usermode
condition|?
name|pp
else|:
name|km
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppm
operator|==
name|NULL
condition|)
block|{
comment|/* Detect full frame capture (kernel + user). */
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
name|ppm
operator|=
name|pmcstat_process_find_map
argument_list|(
name|pp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppm
operator|!=
name|NULL
condition|)
name|km
operator|=
name|pp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ppm
operator|==
name|NULL
condition|)
return|return;
name|image
operator|=
name|ppm
operator|->
name|ppm_image
expr_stmt|;
name|loadaddress
operator|=
name|ppm
operator|->
name|ppm_lowpc
operator|+
name|image
operator|->
name|pi_vaddr
operator|-
name|image
operator|->
name|pi_start
expr_stmt|;
name|pc
operator|-=
name|loadaddress
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|=
name|pmcstat_symbol_search
argument_list|(
name|image
argument_list|,
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pc
operator|=
name|sym
operator|->
name|ps_start
expr_stmt|;
name|child
operator|=
name|pmcstat_cgnode_find
argument_list|(
name|parent
argument_list|,
name|image
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|child
operator|->
name|pcg_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Printing a callgraph for a PMC.  */
end_comment

begin_function
specifier|static
name|void
name|pmcstat_callgraph_print_for_pmcid
parameter_list|(
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcr
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|nentries
decl_stmt|;
name|uint32_t
name|nsamples
decl_stmt|;
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmcstat_cgnode
modifier|*
modifier|*
name|sortbuffer
decl_stmt|,
modifier|*
modifier|*
name|cgn
decl_stmt|;
name|struct
name|pmcstat_cgnode_hash
modifier|*
name|pch
decl_stmt|;
comment|/* 	 * We pull out all callgraph nodes in the top-level hash table 	 * with a matching PMC id.  We then sort these based on the 	 * frequency of occurrence.  Each callgraph node is then 	 * printed. 	 */
name|nsamples
operator|=
literal|0
expr_stmt|;
name|pmcid
operator|=
name|pmcr
operator|->
name|pr_pmcid
expr_stmt|;
if|if
condition|(
operator|(
name|sortbuffer
operator|=
operator|(
expr|struct
name|pmcstat_cgnode
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
operator|*
name|pmcstat_cgnode_hash_count
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot sort callgraph"
argument_list|)
expr_stmt|;
name|cgn
operator|=
name|sortbuffer
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|PMCSTAT_NHASH
condition|;
name|n
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|pch
argument_list|,
argument|&pmcstat_cgnode_hash[n]
argument_list|,
argument|pch_next
argument_list|)
if|if
condition|(
name|pch
operator|->
name|pch_pmcid
operator|==
name|pmcid
condition|)
block|{
name|nsamples
operator|+=
name|pch
operator|->
name|pch_cgnode
operator|->
name|pcg_count
expr_stmt|;
operator|*
name|cgn
operator|++
operator|=
name|pch
operator|->
name|pch_cgnode
expr_stmt|;
block|}
name|nentries
operator|=
name|cgn
operator|-
name|sortbuffer
expr_stmt|;
name|assert
argument_list|(
name|nentries
operator|<=
name|pmcstat_cgnode_hash_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentries
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sortbuffer
argument_list|)
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|sortbuffer
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
argument_list|,
name|pmcstat_cgnode_compare
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"@ %s [%u samples]\n\n"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|pmcr
operator|->
name|pr_pmcname
argument_list|)
argument_list|,
name|nsamples
argument_list|)
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|sortbuffer
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nentries
condition|;
name|n
operator|++
operator|,
name|cgn
operator|++
control|)
block|{
name|pmcstat_previous_filename_printed
operator|=
name|NULL
expr_stmt|;
name|pmcstat_cgnode_print
argument_list|(
operator|*
name|cgn
argument_list|,
literal|0
argument_list|,
name|nsamples
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|args
operator|.
name|pa_graphfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sortbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out callgraphs.  */
end_comment

begin_function
specifier|static
name|void
name|pmcstat_callgraph_print
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pmcr
argument_list|,
argument|&pmcstat_pmcs
argument_list|,
argument|pr_next
argument_list|)
name|pmcstat_callgraph_print_for_pmcid
argument_list|(
name|pmcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmcstat_cgnode_topprint
parameter_list|(
name|struct
name|pmcstat_cgnode
modifier|*
name|cg
parameter_list|,
name|int
name|depth
parameter_list|,
name|uint32_t
name|nsamples
parameter_list|)
block|{
name|int
name|v_attrs
decl_stmt|,
name|vs_len
decl_stmt|,
name|ns_len
decl_stmt|,
name|width
decl_stmt|,
name|len
decl_stmt|,
name|n
decl_stmt|,
name|nchildren
decl_stmt|;
name|float
name|v
decl_stmt|;
name|char
name|ns
index|[
literal|30
index|]
decl_stmt|,
name|vs
index|[
literal|10
index|]
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|pmcstat_cgnode
modifier|*
modifier|*
name|sortbuffer
decl_stmt|,
modifier|*
modifier|*
name|cgn
decl_stmt|,
modifier|*
name|pcg
decl_stmt|;
operator|(
name|void
operator|)
name|depth
expr_stmt|;
comment|/* Format value. */
name|v
operator|=
name|PMCPL_CG_COUNTP
argument_list|(
name|cg
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|,
literal|"%.1f"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v_attrs
operator|=
name|PMCSTAT_ATTRPERCENT
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* Format name. */
name|sym
operator|=
name|pmcstat_symbol_search
argument_list|(
name|cg
operator|->
name|pcg_image
argument_list|,
name|cg
operator|->
name|pcg_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|sym
operator|->
name|ps_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|"%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cg
operator|->
name|pcg_func
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTRON
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"%5.5s"
argument_list|,
name|vs
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTROFF
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|" %-10.10s %-20.20s"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|cg
operator|->
name|pcg_image
operator|->
name|pi_name
argument_list|)
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|nchildren
operator|=
name|cg
operator|->
name|pcg_nchildren
expr_stmt|;
if|if
condition|(
name|nchildren
operator|==
literal|0
condition|)
block|{
name|PMCSTAT_PRINTW
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|width
operator|=
name|pmcstat_displaywidth
operator|-
literal|40
expr_stmt|;
if|if
condition|(
operator|(
name|sortbuffer
operator|=
operator|(
expr|struct
name|pmcstat_cgnode
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
operator|*
name|nchildren
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot print callgraph"
argument_list|)
expr_stmt|;
name|cgn
operator|=
name|sortbuffer
expr_stmt|;
name|LIST_FOREACH
argument_list|(
name|pcg
argument_list|,
operator|&
name|cg
operator|->
name|pcg_children
argument_list|,
name|pcg_sibling
argument_list|)
operator|*
name|cgn
operator|++
operator|=
name|pcg
expr_stmt|;
name|assert
argument_list|(
name|cgn
operator|-
name|sortbuffer
operator|==
operator|(
name|int
operator|)
name|nchildren
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sortbuffer
argument_list|,
name|nchildren
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
argument_list|,
name|pmcstat_cgnode_compare
argument_list|)
expr_stmt|;
comment|/* Count how many callers. */
for|for
control|(
name|cgn
operator|=
name|sortbuffer
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nchildren
condition|;
name|n
operator|++
operator|,
name|cgn
operator|++
control|)
block|{
name|pcg
operator|=
operator|*
name|cgn
expr_stmt|;
name|v
operator|=
name|PMCPL_CG_COUNTP
argument_list|(
name|pcg
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|pmcstat_threshold
condition|)
break|break;
block|}
name|nchildren
operator|=
name|n
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|sortbuffer
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nchildren
condition|;
name|n
operator|++
operator|,
name|cgn
operator|++
control|)
block|{
name|pcg
operator|=
operator|*
name|cgn
expr_stmt|;
comment|/* Format value. */
if|if
condition|(
name|nchildren
operator|>
literal|1
condition|)
block|{
name|v
operator|=
name|PMCPL_CG_COUNTP
argument_list|(
name|pcg
argument_list|)
expr_stmt|;
name|vs_len
operator|=
name|snprintf
argument_list|(
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|,
literal|":%.1f"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v_attrs
operator|=
name|PMCSTAT_ATTRPERCENT
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|vs_len
operator|=
literal|0
expr_stmt|;
comment|/* Format name. */
name|sym
operator|=
name|pmcstat_symbol_search
argument_list|(
name|pcg
operator|->
name|pcg_image
argument_list|,
name|pcg
operator|->
name|pcg_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|ns_len
operator|=
name|snprintf
argument_list|(
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|sym
operator|->
name|ps_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ns_len
operator|=
name|snprintf
argument_list|(
name|ns
argument_list|,
sizeof|sizeof
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|"%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pcg
operator|->
name|pcg_func
argument_list|)
expr_stmt|;
name|len
operator|=
name|ns_len
operator|+
name|vs_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|width
operator|-
name|len
operator|<
literal|0
condition|)
block|{
name|PMCSTAT_PRINTW
argument_list|(
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
name|width
operator|-=
name|len
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|" %s"
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchildren
operator|>
literal|1
condition|)
block|{
name|PMCSTAT_ATTRON
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"%s"
argument_list|,
name|vs
argument_list|)
expr_stmt|;
name|PMCSTAT_ATTROFF
argument_list|(
name|v_attrs
argument_list|)
expr_stmt|;
block|}
block|}
name|PMCSTAT_PRINTW
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sortbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Top mode display.  */
end_comment

begin_function
name|void
name|pmcpl_cg_topdisplay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|nentries
decl_stmt|;
name|uint32_t
name|nsamples
decl_stmt|;
name|struct
name|pmcstat_cgnode
modifier|*
modifier|*
name|sortbuffer
decl_stmt|,
modifier|*
modifier|*
name|cgn
decl_stmt|;
name|struct
name|pmcstat_cgnode_hash
modifier|*
name|pch
decl_stmt|;
name|struct
name|pmcstat_pmcrecord
modifier|*
name|pmcr
decl_stmt|;
name|pmcr
operator|=
name|pmcstat_pmcindex_to_pmcr
argument_list|(
name|pmcstat_pmcinfilter
argument_list|)
expr_stmt|;
comment|/* 	 * We pull out all callgraph nodes in the top-level hash table 	 * with a matching PMC index.  We then sort these based on the 	 * frequency of occurrence.  Each callgraph node is then 	 * printed. 	 */
name|nsamples
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sortbuffer
operator|=
operator|(
expr|struct
name|pmcstat_cgnode
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
operator|*
name|pmcstat_cgnode_hash_count
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot sort callgraph"
argument_list|)
expr_stmt|;
name|cgn
operator|=
name|sortbuffer
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|PMCSTAT_NHASH
condition|;
name|n
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|pch
argument_list|,
argument|&pmcstat_cgnode_hash[n]
argument_list|,
argument|pch_next
argument_list|)
if|if
condition|(
name|pmcr
operator|==
name|NULL
operator|||
name|pch
operator|->
name|pch_pmcid
operator|==
name|pmcr
operator|->
name|pr_pmcid
condition|)
block|{
name|nsamples
operator|+=
name|pch
operator|->
name|pch_cgnode
operator|->
name|pcg_count
expr_stmt|;
operator|*
name|cgn
operator|++
operator|=
name|pch
operator|->
name|pch_cgnode
expr_stmt|;
block|}
name|nentries
operator|=
name|cgn
operator|-
name|sortbuffer
expr_stmt|;
name|assert
argument_list|(
name|nentries
operator|<=
name|pmcstat_cgnode_hash_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentries
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sortbuffer
argument_list|)
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|sortbuffer
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmcstat_cgnode
operator|*
argument_list|)
argument_list|,
name|pmcstat_cgnode_compare
argument_list|)
expr_stmt|;
name|PMCSTAT_PRINTW
argument_list|(
literal|"%5.5s %-10.10s %-20.20s %s\n"
argument_list|,
literal|"%SAMP"
argument_list|,
literal|"IMAGE"
argument_list|,
literal|"FUNCTION"
argument_list|,
literal|"CALLERS"
argument_list|)
expr_stmt|;
name|nentries
operator|=
name|min
argument_list|(
name|pmcstat_displayheight
operator|-
literal|2
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|sortbuffer
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nentries
condition|;
name|n
operator|++
operator|,
name|cgn
operator|++
control|)
block|{
if|if
condition|(
name|PMCPL_CG_COUNTP
argument_list|(
operator|*
name|cgn
argument_list|)
operator|<
name|pmcstat_threshold
condition|)
break|break;
name|pmcstat_cgnode_topprint
argument_list|(
operator|*
name|cgn
argument_list|,
literal|0
argument_list|,
name|nsamples
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sortbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle top mode keypress.  */
end_comment

begin_function
name|int
name|pmcpl_cg_topkeypress
parameter_list|(
name|int
name|c
parameter_list|,
name|WINDOW
modifier|*
name|w
parameter_list|)
block|{
operator|(
name|void
operator|)
name|c
expr_stmt|;
operator|(
name|void
operator|)
name|w
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pmcpl_cg_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pmcstat_cgnode_hash_count
operator|=
literal|0
expr_stmt|;
name|pmcstat_previous_filename_printed
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMCSTAT_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|pmcstat_cgnode_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmcpl_cg_shutdown
parameter_list|(
name|FILE
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pmcstat_cgnode_hash
modifier|*
name|pch
decl_stmt|,
modifier|*
name|pchtmp
decl_stmt|;
operator|(
name|void
operator|)
name|mf
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|pa_flags
operator|&
name|FLAG_DO_CALLGRAPHS
condition|)
name|pmcstat_callgraph_print
argument_list|()
expr_stmt|;
comment|/* 	 * Free memory. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMCSTAT_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|pch
argument_list|,
argument|&pmcstat_cgnode_hash[i]
argument_list|,
argument|pch_next
argument_list|,
argument|pchtmp
argument_list|)
block|{
name|pmcstat_cgnode_free
argument_list|(
name|pch
operator|->
name|pch_cgnode
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pch
argument_list|,
name|pch_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

