begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  * stlload.c  -- stallion intelligent multiport down loader.  *  * Copyright (c) 1994-1996 Greg Ungerer (gerg@stallion.oz.au).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Greg Ungerer.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: stlload.c,v 1.7 1997/10/20 12:51:29 charnier Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cdk.h>
end_include

begin_comment
comment|/*****************************************************************************/
end_comment

begin_decl_stmt
name|char
modifier|*
name|version
init|=
literal|"1.0.0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|defdevice
init|=
literal|"/dev/staliomem%d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|image
init|=
name|BOOTDIR
literal|"/cdk.sys"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|oldimage
init|=
name|BOOTDIR
literal|"/2681.sys"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|memdevice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|devstr
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brdnr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Define a local buffer for copying the image into the shared memory.  */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|4096
end_define

begin_decl_stmt
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Define the timeout length when waiting for slave to start up.  *	The quantity is measured in seconds.  */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT
value|5
end_define

begin_comment
comment|/*  *	Set up a default feature area structure.  */
end_comment

begin_decl_stmt
name|cdkfeature_t
name|feature
init|=
block|{
literal|0
block|,
literal|0
block|,
name|ETYP_CDK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Have local copies of the board signatures ready.  */
end_comment

begin_decl_stmt
name|cdkecpsig_t
name|ecpsig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cdkonbsig_t
name|onbsig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Declare internal function prototypes here.  */
end_comment

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ecpfindports
parameter_list|(
name|cdkecpsig_t
modifier|*
name|sigp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|onbfindports
parameter_list|(
name|cdkonbsig_t
modifier|*
name|sigp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|download
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: stlload [-vhVR] [-i image-file] [-c control-device] [-r rx-buf-size]"
argument_list|,
literal|"               [-t tx-buf-size] [-B boot-banner] [-b unit-number]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Given a boards signature determine how many ports it has. We need to  *	know this to setup the slave feature arguments. This function is for  *	ECP boards only.  */
end_comment

begin_function
name|int
name|ecpfindports
parameter_list|(
name|cdkecpsig_t
modifier|*
name|sigp
parameter_list|)
block|{
name|unsigned
name|int
name|id
decl_stmt|;
name|int
name|bank
decl_stmt|,
name|nrports
decl_stmt|;
name|nrports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bank
operator|=
literal|0
init|;
operator|(
name|bank
operator|<
literal|8
operator|)
condition|;
name|bank
operator|++
control|)
block|{
name|id
operator|=
operator|(
name|unsigned
name|int
operator|)
name|sigp
operator|->
name|panelid
index|[
name|bank
index|]
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0xff
condition|)
break|break;
if|if
condition|(
operator|(
name|id
operator|&
literal|0x07
operator|)
operator|!=
name|bank
condition|)
break|break;
if|if
condition|(
name|id
operator|&
literal|0x20
condition|)
block|{
name|nrports
operator|+=
literal|16
expr_stmt|;
name|bank
operator|++
expr_stmt|;
block|}
else|else
block|{
name|nrports
operator|+=
literal|8
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nrports
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Given a boards signature determine how many ports it has. We need to  *	know this to setup the slave feature arguments. This function is for  *	ONboards and Brumbys.  */
end_comment

begin_function
name|int
name|onbfindports
parameter_list|(
name|cdkonbsig_t
modifier|*
name|sigp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nrports
decl_stmt|;
if|if
condition|(
name|sigp
operator|->
name|amask1
condition|)
block|{
name|nrports
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|16
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|sigp
operator|->
name|amask0
operator|<<
name|i
operator|)
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|nrports
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|nrports
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Download an image to the slave board. There is a long sequence of  *	things to do to get the slave running, but it is basically a simple  *	process. Main things to do are: copy slave image into shared memory,  *	start slave running and then read shared memory map.  */
end_comment

begin_function
name|int
name|download
parameter_list|()
block|{
name|unsigned
name|char
name|alivemarker
decl_stmt|;
name|time_t
name|strttime
decl_stmt|;
name|int
name|memfd
decl_stmt|,
name|ifd
decl_stmt|;
name|int
name|nrdevs
decl_stmt|,
name|sigok
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Opening shared memory device %s\n"
argument_list|,
name|memdevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|memfd
operator|=
name|open
argument_list|(
name|memdevice
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"failed to open memory device %s"
argument_list|,
name|memdevice
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	Before starting the download must tell driver that we are about to  *	stop its slave. This is only important if it is already running.  *	Once we have told the driver its stopped then do a hardware reset  *	on it, to get it into a known state.  */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Stoping any current slave\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|memfd
argument_list|,
name|STL_BSTOP
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"ioctl(STL_BSTOP)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Reseting the board\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|memfd
argument_list|,
name|STL_BRESET
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"ioctl(STL_BRESET)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|reset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	After reseting the board we need to send an interrupt to the older  *	board types to get them to become active. Do that now.  */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Interrupting board to activate shared memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|memfd
argument_list|,
name|STL_BINTR
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"ioctl(STL_BINTR)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*sleep(1);*/
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Opening slave image file %s\n"
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|image
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"failed to open image file %s"
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	At this point get the signature of the board from the shared memory.  *	Do a double check that it is a board we know about. We will also need  *	to calculate the number of ports on this board (to use later).  */
name|sigok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Reading ROM signature from board\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
name|CDK_SIGADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|CDK_SIGADDR
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory file"
argument_list|,
name|CDK_FEATADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|memfd
argument_list|,
operator|&
name|ecpsig
argument_list|,
sizeof|sizeof
argument_list|(
name|cdkecpsig_t
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read of ROM signature failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ecpsig
operator|.
name|magic
operator|==
name|ECP_MAGIC
condition|)
block|{
name|nrdevs
operator|=
name|ecpfindports
argument_list|(
operator|&
name|ecpsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrdevs
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sigok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
name|CDK_SIGADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|CDK_SIGADDR
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory file"
argument_list|,
name|CDK_FEATADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|memfd
argument_list|,
operator|&
name|onbsig
argument_list|,
sizeof|sizeof
argument_list|(
name|cdkonbsig_t
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read of ROM signature failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|onbsig
operator|.
name|magic0
operator|==
name|ONB_MAGIC0
operator|)
operator|&&
operator|(
name|onbsig
operator|.
name|magic1
operator|==
name|ONB_MAGIC1
operator|)
operator|&&
operator|(
name|onbsig
operator|.
name|magic2
operator|==
name|ONB_MAGIC2
operator|)
operator|&&
operator|(
name|onbsig
operator|.
name|magic3
operator|==
name|ONB_MAGIC3
operator|)
condition|)
block|{
name|nrdevs
operator|=
name|onbfindports
argument_list|(
operator|&
name|onbsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrdevs
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sigok
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sigok
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown signature from board"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Board signature reports %d ports\n"
argument_list|,
name|nrdevs
argument_list|)
expr_stmt|;
comment|/*  *	Start to copy the image file into shared memory. The first thing to  *	do is copy the vector region in from shared memory address 0. We will  *	then skip over the signature and feature area and start copying the  *	actual image data and code from 4k upwards.  */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Copying vector table into shared memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
name|CDK_SIGADDR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read of image file failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory file"
argument_list|,
name|CDK_FEATADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
name|memfd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"write to memory device failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|ifd
argument_list|,
literal|0x1000
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0x1000
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on image file"
argument_list|,
name|CDK_FEATADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
literal|0x1000
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0x1000
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory device"
argument_list|,
name|CDK_FEATADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	Copy buffer size chunks of data from the image file into shared memory.  */
do|do
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read of image file failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
name|memfd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"write to memory device failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|n
operator|==
name|BUFSIZE
condition|)
do|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
comment|/*  *	We need to down load the start up parameters for the slave. This is  *	done via the feature area of shared memory. Think of the feature area  *	as a way of passing "command line" arguments to the slave.  *	FIX: should do something here to load "brdspec" as well...  */
name|feature
operator|.
name|nrdevs
operator|=
name|nrdevs
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Loading features into shared memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
name|CDK_FEATADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|CDK_FEATADDR
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory device"
argument_list|,
name|CDK_FEATADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
name|memfd
argument_list|,
operator|&
name|feature
argument_list|,
sizeof|sizeof
argument_list|(
name|cdkfeature_t
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"write to memory device failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	Wait for board alive marker to be set. The slave image will set the  *	byte at address CDK_RDYADDR to 0x13 after it has successfully started.  *	If this doesn't happen we timeout and fail.  */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Setting alive marker to 0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
name|CDK_RDYADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|CDK_RDYADDR
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory device"
argument_list|,
name|CDK_RDYADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alivemarker
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|memfd
argument_list|,
operator|&
name|alivemarker
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"write to memory device failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	At this point the entire image is loaded into shared memory. To start  *	it executiong we poke the board with an interrupt.  */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Interrupting board to start slave image\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|memfd
argument_list|,
name|STL_BINTR
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"ioctl(STL_BINTR) failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strttime
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Waiting for slave alive marker, time=%x timeout=%d\n"
argument_list|,
name|strttime
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
while|while
condition|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|<
operator|(
name|strttime
operator|+
name|TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
name|CDK_RDYADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|CDK_RDYADDR
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory device"
argument_list|,
name|CDK_RDYADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|memfd
argument_list|,
operator|&
name|alivemarker
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read of image file failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|alivemarker
operator|==
name|CDK_ALIVEMARKER
condition|)
break|break;
block|}
if|if
condition|(
name|alivemarker
operator|!=
name|CDK_ALIVEMARKER
condition|)
block|{
name|warnx
argument_list|(
literal|"slave image failed to start"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|memfd
argument_list|,
name|CDK_RDYADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|CDK_RDYADDR
condition|)
block|{
name|warn
argument_list|(
literal|"lseek(%x) failed on memory device"
argument_list|,
name|CDK_RDYADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alivemarker
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|memfd
argument_list|,
operator|&
name|alivemarker
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"write to memory device failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Slave image started successfully\n"
argument_list|)
expr_stmt|;
comment|/*  *	The last thing to do now is to get the driver started. Now that the  *	slave is operational it must read in the memory map and gets its  *	internal tables initialized.  */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Driver initializing host shared memory interface\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|memfd
argument_list|,
name|STL_BSTART
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"ioctl(STL_BSTART) failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|memfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|stat
name|statinfo
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hvVRB:i:b:c:t:r:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'V'
case|:
name|printf
argument_list|(
literal|"stlload version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|feature
operator|.
name|banner
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|image
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|reset
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|brdnr
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|memdevice
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|feature
operator|.
name|txrqsize
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|feature
operator|.
name|rxrqsize
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|memdevice
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|brdnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|brdnr
operator|>=
literal|8
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid board number %d specified"
argument_list|,
name|brdnr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|devstr
argument_list|,
name|defdevice
argument_list|,
name|brdnr
argument_list|)
expr_stmt|;
name|memdevice
operator|=
operator|&
name|devstr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Using shared memory device %s\n"
argument_list|,
name|memdevice
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Downloading image %s to board %d\n"
argument_list|,
name|image
argument_list|,
name|brdnr
argument_list|)
expr_stmt|;
comment|/*  *	Check that the shared memory device exits and is a character device.  */
if|if
condition|(
name|stat
argument_list|(
name|memdevice
argument_list|,
operator|&
name|statinfo
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"memory device %s does not exist"
argument_list|,
name|memdevice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|statinfo
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"memory device %s is not a char device"
argument_list|,
name|memdevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|image
argument_list|,
operator|&
name|statinfo
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"image file %s does not exist"
argument_list|,
name|image
argument_list|)
expr_stmt|;
comment|/*  *	All argument checking is now done. So lets get this show on the road.  */
if|if
condition|(
name|download
argument_list|()
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

end_unit

