begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: route6d.c,v 1.64 2001/05/08 04:36:37 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|_rcsid
index|[]
init|=
literal|"$KAME: route6d.c,v 1.64 2001/05/08 04:36:37 itojun Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__>= 3 */
end_comment

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"route6d.h"
end_include

begin_define
define|#
directive|define
name|MAXFILTER
value|40
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|INIT_INTERVAL6
value|6
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INIT_INTERVAL6
value|10
end_define

begin_comment
comment|/* Wait to submit an initial riprequest. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alignment constraint for routing socket */
end_comment

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
end_define

begin_define
define|#
directive|define
name|ADVANCE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(x += ROUNDUP((n)->sa_len))
end_define

begin_comment
comment|/*  * Following two macros are highly depending on KAME Release  */
end_comment

begin_define
define|#
directive|define
name|IN6_LINKLOCAL_IFINDEX
parameter_list|(
name|addr
parameter_list|)
define|\
value|((addr).s6_addr[2]<< 8 | (addr).s6_addr[3])
end_define

begin_define
define|#
directive|define
name|SET_IN6_LINKLOCAL_IFINDEX
parameter_list|(
name|addr
parameter_list|,
name|index
parameter_list|)
define|\
value|do { \ 		(addr).s6_addr[2] = ((index)>> 8)& 0xff; \ 		(addr).s6_addr[3] = (index)& 0xff; \ 	} while (0)
end_define

begin_struct
struct|struct
name|ifc
block|{
comment|/* Configuration of an interface */
name|char
modifier|*
name|ifc_name
decl_stmt|;
comment|/* if name */
name|struct
name|ifc
modifier|*
name|ifc_next
decl_stmt|;
name|int
name|ifc_index
decl_stmt|;
comment|/* if index */
name|int
name|ifc_mtu
decl_stmt|;
comment|/* if mtu */
name|int
name|ifc_metric
decl_stmt|;
comment|/* if metric */
name|u_int
name|ifc_flags
decl_stmt|;
comment|/* flags */
name|short
name|ifc_cflags
decl_stmt|;
comment|/* IFC_XXX */
name|struct
name|in6_addr
name|ifc_mylladdr
decl_stmt|;
comment|/* my link-local address */
name|struct
name|sockaddr_in6
name|ifc_ripsin
decl_stmt|;
comment|/* rip multicast address */
name|struct
name|iff
modifier|*
name|ifc_filter
decl_stmt|;
comment|/* filter structure */
name|struct
name|ifac
modifier|*
name|ifc_addr
decl_stmt|;
comment|/* list of AF_INET6 addresses */
name|int
name|ifc_joined
decl_stmt|;
comment|/* joined to ff02::9 */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ifac
block|{
comment|/* Adddress associated to an interface */
name|struct
name|ifc
modifier|*
name|ifa_conf
decl_stmt|;
comment|/* back pointer */
name|struct
name|ifac
modifier|*
name|ifa_next
decl_stmt|;
name|struct
name|in6_addr
name|ifa_addr
decl_stmt|;
comment|/* address */
name|struct
name|in6_addr
name|ifa_raddr
decl_stmt|;
comment|/* remote address, valid in p2p */
name|int
name|ifa_plen
decl_stmt|;
comment|/* prefix length */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iff
block|{
name|int
name|iff_type
decl_stmt|;
name|struct
name|in6_addr
name|iff_addr
decl_stmt|;
name|int
name|iff_plen
decl_stmt|;
name|struct
name|iff
modifier|*
name|iff_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|ifc
modifier|*
name|ifc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nifc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid ifc's */
end_comment

begin_decl_stmt
name|struct
name|ifc
modifier|*
modifier|*
name|index2ifc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nindex2ifc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifc
modifier|*
name|loopifcp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointing to loopback */
end_comment

begin_decl_stmt
name|int
name|loopifindex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ditto */
end_comment

begin_decl_stmt
name|fd_set
name|sockvec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vector to select() for receiving */
end_comment

begin_decl_stmt
name|int
name|rtsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the routing socket */
end_comment

begin_decl_stmt
name|int
name|ripsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket to send/receive RIP datagram */
end_comment

begin_decl_stmt
name|struct
name|rip6
modifier|*
name|ripbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet buffer for sending */
end_comment

begin_comment
comment|/*  * Maintain the routes in a linked list.  When the number of the routes  * grows, somebody would like to introduce a hash based or a radix tree  * based structure.  I believe the number of routes handled by RIP is  * limited and I don't have to manage a complex data structure, however.  *  * One of the major drawbacks of the linear linked list is the difficulty  * of representing the relationship between a couple of routes.  This may  * be a significant problem when we have to support route aggregation with  * supressing the specifices covered by the aggregate.  */
end_comment

begin_struct
struct|struct
name|riprt
block|{
name|struct
name|riprt
modifier|*
name|rrt_next
decl_stmt|;
comment|/* next destination */
name|struct
name|riprt
modifier|*
name|rrt_same
decl_stmt|;
comment|/* same destination - future use */
name|struct
name|netinfo6
name|rrt_info
decl_stmt|;
comment|/* network info */
name|struct
name|in6_addr
name|rrt_gw
decl_stmt|;
comment|/* gateway */
name|u_long
name|rrt_flags
decl_stmt|;
comment|/* kernel routing table flags */
name|u_long
name|rrt_rflags
decl_stmt|;
comment|/* route6d routing table flags */
name|time_t
name|rrt_t
decl_stmt|;
comment|/* when the route validated */
name|int
name|rrt_index
decl_stmt|;
comment|/* ifindex from which this route got */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|riprt
modifier|*
name|riprt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag */
end_comment

begin_decl_stmt
name|int
name|qflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* quiet flag */
end_comment

begin_decl_stmt
name|int
name|nflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't update kernel routing table */
end_comment

begin_decl_stmt
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* age out even the statically defined routes */
end_comment

begin_decl_stmt
name|int
name|hflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't split horizon */
end_comment

begin_decl_stmt
name|int
name|lflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exchange site local routes */
end_comment

begin_decl_stmt
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* announce static routes w/ split horizon */
end_comment

begin_decl_stmt
name|int
name|Sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* announce static routes to every interface */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|routetag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* route tag attached on originating case */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filter
index|[
name|MAXFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filtertype
index|[
name|MAXFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfilter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pid_t
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_storage
name|ripsin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtentry
name|rtentry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|nextalarm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|sup_trig_update
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rtlog
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logopened
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|seq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|seenalrm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|seenquit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|seenusr1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RRTF_AGGREGATE
value|0x08000000
end_define

begin_define
define|#
directive|define
name|RRTF_NOADVERTISE
value|0x10000000
end_define

begin_define
define|#
directive|define
name|RRTF_NH_NOT_LLADDR
value|0x20000000
end_define

begin_define
define|#
directive|define
name|RRTF_SENDANYWAY
value|0x40000000
end_define

begin_define
define|#
directive|define
name|RRTF_CHANGED
value|0x80000000
end_define

begin_decl_stmt
name|int
decl|main
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sighandler
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ripalarm
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|riprecv
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ripsend
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|out_filter
name|__P
argument_list|(
operator|(
expr|struct
name|riprt
operator|*
operator|,
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sockopt
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ifconfig
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ifconfig1
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|ifc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rtrecv
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rt_del
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|,
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|,
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rt_deladdr
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|,
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|filterconfig
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|getifmtu
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rttypes
name|__P
argument_list|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rtflags
name|__P
argument_list|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ifflags
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ifrt
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ifrt_p2p
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|applymask
name|__P
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|,
expr|struct
name|in6_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|applyplen
name|__P
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ifrtdump
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ifdump
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ifdump0
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rtdump
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rt_entry
name|__P
argument_list|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rtdexit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|riprequest
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
expr|struct
name|netinfo6
operator|*
operator|,
name|int
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ripflush
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sendrequest
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sin6mask2len
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mask2len
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|in6_addr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sendpacket
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|addroute
name|__P
argument_list|(
operator|(
expr|struct
name|riprt
operator|*
operator|,
specifier|const
expr|struct
name|in6_addr
operator|*
operator|,
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delroute
name|__P
argument_list|(
operator|(
expr|struct
name|netinfo6
operator|*
operator|,
expr|struct
name|in6_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_addr
modifier|*
name|getroute
name|__P
argument_list|(
operator|(
expr|struct
name|netinfo6
operator|*
operator|,
expr|struct
name|in6_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|krtread
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tobeadv
name|__P
argument_list|(
operator|(
expr|struct
name|riprt
operator|*
operator|,
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|allocopy
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hms
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|inet6_n2p
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|in6_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifac
modifier|*
name|ifa_match
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|ifc
operator|*
operator|,
specifier|const
expr|struct
name|in6_addr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_addr
modifier|*
name|plen2mask
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|riprt
modifier|*
name|rtsearch
name|__P
argument_list|(
operator|(
expr|struct
name|netinfo6
operator|*
operator|,
expr|struct
name|riprt
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ripinterval
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|ripsuptrig
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|trace
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tracet
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|if_maxindex
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifc
modifier|*
name|ifc_find
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iff
modifier|*
name|iff_find
name|__P
argument_list|(
operator|(
expr|struct
name|ifc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|setindex2ifc
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|ifc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MALLOC
parameter_list|(
name|type
parameter_list|)
value|((type *)malloc(sizeof(type)))
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|FILE
modifier|*
name|pidfile
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
operator|*
name|argv
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"A:N:O:R:T:L:t:adDhlnqsS"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'T'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|nfilter
operator|>=
name|MAXFILTER
condition|)
block|{
name|fatal
argument_list|(
literal|"Exceeds MAXFILTER"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|filtertype
index|[
name|nfilter
index|]
operator|=
name|ch
expr_stmt|;
name|filter
index|[
name|nfilter
operator|++
index|]
operator|=
name|allocopy
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ep
operator|=
name|NULL
expr_stmt|;
name|routetag
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
operator|(
name|routetag
operator|&
operator|~
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"invalid route tag"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
operator|(
name|rtlog
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"Can not write to routelog"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
break|break;
define|#
directive|define
name|FLAG
parameter_list|(
name|c
parameter_list|,
name|flag
parameter_list|,
name|n
parameter_list|)
value|case c: do { flag = n; break; } while(0)
name|FLAG
argument_list|(
literal|'a'
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'d'
argument_list|,
name|dflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'D'
argument_list|,
name|dflag
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'h'
argument_list|,
name|hflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'l'
argument_list|,
name|lflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'n'
argument_list|,
name|nflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'q'
argument_list|,
name|qflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'s'
argument_list|,
name|sflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
name|FLAG
argument_list|(
literal|'S'
argument_list|,
name|Sflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|FLAG
default|default:
name|fatal
argument_list|(
literal|"Invalid option specified, terminating"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"bogus extra arguments"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|geteuid
argument_list|()
condition|)
block|{
name|nflag
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No kernel update is allowed\n"
argument_list|)
expr_stmt|;
block|}
name|openlog
argument_list|(
name|progname
argument_list|,
name|LOG_NDELAY
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|logopened
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ripbuf
operator|=
operator|(
expr|struct
name|rip6
operator|*
operator|)
name|malloc
argument_list|(
name|RIP6_MAXMTU
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ripbuf
argument_list|,
literal|0
argument_list|,
name|RIP6_MAXMTU
argument_list|)
expr_stmt|;
name|ripbuf
operator|->
name|rip6_cmd
operator|=
name|RIP6_RESPONSE
expr_stmt|;
name|ripbuf
operator|->
name|rip6_vers
operator|=
name|RIP6_VERSION
expr_stmt|;
name|ripbuf
operator|->
name|rip6_res1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ripbuf
operator|->
name|rip6_res1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|ifconfig
argument_list|()
expr_stmt|;
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_index
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No ifindex found at %s (no link-local address?)\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|loopifcp
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"No loopback found"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|sranddev
argument_list|()
expr_stmt|;
else|#
directive|else
name|srand
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|pid
operator|<<
literal|16
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loopifindex
operator|=
name|loopifcp
operator|->
name|ifc_index
expr_stmt|;
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
name|ifrt
argument_list|(
name|ifcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filterconfig
argument_list|()
expr_stmt|;
name|krtread
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|ifrtdump
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|1
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"daemon"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"setid"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pidfile
operator|=
name|fopen
argument_list|(
name|ROUTE6D_PID
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|pidfile
argument_list|,
literal|"%d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ripbuf
operator|=
operator|(
expr|struct
name|rip6
operator|*
operator|)
name|malloc
argument_list|(
name|RIP6_MAXMTU
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|ripbuf
argument_list|,
literal|0
argument_list|,
name|RIP6_MAXMTU
argument_list|)
expr_stmt|;
name|ripbuf
operator|->
name|rip6_cmd
operator|=
name|RIP6_RESPONSE
expr_stmt|;
name|ripbuf
operator|->
name|rip6_vers
operator|=
name|RIP6_VERSION
expr_stmt|;
name|ripbuf
operator|->
name|rip6_res1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ripbuf
operator|->
name|rip6_res1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sighandler
argument_list|)
operator|==
name|SIG_ERR
operator|||
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sighandler
argument_list|)
operator|==
name|SIG_ERR
operator|||
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sighandler
argument_list|)
operator|==
name|SIG_ERR
operator|||
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|sighandler
argument_list|)
operator|==
name|SIG_ERR
operator|||
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighandler
argument_list|)
operator|==
name|SIG_ERR
operator|||
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sighandler
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|fatal
argument_list|(
literal|"signal"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * To avoid rip packet congestion (not on a cable but in this 	 * process), wait for a moment to send the first RIP6_RESPONSE 	 * packets. 	 */
name|alarm
argument_list|(
name|ripinterval
argument_list|(
name|INIT_INTERVAL6
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_index
operator|>
literal|0
operator|&&
operator|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_UP
operator|)
condition|)
name|sendrequest
argument_list|(
name|ifcp
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"**** Started ****"
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fd_set
name|recvec
decl_stmt|;
if|if
condition|(
name|seenalrm
condition|)
block|{
name|ripalarm
argument_list|()
expr_stmt|;
name|seenalrm
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|seenquit
condition|)
block|{
name|rtdexit
argument_list|()
expr_stmt|;
name|seenquit
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|seenusr1
condition|)
block|{
name|ifrtdump
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
name|seenusr1
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|FD_COPY
argument_list|(
operator|&
name|sockvec
argument_list|,
operator|&
name|recvec
argument_list|)
expr_stmt|;
name|signo
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|recvec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|fatal
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
continue|continue;
case|case
literal|0
case|:
continue|continue;
default|default:
if|if
condition|(
name|FD_ISSET
argument_list|(
name|ripsock
argument_list|,
operator|&
name|recvec
argument_list|)
condition|)
block|{
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|riprecv
argument_list|()
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|rtsock
argument_list|,
operator|&
name|recvec
argument_list|)
condition|)
block|{
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|rtrecv
argument_list|()
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sighandler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signo
operator|=
name|sig
expr_stmt|;
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGALRM
case|:
name|seenalrm
operator|++
expr_stmt|;
break|break;
case|case
name|SIGQUIT
case|:
case|case
name|SIGTERM
case|:
name|seenquit
operator|++
expr_stmt|;
break|break;
case|case
name|SIGUSR1
case|:
case|case
name|SIGHUP
case|:
case|case
name|SIGINT
case|:
name|seenusr1
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * gracefully exits after resetting sockopts.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|rtdexit
parameter_list|()
block|{
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_AGGREGATE
condition|)
block|{
name|delroute
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|ripsock
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rtsock
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"**** Terminated ****"
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called periodically:  *	1. age out the learned route. remove it if necessary.  *	2. submit RIP6_RESPONSE packets.  * Invoked in every SUPPLY_INTERVAL6 (30) seconds.  I believe we don't have  * to invoke this function in every 1 or 5 or 10 seconds only to age the  * routes more precisely.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ripalarm
parameter_list|()
block|{
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|,
modifier|*
name|rrt_prev
decl_stmt|,
modifier|*
name|rrt_next
decl_stmt|;
name|time_t
name|t_lifetime
decl_stmt|,
name|t_holddown
decl_stmt|;
comment|/* age the RIP routes */
name|rrt_prev
operator|=
literal|0
expr_stmt|;
name|t_lifetime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|RIP_LIFETIME
expr_stmt|;
name|t_holddown
operator|=
name|t_lifetime
operator|-
name|RIP_HOLDDOWN
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt_next
control|)
block|{
name|rrt_next
operator|=
name|rrt
operator|->
name|rrt_next
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|==
literal|0
condition|)
block|{
name|rrt_prev
operator|=
name|rrt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|<
name|t_holddown
condition|)
block|{
if|if
condition|(
name|rrt_prev
condition|)
block|{
name|rrt_prev
operator|->
name|rrt_next
operator|=
name|rrt
operator|->
name|rrt_next
expr_stmt|;
block|}
else|else
block|{
name|riprt
operator|=
name|rrt
operator|->
name|rrt_next
expr_stmt|;
block|}
name|delroute
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|<
name|t_lifetime
condition|)
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
name|rrt_prev
operator|=
name|rrt
expr_stmt|;
block|}
comment|/* Supply updates */
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_index
operator|>
literal|0
operator|&&
operator|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_UP
operator|)
condition|)
name|ripsend
argument_list|(
name|ifcp
argument_list|,
operator|&
name|ifcp
operator|->
name|ifc_ripsin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
name|ripinterval
argument_list|(
name|SUPPLY_INTERVAL6
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init
parameter_list|()
block|{
name|int
name|error
decl_stmt|;
specifier|const
name|int
name|int0
init|=
literal|0
decl_stmt|,
name|int1
init|=
literal|1
decl_stmt|,
name|int255
init|=
literal|255
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|char
name|port
index|[
literal|10
index|]
decl_stmt|;
name|ifc
operator|=
operator|(
expr|struct
name|ifc
operator|*
operator|)
name|NULL
expr_stmt|;
name|nifc
operator|=
literal|0
expr_stmt|;
name|nindex2ifc
operator|=
literal|0
expr_stmt|;
comment|/*initial guess*/
name|index2ifc
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|port
argument_list|,
sizeof|sizeof
argument_list|(
name|port
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|RIP6_PORT
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|res
operator|->
name|ai_next
condition|)
block|{
name|fatal
argument_list|(
literal|":: resolved to multiple address"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|ripsock
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ripsock
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip socket"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|setsockopt
argument_list|(
name|ripsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|&
name|int1
argument_list|,
sizeof|sizeof
argument_list|(
name|int1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip IPV6_V6ONLY"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|ripsock
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip bind"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|ripsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_HOPS
argument_list|,
operator|&
name|int255
argument_list|,
sizeof|sizeof
argument_list|(
name|int255
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip IPV6_MULTICAST_HOPS"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|ripsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_LOOP
argument_list|,
operator|&
name|int0
argument_list|,
sizeof|sizeof
argument_list|(
name|int0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip IPV6_MULTICAST_LOOP"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
ifdef|#
directive|ifdef
name|IPV6_RECVPKTINFO
if|if
condition|(
name|setsockopt
argument_list|(
name|ripsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|&
name|int1
argument_list|,
sizeof|sizeof
argument_list|(
name|int1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip IPV6_RECVPKTINFO"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* old adv. API */
if|if
condition|(
name|setsockopt
argument_list|(
name|ripsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTINFO
argument_list|,
operator|&
name|int1
argument_list|,
sizeof|sizeof
argument_list|(
name|int1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"rip IPV6_PKTINFO"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|RIP6_DEST
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|res
operator|->
name|ai_next
condition|)
block|{
name|fatal
argument_list|(
literal|"%s resolved to multiple address"
argument_list|,
name|RIP6_DEST
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memcpy
argument_list|(
operator|&
name|ripsin
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FD_ZERO
name|FD_ZERO
argument_list|(
operator|&
name|sockvec
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|sockvec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sockvec
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_SET
argument_list|(
name|ripsock
argument_list|,
operator|&
name|sockvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rtsock
operator|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"route socket"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|FD_SET
argument_list|(
name|rtsock
argument_list|,
operator|&
name|sockvec
argument_list|)
expr_stmt|;
block|}
else|else
name|rtsock
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*just for safety */
block|}
end_function

begin_define
define|#
directive|define
name|RIPSIZE
parameter_list|(
name|n
parameter_list|)
define|\
value|(sizeof(struct rip6) + ((n)-1) * sizeof(struct netinfo6))
end_define

begin_comment
comment|/*  * ripflush flushes the rip datagram stored in the rip buffer  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ripflush
parameter_list|(
name|ifcp
parameter_list|,
name|sin6
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ifcp
condition|)
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"Send(%s): info(%d) to %s.%d\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|nrt
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"Send: info(%d) to %s.%d\n"
argument_list|,
name|nrt
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|>=
literal|2
condition|)
block|{
name|np
operator|=
name|ripbuf
operator|->
name|rip6_nets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrt
condition|;
name|i
operator|++
operator|,
name|np
operator|++
control|)
block|{
if|if
condition|(
name|np
operator|->
name|rip6_metric
operator|==
name|NEXTHOP_METRIC
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
name|trace
argument_list|(
literal|2
argument_list|,
literal|"    NextHop reset"
argument_list|)
expr_stmt|;
else|else
block|{
name|trace
argument_list|(
literal|2
argument_list|,
literal|"    NextHop %s"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|trace
argument_list|(
literal|2
argument_list|,
literal|"    %s/%d[%d]"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|np
operator|->
name|rip6_metric
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|rip6_tag
condition|)
block|{
name|trace
argument_list|(
literal|2
argument_list|,
literal|"  tag=0x%04x"
argument_list|,
name|ntohs
argument_list|(
name|np
operator|->
name|rip6_tag
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
name|trace
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sendpacket
argument_list|(
name|sin6
argument_list|,
name|RIPSIZE
argument_list|(
name|nrt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAFNOSUPPORT
condition|)
block|{
comment|/* Protocol not supported */
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"Could not send info to %s (%s): "
literal|"set IFF_UP to 0\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_ripsin
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
comment|/* As if down for AF_INET6 */
block|}
name|nrt
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|ripbuf
operator|->
name|rip6_nets
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate RIP6_RESPONSE packets and send them.  */
end_comment

begin_function
name|void
name|ripsend
parameter_list|(
name|ifcp
parameter_list|,
name|sin6
parameter_list|,
name|flag
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|nh
decl_stmt|;
comment|/* next hop */
name|int
name|maxrte
decl_stmt|;
if|if
condition|(
name|ifcp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Request from non-link local address is not 		 * a regular route6d update. 		 */
name|maxrte
operator|=
operator|(
name|IFMINMTU
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
expr_stmt|;
name|nrt
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|ripbuf
operator|->
name|rip6_nets
expr_stmt|;
name|nh
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_NOADVERTISE
condition|)
continue|continue;
comment|/* Put the route to the buffer */
operator|*
name|np
operator|=
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|np
operator|++
expr_stmt|;
name|nrt
operator|++
expr_stmt|;
if|if
condition|(
name|nrt
operator|==
name|maxrte
condition|)
block|{
name|ripflush
argument_list|(
name|NULL
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|nh
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrt
condition|)
comment|/* Send last packet */
name|ripflush
argument_list|(
name|NULL
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|RRTF_SENDANYWAY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|qflag
operator|||
operator|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|)
condition|)
return|return;
comment|/* -N: no use */
if|if
condition|(
name|iff_find
argument_list|(
name|ifcp
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* -T: generate default route only */
if|if
condition|(
name|iff_find
argument_list|(
name|ifcp
argument_list|,
literal|'T'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|netinfo6
name|rrt_info
decl_stmt|;
name|memset
argument_list|(
operator|&
name|rrt_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
argument_list|)
expr_stmt|;
name|rrt_info
operator|.
name|rip6_dest
operator|=
name|in6addr_any
expr_stmt|;
name|rrt_info
operator|.
name|rip6_plen
operator|=
literal|0
expr_stmt|;
name|rrt_info
operator|.
name|rip6_metric
operator|=
literal|1
expr_stmt|;
name|rrt_info
operator|.
name|rip6_metric
operator|+=
name|ifcp
operator|->
name|ifc_metric
expr_stmt|;
name|rrt_info
operator|.
name|rip6_tag
operator|=
name|htons
argument_list|(
name|routetag
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|np
operator|=
name|ripbuf
operator|->
name|rip6_nets
expr_stmt|;
operator|*
name|np
operator|=
name|rrt_info
expr_stmt|;
name|nrt
operator|=
literal|1
expr_stmt|;
name|ripflush
argument_list|(
name|ifcp
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
return|return;
block|}
name|maxrte
operator|=
operator|(
name|ifcp
operator|->
name|ifc_mtu
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
expr_stmt|;
name|nrt
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|ripbuf
operator|->
name|rip6_nets
expr_stmt|;
name|nh
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_NOADVERTISE
condition|)
continue|continue;
comment|/* Need to check filter here */
if|if
condition|(
name|out_filter
argument_list|(
name|rrt
argument_list|,
name|ifcp
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Check split horizon and other conditions */
if|if
condition|(
name|tobeadv
argument_list|(
name|rrt
argument_list|,
name|ifcp
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Only considers the routes with flag if specified */
if|if
condition|(
operator|(
name|flag
operator|&
name|RRTF_CHANGED
operator|)
operator|&&
operator|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_CHANGED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Check nexthop */
if|if
condition|(
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
operator|&&
operator|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_NH_NOT_LLADDR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nh
operator|==
name|NULL
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
name|nh
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
condition|)
block|{
if|if
condition|(
name|nrt
operator|==
name|maxrte
operator|-
literal|2
condition|)
name|ripflush
argument_list|(
name|ifcp
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|np
operator|->
name|rip6_dest
operator|=
name|rrt
operator|->
name|rrt_gw
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
name|SET_IN6_LINKLOCAL_IFINDEX
argument_list|(
name|np
operator|->
name|rip6_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|rip6_plen
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rip6_tag
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rip6_metric
operator|=
name|NEXTHOP_METRIC
expr_stmt|;
name|nh
operator|=
operator|&
name|rrt
operator|->
name|rrt_gw
expr_stmt|;
name|np
operator|++
expr_stmt|;
name|nrt
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nh
operator|&&
operator|(
name|rrt
operator|->
name|rrt_index
operator|!=
name|ifcp
operator|->
name|ifc_index
operator|||
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
name|nh
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
operator|||
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_NH_NOT_LLADDR
operator|)
condition|)
block|{
comment|/* Reset nexthop */
if|if
condition|(
name|nrt
operator|==
name|maxrte
operator|-
literal|2
condition|)
name|ripflush
argument_list|(
name|ifcp
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|rip6_metric
operator|=
name|NEXTHOP_METRIC
expr_stmt|;
name|nh
operator|=
name|NULL
expr_stmt|;
name|np
operator|++
expr_stmt|;
name|nrt
operator|++
expr_stmt|;
block|}
comment|/* Put the route to the buffer */
operator|*
name|np
operator|=
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|np
operator|++
expr_stmt|;
name|nrt
operator|++
expr_stmt|;
if|if
condition|(
name|nrt
operator|==
name|maxrte
condition|)
block|{
name|ripflush
argument_list|(
name|ifcp
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|nh
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrt
condition|)
comment|/* Send last packet */
name|ripflush
argument_list|(
name|ifcp
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * outbound filter logic, per-route/interface.  */
end_comment

begin_function
name|int
name|out_filter
parameter_list|(
name|rrt
parameter_list|,
name|ifcp
parameter_list|)
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
block|{
name|struct
name|iff
modifier|*
name|iffp
decl_stmt|;
name|struct
name|in6_addr
name|ia
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* 	 * -A: filter out less specific routes, if we have aggregated 	 * route configured. 	 */
for|for
control|(
name|iffp
operator|=
name|ifcp
operator|->
name|ifc_filter
init|;
name|iffp
condition|;
name|iffp
operator|=
name|iffp
operator|->
name|iff_next
control|)
block|{
if|if
condition|(
name|iffp
operator|->
name|iff_type
operator|!=
literal|'A'
condition|)
continue|continue;
if|if
condition|(
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|<=
name|iffp
operator|->
name|iff_plen
condition|)
continue|continue;
name|ia
operator|=
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ia
argument_list|,
name|iffp
operator|->
name|iff_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ia
argument_list|,
operator|&
name|iffp
operator|->
name|iff_addr
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* 	 * if it is an aggregated route, advertise it only to the 	 * interfaces specified on -A. 	 */
if|if
condition|(
operator|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_AGGREGATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|iffp
operator|=
name|ifcp
operator|->
name|ifc_filter
init|;
name|iffp
condition|;
name|iffp
operator|=
name|iffp
operator|->
name|iff_next
control|)
block|{
if|if
condition|(
name|iffp
operator|->
name|iff_type
operator|!=
literal|'A'
condition|)
continue|continue;
if|if
condition|(
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|==
name|iffp
operator|->
name|iff_plen
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|,
operator|&
name|iffp
operator|->
name|iff_addr
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
block|}
comment|/* 	 * -O: advertise only if prefix matches the configured prefix. 	 */
if|if
condition|(
name|iff_find
argument_list|(
name|ifcp
argument_list|,
literal|'O'
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|iffp
operator|=
name|ifcp
operator|->
name|ifc_filter
init|;
name|iffp
condition|;
name|iffp
operator|=
name|iffp
operator|->
name|iff_next
control|)
block|{
if|if
condition|(
name|iffp
operator|->
name|iff_type
operator|!=
literal|'O'
condition|)
continue|continue;
if|if
condition|(
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|<
name|iffp
operator|->
name|iff_plen
condition|)
continue|continue;
name|ia
operator|=
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ia
argument_list|,
name|iffp
operator|->
name|iff_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ia
argument_list|,
operator|&
name|iffp
operator|->
name|iff_addr
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
block|}
comment|/* the prefix should be advertised */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the route is to be advertised on the specified interface.  * It checks options specified in the arguments and the split horizon rule.  */
end_comment

begin_function
name|int
name|tobeadv
parameter_list|(
name|rrt
parameter_list|,
name|ifcp
parameter_list|)
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
block|{
comment|/* Special care for static routes */
if|if
condition|(
name|rrt
operator|->
name|rrt_flags
operator|&
name|RTF_STATIC
condition|)
block|{
comment|/* XXX don't advertise reject/blackhole routes */
if|if
condition|(
name|rrt
operator|->
name|rrt_flags
operator|&
operator|(
name|RTF_REJECT
operator||
name|RTF_BLACKHOLE
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Sflag
condition|)
comment|/* Yes, advertise it anyway */
return|return
literal|1
return|;
if|if
condition|(
name|sflag
operator|&&
name|rrt
operator|->
name|rrt_index
operator|!=
name|ifcp
operator|->
name|ifc_index
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* Regular split horizon */
if|if
condition|(
name|hflag
operator|==
literal|0
operator|&&
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Send a rip packet actually.  */
end_comment

begin_function
name|int
name|sendpacket
parameter_list|(
name|sin6
parameter_list|,
name|len
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* 	 * MSG_DONTROUTE should not be specified when it responds with a 	 * RIP6_REQUEST message.  SO_DONTROUTE has been specified to 	 * other sockets. 	 */
name|struct
name|msghdr
name|m
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|cmsgbuf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|sockaddr_in6
name|sincopy
decl_stmt|;
comment|/* do not overwrite the given sin */
name|sincopy
operator|=
operator|*
name|sin6
expr_stmt|;
name|sin6
operator|=
operator|&
name|sincopy
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|idx
operator|=
name|IN6_LINKLOCAL_IFINDEX
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
name|SET_IN6_LINKLOCAL_IFINDEX
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|idx
operator|=
literal|0
expr_stmt|;
name|m
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
name|sin6
expr_stmt|;
name|m
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|ripbuf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|m
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|m
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|idx
condition|)
block|{
name|m
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|m
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|cmsgbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmsgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|cmsgbuf
expr_stmt|;
name|m
operator|.
name|msg_control
operator|=
operator|(
name|caddr_t
operator|)
name|cm
expr_stmt|;
name|m
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cm
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|pi
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pi
operator|->
name|ipi6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|ipi6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/*::*/
name|pi
operator|->
name|ipi6_ifindex
operator|=
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|sendmsg
argument_list|(
name|ripsock
argument_list|,
operator|&
name|m
argument_list|,
literal|0
comment|/*MSG_DONTROUTE*/
argument_list|)
operator|<
literal|0
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"sendmsg: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Receive and process RIP packets.  Update the routes/kernel forwarding  * table if necessary.  */
end_comment

begin_function
name|void
name|riprecv
parameter_list|()
block|{
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|,
modifier|*
name|ic
decl_stmt|;
name|struct
name|sockaddr_in6
name|fsock
decl_stmt|;
name|struct
name|in6_addr
name|nh
decl_stmt|;
comment|/* next hop */
name|struct
name|rip6
modifier|*
name|rp
decl_stmt|;
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|,
modifier|*
name|nq
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nn
decl_stmt|,
name|need_trigger
decl_stmt|,
name|idx
decl_stmt|;
name|char
name|buf
index|[
literal|4
operator|*
name|RIP6_MAXMTU
index|]
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|msghdr
name|m
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|cmsgbuf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|iff
modifier|*
name|iffp
decl_stmt|;
name|struct
name|in6_addr
name|ia
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|time_t
name|t_half_lifetime
decl_stmt|;
name|need_trigger
operator|=
literal|0
expr_stmt|;
name|m
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|fsock
expr_stmt|;
name|m
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|fsock
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|m
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|m
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|cmsgbuf
expr_stmt|;
name|m
operator|.
name|msg_control
operator|=
operator|(
name|caddr_t
operator|)
name|cm
expr_stmt|;
name|m
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|cmsgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|recvmsg
argument_list|(
name|ripsock
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"recvmsg"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|m
argument_list|)
init|;
name|cm
condition|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|CMSG_NXTHDR
argument_list|(
operator|&
name|m
argument_list|,
name|cm
argument_list|)
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|IPV6_PKTINFO
condition|)
block|{
name|pi
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
operator|(
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
operator|)
expr_stmt|;
name|idx
operator|=
name|pi
operator|->
name|ipi6_ifindex
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|fsock
operator|.
name|sin6_addr
argument_list|)
condition|)
name|SET_IN6_LINKLOCAL_IFINDEX
argument_list|(
name|fsock
operator|.
name|sin6_addr
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|nh
operator|=
name|fsock
operator|.
name|sin6_addr
expr_stmt|;
name|nn
operator|=
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|rip6
operator|*
operator|)
name|buf
expr_stmt|;
name|np
operator|=
name|rp
operator|->
name|rip6_nets
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rip6_vers
operator|!=
name|RIP6_VERSION
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"Incorrect RIP version %d\n"
argument_list|,
name|rp
operator|->
name|rip6_vers
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rp
operator|->
name|rip6_cmd
operator|==
name|RIP6_REQUEST
condition|)
block|{
if|if
condition|(
name|idx
operator|&&
name|idx
operator|<
name|nindex2ifc
condition|)
block|{
name|ifcp
operator|=
name|index2ifc
index|[
name|idx
index|]
expr_stmt|;
name|riprequest
argument_list|(
name|ifcp
argument_list|,
name|np
argument_list|,
name|nn
argument_list|,
operator|&
name|fsock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|riprequest
argument_list|(
name|NULL
argument_list|,
name|np
argument_list|,
name|nn
argument_list|,
operator|&
name|fsock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|fsock
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"Packets from non-ll addr: %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|fsock
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* Ignore packets from non-link-local addr */
block|}
name|idx
operator|=
name|IN6_LINKLOCAL_IFINDEX
argument_list|(
name|fsock
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
name|ifcp
operator|=
operator|(
name|idx
operator|<
name|nindex2ifc
operator|)
condition|?
name|index2ifc
index|[
name|idx
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ifcp
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"Packets to unknown interface index %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return;
comment|/* Ignore it */
block|}
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_mylladdr
argument_list|,
operator|&
name|fsock
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return;
comment|/* The packet is from me; ignore */
if|if
condition|(
name|rp
operator|->
name|rip6_cmd
operator|!=
name|RIP6_RESPONSE
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"Invalid command %d\n"
argument_list|,
name|rp
operator|->
name|rip6_cmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* -N: no use */
if|if
condition|(
name|iff_find
argument_list|(
name|ifcp
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"Recv(%s): from %s.%d info(%d)\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|nh
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|fsock
operator|.
name|sin6_port
argument_list|)
argument_list|,
name|nn
argument_list|)
expr_stmt|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|t_half_lifetime
operator|=
name|t
operator|-
operator|(
name|RIP_LIFETIME
operator|/
literal|2
operator|)
expr_stmt|;
for|for
control|(
init|;
name|nn
condition|;
name|nn
operator|--
operator|,
name|np
operator|++
control|)
block|{
if|if
condition|(
name|np
operator|->
name|rip6_metric
operator|==
name|NEXTHOP_METRIC
condition|)
block|{
comment|/* modify neighbor address */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
block|{
name|nh
operator|=
name|np
operator|->
name|rip6_dest
expr_stmt|;
name|SET_IN6_LINKLOCAL_IFINDEX
argument_list|(
name|nh
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tNexthop: %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|nh
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
block|{
name|nh
operator|=
name|fsock
operator|.
name|sin6_addr
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tNexthop: %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|nh
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nh
operator|=
name|fsock
operator|.
name|sin6_addr
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tInvalid Nexthop: %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tMulticast netinfo6: %s/%d [%d]\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|np
operator|->
name|rip6_metric
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tLoopback netinfo6: %s/%d [%d]\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|np
operator|->
name|rip6_metric
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tLink Local netinfo6: %s/%d [%d]\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|np
operator|->
name|rip6_metric
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* may need to pass sitelocal prefix in some case, however*/
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
operator|&&
operator|!
name|lflag
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tSite Local netinfo6: %s/%d [%d]\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|np
operator|->
name|rip6_metric
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|trace
argument_list|(
literal|2
argument_list|,
literal|"\tnetinfo6: %s/%d [%d]"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|np
operator|->
name|rip6_metric
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|rip6_tag
condition|)
name|trace
argument_list|(
literal|2
argument_list|,
literal|"  tag=0x%04x"
argument_list|,
name|ntohs
argument_list|(
name|np
operator|->
name|rip6_tag
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|>=
literal|2
condition|)
block|{
name|ia
operator|=
name|np
operator|->
name|rip6_dest
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ia
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ia
argument_list|,
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
name|trace
argument_list|(
literal|2
argument_list|,
literal|" [junk outside prefix]"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * -L: listen only if the prefix matches the configuration 		 */
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* if there's no L filter, it is ok */
for|for
control|(
name|iffp
operator|=
name|ifcp
operator|->
name|ifc_filter
init|;
name|iffp
condition|;
name|iffp
operator|=
name|iffp
operator|->
name|iff_next
control|)
block|{
if|if
condition|(
name|iffp
operator|->
name|iff_type
operator|!=
literal|'L'
condition|)
continue|continue;
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|rip6_plen
operator|<
name|iffp
operator|->
name|iff_plen
condition|)
continue|continue;
comment|/* special rule: ::/0 means default, not "in /0" */
if|if
condition|(
name|iffp
operator|->
name|iff_plen
operator|==
literal|0
operator|&&
name|np
operator|->
name|rip6_plen
operator|>
literal|0
condition|)
continue|continue;
name|ia
operator|=
name|np
operator|->
name|rip6_dest
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ia
argument_list|,
name|iffp
operator|->
name|iff_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ia
argument_list|,
operator|&
name|iffp
operator|->
name|iff_addr
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|trace
argument_list|(
literal|2
argument_list|,
literal|"  (filtered)\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|trace
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|np
operator|->
name|rip6_metric
operator|++
expr_stmt|;
name|np
operator|->
name|rip6_metric
operator|+=
name|ifcp
operator|->
name|ifc_metric
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|rip6_metric
operator|>
name|HOPCNT_INFINITY6
condition|)
name|np
operator|->
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rrt
operator|=
name|rtsearch
argument_list|(
name|np
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|==
literal|0
condition|)
continue|continue;
comment|/* Intf route has priority */
name|nq
operator|=
operator|&
name|rrt
operator|->
name|rrt_info
expr_stmt|;
if|if
condition|(
name|nq
operator|->
name|rip6_metric
operator|>
name|np
operator|->
name|rip6_metric
condition|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|nh
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
condition|)
block|{
comment|/* Small metric from the same gateway */
name|nq
operator|->
name|rip6_metric
operator|=
name|np
operator|->
name|rip6_metric
expr_stmt|;
block|}
else|else
block|{
comment|/* Better route found */
name|rrt
operator|->
name|rrt_index
operator|=
name|ifcp
operator|->
name|ifc_index
expr_stmt|;
comment|/* Update routing table */
name|delroute
argument_list|(
name|nq
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_gw
operator|=
name|nh
expr_stmt|;
operator|*
name|nq
operator|=
operator|*
name|np
expr_stmt|;
name|addroute
argument_list|(
name|rrt
argument_list|,
operator|&
name|nh
argument_list|,
name|ifcp
argument_list|)
expr_stmt|;
block|}
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_CHANGED
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
name|t
expr_stmt|;
name|need_trigger
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nq
operator|->
name|rip6_metric
operator|<
name|np
operator|->
name|rip6_metric
operator|&&
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|nh
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
condition|)
block|{
comment|/* Got worse route from same gw */
name|nq
operator|->
name|rip6_metric
operator|=
name|np
operator|->
name|rip6_metric
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
name|t
expr_stmt|;
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_CHANGED
expr_stmt|;
name|need_trigger
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nq
operator|->
name|rip6_metric
operator|==
name|np
operator|->
name|rip6_metric
operator|&&
name|np
operator|->
name|rip6_metric
operator|<
name|HOPCNT_INFINITY6
condition|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|nh
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
condition|)
block|{
comment|/* same metric, same route from same gw */
name|rrt
operator|->
name|rrt_t
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|<
name|t_half_lifetime
condition|)
block|{
comment|/* Better route found */
name|rrt
operator|->
name|rrt_index
operator|=
name|ifcp
operator|->
name|ifc_index
expr_stmt|;
comment|/* Update routing table */
name|delroute
argument_list|(
name|nq
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_gw
operator|=
name|nh
expr_stmt|;
operator|*
name|nq
operator|=
operator|*
name|np
expr_stmt|;
name|addroute
argument_list|(
name|rrt
argument_list|,
operator|&
name|nh
argument_list|,
name|ifcp
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_CHANGED
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|/*  			 * if nq->rip6_metric == HOPCNT_INFINITY6 then 			 * do not update age value.  Do nothing. 			 */
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|rip6_metric
operator|<
name|HOPCNT_INFINITY6
condition|)
block|{
comment|/* Got a new valid route */
if|if
condition|(
operator|(
name|rrt
operator|=
name|MALLOC
argument_list|(
expr|struct
name|riprt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: struct riprt"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|rrt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrt
argument_list|)
argument_list|)
expr_stmt|;
name|nq
operator|=
operator|&
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|rrt
operator|->
name|rrt_same
operator|=
name|NULL
expr_stmt|;
name|rrt
operator|->
name|rrt_index
operator|=
name|ifcp
operator|->
name|ifc_index
expr_stmt|;
name|rrt
operator|->
name|rrt_flags
operator|=
name|RTF_UP
operator||
name|RTF_GATEWAY
expr_stmt|;
name|rrt
operator|->
name|rrt_gw
operator|=
name|nh
expr_stmt|;
operator|*
name|nq
operator|=
operator|*
name|np
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|nq
operator|->
name|rip6_dest
argument_list|,
name|nq
operator|->
name|rip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nq
operator|->
name|rip6_plen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|*
literal|8
condition|)
name|rrt
operator|->
name|rrt_flags
operator||=
name|RTF_HOST
expr_stmt|;
comment|/* Put the route to the list */
name|rrt
operator|->
name|rrt_next
operator|=
name|riprt
expr_stmt|;
name|riprt
operator|=
name|rrt
expr_stmt|;
comment|/* Update routing table */
name|addroute
argument_list|(
name|rrt
argument_list|,
operator|&
name|nh
argument_list|,
name|ifcp
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_CHANGED
expr_stmt|;
name|need_trigger
operator|=
literal|1
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|/* XXX need to care the interval between triggered updates */
if|if
condition|(
name|need_trigger
condition|)
block|{
if|if
condition|(
name|nextalarm
operator|>
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|RIP_TRIG_INT6_MAX
condition|)
block|{
for|for
control|(
name|ic
operator|=
name|ifc
init|;
name|ic
condition|;
name|ic
operator|=
name|ic
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_index
operator|==
name|ic
operator|->
name|ifc_index
condition|)
continue|continue;
if|if
condition|(
name|ic
operator|->
name|ifc_flags
operator|&
name|IFF_UP
condition|)
name|ripsend
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ifc_ripsin
argument_list|,
name|RRTF_CHANGED
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset the flag */
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
name|rrt
operator|->
name|rrt_rflags
operator|&=
operator|~
name|RRTF_CHANGED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send all routes request packet to the specified interface.  */
end_comment

begin_function
name|void
name|sendrequest
parameter_list|(
name|ifcp
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
block|{
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_LOOPBACK
condition|)
return|return;
name|ripbuf
operator|->
name|rip6_cmd
operator|=
name|RIP6_REQUEST
expr_stmt|;
name|np
operator|=
name|ripbuf
operator|->
name|rip6_nets
expr_stmt|;
name|memset
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo6
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"Send rtdump Request to %s (%s)\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_ripsin
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sendpacket
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_ripsin
argument_list|,
name|RIPSIZE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAFNOSUPPORT
condition|)
block|{
comment|/* Protocol not supported */
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"Could not send rtdump Request to %s (%s): "
literal|"set IFF_UP to 0\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_ripsin
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
comment|/* As if down for AF_INET6 */
block|}
name|ripbuf
operator|->
name|rip6_cmd
operator|=
name|RIP6_RESPONSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a RIP6_REQUEST packet.  */
end_comment

begin_function
name|void
name|riprequest
parameter_list|(
name|ifcp
parameter_list|,
name|np
parameter_list|,
name|nn
parameter_list|,
name|sin6
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|int
name|nn
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|nn
operator|==
literal|1
operator|&&
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
operator|&&
name|np
operator|->
name|rip6_plen
operator|==
literal|0
operator|&&
name|np
operator|->
name|rip6_metric
operator|==
name|HOPCNT_INFINITY6
operator|)
condition|)
block|{
comment|/* Specific response, don't split-horizon */
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tRIP Request\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nn
condition|;
name|i
operator|++
operator|,
name|np
operator|++
control|)
block|{
name|rrt
operator|=
name|rtsearch
argument_list|(
name|np
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
condition|)
name|np
operator|->
name|rip6_metric
operator|=
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
expr_stmt|;
else|else
name|np
operator|->
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sendpacket
argument_list|(
name|sin6
argument_list|,
name|RIPSIZE
argument_list|(
name|nn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Whole routing table dump */
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tRIP Request -- whole routing table\n"
argument_list|)
expr_stmt|;
name|ripsend
argument_list|(
name|ifcp
argument_list|,
name|sin6
argument_list|,
name|RRTF_SENDANYWAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get information of each interface.  */
end_comment

begin_function
name|void
name|ifconfig
parameter_list|()
block|{
name|struct
name|ifaddrs
modifier|*
name|ifap
decl_stmt|,
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|struct
name|ipv6_mreq
name|mreq
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"getifaddrs"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
for|for
control|(
name|ifa
operator|=
name|ifap
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|ifcp
operator|=
name|ifc_find
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
comment|/* we are interested in multicast-capable interfaces */
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ifcp
condition|)
block|{
comment|/* new interface */
if|if
condition|(
operator|(
name|ifcp
operator|=
name|MALLOC
argument_list|(
expr|struct
name|ifc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: struct ifc"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|ifcp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifcp
argument_list|)
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_index
operator|=
operator|-
literal|1
expr_stmt|;
name|ifcp
operator|->
name|ifc_next
operator|=
name|ifc
expr_stmt|;
name|ifc
operator|=
name|ifcp
expr_stmt|;
name|nifc
operator|++
expr_stmt|;
name|ifcp
operator|->
name|ifc_name
operator|=
name|allocopy
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_addr
operator|=
literal|0
expr_stmt|;
name|ifcp
operator|->
name|ifc_filter
operator|=
literal|0
expr_stmt|;
name|ifcp
operator|->
name|ifc_flags
operator|=
name|ifa
operator|->
name|ifa_flags
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"newif %s<%s>\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|ifflags
argument_list|(
name|ifcp
operator|->
name|ifc_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|LOOPBACK_IF
argument_list|)
condition|)
name|loopifcp
operator|=
name|ifcp
expr_stmt|;
block|}
else|else
block|{
comment|/* update flag, this may be up again */
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|!=
name|ifa
operator|->
name|ifa_flags
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"%s:<%s> -> "
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|ifflags
argument_list|(
name|ifcp
operator|->
name|ifc_flags
argument_list|)
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"<%s>\n"
argument_list|,
name|ifflags
argument_list|(
name|ifa
operator|->
name|ifa_flags
argument_list|)
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_cflags
operator||=
name|IFC_CHANGED
expr_stmt|;
block|}
name|ifcp
operator|->
name|ifc_flags
operator|=
name|ifa
operator|->
name|ifa_flags
expr_stmt|;
block|}
name|ifconfig1
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|ifcp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifcp
operator|->
name|ifc_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_UP
operator|)
operator|)
operator|==
name|IFF_UP
operator|&&
literal|0
operator|<
name|ifcp
operator|->
name|ifc_index
operator|&&
operator|!
name|ifcp
operator|->
name|ifc_joined
condition|)
block|{
name|mreq
operator|.
name|ipv6mr_multiaddr
operator|=
name|ifcp
operator|->
name|ifc_ripsin
operator|.
name|sin6_addr
expr_stmt|;
name|mreq
operator|.
name|ipv6mr_interface
operator|=
name|ifcp
operator|->
name|ifc_index
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|ripsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_JOIN_GROUP
argument_list|,
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"IPV6_JOIN_GROUP"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|trace
argument_list|(
literal|1
argument_list|,
literal|"join %s %s\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|RIP6_DEST
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_joined
operator|++
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|freeifaddrs
argument_list|(
name|ifap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ifconfig1
parameter_list|(
name|name
parameter_list|,
name|sa
parameter_list|,
name|ifcp
parameter_list|,
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|int
name|s
decl_stmt|;
block|{
name|struct
name|in6_ifreq
name|ifr
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|ifac
modifier|*
name|ifa
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sin6
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|ifr
operator|.
name|ifr_addr
operator|=
operator|*
name|sin6
expr_stmt|;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK_IN6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"ioctl: SIOCGIFNETMASK_IN6"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|plen
operator|=
name|sin6mask2len
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|=
name|ifa_match
argument_list|(
name|ifcp
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|plen
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* same interface found */
comment|/* need check if something changed */
comment|/* XXX not yet implemented */
return|return;
block|}
comment|/* 	 * New address is found 	 */
if|if
condition|(
operator|(
name|ifa
operator|=
name|MALLOC
argument_list|(
expr|struct
name|ifac
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: struct ifac"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|ifa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifa
argument_list|)
argument_list|)
expr_stmt|;
name|ifa
operator|->
name|ifa_conf
operator|=
name|ifcp
expr_stmt|;
name|ifa
operator|->
name|ifa_next
operator|=
name|ifcp
operator|->
name|ifc_addr
expr_stmt|;
name|ifcp
operator|->
name|ifc_addr
operator|=
name|ifa
expr_stmt|;
name|ifa
operator|->
name|ifa_addr
operator|=
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
name|ifa
operator|->
name|ifa_plen
operator|=
name|plen
expr_stmt|;
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|ifr
operator|.
name|ifr_addr
operator|=
operator|*
name|sin6
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFDSTADDR_IN6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"ioctl: SIOCGIFDSTADDR_IN6"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|ifa
operator|->
name|ifa_raddr
operator|=
name|ifr
operator|.
name|ifr_dstaddr
operator|.
name|sin6_addr
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ifa
operator|->
name|ifa_raddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"found address %s/%d -- %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"found address %s/%d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifcp
operator|->
name|ifc_index
operator|<
literal|0
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
name|ifcp
operator|->
name|ifc_mylladdr
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|ifcp
operator|->
name|ifc_index
operator|=
name|IN6_LINKLOCAL_IFINDEX
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_ripsin
argument_list|,
operator|&
name|ripsin
argument_list|,
name|ripsin
operator|.
name|ss_len
argument_list|)
expr_stmt|;
name|SET_IN6_LINKLOCAL_IFINDEX
argument_list|(
name|ifcp
operator|->
name|ifc_ripsin
operator|.
name|sin6_addr
argument_list|,
name|ifcp
operator|->
name|ifc_index
argument_list|)
expr_stmt|;
name|setindex2ifc
argument_list|(
name|ifcp
operator|->
name|ifc_index
argument_list|,
name|ifcp
argument_list|)
expr_stmt|;
name|ifcp
operator|->
name|ifc_mtu
operator|=
name|getifmtu
argument_list|(
name|ifcp
operator|->
name|ifc_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifcp
operator|->
name|ifc_mtu
operator|>
name|RIP6_MAXMTU
condition|)
name|ifcp
operator|->
name|ifc_mtu
operator|=
name|RIP6_MAXMTU
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFMETRIC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"ioctl: SIOCGIFMETRIC"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|ifcp
operator|->
name|ifc_metric
operator|=
name|ifr
operator|.
name|ifr_metric
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tindex: %d, mtu: %d, metric: %d\n"
argument_list|,
name|ifcp
operator|->
name|ifc_index
argument_list|,
name|ifcp
operator|->
name|ifc_mtu
argument_list|,
name|ifcp
operator|->
name|ifc_metric
argument_list|)
expr_stmt|;
block|}
else|else
name|ifcp
operator|->
name|ifc_cflags
operator||=
name|IFC_CHANGED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive and process routing messages.  * Update interface information as necesssary.  */
end_comment

begin_function
name|void
name|rtrecv
parameter_list|()
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|,
modifier|*
name|ic
decl_stmt|;
name|int
name|iface
init|=
literal|0
decl_stmt|,
name|rtable
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rta
index|[
name|RTAX_MAX
index|]
decl_stmt|;
name|struct
name|sockaddr_in6
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|addrs
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|rtsock
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"read from rtsock"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|rtm
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"short read from rtsock: %d (should be> %lu)\n"
argument_list|,
name|len
argument_list|,
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|rtm
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|-
name|buf
operator|<
name|len
condition|;
name|p
operator|+=
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_msglen
control|)
block|{
comment|/* safety against bogus message */
if|if
condition|(
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_msglen
operator|<=
literal|0
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"bogus rtmsg: length=%d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_msglen
argument_list|)
expr_stmt|;
break|break;
block|}
name|rtm
operator|=
name|NULL
expr_stmt|;
name|ifam
operator|=
name|NULL
expr_stmt|;
name|ifm
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_type
condition|)
block|{
case|case
name|RTM_NEWADDR
case|:
case|case
name|RTM_DELADDR
case|:
name|ifam
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|p
expr_stmt|;
name|addrs
operator|=
name|ifam
operator|->
name|ifam_addrs
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|RTM_IFINFO
case|:
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|p
expr_stmt|;
name|addrs
operator|=
name|ifm
operator|->
name|ifm_addrs
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ifm
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
expr_stmt|;
name|addrs
operator|=
name|rtm
operator|->
name|rtm_addrs
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|rtm
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"unexpected rtmsg version %d "
literal|"(should be %d)\n"
argument_list|,
name|rtm
operator|->
name|rtm_version
argument_list|,
name|RTM_VERSION
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rtm
operator|->
name|rtm_pid
operator|==
name|pid
condition|)
block|{
if|#
directive|if
literal|0
block|trace(1, "rtmsg looped back to me, ignored\n");
endif|#
directive|endif
continue|continue;
block|}
break|break;
block|}
name|memset
argument_list|(
operator|&
name|rta
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rta
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTAX_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addrs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|rta
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|q
expr_stmt|;
name|q
operator|+=
name|ROUNDUP
argument_list|(
name|rta
index|[
name|i
index|]
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
block|}
name|trace
argument_list|(
literal|1
argument_list|,
literal|"rtsock: %s (addrs=%x)\n"
argument_list|,
name|rttypes
argument_list|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
argument_list|)
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_msglen
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x "
argument_list|,
name|p
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Easy ones first. 		 * 		 * We may be able to optimize by using ifm->ifm_index or 		 * ifam->ifam_index.  For simplicity we don't do that here. 		 */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_type
condition|)
block|{
case|case
name|RTM_NEWADDR
case|:
case|case
name|RTM_IFINFO
case|:
name|iface
operator|++
expr_stmt|;
continue|continue;
case|case
name|RTM_ADD
case|:
name|rtable
operator|++
expr_stmt|;
continue|continue;
case|case
name|RTM_LOSING
case|:
case|case
name|RTM_MISS
case|:
case|case
name|RTM_RESOLVE
case|:
case|case
name|RTM_GET
case|:
case|case
name|RTM_LOCK
case|:
comment|/* nothing to be done here */
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tnothing to be done, ignored\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (rta[RTAX_DST] == NULL) { 			trace(1, "\tno destination, ignored\n"); 			continue;	 		} 		if (rta[RTAX_DST]->sin6_family != AF_INET6) { 			trace(1, "\taf mismatch, ignored\n"); 			continue; 		} 		if (IN6_IS_ADDR_LINKLOCAL(&rta[RTAX_DST]->sin6_addr)) { 			trace(1, "\tlinklocal destination, ignored\n"); 			continue; 		} 		if (IN6_ARE_ADDR_EQUAL(&rta[RTAX_DST]->sin6_addr,&in6addr_loopback)) { 			trace(1, "\tloopback destination, ignored\n"); 			continue;
comment|/* Loopback */
block|} 		if (IN6_IS_ADDR_MULTICAST(&rta[RTAX_DST]->sin6_addr)) { 			trace(1, "\tmulticast destination, ignored\n"); 			continue; 		}
endif|#
directive|endif
comment|/* hard ones */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
operator|)
operator|->
name|rtm_type
condition|)
block|{
case|case
name|RTM_NEWADDR
case|:
case|case
name|RTM_IFINFO
case|:
case|case
name|RTM_ADD
case|:
case|case
name|RTM_LOSING
case|:
case|case
name|RTM_MISS
case|:
case|case
name|RTM_RESOLVE
case|:
case|case
name|RTM_GET
case|:
case|case
name|RTM_LOCK
case|:
comment|/* should already be handled */
name|fatal
argument_list|(
literal|"rtrecv: never reach here"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|RTM_DELETE
case|:
if|if
condition|(
operator|!
name|rta
index|[
name|RTAX_DST
index|]
operator|||
operator|!
name|rta
index|[
name|RTAX_GATEWAY
index|]
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tsome of dst/gw/netamsk are "
literal|"unavailable, ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_HOST
operator|)
operator|!=
literal|0
condition|)
block|{
name|mask
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mask
operator|.
name|sin6_addr
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rta
index|[
name|RTAX_NETMASK
index|]
operator|=
operator|&
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rta
index|[
name|RTAX_NETMASK
index|]
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tsome of dst/gw/netamsk are "
literal|"unavailable, ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rt_del
argument_list|(
name|rta
index|[
name|RTAX_DST
index|]
argument_list|,
name|rta
index|[
name|RTAX_GATEWAY
index|]
argument_list|,
name|rta
index|[
name|RTAX_NETMASK
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtable
operator|++
expr_stmt|;
comment|/*just to be sure*/
block|}
break|break;
case|case
name|RTM_CHANGE
case|:
case|case
name|RTM_REDIRECT
case|:
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tnot supported yet, ignored\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RTM_DELADDR
case|:
if|if
condition|(
operator|!
name|rta
index|[
name|RTAX_NETMASK
index|]
operator|||
operator|!
name|rta
index|[
name|RTAX_IFA
index|]
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tno netmask or ifa given, ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifam
operator|->
name|ifam_index
operator|<
name|nindex2ifc
condition|)
name|ifcp
operator|=
name|index2ifc
index|[
name|ifam
operator|->
name|ifam_index
index|]
expr_stmt|;
else|else
name|ifcp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ifcp
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tinvalid ifam_index %d, ignored\n"
argument_list|,
name|ifam
operator|->
name|ifam_index
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|rt_deladdr
argument_list|(
name|ifcp
argument_list|,
name|rta
index|[
name|RTAX_IFA
index|]
argument_list|,
name|rta
index|[
name|RTAX_NETMASK
index|]
argument_list|)
condition|)
name|iface
operator|++
expr_stmt|;
break|break;
case|case
name|RTM_OLDADD
case|:
case|case
name|RTM_OLDDEL
case|:
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tnot supported yet, ignored\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|iface
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"rtsock: reconfigure interfaces, refresh interface routes\n"
argument_list|)
expr_stmt|;
name|ifconfig
argument_list|()
expr_stmt|;
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
if|if
condition|(
name|ifcp
operator|->
name|ifc_cflags
operator|&
name|IFC_CHANGED
condition|)
block|{
if|if
condition|(
name|ifrt
argument_list|(
name|ifcp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|ic
operator|=
name|ifc
init|;
name|ic
condition|;
name|ic
operator|=
name|ic
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_index
operator|==
name|ic
operator|->
name|ifc_index
condition|)
continue|continue;
if|if
condition|(
name|ic
operator|->
name|ifc_flags
operator|&
name|IFF_UP
condition|)
name|ripsend
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ifc_ripsin
argument_list|,
name|RRTF_CHANGED
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the flag */
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
name|rrt
operator|->
name|rrt_rflags
operator|&=
operator|~
name|RRTF_CHANGED
expr_stmt|;
block|}
name|ifcp
operator|->
name|ifc_cflags
operator|&=
operator|~
name|IFC_CHANGED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtable
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"rtsock: read routing table again\n"
argument_list|)
expr_stmt|;
name|krtread
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * remove specified route from the internal routing table.  */
end_comment

begin_function
name|int
name|rt_del
parameter_list|(
name|sdst
parameter_list|,
name|sgw
parameter_list|,
name|smask
parameter_list|)
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sdst
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sgw
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|smask
decl_stmt|;
block|{
specifier|const
name|struct
name|in6_addr
modifier|*
name|dst
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|in6_addr
modifier|*
name|gw
init|=
name|NULL
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|struct
name|netinfo6
name|ni6
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
init|=
name|NULL
decl_stmt|;
name|time_t
name|t_lifetime
decl_stmt|;
if|if
condition|(
name|sdst
operator|->
name|sin6_family
operator|!=
name|AF_INET6
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tother AF, ignored\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sdst
operator|->
name|sin6_addr
argument_list|)
operator|||
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sdst
operator|->
name|sin6_addr
argument_list|,
operator|&
name|in6addr_loopback
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sdst
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\taddress %s not interesting, ignored\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|sdst
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dst
operator|=
operator|&
name|sdst
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|sgw
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* easy case */
name|gw
operator|=
operator|&
name|sgw
operator|->
name|sin6_addr
expr_stmt|;
name|prefix
operator|=
name|sin6mask2len
argument_list|(
name|smask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sgw
operator|->
name|sin6_family
operator|==
name|AF_LINK
condition|)
block|{
comment|/* 		 * Interface route... a hard case.  We need to get the prefix 		 * length from the kernel, but we now are parsing rtmsg. 		 * We'll purge matching routes from my list, then get the 		 * fresh list. 		 */
name|struct
name|riprt
modifier|*
name|longest
decl_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\t%s is an interface route, guessing prefixlen\n"
argument_list|,
name|inet6_n2p
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|longest
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|,
operator|&
name|sdst
operator|->
name|sin6_addr
argument_list|)
operator|&&
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|longest
operator|||
name|longest
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|<
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
condition|)
block|{
name|longest
operator|=
name|rrt
expr_stmt|;
block|}
block|}
block|}
name|rrt
operator|=
name|longest
expr_stmt|;
if|if
condition|(
operator|!
name|rrt
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tno matching interface route found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|gw
operator|=
operator|&
name|in6addr_loopback
expr_stmt|;
name|prefix
operator|=
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
expr_stmt|;
block|}
else|else
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tunsupported af: (gw=%d)\n"
argument_list|,
name|sgw
operator|->
name|sin6_family
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tdeleting %s/%d "
argument_list|,
name|inet6_n2p
argument_list|(
name|dst
argument_list|)
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"gw %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
name|t_lifetime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|RIP_LIFETIME
expr_stmt|;
comment|/* age route for interface address */
name|memset
argument_list|(
operator|&
name|ni6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ni6
argument_list|)
argument_list|)
expr_stmt|;
name|ni6
operator|.
name|rip6_dest
operator|=
operator|*
name|dst
expr_stmt|;
name|ni6
operator|.
name|rip6_plen
operator|=
name|prefix
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ni6
operator|.
name|rip6_dest
argument_list|,
name|ni6
operator|.
name|rip6_plen
argument_list|)
expr_stmt|;
comment|/*to be sure*/
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tfind route %s/%d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ni6
operator|.
name|rip6_dest
argument_list|)
argument_list|,
name|ni6
operator|.
name|rip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrt
operator|&&
operator|(
name|rrt
operator|=
name|rtsearch
argument_list|(
operator|&
name|ni6
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tno route found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
literal|0
block|if ((rrt->rrt_flags& RTF_STATIC) == 0) { 		trace(1, "\tyou can delete static routes only\n"); 	} else
endif|#
directive|endif
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
name|gw
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tgw mismatch: %s<-> "
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|inet6_n2p
argument_list|(
name|gw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\troute found, age it\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|==
literal|0
operator|||
name|rrt
operator|->
name|rrt_t
operator|>
name|t_lifetime
condition|)
block|{
name|rrt
operator|->
name|rrt_t
operator|=
name|t_lifetime
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * remove specified address from internal interface/routing table.  */
end_comment

begin_function
name|int
name|rt_deladdr
parameter_list|(
name|ifcp
parameter_list|,
name|sifa
parameter_list|,
name|smask
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sifa
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|smask
decl_stmt|;
block|{
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
init|=
name|NULL
decl_stmt|;
name|int
name|prefix
decl_stmt|;
name|struct
name|ifac
modifier|*
name|ifa
init|=
name|NULL
decl_stmt|;
name|struct
name|netinfo6
name|ni6
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
init|=
name|NULL
decl_stmt|;
name|time_t
name|t_lifetime
decl_stmt|;
name|int
name|updated
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sifa
operator|->
name|sin6_family
operator|!=
name|AF_INET6
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tother AF, ignored\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|addr
operator|=
operator|&
name|sifa
operator|->
name|sin6_addr
expr_stmt|;
name|prefix
operator|=
name|sin6mask2len
argument_list|(
name|smask
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tdeleting %s/%d from %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
name|addr
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
name|ifa
operator|=
name|ifa_match
argument_list|(
name|ifcp
argument_list|,
name|addr
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifa
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tno matching ifa found for %s/%d on %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
name|addr
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ifa
operator|->
name|ifa_conf
operator|!=
name|ifcp
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\taddress table corrupt: back pointer does not match "
literal|"(%s != %s)\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|ifa
operator|->
name|ifa_conf
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* remove ifa from interface */
if|if
condition|(
name|ifcp
operator|->
name|ifc_addr
operator|==
name|ifa
condition|)
name|ifcp
operator|->
name|ifc_addr
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
else|else
block|{
name|struct
name|ifac
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ifcp
operator|->
name|ifc_addr
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|ifa_next
operator|==
name|ifa
condition|)
block|{
name|p
operator|->
name|ifa_next
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ifa
operator|->
name|ifa_next
operator|=
name|NULL
expr_stmt|;
name|ifa
operator|->
name|ifa_conf
operator|=
name|NULL
expr_stmt|;
name|t_lifetime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|RIP_LIFETIME
expr_stmt|;
comment|/* age route for interface address */
name|memset
argument_list|(
operator|&
name|ni6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ni6
argument_list|)
argument_list|)
expr_stmt|;
name|ni6
operator|.
name|rip6_dest
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|ni6
operator|.
name|rip6_plen
operator|=
name|ifa
operator|->
name|ifa_plen
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ni6
operator|.
name|rip6_dest
argument_list|,
name|ni6
operator|.
name|rip6_plen
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tfind interface route %s/%d on %d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ni6
operator|.
name|rip6_dest
argument_list|)
argument_list|,
name|ni6
operator|.
name|rip6_plen
argument_list|,
name|ifcp
operator|->
name|ifc_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rrt
operator|=
name|rtsearch
argument_list|(
operator|&
name|ni6
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in6_addr
name|none
decl_stmt|;
name|memset
argument_list|(
operator|&
name|none
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|none
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
operator|&&
operator|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
operator|&
name|none
argument_list|)
operator|||
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
operator|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\troute found, age it\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|==
literal|0
operator|||
name|rrt
operator|->
name|rrt_t
operator|>
name|t_lifetime
condition|)
block|{
name|rrt
operator|->
name|rrt_t
operator|=
name|t_lifetime
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
block|}
name|updated
operator|++
expr_stmt|;
block|}
else|else
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tnon-interface route found: %s/%d on %d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|)
argument_list|,
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
argument_list|,
name|rrt
operator|->
name|rrt_index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tno interface route found\n"
argument_list|)
expr_stmt|;
comment|/* age route for p2p destination */
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ni6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ni6
argument_list|)
argument_list|)
expr_stmt|;
name|ni6
operator|.
name|rip6_dest
operator|=
name|ifa
operator|->
name|ifa_raddr
expr_stmt|;
name|ni6
operator|.
name|rip6_plen
operator|=
literal|128
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ni6
operator|.
name|rip6_dest
argument_list|,
name|ni6
operator|.
name|rip6_plen
argument_list|)
expr_stmt|;
comment|/*to be sure*/
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tfind p2p route %s/%d on %d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ni6
operator|.
name|rip6_dest
argument_list|)
argument_list|,
name|ni6
operator|.
name|rip6_plen
argument_list|,
name|ifcp
operator|->
name|ifc_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rrt
operator|=
name|rtsearch
argument_list|(
operator|&
name|ni6
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\troute found, age it\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|==
literal|0
operator|||
name|rrt
operator|->
name|rrt_t
operator|>
name|t_lifetime
condition|)
block|{
name|rrt
operator|->
name|rrt_t
operator|=
name|t_lifetime
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
name|updated
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tnon-p2p route found: %s/%d on %d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|)
argument_list|,
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
argument_list|,
name|rrt
operator|->
name|rrt_index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\tno p2p route found\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|updated
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Get each interface address and put those interface routes to the route  * list.  */
end_comment

begin_function
name|int
name|ifrt
parameter_list|(
name|ifcp
parameter_list|,
name|again
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|int
name|again
decl_stmt|;
block|{
name|struct
name|ifac
modifier|*
name|ifa
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|,
modifier|*
name|search_rrt
decl_stmt|,
modifier|*
name|prev_rrt
decl_stmt|,
modifier|*
name|loop_rrt
decl_stmt|;
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|time_t
name|t_lifetime
decl_stmt|;
name|int
name|need_trigger
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_LOOPBACK
condition|)
return|return
literal|0
return|;
comment|/* ignore loopback */
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|ifrt_p2p
argument_list|(
name|ifcp
argument_list|,
name|again
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ifa
operator|=
name|ifcp
operator|->
name|ifc_addr
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|trace(1, "route: %s on %s: " 			    "skip linklocal interface address\n", 			    inet6_n2p(&ifa->ifa_addr), ifcp->ifc_name);
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|trace(1, "route: %s: skip unspec interface address\n", 			    ifcp->ifc_name);
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|rrt
operator|=
name|MALLOC
argument_list|(
expr|struct
name|riprt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"malloc: struct riprt"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rrt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrt
argument_list|)
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_same
operator|=
name|NULL
expr_stmt|;
name|rrt
operator|->
name|rrt_index
operator|=
name|ifcp
operator|->
name|ifc_index
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
literal|0
expr_stmt|;
comment|/* don't age */
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_tag
operator|=
name|htons
argument_list|(
name|routetag
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
literal|1
operator|+
name|ifcp
operator|->
name|ifc_metric
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|=
name|ifa
operator|->
name|ifa_plen
expr_stmt|;
name|rrt
operator|->
name|rrt_flags
operator|=
name|RTF_CLONING
expr_stmt|;
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_CHANGED
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX why gateway address == network adddress? */
block|rrt->rrt_gw = ifa->ifa_addr;
endif|#
directive|endif
name|np
operator|=
operator|&
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|search_rrt
operator|=
name|rtsearch
argument_list|(
name|np
argument_list|,
operator|&
name|prev_rrt
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_rrt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|search_rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|>
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
condition|)
block|{
if|if
condition|(
name|prev_rrt
condition|)
name|prev_rrt
operator|->
name|rrt_next
operator|=
name|rrt
operator|->
name|rrt_next
expr_stmt|;
else|else
name|riprt
operator|=
name|rrt
operator|->
name|rrt_next
expr_stmt|;
name|delroute
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Already have better route */
if|if
condition|(
operator|!
name|again
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d: "
literal|"already registered (%s)\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Attach the route to the list */
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d: register route (%s)\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_next
operator|=
name|riprt
expr_stmt|;
name|riprt
operator|=
name|rrt
expr_stmt|;
name|addroute
argument_list|(
name|rrt
argument_list|,
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
name|ifcp
argument_list|)
expr_stmt|;
name|sendrequest
argument_list|(
name|ifcp
argument_list|)
expr_stmt|;
name|ripsend
argument_list|(
name|ifcp
argument_list|,
operator|&
name|ifcp
operator|->
name|ifc_ripsin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|need_trigger
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|loop_rrt
operator|=
name|riprt
init|;
name|loop_rrt
condition|;
name|loop_rrt
operator|=
name|loop_rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|loop_rrt
operator|->
name|rrt_index
operator|==
name|ifcp
operator|->
name|ifc_index
condition|)
block|{
name|t_lifetime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|RIP_LIFETIME
expr_stmt|;
if|if
condition|(
name|loop_rrt
operator|->
name|rrt_t
operator|==
literal|0
operator|||
name|loop_rrt
operator|->
name|rrt_t
operator|>
name|t_lifetime
condition|)
block|{
name|loop_rrt
operator|->
name|rrt_t
operator|=
name|t_lifetime
expr_stmt|;
name|loop_rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
name|HOPCNT_INFINITY6
expr_stmt|;
name|loop_rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_CHANGED
expr_stmt|;
name|need_trigger
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|need_trigger
return|;
block|}
end_function

begin_comment
comment|/*  * there are couple of p2p interface routing models.  "behavior" lets  * you pick one.  it looks that gated behavior fits best with BSDs,  * since BSD kernels do not look at prefix length on p2p interfaces.  */
end_comment

begin_function
name|void
name|ifrt_p2p
parameter_list|(
name|ifcp
parameter_list|,
name|again
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|int
name|again
decl_stmt|;
block|{
name|struct
name|ifac
modifier|*
name|ifa
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|,
modifier|*
name|orrt
decl_stmt|,
modifier|*
name|prevrrt
decl_stmt|;
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|struct
name|in6_addr
name|addr
decl_stmt|,
name|dest
decl_stmt|;
name|int
name|advert
decl_stmt|,
name|ignore
decl_stmt|,
name|i
decl_stmt|;
define|#
directive|define
name|P2PADVERT_NETWORK
value|1
define|#
directive|define
name|P2PADVERT_ADDR
value|2
define|#
directive|define
name|P2PADVERT_DEST
value|4
define|#
directive|define
name|P2PADVERT_MAX
value|4
specifier|const
enum|enum
block|{
name|CISCO
block|,
name|GATED
block|,
name|ROUTE6D
block|}
name|behavior
init|=
name|GATED
enum|;
specifier|const
name|char
modifier|*
name|category
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|noadv
decl_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifcp
operator|->
name|ifc_addr
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
name|addr
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|dest
operator|=
name|ifa
operator|->
name|ifa_raddr
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|addr
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|)
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|dest
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|)
expr_stmt|;
name|advert
operator|=
name|ignore
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|behavior
condition|)
block|{
case|case
name|CISCO
case|:
comment|/* 			 * honor addr/plen, just like normal shared medium 			 * interface.  this may cause trouble if you reuse 			 * addr/plen on other interfaces. 			 * 			 * advertise addr/plen. 			 */
name|advert
operator||=
name|P2PADVERT_NETWORK
expr_stmt|;
break|break;
case|case
name|GATED
case|:
comment|/* 			 * prefixlen on p2p interface is meaningless. 			 * advertise addr/128 and dest/128. 			 * 			 * do not install network route to route6d routing 			 * table (if we do, it would prevent route installation 			 * for other p2p interface that shares addr/plen). 			 * 			 * XXX what should we do if dest is ::?  it will not 			 * get announced anyways (see following filter), 			 * but we need to think. 			 */
name|advert
operator||=
name|P2PADVERT_ADDR
expr_stmt|;
name|advert
operator||=
name|P2PADVERT_DEST
expr_stmt|;
name|ignore
operator||=
name|P2PADVERT_NETWORK
expr_stmt|;
break|break;
case|case
name|ROUTE6D
case|:
comment|/* 			 * just for testing.  actually the code is redundant 			 * given the current p2p interface address assignment 			 * rule for kame kernel. 			 * 			 * intent: 			 *	A/n -> announce A/n 			 *	A B/n, A and B share prefix -> A/n (= B/n) 			 *	A B/n, do not share prefix -> A/128 and B/128 			 * actually, A/64 and A B/128 are the only cases 			 * permitted by the kernel: 			 *	A/64 -> A/64 			 *	A B/128 -> A/128 and B/128 			 */
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_raddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|dest
argument_list|)
condition|)
name|advert
operator||=
name|P2PADVERT_NETWORK
expr_stmt|;
else|else
block|{
name|advert
operator||=
name|P2PADVERT_ADDR
expr_stmt|;
name|advert
operator||=
name|P2PADVERT_DEST
expr_stmt|;
name|ignore
operator||=
name|P2PADVERT_NETWORK
expr_stmt|;
block|}
block|}
else|else
name|advert
operator||=
name|P2PADVERT_NETWORK
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|P2PADVERT_MAX
condition|;
name|i
operator|*=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|ignore
operator|&
name|i
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rrt
operator|=
name|MALLOC
argument_list|(
expr|struct
name|riprt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: struct riprt"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|rrt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrt
argument_list|)
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_same
operator|=
name|NULL
expr_stmt|;
name|rrt
operator|->
name|rrt_index
operator|=
name|ifcp
operator|->
name|ifc_index
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
literal|0
expr_stmt|;
comment|/* don't age */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|P2PADVERT_NETWORK
case|:
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|=
name|ifa
operator|->
name|ifa_plen
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|)
expr_stmt|;
name|category
operator|=
literal|"network"
expr_stmt|;
break|break;
case|case
name|P2PADVERT_ADDR
case|:
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|=
literal|128
expr_stmt|;
name|rrt
operator|->
name|rrt_gw
operator|=
name|in6addr_loopback
expr_stmt|;
name|category
operator|=
literal|"addr"
expr_stmt|;
break|break;
case|case
name|P2PADVERT_DEST
case|:
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
operator|=
name|ifa
operator|->
name|ifa_raddr
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|=
literal|128
expr_stmt|;
name|rrt
operator|->
name|rrt_gw
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|category
operator|=
literal|"dest"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|)
operator|||
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|trace(1, "route: %s: skip unspec/linklocal " 				    "(%s on %s)\n", category, ifcp->ifc_name);
endif|#
directive|endif
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|advert
operator|&
name|i
operator|)
operator|==
literal|0
condition|)
block|{
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_NOADVERTISE
expr_stmt|;
name|noadv
operator|=
literal|", NO-ADV"
expr_stmt|;
block|}
else|else
name|noadv
operator|=
literal|""
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_tag
operator|=
name|htons
argument_list|(
name|routetag
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
literal|1
operator|+
name|ifcp
operator|->
name|ifc_metric
expr_stmt|;
name|np
operator|=
operator|&
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|orrt
operator|=
name|rtsearch
argument_list|(
name|np
argument_list|,
operator|&
name|prevrrt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orrt
condition|)
block|{
comment|/* Attach the route to the list */
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d: register route "
literal|"(%s on %s%s)\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|category
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|noadv
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_next
operator|=
name|riprt
expr_stmt|;
name|riprt
operator|=
name|rrt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rrt
operator|->
name|rrt_index
operator|!=
name|orrt
operator|->
name|rrt_index
operator|||
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|!=
name|orrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
condition|)
block|{
comment|/* swap route */
name|rrt
operator|->
name|rrt_next
operator|=
name|orrt
operator|->
name|rrt_next
expr_stmt|;
if|if
condition|(
name|prevrrt
condition|)
name|prevrrt
operator|->
name|rrt_next
operator|=
name|rrt
expr_stmt|;
else|else
name|riprt
operator|=
name|rrt
expr_stmt|;
name|free
argument_list|(
name|orrt
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d: update (%s on %s%s)\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|category
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|noadv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Already found */
if|if
condition|(
operator|!
name|again
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d: "
literal|"already registered (%s on %s%s)\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|category
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|noadv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|P2PADVERT_NETWORK
undef|#
directive|undef
name|P2PADVERT_ADDR
undef|#
directive|undef
name|P2PADVERT_DEST
undef|#
directive|undef
name|P2PADVERT_MAX
block|}
end_function

begin_function
name|int
name|getifmtu
parameter_list|(
name|ifindex
parameter_list|)
name|int
name|ifindex
decl_stmt|;
block|{
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|msize
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|int
name|mtu
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET6
expr_stmt|;
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_IFLIST
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
name|ifindex
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|msize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"sysctl estimate NET_RT_IFLIST"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|msize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|buf
argument_list|,
operator|&
name|msize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"sysctl NET_RT_IFLIST"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|buf
expr_stmt|;
name|mtu
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_mtu
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|ifindex
operator|!=
name|ifm
operator|->
name|ifm_index
condition|)
block|{
name|fatal
argument_list|(
literal|"ifindex does not match with ifm_index"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|mtu
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|rttypes
parameter_list|(
name|rtm
parameter_list|)
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
block|{
define|#
directive|define
name|RTTYPE
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|do { \ 	if (rtm->rtm_type == (f)) \ 		return (s); \ } while (0)
name|RTTYPE
argument_list|(
literal|"ADD"
argument_list|,
name|RTM_ADD
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"DELETE"
argument_list|,
name|RTM_DELETE
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"CHANGE"
argument_list|,
name|RTM_CHANGE
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"GET"
argument_list|,
name|RTM_GET
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"LOSING"
argument_list|,
name|RTM_LOSING
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"REDIRECT"
argument_list|,
name|RTM_REDIRECT
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"MISS"
argument_list|,
name|RTM_MISS
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"LOCK"
argument_list|,
name|RTM_LOCK
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"OLDADD"
argument_list|,
name|RTM_OLDADD
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"OLDDEL"
argument_list|,
name|RTM_OLDDEL
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"RESOLVE"
argument_list|,
name|RTM_RESOLVE
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"NEWADDR"
argument_list|,
name|RTM_NEWADDR
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"DELADDR"
argument_list|,
name|RTM_DELADDR
argument_list|)
expr_stmt|;
name|RTTYPE
argument_list|(
literal|"IFINFO"
argument_list|,
name|RTM_IFINFO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTM_OLDADD
name|RTTYPE
argument_list|(
literal|"OLDADD"
argument_list|,
name|RTM_OLDADD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_OLDDEL
name|RTTYPE
argument_list|(
literal|"OLDDEL"
argument_list|,
name|RTM_OLDDEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_OIFINFO
name|RTTYPE
argument_list|(
literal|"OIFINFO"
argument_list|,
name|RTM_OIFINFO
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_IFANNOUNCE
name|RTTYPE
argument_list|(
literal|"IFANNOUNCE"
argument_list|,
name|RTM_IFANNOUNCE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_NEWMADDR
name|RTTYPE
argument_list|(
literal|"NEWMADDR"
argument_list|,
name|RTM_NEWMADDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTM_DELMADDR
name|RTTYPE
argument_list|(
literal|"DELMADDR"
argument_list|,
name|RTM_DELMADDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|RTTYPE
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|rtflags
parameter_list|(
name|rtm
parameter_list|)
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	 * letter conflict should be okay.  painful when *BSD diverges... 	 */
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|RTFLAG
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|do { \ 	if (rtm->rtm_flags& (f)) \ 		strlcat(buf, (s), sizeof(buf)); \ } while (0)
name|RTFLAG
argument_list|(
literal|"U"
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"G"
argument_list|,
name|RTF_GATEWAY
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"H"
argument_list|,
name|RTF_HOST
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"R"
argument_list|,
name|RTF_REJECT
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"D"
argument_list|,
name|RTF_DYNAMIC
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"M"
argument_list|,
name|RTF_MODIFIED
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"d"
argument_list|,
name|RTF_DONE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTF_MASK
name|RTFLAG
argument_list|(
literal|"m"
argument_list|,
name|RTF_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RTFLAG
argument_list|(
literal|"C"
argument_list|,
name|RTF_CLONING
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTF_CLONED
name|RTFLAG
argument_list|(
literal|"c"
argument_list|,
name|RTF_CLONED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_PRCLONING
name|RTFLAG
argument_list|(
literal|"c"
argument_list|,
name|RTF_PRCLONING
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_WASCLONED
name|RTFLAG
argument_list|(
literal|"W"
argument_list|,
name|RTF_WASCLONED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RTFLAG
argument_list|(
literal|"X"
argument_list|,
name|RTF_XRESOLVE
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"L"
argument_list|,
name|RTF_LLINFO
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"S"
argument_list|,
name|RTF_STATIC
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"B"
argument_list|,
name|RTF_BLACKHOLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTF_PROTO3
name|RTFLAG
argument_list|(
literal|"3"
argument_list|,
name|RTF_PROTO3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RTFLAG
argument_list|(
literal|"2"
argument_list|,
name|RTF_PROTO2
argument_list|)
expr_stmt|;
name|RTFLAG
argument_list|(
literal|"1"
argument_list|,
name|RTF_PROTO1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTF_BROADCAST
name|RTFLAG
argument_list|(
literal|"b"
argument_list|,
name|RTF_BROADCAST
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_DEFAULT
name|RTFLAG
argument_list|(
literal|"d"
argument_list|,
name|RTF_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_ISAROUTER
name|RTFLAG
argument_list|(
literal|"r"
argument_list|,
name|RTF_ISAROUTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_TUNNEL
name|RTFLAG
argument_list|(
literal|"T"
argument_list|,
name|RTF_TUNNEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_AUTH
name|RTFLAG
argument_list|(
literal|"A"
argument_list|,
name|RTF_AUTH
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_CRYPT
name|RTFLAG
argument_list|(
literal|"E"
argument_list|,
name|RTF_CRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
undef|#
directive|undef
name|RTFLAG
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ifflags
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|IFFLAG
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
define|\
value|do { \ 	if (flags& f) { \ 		if (buf[0]) \ 			strlcat(buf, ",", sizeof(buf)); \ 		strlcat(buf, s, sizeof(buf)); \ 	} \ } while (0)
name|IFFLAG
argument_list|(
literal|"UP"
argument_list|,
name|IFF_UP
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"BROADCAST"
argument_list|,
name|IFF_BROADCAST
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"DEBUG"
argument_list|,
name|IFF_DEBUG
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"LOOPBACK"
argument_list|,
name|IFF_LOOPBACK
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"POINTOPOINT"
argument_list|,
name|IFF_POINTOPOINT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFF_NOTRAILERS
name|IFFLAG
argument_list|(
literal|"NOTRAILERS"
argument_list|,
name|IFF_NOTRAILERS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFF_SMART
name|IFFLAG
argument_list|(
literal|"SMART"
argument_list|,
name|IFF_SMART
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IFFLAG
argument_list|(
literal|"RUNNING"
argument_list|,
name|IFF_RUNNING
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"NOARP"
argument_list|,
name|IFF_NOARP
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"PROMISC"
argument_list|,
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"ALLMULTI"
argument_list|,
name|IFF_ALLMULTI
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"OACTIVE"
argument_list|,
name|IFF_OACTIVE
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"SIMPLEX"
argument_list|,
name|IFF_SIMPLEX
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"LINK0"
argument_list|,
name|IFF_LINK0
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"LINK1"
argument_list|,
name|IFF_LINK1
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"LINK2"
argument_list|,
name|IFF_LINK2
argument_list|)
expr_stmt|;
name|IFFLAG
argument_list|(
literal|"MULTICAST"
argument_list|,
name|IFF_MULTICAST
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|IFFLAG
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|krtread
parameter_list|(
name|again
parameter_list|)
name|int
name|again
decl_stmt|;
block|{
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|size_t
name|msize
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|int
name|retry
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET6
expr_stmt|;
comment|/* Address family */
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_DUMP
expr_stmt|;
comment|/* Dump the kernel routing table */
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* No flags */
do|do
block|{
name|retry
operator|++
expr_stmt|;
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|msize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"sysctl estimate"
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|msize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errmsg
operator|=
literal|"malloc"
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|buf
argument_list|,
operator|&
name|msize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errmsg
operator|=
literal|"sysctl NET_RT_DUMP"
expr_stmt|;
continue|continue;
block|}
block|}
do|while
condition|(
name|retry
operator|<
literal|5
operator|&&
name|errmsg
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|fatal
argument_list|(
literal|"%s (with %d retries, msize=%lu)"
argument_list|,
name|errmsg
argument_list|,
name|retry
argument_list|,
operator|(
name|u_long
operator|)
name|msize
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
name|retry
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NET_RT_DUMP %d retires"
argument_list|,
name|retry
argument_list|)
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|msize
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<
name|lim
condition|;
name|p
operator|+=
name|rtm
operator|->
name|rtm_msglen
control|)
block|{
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|p
expr_stmt|;
name|rt_entry
argument_list|(
name|rtm
argument_list|,
name|again
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rt_entry
parameter_list|(
name|rtm
parameter_list|,
name|again
parameter_list|)
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|int
name|again
decl_stmt|;
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6_dst
decl_stmt|,
modifier|*
name|sin6_gw
decl_stmt|,
modifier|*
name|sin6_mask
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6_genmask
decl_stmt|,
modifier|*
name|sin6_ifp
decl_stmt|;
name|char
modifier|*
name|rtmp
decl_stmt|,
modifier|*
name|ifname
init|=
name|NULL
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|,
modifier|*
name|orrt
decl_stmt|;
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sin6_dst
operator|=
name|sin6_gw
operator|=
name|sin6_mask
operator|=
name|sin6_genmask
operator|=
name|sin6_ifp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
name|rtm
operator|->
name|rtm_flags
operator|&
operator|(
name|RTF_CLONING
operator||
name|RTF_XRESOLVE
operator||
name|RTF_LLINFO
operator||
name|RTF_BLACKHOLE
operator|)
condition|)
block|{
return|return;
comment|/* not interested in the link route */
block|}
comment|/* do not look at cloned routes */
ifdef|#
directive|ifdef
name|RTF_WASCLONED
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_WASCLONED
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RTF_CLONED
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_CLONED
condition|)
return|return;
endif|#
directive|endif
comment|/* 	 * do not look at dynamic routes. 	 * netbsd/openbsd cloned routes have UGHD. 	 */
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_DYNAMIC
condition|)
return|return;
name|rtmp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|rtm
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Destination */
if|if
condition|(
operator|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_DST
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* ignore routes without destination address */
name|sin6_dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rtmp
expr_stmt|;
name|rtmp
operator|+=
name|ROUNDUP
argument_list|(
name|sin6_dst
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_GATEWAY
condition|)
block|{
name|sin6_gw
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rtmp
expr_stmt|;
name|rtmp
operator|+=
name|ROUNDUP
argument_list|(
name|sin6_gw
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_NETMASK
condition|)
block|{
name|sin6_mask
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rtmp
expr_stmt|;
name|rtmp
operator|+=
name|ROUNDUP
argument_list|(
name|sin6_mask
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_GENMASK
condition|)
block|{
name|sin6_genmask
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rtmp
expr_stmt|;
name|rtmp
operator|+=
name|ROUNDUP
argument_list|(
name|sin6_genmask
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_IFP
condition|)
block|{
name|sin6_ifp
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rtmp
expr_stmt|;
name|rtmp
operator|+=
name|ROUNDUP
argument_list|(
name|sin6_ifp
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
comment|/* Destination */
if|if
condition|(
name|sin6_dst
operator|->
name|sin6_family
operator|!=
name|AF_INET6
condition|)
return|return;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6_dst
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return;
comment|/* Link-local */
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6_dst
operator|->
name|sin6_addr
argument_list|,
operator|&
name|in6addr_loopback
argument_list|)
condition|)
return|return;
comment|/* Loopback */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6_dst
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|rrt
operator|=
name|MALLOC
argument_list|(
expr|struct
name|riprt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: struct riprt"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|rrt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrt
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
operator|&
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|rrt
operator|->
name|rrt_same
operator|=
name|NULL
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|==
literal|0
operator|&&
operator|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_STATIC
operator|)
condition|)
name|rrt
operator|->
name|rrt_t
operator|=
literal|0
expr_stmt|;
comment|/* Don't age static routes */
name|np
operator|->
name|rip6_tag
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|rip6_metric
operator|=
name|rtm
operator|->
name|rtm_rmx
operator|.
name|rmx_hopcount
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|rip6_metric
operator|<
literal|1
condition|)
name|np
operator|->
name|rip6_metric
operator|=
literal|1
expr_stmt|;
name|rrt
operator|->
name|rrt_flags
operator|=
name|rtm
operator|->
name|rtm_flags
expr_stmt|;
name|np
operator|->
name|rip6_dest
operator|=
name|sin6_dst
operator|->
name|sin6_addr
expr_stmt|;
comment|/* Mask or plen */
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_HOST
condition|)
name|np
operator|->
name|rip6_plen
operator|=
literal|128
expr_stmt|;
comment|/* Host route */
elseif|else
if|if
condition|(
name|sin6_mask
condition|)
name|np
operator|->
name|rip6_plen
operator|=
name|sin6mask2len
argument_list|(
name|sin6_mask
argument_list|)
expr_stmt|;
else|else
name|np
operator|->
name|rip6_plen
operator|=
literal|0
expr_stmt|;
name|orrt
operator|=
name|rtsearch
argument_list|(
name|np
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|orrt
operator|&&
name|orrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|!=
name|HOPCNT_INFINITY6
condition|)
block|{
comment|/* Already found */
if|if
condition|(
operator|!
name|again
condition|)
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d flags %s: already registered\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|rtflags
argument_list|(
name|rtm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Gateway */
if|if
condition|(
operator|!
name|sin6_gw
condition|)
name|memset
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sin6_gw
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
name|rrt
operator|->
name|rrt_gw
operator|=
name|sin6_gw
operator|->
name|sin6_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|sin6_gw
operator|->
name|sin6_family
operator|==
name|AF_LINK
condition|)
block|{
comment|/* XXX in case ppp link? */
name|rrt
operator|->
name|rrt_gw
operator|=
name|in6addr_loopback
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d flags %s"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|rtflags
argument_list|(
name|rtm
argument_list|)
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|" gw %s"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Interface */
name|s
operator|=
name|rtm
operator|->
name|rtm_index
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|nindex2ifc
operator|&&
name|index2ifc
index|[
name|s
index|]
condition|)
name|ifname
operator|=
name|index2ifc
index|[
name|s
index|]
operator|->
name|ifc_name
expr_stmt|;
else|else
block|{
name|trace
argument_list|(
literal|1
argument_list|,
literal|" not configured\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
return|return;
block|}
name|trace
argument_list|(
literal|1
argument_list|,
literal|" if %s sock %d"
argument_list|,
name|ifname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_index
operator|=
name|s
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Check gateway */
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|&&
operator|(
name|rrt
operator|->
name|rrt_flags
operator|&
name|RTF_LOCAL
operator|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
name|trace
argument_list|(
literal|0
argument_list|,
literal|"***** Gateway %s is not a link-local address.\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|0
argument_list|,
literal|"*****     dest(%s) if(%s) -- Not optimized.\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|)
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_rflags
operator||=
name|RRTF_NH_NOT_LLADDR
expr_stmt|;
block|}
comment|/* Put it to the route list */
if|if
condition|(
name|orrt
operator|&&
name|orrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|==
name|HOPCNT_INFINITY6
condition|)
block|{
comment|/* replace route list */
name|rrt
operator|->
name|rrt_next
operator|=
name|orrt
operator|->
name|rrt_next
expr_stmt|;
operator|*
name|orrt
operator|=
operator|*
name|rrt
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"route: %s/%d flags %s: replace new route\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|rtflags
argument_list|(
name|rtm
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rrt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rrt
operator|->
name|rrt_next
operator|=
name|riprt
expr_stmt|;
name|riprt
operator|=
name|rrt
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|addroute
parameter_list|(
name|rrt
parameter_list|,
name|gw
parameter_list|,
name|ifcp
parameter_list|)
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
specifier|const
name|struct
name|in6_addr
modifier|*
name|gw
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
block|{
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|u_char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|len
decl_stmt|;
name|np
operator|=
operator|&
name|rrt
operator|->
name|rrt_info
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|gw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ifcp
operator|->
name|ifc_mylladdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"ADD: %s/%d gw %s [%d] ifa %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf1
argument_list|,
name|np
operator|->
name|rip6_metric
operator|-
literal|1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlog
condition|)
name|fprintf
argument_list|(
name|rtlog
argument_list|,
literal|"%s: ADD: %s/%d gw %s [%d] ifa %s\n"
argument_list|,
name|hms
argument_list|()
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf1
argument_list|,
name|np
operator|->
name|rip6_metric
operator|-
literal|1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|buf
expr_stmt|;
name|rtm
operator|->
name|rtm_type
operator|=
name|RTM_ADD
expr_stmt|;
name|rtm
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rtm
operator|->
name|rtm_seq
operator|=
operator|++
name|seq
expr_stmt|;
name|rtm
operator|->
name|rtm_pid
operator|=
name|pid
expr_stmt|;
name|rtm
operator|->
name|rtm_flags
operator|=
name|rrt
operator|->
name|rrt_flags
expr_stmt|;
name|rtm
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
operator||
name|RTA_GATEWAY
operator||
name|RTA_NETMASK
expr_stmt|;
name|rtm
operator|->
name|rtm_rmx
operator|.
name|rmx_hopcount
operator|=
name|np
operator|->
name|rip6_metric
operator|-
literal|1
expr_stmt|;
name|rtm
operator|->
name|rtm_inits
operator|=
name|RTV_HOPCOUNT
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
index|]
expr_stmt|;
comment|/* Destination */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|np
operator|->
name|rip6_dest
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
comment|/* Gateway */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
operator|*
name|gw
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
comment|/* Netmask */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
operator|*
operator|(
name|plen2mask
argument_list|(
name|np
operator|->
name|rip6_plen
argument_list|)
operator|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
operator|(
name|char
operator|*
operator|)
name|sin6
operator|-
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|rtm
operator|->
name|rtm_msglen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|rtsock
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|trace
argument_list|(
literal|0
argument_list|,
literal|"ADD: Route already exists %s/%d gw %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlog
condition|)
name|fprintf
argument_list|(
name|rtlog
argument_list|,
literal|"ADD: Route already exists %s/%d gw %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace
argument_list|(
literal|0
argument_list|,
literal|"Can not write to rtsock (addroute): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlog
condition|)
name|fprintf
argument_list|(
name|rtlog
argument_list|,
literal|"\tCan not write to rtsock: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|delroute
parameter_list|(
name|np
parameter_list|,
name|gw
parameter_list|)
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|gw
decl_stmt|;
block|{
name|u_char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|len
decl_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|tracet
argument_list|(
literal|1
argument_list|,
literal|"DEL: %s/%d gw %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlog
condition|)
name|fprintf
argument_list|(
name|rtlog
argument_list|,
literal|"%s: DEL: %s/%d gw %s\n"
argument_list|,
name|hms
argument_list|()
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|buf
expr_stmt|;
name|rtm
operator|->
name|rtm_type
operator|=
name|RTM_DELETE
expr_stmt|;
name|rtm
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rtm
operator|->
name|rtm_seq
operator|=
operator|++
name|seq
expr_stmt|;
name|rtm
operator|->
name|rtm_pid
operator|=
name|pid
expr_stmt|;
name|rtm
operator|->
name|rtm_flags
operator|=
name|RTF_UP
operator||
name|RTF_GATEWAY
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|rip6_plen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|*
literal|8
condition|)
name|rtm
operator|->
name|rtm_flags
operator||=
name|RTF_HOST
expr_stmt|;
name|rtm
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
operator||
name|RTA_GATEWAY
operator||
name|RTA_NETMASK
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
index|]
expr_stmt|;
comment|/* Destination */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|np
operator|->
name|rip6_dest
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
comment|/* Gateway */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
operator|*
name|gw
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
comment|/* Netmask */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
operator|*
operator|(
name|plen2mask
argument_list|(
name|np
operator|->
name|rip6_plen
argument_list|)
operator|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
operator|(
name|char
operator|*
operator|)
name|sin6
operator|-
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|rtm
operator|->
name|rtm_msglen
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|rtsock
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
block|{
name|trace
argument_list|(
literal|0
argument_list|,
literal|"RTDEL: Route does not exist: %s/%d gw %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlog
condition|)
name|fprintf
argument_list|(
name|rtlog
argument_list|,
literal|"RTDEL: Route does not exist: %s/%d gw %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
argument_list|,
name|np
operator|->
name|rip6_plen
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace
argument_list|(
literal|0
argument_list|,
literal|"Can not write to rtsock (delroute): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlog
condition|)
name|fprintf
argument_list|(
name|rtlog
argument_list|,
literal|"\tCan not write to rtsock: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|in6_addr
modifier|*
name|getroute
parameter_list|(
name|np
parameter_list|,
name|gw
parameter_list|)
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|gw
decl_stmt|;
block|{
name|u_char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_long
name|myseq
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rtm
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rtm
operator|->
name|rtm_type
operator|=
name|RTM_GET
expr_stmt|;
name|rtm
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|myseq
operator|=
operator|++
name|seq
expr_stmt|;
name|rtm
operator|->
name|rtm_seq
operator|=
name|myseq
expr_stmt|;
name|rtm
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
expr_stmt|;
name|rtm
operator|->
name|rtm_msglen
operator|=
name|len
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
index|]
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|np
operator|->
name|rip6_dest
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|rtsock
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
comment|/* No such route found */
return|return
name|NULL
return|;
name|perror
argument_list|(
literal|"write to rtsock"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|rtsock
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"read from rtsock"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|buf
expr_stmt|;
block|}
do|while
condition|(
name|rtm
operator|->
name|rtm_seq
operator|!=
name|myseq
operator|||
name|rtm
operator|->
name|rtm_pid
operator|!=
name|pid
condition|)
do|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rt_msghdr
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_DST
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sin6
operator|+
name|ROUNDUP
argument_list|(
name|sin6
operator|->
name|sin6_len
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rtm
operator|->
name|rtm_addrs
operator|&
name|RTA_GATEWAY
condition|)
block|{
operator|*
name|gw
operator|=
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
return|return
name|gw
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|inet6_n2p
parameter_list|(
name|p
parameter_list|)
specifier|const
name|struct
name|in6_addr
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
return|return
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|p
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ifrtdump
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|ifdump
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|rtdump
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ifdump
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
name|dump
operator|=
name|stderr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dump
operator|=
name|fopen
argument_list|(
name|ROUTE6D_DUMP
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dump
operator|=
name|stderr
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s: Interface Table Dump\n"
argument_list|,
name|hms
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  Number of interfaces: %d\n"
argument_list|,
name|nifc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  %sadvertising interfaces:\n"
argument_list|,
name|i
condition|?
literal|"non-"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|iff_find
argument_list|(
name|ifcp
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_UP
condition|)
continue|continue;
block|}
name|ifdump0
argument_list|(
name|dump
argument_list|,
name|ifcp
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ifdump0
parameter_list|(
name|dump
parameter_list|,
name|ifcp
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
specifier|const
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
block|{
name|struct
name|ifac
modifier|*
name|ifa
decl_stmt|;
name|struct
name|iff
modifier|*
name|iffp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ft
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"    %s: index(%d) flags(%s) addr(%s) mtu(%d) metric(%d)\n"
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|,
name|ifcp
operator|->
name|ifc_index
argument_list|,
name|ifflags
argument_list|(
name|ifcp
operator|->
name|ifc_flags
argument_list|)
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifcp
operator|->
name|ifc_mylladdr
argument_list|)
argument_list|,
name|ifcp
operator|->
name|ifc_mtu
argument_list|,
name|ifcp
operator|->
name|ifc_metric
argument_list|)
expr_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifcp
operator|->
name|ifc_addr
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ifcp
operator|->
name|ifc_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ifa
operator|->
name|ifa_raddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\t%s/%d -- %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\t%s/%d\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|ifa
operator|->
name|ifa_plen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifcp
operator|->
name|ifc_filter
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\tFilter:"
argument_list|)
expr_stmt|;
for|for
control|(
name|iffp
operator|=
name|ifcp
operator|->
name|ifc_filter
init|;
name|iffp
condition|;
name|iffp
operator|=
name|iffp
operator|->
name|iff_next
control|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|iffp
operator|->
name|iff_type
condition|)
block|{
case|case
literal|'A'
case|:
name|ft
operator|=
literal|"Aggregate"
expr_stmt|;
name|addr
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|ft
operator|=
literal|"No-use"
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|ft
operator|=
literal|"Advertise-only"
expr_stmt|;
name|addr
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ft
operator|=
literal|"Default-only"
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|ft
operator|=
literal|"Listen-only"
expr_stmt|;
name|addr
operator|++
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Unknown-%c"
argument_list|,
name|iffp
operator|->
name|iff_type
argument_list|)
expr_stmt|;
name|ft
operator|=
name|buf
expr_stmt|;
name|addr
operator|++
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %s"
argument_list|,
name|ft
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"(%s/%d)"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|iffp
operator|->
name|iff_addr
argument_list|)
argument_list|,
name|iffp
operator|->
name|iff_plen
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rtdump
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|dump
decl_stmt|;
name|time_t
name|t
decl_stmt|,
name|age
decl_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
name|dump
operator|=
name|stderr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dump
operator|=
name|fopen
argument_list|(
name|ROUTE6D_DUMP
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dump
operator|=
name|stderr
expr_stmt|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n%s: Routing Table Dump\n"
argument_list|,
name|hms
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_t
operator|==
literal|0
condition|)
name|age
operator|=
literal|0
expr_stmt|;
else|else
name|age
operator|=
name|t
operator|-
name|rrt
operator|->
name|rrt_t
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"    %s/%d if(%d:%s) gw(%s) [%d] age(%ld)"
argument_list|,
name|buf
argument_list|,
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
argument_list|,
name|rrt
operator|->
name|rrt_index
argument_list|,
name|index2ifc
index|[
name|rrt
operator|->
name|rrt_index
index|]
operator|->
name|ifc_name
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_gw
argument_list|)
argument_list|,
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
argument_list|,
operator|(
name|long
operator|)
name|age
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_tag
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" tag(0x%04x)"
argument_list|,
name|ntohs
argument_list|(
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_tag
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_NH_NOT_LLADDR
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" NOT-LL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|->
name|rrt_rflags
operator|&
name|RRTF_NOADVERTISE
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" NO-ADV"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the -A (and -O) options and put corresponding filter object to the  * specified interface structures.  Each of the -A/O option has the following  * syntax:	-A 5f09:c400::/32,ef0,ef1  (aggregate)  * 		-O 5f09:c400::/32,ef0,ef1  (only when match)  */
end_comment

begin_function
name|void
name|filterconfig
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ap
decl_stmt|,
modifier|*
name|iflp
decl_stmt|,
modifier|*
name|ifname
decl_stmt|;
name|struct
name|iff
name|ftmp
decl_stmt|,
modifier|*
name|iff_obj
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
if|#
directive|if
literal|0
block|struct in6_addr gw;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfilter
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|=
name|filter
index|[
name|i
index|]
expr_stmt|;
name|iflp
operator|=
name|NULL
expr_stmt|;
name|ifcp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|filtertype
index|[
name|i
index|]
operator|==
literal|'N'
operator|||
name|filtertype
index|[
name|i
index|]
operator|==
literal|'T'
condition|)
block|{
name|iflp
operator|=
name|ap
expr_stmt|;
goto|goto
name|ifonly
goto|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|ap
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|iflp
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|ap
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"no prefixlen specified for '%s'"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ap
argument_list|,
operator|&
name|ftmp
operator|.
name|iff_addr
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fatal
argument_list|(
literal|"invalid prefix specified for '%s'"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|ftmp
operator|.
name|iff_plen
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ftmp
operator|.
name|iff_next
operator|=
name|NULL
expr_stmt|;
name|applyplen
argument_list|(
operator|&
name|ftmp
operator|.
name|iff_addr
argument_list|,
name|ftmp
operator|.
name|iff_plen
argument_list|)
expr_stmt|;
name|ifonly
label|:
name|ftmp
operator|.
name|iff_type
operator|=
name|filtertype
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|iflp
operator|==
name|NULL
operator|||
operator|*
name|iflp
operator|==
literal|'\0'
condition|)
block|{
name|fatal
argument_list|(
literal|"no interface specified for '%s'"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* parse the interface listing portion */
while|while
condition|(
name|iflp
condition|)
block|{
name|ifname
operator|=
name|iflp
expr_stmt|;
if|if
condition|(
operator|(
name|iflp
operator|=
name|index
argument_list|(
name|iflp
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|iflp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ifcp
operator|=
name|ifc_find
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifcp
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"no interface %s exists"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|iff_obj
operator|=
operator|(
expr|struct
name|iff
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iff_obj
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc of iff_obj"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|iff_obj
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ftmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* link it to the interface filter */
name|iff_obj
operator|->
name|iff_next
operator|=
name|ifcp
operator|->
name|ifc_filter
expr_stmt|;
name|ifcp
operator|->
name|ifc_filter
operator|=
name|iff_obj
expr_stmt|;
block|}
comment|/* 		 * -A: aggregate configuration. 		 */
if|if
condition|(
name|filtertype
index|[
name|i
index|]
operator|!=
literal|'A'
condition|)
continue|continue;
comment|/* put the aggregate to the kernel routing table */
name|rrt
operator|=
operator|(
expr|struct
name|riprt
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|riprt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrt
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc: rrt"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|rrt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|riprt
argument_list|)
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
operator|=
name|ftmp
operator|.
name|iff_addr
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|=
name|ftmp
operator|.
name|iff_plen
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_metric
operator|=
literal|1
expr_stmt|;
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_tag
operator|=
name|htons
argument_list|(
name|routetag
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|rrt
operator|->
name|rrt_gw
operator|=
name|in6addr_loopback
expr_stmt|;
name|rrt
operator|->
name|rrt_flags
operator|=
name|RTF_UP
operator||
name|RTF_REJECT
expr_stmt|;
name|rrt
operator|->
name|rrt_rflags
operator|=
name|RRTF_AGGREGATE
expr_stmt|;
name|rrt
operator|->
name|rrt_t
operator|=
literal|0
expr_stmt|;
name|rrt
operator|->
name|rrt_index
operator|=
name|loopifindex
expr_stmt|;
if|#
directive|if
literal|0
block|if (getroute(&rrt->rrt_info,&gw)) {
if|#
directive|if
literal|0
comment|/* 			 * When the address has already been registered in the 			 * kernel routing table, it should be removed  			 */
block|delroute(&rrt->rrt_info,&gw);
else|#
directive|else
comment|/* it is safer behavior */
block|errno = EINVAL; 			fatal("%s/%u already in routing table, " 			    "cannot aggregate", 			    inet6_n2p(&rrt->rrt_info.rip6_dest), 			    rrt->rrt_info.rip6_plen);
comment|/*NOTREACHED*/
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Put the route to the list */
name|rrt
operator|->
name|rrt_next
operator|=
name|riprt
expr_stmt|;
name|riprt
operator|=
name|rrt
expr_stmt|;
name|trace
argument_list|(
literal|1
argument_list|,
literal|"Aggregate: %s/%d for %s\n"
argument_list|,
name|inet6_n2p
argument_list|(
operator|&
name|ftmp
operator|.
name|iff_addr
argument_list|)
argument_list|,
name|ftmp
operator|.
name|iff_plen
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
expr_stmt|;
comment|/* Add this route to the kernel */
if|if
condition|(
name|nflag
condition|)
comment|/* do not modify kernel routing table */
continue|continue;
name|addroute
argument_list|(
name|rrt
argument_list|,
operator|&
name|in6addr_loopback
argument_list|,
name|loopifcp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************** utility functions *****************/
end_comment

begin_comment
comment|/*  * Returns a pointer to ifac whose address and prefix length matches  * with the address and prefix length specified in the arguments.  */
end_comment

begin_function
name|struct
name|ifac
modifier|*
name|ifa_match
parameter_list|(
name|ifcp
parameter_list|,
name|ia
parameter_list|,
name|plen
parameter_list|)
specifier|const
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
specifier|const
name|struct
name|in6_addr
modifier|*
name|ia
decl_stmt|;
name|int
name|plen
decl_stmt|;
block|{
name|struct
name|ifac
modifier|*
name|ifa
decl_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifcp
operator|->
name|ifc_addr
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|ia
argument_list|)
operator|&&
name|ifa
operator|->
name|ifa_plen
operator|==
name|plen
condition|)
break|break;
block|}
return|return
name|ifa
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to riprt structure whose address and prefix length  * matches with the address and prefix length found in the argument.  * Note: This is not a rtalloc().  Therefore exact match is necessary.  */
end_comment

begin_function
name|struct
name|riprt
modifier|*
name|rtsearch
parameter_list|(
name|np
parameter_list|,
name|prev_rrt
parameter_list|)
name|struct
name|netinfo6
modifier|*
name|np
decl_stmt|;
name|struct
name|riprt
modifier|*
modifier|*
name|prev_rrt
decl_stmt|;
block|{
name|struct
name|riprt
modifier|*
name|rrt
decl_stmt|;
if|if
condition|(
name|prev_rrt
condition|)
operator|*
name|prev_rrt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rrt
operator|=
name|riprt
init|;
name|rrt
condition|;
name|rrt
operator|=
name|rrt
operator|->
name|rrt_next
control|)
block|{
if|if
condition|(
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_plen
operator|==
name|np
operator|->
name|rip6_plen
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|rrt
operator|->
name|rrt_info
operator|.
name|rip6_dest
argument_list|,
operator|&
name|np
operator|->
name|rip6_dest
argument_list|)
condition|)
return|return
name|rrt
return|;
if|if
condition|(
name|prev_rrt
condition|)
operator|*
name|prev_rrt
operator|=
name|rrt
expr_stmt|;
block|}
if|if
condition|(
name|prev_rrt
condition|)
operator|*
name|prev_rrt
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sin6mask2len
parameter_list|(
name|sin6
parameter_list|)
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
block|{
return|return
name|mask2len
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|sin6
operator|->
name|sin6_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mask2len
parameter_list|(
name|addr
parameter_list|,
name|lenlim
parameter_list|)
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
decl_stmt|;
name|int
name|lenlim
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p
init|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|addr
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lenlim
condition|;
name|j
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|0xff
condition|)
break|break;
name|i
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|lenlim
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
define|#
directive|define
name|MASKLEN
parameter_list|(
name|m
parameter_list|,
name|l
parameter_list|)
value|case m: do { i += l; break; } while (0)
name|MASKLEN
argument_list|(
literal|0xfe
argument_list|,
literal|7
argument_list|)
expr_stmt|;
break|break;
name|MASKLEN
argument_list|(
literal|0xfc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
name|MASKLEN
argument_list|(
literal|0xf8
argument_list|,
literal|5
argument_list|)
expr_stmt|;
break|break;
name|MASKLEN
argument_list|(
literal|0xf0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
name|MASKLEN
argument_list|(
literal|0xe0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
name|MASKLEN
argument_list|(
literal|0xc0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
name|MASKLEN
argument_list|(
literal|0x80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|MASKLEN
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|applymask
parameter_list|(
name|addr
parameter_list|,
name|mask
parameter_list|)
name|struct
name|in6_addr
modifier|*
name|addr
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|u_long
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
operator|(
name|u_long
operator|*
operator|)
name|addr
expr_stmt|;
name|q
operator|=
operator|(
name|u_long
operator|*
operator|)
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|&=
operator|*
name|q
operator|++
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|plent
index|[
literal|8
index|]
init|=
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0xc0
block|,
literal|0xe0
block|,
literal|0xf0
block|,
literal|0xf8
block|,
literal|0xfc
block|,
literal|0xfe
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|applyplen
parameter_list|(
name|ia
parameter_list|,
name|plen
parameter_list|)
name|struct
name|in6_addr
modifier|*
name|ia
decl_stmt|;
name|int
name|plen
decl_stmt|;
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|ia
operator|->
name|s6_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|plen
operator|<=
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|plen
operator|<
literal|8
condition|)
operator|*
name|p
operator|&=
name|plent
index|[
name|plen
index|]
expr_stmt|;
name|p
operator|++
operator|,
name|plen
operator|-=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|pl2m
index|[
literal|9
index|]
init|=
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0xc0
block|,
literal|0xe0
block|,
literal|0xf0
block|,
literal|0xf8
block|,
literal|0xfc
block|,
literal|0xfe
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|in6_addr
modifier|*
name|plen2mask
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|struct
name|in6_addr
name|ia
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ia
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ia
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|n
operator|-=
literal|8
control|)
block|{
if|if
condition|(
name|n
operator|>=
literal|8
condition|)
block|{
operator|*
name|p
operator|=
literal|0xff
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
name|pl2m
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
return|return
operator|&
name|ia
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|allocopy
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|q
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|strlcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|hms
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"localtime"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%02d:%02d:%02d"
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RIPRANDDEV
value|1.0
end_define

begin_comment
comment|/* 30 +- 15, max - min = 30 */
end_comment

begin_function
name|int
name|ripinterval
parameter_list|(
name|timer
parameter_list|)
name|int
name|timer
decl_stmt|;
block|{
name|double
name|r
init|=
name|rand
argument_list|()
decl_stmt|;
name|interval
operator|=
call|(
name|int
call|)
argument_list|(
name|timer
operator|+
name|timer
operator|*
name|RIPRANDDEV
operator|*
operator|(
name|r
operator|/
name|RAND_MAX
operator|-
literal|0.5
operator|)
argument_list|)
expr_stmt|;
name|nextalarm
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|interval
expr_stmt|;
return|return
name|interval
return|;
block|}
end_function

begin_function
name|time_t
name|ripsuptrig
parameter_list|()
block|{
name|time_t
name|t
decl_stmt|;
name|double
name|r
init|=
name|rand
argument_list|()
decl_stmt|;
name|t
operator|=
call|(
name|int
call|)
argument_list|(
name|RIP_TRIG_INT6_MIN
operator|+
operator|(
name|RIP_TRIG_INT6_MAX
operator|-
name|RIP_TRIG_INT6_MIN
operator|)
operator|*
operator|(
name|r
operator|/
name|RAND_MAX
operator|)
argument_list|)
expr_stmt|;
name|sup_trig_update
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|t
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fatal
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s"
argument_list|,
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rtdexit
argument_list|()
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|tracet
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|tracet
parameter_list|(
name|level
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|level
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|level
operator|<=
name|dflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|hms
argument_list|()
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dflag
condition|)
block|{
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|vsyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|vsyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|trace
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|trace
parameter_list|(
name|level
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|level
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|level
operator|<=
name|dflag
condition|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
block|{
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|vsyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|vsyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|if_maxindex
parameter_list|()
block|{
name|struct
name|if_nameindex
modifier|*
name|p
decl_stmt|,
modifier|*
name|p0
decl_stmt|;
name|unsigned
name|int
name|max
init|=
literal|0
decl_stmt|;
name|p0
operator|=
name|if_nameindex
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
operator|&&
name|p
operator|->
name|if_index
operator|&&
name|p
operator|->
name|if_name
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|max
operator|<
name|p
operator|->
name|if_index
condition|)
name|max
operator|=
name|p
operator|->
name|if_index
expr_stmt|;
block|}
name|if_freenameindex
argument_list|(
name|p0
argument_list|)
expr_stmt|;
return|return
name|max
return|;
block|}
end_function

begin_function
name|struct
name|ifc
modifier|*
name|ifc_find
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
for|for
control|(
name|ifcp
operator|=
name|ifc
init|;
name|ifcp
condition|;
name|ifcp
operator|=
name|ifcp
operator|->
name|ifc_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ifcp
operator|->
name|ifc_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ifcp
return|;
block|}
return|return
operator|(
expr|struct
name|ifc
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|iff
modifier|*
name|iff_find
parameter_list|(
name|ifcp
parameter_list|,
name|type
parameter_list|)
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|iff
modifier|*
name|iffp
decl_stmt|;
for|for
control|(
name|iffp
operator|=
name|ifcp
operator|->
name|ifc_filter
init|;
name|iffp
condition|;
name|iffp
operator|=
name|iffp
operator|->
name|iff_next
control|)
block|{
if|if
condition|(
name|iffp
operator|->
name|iff_type
operator|==
name|type
condition|)
return|return
name|iffp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|setindex2ifc
parameter_list|(
name|idx
parameter_list|,
name|ifcp
parameter_list|)
name|int
name|idx
decl_stmt|;
name|struct
name|ifc
modifier|*
name|ifcp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|struct
name|ifc
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|index2ifc
condition|)
block|{
name|nindex2ifc
operator|=
literal|5
expr_stmt|;
comment|/*initial guess*/
name|index2ifc
operator|=
operator|(
expr|struct
name|ifc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|index2ifc
argument_list|)
operator|*
name|nindex2ifc
argument_list|)
expr_stmt|;
if|if
condition|(
name|index2ifc
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|index2ifc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|index2ifc
argument_list|)
operator|*
name|nindex2ifc
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|nindex2ifc
expr_stmt|;
while|while
condition|(
name|nindex2ifc
operator|<=
name|idx
condition|)
name|nindex2ifc
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|nindex2ifc
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|ifc
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|index2ifc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|index2ifc
argument_list|)
operator|*
name|nindex2ifc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"realloc"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|memset
argument_list|(
name|p
operator|+
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|index2ifc
argument_list|)
operator|*
operator|(
name|nindex2ifc
operator|-
name|n
operator|)
argument_list|)
expr_stmt|;
name|index2ifc
operator|=
name|p
expr_stmt|;
block|}
name|index2ifc
index|[
name|idx
index|]
operator|=
name|ifcp
expr_stmt|;
block|}
end_function

end_unit

