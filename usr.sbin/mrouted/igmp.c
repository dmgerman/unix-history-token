begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * igmp.c,v 1.2 1994/09/08 02:51:15 wollman Exp  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|char
name|recv_buf
index|[
name|MAX_IP_PACKET_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input packet buffer         */
end_comment

begin_decl_stmt
name|char
name|send_buf
index|[
name|MAX_IP_PACKET_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output packet buffer        */
end_comment

begin_decl_stmt
name|int
name|igmp_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket for all network I/O  */
end_comment

begin_decl_stmt
name|u_long
name|allhosts_group
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allhosts  addr in net order */
end_comment

begin_decl_stmt
name|u_long
name|dvmrp_group
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DVMRP grp addr in net order */
end_comment

begin_decl_stmt
name|u_long
name|dvmrp_genid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IGMP generation id          */
end_comment

begin_comment
comment|/*  * Open and initialize the igmp socket, and fill in the non-changing  * IP header fields in the output packet buffer.  */
end_comment

begin_function
name|void
name|init_igmp
parameter_list|()
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|igmp_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_IGMP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"IGMP socket"
argument_list|)
expr_stmt|;
name|k_hdr_include
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* include IP header when sending */
name|k_set_rcvbuf
argument_list|(
literal|48
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* lots of input buffering        */
name|k_set_ttl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* restrict multicasts to one hop */
name|k_set_loop
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* disable multicast loopback     */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|send_buf
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_IGMP
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
comment|/* applies to unicasts only */
name|allhosts_group
operator|=
name|htonl
argument_list|(
name|INADDR_ALLHOSTS_GROUP
argument_list|)
expr_stmt|;
name|dvmrp_group
operator|=
name|htonl
argument_list|(
name|INADDR_DVMRP_GROUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* %%% hack for PIM %%% */
end_comment

begin_define
define|#
directive|define
name|IGMP_PIM
value|0x14
end_define

begin_define
define|#
directive|define
name|PIM_QUERY
value|0
end_define

begin_define
define|#
directive|define
name|PIM_REGISTER
value|1
end_define

begin_define
define|#
directive|define
name|PIM_REGISTER_STOP
value|2
end_define

begin_define
define|#
directive|define
name|PIM_JOIN_PRUNE
value|3
end_define

begin_define
define|#
directive|define
name|PIM_RP_REACHABLE
value|4
end_define

begin_define
define|#
directive|define
name|PIM_ASSERT
value|5
end_define

begin_define
define|#
directive|define
name|PIM_GRAFT
value|6
end_define

begin_define
define|#
directive|define
name|PIM_GRAFT_ACK
value|7
end_define

begin_function
specifier|static
name|char
modifier|*
name|packet_kind
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|u_char
name|type
decl_stmt|,
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IGMP_HOST_MEMBERSHIP_QUERY
case|:
return|return
literal|"membership query  "
return|;
case|case
name|IGMP_HOST_MEMBERSHIP_REPORT
case|:
return|return
literal|"membership report "
return|;
case|case
name|IGMP_HOST_NEW_MEMBERSHIP_REPORT
case|:
return|return
literal|"new membership report "
return|;
case|case
name|IGMP_HOST_LEAVE_MESSAGE
case|:
return|return
literal|"leave message"
return|;
case|case
name|IGMP_DVMRP
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DVMRP_PROBE
case|:
return|return
literal|"neighbor probe    "
return|;
case|case
name|DVMRP_REPORT
case|:
return|return
literal|"route report      "
return|;
case|case
name|DVMRP_ASK_NEIGHBORS
case|:
return|return
literal|"neighbor request  "
return|;
case|case
name|DVMRP_NEIGHBORS
case|:
return|return
literal|"neighbor list     "
return|;
case|case
name|DVMRP_ASK_NEIGHBORS2
case|:
return|return
literal|"neighbor request 2"
return|;
case|case
name|DVMRP_NEIGHBORS2
case|:
return|return
literal|"neighbor list 2   "
return|;
case|case
name|DVMRP_PRUNE
case|:
return|return
literal|"prune message	  "
return|;
case|case
name|DVMRP_GRAFT
case|:
return|return
literal|"graft message	  "
return|;
case|case
name|DVMRP_GRAFT_ACK
case|:
return|return
literal|"graft message ack "
return|;
default|default:
return|return
literal|"unknown DVMRP msg "
return|;
block|}
case|case
name|IGMP_PIM
case|:
comment|/* %%% hack for PIM %%% */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PIM_QUERY
case|:
return|return
literal|"PIM Router-Query  "
return|;
case|case
name|PIM_REGISTER
case|:
return|return
literal|"PIM Register      "
return|;
case|case
name|PIM_REGISTER_STOP
case|:
return|return
literal|"PIM Register-Stop "
return|;
case|case
name|PIM_JOIN_PRUNE
case|:
return|return
literal|"PIM Join/Prune    "
return|;
case|case
name|PIM_RP_REACHABLE
case|:
return|return
literal|"PIM RP-Reachable  "
return|;
case|case
name|PIM_ASSERT
case|:
return|return
literal|"PIM Assert        "
return|;
case|case
name|PIM_GRAFT
case|:
return|return
literal|"PIM Graft         "
return|;
case|case
name|PIM_GRAFT_ACK
case|:
return|return
literal|"PIM Graft-Ack     "
return|;
default|default:
return|return
literal|"unknown PIM msg   "
return|;
block|}
case|case
name|IGMP_MTRACE
case|:
return|return
literal|"IGMP trace query  "
return|;
case|case
name|IGMP_MTRACE_RESP
case|:
return|return
literal|"IGMP trace reply  "
return|;
default|default:
return|return
literal|"unknown IGMP msg  "
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a newly received IGMP packet that is sitting in the input  * packet buffer.  */
end_comment

begin_function
name|void
name|accept_igmp
parameter_list|(
name|recvlen
parameter_list|)
name|int
name|recvlen
decl_stmt|;
block|{
specifier|register
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
name|ipdatalen
decl_stmt|,
name|iphdrlen
decl_stmt|,
name|igmpdatalen
decl_stmt|;
if|if
condition|(
name|recvlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received packet too short (%u bytes) for IP header"
argument_list|,
name|recvlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
expr_stmt|;
name|src
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/*      * this is most likely a message from the kernel indicating that      * a new src grp pair message has arrived and so, it would be      * necessary to install a route into the kernel for this.      */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|src
operator|==
literal|0
operator|||
name|dst
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"kernel request not accurate"
argument_list|)
expr_stmt|;
else|else
name|add_table_entry
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
name|iphdrlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipdatalen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
if|if
condition|(
name|iphdrlen
operator|+
name|ipdatalen
operator|!=
name|recvlen
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received packet shorter (%u bytes) than hdr+data length (%u+%u)"
argument_list|,
name|recvlen
argument_list|,
name|iphdrlen
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
return|return;
block|}
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
name|iphdrlen
operator|)
expr_stmt|;
name|group
operator|=
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
expr_stmt|;
name|igmpdatalen
operator|=
name|ipdatalen
operator|-
name|IGMP_MINLEN
expr_stmt|;
if|if
condition|(
name|igmpdatalen
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received IP data field too short (%u bytes) for IGMP, from %s"
argument_list|,
name|ipdatalen
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"RECV %s from %-15s to %s"
argument_list|,
name|packet_kind
argument_list|(
name|igmp
operator|->
name|igmp_type
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|igmp
operator|->
name|igmp_type
condition|)
block|{
case|case
name|IGMP_HOST_MEMBERSHIP_QUERY
case|:
comment|/* we have to do the determination of the querrier router here */
return|return;
case|case
name|IGMP_HOST_MEMBERSHIP_REPORT
case|:
case|case
name|IGMP_HOST_NEW_MEMBERSHIP_REPORT
case|:
name|accept_group_report
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|,
name|igmp
operator|->
name|igmp_type
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGMP_HOST_LEAVE_MESSAGE
case|:
name|leave_group_message
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGMP_DVMRP
case|:
switch|switch
condition|(
name|igmp
operator|->
name|igmp_code
condition|)
block|{
case|case
name|DVMRP_PROBE
case|:
name|accept_probe
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|ntohl
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_REPORT
case|:
name|accept_report
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|ntohl
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_ASK_NEIGHBORS
case|:
name|accept_neighbor_request
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_ASK_NEIGHBORS2
case|:
name|accept_neighbor_request2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_NEIGHBORS
case|:
name|accept_neighbors
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_NEIGHBORS2
case|:
name|accept_neighbors2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_PRUNE
case|:
name|accept_prune
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_GRAFT
case|:
name|accept_graft
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_GRAFT_ACK
case|:
name|accept_g_ack
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring unknown DVMRP message code %u from %s to %s"
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|IGMP_PIM
case|:
comment|/* %%% hack for PIM  %%% */
return|return;
case|case
name|IGMP_MTRACE
case|:
name|mtrace
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring unknown IGMP message type %u from %s to %s"
argument_list|,
name|igmp
operator|->
name|igmp_type
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct an IGMP message in the output packet buffer.  The caller may  * have already placed data in that buffer, of length 'datalen'.  Then send  * the message from the interface with IP address 'src' to destination 'dst'.  */
end_comment

begin_function
name|void
name|send_igmp
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|,
name|group
parameter_list|,
name|datalen
parameter_list|)
name|u_long
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|type
decl_stmt|,
name|code
decl_stmt|;
name|u_long
name|group
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
specifier|static
name|struct
name|sockaddr_in
name|sdst
init|=
block|{
name|AF_INET
block|,
sizeof|sizeof
name|sdst
block|}
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|send_buf
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|+
name|datalen
expr_stmt|;
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|)
expr_stmt|;
name|igmp
operator|->
name|igmp_type
operator|=
name|type
expr_stmt|;
name|igmp
operator|->
name|igmp_code
operator|=
name|code
expr_stmt|;
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|=
name|group
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
name|inet_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|igmp
argument_list|,
name|IGMP_MINLEN
operator|+
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|k_set_if
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|allhosts_group
condition|)
name|k_set_loop
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|sdst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|igmp_socket
argument_list|,
name|send_buf
argument_list|,
name|ip
operator|->
name|ip_len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdst
argument_list|,
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENETDOWN
condition|)
name|check_vif_state
argument_list|()
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"sendto to %s on %s"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|==
name|allhosts_group
condition|)
name|k_set_loop
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"SENT %s from %-15s to %s"
argument_list|,
name|packet_kind
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

