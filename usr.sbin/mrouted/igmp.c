begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|recv_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input packet buffer         */
end_comment

begin_decl_stmt
name|char
modifier|*
name|send_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output packet buffer        */
end_comment

begin_decl_stmt
name|int
name|igmp_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket for all network I/O  */
end_comment

begin_decl_stmt
name|u_int32
name|allhosts_group
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All hosts addr in net order */
end_comment

begin_decl_stmt
name|u_int32
name|allrtrs_group
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All-Routers "  in net order */
end_comment

begin_decl_stmt
name|u_int32
name|dvmrp_group
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DVMRP grp addr in net order */
end_comment

begin_decl_stmt
name|u_int32
name|dvmrp_genid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IGMP generation id          */
end_comment

begin_comment
comment|/*  * Private variables  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|router_alert
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Router Alert IP Option	    */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IPOPT_RA
end_ifndef

begin_define
define|#
directive|define
name|IPOPT_RA
value|148
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS5
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|no_op
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Null IP Option		    */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ip_addlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Workaround for Option bug #2*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SEND_RA
parameter_list|(
name|x
parameter_list|)
value|(((x) == IGMP_MEMBERSHIP_QUERY) || \ 			 ((x) == IGMP_V1_MEMBERSHIP_REPORT) || \ 			 ((x) == IGMP_V2_MEMBERSHIP_REPORT) || \ 			 ((x) == IGMP_V2_LEAVE_GROUP) || \ 			 ((x) == IGMP_MTRACE))
end_define

begin_comment
comment|/*  * Local function definitions.  */
end_comment

begin_comment
comment|/* u_char promoted to u_int */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|packet_kind
name|__P
argument_list|(
operator|(
name|u_int
name|type
operator|,
name|u_int
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|igmp_log_level
name|__P
argument_list|(
operator|(
name|u_int
name|type
operator|,
name|u_int
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open and initialize the igmp socket, and fill in the non-changing  * IP header fields in the output packet buffer.  */
end_comment

begin_function
name|void
name|init_igmp
parameter_list|()
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNOS5
name|u_int32
name|localhost
init|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|recv_buf
operator|=
name|malloc
argument_list|(
name|RECV_BUF_SIZE
argument_list|)
expr_stmt|;
name|send_buf
operator|=
name|malloc
argument_list|(
name|RECV_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|igmp_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_IGMP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"IGMP socket"
argument_list|)
expr_stmt|;
name|k_hdr_include
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* include IP header when sending */
name|k_set_rcvbuf
argument_list|(
literal|48
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* lots of input buffering        */
name|k_set_ttl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* restrict multicasts to one hop */
name|k_set_loop
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* disable multicast loopback     */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|send_buf
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_IGMP
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
comment|/* applies to unicasts only */
name|allhosts_group
operator|=
name|htonl
argument_list|(
name|INADDR_ALLHOSTS_GROUP
argument_list|)
expr_stmt|;
name|dvmrp_group
operator|=
name|htonl
argument_list|(
name|INADDR_DVMRP_GROUP
argument_list|)
expr_stmt|;
name|allrtrs_group
operator|=
name|htonl
argument_list|(
name|INADDR_ALLRTRS_GROUP
argument_list|)
expr_stmt|;
name|router_alert
index|[
literal|0
index|]
operator|=
name|IPOPT_RA
expr_stmt|;
comment|/* Router Alert */
name|router_alert
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
comment|/* 4 bytes */
name|router_alert
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|router_alert
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNOS5
name|no_op
index|[
literal|0
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
name|no_op
index|[
literal|1
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
name|no_op
index|[
literal|2
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
name|no_op
index|[
literal|3
index|]
operator|=
name|IPOPT_NOP
expr_stmt|;
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|no_op
argument_list|,
sizeof|sizeof
argument_list|(
name|no_op
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Check if the kernel adds the options length to the packet      * length.  Send myself an IGMP packet of type 0 (illegal),      * with 4 IPOPT_NOP options, my PID (for collision detection)      * and 4 bytes of zero (so that the checksum works whether      * the 4 bytes of zero get truncated or not).      */
name|bzero
argument_list|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|send_igmp
argument_list|(
name|localhost
argument_list|,
name|localhost
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|recvlen
decl_stmt|,
name|dummy
init|=
literal|0
decl_stmt|;
name|recvlen
operator|=
name|recvfrom
argument_list|(
name|igmp_socket
argument_list|,
name|recv_buf
argument_list|,
name|RECV_BUF_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* 8 == 4 bytes of options and 4 bytes of PID */
if|if
condition|(
name|recvlen
operator|>=
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|+
literal|8
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|!=
literal|6
operator|||
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_IGMP
operator|||
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|localhost
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|localhost
condition|)
continue|continue;
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|igmp
operator|->
name|igmp_type
operator|!=
literal|0
operator|||
name|igmp
operator|->
name|igmp_code
operator|!=
literal|0
condition|)
continue|continue;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|igmp
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|getpid
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|==
name|IGMP_MINLEN
operator|+
literal|4
condition|)
name|ip_addlen
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|==
name|IGMP_MINLEN
operator|+
literal|8
condition|)
name|ip_addlen
operator|=
literal|0
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"while checking for Solaris bug: Sent %d bytes and got back %d!"
argument_list|,
name|IGMP_MINLEN
operator|+
literal|8
argument_list|,
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|PIM_QUERY
value|0
end_define

begin_define
define|#
directive|define
name|PIM_REGISTER
value|1
end_define

begin_define
define|#
directive|define
name|PIM_REGISTER_STOP
value|2
end_define

begin_define
define|#
directive|define
name|PIM_JOIN_PRUNE
value|3
end_define

begin_define
define|#
directive|define
name|PIM_RP_REACHABLE
value|4
end_define

begin_define
define|#
directive|define
name|PIM_ASSERT
value|5
end_define

begin_define
define|#
directive|define
name|PIM_GRAFT
value|6
end_define

begin_define
define|#
directive|define
name|PIM_GRAFT_ACK
value|7
end_define

begin_function
specifier|static
name|char
modifier|*
name|packet_kind
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|u_int
name|type
decl_stmt|,
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IGMP_HOST_MEMBERSHIP_QUERY
case|:
return|return
literal|"membership query  "
return|;
case|case
name|IGMP_HOST_MEMBERSHIP_REPORT
case|:
return|return
literal|"V1 member report  "
return|;
case|case
name|IGMP_HOST_NEW_MEMBERSHIP_REPORT
case|:
return|return
literal|"V2 member report  "
return|;
case|case
name|IGMP_HOST_LEAVE_MESSAGE
case|:
return|return
literal|"leave message     "
return|;
case|case
name|IGMP_DVMRP
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DVMRP_PROBE
case|:
return|return
literal|"neighbor probe    "
return|;
case|case
name|DVMRP_REPORT
case|:
return|return
literal|"route report      "
return|;
case|case
name|DVMRP_ASK_NEIGHBORS
case|:
return|return
literal|"neighbor request  "
return|;
case|case
name|DVMRP_NEIGHBORS
case|:
return|return
literal|"neighbor list     "
return|;
case|case
name|DVMRP_ASK_NEIGHBORS2
case|:
return|return
literal|"neighbor request 2"
return|;
case|case
name|DVMRP_NEIGHBORS2
case|:
return|return
literal|"neighbor list 2   "
return|;
case|case
name|DVMRP_PRUNE
case|:
return|return
literal|"prune message     "
return|;
case|case
name|DVMRP_GRAFT
case|:
return|return
literal|"graft message     "
return|;
case|case
name|DVMRP_GRAFT_ACK
case|:
return|return
literal|"graft message ack "
return|;
case|case
name|DVMRP_INFO_REQUEST
case|:
return|return
literal|"info request      "
return|;
case|case
name|DVMRP_INFO_REPLY
case|:
return|return
literal|"info reply        "
return|;
default|default:
return|return
literal|"unknown DVMRP msg "
return|;
block|}
case|case
name|IGMP_PIM
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PIM_QUERY
case|:
return|return
literal|"PIM Router-Query  "
return|;
case|case
name|PIM_REGISTER
case|:
return|return
literal|"PIM Register      "
return|;
case|case
name|PIM_REGISTER_STOP
case|:
return|return
literal|"PIM Register-Stop "
return|;
case|case
name|PIM_JOIN_PRUNE
case|:
return|return
literal|"PIM Join/Prune    "
return|;
case|case
name|PIM_RP_REACHABLE
case|:
return|return
literal|"PIM RP-Reachable  "
return|;
case|case
name|PIM_ASSERT
case|:
return|return
literal|"PIM Assert        "
return|;
case|case
name|PIM_GRAFT
case|:
return|return
literal|"PIM Graft         "
return|;
case|case
name|PIM_GRAFT_ACK
case|:
return|return
literal|"PIM Graft-Ack     "
return|;
default|default:
return|return
literal|"unknown PIM msg   "
return|;
block|}
case|case
name|IGMP_MTRACE
case|:
return|return
literal|"IGMP trace query  "
return|;
case|case
name|IGMP_MTRACE_RESP
case|:
return|return
literal|"IGMP trace reply  "
return|;
default|default:
return|return
literal|"unknown IGMP msg  "
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a newly received IGMP packet that is sitting in the input  * packet buffer.  */
end_comment

begin_function
name|void
name|accept_igmp
parameter_list|(
name|recvlen
parameter_list|)
name|int
name|recvlen
decl_stmt|;
block|{
specifier|register
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
name|ipdatalen
decl_stmt|,
name|iphdrlen
decl_stmt|,
name|igmpdatalen
decl_stmt|;
if|if
condition|(
name|recvlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received packet too short (%u bytes) for IP header"
argument_list|,
name|recvlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
expr_stmt|;
name|src
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/*       * this is most likely a message from the kernel indicating that      * a new src grp pair message has arrived and so, it would be       * necessary to install a route into the kernel for this.      */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|src
operator|==
literal|0
operator|||
name|dst
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"kernel request not accurate"
argument_list|)
expr_stmt|;
else|else
name|add_table_entry
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
name|iphdrlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipdatalen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
if|if
condition|(
name|iphdrlen
operator|+
name|ipdatalen
operator|!=
name|recvlen
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received packet from %s shorter (%u bytes) than hdr+data length (%u+%u)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|recvlen
argument_list|,
name|iphdrlen
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
return|return;
block|}
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
name|iphdrlen
operator|)
expr_stmt|;
name|group
operator|=
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
expr_stmt|;
name|igmpdatalen
operator|=
name|ipdatalen
operator|-
name|IGMP_MINLEN
expr_stmt|;
if|if
condition|(
name|igmpdatalen
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received IP data field too short (%u bytes) for IGMP, from %s"
argument_list|,
name|ipdatalen
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"RECV %s from %-15s to %s"
argument_list|,
name|packet_kind
argument_list|(
name|igmp
operator|->
name|igmp_type
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|igmp
operator|->
name|igmp_type
condition|)
block|{
case|case
name|IGMP_HOST_MEMBERSHIP_QUERY
case|:
name|accept_membership_query
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGMP_HOST_MEMBERSHIP_REPORT
case|:
case|case
name|IGMP_HOST_NEW_MEMBERSHIP_REPORT
case|:
name|accept_group_report
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|,
name|igmp
operator|->
name|igmp_type
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGMP_HOST_LEAVE_MESSAGE
case|:
name|accept_leave_message
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGMP_DVMRP
case|:
name|group
operator|=
name|ntohl
argument_list|(
name|group
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|igmp
operator|->
name|igmp_code
condition|)
block|{
case|case
name|DVMRP_PROBE
case|:
name|accept_probe
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_REPORT
case|:
name|accept_report
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_ASK_NEIGHBORS
case|:
name|accept_neighbor_request
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_ASK_NEIGHBORS2
case|:
name|accept_neighbor_request2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_NEIGHBORS
case|:
name|accept_neighbors
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_NEIGHBORS2
case|:
name|accept_neighbors2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_PRUNE
case|:
name|accept_prune
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_GRAFT
case|:
name|accept_graft
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_GRAFT_ACK
case|:
name|accept_g_ack
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_INFO_REQUEST
case|:
name|accept_info_request
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
case|case
name|DVMRP_INFO_REPLY
case|:
name|accept_info_reply
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring unknown DVMRP message code %u from %s to %s"
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|IGMP_PIM
case|:
return|return;
case|case
name|IGMP_MTRACE_RESP
case|:
return|return;
case|case
name|IGMP_MTRACE
case|:
name|accept_mtrace
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|group
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
return|return;
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring unknown IGMP message type %x from %s to %s"
argument_list|,
name|igmp
operator|->
name|igmp_type
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Some IGMP messages are more important than others.  This routine  * determines the logging level at which to log a send error (often  * "No route to host").  This is important when there is asymmetric  * reachability and someone is trying to, i.e., mrinfo me periodically.  */
end_comment

begin_function
specifier|static
name|int
name|igmp_log_level
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|u_int
name|type
decl_stmt|,
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IGMP_MTRACE_RESP
case|:
return|return
name|LOG_INFO
return|;
case|case
name|IGMP_DVMRP
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DVMRP_NEIGHBORS
case|:
case|case
name|DVMRP_NEIGHBORS2
case|:
return|return
name|LOG_INFO
return|;
block|}
block|}
return|return
name|LOG_WARNING
return|;
block|}
end_function

begin_comment
comment|/*  * Construct an IGMP message in the output packet buffer.  The caller may  * have already placed data in that buffer, of length 'datalen'.  Then send  * the message from the interface with IP address 'src' to destination 'dst'.  */
end_comment

begin_function
name|void
name|send_igmp
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|,
name|group
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|type
decl_stmt|,
name|code
decl_stmt|;
name|u_int32
name|group
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|sdst
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
name|setloop
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|raset
init|=
literal|0
decl_stmt|;
name|int
name|sendra
init|=
literal|0
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|send_buf
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|+
name|datalen
expr_stmt|;
name|sendlen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNOS5
name|ip
operator|->
name|ip_len
operator|+=
name|ip_addlen
expr_stmt|;
endif|#
directive|endif
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|)
expr_stmt|;
name|igmp
operator|->
name|igmp_type
operator|=
name|type
expr_stmt|;
name|igmp
operator|->
name|igmp_code
operator|=
name|code
expr_stmt|;
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|=
name|group
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
name|inet_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|igmp
argument_list|,
name|IGMP_MINLEN
operator|+
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
name|k_set_if
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|IGMP_DVMRP
operator|||
name|dst
operator|==
name|allhosts_group
condition|)
block|{
name|setloop
operator|=
literal|1
expr_stmt|;
name|k_set_loop
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SEND_RA
argument_list|(
name|type
argument_list|)
condition|)
name|sendra
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sendra
operator|&&
operator|!
name|raset
condition|)
block|{
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|router_alert
argument_list|,
sizeof|sizeof
argument_list|(
name|router_alert
argument_list|)
argument_list|)
expr_stmt|;
name|raset
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sendra
operator|&&
name|raset
condition|)
block|{
ifdef|#
directive|ifdef
name|SUNOS5
comment|/* 	 * SunOS5< 5.6 cannot properly reset the IP_OPTIONS "socket" 	 * option.  Instead, set up a string of 4 no-op's. 	 */
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|no_op
argument_list|,
sizeof|sizeof
argument_list|(
name|no_op
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|raset
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|sdst
argument_list|,
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
argument_list|)
expr_stmt|;
name|sdst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|sdst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sdst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|igmp_socket
argument_list|,
name|send_buf
argument_list|,
name|sendlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdst
argument_list|,
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENETDOWN
condition|)
name|check_vif_state
argument_list|()
expr_stmt|;
else|else
name|log
argument_list|(
name|igmp_log_level
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
argument_list|,
name|errno
argument_list|,
literal|"sendto to %s on %s"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setloop
condition|)
name|k_set_loop
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"SENT %s from %-15s to %s"
argument_list|,
name|packet_kind
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
argument_list|,
name|src
operator|==
name|INADDR_ANY
condition|?
literal|"INADDR_ANY"
else|:
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

