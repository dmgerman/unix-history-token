begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * $Id: prune.c,v 1.4 1994/08/24 23:54:33 thyagara Exp $  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|cache_lifetime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_prune_lifetime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * dither cache lifetime to obtain a value between x and 2*x  */
end_comment

begin_define
define|#
directive|define
name|CACHE_LIFETIME
parameter_list|(
name|x
parameter_list|)
value|((x) + (random() % (x)))
end_define

begin_define
define|#
directive|define
name|CHK_GS
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{	\ 		switch(x) { \ 			case 2:	\ 			case 4:	\ 			case 8:	\ 			case 16: \ 			case 32: \ 			case 64: \ 			case 128: \ 			case 256: y = 1; \ 				  break; \ 			default:  y = 0; \ 		} \ 	}
end_define

begin_decl_stmt
specifier|static
name|struct
name|ktable
modifier|*
name|kernel_rtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to list of kernel rt entries */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|kroutes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current number of cache entries  */
end_comment

begin_comment
comment|/*  * Initialize the kernel table structure  */
end_comment

begin_function
name|void
name|init_ktable
parameter_list|()
block|{
name|kernel_rtable
operator|=
name|NULL
expr_stmt|;
name|kroutes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Determine if mcastgrp has a listener on vifi  */
end_comment

begin_function
name|int
name|grplst_mem
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
block|{
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
if|if
condition|(
name|mcastgrp
operator|==
name|g
operator|->
name|al_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Updates the ttl values for each vif.  */
end_comment

begin_function
name|void
name|prun_add_ttls
parameter_list|(
name|kt
parameter_list|)
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
condition|)
name|kt
operator|->
name|kt_ttls
index|[
name|vifi
index|]
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
else|else
name|kt
operator|->
name|kt_ttls
index|[
name|vifi
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * checks for scoped multicast addresses  */
end_comment

begin_define
define|#
directive|define
name|GET_SCOPE
parameter_list|(
name|kt
parameter_list|)
value|{ \ 	register int _i; \ 	if (((kt)->kt_mcastgrp& 0xff000000) == 0xef000000) \ 	    for (_i = 0; _i< numvifs; _i++) \ 		if (scoped_addr(_i, (kt)->kt_mcastgrp)) \ 		    VIFM_SET(_i, (kt)->kt_scope); \ 	}
end_define

begin_function
name|int
name|scoped_addr
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
block|{
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
for|for
control|(
name|acl
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_acl
init|;
name|acl
condition|;
name|acl
operator|=
name|acl
operator|->
name|acl_next
control|)
if|if
condition|(
operator|(
name|addr
operator|&
name|acl
operator|->
name|acl_mask
operator|)
operator|==
name|acl
operator|->
name|acl_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Add a new table entry for (origin, mcastgrp)  */
end_comment

begin_function
name|void
name|add_table_entry
parameter_list|(
name|origin
parameter_list|,
name|mcastgrp
parameter_list|)
name|u_long
name|origin
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|kt
operator|=
name|find_src_grp
argument_list|(
name|origin
argument_list|,
name|mcastgrp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"kernel entry exists for (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|determine_route
argument_list|(
name|origin
argument_list|)
expr_stmt|;
comment|/* allocate space for the new entry */
name|kt
operator|=
operator|(
expr|struct
name|ktable
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ktable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|kroutes
operator|++
expr_stmt|;
comment|/* add the new values in */
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|kt
operator|->
name|kt_origin
operator|=
name|origin
expr_stmt|;
name|kt
operator|->
name|kt_mcastgrp
operator|=
name|mcastgrp
expr_stmt|;
name|kt
operator|->
name|kt_originmask
operator|=
literal|0xffffffff
expr_stmt|;
name|kt
operator|->
name|kt_parent
operator|=
name|NO_VIF
expr_stmt|;
name|kt
operator|->
name|kt_gateway
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_children
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_leaves
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_grpmems
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|NULL
expr_stmt|;
name|kt
operator|->
name|kt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_prun_count
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_scope
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|kt
operator|->
name|kt_origin
operator|=
name|r
operator|->
name|rt_origin
expr_stmt|;
name|kt
operator|->
name|kt_mcastgrp
operator|=
name|mcastgrp
expr_stmt|;
name|kt
operator|->
name|kt_originmask
operator|=
name|r
operator|->
name|rt_originmask
expr_stmt|;
name|kt
operator|->
name|kt_parent
operator|=
name|r
operator|->
name|rt_parent
expr_stmt|;
name|kt
operator|->
name|kt_gateway
operator|=
name|r
operator|->
name|rt_gateway
expr_stmt|;
name|kt
operator|->
name|kt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_grpmems
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|NULL
expr_stmt|;
name|kt
operator|->
name|kt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_prun_count
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_scope
operator|=
literal|0
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_children
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_leaves
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
expr_stmt|;
comment|/* obtain the multicast group membership list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
operator|&&
operator|!
operator|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|&&
name|grplst_mem
argument_list|(
name|i
argument_list|,
name|mcastgrp
argument_list|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
block|}
name|GET_SCOPE
argument_list|(
name|kt
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|kt
operator|->
name|kt_parent
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
name|kt
operator|->
name|kt_grpmems
operator|=
name|NULL
expr_stmt|;
else|else
name|kt
operator|->
name|kt_grpmems
operator|&=
operator|~
name|kt
operator|->
name|kt_scope
expr_stmt|;
block|}
comment|/* update the kernel_rtable pointer */
name|kt
operator|->
name|kt_next
operator|=
name|kernel_rtable
expr_stmt|;
name|kernel_rtable
operator|=
name|kt
expr_stmt|;
comment|/* update ttls and add entry into kernel */
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"add entry s:%x g:%x gm:%x"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
comment|/* If there are no leaf vifs      * which have this group, then      * mark this src-grp as a prune candidate.       * One thing to do is to check if parent vif is the source      * and not send a prune to that.      */
if|if
condition|(
operator|!
name|kt
operator|->
name|kt_grpmems
operator|&&
name|kt
operator|->
name|kt_gateway
condition|)
name|send_prune
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An mrouter has gone down and come up on an interface  * Forward on that interface immediately  */
end_comment

begin_function
name|void
name|reset_neighbor_state
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
block|{
name|struct
name|ktable
modifier|*
name|prev_kt
decl_stmt|,
modifier|*
name|kt
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|prev_krl
decl_stmt|,
modifier|*
name|krl
decl_stmt|;
comment|/* Check each src-grp entry to see if it was pruned on that interface        If so, forward on that interface */
for|for
control|(
name|prev_kt
operator|=
operator|(
expr|struct
name|ktable
operator|*
operator|)
operator|&
name|kernel_rtable
operator|,
name|kt
operator|=
name|kernel_rtable
init|;
name|kt
condition|;
name|prev_kt
operator|=
name|kt
operator|,
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
block|{
for|for
control|(
name|prev_krl
operator|=
operator|(
expr|struct
name|prunlst
operator|*
operator|)
operator|&
name|kt
operator|->
name|kt_rlist
operator|,
name|krl
operator|=
name|prev_krl
operator|->
name|rl_next
init|;
name|krl
condition|;
name|prev_krl
operator|=
name|krl
operator|,
name|krl
operator|=
name|krl
operator|->
name|rl_next
control|)
block|{
if|if
condition|(
name|krl
operator|->
name|rl_router
operator|==
name|addr
condition|)
block|{
name|prev_krl
operator|->
name|rl_next
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
name|krl
argument_list|)
expr_stmt|;
name|krl
operator|=
name|prev_krl
expr_stmt|;
name|kt
operator|->
name|kt_prun_count
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * If neighbor was the parent, remove the prune sent state 	 * Don't send any grafts upstream. 	 */
if|if
condition|(
name|vifi
operator|==
name|kt
operator|->
name|kt_parent
condition|)
block|{
name|k_del_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|prev_kt
operator|->
name|kt_next
operator|=
name|kt
operator|->
name|kt_next
expr_stmt|;
while|while
condition|(
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
condition|)
block|{
name|kt
operator|->
name|kt_rlist
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kt
argument_list|)
expr_stmt|;
name|kt
operator|=
name|prev_kt
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Neighbor was not the parent, send grafts to join the groups 	 */
if|if
condition|(
name|kt
operator|->
name|kt_prsent_timer
condition|)
block|{
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|1
expr_stmt|;
name|send_graft
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
condition|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
operator|&&
operator|!
operator|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|)
condition|)
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|&&
name|grplst_mem
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|)
condition|)
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_grpmems
operator|&=
operator|~
name|kt
operator|->
name|kt_scope
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Delete table entry from the kernel  * del_flag determines how many entries to delete  */
end_comment

begin_function
name|void
name|del_table_entry
parameter_list|(
name|r
parameter_list|,
name|mcastgrp
parameter_list|,
name|del_flag
parameter_list|)
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
name|u_int
name|del_flag
decl_stmt|;
block|{
name|struct
name|mfcctl
name|mc
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|,
modifier|*
name|prev_kt
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
if|if
condition|(
name|del_flag
operator|==
name|DEL_ALL_ROUTES
condition|)
block|{
for|for
control|(
name|prev_kt
operator|=
operator|(
expr|struct
name|ktable
operator|*
operator|)
operator|&
name|kernel_rtable
init|;
name|kt
operator|=
name|prev_kt
operator|->
name|kt_next
condition|;
name|prev_kt
operator|=
name|kt
control|)
block|{
if|if
condition|(
operator|(
name|kt
operator|->
name|kt_origin
operator|&
name|r
operator|->
name|rt_originmask
operator|)
operator|==
name|r
operator|->
name|rt_origin
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"delete all rtes %x grp %x"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
name|k_del_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
comment|/* free prun list entries */
while|while
condition|(
name|kt
operator|->
name|kt_rlist
condition|)
block|{
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
block|}
comment|/* free the source mcastgrp entry */
name|prev_kt
operator|->
name|kt_next
operator|=
name|kt
operator|->
name|kt_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kt
argument_list|)
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
name|kt
operator|=
name|prev_kt
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|del_flag
operator|==
name|DEL_RTE_GROUP
condition|)
block|{
for|for
control|(
name|prev_kt
operator|=
operator|(
expr|struct
name|ktable
operator|*
operator|)
operator|&
name|kernel_rtable
init|;
operator|(
name|prev_kt
operator|)
operator|&&
operator|(
name|kt
operator|=
name|prev_kt
operator|->
name|kt_next
operator|)
condition|;
name|prev_kt
operator|=
name|kt
control|)
block|{
if|if
condition|(
operator|(
name|kt
operator|->
name|kt_origin
operator|&
name|r
operator|->
name|rt_originmask
operator|)
operator|==
name|r
operator|->
name|rt_origin
operator|&&
name|kt
operator|->
name|kt_mcastgrp
operator|==
name|mcastgrp
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"delete src %x grp %x"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
name|k_del_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
comment|/* free prun list entries */
while|while
condition|(
name|kt
operator|->
name|kt_rlist
condition|)
block|{
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
block|}
comment|/* free the source mcastgrp entry */
name|prev_kt
operator|->
name|kt_next
operator|=
name|kt
operator|->
name|kt_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kt
argument_list|)
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * update kernel table entry when a route entry changes  */
end_comment

begin_function
name|void
name|update_table_entry
parameter_list|(
name|r
parameter_list|)
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
block|{
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|changed
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|kernel_rtable
init|;
name|kt
condition|;
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
if|if
condition|(
operator|(
name|kt
operator|->
name|kt_origin
operator|&
name|r
operator|->
name|rt_originmask
operator|)
operator|==
name|r
operator|->
name|rt_origin
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_leaves
operator|!=
name|r
operator|->
name|rt_leaves
condition|)
name|changed
operator|++
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_children
operator|!=
name|r
operator|->
name|rt_children
condition|)
name|changed
operator|++
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_parent
operator|!=
name|r
operator|->
name|rt_parent
condition|)
name|changed
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
continue|continue;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"update entry: s %-15s g %-15s"
argument_list|,
name|inet_fmt
argument_list|(
name|kt
operator|->
name|kt_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|kt
operator|->
name|kt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* free prun list entries */
while|while
condition|(
name|kt
operator|->
name|kt_rlist
condition|)
block|{
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
block|}
name|kt
operator|->
name|kt_parent
operator|=
name|r
operator|->
name|rt_parent
expr_stmt|;
name|kt
operator|->
name|kt_gateway
operator|=
name|r
operator|->
name|rt_gateway
expr_stmt|;
name|kt
operator|->
name|kt_grpmems
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_prun_count
operator|=
literal|0
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_children
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_leaves
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
expr_stmt|;
comment|/* obtain the multicast group membership list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
operator|&&
operator|!
operator|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|&&
name|grplst_mem
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|kt
operator|->
name|kt_parent
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
name|kt
operator|->
name|kt_grpmems
operator|=
name|NULL
expr_stmt|;
else|else
name|kt
operator|->
name|kt_grpmems
operator|&=
operator|~
name|kt
operator|->
name|kt_scope
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_grpmems
operator|&&
name|kt
operator|->
name|kt_prsent_timer
condition|)
block|{
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|1
expr_stmt|;
name|send_graft
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update ttls and add entry into kernel */
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kt
operator|->
name|kt_grpmems
operator|&&
name|kt
operator|->
name|kt_gateway
condition|)
block|{
name|kt
operator|->
name|kt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|send_prune
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * set the forwarding flag for all mcastgrps on this vifi  */
end_comment

begin_function
name|void
name|update_lclgrp
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"group %x joined at vif %d"
argument_list|,
name|mcastgrp
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|kernel_rtable
init|;
name|kt
condition|;
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
if|if
condition|(
name|kt
operator|->
name|kt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_grpmems
operator|&=
operator|~
name|kt
operator|->
name|kt_scope
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_grpmems
operator|==
name|NULL
condition|)
continue|continue;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * reset forwarding flag for all mcastgrps on this vifi  */
end_comment

begin_function
name|void
name|delete_lclgrp
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"group %x left at vif %d"
argument_list|,
name|mcastgrp
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|kernel_rtable
init|;
name|kt
condition|;
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
if|if
condition|(
name|kt
operator|->
name|kt_mcastgrp
operator|==
name|mcastgrp
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
comment|/* 	     * If there are no more members of this particular group, 	     *  send prune upstream 	     */
if|if
condition|(
name|kt
operator|->
name|kt_grpmems
operator|==
name|NULL
operator|&&
name|kt
operator|->
name|kt_gateway
condition|)
name|send_prune
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if the neighbor supports pruning  */
end_comment

begin_function
name|int
name|pruning_neighbor
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|al_next
control|)
if|if
condition|(
operator|(
name|u
operator|->
name|al_addr
operator|==
name|addr
operator|)
operator|&&
operator|(
name|u
operator|->
name|al_pv
operator|>
literal|2
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a prune message to the upstream router  * given by the kt->kt_gateway argument. The origin and   * multicast group can be determined from the kt   * structure.  *  * Also, record an entry that a prune was sent for this group  */
end_comment

begin_function
name|void
name|send_prune
parameter_list|(
name|kt
parameter_list|)
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
block|{
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
comment|/* Don't process any prunes if router is not pruning */
if|if
condition|(
name|pruning
operator|==
literal|0
condition|)
return|return;
comment|/* Don't send a prune to a non-pruning router */
if|if
condition|(
operator|!
name|pruning_neighbor
argument_list|(
name|kt
operator|->
name|kt_parent
argument_list|,
name|kt
operator|->
name|kt_gateway
argument_list|)
condition|)
return|return;
comment|/*       * sends a prune message to the router upstream.      */
name|src
operator|=
name|uvifs
index|[
name|kt
operator|->
name|kt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|dst
operator|=
name|kt
operator|->
name|kt_gateway
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
comment|/*      * determine prune lifetime      */
name|kt
operator|->
name|kt_prsent_timer
operator|=
name|kt
operator|->
name|kt_timer
expr_stmt|;
for|for
control|(
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
init|;
name|krl
condition|;
name|krl
operator|=
name|krl
operator|->
name|rl_next
control|)
if|if
condition|(
name|krl
operator|->
name|rl_timer
operator|<
name|kt
operator|->
name|kt_prsent_timer
condition|)
name|kt
operator|->
name|kt_prsent_timer
operator|=
name|krl
operator|->
name|rl_timer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_prsent_timer
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|12
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_PRUNE
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/*	log(LOG_DEBUG, 0, "send prune for src:%x, grp:%x up to %x", 	kt->kt_origin, kt->kt_mcastgrp, kt->kt_gateway);*/
block|}
end_function

begin_comment
comment|/*  * Takes the prune message received and then strips it to  * determine the (src, grp) pair to be pruned.  *  * Adds the router to the (src, grp) entry then.  *  * Determines if further packets have to be sent down that vif  *  * Determines if a corresponding prune message has to be generated  */
end_comment

begin_function
name|void
name|accept_prune
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_long
name|prun_src
decl_stmt|;
name|u_long
name|prun_dst
decl_stmt|;
name|u_long
name|prun_tmr
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|stop_sending
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|pr_recv
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|vr
decl_stmt|;
comment|/* Don't process any prunes if router is not pruning */
if|if
condition|(
name|pruning
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring prune report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|<
literal|0
operator|||
name|datalen
operator|>
literal|12
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable prune report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_dst
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_tmr
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|kt
operator|=
name|find_src_grp
argument_list|(
name|prun_src
argument_list|,
name|prun_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"prune message received incorrectly"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring prune report from non-child %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring prune report from %s on scoped vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check if prune has been received from this source */
if|if
condition|(
operator|!
name|no_entry_exists
argument_list|(
name|src
argument_list|,
name|kt
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"duplicate prune from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d prunes (%s %s) tmr %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_dst
argument_list|,
name|s3
argument_list|)
argument_list|,
name|prun_tmr
argument_list|)
expr_stmt|;
comment|/* allocate space for the prune structure */
name|pr_recv
operator|=
operator|(
expr|struct
name|prunlst
operator|*
operator|)
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prunlst
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pr_recv
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"pr_recv: ran out of memory"
argument_list|)
expr_stmt|;
name|pr_recv
operator|->
name|rl_vifi
operator|=
name|vifi
expr_stmt|;
name|pr_recv
operator|->
name|rl_router
operator|=
name|src
expr_stmt|;
name|pr_recv
operator|->
name|rl_timer
operator|=
name|prun_tmr
expr_stmt|;
comment|/*       * add this prune message to the list of prunes received       * for this src group pair       */
name|pr_recv
operator|->
name|rl_next
operator|=
name|kt
operator|->
name|kt_rlist
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|pr_recv
expr_stmt|;
name|kt
operator|->
name|kt_prun_count
operator|++
expr_stmt|;
name|kt
operator|->
name|kt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_timer
operator|<
name|prun_tmr
condition|)
name|kt
operator|->
name|kt_timer
operator|=
name|prun_tmr
expr_stmt|;
comment|/*      * check if any more packets need to be sent on the       * vif which sent this message      */
for|for
control|(
name|vr
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
operator|,
name|stop_sending
operator|=
literal|1
init|;
name|vr
condition|;
name|vr
operator|=
name|vr
operator|->
name|al_next
control|)
if|if
condition|(
name|no_entry_exists
argument_list|(
name|vr
operator|->
name|al_addr
argument_list|,
name|kt
argument_list|)
condition|)
block|{
name|stop_sending
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_sending
operator|&&
operator|!
name|grplst_mem
argument_list|(
name|vifi
argument_list|,
name|prun_dst
argument_list|)
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
comment|/*      * check if all the child routers have expressed no interest      * in this group and if this group does not exist in the       * interface      * Send a prune message then upstream      */
if|if
condition|(
name|kt
operator|->
name|kt_grpmems
operator|==
name|NULL
operator|&&
name|kt
operator|->
name|kt_gateway
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"snt prun up %d %d"
argument_list|,
name|kt
operator|->
name|kt_prun_count
argument_list|,
name|rtr_cnt
argument_list|(
name|kt
argument_list|)
argument_list|)
expr_stmt|;
name|send_prune
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns 1 if router vr is not present in the prunlist of kt  */
end_comment

begin_function
name|int
name|no_entry_exists
parameter_list|(
name|vr
parameter_list|,
name|kt
parameter_list|)
name|u_long
name|vr
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
block|{
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
for|for
control|(
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
init|;
name|krl
condition|;
name|krl
operator|=
name|krl
operator|->
name|rl_next
control|)
if|if
condition|(
name|krl
operator|->
name|rl_router
operator|==
name|vr
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Finds the entry for the source group pair in the table  */
end_comment

begin_function
name|struct
name|ktable
modifier|*
name|find_src_grp
parameter_list|(
name|src
parameter_list|,
name|grp
parameter_list|)
name|u_long
name|src
decl_stmt|;
name|u_long
name|grp
decl_stmt|;
block|{
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|kernel_rtable
init|;
name|kt
condition|;
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
if|if
condition|(
operator|(
name|kt
operator|->
name|kt_origin
operator|==
operator|(
name|src
operator|&
name|kt
operator|->
name|kt_originmask
operator|)
operator|)
operator|&&
operator|(
name|kt
operator|->
name|kt_mcastgrp
operator|==
name|grp
operator|)
condition|)
return|return
name|kt
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*   * scans through the neighbor list of this router and then  * determines the total no. of child routers present  */
end_comment

begin_function
name|int
name|rtr_cnt
parameter_list|(
name|kt
parameter_list|)
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
block|{
name|int
name|ri
decl_stmt|;
name|int
name|rcount
init|=
literal|0
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|numvifs
condition|;
name|ri
operator|++
control|)
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|ri
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
condition|)
for|for
control|(
name|u
operator|=
name|uvifs
index|[
name|ri
index|]
operator|.
name|uv_neighbors
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|al_next
control|)
name|rcount
operator|++
expr_stmt|;
return|return
name|rcount
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if this mcastgrp is present in the kernel table  * If so and if a prune was sent, it sends a graft upwards  */
end_comment

begin_function
name|void
name|chkgrp_graft
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
for|for
control|(
name|kt
operator|=
name|kernel_rtable
init|;
name|kt
condition|;
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
if|if
condition|(
name|kt
operator|->
name|kt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
condition|)
if|if
condition|(
name|kt
operator|->
name|kt_prsent_timer
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
comment|/* 		 * If the vif that was joined was a scoped vif, 		 * ignore it ; don't graft back 		 */
name|kt
operator|->
name|kt_grpmems
operator|&=
operator|~
name|kt
operator|->
name|kt_scope
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_grpmems
operator|==
name|NULL
condition|)
continue|continue;
comment|/* set the flag for graft retransmission */
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|1
expr_stmt|;
comment|/* send graft upwards */
name|send_graft
argument_list|(
name|kt
argument_list|)
expr_stmt|;
comment|/* reset the prune timer and update cache timer*/
name|kt
operator|->
name|kt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|kt
operator|->
name|kt_timer
operator|=
name|max_prune_lifetime
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* determine the multicast group and src  *   * if it does, then determine if a prune was sent   * upstream.  * if prune sent upstream, send graft upstream and send  * ack downstream.  *   * if no prune sent upstream, change the forwarding bit  * for this interface and send ack downstream.  *  * if no entry exists for this group just ignore the message  * [this may not be the right thing to do. but lets see what   * happens for the time being and then we might decide to do  * a modification to the code depending on the type of behaviour   * that we see in this]  */
end_comment

begin_function
name|void
name|accept_graft
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|prun_src
decl_stmt|;
name|u_long
name|prun_dst
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|prev_krl
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring graft report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|<
literal|0
operator|||
name|datalen
operator|>
literal|8
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable graft report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_dst
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d grafts (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|find_src_grp
argument_list|(
name|prun_src
argument_list|,
name|prun_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"incorrect graft received from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"incorrect graft received from %s on scoped vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* remove prune entry from the list       * allow forwarding on that vif, make change in the kernel      */
for|for
control|(
name|prev_krl
operator|=
operator|(
expr|struct
name|prunlst
operator|*
operator|)
operator|&
name|kt
operator|->
name|kt_rlist
init|;
name|krl
operator|=
name|prev_krl
operator|->
name|rl_next
condition|;
name|prev_krl
operator|=
name|krl
control|)
if|if
condition|(
operator|(
name|krl
operator|->
name|rl_vifi
operator|)
operator|==
name|vifi
operator|&&
operator|(
name|krl
operator|->
name|rl_router
operator|==
name|src
operator|)
condition|)
block|{
name|prev_krl
operator|->
name|rl_next
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
name|krl
operator|=
name|prev_krl
expr_stmt|;
name|kt
operator|->
name|kt_prun_count
operator|--
expr_stmt|;
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* send ack downstream */
name|send_graft_ack
argument_list|(
name|kt
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|kt
operator|->
name|kt_timer
operator|=
name|max_prune_lifetime
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|kt_prsent_timer
condition|)
block|{
comment|/* set the flag for graft retransmission */
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|1
expr_stmt|;
comment|/* send graft upwards */
name|send_graft
argument_list|(
name|kt
argument_list|)
expr_stmt|;
comment|/* reset the prune sent timer */
name|kt
operator|->
name|kt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send an ack that a graft was received  */
end_comment

begin_function
name|void
name|send_graft_ack
parameter_list|(
name|kt
parameter_list|,
name|to
parameter_list|)
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|u_long
name|to
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|src
operator|=
name|uvifs
index|[
name|kt
operator|->
name|kt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|dst
operator|=
name|to
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|8
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_GRAFT_ACK
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"send graft ack for src:%x, grp:%x to %x"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * a prune was sent upstream  * so, a graft has to be sent to annul the prune  * set up a graft timer so that if an ack is not   * heard within that time, another graft request  * is sent out.  */
end_comment

begin_function
name|void
name|send_graft
parameter_list|(
name|kt
parameter_list|)
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|src
operator|=
name|uvifs
index|[
name|kt
operator|->
name|kt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|dst
operator|=
name|kt
operator|->
name|kt_gateway
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|kt
operator|->
name|kt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_GRAFT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"send graft for src:%x, grp:%x up to %x"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|,
name|kt
operator|->
name|kt_gateway
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find out which group is involved first of all   * then determine if a graft was sent.  * if no graft sent, ignore the message  * if graft was sent and the ack is from the right   * source, remove the graft timer so that we don't   * have send a graft again  */
end_comment

begin_function
name|void
name|accept_g_ack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|u_long
name|grft_src
decl_stmt|;
name|u_long
name|grft_dst
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring graft ack report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|<
literal|0
operator|||
name|datalen
operator|>
literal|8
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable graft ack report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|grft_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|grft_dst
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d acks graft (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|grft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grft_dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|=
name|find_src_grp
argument_list|(
name|grft_src
argument_list|,
name|grft_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received wrong graft ack from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kt
operator|->
name|kt_grftsnt
condition|)
name|kt
operator|->
name|kt_grftsnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free all prune entries  */
end_comment

begin_function
name|void
name|free_all_prunes
parameter_list|()
block|{
specifier|register
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
specifier|register
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
while|while
condition|(
name|kernel_rtable
operator|!=
name|NULL
condition|)
block|{
name|kt
operator|=
name|kernel_rtable
expr_stmt|;
name|kernel_rtable
operator|=
name|kt
operator|->
name|kt_next
expr_stmt|;
while|while
condition|(
name|kt
operator|->
name|kt_rlist
operator|!=
name|NULL
condition|)
block|{
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
expr_stmt|;
name|kt
operator|->
name|kt_rlist
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kt
argument_list|)
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Advance the timers on all the cache entries.  * If there are any entries whose timers have expired,  * remove these entries from the kernel cache.  */
end_comment

begin_function
name|void
name|age_table_entry
parameter_list|()
block|{
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|struct
name|ktable
modifier|*
name|prev_kt
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
name|struct
name|prunlst
modifier|*
name|prev_krl
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"kr:%x pr:%x"
argument_list|,
name|kernel_rtable
argument_list|,
operator|(
expr|struct
name|ktable
operator|*
operator|)
operator|&
name|kernel_rtable
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_kt
operator|=
operator|(
expr|struct
name|ktable
operator|*
operator|)
operator|&
name|kernel_rtable
init|;
name|kt
operator|=
name|prev_kt
operator|->
name|kt_next
condition|;
name|prev_kt
operator|=
name|kt
control|)
block|{
comment|/* advance the timer for the kernel entry */
name|kt
operator|->
name|kt_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
expr_stmt|;
comment|/* decrement prune timer if need be */
if|if
condition|(
name|kt
operator|->
name|kt_prsent_timer
condition|)
name|kt
operator|->
name|kt_prsent_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
expr_stmt|;
comment|/* retransmit graft if graft sent flag is still set */
if|if
condition|(
name|kt
operator|->
name|kt_grftsnt
condition|)
block|{
specifier|register
name|int
name|y
decl_stmt|;
name|CHK_GS
argument_list|(
name|kt
operator|->
name|kt_grftsnt
operator|++
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
name|send_graft
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
comment|/* delete the entry only if there are no subordinate  	   routers 	    	   Now, if there are subordinate routers, then, what we  	   have to do is to decrement each and every router's  	   time entry too and decide if we want to forward on 	   that link basically 	   */
for|for
control|(
name|prev_krl
operator|=
operator|(
expr|struct
name|prunlst
operator|*
operator|)
operator|&
name|kt
operator|->
name|kt_rlist
operator|,
name|krl
operator|=
name|prev_krl
operator|->
name|rl_next
init|;
name|krl
condition|;
name|prev_krl
operator|=
name|krl
operator|,
name|krl
operator|=
name|krl
operator|->
name|rl_next
control|)
block|{
if|if
condition|(
operator|(
name|krl
operator|->
name|rl_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
operator|)
operator|<=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"forw again s %x g%x on vif %d"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|,
name|krl
operator|->
name|rl_vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|krl
operator|->
name|rl_vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|krl
operator|->
name|rl_vifi
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
block|}
name|kt
operator|->
name|kt_prun_count
operator|--
expr_stmt|;
name|prev_krl
operator|->
name|rl_next
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|krl
argument_list|)
expr_stmt|;
name|krl
operator|=
name|prev_krl
expr_stmt|;
if|if
condition|(
name|krl
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|kt
operator|->
name|kt_timer
operator|<=
literal|0
condition|)
block|{
comment|/* 	     * If there are prune entries still outstanding,  	     * update the cache timer otherwise expire entry. 	     */
if|if
condition|(
name|kt
operator|->
name|kt_rlist
condition|)
block|{
name|kt
operator|->
name|kt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"age route s %x g %x"
argument_list|,
name|kt
operator|->
name|kt_origin
argument_list|,
name|kt
operator|->
name|kt_mcastgrp
argument_list|)
expr_stmt|;
name|k_del_rg
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|prev_kt
operator|->
name|kt_next
operator|=
name|kt
operator|->
name|kt_next
expr_stmt|;
comment|/* free all the prune list entries */
name|krl
operator|=
name|kt
operator|->
name|kt_rlist
expr_stmt|;
while|while
condition|(
name|krl
condition|)
block|{
name|prev_krl
operator|=
name|krl
expr_stmt|;
name|krl
operator|=
name|krl
operator|->
name|rl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prev_krl
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kt
argument_list|)
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
name|kt
operator|=
name|prev_kt
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print the contents of the routing table on file 'fp'.  */
end_comment

begin_function
name|void
name|dump_cache
parameter_list|(
name|fp2
parameter_list|)
name|FILE
modifier|*
name|fp2
decl_stmt|;
block|{
specifier|register
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
specifier|register
name|struct
name|prunlst
modifier|*
name|krl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"Multicast Routing Cache Table (%d entries)\n%s"
argument_list|,
name|kroutes
argument_list|,
literal|" Origin-Subnet   Mcast-group      CTmr IVif Prcv# Psnt Forwvifs\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|kernel_rtable
operator|,
name|count
operator|=
literal|0
init|;
name|kt
operator|!=
name|NULL
condition|;
name|kt
operator|=
name|kt
operator|->
name|kt_next
control|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-15s %-15s"
argument_list|,
name|inet_fmts
argument_list|(
name|kt
operator|->
name|kt_origin
argument_list|,
name|kt
operator|->
name|kt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|kt
operator|->
name|kt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|kt
operator|->
name|kt_parent
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %5u  %2ub %3u    %c  "
argument_list|,
name|kt
operator|->
name|kt_timer
argument_list|,
name|kt
operator|->
name|kt_parent
argument_list|,
name|kt
operator|->
name|kt_prun_count
argument_list|,
name|kt
operator|->
name|kt_prsent_timer
condition|?
literal|'P'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %5u  %2u  %3u    %c  "
argument_list|,
name|kt
operator|->
name|kt_timer
argument_list|,
name|kt
operator|->
name|kt_parent
argument_list|,
name|kt
operator|->
name|kt_prun_count
argument_list|,
name|kt
operator|->
name|kt_prsent_timer
condition|?
literal|'P'
else|:
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_grpmems
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u "
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
operator|&&
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u%c"
argument_list|,
name|i
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_children
argument_list|)
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|kt
operator|->
name|kt_leaves
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u%c"
argument_list|,
name|i
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if there are any routers that can understand traceroute  * downstream  */
end_comment

begin_function
name|int
name|can_forward
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|al_next
control|)
if|if
condition|(
operator|(
operator|(
name|u
operator|->
name|al_pv
operator|>
literal|2
operator|)
operator|&&
operator|(
name|u
operator|->
name|al_mv
operator|>
literal|2
operator|)
operator|)
operator|||
operator|(
name|u
operator|->
name|al_pv
operator|>
literal|3
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Traceroute function which returns traceroute replies to the requesting  * router. Also forwards the request to downstream routers.  */
end_comment

begin_function
name|void
name|mtrace
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|data
parameter_list|,
name|no
parameter_list|,
name|datalen
parameter_list|)
name|u_long
name|src
decl_stmt|;
name|u_long
name|dst
decl_stmt|;
name|u_long
name|group
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_char
name|no
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_char
name|type
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|tr_query
modifier|*
name|qry
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|resp
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|vifi
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|ktable
modifier|*
name|kt
decl_stmt|;
name|int
name|rcount
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|struct
name|sioc_vif_req
name|v_req
decl_stmt|;
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
comment|/* timestamp the request/response */
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
comment|/*      * Check if it is a query or a response      */
if|if
condition|(
name|datalen
operator|==
name|QLEN
condition|)
block|{
name|type
operator|=
name|QUERY
expr_stmt|;
name|printf
argument_list|(
literal|"Traceroute query rcvd\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|RESP
expr_stmt|;
name|printf
argument_list|(
literal|"Traceroute response rcvd\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Non decipherable trace request %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|qry
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
name|data
expr_stmt|;
comment|/*      * if it is a multicast packet with all reports filled, drop it      */
if|if
condition|(
operator|(
name|rcount
operator|=
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
operator|)
operator|==
name|no
condition|)
block|{
name|printf
argument_list|(
literal|"multicast packet with reports filled in\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"s: %s g: %s d: %s "
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|group
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rttl: %d rd: %s\n"
argument_list|,
name|qry
operator|->
name|tr_rttl
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_raddr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rcount:%d\n"
argument_list|,
name|rcount
argument_list|)
expr_stmt|;
comment|/* determine the routing table entry for this traceroute */
name|rt
operator|=
name|determine_route
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|)
expr_stmt|;
comment|/*      * Query type packet - check if rte exists       * Check if the query destination is a vif connected to me.      * and if so, whether I should start response back      */
if|if
condition|(
name|type
operator|==
name|QUERY
condition|)
block|{
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Mcast traceroute: no route entry %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
block|}
for|for
control|(
name|v
operator|=
name|uvifs
operator|,
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
operator|(
operator|(
name|qry
operator|->
name|tr_dst
operator|&
name|v
operator|->
name|uv_subnetmask
operator|)
operator|==
name|v
operator|->
name|uv_subnet
operator|)
condition|)
break|break;
if|if
condition|(
name|vifi
operator|==
name|numvifs
condition|)
block|{
name|printf
argument_list|(
literal|"Destination %s not an interface\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rt
operator|!=
name|NULL
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Destination %s not on forwarding tree for src %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* 	 * determine which interface the packet came in on 	 */
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|printf
argument_list|(
literal|"Wrong interface for packet\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"Sending traceroute response\n"
argument_list|)
expr_stmt|;
comment|/* copy the packet to the sending buffer */
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|datalen
expr_stmt|;
comment|/*      * fill in initial response fields      */
name|resp
operator|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
name|p
expr_stmt|;
name|resp
operator|->
name|tr_qarr
operator|=
operator|(
operator|(
name|tp
operator|.
name|tv_sec
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|tp
operator|.
name|tv_usec
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|resp
operator|->
name|tr_vifin
operator|=
literal|0
expr_stmt|;
comment|/* default values */
name|resp
operator|->
name|tr_pktcnt
operator|=
literal|0
expr_stmt|;
comment|/* default values */
name|resp
operator|->
name|tr_rproto
operator|=
name|PROTO_DVMRP
expr_stmt|;
name|resp
operator|->
name|tr_smask
operator|=
literal|0
expr_stmt|;
name|resp
operator|->
name|tr_outaddr
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|resp
operator|->
name|tr_fttl
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_threshold
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_ERR
expr_stmt|;
comment|/*      * obtain # of packets out on interface      */
name|v_req
operator|.
name|vifi
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifout
operator|=
name|v_req
operator|.
name|ocount
expr_stmt|;
comment|/*      * fill in scoping& pruning information      */
name|kt
operator|=
name|find_src_grp
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|!=
name|NULL
condition|)
block|{
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|qry
operator|->
name|tr_src
expr_stmt|;
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_pktcnt
operator|=
name|sg_req
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|kt
operator|->
name|kt_scope
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_SCOPED
expr_stmt|;
elseif|else
if|if
condition|(
name|kt
operator|->
name|kt_prsent_timer
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_PRUNED
expr_stmt|;
block|}
comment|/*      *  if no rte exists, set NO_RTE error      */
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|src
operator|=
name|dst
expr_stmt|;
comment|/* the dst address of resp. pkt */
name|resp
operator|->
name|tr_inaddr
operator|=
name|NULL
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_RTE
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* get # of packets in on interface */
name|v_req
operator|.
name|vifi
operator|=
name|rt
operator|->
name|rt_parent
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifin
operator|=
name|v_req
operator|.
name|icount
expr_stmt|;
name|MASK_TO_VAL
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|,
name|resp
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
name|src
operator|=
name|uvifs
index|[
name|rt
operator|->
name|rt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|resp
operator|->
name|tr_inaddr
operator|=
name|src
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Destination %s not on forwarding tree for src %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
comment|/*      * if metric is 1 or no. of reports is 1, send response to requestor      * else send to upstream router.      */
name|printf
argument_list|(
literal|"rcount:%d, no:%d\n"
argument_list|,
name|rcount
argument_list|,
name|no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcount
operator|+
literal|1
operator|==
name|no
operator|)
operator|||
operator|(
name|rt
operator|->
name|rt_metric
operator|==
literal|1
operator|)
condition|)
name|dst
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
else|else
name|dst
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
name|k_set_ttl
argument_list|(
name|qry
operator|->
name|tr_rttl
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_MTRACE_RESP
argument_list|,
name|no
argument_list|,
name|group
argument_list|,
name|datalen
operator|+
name|RLEN
argument_list|)
expr_stmt|;
name|k_set_ttl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|no
argument_list|,
name|group
argument_list|,
name|datalen
operator|+
name|RLEN
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

