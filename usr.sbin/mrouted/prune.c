begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|cache_lifetime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_prune_lifetime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|rtentry
modifier|*
name|routing_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|phys_vif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * dither cache lifetime to obtain a value between x and 2*x  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|CACHE_LIFETIME
parameter_list|(
name|x
parameter_list|)
value|((x) + (lrand48() % (x)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CACHE_LIFETIME
parameter_list|(
name|x
parameter_list|)
value|((x) + (random() % (x)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHK_GS
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{	\ 		switch(x) { \ 			case 2:	\ 			case 4:	\ 			case 8:	\ 			case 16: \ 			case 32: \ 			case 64: \ 			case 128: \ 			case 256: y = 1; \ 				  break; \ 			default:  y = 0; \ 		} \ 	}
end_define

begin_decl_stmt
name|struct
name|gtable
modifier|*
name|kernel_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to list of kernel grp entries*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gtable
modifier|*
name|kernel_no_route
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of grp entries w/o routes   */
end_comment

begin_decl_stmt
name|struct
name|gtable
modifier|*
name|gtp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer for kernel rt entries    */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|kroutes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current number of cache entries  */
end_comment

begin_comment
comment|/****************************************************************************                        Functions that are local to prune.c ****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|void
name|prun_add_ttls
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pruning_neighbor
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_mtrace
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ptable
modifier|*
name|find_prune_entry
name|__P
argument_list|(
operator|(
name|u_int32
name|vr
operator|,
expr|struct
name|ptable
operator|*
name|pt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expire_prune
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_prune
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_graft
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_graft_ack
name|__P
argument_list|(
operator|(
name|u_int32
name|src
operator|,
name|u_int32
name|dst
operator|,
name|u_int32
name|origin
operator|,
name|u_int32
name|grp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_kernel
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|g
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scaletime
name|__P
argument_list|(
operator|(
name|u_long
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Updates the ttl values for each vif.  */
end_comment

begin_function
specifier|static
name|void
name|prun_add_ttls
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
name|gt
operator|->
name|gt_ttls
index|[
name|vifi
index|]
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
else|else
name|gt
operator|->
name|gt_ttls
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * checks for scoped multicast addresses  */
end_comment

begin_define
define|#
directive|define
name|GET_SCOPE
parameter_list|(
name|gt
parameter_list|)
value|{ \ 	register vifi_t _i; \ 	if ((ntohl((gt)->gt_mcastgrp)& 0xff000000) == 0xef000000) \ 	    for (_i = 0; _i< numvifs; _i++) \ 		if (scoped_addr(_i, (gt)->gt_mcastgrp)) \ 		    VIFM_SET(_i, (gt)->gt_scope); \ 	}
end_define

begin_function
name|int
name|scoped_addr
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
for|for
control|(
name|acl
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_acl
init|;
name|acl
condition|;
name|acl
operator|=
name|acl
operator|->
name|acl_next
control|)
if|if
condition|(
operator|(
name|addr
operator|&
name|acl
operator|->
name|acl_mask
operator|)
operator|==
name|acl
operator|->
name|acl_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Determine if mcastgrp has a listener on vifi  */
end_comment

begin_function
name|int
name|grplst_mem
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
if|if
condition|(
name|mcastgrp
operator|==
name|g
operator|->
name|al_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Finds the group entry with the specified source and netmask.  * If netmask is 0, it uses the route's netmask.  *  * Returns TRUE if found a match, and the global variable gtp is left  * pointing to entry before the found entry.  * Returns FALSE if no exact match found, gtp is left pointing to before  * the entry in question belongs, or is NULL if the it belongs at the  * head of the list.  */
end_comment

begin_function
name|int
name|find_src_grp
parameter_list|(
name|src
parameter_list|,
name|mask
parameter_list|,
name|grp
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|u_int32
name|grp
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|gtp
operator|=
name|NULL
expr_stmt|;
name|gt
operator|=
name|kernel_table
expr_stmt|;
while|while
condition|(
name|gt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|grp
operator|==
name|gt
operator|->
name|gt_mcastgrp
operator|&&
operator|(
name|mask
condition|?
operator|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|==
name|src
operator|&&
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
operator|==
name|mask
operator|)
else|:
operator|(
operator|(
name|src
operator|&
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
operator|)
operator|==
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|>
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|||
operator|(
name|grp
operator|==
name|gt
operator|->
name|gt_mcastgrp
operator|&&
operator|(
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|<
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
argument_list|)
operator|||
operator|(
name|mask
operator|==
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
operator|&&
operator|(
name|ntohl
argument_list|(
name|src
argument_list|)
operator|>
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|gtp
operator|=
name|gt
expr_stmt|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the neighbor supports pruning  */
end_comment

begin_function
specifier|static
name|int
name|pruning_neighbor
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|n
init|=
name|neighbor_info
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|int
name|vers
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NF_PRUNE
condition|)
return|return
literal|1
return|;
comment|/*      * Versions from 3.0 to 3.4 relied on the version number to identify      * that they could handle pruning.      */
name|vers
operator|=
name|NBR_VERS
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|vers
operator|>=
literal|0x0300
operator|&&
name|vers
operator|<=
literal|0x0304
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can the neighbor in question handle multicast traceroute?  */
end_comment

begin_function
specifier|static
name|int
name|can_mtrace
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|n
init|=
name|neighbor_info
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|int
name|vers
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NF_MTRACE
condition|)
return|return
literal|1
return|;
comment|/*      * Versions 3.3 and 3.4 relied on the version number to identify      * that they could handle traceroute.      */
name|vers
operator|=
name|NBR_VERS
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|vers
operator|>=
literal|0x0303
operator|&&
name|vers
operator|<=
literal|0x0304
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the prune entry of the router, or NULL if none exists  */
end_comment

begin_function
specifier|static
name|struct
name|ptable
modifier|*
name|find_prune_entry
parameter_list|(
name|vr
parameter_list|,
name|pt
parameter_list|)
name|u_int32
name|vr
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
block|{
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|pt_router
operator|==
name|vr
condition|)
return|return
name|pt
return|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Send a prune message to the dominant router for  * this source.  *  * Record an entry that a prune was sent for this group  */
end_comment

begin_function
specifier|static
name|void
name|send_prune
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|u_int32
name|tmp
decl_stmt|;
comment|/* Don't process any prunes if router is not pruning */
if|if
condition|(
name|pruning
operator|==
literal|0
condition|)
return|return;
comment|/* Can't process a prune if we don't have an associated route */
if|if
condition|(
name|gt
operator|->
name|gt_route
operator|==
name|NULL
condition|)
return|return;
comment|/* Don't send a prune to a non-pruning router */
if|if
condition|(
operator|!
name|pruning_neighbor
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|)
condition|)
return|return;
comment|/*       * sends a prune message to the router upstream.      */
name|src
operator|=
name|uvifs
index|[
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|dst
operator|=
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
comment|/*      * determine prune lifetime      */
name|gt
operator|->
name|gt_prsent_timer
operator|=
name|gt
operator|->
name|gt_timer
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|gt
operator|->
name|gt_pruntbl
init|;
name|pt
condition|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
control|)
if|if
condition|(
name|pt
operator|->
name|pt_timer
operator|<
name|gt
operator|->
name|gt_prsent_timer
condition|)
name|gt
operator|->
name|gt_prsent_timer
operator|=
name|pt
operator|->
name|pt_timer
expr_stmt|;
comment|/*      * If we have a graft pending, cancel graft retransmission      */
name|gt
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|htonl
argument_list|(
name|gt
operator|->
name|gt_prsent_timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|tmp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|12
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_PRUNE
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sent prune for (%s %s)/%d on vif %d to %s"
argument_list|,
name|inet_fmts
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * a prune was sent upstream  * so, a graft has to be sent to annul the prune  * set up a graft timer so that if an ack is not   * heard within that time, another graft request  * is sent out.  */
end_comment

begin_function
specifier|static
name|void
name|send_graft
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
comment|/* Can't send a graft without an associated route */
if|if
condition|(
name|gt
operator|->
name|gt_route
operator|==
name|NULL
condition|)
return|return;
name|src
operator|=
name|uvifs
index|[
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|dst
operator|=
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_GRAFT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sent graft for (%s %s) to %s on vif %d"
argument_list|,
name|inet_fmts
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send an ack that a graft was received  */
end_comment

begin_function
specifier|static
name|void
name|send_graft_ack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|origin
parameter_list|,
name|grp
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|u_int32
name|origin
decl_stmt|;
name|u_int32
name|grp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|grp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|8
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_GRAFT_ACK
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sent graft ack for (%s, %s) to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the kernel cache with all the routes hanging off the group entry  */
end_comment

begin_function
specifier|static
name|void
name|update_kernel
parameter_list|(
name|g
parameter_list|)
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
for|for
control|(
name|st
operator|=
name|g
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
name|k_add_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************                           Functions that are used externally ****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SNMP
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"snmp.h"
end_include

begin_comment
comment|/*  * Find a specific group entry in the group table  */
end_comment

begin_function
name|struct
name|gtable
modifier|*
name|find_grp
parameter_list|(
name|grp
parameter_list|)
name|u_long
name|grp
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
for|for
control|(
name|gt
operator|=
name|kernel_table
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|gt
operator|->
name|gt_mcastgrp
operator|==
name|grp
condition|)
return|return
name|gt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Given a group entry and source, find the corresponding source table  * entry  */
end_comment

begin_function
name|struct
name|stable
modifier|*
name|find_grp_src
parameter_list|(
name|gt
parameter_list|,
name|src
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|u_long
name|src
decl_stmt|;
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
name|u_long
name|grp
init|=
name|gt
operator|->
name|gt_mcastgrp
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gtcurr
decl_stmt|;
for|for
control|(
name|gtcurr
operator|=
name|gt
init|;
name|gtcurr
operator|->
name|gt_mcastgrp
operator|==
name|grp
condition|;
name|gtcurr
operator|=
name|gtcurr
operator|->
name|gt_gnext
control|)
block|{
for|for
control|(
name|st
operator|=
name|gtcurr
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
if|if
condition|(
name|st
operator|->
name|st_origin
operator|==
name|src
condition|)
return|return
name|st
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*   * Find next entry> specification   */
end_comment

begin_function
name|int
name|next_grp_src_mask
parameter_list|(
name|gtpp
parameter_list|,
name|stpp
parameter_list|,
name|grp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|)
name|struct
name|gtable
modifier|*
modifier|*
name|gtpp
decl_stmt|;
comment|/* ordered by group  */
name|struct
name|stable
modifier|*
modifier|*
name|stpp
decl_stmt|;
comment|/* ordered by source */
name|u_long
name|grp
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|mask
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
name|gbest
init|=
name|NULL
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
name|sbest
init|=
name|NULL
decl_stmt|;
comment|/* Find first group entry>= grp spec */
operator|(
operator|*
name|gtpp
operator|)
operator|=
name|kernel_table
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|gtpp
operator|)
operator|&&
name|ntohl
argument_list|(
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|grp
argument_list|)
condition|)
operator|(
operator|*
name|gtpp
operator|)
operator|=
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_gnext
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|gtpp
operator|)
condition|)
return|return
literal|0
return|;
comment|/* no more groups */
for|for
control|(
name|gt
operator|=
name|kernel_table
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
control|)
block|{
comment|/* Since grps are ordered, we can stop when group changes from gbest */
if|if
condition|(
name|gbest
operator|&&
name|gbest
operator|->
name|gt_mcastgrp
operator|!=
name|gt
operator|->
name|gt_mcastgrp
condition|)
break|break;
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
block|{
comment|/* Among those entries> spec, find "lowest" one */
if|if
condition|(
operator|(
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|>
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|==
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|>
name|ntohl
argument_list|(
name|src
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|==
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|==
name|src
operator|&&
literal|0xFFFFFFFF
operator|>
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|gbest
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|gbest
operator|->
name|gt_mcastgrp
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|==
name|ntohl
argument_list|(
name|gbest
operator|->
name|gt_mcastgrp
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|<
name|ntohl
argument_list|(
name|sbest
operator|->
name|st_origin
argument_list|)
operator|)
operator|)
condition|)
block|{
name|gbest
operator|=
name|gt
expr_stmt|;
name|sbest
operator|=
name|st
expr_stmt|;
block|}
block|}
block|}
operator|(
operator|*
name|gtpp
operator|)
operator|=
name|gbest
expr_stmt|;
operator|(
operator|*
name|stpp
operator|)
operator|=
name|sbest
expr_stmt|;
return|return
operator|(
operator|*
name|gtpp
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that sg contains current information for the given group,source.  * This is fetched from the kernel as a unit so that counts for the entry   * are consistent, i.e. packet and byte counts for the same entry are   * read at the same time.  */
end_comment

begin_function
name|void
name|refresh_sg
parameter_list|(
name|sg
parameter_list|,
name|gt
parameter_list|,
name|st
parameter_list|)
name|struct
name|sioc_sg_req
modifier|*
name|sg
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
block|{
specifier|static
name|int
name|lastq
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|quantum
operator|!=
name|lastq
operator|||
name|sg
operator|->
name|src
operator|.
name|s_addr
operator|!=
name|st
operator|->
name|st_origin
operator|||
name|sg
operator|->
name|grp
operator|.
name|s_addr
operator|!=
name|gt
operator|->
name|gt_mcastgrp
condition|)
block|{
name|lastq
operator|=
name|quantum
expr_stmt|;
name|sg
operator|->
name|src
operator|.
name|s_addr
operator|=
name|st
operator|->
name|st_origin
expr_stmt|;
name|sg
operator|->
name|grp
operator|.
name|s_addr
operator|=
name|gt
operator|->
name|gt_mcastgrp
expr_stmt|;
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return pointer to a specific route entry.  This must be a separate  * function from find_route() which modifies rtp.  */
end_comment

begin_function
name|struct
name|rtentry
modifier|*
name|snmp_find_route
parameter_list|(
name|src
parameter_list|,
name|mask
parameter_list|)
specifier|register
name|u_long
name|src
decl_stmt|,
name|mask
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|routing_table
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|src
operator|==
name|rt
operator|->
name|rt_origin
operator|&&
name|mask
operator|==
name|rt
operator|->
name|rt_originmask
condition|)
return|return
name|rt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Find next route entry> specification   */
end_comment

begin_function
name|int
name|next_route
parameter_list|(
name|rtpp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|)
name|struct
name|rtentry
modifier|*
modifier|*
name|rtpp
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|mask
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|,
modifier|*
name|rbest
init|=
name|NULL
decl_stmt|;
comment|/* Among all entries> spec, find "lowest" one in order */
for|for
control|(
name|rt
operator|=
name|routing_table
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|>
name|ntohl
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|==
name|ntohl
argument_list|(
name|src
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|)
operator|>
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|rbest
operator|||
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|<
name|ntohl
argument_list|(
name|rbest
operator|->
name|rt_origin
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|==
name|ntohl
argument_list|(
name|rbest
operator|->
name|rt_origin
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|)
operator|<
name|ntohl
argument_list|(
name|rbest
operator|->
name|rt_originmask
argument_list|)
operator|)
operator|)
condition|)
name|rbest
operator|=
name|rt
expr_stmt|;
block|}
operator|(
operator|*
name|rtpp
operator|)
operator|=
name|rbest
expr_stmt|;
return|return
operator|(
operator|*
name|rtpp
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a routing table entry, and a vifi, find the next vifi/entry  */
end_comment

begin_function
name|int
name|next_route_child
parameter_list|(
name|rtpp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|,
name|vifi
parameter_list|)
name|struct
name|rtentry
modifier|*
modifier|*
name|rtpp
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|mask
decl_stmt|;
name|vifi_t
modifier|*
name|vifi
decl_stmt|;
comment|/* vif at which to start looking */
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* Get (S,M) entry */
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|rtpp
operator|)
operator|=
name|snmp_find_route
argument_list|(
name|src
argument_list|,
name|mask
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
name|next_route
argument_list|(
name|rtpp
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Continue until we get one with a valid next vif */
do|do
block|{
for|for
control|(
init|;
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_children
operator|&&
operator|*
name|vifi
operator|<
name|numvifs
condition|;
operator|(
operator|*
name|vifi
operator|)
operator|++
control|)
if|if
condition|(
name|VIFM_ISSET
argument_list|(
operator|*
name|vifi
argument_list|,
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_children
argument_list|)
condition|)
return|return
literal|1
return|;
operator|*
name|vifi
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|next_route
argument_list|(
name|rtpp
argument_list|,
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_origin
argument_list|,
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_originmask
argument_list|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a routing table entry, and a vifi, find the next entry  * equal to or greater than those  */
end_comment

begin_function
name|int
name|next_child
parameter_list|(
name|gtpp
parameter_list|,
name|stpp
parameter_list|,
name|grp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|,
name|vifi
parameter_list|)
name|struct
name|gtable
modifier|*
modifier|*
name|gtpp
decl_stmt|;
name|struct
name|stable
modifier|*
modifier|*
name|stpp
decl_stmt|;
name|u_long
name|grp
decl_stmt|;
name|u_long
name|src
decl_stmt|;
name|u_long
name|mask
decl_stmt|;
name|vifi_t
modifier|*
name|vifi
decl_stmt|;
comment|/* vif at which to start looking */
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
comment|/* Get (G,S,M) entry */
if|if
condition|(
name|mask
operator|!=
literal|0xFFFFFFFF
operator|||
operator|!
operator|(
operator|(
operator|*
name|gtpp
operator|)
operator|=
name|find_grp
argument_list|(
name|grp
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|stpp
operator|)
operator|=
name|find_grp_src
argument_list|(
operator|(
operator|*
name|gtpp
operator|)
argument_list|,
name|src
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
name|next_grp_src_mask
argument_list|(
name|gtpp
argument_list|,
name|stpp
argument_list|,
name|grp
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Continue until we get one with a valid next vif */
do|do
block|{
for|for
control|(
init|;
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_route
operator|->
name|rt_children
operator|&&
operator|*
name|vifi
operator|<
name|numvifs
condition|;
operator|(
operator|*
name|vifi
operator|)
operator|++
control|)
if|if
condition|(
name|VIFM_ISSET
argument_list|(
operator|*
name|vifi
argument_list|,
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_route
operator|->
name|rt_children
argument_list|)
condition|)
return|return
literal|1
return|;
operator|*
name|vifi
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|next_grp_src_mask
argument_list|(
name|gtpp
argument_list|,
name|stpp
argument_list|,
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_mcastgrp
argument_list|,
operator|(
operator|*
name|stpp
operator|)
operator|->
name|st_origin
argument_list|,
literal|0xFFFFFFFF
argument_list|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNMP */
end_comment

begin_comment
comment|/*  * Initialize the kernel table structure  */
end_comment

begin_function
name|void
name|init_ktable
parameter_list|()
block|{
name|kernel_table
operator|=
name|NULL
expr_stmt|;
name|kernel_no_route
operator|=
name|NULL
expr_stmt|;
name|kroutes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Add a new table entry for (origin, mcastgrp)  */
end_comment

begin_function
name|void
name|add_table_entry
parameter_list|(
name|origin
parameter_list|,
name|mcastgrp
parameter_list|)
name|u_int32
name|origin
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
modifier|*
name|gtnp
decl_stmt|,
modifier|*
name|prev_gt
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
modifier|*
name|stnp
decl_stmt|;
name|vifi_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MFC
name|md_log
argument_list|(
name|MD_MISS
argument_list|,
name|origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|determine_route
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|prev_gt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Look for it on the no_route table; if it is found then 	 * it will be detected as a duplicate below. 	 */
for|for
control|(
name|gt
operator|=
name|kernel_no_route
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
if|if
condition|(
name|mcastgrp
operator|==
name|gt
operator|->
name|gt_mcastgrp
operator|&&
name|gt
operator|->
name|gt_srctbl
operator|&&
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
operator|==
name|origin
condition|)
break|break;
name|gtnp
operator|=
operator|&
name|kernel_no_route
expr_stmt|;
block|}
else|else
block|{
name|gtnp
operator|=
operator|&
name|r
operator|->
name|rt_groups
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_mcastgrp
operator|>=
name|mcastgrp
condition|)
break|break;
name|gtnp
operator|=
operator|&
name|gt
operator|->
name|gt_next
expr_stmt|;
name|prev_gt
operator|=
name|gt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gt
operator|==
name|NULL
operator|||
name|gt
operator|->
name|gt_mcastgrp
operator|!=
name|mcastgrp
condition|)
block|{
name|gt
operator|=
operator|(
expr|struct
name|gtable
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_mcastgrp
operator|=
name|mcastgrp
expr_stmt|;
name|gt
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|gt
operator|->
name|gt_ctime
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_grpmems
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_scope
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_srctbl
operator|=
name|NULL
expr_stmt|;
name|gt
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
name|gt
operator|->
name|gt_route
operator|=
name|r
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|gt
operator|->
name|gt_rsrr_cache
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
comment|/* obtain the multicast group membership list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|&&
operator|!
operator|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
operator|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
operator|&&
name|grplst_mem
argument_list|(
name|i
argument_list|,
name|mcastgrp
argument_list|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
block|}
name|GET_SCOPE
argument_list|(
name|gt
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|r
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|)
name|gt
operator|->
name|gt_scope
operator|=
operator|-
literal|1
expr_stmt|;
name|gt
operator|->
name|gt_grpmems
operator|&=
operator|~
name|gt
operator|->
name|gt_scope
expr_stmt|;
block|}
else|else
block|{
name|gt
operator|->
name|gt_scope
operator|=
operator|-
literal|1
expr_stmt|;
name|gt
operator|->
name|gt_grpmems
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update ttls */
name|prun_add_ttls
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_next
operator|=
operator|*
name|gtnp
expr_stmt|;
operator|*
name|gtnp
operator|=
name|gt
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
expr_stmt|;
name|gt
operator|->
name|gt_prev
operator|=
name|prev_gt
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|find_src_grp
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Entry for (%s %s) (rt:%x) exists (rt:%x)"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|r
argument_list|,
name|g
operator|->
name|gt_route
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gtp
condition|)
block|{
name|gt
operator|->
name|gt_gnext
operator|=
name|gtp
operator|->
name|gt_gnext
expr_stmt|;
name|gt
operator|->
name|gt_gprev
operator|=
name|gtp
expr_stmt|;
name|gtp
operator|->
name|gt_gnext
operator|=
name|gt
expr_stmt|;
block|}
else|else
block|{
name|gt
operator|->
name|gt_gnext
operator|=
name|kernel_table
expr_stmt|;
name|gt
operator|->
name|gt_gprev
operator|=
name|NULL
expr_stmt|;
name|kernel_table
operator|=
name|gt
expr_stmt|;
block|}
if|if
condition|(
name|gt
operator|->
name|gt_gnext
condition|)
name|gt
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|gt
expr_stmt|;
block|}
block|}
else|else
block|{
name|gt
operator|->
name|gt_gnext
operator|=
name|gt
operator|->
name|gt_gprev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|stnp
operator|=
operator|&
name|gt
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
operator|*
name|stnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|>=
name|ntohl
argument_list|(
name|origin
argument_list|)
condition|)
break|break;
name|stnp
operator|=
operator|&
name|st
operator|->
name|st_next
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|==
name|NULL
operator|||
name|st
operator|->
name|st_origin
operator|!=
name|origin
condition|)
block|{
name|st
operator|=
operator|(
expr|struct
name|stable
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_origin
operator|=
name|origin
expr_stmt|;
name|st
operator|->
name|st_pktcnt
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_next
operator|=
operator|*
name|stnp
expr_stmt|;
operator|*
name|stnp
operator|=
name|st
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_MFC
name|md_log
argument_list|(
name|MD_DUPE
argument_list|,
name|origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"kernel entry already exists for (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX Doing this should cause no harm, and may ensure  	 * kernel<>mrouted synchronization */
name|k_add_rg
argument_list|(
name|origin
argument_list|,
name|gt
argument_list|)
expr_stmt|;
return|return;
block|}
name|kroutes
operator|++
expr_stmt|;
name|k_add_rg
argument_list|(
name|origin
argument_list|,
name|gt
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"add cache entry (%s %s) gm:%x, parent-vif:%d"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|,
name|r
condition|?
name|r
operator|->
name|rt_parent
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If there are no leaf vifs      * which have this group, then      * mark this src-grp as a prune candidate.       */
if|if
condition|(
operator|!
name|gt
operator|->
name|gt_prsent_timer
operator|&&
operator|!
name|gt
operator|->
name|gt_grpmems
operator|&&
name|r
operator|&&
name|r
operator|->
name|rt_gateway
condition|)
name|send_prune
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An mrouter has gone down and come up on an interface  * Forward on that interface immediately  */
end_comment

begin_function
name|void
name|reset_neighbor_state
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
comment|/* 	 * If neighbor was the parent, remove the prune sent state 	 * and all of the source cache info so that prunes get 	 * regenerated. 	 */
if|if
condition|(
name|vifi
operator|==
name|r
operator|->
name|rt_parent
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|r
operator|->
name|rt_gateway
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"reset_neighbor_state parent reset (%s %s)"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
name|g
operator|->
name|gt_srctbl
operator|)
condition|)
block|{
name|g
operator|->
name|gt_srctbl
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	     * Neighbor was not the parent, send grafts to join the groups 	     */
if|if
condition|(
name|g
operator|->
name|gt_prsent_timer
condition|)
block|{
name|g
operator|->
name|gt_grftsnt
operator|=
literal|1
expr_stmt|;
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	     * Remove any prunes that this router has sent us. 	     */
name|ptnp
operator|=
operator|&
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|pt_vifi
operator|==
name|vifi
operator|&&
name|pt
operator|->
name|pt_router
operator|==
name|addr
condition|)
block|{
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
else|else
name|ptnp
operator|=
operator|&
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
comment|/* 	     * And see if we want to forward again. 	     */
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
condition|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|&&
operator|!
operator|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
operator|)
condition|)
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
operator|&&
name|grplst_mem
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_grpmems
operator|&=
operator|~
name|g
operator|->
name|gt_scope
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* Update kernel state */
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"reset member state (%s %s) gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Delete table entry from the kernel  * del_flag determines how many entries to delete  */
end_comment

begin_function
name|void
name|del_table_entry
parameter_list|(
name|r
parameter_list|,
name|mcastgrp
parameter_list|,
name|del_flag
parameter_list|)
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
name|u_int
name|del_flag
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|,
modifier|*
name|prev_g
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
name|prev_st
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
name|prev_pt
decl_stmt|;
if|if
condition|(
name|del_flag
operator|==
name|DEL_ALL_ROUTES
condition|)
block|{
name|g
operator|=
name|r
operator|->
name|rt_groups
expr_stmt|;
while|while
condition|(
name|g
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"del_table_entry deleting (%s %s)"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|g
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
name|st
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"del_table_entry trying to delete (%s, %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
name|prev_st
operator|=
name|st
expr_stmt|;
name|st
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|prev_st
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_srctbl
operator|=
name|NULL
expr_stmt|;
name|pt
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|prev_pt
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|prev_pt
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gnext
condition|)
name|g
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|g
operator|->
name|gt_gprev
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gprev
condition|)
name|g
operator|->
name|gt_gprev
operator|->
name|gt_gnext
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
else|else
name|kernel_table
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsrr_cache_clean
argument_list|(
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
name|prev_g
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
name|free
argument_list|(
name|prev_g
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|rt_groups
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*       * Dummy routine - someday this may be needed, so it is just there      */
if|if
condition|(
name|del_flag
operator|==
name|DEL_RTE_GROUP
condition|)
block|{
name|prev_g
operator|=
operator|(
expr|struct
name|gtable
operator|*
operator|)
operator|&
name|r
operator|->
name|rt_groups
expr_stmt|;
for|for
control|(
name|g
operator|=
name|r
operator|->
name|rt_groups
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_next
control|)
block|{
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"del_table_entry deleting (%s %s)"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|g
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
name|st
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"del_table_entry trying to delete (%s, %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
name|prev_st
operator|=
name|st
expr_stmt|;
name|st
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|prev_st
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_srctbl
operator|=
name|NULL
expr_stmt|;
name|pt
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|prev_pt
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|prev_pt
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gnext
condition|)
name|g
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|g
operator|->
name|gt_gprev
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gprev
condition|)
name|g
operator|->
name|gt_gprev
operator|->
name|gt_gnext
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
else|else
name|kernel_table
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
if|if
condition|(
name|prev_g
operator|!=
operator|(
expr|struct
name|gtable
operator|*
operator|)
operator|&
name|r
operator|->
name|rt_groups
condition|)
name|g
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|prev_g
expr_stmt|;
else|else
name|g
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|NULL
expr_stmt|;
name|prev_g
operator|->
name|gt_next
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsrr_cache_clean
argument_list|(
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|=
name|prev_g
expr_stmt|;
block|}
else|else
block|{
name|prev_g
operator|=
name|g
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * update kernel table entry when a route entry changes  */
end_comment

begin_function
name|void
name|update_table_entry
parameter_list|(
name|r
parameter_list|)
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
name|prev_pt
decl_stmt|;
name|vifi_t
name|i
decl_stmt|;
for|for
control|(
name|g
operator|=
name|r
operator|->
name|rt_groups
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_next
control|)
block|{
name|pt
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|prev_pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|prev_pt
expr_stmt|;
block|}
name|g
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|gt_grpmems
operator|=
literal|0
expr_stmt|;
comment|/* obtain the multicast group membership list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|&&
operator|!
operator|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
operator|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
operator|&&
name|grplst_mem
argument_list|(
name|i
argument_list|,
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
name|VIFM_SET
argument_list|(
name|i
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|r
operator|->
name|rt_parent
argument_list|,
name|g
operator|->
name|gt_scope
argument_list|)
condition|)
name|g
operator|->
name|gt_scope
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|gt_grpmems
operator|&=
operator|~
name|g
operator|->
name|gt_scope
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"updating cache entries (%s %s) gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_grpmems
operator|&&
name|g
operator|->
name|gt_prsent_timer
condition|)
block|{
name|g
operator|->
name|gt_grftsnt
operator|=
literal|1
expr_stmt|;
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update ttls and add entry into kernel */
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
comment|/* Check if we want to prune this group */
if|if
condition|(
operator|!
name|g
operator|->
name|gt_prsent_timer
operator|&&
name|g
operator|->
name|gt_grpmems
operator|==
literal|0
operator|&&
name|r
operator|->
name|rt_gateway
condition|)
block|{
name|g
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|send_prune
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * set the forwarding flag for all mcastgrps on this vifi  */
end_comment

begin_function
name|void
name|update_lclgrp
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"group %s joined on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_grpmems
operator|&=
operator|~
name|g
operator|->
name|gt_scope
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_grpmems
operator|==
literal|0
condition|)
continue|continue;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"update lclgrp (%s %s) gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * reset forwarding flag for all mcastgrps on this vifi  */
end_comment

begin_function
name|void
name|delete_lclgrp
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"group %s left on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
condition|)
block|{
name|int
name|stop_sending
init|=
literal|1
decl_stmt|;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
comment|/* 	     * If this is not a leaf, then we have router neighbors on this 	     * vif.  Only turn off forwarding if they have all pruned. 	     */
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
condition|)
block|{
name|struct
name|listaddr
modifier|*
name|vr
decl_stmt|;
for|for
control|(
name|vr
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
init|;
name|vr
condition|;
name|vr
operator|=
name|vr
operator|->
name|al_next
control|)
if|if
condition|(
name|find_prune_entry
argument_list|(
name|vr
operator|->
name|al_addr
argument_list|,
name|g
operator|->
name|gt_pruntbl
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|stop_sending
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stop_sending
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"delete lclgrp (%s %s) gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
comment|/* 		 * If there are no more members of this particular group, 		 *  send prune upstream 		 */
if|if
condition|(
operator|!
name|g
operator|->
name|gt_prsent_timer
operator|&&
name|g
operator|->
name|gt_grpmems
operator|==
literal|0
operator|&&
name|r
operator|->
name|rt_gateway
condition|)
name|send_prune
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Takes the prune message received and then strips it to  * determine the (src, grp) pair to be pruned.  *  * Adds the router to the (src, grp) entry then.  *  * Determines if further packets have to be sent down that vif  *  * Determines if a corresponding prune message has to be generated  */
end_comment

begin_function
name|void
name|accept_prune
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_int32
name|prun_src
decl_stmt|;
name|u_int32
name|prun_grp
decl_stmt|;
name|u_int32
name|prun_tmr
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|stop_sending
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|vr
decl_stmt|;
comment|/* Don't process any prunes if router is not pruning */
if|if
condition|(
name|pruning
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring prune report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if enough data is present */
if|if
condition|(
name|datalen
operator|<
literal|12
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"non-decipherable prune from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_grp
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_tmr
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|prun_tmr
operator|=
name|ntohl
argument_list|(
name|prun_tmr
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d prunes (%s %s)/%d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|prun_tmr
argument_list|)
expr_stmt|;
comment|/*      * Find the subnet for the prune      */
if|if
condition|(
name|find_src_grp
argument_list|(
name|prun_src
argument_list|,
literal|0
argument_list|,
name|prun_grp
argument_list|)
condition|)
block|{
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"prune received from non-child %s for (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_scope
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"prune received from %s on scoped grp (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pt
operator|=
name|find_prune_entry
argument_list|(
name|src
argument_list|,
name|g
operator|->
name|gt_pruntbl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s %d from %s for (%s %s)/%d %s %d %s %x"
argument_list|,
literal|"duplicate prune received on vif"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|prun_tmr
argument_list|,
literal|"old timer:"
argument_list|,
name|pt
operator|->
name|pt_timer
argument_list|,
literal|"cur gm:"
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_timer
operator|=
name|prun_tmr
expr_stmt|;
block|}
else|else
block|{
comment|/* allocate space for the prune structure */
name|pt
operator|=
operator|(
expr|struct
name|ptable
operator|*
operator|)
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptable
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"pt: ran out of memory"
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_vifi
operator|=
name|vifi
expr_stmt|;
name|pt
operator|->
name|pt_router
operator|=
name|src
expr_stmt|;
name|pt
operator|->
name|pt_timer
operator|=
name|prun_tmr
expr_stmt|;
name|pt
operator|->
name|pt_next
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
name|g
operator|->
name|gt_pruntbl
operator|=
name|pt
expr_stmt|;
block|}
comment|/* Refresh the group's lifetime */
name|g
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_timer
operator|<
name|prun_tmr
condition|)
name|g
operator|->
name|gt_timer
operator|=
name|prun_tmr
expr_stmt|;
comment|/* 	 * check if any more packets need to be sent on the  	 * vif which sent this message 	 */
name|stop_sending
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|vr
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
init|;
name|vr
condition|;
name|vr
operator|=
name|vr
operator|->
name|al_next
control|)
if|if
condition|(
name|find_prune_entry
argument_list|(
name|vr
operator|->
name|al_addr
argument_list|,
name|g
operator|->
name|gt_pruntbl
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|stop_sending
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_sending
operator|&&
operator|!
name|grplst_mem
argument_list|(
name|vifi
argument_list|,
name|prun_grp
argument_list|)
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"prune (%s %s), stop sending on vif %d, gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
comment|/* 	 * check if all the child routers have expressed no interest 	 * in this group and if this group does not exist in the  	 * interface 	 * Send a prune message then upstream 	 */
if|if
condition|(
operator|!
name|g
operator|->
name|gt_prsent_timer
operator|&&
name|g
operator|->
name|gt_grpmems
operator|==
literal|0
operator|&&
name|r
operator|->
name|rt_gateway
condition|)
block|{
name|send_prune
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * There is no kernel entry for this group.  Therefore, we can 	 * simply ignore the prune, as we are not forwarding this traffic 	 * downstream. 	 */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (%s %s)/%d from %s"
argument_list|,
literal|"prune message received with no kernel entry for"
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|prun_tmr
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if this mcastgrp is present in the kernel table  * If so and if a prune was sent, it sends a graft upwards  */
end_comment

begin_function
name|void
name|chkgrp_graft
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
if|if
condition|(
name|g
operator|->
name|gt_prsent_timer
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
comment|/* 		 * If the vif that was joined was a scoped vif, 		 * ignore it ; don't graft back 		 */
name|g
operator|->
name|gt_grpmems
operator|&=
operator|~
name|g
operator|->
name|gt_scope
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_grpmems
operator|==
literal|0
condition|)
continue|continue;
comment|/* set the flag for graft retransmission */
name|g
operator|->
name|gt_grftsnt
operator|=
literal|1
expr_stmt|;
comment|/* send graft upwards */
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* reset the prune timer and update cache timer*/
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|gt_timer
operator|=
name|max_prune_lifetime
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"chkgrp graft (%s %s) gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
block|}
end_function

begin_comment
comment|/* determine the multicast group and src  *   * if it does, then determine if a prune was sent   * upstream.  * if prune sent upstream, send graft upstream and send  * ack downstream.  *   * if no prune sent upstream, change the forwarding bit  * for this interface and send ack downstream.  *  * if no entry exists for this group send ack downstream.  */
end_comment

begin_function
name|void
name|accept_graft
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|graft_src
decl_stmt|;
name|u_int32
name|graft_grp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring graft from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|<
literal|8
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable graft from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|graft_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|graft_grp
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d grafts (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Find the subnet for the graft      */
if|if
condition|(
name|find_src_grp
argument_list|(
name|graft_src
argument_list|,
literal|0
argument_list|,
name|graft_grp
argument_list|)
condition|)
block|{
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_scope
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"graft received from %s on scoped grp (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptnp
operator|=
operator|&
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pt_vifi
operator|==
name|vifi
operator|)
operator|&&
operator|(
name|pt
operator|->
name|pt_router
operator|==
name|src
operator|)
condition|)
block|{
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"accept graft (%s %s) gm:%x"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
break|break;
block|}
else|else
block|{
name|ptnp
operator|=
operator|&
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
block|}
comment|/* send ack downstream */
name|send_graft_ack
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|graft_src
argument_list|,
name|graft_grp
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_timer
operator|=
name|max_prune_lifetime
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_prsent_timer
condition|)
block|{
comment|/* set the flag for graft retransmission */
name|g
operator|->
name|gt_grftsnt
operator|=
literal|1
expr_stmt|;
comment|/* send graft upwards */
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* reset the prune sent timer */
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * We have no state for the source and group in question. 	 * We can simply acknowledge the graft, since we know 	 * that we have no prune state, and grafts are requests 	 * to remove prune state. 	 */
name|send_graft_ack
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|graft_src
argument_list|,
name|graft_grp
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (%s %s) from %s"
argument_list|,
literal|"graft received with no kernel entry for"
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * find out which group is involved first of all   * then determine if a graft was sent.  * if no graft sent, ignore the message  * if graft was sent and the ack is from the right   * source, remove the graft timer so that we don't   * have send a graft again  */
end_comment

begin_function
name|void
name|accept_g_ack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|grft_src
decl_stmt|;
name|u_int32
name|grft_grp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring graft ack from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|<
literal|0
operator|||
name|datalen
operator|>
literal|8
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable graft ack from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|grft_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|grft_grp
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d acks graft (%s, %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|grft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grft_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Find the subnet for the graft ack      */
if|if
condition|(
name|find_src_grp
argument_list|(
name|grft_src
argument_list|,
literal|0
argument_list|,
name|grft_grp
argument_list|)
condition|)
block|{
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|g
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s (%s, %s) from %s"
argument_list|,
literal|"rcvd graft ack with no kernel entry for"
argument_list|,
name|inet_fmt
argument_list|(
name|grft_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grft_grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * free all prune entries and kernel routes  * normally, this should inform the kernel that all of its routes  * are going away, but this is only called by restart(), which is  * about to call MRT_DONE which does that anyway.  */
end_comment

begin_function
name|void
name|free_all_prunes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|gtable
modifier|*
name|g
decl_stmt|,
modifier|*
name|prev_g
decl_stmt|;
specifier|register
name|struct
name|stable
modifier|*
name|s
decl_stmt|,
modifier|*
name|prev_s
decl_stmt|;
specifier|register
name|struct
name|ptable
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev_p
decl_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|g
operator|=
name|r
operator|->
name|rt_groups
expr_stmt|;
while|while
condition|(
name|g
condition|)
block|{
name|s
operator|=
name|g
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|prev_s
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|prev_s
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|prev_p
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|prev_p
argument_list|)
expr_stmt|;
block|}
name|prev_g
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
name|free
argument_list|(
name|prev_g
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|rt_groups
operator|=
name|NULL
expr_stmt|;
block|}
name|kernel_table
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|kernel_no_route
expr_stmt|;
while|while
condition|(
name|g
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|gt_srctbl
condition|)
name|free
argument_list|(
name|g
operator|->
name|gt_srctbl
argument_list|)
expr_stmt|;
name|prev_g
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
name|free
argument_list|(
name|prev_g
argument_list|)
expr_stmt|;
block|}
name|kernel_no_route
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a new route is created, search  * a) The less-specific part of the routing table  * b) The route-less kernel table  * for sources that the new route might want to handle.  *  * "Inheriting" these sources might be cleanest, but simply deleting  * them is easier, and letting the kernel re-request them.  */
end_comment

begin_function
name|void
name|steal_sources
parameter_list|(
name|rt
parameter_list|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
modifier|*
name|gtnp
decl_stmt|;
specifier|register
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
modifier|*
name|stnp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|rt
operator|->
name|rt_next
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_origin
operator|&
name|rp
operator|->
name|rt_originmask
operator|)
operator|==
name|rp
operator|->
name|rt_origin
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Route for %s stealing sources from %s"
argument_list|,
name|inet_fmts
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|,
name|rt
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|rp
operator|->
name|rt_origin
argument_list|,
name|rp
operator|->
name|rt_originmask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|gt
operator|=
name|rp
operator|->
name|rt_groups
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
block|{
name|stnp
operator|=
operator|&
name|gt
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
operator|*
name|stnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|st
operator|->
name|st_origin
operator|&
name|rt
operator|->
name|rt_originmask
operator|)
operator|==
name|rt
operator|->
name|rt_origin
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s stealing (%s %s) from %s"
argument_list|,
name|inet_fmts
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|,
name|rt
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s4
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|rp
operator|->
name|rt_origin
argument_list|,
name|rp
operator|->
name|rt_originmask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s, %s)"
argument_list|,
literal|"steal_sources trying to delete"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|stnp
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stnp
operator|=
operator|&
name|st
operator|->
name|st_next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|gtnp
operator|=
operator|&
name|kernel_no_route
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
operator|&&
operator|(
operator|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
operator|&
name|rt
operator|->
name|rt_originmask
operator|)
operator|==
name|rt
operator|->
name|rt_origin
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s stealing (%s %s) from %s"
argument_list|,
name|inet_fmts
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|,
name|rt
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s4
argument_list|)
argument_list|,
literal|"no_route table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_del_rg
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s %s)"
argument_list|,
literal|"steal_sources trying to delete"
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
name|free
argument_list|(
name|gt
operator|->
name|gt_srctbl
argument_list|)
expr_stmt|;
operator|*
name|gtnp
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
operator|->
name|gt_prev
expr_stmt|;
name|free
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gtnp
operator|=
operator|&
name|gt
operator|->
name|gt_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Advance the timers on all the cache entries.  * If there are any entries whose timers have expired,  * remove these entries from the kernel cache.  */
end_comment

begin_function
name|void
name|age_table_entry
parameter_list|()
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
modifier|*
name|gtnptr
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
modifier|*
name|stnp
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ageing entries"
argument_list|)
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|kernel_table
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnptr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|gt
operator|->
name|gt_route
expr_stmt|;
comment|/* advance the timer for the kernel entry */
name|gt
operator|->
name|gt_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
expr_stmt|;
comment|/* decrement prune timer if need be */
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
condition|)
block|{
name|gt
operator|->
name|gt_prsent_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|<=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"upstream prune tmo (%s %s)"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* retransmit graft if graft sent flag is still set */
if|if
condition|(
name|gt
operator|->
name|gt_grftsnt
condition|)
block|{
specifier|register
name|int
name|y
decl_stmt|;
name|CHK_GS
argument_list|(
name|gt
operator|->
name|gt_grftsnt
operator|++
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
name|send_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Age prunes 	 * 	 * If a prune expires, forward again on that vif. 	 */
name|ptnp
operator|=
operator|&
name|gt
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pt_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
operator|)
operator|<=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"expire prune (%s %s) from %s on vif %d"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s3
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|)
expr_stmt|;
name|expire_prune
argument_list|(
name|pt
operator|->
name|pt_vifi
argument_list|,
name|gt
argument_list|)
expr_stmt|;
comment|/* remove the router's prune entry and await new one */
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptnp
operator|=
operator|&
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
block|}
comment|/* 	 * If the cache entry has expired, delete source table entries for 	 * silent sources.  If there are no source entries left, and there 	 * are no downstream prunes, then the entry is deleted. 	 * Otherwise, the cache entry's timer is refreshed. 	 */
if|if
condition|(
name|gt
operator|->
name|gt_timer
operator|<=
literal|0
condition|)
block|{
comment|/* Check for traffic before deleting source entries */
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|gt
operator|->
name|gt_mcastgrp
expr_stmt|;
name|stnp
operator|=
operator|&
name|gt
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
operator|*
name|stnp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|st
operator|->
name|st_origin
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s %s)"
argument_list|,
literal|"age_table_entry: SIOCGETSGCNT failing for"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure it gets deleted below */
name|sg_req
operator|.
name|pktcnt
operator|=
name|st
operator|->
name|st_pktcnt
expr_stmt|;
block|}
if|if
condition|(
name|sg_req
operator|.
name|pktcnt
operator|==
name|st
operator|->
name|st_pktcnt
condition|)
block|{
operator|*
name|stnp
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"age_table_entry deleting (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"age_table_entry trying to delete (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|st_pktcnt
operator|=
name|sg_req
operator|.
name|pktcnt
expr_stmt|;
name|stnp
operator|=
operator|&
name|st
operator|->
name|st_next
expr_stmt|;
block|}
block|}
comment|/* 	     * Retain the group entry if we have downstream prunes or if 	     * there is at least one source in the list that still has 	     * traffic, or if our upstream prune timer is running. 	     */
if|if
condition|(
name|gt
operator|->
name|gt_pruntbl
operator|!=
name|NULL
operator|||
name|gt
operator|->
name|gt_srctbl
operator|!=
name|NULL
operator|||
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
condition|)
block|{
name|gt
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|gt
operator|->
name|gt_grpmems
operator|==
literal|0
condition|)
name|send_prune
argument_list|(
name|gt
argument_list|)
expr_stmt|;
else|else
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_gnext
expr_stmt|;
continue|continue;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"timeout cache entry (%s, %s)"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prev
condition|)
name|gt
operator|->
name|gt_prev
operator|->
name|gt_next
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
else|else
name|gt
operator|->
name|gt_route
operator|->
name|rt_groups
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
operator|->
name|gt_prev
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_gprev
condition|)
block|{
name|gt
operator|->
name|gt_gprev
operator|->
name|gt_gnext
operator|=
name|gt
operator|->
name|gt_gnext
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_gprev
operator|->
name|gt_gnext
expr_stmt|;
block|}
else|else
block|{
name|kernel_table
operator|=
name|gt
operator|->
name|gt_gnext
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|kernel_table
expr_stmt|;
block|}
if|if
condition|(
name|gt
operator|->
name|gt_gnext
condition|)
name|gt
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|gt
operator|->
name|gt_gprev
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|gt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsrr_cache_clean
argument_list|(
name|gt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|gt
operator|->
name|gt_grpmems
operator|==
literal|0
condition|)
name|send_prune
argument_list|(
name|gt
argument_list|)
expr_stmt|;
else|else
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_gnext
expr_stmt|;
block|}
block|}
comment|/*      * When traversing the no_route table, the decision is much easier.      * Just delete it if it has timed out.      */
name|gtnptr
operator|=
operator|&
name|kernel_no_route
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnptr
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* advance the timer for the kernel entry */
name|gt
operator|->
name|gt_timer
operator|-=
name|ROUTE_MAX_REPORT_DELAY
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_timer
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s %s)"
argument_list|,
literal|"age_table_entry trying to delete no-route"
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|gt
operator|->
name|gt_srctbl
argument_list|)
expr_stmt|;
block|}
operator|*
name|gtnptr
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
operator|->
name|gt_prev
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Modify the kernel to forward packets when one or multiple prunes that  * were received on the vif given by vifi, for the group given by gt,  * have expired.  */
end_comment

begin_function
specifier|static
name|void
name|expire_prune
parameter_list|(
name|vifi
parameter_list|,
name|gt
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
comment|/*      * No need to send a graft, any prunes that we sent      * will expire before any prunes that we have received.      */
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"prune expired with %d left on %s"
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
literal|"prsent_timer"
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* modify the kernel entry to forward packets */
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|gt
operator|->
name|gt_route
decl_stmt|;
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"forw again (%s %s) gm:%x vif:%d"
argument_list|,
name|inet_fmts
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|,
name|rt
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|gt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|gt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|scaletime
parameter_list|(
name|t
parameter_list|)
name|u_long
name|t
decl_stmt|;
block|{
specifier|static
name|char
name|buf1
index|[
literal|5
index|]
decl_stmt|;
specifier|static
name|char
name|buf2
index|[
literal|5
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
name|buf1
decl_stmt|;
name|char
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|buf1
condition|)
name|buf
operator|=
name|buf2
expr_stmt|;
else|else
name|buf
operator|=
name|buf1
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|120
condition|)
block|{
name|s
operator|=
literal|'s'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
literal|3600
condition|)
block|{
name|t
operator|/=
literal|60
expr_stmt|;
name|s
operator|=
literal|'m'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
literal|86400
condition|)
block|{
name|t
operator|/=
literal|3600
expr_stmt|;
name|s
operator|=
literal|'h'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|<
literal|864000
condition|)
block|{
name|t
operator|/=
literal|86400
expr_stmt|;
name|s
operator|=
literal|'d'
expr_stmt|;
block|}
else|else
block|{
name|t
operator|/=
literal|604800
expr_stmt|;
name|s
operator|=
literal|'w'
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|>
literal|999
condition|)
return|return
literal|"*** "
return|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%3d%c"
argument_list|,
operator|(
name|int
operator|)
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Print the contents of the cache table on file 'fp2'.  */
end_comment

begin_function
name|void
name|dump_cache
parameter_list|(
name|fp2
parameter_list|)
name|FILE
modifier|*
name|fp2
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
specifier|register
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
specifier|register
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
specifier|register
name|vifi_t
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|time_t
name|thyme
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"Multicast Routing Cache Table (%d entries)\n%s"
argument_list|,
name|kroutes
argument_list|,
literal|" Origin             Mcast-group     CTmr  Age Ptmr IVif Forwvifs\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|gt
operator|=
name|kernel_no_route
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
condition|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-18s %-15s %-4s %-4s    - -1\n"
argument_list|,
name|inet_fmts
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
literal|0xffffffff
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|gt
operator|->
name|gt_timer
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|thyme
operator|-
name|gt
operator|->
name|gt_ctime
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|">%s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|gt
operator|=
name|kernel_table
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
control|)
block|{
name|r
operator|=
name|gt
operator|->
name|gt_route
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-18s %-15s"
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-4s"
argument_list|,
name|scaletime
argument_list|(
name|gt
operator|->
name|gt_timer
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-4s %-4s "
argument_list|,
name|scaletime
argument_list|(
name|thyme
operator|-
name|gt
operator|->
name|gt_ctime
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
condition|?
name|scaletime
argument_list|(
name|gt
operator|->
name|gt_prsent_timer
argument_list|)
else|:
literal|"   -"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"%2u%c%c "
argument_list|,
name|r
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
condition|?
literal|'P'
else|:
literal|' '
argument_list|,
name|VIFM_ISSET
argument_list|(
name|r
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|?
literal|'B'
else|:
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u "
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u%c"
argument_list|,
name|i
argument_list|,
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|?
literal|'b'
else|:
literal|'p'
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_pruntbl
condition|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|gt
operator|->
name|gt_pruntbl
init|;
name|pt
condition|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
control|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"%c%s:%d/%d"
argument_list|,
name|c
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s1
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|,
name|pt
operator|->
name|pt_timer
argument_list|)
expr_stmt|;
name|c
operator|=
literal|','
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|">%s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Traceroute function which returns traceroute replies to the requesting  * router. Also forwards the request to downstream routers.  */
end_comment

begin_function
name|void
name|accept_mtrace
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|data
parameter_list|,
name|no
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|u_int32
name|group
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|no
decl_stmt|;
comment|/* promoted u_char */
name|int
name|datalen
decl_stmt|;
block|{
name|u_char
name|type
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|struct
name|tr_query
modifier|*
name|qry
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|resp
decl_stmt|;
name|int
name|vifi
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|rcount
decl_stmt|;
name|int
name|errcode
init|=
name|TR_NO_ERR
decl_stmt|;
name|int
name|resptype
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|sioc_vif_req
name|v_req
decl_stmt|;
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
comment|/* Remember qid across invocations */
specifier|static
name|u_int32
name|oqid
init|=
literal|0
decl_stmt|;
comment|/* timestamp the request/response */
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Check if it is a query or a response      */
if|if
condition|(
name|datalen
operator|==
name|QLEN
condition|)
block|{
name|type
operator|=
name|QUERY
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Initial traceroute query rcvd from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|RESP
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"In-transit traceroute query rcvd from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Dropping multicast response"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s from %s to %s"
argument_list|,
literal|"Non decipherable traceroute request recieved"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|qry
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
name|data
expr_stmt|;
comment|/*      * if it is a packet with all reports filled, drop it      */
if|if
condition|(
operator|(
name|rcount
operator|=
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
operator|)
operator|==
name|no
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"packet with all reports filled in"
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"s: %s g: %s d: %s "
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|group
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rttl: %d rd: %s"
argument_list|,
name|qry
operator|->
name|tr_rttl
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_raddr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rcount:%d, qid:%06x"
argument_list|,
name|rcount
argument_list|,
name|qry
operator|->
name|tr_qid
argument_list|)
expr_stmt|;
comment|/* determine the routing table entry for this traceroute */
name|rt
operator|=
name|determine_route
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rt parent vif: %d rtr: %s metric: %d"
argument_list|,
name|rt
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|s1
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rt origin %s"
argument_list|,
name|inet_fmts
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|,
name|rt
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"...no route"
argument_list|)
expr_stmt|;
comment|/*      * Query type packet - check if rte exists       * Check if the query destination is a vif connected to me.      * and if so, whether I should start response back      */
if|if
condition|(
name|type
operator|==
name|QUERY
condition|)
block|{
if|if
condition|(
name|oqid
operator|==
name|qry
operator|->
name|tr_qid
condition|)
block|{
comment|/* 	     * If the multicast router is a member of the group being 	     * queried, and the query is multicasted, then the router can 	     * recieve multiple copies of the same query.  If we have already 	     * replied to this traceroute, just ignore it this time. 	     * 	     * This is not a total solution, but since if this fails you 	     * only get N copies, N<= the number of interfaces on the router, 	     * it is not fatal. 	     */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring duplicate traceroute packet"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Mcast traceroute: no route entry %s"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
block|}
name|vifi
operator|=
name|find_vif
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifi
operator|==
name|NO_VIF
condition|)
block|{
comment|/* The traceroute destination is not on one of my subnet vifs. */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not an interface"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|!=
name|NULL
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not on forwarding tree for src %s"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * determine which interface the packet came in on 	 * RESP packets travel hop-by-hop so this either traversed 	 * a tunnel or came from a directly attached mrouter. 	 */
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Wrong interface for packet"
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
comment|/* Now that we've decided to send a response, save the qid */
name|oqid
operator|=
name|qry
operator|->
name|tr_qid
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending traceroute response"
argument_list|)
expr_stmt|;
comment|/* copy the packet to the sending buffer */
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|datalen
expr_stmt|;
comment|/*      * If there is no room to insert our reply, coopt the previous hop      * error indication to relay this fact.      */
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tr_resp
argument_list|)
operator|>
name|send_buf
operator|+
name|RECV_BUF_SIZE
condition|)
block|{
name|resp
operator|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
name|p
operator|-
literal|1
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_SPACE
expr_stmt|;
name|rt
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sendit
goto|;
block|}
comment|/*      * fill in initial response fields      */
name|resp
operator|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
name|p
expr_stmt|;
name|bzero
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tr_resp
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
name|RLEN
expr_stmt|;
name|resp
operator|->
name|tr_qarr
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|tp
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|tp
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
operator|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rproto
operator|=
name|PROTO_DVMRP
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
name|TR_NO_ERR
condition|)
block|{
name|resp
operator|->
name|tr_rflags
operator|=
name|errcode
expr_stmt|;
name|rt
operator|=
name|NULL
expr_stmt|;
comment|/* hack to enforce send straight to requestor */
goto|goto
name|sendit
goto|;
block|}
name|resp
operator|->
name|tr_outaddr
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|resp
operator|->
name|tr_fttl
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_threshold
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_ERR
expr_stmt|;
comment|/*      * obtain # of packets out on interface      */
name|v_req
operator|.
name|vifi
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifout
operator|=
name|htonl
argument_list|(
name|v_req
operator|.
name|ocount
argument_list|)
expr_stmt|;
comment|/*      * fill in scoping& pruning information      */
if|if
condition|(
name|rt
condition|)
for|for
control|(
name|gt
operator|=
name|rt
operator|->
name|rt_groups
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_mcastgrp
operator|>=
name|group
condition|)
break|break;
block|}
else|else
name|gt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gt
operator|&&
name|gt
operator|->
name|gt_mcastgrp
operator|==
name|group
condition|)
block|{
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|qry
operator|->
name|tr_src
expr_stmt|;
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_pktcnt
operator|=
name|htonl
argument_list|(
name|sg_req
operator|.
name|pktcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_SCOPED
expr_stmt|;
elseif|else
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_PRUNED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_leaves
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_OPRUNED
expr_stmt|;
else|else
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_FWD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scoped_addr
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_SCOPED
expr_stmt|;
elseif|else
if|if
condition|(
name|rt
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_FWD
expr_stmt|;
block|}
comment|/*      *  if no rte exists, set NO_RTE error      */
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|src
operator|=
name|dst
expr_stmt|;
comment|/* the dst address of resp. pkt */
name|resp
operator|->
name|tr_inaddr
operator|=
literal|0
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_RTE
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* get # of packets in on interface */
name|v_req
operator|.
name|vifi
operator|=
name|rt
operator|->
name|rt_parent
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifin
operator|=
name|htonl
argument_list|(
name|v_req
operator|.
name|icount
argument_list|)
expr_stmt|;
name|MASK_TO_VAL
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|,
name|resp
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
name|src
operator|=
name|uvifs
index|[
name|rt
operator|->
name|rt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|resp
operator|->
name|tr_inaddr
operator|=
name|src
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not on forwarding tree for src %s"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_metric
operator|>=
name|UNREACHABLE
condition|)
block|{
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_RTE
expr_stmt|;
comment|/* Hack to send reply directly */
name|rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sendit
label|:
comment|/*      * if metric is 1 or no. of reports is 1, send response to requestor      * else send to upstream router.  If the upstream router can't handle      * mtrace, set an error code and send to requestor anyway.      */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rcount:%d, no:%d"
argument_list|,
name|rcount
argument_list|,
name|no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcount
operator|+
literal|1
operator|==
name|no
operator|)
operator|||
operator|(
name|rt
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rt
operator|->
name|rt_metric
operator|==
literal|1
operator|)
condition|)
block|{
name|resptype
operator|=
name|IGMP_MTRACE_RESP
expr_stmt|;
name|dst
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|can_mtrace
argument_list|(
name|rt
operator|->
name|rt_parent
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|)
condition|)
block|{
name|dst
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_OLD_ROUTER
expr_stmt|;
name|resptype
operator|=
name|IGMP_MTRACE_RESP
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|resptype
operator|=
name|IGMP_MTRACE
expr_stmt|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 	 * Send the reply on a known multicast capable vif. 	 * If we don't have one, we can't source any multicasts anyway. 	 */
if|if
condition|(
name|phys_vif
operator|!=
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending reply to %s from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|uvifs
index|[
name|phys_vif
index|]
operator|.
name|uv_lcl_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|k_set_ttl
argument_list|(
name|qry
operator|->
name|tr_rttl
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|uvifs
index|[
name|phys_vif
index|]
operator|.
name|uv_lcl_addr
argument_list|,
name|dst
argument_list|,
name|resptype
argument_list|,
name|no
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|k_set_ttl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"No enabled phyints -- %s"
argument_list|,
literal|"dropping traceroute reply"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending %s to %s from %s"
argument_list|,
name|resptype
operator|==
name|IGMP_MTRACE_RESP
condition|?
literal|"reply"
else|:
literal|"request on"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|resptype
argument_list|,
name|no
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

