begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * prune.c,v 3.8.4.59 1998/03/01 02:06:32 fenner Exp  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Id: \ prune.c,v 3.8.4.59 1998/03/01 02:06:32 fenner Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|cache_lifetime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|prune_lifetime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|rtentry
modifier|*
name|routing_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|phys_vif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|allow_black_holes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * randomize value to obtain a value between .5x and 1.5x  * in order to prevent synchronization  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|JITTERED_VALUE
parameter_list|(
name|x
parameter_list|)
value|((x)/2 + (lrand48() % (x)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|JITTERED_VALUE
parameter_list|(
name|x
parameter_list|)
value|((x)/2 + (random() % (x)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CACHE_LIFETIME
parameter_list|(
name|x
parameter_list|)
value|JITTERED_VALUE(x)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|struct
name|gtable
modifier|*
name|kernel_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to list of kernel grp entries*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gtable
modifier|*
name|kernel_no_route
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of grp entries w/o routes   */
end_comment

begin_decl_stmt
name|struct
name|gtable
modifier|*
name|gtp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer for kernel rt entries    */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|kroutes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current number of cache entries  */
end_comment

begin_comment
comment|/****************************************************************************                        Functions that are local to prune.c ****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|scoped_addr
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prun_add_ttls
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pruning_neighbor
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_mtrace
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ptable
modifier|*
name|find_prune_entry
name|__P
argument_list|(
operator|(
name|u_int32
name|vr
operator|,
expr|struct
name|ptable
operator|*
name|pt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_sources
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rexmit_prune
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expire_prune
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|,
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_prune
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_graft
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|gt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_graft_ack
name|__P
argument_list|(
operator|(
name|u_int32
name|src
operator|,
name|u_int32
name|dst
operator|,
name|u_int32
name|origin
operator|,
name|u_int32
name|grp
operator|,
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_kernel
name|__P
argument_list|(
operator|(
expr|struct
name|gtable
operator|*
name|g
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Updates the ttl values for each vif.  */
end_comment

begin_function
specifier|static
name|void
name|prun_add_ttls
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
name|gt
operator|->
name|gt_ttls
index|[
name|vifi
index|]
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
else|else
name|gt
operator|->
name|gt_ttls
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * checks for scoped multicast addresses  * XXX I want to make the check of allow_black_holes based on ALLOW_BLACK_HOLES  * but macros are not functions.  */
end_comment

begin_define
define|#
directive|define
name|GET_SCOPE
parameter_list|(
name|gt
parameter_list|)
value|{ \ 	register vifi_t _i; \ 	VIFM_CLRALL((gt)->gt_scope); \ 	if (allow_black_holes || \ 	    (ntohl((gt)->gt_mcastgrp)& 0xff000000) == 0xef000000) \ 	    for (_i = 0; _i< numvifs; _i++) \ 		if (scoped_addr(_i, (gt)->gt_mcastgrp)) \ 		    VIFM_SET(_i, (gt)->gt_scope); \ 	} \ 	if ((gt)->gt_route == NULL || ((gt)->gt_route->rt_parent != NO_VIF&& \ 	    VIFM_ISSET((gt)->gt_route->rt_parent, (gt)->gt_scope))) \ 		VIFM_SETALL((gt)->gt_scope);
end_define

begin_define
define|#
directive|define
name|APPLY_SCOPE
parameter_list|(
name|gt
parameter_list|)
value|VIFM_CLR_MASK((gt)->gt_grpmems, (gt)->gt_scope)
end_define

begin_define
define|#
directive|define
name|GET_MEMBERSHIP
parameter_list|(
name|gt
parameter_list|,
name|vifi
parameter_list|)
value|{ \ 	if ((gt)->gt_route&& \ 	    VIFM_ISSET((vifi), (gt)->gt_route->rt_children)&& \ 	    (!SUBS_ARE_PRUNED((gt)->gt_route->rt_subordinates, \ 				uvifs[vifi].uv_nbrmap, (gt)->gt_prunes) || \ 	     grplst_mem((vifi), (gt)->gt_mcastgrp))) \ 		VIFM_SET((vifi), (gt)->gt_grpmems); \ 	}
end_define

begin_function
specifier|static
name|int
name|scoped_addr
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
for|for
control|(
name|acl
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_acl
init|;
name|acl
condition|;
name|acl
operator|=
name|acl
operator|->
name|acl_next
control|)
if|if
condition|(
operator|(
name|addr
operator|&
name|acl
operator|->
name|acl_mask
operator|)
operator|==
name|acl
operator|->
name|acl_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the list of outgoing vifs, based upon  * route subordinates, prunes received, and group  * memberships.  */
end_comment

begin_function
name|void
name|determine_forwvifs
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
name|vifi_t
name|i
decl_stmt|;
name|VIFM_CLRALL
argument_list|(
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
name|GET_MEMBERSHIP
argument_list|(
name|gt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|GET_SCOPE
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|APPLY_SCOPE
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a prune or a graft if necessary.  */
end_comment

begin_function
name|void
name|send_prune_or_graft
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
name|send_prune
argument_list|(
name|gt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
condition|)
name|send_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Determine if mcastgrp has a listener on vifi  */
end_comment

begin_function
name|int
name|grplst_mem
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
if|if
condition|(
name|mcastgrp
operator|==
name|g
operator|->
name|al_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Finds the group entry with the specified source and netmask.  * If netmask is 0, it uses the route's netmask.  *  * Returns TRUE if found a match, and the global variable gtp is left  * pointing to entry before the found entry.  * Returns FALSE if no exact match found, gtp is left pointing to before  * the entry in question belongs, or is NULL if the it belongs at the  * head of the list.  */
end_comment

begin_function
name|int
name|find_src_grp
parameter_list|(
name|src
parameter_list|,
name|mask
parameter_list|,
name|grp
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|u_int32
name|grp
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|gtp
operator|=
name|NULL
expr_stmt|;
name|gt
operator|=
name|kernel_table
expr_stmt|;
while|while
condition|(
name|gt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|grp
operator|==
name|gt
operator|->
name|gt_mcastgrp
operator|&&
operator|(
name|mask
condition|?
operator|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|==
name|src
operator|&&
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
operator|==
name|mask
operator|)
else|:
operator|(
operator|(
name|src
operator|&
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
operator|)
operator|==
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|>
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|||
operator|(
name|grp
operator|==
name|gt
operator|->
name|gt_mcastgrp
operator|&&
operator|(
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|<
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
argument_list|)
operator|||
operator|(
name|mask
operator|==
name|gt
operator|->
name|gt_route
operator|->
name|rt_originmask
operator|&&
operator|(
name|ntohl
argument_list|(
name|src
argument_list|)
operator|>
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|gtp
operator|=
name|gt
expr_stmt|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the neighbor supports pruning  */
end_comment

begin_function
specifier|static
name|int
name|pruning_neighbor
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|n
init|=
name|neighbor_info
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|int
name|vers
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|vers
operator|=
name|NBR_VERS
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|vers
operator|>=
literal|0x0300
operator|&&
operator|(
operator|(
name|vers
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x0a00
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can the neighbor in question handle multicast traceroute?  */
end_comment

begin_function
specifier|static
name|int
name|can_mtrace
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|n
init|=
name|neighbor_info
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|int
name|vers
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* fail "safe" */
name|vers
operator|=
name|NBR_VERS
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|vers
operator|>=
literal|0x0303
operator|&&
operator|(
operator|(
name|vers
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x0a00
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the prune entry of the router, or NULL if none exists  */
end_comment

begin_function
specifier|static
name|struct
name|ptable
modifier|*
name|find_prune_entry
parameter_list|(
name|vr
parameter_list|,
name|pt
parameter_list|)
name|u_int32
name|vr
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
block|{
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|pt_router
operator|==
name|vr
condition|)
return|return
name|pt
return|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all the sources hanging off the group table entry from the kernel  * cache.  Remember the packet counts wherever possible, to keep the mtrace  * counters consistent.  This prepares for possible prune retransmission,  * either on a multi-access network or when a prune that we sent upstream  * has expired.  */
end_comment

begin_function
specifier|static
name|void
name|remove_sources
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|gt
operator|->
name|gt_mcastgrp
expr_stmt|;
comment|/*      * call k_del_rg() on every one of the gt->gt_srctbl entries      * but first save the packet count so that the mtrace packet      * counters can remain approximately correct.  There's a race      * here but it's minor.      */
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
block|{
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|==
literal|0
condition|)
continue|continue;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rexmit_prune deleting (%s %s) (next is %d sec)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prune_rexmit
argument_list|)
expr_stmt|;
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|st
operator|->
name|st_origin
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sg_req
operator|.
name|pktcnt
operator|=
literal|0
expr_stmt|;
block|}
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
literal|0
expr_stmt|;
comment|/* flag that it's not in the kernel any more */
name|st
operator|->
name|st_savpkt
operator|+=
name|sg_req
operator|.
name|pktcnt
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
block|}
comment|/*      * Now, add_table_entry will prune when asked to add a cache entry.      */
block|}
end_function

begin_comment
comment|/*  * Prepare for possible prune retransmission  */
end_comment

begin_function
specifier|static
name|void
name|rexmit_prune
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
init|=
operator|*
operator|(
expr|struct
name|gtable
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_rexmit_timer
operator|=
literal|0
expr_stmt|;
comment|/* Make sure we're still not forwarding traffic */
if|if
condition|(
operator|!
name|VIFM_ISEMPTY
argument_list|(
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rexmit_prune (%s %s): gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
return|return;
block|}
name|remove_sources
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a prune message to the dominant router for  * this source.  *  * Record an entry that a prune was sent for this group  */
end_comment

begin_function
specifier|static
name|void
name|send_prune
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|u_int32
name|tmp
decl_stmt|;
name|int
name|rexmitting
init|=
literal|0
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
comment|/*      * Can't process a prune if we don't have an associated route      * or if the route points to a local interface.      */
if|if
condition|(
name|gt
operator|->
name|gt_route
operator|==
name|NULL
operator|||
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
operator|==
name|NO_VIF
operator|||
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
operator|==
literal|0
condition|)
return|return;
comment|/* Don't send a prune to a non-pruning router */
if|if
condition|(
operator|!
name|pruning_neighbor
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|)
condition|)
return|return;
name|v
operator|=
operator|&
name|uvifs
index|[
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
index|]
expr_stmt|;
comment|/*       * sends a prune message to the router upstream.      */
if|#
directive|if
literal|0
block|dst = v->uv_flags& VIFF_TUNNEL ? dvmrp_group : gt->gt_route->rt_gateway;
comment|/*XXX*/
else|#
directive|else
name|dst
operator|=
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
comment|/*      * determine prune lifetime, if this isn't a retransmission.      *      * Use interface-specified lifetime if there is one.      */
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|==
literal|0
condition|)
block|{
name|int
name|l
init|=
name|prune_lifetime
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_prune_lifetime
operator|!=
literal|0
condition|)
name|l
operator|=
name|v
operator|->
name|uv_prune_lifetime
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
name|JITTERED_VALUE
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|gt
operator|->
name|gt_pruntbl
init|;
name|pt
condition|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
control|)
if|if
condition|(
name|pt
operator|->
name|pt_timer
operator|<
name|gt
operator|->
name|gt_prsent_timer
condition|)
name|gt
operator|->
name|gt_prsent_timer
operator|=
name|pt
operator|->
name|pt_timer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|<
literal|0
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"asked to rexmit? (%s,%s)/%d on vif %d to %s with negative time"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|rexmitting
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rexmitting
operator|&&
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_REXMIT_PRUNES
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"not rexmitting prune for (%s %s)/%d on vif %d to %s"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|<=
name|MIN_PRUNE_LIFE
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"not bothering to send prune for (%s,%s)/%d on vif %d to %s because it's too short"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * If we have a graft pending, cancel graft retransmission      */
name|gt
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|htonl
argument_list|(
name|gt
operator|->
name|gt_prsent_timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|tmp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|12
expr_stmt|;
name|send_on_vif
argument_list|(
name|v
argument_list|,
name|dst
argument_list|,
name|DVMRP_PRUNE
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s prune for (%s %s)/%d on vif %d to %s"
argument_list|,
name|rexmitting
condition|?
literal|"rexmitted"
else|:
literal|"sent"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_REXMIT_PRUNES
operator|)
operator|&&
name|gt
operator|->
name|gt_rexmit_timer
operator|==
literal|0
operator|&&
name|gt
operator|->
name|gt_prsent_timer
operator|>
name|gt
operator|->
name|gt_prune_rexmit
condition|)
block|{
name|struct
name|gtable
modifier|*
modifier|*
name|arg
init|=
operator|(
expr|struct
name|gtable
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gtable
operator|*
operator|*
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|arg
operator|=
name|gt
expr_stmt|;
name|gt
operator|->
name|gt_rexmit_timer
operator|=
name|timer_setTimer
argument_list|(
name|JITTERED_VALUE
argument_list|(
name|gt
operator|->
name|gt_prune_rexmit
argument_list|)
argument_list|,
name|rexmit_prune
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prune_rexmit
operator|*=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * a prune was sent upstream  * so, a graft has to be sent to annul the prune  * set up a graft timer so that if an ack is not   * heard within that time, another graft request  * is sent out.  */
end_comment

begin_function
specifier|static
name|void
name|send_graft
parameter_list|(
name|gt
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
comment|/* Can't send a graft without an associated route */
if|if
condition|(
name|gt
operator|->
name|gt_route
operator|==
name|NULL
operator|||
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
operator|==
name|NO_VIF
condition|)
block|{
name|gt
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_prune_rexmit
operator|=
name|PRUNE_REXMIT_VAL
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|gt
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_grftsnt
operator|==
literal|0
condition|)
name|gt
operator|->
name|gt_grftsnt
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|dst = uvifs[gt->gt_route->rt_parent].uv_flags& VIFF_TUNNEL ? dvmrp_group : gt->gt_route->rt_gateway;
comment|/*XXX*/
else|#
directive|else
name|dst
operator|=
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|gt
operator|->
name|gt_mcastgrp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|8
expr_stmt|;
name|send_on_vif
argument_list|(
operator|&
name|uvifs
index|[
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
index|]
argument_list|,
name|dst
argument_list|,
name|DVMRP_GRAFT
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sent graft for (%s %s) to %s on vif %d"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_route
operator|->
name|rt_gateway
argument_list|,
name|s3
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_route
operator|->
name|rt_parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send an ack that a graft was received  */
end_comment

begin_function
specifier|static
name|void
name|send_graft_ack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|origin
parameter_list|,
name|grp
parameter_list|,
name|vifi
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|u_int32
name|origin
decl_stmt|;
name|u_int32
name|grp
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|grp
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|vifi
operator|==
name|NO_VIF
condition|)
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_GRAFT_ACK
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
block|if (uvifs[vifi].uv_flags& VIFF_TUNNEL) 	    dst = dvmrp_group;
comment|/* XXX */
endif|#
directive|endif
name|send_on_vif
argument_list|(
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|,
name|dst
argument_list|,
name|DVMRP_GRAFT_ACK
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
if|if
condition|(
name|vifi
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sent graft ack for (%s, %s) to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sent graft ack for (%s, %s) to %s on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s3
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the kernel cache with all the routes hanging off the group entry  */
end_comment

begin_function
specifier|static
name|void
name|update_kernel
parameter_list|(
name|g
parameter_list|)
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
for|for
control|(
name|st
operator|=
name|g
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
name|k_add_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************                           Functions that are used externally ****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SNMP
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"snmp.h"
end_include

begin_comment
comment|/*  * Find a specific group entry in the group table  */
end_comment

begin_function
name|struct
name|gtable
modifier|*
name|find_grp
parameter_list|(
name|grp
parameter_list|)
name|u_int32
name|grp
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
for|for
control|(
name|gt
operator|=
name|kernel_table
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|gt
operator|->
name|gt_mcastgrp
operator|==
name|grp
condition|)
return|return
name|gt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Given a group entry and source, find the corresponding source table  * entry  */
end_comment

begin_function
name|struct
name|stable
modifier|*
name|find_grp_src
parameter_list|(
name|gt
parameter_list|,
name|src
parameter_list|)
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
name|u_long
name|grp
init|=
name|gt
operator|->
name|gt_mcastgrp
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gtcurr
decl_stmt|;
for|for
control|(
name|gtcurr
operator|=
name|gt
init|;
name|gtcurr
operator|->
name|gt_mcastgrp
operator|==
name|grp
condition|;
name|gtcurr
operator|=
name|gtcurr
operator|->
name|gt_gnext
control|)
block|{
for|for
control|(
name|st
operator|=
name|gtcurr
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
if|if
condition|(
name|st
operator|->
name|st_origin
operator|==
name|src
condition|)
return|return
name|st
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*   * Find next entry> specification   */
end_comment

begin_function
name|int
name|next_grp_src_mask
parameter_list|(
name|gtpp
parameter_list|,
name|stpp
parameter_list|,
name|grp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|)
name|struct
name|gtable
modifier|*
modifier|*
name|gtpp
decl_stmt|;
comment|/* ordered by group  */
name|struct
name|stable
modifier|*
modifier|*
name|stpp
decl_stmt|;
comment|/* ordered by source */
name|u_int32
name|grp
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
name|gbest
init|=
name|NULL
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
name|sbest
init|=
name|NULL
decl_stmt|;
comment|/* Find first group entry>= grp spec */
operator|(
operator|*
name|gtpp
operator|)
operator|=
name|kernel_table
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|gtpp
operator|)
operator|&&
name|ntohl
argument_list|(
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|grp
argument_list|)
condition|)
operator|(
operator|*
name|gtpp
operator|)
operator|=
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_gnext
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|gtpp
operator|)
condition|)
return|return
literal|0
return|;
comment|/* no more groups */
for|for
control|(
name|gt
operator|=
name|kernel_table
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
control|)
block|{
comment|/* Since grps are ordered, we can stop when group changes from gbest */
if|if
condition|(
name|gbest
operator|&&
name|gbest
operator|->
name|gt_mcastgrp
operator|!=
name|gt
operator|->
name|gt_mcastgrp
condition|)
break|break;
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
block|{
comment|/* Among those entries> spec, find "lowest" one */
if|if
condition|(
operator|(
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|>
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|==
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|>
name|ntohl
argument_list|(
name|src
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|==
name|ntohl
argument_list|(
name|grp
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|==
name|src
operator|&&
literal|0xFFFFFFFF
operator|>
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|gbest
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|gbest
operator|->
name|gt_mcastgrp
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
operator|==
name|ntohl
argument_list|(
name|gbest
operator|->
name|gt_mcastgrp
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|<
name|ntohl
argument_list|(
name|sbest
operator|->
name|st_origin
argument_list|)
operator|)
operator|)
condition|)
block|{
name|gbest
operator|=
name|gt
expr_stmt|;
name|sbest
operator|=
name|st
expr_stmt|;
block|}
block|}
block|}
operator|(
operator|*
name|gtpp
operator|)
operator|=
name|gbest
expr_stmt|;
operator|(
operator|*
name|stpp
operator|)
operator|=
name|sbest
expr_stmt|;
return|return
operator|(
operator|*
name|gtpp
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that sg contains current information for the given group,source.  * This is fetched from the kernel as a unit so that counts for the entry   * are consistent, i.e. packet and byte counts for the same entry are   * read at the same time.  */
end_comment

begin_function
name|void
name|refresh_sg
parameter_list|(
name|sg
parameter_list|,
name|gt
parameter_list|,
name|st
parameter_list|)
name|struct
name|sioc_sg_req
modifier|*
name|sg
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
block|{
specifier|static
name|int
name|lastq
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|quantum
operator|!=
name|lastq
operator|||
name|sg
operator|->
name|src
operator|.
name|s_addr
operator|!=
name|st
operator|->
name|st_origin
operator|||
name|sg
operator|->
name|grp
operator|.
name|s_addr
operator|!=
name|gt
operator|->
name|gt_mcastgrp
condition|)
block|{
name|lastq
operator|=
name|quantum
expr_stmt|;
name|sg
operator|->
name|src
operator|.
name|s_addr
operator|=
name|st
operator|->
name|st_origin
expr_stmt|;
name|sg
operator|->
name|grp
operator|.
name|s_addr
operator|=
name|gt
operator|->
name|gt_mcastgrp
expr_stmt|;
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a routing table entry, and a vifi, find the next entry  * equal to or greater than those  */
end_comment

begin_function
name|int
name|next_child
parameter_list|(
name|gtpp
parameter_list|,
name|stpp
parameter_list|,
name|grp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|,
name|vifi
parameter_list|)
name|struct
name|gtable
modifier|*
modifier|*
name|gtpp
decl_stmt|;
name|struct
name|stable
modifier|*
modifier|*
name|stpp
decl_stmt|;
name|u_int32
name|grp
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|vifi_t
modifier|*
name|vifi
decl_stmt|;
comment|/* vif at which to start looking */
block|{
comment|/* Get (G,S,M) entry */
if|if
condition|(
name|mask
operator|!=
literal|0xFFFFFFFF
operator|||
operator|!
operator|(
operator|(
operator|*
name|gtpp
operator|)
operator|=
name|find_grp
argument_list|(
name|grp
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|stpp
operator|)
operator|=
name|find_grp_src
argument_list|(
operator|(
operator|*
name|gtpp
operator|)
argument_list|,
name|src
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
name|next_grp_src_mask
argument_list|(
name|gtpp
argument_list|,
name|stpp
argument_list|,
name|grp
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Continue until we get one with a valid next vif */
do|do
block|{
for|for
control|(
init|;
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_route
operator|->
name|rt_children
operator|&&
operator|*
name|vifi
operator|<
name|numvifs
condition|;
operator|(
operator|*
name|vifi
operator|)
operator|++
control|)
if|if
condition|(
name|VIFM_ISSET
argument_list|(
operator|*
name|vifi
argument_list|,
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_route
operator|->
name|rt_children
argument_list|)
condition|)
return|return
literal|1
return|;
operator|*
name|vifi
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|next_grp_src_mask
argument_list|(
name|gtpp
argument_list|,
name|stpp
argument_list|,
operator|(
operator|*
name|gtpp
operator|)
operator|->
name|gt_mcastgrp
argument_list|,
operator|(
operator|*
name|stpp
operator|)
operator|->
name|st_origin
argument_list|,
literal|0xFFFFFFFF
argument_list|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNMP */
end_comment

begin_comment
comment|/*  * Initialize the kernel table structure  */
end_comment

begin_function
name|void
name|init_ktable
parameter_list|()
block|{
name|kernel_table
operator|=
name|NULL
expr_stmt|;
name|kernel_no_route
operator|=
name|NULL
expr_stmt|;
name|kroutes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Add a new table entry for (origin, mcastgrp)  */
end_comment

begin_function
name|void
name|add_table_entry
parameter_list|(
name|origin
parameter_list|,
name|mcastgrp
parameter_list|)
name|u_int32
name|origin
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
modifier|*
name|gtnp
decl_stmt|,
modifier|*
name|prev_gt
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
modifier|*
name|stnp
decl_stmt|;
comment|/*      * Since we have to enable mrouting to get the version number,      * some cache creation requests can sneak through.  Ignore them      * since we're not going to do useful stuff until we've performed      * final initialization.      */
if|if
condition|(
operator|!
name|did_final_init
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG_MFC
name|md_log
argument_list|(
name|MD_MISS
argument_list|,
name|origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|determine_route
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|prev_gt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Look for it on the no_route table; if it is found then 	 * it will be detected as a duplicate below. 	 */
for|for
control|(
name|gt
operator|=
name|kernel_no_route
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
if|if
condition|(
name|mcastgrp
operator|==
name|gt
operator|->
name|gt_mcastgrp
operator|&&
name|gt
operator|->
name|gt_srctbl
operator|&&
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
operator|==
name|origin
condition|)
break|break;
name|gtnp
operator|=
operator|&
name|kernel_no_route
expr_stmt|;
block|}
else|else
block|{
name|gtnp
operator|=
operator|&
name|r
operator|->
name|rt_groups
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_mcastgrp
operator|>=
name|mcastgrp
condition|)
break|break;
name|gtnp
operator|=
operator|&
name|gt
operator|->
name|gt_next
expr_stmt|;
name|prev_gt
operator|=
name|gt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gt
operator|==
name|NULL
operator|||
name|gt
operator|->
name|gt_mcastgrp
operator|!=
name|mcastgrp
condition|)
block|{
name|gt
operator|=
operator|(
expr|struct
name|gtable
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_mcastgrp
operator|=
name|mcastgrp
expr_stmt|;
name|gt
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|gt
operator|->
name|gt_ctime
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|gt_srctbl
operator|=
name|NULL
expr_stmt|;
name|gt
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
name|gt
operator|->
name|gt_route
operator|=
name|r
expr_stmt|;
name|gt
operator|->
name|gt_rexmit_timer
operator|=
literal|0
expr_stmt|;
name|NBRM_CLRALL
argument_list|(
name|gt
operator|->
name|gt_prunes
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prune_rexmit
operator|=
name|PRUNE_REXMIT_VAL
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|gt
operator|->
name|gt_rsrr_cache
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* Calculate forwarding vifs */
name|determine_forwvifs
argument_list|(
name|gt
argument_list|)
expr_stmt|;
comment|/* update ttls */
name|prun_add_ttls
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_next
operator|=
operator|*
name|gtnp
expr_stmt|;
operator|*
name|gtnp
operator|=
name|gt
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
expr_stmt|;
name|gt
operator|->
name|gt_prev
operator|=
name|prev_gt
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|find_src_grp
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|gt
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Entry for (%s %s) (rt:%x) exists (rt:%x)"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|r
argument_list|,
name|g
operator|->
name|gt_route
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gtp
condition|)
block|{
name|gt
operator|->
name|gt_gnext
operator|=
name|gtp
operator|->
name|gt_gnext
expr_stmt|;
name|gt
operator|->
name|gt_gprev
operator|=
name|gtp
expr_stmt|;
name|gtp
operator|->
name|gt_gnext
operator|=
name|gt
expr_stmt|;
block|}
else|else
block|{
name|gt
operator|->
name|gt_gnext
operator|=
name|kernel_table
expr_stmt|;
name|gt
operator|->
name|gt_gprev
operator|=
name|NULL
expr_stmt|;
name|kernel_table
operator|=
name|gt
expr_stmt|;
block|}
if|if
condition|(
name|gt
operator|->
name|gt_gnext
condition|)
name|gt
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|gt
expr_stmt|;
block|}
block|}
else|else
block|{
name|gt
operator|->
name|gt_gnext
operator|=
name|gt
operator|->
name|gt_gprev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|stnp
operator|=
operator|&
name|gt
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
operator|*
name|stnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|st
operator|->
name|st_origin
argument_list|)
operator|>=
name|ntohl
argument_list|(
name|origin
argument_list|)
condition|)
break|break;
name|stnp
operator|=
operator|&
name|st
operator|->
name|st_next
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|==
name|NULL
operator|||
name|st
operator|->
name|st_origin
operator|!=
name|origin
condition|)
block|{
name|st
operator|=
operator|(
expr|struct
name|stable
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_origin
operator|=
name|origin
expr_stmt|;
name|st
operator|->
name|st_pktcnt
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_savpkt
operator|=
literal|0
expr_stmt|;
name|time
argument_list|(
operator|&
name|st
operator|->
name|st_ctime
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_next
operator|=
operator|*
name|stnp
expr_stmt|;
operator|*
name|stnp
operator|=
name|st
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|==
literal|0
condition|)
block|{
comment|/* An old source which we're keeping around for statistics */
name|time
argument_list|(
operator|&
name|st
operator|->
name|st_ctime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_MFC
name|md_log
argument_list|(
name|MD_DUPE
argument_list|,
name|origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Ignore kernel->mrouted retransmissions */
if|if
condition|(
name|time
argument_list|(
literal|0
argument_list|)
operator|-
name|st
operator|->
name|st_ctime
operator|>
literal|5
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"kernel entry already exists for (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|k_add_rg
argument_list|(
name|origin
argument_list|,
name|gt
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|kroutes
operator|++
expr_stmt|;
name|k_add_rg
argument_list|(
name|origin
argument_list|,
name|gt
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"add cache entry (%s %s) gm:%x, parent-vif:%d"
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|,
name|r
condition|?
name|r
operator|->
name|rt_parent
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*      * If there are no downstream routers that want traffic for      * this group, send (or retransmit) a prune upstream.      */
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
name|send_prune
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A router has gone down.  Remove prune state pertinent to that router.  */
end_comment

begin_function
name|void
name|reset_neighbor_state
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
comment|/* 	 * If neighbor was the parent, remove the prune sent state 	 * and all of the source cache info so that prunes get 	 * regenerated. 	 */
if|if
condition|(
name|vifi
operator|==
name|r
operator|->
name|rt_parent
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|r
operator|->
name|rt_gateway
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"reset_neighbor_state parent reset (%s %s)"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
name|g
operator|->
name|gt_srctbl
operator|)
operator|!=
name|NULL
condition|)
block|{
name|g
operator|->
name|gt_srctbl
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|kroutes
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	     * Remove any prunes that this router has sent us. 	     */
name|ptnp
operator|=
operator|&
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|pt_vifi
operator|==
name|vifi
operator|&&
name|pt
operator|->
name|pt_router
operator|==
name|addr
condition|)
block|{
name|NBRM_CLR
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
expr_stmt|;
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
else|else
name|ptnp
operator|=
operator|&
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
comment|/* 	     * And see if we want to forward again. 	     */
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
condition|)
block|{
name|GET_MEMBERSHIP
argument_list|(
name|g
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|APPLY_SCOPE
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* Update kernel state */
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
comment|/* 		 * If removing this prune causes us to start forwarding 		 * (e.g. the neighbor rebooted), and we sent a prune upstream, 		 * send a graft to cancel the prune. 		 */
if|if
condition|(
operator|!
name|VIFM_ISEMPTY
argument_list|(
name|g
operator|->
name|gt_grpmems
argument_list|)
operator|&&
name|g
operator|->
name|gt_prsent_timer
condition|)
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"reset neighbor state (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Delete table entry from the kernel  * del_flag determines how many entries to delete  */
end_comment

begin_function
name|void
name|del_table_entry
parameter_list|(
name|r
parameter_list|,
name|mcastgrp
parameter_list|,
name|del_flag
parameter_list|)
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
name|u_int
name|del_flag
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|,
modifier|*
name|prev_g
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
name|prev_st
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
name|prev_pt
decl_stmt|;
if|if
condition|(
name|del_flag
operator|==
name|DEL_ALL_ROUTES
condition|)
block|{
name|g
operator|=
name|r
operator|->
name|rt_groups
expr_stmt|;
while|while
condition|(
name|g
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"del_table_entry deleting (%s %s)"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|g
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
name|st
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"del_table_entry trying to delete (%s, %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
block|}
name|prev_st
operator|=
name|st
expr_stmt|;
name|st
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|prev_st
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_srctbl
operator|=
name|NULL
expr_stmt|;
name|pt
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|prev_pt
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|prev_pt
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gnext
condition|)
name|g
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|g
operator|->
name|gt_gprev
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gprev
condition|)
name|g
operator|->
name|gt_gprev
operator|->
name|gt_gnext
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
else|else
name|kernel_table
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsrr_cache_clean
argument_list|(
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
if|if
condition|(
name|g
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|g
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
name|prev_g
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
name|free
argument_list|(
name|prev_g
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|rt_groups
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*       * Dummy routine - someday this may be needed, so it is just there      */
if|if
condition|(
name|del_flag
operator|==
name|DEL_RTE_GROUP
condition|)
block|{
name|prev_g
operator|=
operator|(
expr|struct
name|gtable
operator|*
operator|)
operator|&
name|r
operator|->
name|rt_groups
expr_stmt|;
for|for
control|(
name|g
operator|=
name|r
operator|->
name|rt_groups
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_next
control|)
block|{
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"del_table_entry deleting (%s %s)"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|g
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
name|st
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|g
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"del_table_entry trying to delete (%s, %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
block|}
name|prev_st
operator|=
name|st
expr_stmt|;
name|st
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|prev_st
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_srctbl
operator|=
name|NULL
expr_stmt|;
name|pt
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|prev_pt
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|prev_pt
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gt_pruntbl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gnext
condition|)
name|g
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|g
operator|->
name|gt_gprev
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_gprev
condition|)
name|g
operator|->
name|gt_gprev
operator|->
name|gt_gnext
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
else|else
name|kernel_table
operator|=
name|g
operator|->
name|gt_gnext
expr_stmt|;
if|if
condition|(
name|prev_g
operator|!=
operator|(
expr|struct
name|gtable
operator|*
operator|)
operator|&
name|r
operator|->
name|rt_groups
condition|)
name|g
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|prev_g
expr_stmt|;
else|else
name|g
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|NULL
expr_stmt|;
name|prev_g
operator|->
name|gt_next
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|g
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsrr_cache_clean
argument_list|(
name|g
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|=
name|prev_g
expr_stmt|;
block|}
else|else
block|{
name|prev_g
operator|=
name|g
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * update kernel table entry when a route entry changes  */
end_comment

begin_function
name|void
name|update_table_entry
parameter_list|(
name|r
parameter_list|,
name|old_parent_gw
parameter_list|)
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|u_int32
name|old_parent_gw
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
for|for
control|(
name|g
operator|=
name|r
operator|->
name|rt_groups
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_next
control|)
block|{
name|ptnp
operator|=
operator|&
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
comment|/* 	 * Delete prune entries from non-children, or non-subordinates. 	 */
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|pt
operator|->
name|pt_vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|||
operator|!
name|NBRM_ISSET
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"update_table_entry deleting prune for (%s %s) from %s on vif %d -%s%s"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s3
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|,
name|VIFM_ISSET
argument_list|(
name|pt
operator|->
name|pt_vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|?
literal|""
else|:
literal|" not a child"
argument_list|,
name|NBRM_ISSET
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|?
literal|""
else|:
literal|" not a subordinate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NBRM_ISSET
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"gt_prunes lost track of (%s %s) from %s on vif %d"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s3
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|)
expr_stmt|;
block|}
name|NBRM_CLR
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
expr_stmt|;
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ptnp
operator|=
operator|&
operator|(
operator|(
operator|*
name|ptnp
operator|)
operator|->
name|pt_next
operator|)
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"updating cache entries (%s %s) old gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
comment|/* 	 * Forget about a prune or graft that we sent previously if we 	 * have a new parent router (since the new parent router will 	 * know nothing about what I sent to the previous parent).  The 	 * old parent will forget any prune state it is keeping for us. 	 */
if|if
condition|(
name|old_parent_gw
operator|!=
name|r
operator|->
name|rt_gateway
condition|)
block|{
name|g
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Recalculate membership */
name|determine_forwvifs
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* send a prune or graft if needed. */
name|send_prune_or_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"updating cache entries (%s %s) new gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
comment|/* update ttls and add entry into kernel */
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
end_function

begin_comment
comment|/*  * set the forwarding flag for all mcastgrps on this vifi  */
end_comment

begin_function
name|void
name|update_lclgrp
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_MEMBER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"group %s joined on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|APPLY_SCOPE
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|g
operator|->
name|gt_grpmems
argument_list|)
condition|)
continue|continue;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"update lclgrp (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * reset forwarding flag for all mcastgrps on this vifi  */
end_comment

begin_function
name|void
name|delete_lclgrp
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_MEMBER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"group %s left on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|mcastgrp
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|gt_route
operator|==
name|NULL
operator|||
name|SUBS_ARE_PRUNED
argument_list|(
name|g
operator|->
name|gt_route
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"delete lclgrp (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|g
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
comment|/* 		 * If there are no more members of this particular group, 		 *  send prune upstream 		 */
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|g
operator|->
name|gt_grpmems
argument_list|)
operator|&&
name|g
operator|->
name|gt_route
operator|->
name|rt_gateway
condition|)
name|send_prune
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Takes the prune message received and then strips it to  * determine the (src, grp) pair to be pruned.  *  * Adds the router to the (src, grp) entry then.  *  * Determines if further packets have to be sent down that vif  *  * Determines if a corresponding prune message has to be generated  */
end_comment

begin_function
name|void
name|accept_prune
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_int32
name|prun_src
decl_stmt|;
name|u_int32
name|prun_grp
decl_stmt|;
name|u_int32
name|prun_tmr
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring prune report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if enough data is present */
if|if
condition|(
name|datalen
operator|<
literal|12
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"non-decipherable prune from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_grp
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|prun_tmr
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|prun_tmr
operator|=
name|ntohl
argument_list|(
name|prun_tmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|prun_tmr
operator|<=
name|MIN_PRUNE_LIFE
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring prune from %s on vif %d for (%s %s)/%d because its lifetime is too short"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|prun_tmr
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d prunes (%s %s)/%d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|prun_tmr
argument_list|)
expr_stmt|;
comment|/*      * Find the subnet for the prune      */
if|if
condition|(
name|find_src_grp
argument_list|(
name|prun_src
argument_list|,
literal|0
argument_list|,
name|prun_grp
argument_list|)
condition|)
block|{
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"found grp state, (%s %s), metric is %d, children are %x, subords are %08x%08x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|,
name|r
operator|->
name|rt_children
argument_list|,
name|r
operator|->
name|rt_subordinates
operator|.
name|hi
argument_list|,
name|r
operator|->
name|rt_subordinates
operator|.
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"prune received from non-child %s for (%s %s) (dominant on vif %d is %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
argument_list|,
name|s4
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RINGBUFFER
name|printringbuf
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_scope
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"prune received from %s on scoped grp (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pt
operator|=
name|find_prune_entry
argument_list|(
name|src
argument_list|,
name|g
operator|->
name|gt_pruntbl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s %d from %s for (%s %s)/%d %s %d %s %x"
argument_list|,
literal|"duplicate prune received on vif"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|prun_tmr
argument_list|,
literal|"old timer:"
argument_list|,
name|pt
operator|->
name|pt_timer
argument_list|,
literal|"cur gm:"
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_timer
operator|=
name|prun_tmr
expr_stmt|;
block|}
else|else
block|{
name|struct
name|listaddr
modifier|*
name|n
init|=
name|neighbor_info
argument_list|(
name|vifi
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Prune from non-neighbor %s on vif %d!?"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* allocate space for the prune structure */
name|pt
operator|=
operator|(
expr|struct
name|ptable
operator|*
operator|)
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ptable
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"pt: ran out of memory"
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_vifi
operator|=
name|vifi
expr_stmt|;
name|pt
operator|->
name|pt_router
operator|=
name|src
expr_stmt|;
name|pt
operator|->
name|pt_timer
operator|=
name|prun_tmr
expr_stmt|;
name|pt
operator|->
name|pt_next
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
name|g
operator|->
name|gt_pruntbl
operator|=
name|pt
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|pt
operator|->
name|pt_index
operator|=
name|n
operator|->
name|al_index
expr_stmt|;
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check if any more packets need to be sent on the  	 * vif which sent this message 	 */
if|if
condition|(
name|SUBS_ARE_PRUNED
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
operator|&&
operator|!
name|grplst_mem
argument_list|(
name|vifi
argument_list|,
name|prun_grp
argument_list|)
condition|)
block|{
name|nbrbitmap_t
name|tmp
decl_stmt|;
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"vifnbrs=0x%08x%08x, subord=0x%08x%08x prunes=0x%08x%08x"
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
operator|.
name|hi
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
operator|.
name|lo
argument_list|,
name|r
operator|->
name|rt_subordinates
operator|.
name|hi
argument_list|,
name|r
operator|->
name|rt_subordinates
operator|.
name|lo
argument_list|,
name|g
operator|->
name|gt_prunes
operator|.
name|hi
argument_list|,
name|g
operator|->
name|gt_prunes
operator|.
name|lo
argument_list|)
expr_stmt|;
comment|/* XXX debugging */
name|NBRM_COPY
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|NBRM_MASK
argument_list|(
name|tmp
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NBRM_ISSETALLMASK
argument_list|(
name|g
operator|->
name|gt_prunes
argument_list|,
name|tmp
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"subordinate error"
argument_list|)
expr_stmt|;
comment|/* XXX end debugging */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"prune (%s %s), stop sending on vif %d, gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
comment|/* 	 * check if all the child routers have expressed no interest 	 * in this group and if this group does not exist in the  	 * interface 	 * Send a prune message then upstream 	 */
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|g
operator|->
name|gt_grpmems
argument_list|)
operator|&&
name|r
operator|->
name|rt_gateway
condition|)
block|{
name|send_prune
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * There is no kernel entry for this group.  Therefore, we can 	 * simply ignore the prune, as we are not forwarding this traffic 	 * downstream. 	 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (%s %s)/%d from %s"
argument_list|,
literal|"prune message received with no kernel entry for"
argument_list|,
name|inet_fmt
argument_list|(
name|prun_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|prun_grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|prun_tmr
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if this mcastgrp is present in the kernel table  * If so and if a prune was sent, it sends a graft upwards  */
end_comment

begin_function
name|void
name|chkgrp_graft
parameter_list|(
name|vifi
parameter_list|,
name|mcastgrp
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|mcastgrp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
name|kernel_table
init|;
name|g
condition|;
name|g
operator|=
name|g
operator|->
name|gt_gnext
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mcastgrp
argument_list|)
operator|<
name|ntohl
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|)
condition|)
break|break;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_mcastgrp
operator|==
name|mcastgrp
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
if|if
condition|(
name|g
operator|->
name|gt_prsent_timer
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
comment|/* 		 * If the vif that was joined was a scoped vif, 		 * ignore it ; don't graft back 		 */
name|APPLY_SCOPE
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|g
operator|->
name|gt_grpmems
argument_list|)
condition|)
continue|continue;
comment|/* send graft upwards */
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* update cache timer*/
name|g
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"chkgrp graft (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
block|}
end_function

begin_comment
comment|/* determine the multicast group and src  *   * if it does, then determine if a prune was sent   * upstream.  * if prune sent upstream, send graft upstream and send  * ack downstream.  *   * if no prune sent upstream, change the forwarding bit  * for this interface and send ack downstream.  *  * if no entry exists for this group send ack downstream.  */
end_comment

begin_function
name|void
name|accept_graft
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|graft_src
decl_stmt|;
name|u_int32
name|graft_grp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
if|if
condition|(
name|datalen
operator|<
literal|8
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable graft from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|graft_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|graft_grp
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|send_graft_ack
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|graft_src
argument_list|,
name|graft_grp
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifi
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring graft for (%s %s) from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d grafts (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Find the subnet for the graft      */
if|if
condition|(
name|find_src_grp
argument_list|(
name|graft_src
argument_list|,
literal|0
argument_list|,
name|graft_grp
argument_list|)
condition|)
block|{
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|r
operator|=
name|g
operator|->
name|gt_route
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_scope
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"graft received from %s on scoped grp (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptnp
operator|=
operator|&
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pt_vifi
operator|==
name|vifi
operator|)
operator|&&
operator|(
name|pt
operator|->
name|pt_router
operator|==
name|src
operator|)
condition|)
block|{
name|NBRM_CLR
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|g
operator|->
name|gt_prunes
argument_list|)
expr_stmt|;
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"accept graft (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|g
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|g
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|g
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
break|break;
block|}
else|else
block|{
name|ptnp
operator|=
operator|&
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
block|}
name|g
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gt_prsent_timer
condition|)
comment|/* send graft upwards */
name|send_graft
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * We have no state for the source and group in question. 	 * This is fine, since we know that we have no prune state, and 	 * grafts are requests to remove prune state. 	 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (%s %s) from %s"
argument_list|,
literal|"graft received with no kernel entry for"
argument_list|,
name|inet_fmt
argument_list|(
name|graft_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|graft_grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * find out which group is involved first of all   * then determine if a graft was sent.  * if no graft sent, ignore the message  * if graft was sent and the ack is from the right   * source, remove the graft timer so that we don't   * have send a graft again  */
end_comment

begin_function
name|void
name|accept_g_ack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|gtable
modifier|*
name|g
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|grft_src
decl_stmt|;
name|u_int32
name|grft_grp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring graft ack from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|datalen
operator|<
literal|0
operator|||
name|datalen
operator|>
literal|8
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received non-decipherable graft ack from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|grft_src
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|grft_grp
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d acks graft (%s, %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|grft_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grft_grp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Find the subnet for the graft ack      */
if|if
condition|(
name|find_src_grp
argument_list|(
name|grft_src
argument_list|,
literal|0
argument_list|,
name|grft_grp
argument_list|)
condition|)
block|{
name|g
operator|=
name|gtp
condition|?
name|gtp
operator|->
name|gt_gnext
else|:
name|kernel_table
expr_stmt|;
name|g
operator|->
name|gt_grftsnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s (%s, %s) from %s"
argument_list|,
literal|"rcvd graft ack with no kernel entry for"
argument_list|,
name|inet_fmt
argument_list|(
name|grft_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|grft_grp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RINGBUFFER
name|printringbuf
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * free all prune entries and kernel routes  * normally, this should inform the kernel that all of its routes  * are going away, but this is only called by restart(), which is  * about to call MRT_DONE which does that anyway.  */
end_comment

begin_function
name|void
name|free_all_prunes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|gtable
modifier|*
name|g
decl_stmt|,
modifier|*
name|prev_g
decl_stmt|;
specifier|register
name|struct
name|stable
modifier|*
name|s
decl_stmt|,
modifier|*
name|prev_s
decl_stmt|;
specifier|register
name|struct
name|ptable
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev_p
decl_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|g
operator|=
name|r
operator|->
name|rt_groups
expr_stmt|;
while|while
condition|(
name|g
condition|)
block|{
name|s
operator|=
name|g
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|prev_s
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|prev_s
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|g
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|prev_p
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|prev_p
argument_list|)
expr_stmt|;
block|}
name|prev_g
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|prev_g
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|prev_g
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_g
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|rt_groups
operator|=
name|NULL
expr_stmt|;
block|}
name|kernel_table
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|kernel_no_route
expr_stmt|;
while|while
condition|(
name|g
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|gt_srctbl
condition|)
name|free
argument_list|(
name|g
operator|->
name|gt_srctbl
argument_list|)
expr_stmt|;
name|prev_g
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|prev_g
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|prev_g
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_g
argument_list|)
expr_stmt|;
block|}
name|kernel_no_route
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a new route is created, search  * a) The less-specific part of the routing table  * b) The route-less kernel table  * for sources that the new route might want to handle.  *  * "Inheriting" these sources might be cleanest, but simply deleting  * them is easier, and letting the kernel re-request them.  */
end_comment

begin_function
name|void
name|steal_sources
parameter_list|(
name|rt
parameter_list|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
modifier|*
name|gtnp
decl_stmt|;
specifier|register
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
modifier|*
name|stnp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|rt
operator|->
name|rt_next
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|rt_groups
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_origin
operator|&
name|rp
operator|->
name|rt_originmask
operator|)
operator|==
name|rp
operator|->
name|rt_origin
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Route for %s stealing sources from %s"
argument_list|,
name|RT_FMT
argument_list|(
name|rt
argument_list|,
name|s1
argument_list|)
argument_list|,
name|RT_FMT
argument_list|(
name|rp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|gt
operator|=
name|rp
operator|->
name|rt_groups
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
block|{
name|stnp
operator|=
operator|&
name|gt
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
operator|*
name|stnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|st
operator|->
name|st_origin
operator|&
name|rt
operator|->
name|rt_originmask
operator|)
operator|==
name|rt
operator|->
name|rt_origin
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s stealing (%s %s) from %s"
argument_list|,
name|RT_FMT
argument_list|(
name|rt
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s4
argument_list|)
argument_list|,
name|RT_FMT
argument_list|(
name|rp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s, %s)"
argument_list|,
literal|"steal_sources trying to delete"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
block|}
operator|*
name|stnp
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stnp
operator|=
operator|&
name|st
operator|->
name|st_next
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|gtnp
operator|=
operator|&
name|kernel_no_route
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
operator|&&
operator|(
operator|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
operator|&
name|rt
operator|->
name|rt_originmask
operator|)
operator|==
name|rt
operator|->
name|rt_origin
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s stealing (%s %s) from %s"
argument_list|,
name|RT_FMT
argument_list|(
name|rt
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s4
argument_list|)
argument_list|,
literal|"no_route table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s %s)"
argument_list|,
literal|"steal_sources trying to delete"
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|gt
operator|->
name|gt_srctbl
argument_list|)
expr_stmt|;
operator|*
name|gtnp
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
operator|->
name|gt_prev
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|gt
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gtnp
operator|=
operator|&
name|gt
operator|->
name|gt_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Advance the timers on all the cache entries.  * If there are any entries whose timers have expired,  * remove these entries from the kernel cache.  */
end_comment

begin_function
name|void
name|age_table_entry
parameter_list|()
block|{
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|,
modifier|*
modifier|*
name|gtnptr
decl_stmt|;
name|struct
name|stable
modifier|*
name|st
decl_stmt|,
modifier|*
modifier|*
name|stnp
decl_stmt|;
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|ptnp
decl_stmt|;
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"aging forwarding cache entries"
argument_list|)
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|kernel_table
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnptr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vifi_t
name|i
decl_stmt|;
comment|/* XXX Debugging */
name|int
name|fixit
init|=
literal|0
decl_stmt|;
comment|/* XXX Debugging */
name|r
operator|=
name|gt
operator|->
name|gt_route
expr_stmt|;
comment|/* XXX Debugging... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	     * If we're not sending on this vif, 	     * And this group isn't scoped on this vif, 	     * And I'm the parent for this route on this vif, 	     * And there are subordinates on this vif, 	     * And all of the subordinates haven't pruned, 	     *		YELL LOUDLY 	     *		and remember to fix it up later 	     */
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
operator|&&
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|&&
name|NBRM_ISSETMASK
argument_list|(
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
operator|&&
operator|!
name|SUBS_ARE_PRUNED
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|gt
operator|->
name|gt_prunes
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"(%s %s) is blackholing on vif %d"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fixit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixit
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"fixing membership for (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|determine_forwvifs
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|send_prune_or_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"fixed  membership for (%s %s) gm:%x"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RINGBUFFER
name|printringbuf
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*DEBUG2*/
comment|/* If there are group members, 	 * and there are recent sources, 	 * and we have a route, 	 * and it's not directly connected, 	 * and we haven't sent a prune, 	 *	if there are any cache entries in the kernel 	 *	 [if there aren't we're probably waiting to rexmit], 	 *		YELL LOUDLY 	 *		and send a prune 	 */
if|if
condition|(
name|VIFM_ISEMPTY
argument_list|(
name|gt
operator|->
name|gt_grpmems
argument_list|)
operator|&&
name|gt
operator|->
name|gt_srctbl
operator|&&
name|r
operator|&&
name|r
operator|->
name|rt_gateway
operator|&&
name|gt
operator|->
name|gt_prsent_timer
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"grpmems for (%s %s) is empty but no prune state!"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|send_prune_or_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RINGBUFFER
name|printringbuf
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* XXX ...Debugging */
comment|/* advance the timer for the kernel entry */
name|gt
operator|->
name|gt_timer
operator|-=
name|TIMER_INTERVAL
expr_stmt|;
comment|/* decrement prune timer if need be */
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
condition|)
block|{
name|gt
operator|->
name|gt_prsent_timer
operator|-=
name|TIMER_INTERVAL
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|<=
literal|0
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"upstream prune tmo (%s %s)"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Reset the prune retransmission timer to its initial value */
name|gt
operator|->
name|gt_prune_rexmit
operator|=
name|PRUNE_REXMIT_VAL
expr_stmt|;
block|}
block|}
comment|/* retransmit graft with exponential backoff */
if|if
condition|(
name|gt
operator|->
name|gt_grftsnt
condition|)
block|{
specifier|register
name|int
name|y
decl_stmt|;
name|y
operator|=
operator|++
name|gt
operator|->
name|gt_grftsnt
expr_stmt|;
while|while
condition|(
name|y
operator|&&
operator|!
operator|(
name|y
operator|&
literal|1
operator|)
condition|)
name|y
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|1
condition|)
name|send_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Age prunes 	 * 	 * If a prune expires, forward again on that vif. 	 */
name|ptnp
operator|=
operator|&
name|gt
operator|->
name|gt_pruntbl
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|ptnp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|pt_timer
operator|-=
name|TIMER_INTERVAL
operator|)
operator|<=
literal|0
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"expire prune (%s %s) from %s on vif %d"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s3
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"prune (%s %s) from %s on vif %d expires with %d left on prsent timer"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s3
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|)
expr_stmt|;
comment|/* Send a graft to heal the tree. */
name|send_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
name|NBRM_CLR
argument_list|(
name|pt
operator|->
name|pt_index
argument_list|,
name|gt
operator|->
name|gt_prunes
argument_list|)
expr_stmt|;
name|expire_prune
argument_list|(
name|pt
operator|->
name|pt_vifi
argument_list|,
name|gt
argument_list|)
expr_stmt|;
comment|/* remove the router's prune entry and await new one */
operator|*
name|ptnp
operator|=
name|pt
operator|->
name|pt_next
expr_stmt|;
name|free
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptnp
operator|=
operator|&
name|pt
operator|->
name|pt_next
expr_stmt|;
block|}
block|}
comment|/* 	 * If the cache entry has expired, delete source table entries for 	 * silent sources.  If there are no source entries left, and there 	 * are no downstream prunes, then the entry is deleted. 	 * Otherwise, the cache entry's timer is refreshed. 	 */
if|if
condition|(
name|gt
operator|->
name|gt_timer
operator|<=
literal|0
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"(%s %s) timed out, checking for traffic"
argument_list|,
name|RT_FMT
argument_list|(
name|gt
operator|->
name|gt_route
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for traffic before deleting source entries */
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|gt
operator|->
name|gt_mcastgrp
expr_stmt|;
name|stnp
operator|=
operator|&
name|gt
operator|->
name|gt_srctbl
expr_stmt|;
while|while
condition|(
operator|(
name|st
operator|=
operator|*
name|stnp
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Source entries with no ctime are not actually in the 		 * kernel; they have been removed by rexmit_prune() so 		 * are safe to remove from the list at this point. 		 */
if|if
condition|(
name|st
operator|->
name|st_ctime
condition|)
block|{
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|st
operator|->
name|st_origin
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s %s)"
argument_list|,
literal|"age_table_entry: SIOCGETSGCNT failing for"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure it gets deleted below */
name|sg_req
operator|.
name|pktcnt
operator|=
name|st
operator|->
name|st_pktcnt
expr_stmt|;
block|}
block|}
else|else
block|{
name|sg_req
operator|.
name|pktcnt
operator|=
name|st
operator|->
name|st_pktcnt
expr_stmt|;
block|}
if|if
condition|(
name|sg_req
operator|.
name|pktcnt
operator|==
name|st
operator|->
name|st_pktcnt
condition|)
block|{
operator|*
name|stnp
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"age_table_entry deleting (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"age_table_entry trying to delete (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|st_pktcnt
operator|=
name|sg_req
operator|.
name|pktcnt
expr_stmt|;
name|stnp
operator|=
operator|&
name|st
operator|->
name|st_next
expr_stmt|;
block|}
block|}
comment|/* 	     * Retain the group entry if we have downstream prunes or if 	     * there is at least one source in the list that still has 	     * traffic, or if our upstream prune timer or graft 	     * retransmission timer is running. 	     */
if|if
condition|(
name|gt
operator|->
name|gt_pruntbl
operator|!=
name|NULL
operator|||
name|gt
operator|->
name|gt_srctbl
operator|!=
name|NULL
operator|||
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
operator|||
name|gt
operator|->
name|gt_grftsnt
operator|>
literal|0
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"refresh lifetim of cache entry %s%s%s%s(%s, %s)"
argument_list|,
name|gt
operator|->
name|gt_pruntbl
condition|?
literal|"(dstrm prunes) "
else|:
literal|""
argument_list|,
name|gt
operator|->
name|gt_srctbl
condition|?
literal|"(trfc flow) "
else|:
literal|""
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
operator|>
literal|0
condition|?
literal|"(upstrm prune) "
else|:
literal|""
argument_list|,
name|gt
operator|->
name|gt_grftsnt
operator|>
literal|0
condition|?
literal|"(grft rexmit) "
else|:
literal|""
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_timer
operator|=
name|CACHE_LIFETIME
argument_list|(
name|cache_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		     * The upstream prune timed out.  Remove any kernel 		     * state. 		     */
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_pruntbl
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"upstream prune for (%s %s) expires with downstream prunes active"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_sources
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_gnext
expr_stmt|;
continue|continue;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"timeout cache entry (%s, %s)"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prev
condition|)
name|gt
operator|->
name|gt_prev
operator|->
name|gt_next
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
else|else
name|gt
operator|->
name|gt_route
operator|->
name|rt_groups
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
operator|->
name|gt_prev
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_gprev
condition|)
block|{
name|gt
operator|->
name|gt_gprev
operator|->
name|gt_gnext
operator|=
name|gt
operator|->
name|gt_gnext
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_gprev
operator|->
name|gt_gnext
expr_stmt|;
block|}
else|else
block|{
name|kernel_table
operator|=
name|gt
operator|->
name|gt_gnext
expr_stmt|;
name|gtnptr
operator|=
operator|&
name|kernel_table
expr_stmt|;
block|}
if|if
condition|(
name|gt
operator|->
name|gt_gnext
condition|)
name|gt
operator|->
name|gt_gnext
operator|->
name|gt_gprev
operator|=
name|gt
operator|->
name|gt_gprev
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|gt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsrr_cache_clean
argument_list|(
name|gt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
if|if
condition|(
name|gt
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|gt
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The upstream prune timed out.  Remove any kernel 		 * state. 		 */
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_pruntbl
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"upstream prune for (%s %s) expires with downstream prunes active"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_sources
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_gnext
expr_stmt|;
block|}
block|}
comment|/*      * When traversing the no_route table, the decision is much easier.      * Just delete it if it has timed out.      */
name|gtnptr
operator|=
operator|&
name|kernel_no_route
expr_stmt|;
while|while
condition|(
operator|(
name|gt
operator|=
operator|*
name|gtnptr
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* advance the timer for the kernel entry */
name|gt
operator|->
name|gt_timer
operator|-=
name|TIMER_INTERVAL
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_timer
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_ctime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|k_del_rg
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|gt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"%s (%s %s)"
argument_list|,
literal|"age_table_entry trying to delete no-route"
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kroutes
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|gt
operator|->
name|gt_srctbl
argument_list|)
expr_stmt|;
block|}
operator|*
name|gtnptr
operator|=
name|gt
operator|->
name|gt_next
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_next
condition|)
name|gt
operator|->
name|gt_next
operator|->
name|gt_prev
operator|=
name|gt
operator|->
name|gt_prev
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_rexmit_timer
condition|)
name|timer_clearTimer
argument_list|(
name|gt
operator|->
name|gt_rexmit_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gtnptr
operator|=
operator|&
name|gt
operator|->
name|gt_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Modify the kernel to forward packets when one or multiple prunes that  * were received on the vif given by vifi, for the group given by gt,  * have expired.  */
end_comment

begin_function
specifier|static
name|void
name|expire_prune
parameter_list|(
name|vifi
parameter_list|,
name|gt
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
block|{
comment|/*      * No need to send a graft, any prunes that we sent      * will expire before any prunes that we have received.      * However, in the case that we did make a mistake,      * send a graft to compensate.      */
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
operator|>=
name|MIN_PRUNE_LIFE
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"prune expired with %d left on %s"
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
argument_list|,
literal|"prsent_timer"
argument_list|)
expr_stmt|;
name|gt
operator|->
name|gt_prsent_timer
operator|=
literal|0
expr_stmt|;
name|send_graft
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
comment|/* modify the kernel entry to forward packets */
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|gt
operator|->
name|gt_route
decl_stmt|;
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_CACHE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"forw again (%s %s) gm:%x vif:%d"
argument_list|,
name|RT_FMT
argument_list|(
name|rt
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|prun_add_ttls
argument_list|(
name|gt
argument_list|)
expr_stmt|;
name|update_kernel
argument_list|(
name|gt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
comment|/* Send route change notification to reservation protocol. */
name|rsrr_cache_send
argument_list|(
name|gt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
block|}
end_function

begin_comment
comment|/*  * Print the contents of the cache table on file 'fp2'.  */
end_comment

begin_function
name|void
name|dump_cache
parameter_list|(
name|fp2
parameter_list|)
name|FILE
modifier|*
name|fp2
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
specifier|register
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
specifier|register
name|struct
name|ptable
modifier|*
name|pt
decl_stmt|;
specifier|register
name|vifi_t
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|time_t
name|thyme
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"Multicast Routing Cache Table (%d entries)\n%s"
argument_list|,
name|kroutes
argument_list|,
literal|" Origin             Mcast-group         CTmr     Age      Ptmr Rx IVif Forwvifs\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"<(prunesrc:vif[idx]/tmr) prunebitmap\n%s"
argument_list|,
literal|">Source             Lifetime SavPkt         Pkts    Bytes RPFf\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|gt
operator|=
name|kernel_no_route
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_srctbl
condition|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-18s %-15s %-8s %-8s        - -1 (no route)\n"
argument_list|,
name|inet_fmts
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
literal|0xffffffff
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|gt
operator|->
name|gt_timer
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|thyme
operator|-
name|gt
operator|->
name|gt_ctime
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|">%s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_srctbl
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|gt
operator|=
name|kernel_table
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_gnext
control|)
block|{
name|r
operator|=
name|gt
operator|->
name|gt_route
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-18s %-15s"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-8s"
argument_list|,
name|scaletime
argument_list|(
name|gt
operator|->
name|gt_timer
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %-8s %-8s "
argument_list|,
name|scaletime
argument_list|(
name|thyme
operator|-
name|gt
operator|->
name|gt_ctime
argument_list|)
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
condition|?
name|scaletime
argument_list|(
name|gt
operator|->
name|gt_prsent_timer
argument_list|)
else|:
literal|"       -"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_prune_rexmit
condition|)
block|{
name|int
name|i
init|=
name|gt
operator|->
name|gt_prune_rexmit
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|>
name|PRUNE_REXMIT_VAL
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|i
operator|/=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|gt
operator|->
name|gt_prsent_timer
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" -"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"%2d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" -"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %2u%c%c"
argument_list|,
name|r
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_prsent_timer
condition|?
literal|'P'
else|:
name|gt
operator|->
name|gt_grftsnt
condition|?
literal|'G'
else|:
literal|' '
argument_list|,
name|VIFM_ISSET
argument_list|(
name|r
operator|->
name|rt_parent
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|?
literal|'B'
else|:
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u "
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
operator|&&
name|NBRM_ISSETMASK
argument_list|(
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" %u%c"
argument_list|,
name|i
argument_list|,
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|?
literal|'b'
else|:
name|SUBS_ARE_PRUNED
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|gt
operator|->
name|gt_prunes
argument_list|)
condition|?
literal|'p'
else|:
literal|'!'
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|gt_pruntbl
condition|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|gt
operator|->
name|gt_pruntbl
init|;
name|pt
condition|;
name|pt
operator|=
name|pt
operator|->
name|pt_next
control|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"%c%s:%d[%d]/%d"
argument_list|,
name|c
argument_list|,
name|inet_fmt
argument_list|(
name|pt
operator|->
name|pt_router
argument_list|,
name|s1
argument_list|)
argument_list|,
name|pt
operator|->
name|pt_vifi
argument_list|,
name|pt
operator|->
name|pt_index
argument_list|,
name|pt
operator|->
name|pt_timer
argument_list|)
expr_stmt|;
name|c
operator|=
literal|','
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|" 0x%08lx%08lx\n"
argument_list|,
comment|/*XXX*/
name|gt
operator|->
name|gt_prunes
operator|.
name|hi
argument_list|,
name|gt
operator|->
name|gt_prunes
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|">%-18s %-8s %6ld"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|st
operator|->
name|st_ctime
condition|?
name|scaletime
argument_list|(
name|thyme
operator|-
name|st
operator|->
name|st_ctime
argument_list|)
else|:
literal|"-"
argument_list|,
name|st
operator|->
name|st_savpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_ctime
condition|)
block|{
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|st
operator|->
name|st_origin
expr_stmt|;
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|gt
operator|->
name|gt_mcastgrp
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"SIOCGETSGCNT on (%s %s)"
argument_list|,
name|inet_fmt
argument_list|(
name|st
operator|->
name|st_origin
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|gt
operator|->
name|gt_mcastgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"     %8ld %8ld %4ld"
argument_list|,
name|sg_req
operator|.
name|pktcnt
argument_list|,
name|sg_req
operator|.
name|bytecnt
argument_list|,
name|sg_req
operator|.
name|wrong_if
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Traceroute function which returns traceroute replies to the requesting  * router. Also forwards the request to downstream routers.  */
end_comment

begin_function
name|void
name|accept_mtrace
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|data
parameter_list|,
name|no
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|u_int32
name|group
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|no
decl_stmt|;
comment|/* promoted u_char */
name|int
name|datalen
decl_stmt|;
block|{
name|u_char
name|type
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|gtable
modifier|*
name|gt
decl_stmt|;
name|struct
name|tr_query
modifier|*
name|qry
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|resp
decl_stmt|;
name|int
name|vifi
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|rcount
decl_stmt|;
name|int
name|errcode
init|=
name|TR_NO_ERR
decl_stmt|;
name|int
name|resptype
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|sioc_vif_req
name|v_req
decl_stmt|;
name|struct
name|sioc_sg_req
name|sg_req
decl_stmt|;
comment|/* Remember qid across invocations */
specifier|static
name|u_int32
name|oqid
init|=
literal|0
decl_stmt|;
comment|/* timestamp the request/response */
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Check if it is a query or a response      */
if|if
condition|(
name|datalen
operator|==
name|QLEN
condition|)
block|{
name|type
operator|=
name|QUERY
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Initial traceroute query rcvd from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|RESP
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"In-transit traceroute query rcvd from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Dropping multicast response"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s from %s to %s"
argument_list|,
literal|"Non decipherable traceroute request recieved"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|qry
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
name|data
expr_stmt|;
comment|/*      * if it is a packet with all reports filled, drop it      */
if|if
condition|(
operator|(
name|rcount
operator|=
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
operator|)
operator|==
name|no
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"packet with all reports filled in"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"s: %s g: %s d: %s "
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|group
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rttl: %d rd: %s"
argument_list|,
name|qry
operator|->
name|tr_rttl
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_raddr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rcount:%d, qid:%06x"
argument_list|,
name|rcount
argument_list|,
name|qry
operator|->
name|tr_qid
argument_list|)
expr_stmt|;
block|}
comment|/* determine the routing table entry for this traceroute */
name|rt
operator|=
name|determine_route
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
if|if
condition|(
name|rt
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rt parent vif: %d rtr: %s metric: %d"
argument_list|,
name|rt
operator|->
name|rt_parent
argument_list|,
name|inet_fmt
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|s1
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rt origin %s"
argument_list|,
name|RT_FMT
argument_list|(
name|rt
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"...no route"
argument_list|)
expr_stmt|;
comment|/*      * Query type packet - check if rte exists       * Check if the query destination is a vif connected to me.      * and if so, whether I should start response back      */
if|if
condition|(
name|type
operator|==
name|QUERY
condition|)
block|{
if|if
condition|(
name|oqid
operator|==
name|qry
operator|->
name|tr_qid
condition|)
block|{
comment|/* 	     * If the multicast router is a member of the group being 	     * queried, and the query is multicasted, then the router can 	     * recieve multiple copies of the same query.  If we have already 	     * replied to this traceroute, just ignore it this time. 	     * 	     * This is not a total solution, but since if this fails you 	     * only get N copies, N<= the number of interfaces on the router, 	     * it is not fatal. 	     */
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring duplicate traceroute packet"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Mcast traceroute: no route entry %s"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
block|}
name|vifi
operator|=
name|find_vif
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifi
operator|==
name|NO_VIF
condition|)
block|{
comment|/* The traceroute destination is not on one of my subnet vifs. */
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not an interface"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|!=
name|NULL
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not on forwarding tree for src %s"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * determine which interface the packet came in on 	 * RESP packets travel hop-by-hop so this either traversed 	 * a tunnel or came from a directly attached mrouter. 	 */
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Wrong interface for packet"
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
comment|/* Now that we've decided to send a response, save the qid */
name|oqid
operator|=
name|qry
operator|->
name|tr_qid
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending traceroute response"
argument_list|)
expr_stmt|;
comment|/* copy the packet to the sending buffer */
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|datalen
expr_stmt|;
comment|/*      * If there is no room to insert our reply, coopt the previous hop      * error indication to relay this fact.      */
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tr_resp
argument_list|)
operator|>
name|send_buf
operator|+
name|RECV_BUF_SIZE
condition|)
block|{
name|resp
operator|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
name|p
operator|-
literal|1
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_SPACE
expr_stmt|;
name|rt
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sendit
goto|;
block|}
comment|/*      * fill in initial response fields      */
name|resp
operator|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
name|p
expr_stmt|;
name|bzero
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tr_resp
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
name|RLEN
expr_stmt|;
name|resp
operator|->
name|tr_qarr
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|tp
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|tp
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
operator|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rproto
operator|=
name|PROTO_DVMRP
expr_stmt|;
name|resp
operator|->
name|tr_outaddr
operator|=
operator|(
name|vifi
operator|==
name|NO_VIF
operator|)
condition|?
name|dst
else|:
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|resp
operator|->
name|tr_fttl
operator|=
operator|(
name|vifi
operator|==
name|NO_VIF
operator|)
condition|?
literal|0
else|:
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_threshold
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|errcode
expr_stmt|;
comment|/*      * obtain # of packets out on interface      */
name|v_req
operator|.
name|vifi
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|vifi
operator|!=
name|NO_VIF
operator|&&
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifout
operator|=
name|htonl
argument_list|(
name|v_req
operator|.
name|ocount
argument_list|)
expr_stmt|;
else|else
name|resp
operator|->
name|tr_vifout
operator|=
literal|0xffffffff
expr_stmt|;
comment|/*      * fill in scoping& pruning information      */
if|if
condition|(
name|rt
condition|)
for|for
control|(
name|gt
operator|=
name|rt
operator|->
name|rt_groups
init|;
name|gt
condition|;
name|gt
operator|=
name|gt
operator|->
name|gt_next
control|)
block|{
if|if
condition|(
name|gt
operator|->
name|gt_mcastgrp
operator|>=
name|group
condition|)
break|break;
block|}
else|else
name|gt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gt
operator|&&
name|gt
operator|->
name|gt_mcastgrp
operator|==
name|group
condition|)
block|{
name|struct
name|stable
modifier|*
name|st
decl_stmt|;
for|for
control|(
name|st
operator|=
name|gt
operator|->
name|gt_srctbl
init|;
name|st
condition|;
name|st
operator|=
name|st
operator|->
name|st_next
control|)
if|if
condition|(
name|qry
operator|->
name|tr_src
operator|==
name|st
operator|->
name|st_origin
condition|)
break|break;
name|sg_req
operator|.
name|src
operator|.
name|s_addr
operator|=
name|qry
operator|->
name|tr_src
expr_stmt|;
name|sg_req
operator|.
name|grp
operator|.
name|s_addr
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|->
name|st_ctime
operator|!=
literal|0
operator|&&
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETSGCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_pktcnt
operator|=
name|htonl
argument_list|(
name|sg_req
operator|.
name|pktcnt
operator|+
name|st
operator|->
name|st_savpkt
argument_list|)
expr_stmt|;
else|else
name|resp
operator|->
name|tr_pktcnt
operator|=
name|htonl
argument_list|(
name|st
condition|?
name|st
operator|->
name|st_savpkt
else|:
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_scope
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_SCOPED
expr_stmt|;
elseif|else
if|if
condition|(
name|gt
operator|->
name|gt_prsent_timer
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_PRUNED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|gt
operator|->
name|gt_grpmems
argument_list|)
condition|)
if|if
condition|(
operator|!
name|NBRM_ISEMPTY
argument_list|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
operator|&&
name|SUBS_ARE_PRUNED
argument_list|(
name|rt
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|gt
operator|->
name|gt_prunes
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_OPRUNED
expr_stmt|;
else|else
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_FWD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|vifi
operator|!=
name|NO_VIF
operator|&&
name|scoped_addr
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
operator|)
operator|||
operator|(
name|rt
operator|&&
name|scoped_addr
argument_list|(
name|rt
operator|->
name|rt_parent
argument_list|,
name|group
argument_list|)
operator|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_SCOPED
expr_stmt|;
elseif|else
if|if
condition|(
name|rt
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_FWD
expr_stmt|;
block|}
comment|/*      *  if no rte exists, set NO_RTE error      */
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|src
operator|=
name|dst
expr_stmt|;
comment|/* the dst address of resp. pkt */
name|resp
operator|->
name|tr_inaddr
operator|=
literal|0
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_RTE
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* get # of packets in on interface */
name|v_req
operator|.
name|vifi
operator|=
name|rt
operator|->
name|rt_parent
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifin
operator|=
name|htonl
argument_list|(
name|v_req
operator|.
name|icount
argument_list|)
expr_stmt|;
else|else
name|resp
operator|->
name|tr_vifin
operator|=
literal|0xffffffff
expr_stmt|;
name|MASK_TO_VAL
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|,
name|resp
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
name|src
operator|=
name|uvifs
index|[
name|rt
operator|->
name|rt_parent
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|resp
operator|->
name|tr_inaddr
operator|=
name|src
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not on forwarding tree for src %s"
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qry
operator|->
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_metric
operator|>=
name|UNREACHABLE
condition|)
block|{
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_RTE
expr_stmt|;
comment|/* Hack to send reply directly */
name|rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sendit
label|:
comment|/*      * if metric is 1 or no. of reports is 1, send response to requestor      * else send to upstream router.  If the upstream router can't handle      * mtrace, set an error code and send to requestor anyway.      */
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rcount:%d, no:%d"
argument_list|,
name|rcount
argument_list|,
name|no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcount
operator|+
literal|1
operator|==
name|no
operator|)
operator|||
operator|(
name|rt
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rt
operator|->
name|rt_metric
operator|==
literal|1
operator|)
condition|)
block|{
name|resptype
operator|=
name|IGMP_MTRACE_RESP
expr_stmt|;
name|dst
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|can_mtrace
argument_list|(
name|rt
operator|->
name|rt_parent
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|)
condition|)
block|{
name|dst
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_OLD_ROUTER
expr_stmt|;
name|resptype
operator|=
name|IGMP_MTRACE_RESP
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|resptype
operator|=
name|IGMP_MTRACE
expr_stmt|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 	 * Send the reply on a known multicast capable vif. 	 * If we don't have one, we can't source any multicasts anyway. 	 */
if|if
condition|(
name|phys_vif
operator|!=
operator|-
literal|1
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending reply to %s from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|uvifs
index|[
name|phys_vif
index|]
operator|.
name|uv_lcl_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|k_set_ttl
argument_list|(
name|qry
operator|->
name|tr_rttl
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|uvifs
index|[
name|phys_vif
index|]
operator|.
name|uv_lcl_addr
argument_list|,
name|dst
argument_list|,
name|resptype
argument_list|,
name|no
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|k_set_ttl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"No enabled phyints -- %s"
argument_list|,
literal|"dropping traceroute reply"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending %s to %s from %s"
argument_list|,
name|resptype
operator|==
name|IGMP_MTRACE_RESP
condition|?
literal|"reply"
else|:
literal|"request on"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|resptype
argument_list|,
name|no
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

