begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * mtrace.c  *  * This tool traces the branch of a multicast tree from a source to a  * receiver for a particular multicast group and gives statistics  * about packet rate and loss for each hop along the path.  It can  * usually be invoked just as  *  * 	mtrace source  *  * to trace the route from that source to the local host for a default  * group when only the route is desired and not group-specific packet  * counts.  See the usage line for more complex forms.  *  *  * Released 4 Apr 1995.  This program was adapted by Steve Casner  * (USC/ISI) from a prototype written by Ajit Thyagarajan (UDel and  * Xerox PARC).  It attempts to parallel in command syntax and output  * format the unicast traceroute program written by Van Jacobson (LBL)  * for the parts where that makes sense.  *   * Copyright (c) 1995 by the University of Southern California  * All rights reserved.  *  * Permission to use, copy, modify, and distribute this software and its  * documentation in source and binary forms for any purposes and without  * fee is hereby granted, provided that the above copyright notice  * appear in all copies and that both the copyright notice and this  * permission notice appear in supporting documentation, and that any  * documentation, advertising materials, and other materials related to  * such distribution and use acknowledge that the software was developed  * by the University of Southern California, Information Sciences  * Institute.  The name of the University may not be used to endorse or  * promote products derived from this software without specific prior  * written permission.  *  * THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about  * the suitability of this software for any purpose.  THIS SOFTWARE IS  * PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Other copyrights might apply to parts of this software and are so  * noted when applicable.  *  * Parts of this software are derived from mrouted, which has the  * following license:  *   * The mrouted program is covered by the following license.  Use of the  * mrouted program represents acceptance of these terms and conditions.  *   * 1. STANFORD grants to LICENSEE a nonexclusive and nontransferable  * license to use, copy and modify the computer software ``mrouted''  * (hereinafter called the ``Program''), upon the terms and conditions  * hereinafter set out and until Licensee discontinues use of the Licensed  * Program.  *   * 2. LICENSEE acknowledges that the Program is a research tool still in  * the development state, that it is being supplied ``as is,'' without any  * accompanying services from STANFORD, and that this license is entered  * into in order to encourage scientific collaboration aimed at further  * development and application of the Program.  *   * 3. LICENSEE may copy the Program and may sublicense others to use  * object code copies of the Program or any derivative version of the  * Program.  All copies must contain all copyright and other proprietary  * notices found in the Program as provided by STANFORD.  Title to  * copyright to the Program remains with STANFORD.  *   * 4. LICENSEE may create derivative versions of the Program.  LICENSEE  * hereby grants STANFORD a royalty-free license to use, copy, modify,  * distribute and sublicense any such derivative works.  At the time  * LICENSEE provides a copy of a derivative version of the Program to a  * third party, LICENSEE shall provide STANFORD with one copy of the  * source code of the derivative version at no charge to STANFORD.  *   * 5. STANFORD MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR  * IMPLIED.  By way of example, but not limitation, STANFORD MAKES NO  * REPRESENTATION OR WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY  * PARTICULAR PURPOSE OR THAT THE USE OF THE LICENSED PROGRAM WILL NOT  * INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. STANFORD  * shall not be held liable for any liability nor for any direct, indirect  * or consequential damages with respect to any claim by LICENSEE or any  * third party on account of or arising from this Agreement or use of the  * Program.  *   * 6. This agreement shall be construed, interpreted and applied in  * accordance with the State of California and any legal action arising  * out of this Agreement or use of the Program shall be filed in a court  * in the State of California.  *   * 7. Nothing in this Agreement shall be construed as conferring rights to  * use in advertising, publicity or otherwise any trademark or the name  * of ``Stanford''.  *   * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * The mtrace program has been modified and improved by Xerox  * Corporation.  Xerox grants to LICENSEE a non-exclusive and  * non-transferable license to use, copy, and modify the Xerox modified  * and improved mrouted software on the same terms and conditions which  * govern the license Stanford and ISI grant with respect to the mtrace  * program.  These terms and conditions are incorporated in this grant  * by reference and shall be deemed to have been accepted by LICENSEE  * to cover its relationship with Xerox Corporation with respect to any  * use of the Xerox improved program.  *   * The mtrace program is COPYRIGHT 1998 by Xerox Corporation.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS5
end_ifdef

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|int
name|u_int32
typedef|;
end_typedef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|"mtrace.h"
end_include

begin_define
define|#
directive|define
name|DEFAULT_TIMEOUT
value|3
end_define

begin_comment
comment|/* How long to wait before retrying requests */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_RETRIES
value|3
end_define

begin_comment
comment|/* How many times to try */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_EXTRAHOPS
value|3
end_define

begin_comment
comment|/* How many hops past a non-responding rtr */
end_comment

begin_define
define|#
directive|define
name|MAXHOPS
value|60
end_define

begin_comment
comment|/* Don't need more hops than this */
end_comment

begin_define
define|#
directive|define
name|UNICAST_TTL
value|255
end_define

begin_comment
comment|/* TTL for unicast response */
end_comment

begin_define
define|#
directive|define
name|MULTICAST_TTL1
value|127
end_define

begin_comment
comment|/* Default TTL for multicast query/response */
end_comment

begin_define
define|#
directive|define
name|MULTICAST_TTL_INC
value|32
end_define

begin_comment
comment|/* TTL increment for increase after timeout */
end_comment

begin_define
define|#
directive|define
name|MULTICAST_TTL_MAX
value|192
end_define

begin_comment
comment|/* Maximum TTL allowed (protect low-BW links */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|DVMRP_ASK_NEIGHBORS2
value|5
end_define

begin_comment
comment|/* DVMRP msg requesting neighbors */
end_comment

begin_define
define|#
directive|define
name|DVMRP_NEIGHBORS2
value|6
end_define

begin_comment
comment|/* reply to above */
end_comment

begin_define
define|#
directive|define
name|DVMRP_NF_DOWN
value|0x10
end_define

begin_comment
comment|/* kernel state of interface */
end_comment

begin_define
define|#
directive|define
name|DVMRP_NF_DISABLED
value|0x20
end_define

begin_comment
comment|/* administratively disabled */
end_comment

begin_define
define|#
directive|define
name|MAX_IP_PACKET_LEN
value|576
end_define

begin_define
define|#
directive|define
name|MIN_IP_HEADER_LEN
value|20
end_define

begin_define
define|#
directive|define
name|MAX_IP_HEADER_LEN
value|60
end_define

begin_define
define|#
directive|define
name|MAX_DVMRP_DATA_LEN
define|\
value|( MAX_IP_PACKET_LEN - MAX_IP_HEADER_LEN - IGMP_MINLEN )
end_define

begin_struct
struct|struct
name|resp_buf
block|{
name|u_long
name|qtime
decl_stmt|;
comment|/* Time query was issued */
name|u_long
name|rtime
decl_stmt|;
comment|/* Time response was received */
name|int
name|len
decl_stmt|;
comment|/* Number of reports or length of data */
name|struct
name|igmp
name|igmp
decl_stmt|;
comment|/* IGMP header */
union|union
block|{
struct|struct
block|{
name|struct
name|tr_query
name|q
decl_stmt|;
comment|/* Query/response header */
name|struct
name|tr_resp
name|r
index|[
name|MAXHOPS
index|]
decl_stmt|;
comment|/* Per-hop reports */
block|}
name|t
struct|;
name|char
name|d
index|[
name|MAX_DVMRP_DATA_LEN
index|]
decl_stmt|;
comment|/* Neighbor data */
block|}
name|u
union|;
block|}
name|base
struct|,
name|incr
index|[
literal|2
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|qhdr
value|u.t.q
end_define

begin_define
define|#
directive|define
name|resps
value|u.t.r
end_define

begin_define
define|#
directive|define
name|ndata
value|u.d
end_define

begin_decl_stmt
name|char
modifier|*
name|names
index|[
name|MAXHOPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In mrouted 3.3 and 3.4 (and in some Cisco IOS releases),  * cache entries can get deleted even if there is traffic  * flowing, which will reset the per-source/group counters.  */
end_comment

begin_define
define|#
directive|define
name|BUG_RESET
value|0x01
end_define

begin_comment
comment|/*  * Also in mrouted 3.3 and 3.4, there's a bug in neighbor  * version processing which can cause them to believe that  * the neighbor is constantly resetting.  This causes them  * to constantly delete all their state.  */
end_comment

begin_define
define|#
directive|define
name|BUG_RESET2X
value|0x02
end_define

begin_comment
comment|/*  * Pre-3.7 mrouted's forget to byte-swap their reports.  */
end_comment

begin_define
define|#
directive|define
name|BUG_SWAP
value|0x04
end_define

begin_comment
comment|/*  * Pre-3.9 mrouted's forgot a parenthesis in the htonl()  * on the time calculation so supply bogus times.  */
end_comment

begin_define
define|#
directive|define
name|BUG_BOGUSTIME
value|0x08
end_define

begin_define
define|#
directive|define
name|BUG_NOPRINT
value|(BUG_RESET | BUG_RESET2X)
end_define

begin_decl_stmt
name|int
name|bugs
index|[
name|MAXHOPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of bugs noticed at each hop */
end_comment

begin_struct
struct|struct
name|mtrace
block|{
name|struct
name|mtrace
modifier|*
name|next
decl_stmt|;
name|struct
name|resp_buf
name|base
decl_stmt|,
name|incr
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|new
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|nresp
decl_stmt|;
name|struct
name|timeval
name|last
decl_stmt|;
name|int
name|bugs
index|[
name|MAXHOPS
index|]
decl_stmt|;
name|char
modifier|*
name|names
index|[
name|MAXHOPS
index|]
decl_stmt|;
name|int
name|lastqid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|timeout
init|=
name|DEFAULT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nqueries
init|=
name|DEFAULT_RETRIES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numeric
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|passive
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|multicast
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unicast
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|statint
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tunstats
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|weak
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extrahops
init|=
name|DEFAULT_EXTRAHOPS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|printstats
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sendopts
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lossthresh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fflag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|staticqid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|defgrp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default group if not specified */
end_comment

begin_decl_stmt
name|u_int32
name|query_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All routers multicast addr */
end_comment

begin_decl_stmt
name|u_int32
name|resp_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mtrace response multicast addr */
end_comment

begin_decl_stmt
name|u_int32
name|lcl_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This host address, in NET order */
end_comment

begin_decl_stmt
name|u_int32
name|dst_netmask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* netmask to go with qdst */
end_comment

begin_comment
comment|/*  * Query/response parameters, all initialized to zero and set later  * to default values or from options.  */
end_comment

begin_decl_stmt
name|u_int32
name|qsrc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source address in the query */
end_comment

begin_decl_stmt
name|u_int32
name|qgrp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Group address in the query */
end_comment

begin_decl_stmt
name|u_int32
name|qdst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination (receiver) address in query */
end_comment

begin_decl_stmt
name|u_char
name|qno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max number of hops to query */
end_comment

begin_decl_stmt
name|u_int32
name|raddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where response should be sent */
end_comment

begin_decl_stmt
name|int
name|qttl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TTL for the query packet */
end_comment

begin_decl_stmt
name|u_char
name|rttl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TTL for the response packet */
end_comment

begin_decl_stmt
name|u_int32
name|gwy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User-supplied last-hop router address */
end_comment

begin_decl_stmt
name|u_int32
name|tdst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where trace is sent (last-hop) */
end_comment

begin_decl_stmt
name|char
name|s1
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers to hold the string representations  */
end_comment

begin_decl_stmt
name|char
name|s2
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* of IP addresses, to be passed to inet_fmt() */
end_comment

begin_decl_stmt
name|char
name|s3
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* or inet_fmts().                             */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RECV_BUF_SIZE
value|8192
end_define

begin_decl_stmt
name|char
modifier|*
name|send_buf
decl_stmt|,
modifier|*
name|recv_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|igmp_socket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|allrtrs_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|router_alert
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Router Alert IP Option	    */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IPOPT_RA
end_ifndef

begin_define
define|#
directive|define
name|IPOPT_RA
value|148
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS5
end_ifdef

begin_decl_stmt
name|char
name|eol
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOL IP Option		    */
end_comment

begin_decl_stmt
name|int
name|ip_addlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Workaround for Option bug #2     */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * max macro, with weird case to avoid conflicts  */
end_comment

begin_define
define|#
directive|define
name|MaX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__P
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*callback_t
argument_list|)
name|__P
argument_list|(
operator|(
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
expr|struct
name|igmp
operator|*
operator|,
name|int
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
name|void
name|init_igmp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|send_igmp
name|__P
argument_list|(
operator|(
name|u_int32
name|src
operator|,
name|u_int32
name|dst
operator|,
name|int
name|type
operator|,
name|int
name|code
operator|,
name|u_int32
name|group
operator|,
name|int
name|datalen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inet_cksum
name|__P
argument_list|(
operator|(
name|u_short
operator|*
name|addr
operator|,
name|u_int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_set_rcvbuf
name|__P
argument_list|(
operator|(
name|int
name|bufsize
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_hdr_include
name|__P
argument_list|(
operator|(
name|int
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_set_ttl
name|__P
argument_list|(
operator|(
name|int
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_set_loop
name|__P
argument_list|(
operator|(
name|int
name|l
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_set_if
name|__P
argument_list|(
operator|(
name|u_int32
name|ifa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_join
name|__P
argument_list|(
operator|(
name|u_int32
name|grp
operator|,
name|u_int32
name|ifa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|k_leave
name|__P
argument_list|(
operator|(
name|u_int32
name|grp
operator|,
name|u_int32
name|ifa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inet_fmt
name|__P
argument_list|(
operator|(
name|u_int32
name|addr
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inet_fmts
name|__P
argument_list|(
operator|(
name|u_int32
name|addr
operator|,
name|u_int32
name|mask
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inet_name
name|__P
argument_list|(
operator|(
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|host_addr
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* u_int is promoted u_char */
end_comment

begin_decl_stmt
name|char
modifier|*
name|proto_type
name|__P
argument_list|(
operator|(
name|u_int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flag_type
name|__P
argument_list|(
operator|(
name|u_int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|get_netmask
name|__P
argument_list|(
operator|(
name|int
name|s
operator|,
name|u_int32
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_ttl
name|__P
argument_list|(
operator|(
expr|struct
name|resp_buf
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t_diff
name|__P
argument_list|(
operator|(
name|u_long
name|a
operator|,
name|u_long
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|byteswap
name|__P
argument_list|(
operator|(
name|u_long
name|v
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mtrace_callback
name|__P
argument_list|(
operator|(
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
expr|struct
name|igmp
operator|*
operator|,
name|int
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|send_recv
name|__P
argument_list|(
operator|(
name|u_int32
name|dst
operator|,
name|int
name|type
operator|,
name|int
name|code
operator|,
name|int
name|tries
operator|,
expr|struct
name|resp_buf
operator|*
name|save
operator|,
name|callback_t
name|callback
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|passive_mode
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|print_host
name|__P
argument_list|(
operator|(
name|u_int32
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|print_host2
name|__P
argument_list|(
operator|(
name|u_int32
name|addr1
operator|,
name|u_int32
name|addr2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_trace
name|__P
argument_list|(
operator|(
name|int
name|idx
operator|,
expr|struct
name|resp_buf
operator|*
name|buf
operator|,
name|char
operator|*
operator|*
name|names
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|what_kind
name|__P
argument_list|(
operator|(
expr|struct
name|resp_buf
operator|*
name|buf
operator|,
name|char
operator|*
name|why
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|scale
name|__P
argument_list|(
operator|(
name|int
operator|*
name|hop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|stat_line
name|__P
argument_list|(
operator|(
expr|struct
name|tr_resp
operator|*
name|r
operator|,
expr|struct
name|tr_resp
operator|*
name|s
operator|,
name|int
name|have_next
operator|,
name|int
operator|*
name|res
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fixup_stats
name|__P
argument_list|(
operator|(
expr|struct
name|resp_buf
operator|*
name|base
operator|,
expr|struct
name|resp_buf
operator|*
name|prev
operator|,
expr|struct
name|resp_buf
operator|*
name|new
operator|,
name|int
operator|*
name|bugs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_thresh
name|__P
argument_list|(
operator|(
name|int
name|thresh
operator|,
expr|struct
name|resp_buf
operator|*
name|base
operator|,
expr|struct
name|resp_buf
operator|*
name|prev
operator|,
expr|struct
name|resp_buf
operator|*
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|print_stats
name|__P
argument_list|(
operator|(
expr|struct
name|resp_buf
operator|*
name|base
operator|,
expr|struct
name|resp_buf
operator|*
name|prev
operator|,
expr|struct
name|resp_buf
operator|*
name|new
operator|,
name|int
operator|*
name|bugs
operator|,
name|char
operator|*
operator|*
name|names
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|path_changed
name|__P
argument_list|(
operator|(
expr|struct
name|resp_buf
operator|*
name|base
operator|,
expr|struct
name|resp_buf
operator|*
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|check_vif_state
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|__P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
name|argv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|log
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open and initialize the igmp socket, and fill in the non-changing  * IP header fields in the output packet buffer.  */
end_comment

begin_function
name|void
name|init_igmp
parameter_list|()
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|recv_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|RECV_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv_buf
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"Out of memory allocating recv_buf!"
argument_list|)
expr_stmt|;
name|send_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|RECV_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_buf
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"Out of memory allocating send_buf!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|igmp_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_IGMP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"IGMP socket"
argument_list|)
expr_stmt|;
name|k_hdr_include
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* include IP header when sending */
name|k_set_rcvbuf
argument_list|(
literal|48
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* lots of input buffering        */
name|k_set_ttl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* restrict multicasts to one hop */
name|k_set_loop
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* disable multicast loopback     */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|send_buf
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_IGMP
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
comment|/* applies to unicasts only */
ifndef|#
directive|ifndef
name|INADDR_ALLRTRS_GROUP
define|#
directive|define
name|INADDR_ALLRTRS_GROUP
value|0xe0000002
comment|/* 224.0.0.2 */
endif|#
directive|endif
name|allrtrs_group
operator|=
name|htonl
argument_list|(
name|INADDR_ALLRTRS_GROUP
argument_list|)
expr_stmt|;
name|router_alert
index|[
literal|0
index|]
operator|=
name|IPOPT_RA
expr_stmt|;
comment|/* Router Alert */
name|router_alert
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
comment|/* 4 bytes */
name|router_alert
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|router_alert
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS5
end_ifdef

begin_function
name|void
name|checkforsolarisbug
parameter_list|()
block|{
name|u_int32
name|localhost
init|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
decl_stmt|;
name|eol
index|[
literal|0
index|]
operator|=
name|IPOPT_EOL
expr_stmt|;
name|eol
index|[
literal|1
index|]
operator|=
name|IPOPT_EOL
expr_stmt|;
name|eol
index|[
literal|2
index|]
operator|=
name|IPOPT_EOL
expr_stmt|;
name|eol
index|[
literal|3
index|]
operator|=
name|IPOPT_EOL
expr_stmt|;
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|eol
argument_list|,
sizeof|sizeof
argument_list|(
name|eol
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Check if the kernel adds the options length to the packet      * length.  Send myself an IGMP packet of type 0 (illegal),      * with 4 IPOPT_EOL options, my PID (for collision detection)      * and 4 bytes of zero (so that the checksum works whether      * the 4 bytes of zero get truncated or not).      */
name|bzero
argument_list|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|send_igmp
argument_list|(
name|localhost
argument_list|,
name|localhost
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|recvlen
decl_stmt|,
name|dummy
init|=
literal|0
decl_stmt|;
name|recvlen
operator|=
name|recvfrom
argument_list|(
name|igmp_socket
argument_list|,
name|recv_buf
argument_list|,
name|RECV_BUF_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* 8 == 4 bytes of options and 4 bytes of PID */
if|if
condition|(
name|recvlen
operator|>=
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|+
literal|8
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|!=
literal|6
operator|||
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_IGMP
operator|||
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|localhost
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|localhost
condition|)
continue|continue;
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|igmp
operator|->
name|igmp_type
operator|!=
literal|0
operator|||
name|igmp
operator|->
name|igmp_code
operator|!=
literal|0
condition|)
continue|continue;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|igmp
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|getpid
argument_list|()
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|RAW_INPUT_IS_RAW
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|==
name|IGMP_MINLEN
operator|+
literal|4
condition|)
name|ip_addlen
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|==
name|IGMP_MINLEN
operator|+
literal|8
condition|)
name|ip_addlen
operator|=
literal|0
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"while checking for Solaris bug: Sent %d bytes and got back %d!"
argument_list|,
name|IGMP_MINLEN
operator|+
literal|8
argument_list|,
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Construct an IGMP message in the output packet buffer.  The caller may  * have already placed data in that buffer, of length 'datalen'.  Then send  * the message from the interface with IP address 'src' to destination 'dst'.  */
end_comment

begin_function
name|void
name|send_igmp
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|,
name|group
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|type
decl_stmt|,
name|code
decl_stmt|;
name|u_int32
name|group
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|sdst
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
name|setloop
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|raset
init|=
literal|0
decl_stmt|;
name|int
name|sendra
init|=
literal|0
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|send_buf
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|+
name|datalen
expr_stmt|;
name|sendlen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNOS5
name|ip
operator|->
name|ip_len
operator|+=
name|ip_addlen
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RAW_OUTPUT_IS_RAW
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|)
expr_stmt|;
name|igmp
operator|->
name|igmp_type
operator|=
name|type
expr_stmt|;
name|igmp
operator|->
name|igmp_code
operator|=
name|code
expr_stmt|;
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|=
name|group
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
literal|0
expr_stmt|;
name|igmp
operator|->
name|igmp_cksum
operator|=
name|inet_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|igmp
argument_list|,
name|IGMP_MINLEN
operator|+
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
name|k_set_if
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|setloop
operator|=
literal|1
expr_stmt|;
name|k_set_loop
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|allrtrs_group
condition|)
name|sendra
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sendopts
operator|&&
name|sendra
operator|&&
operator|!
name|raset
condition|)
block|{
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|router_alert
argument_list|,
sizeof|sizeof
argument_list|(
name|router_alert
argument_list|)
argument_list|)
expr_stmt|;
name|raset
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sendra
operator|&&
name|raset
condition|)
block|{
ifdef|#
directive|ifdef
name|SUNOS5
comment|/* 	 * SunOS5< 5.6 cannot properly reset the IP_OPTIONS "socket" 	 * option.  Instead, set up a string of 4 EOL's. 	 */
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|eol
argument_list|,
sizeof|sizeof
argument_list|(
name|eol
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|raset
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|sdst
argument_list|,
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
argument_list|)
expr_stmt|;
name|sdst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|sdst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sdst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|igmp_socket
argument_list|,
name|send_buf
argument_list|,
name|sendlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdst
argument_list|,
sizeof|sizeof
argument_list|(
name|sdst
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"sendto to %s on %s"
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setloop
condition|)
name|k_set_loop
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"SENT %s from %-15s to %s"
argument_list|,
name|type
operator|==
name|IGMP_MTRACE
condition|?
literal|"mtrace request"
else|:
literal|"ask_neighbors"
argument_list|,
name|src
operator|==
name|INADDR_ANY
condition|?
literal|"INADDR_ANY"
else|:
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * inet_cksum extracted from:  *			P I N G . C  *  * Author -  *	Mike Muuss  *	U. S. Army Ballistic Research Laboratory  *	December, 1983  * Modified at Uc Berkeley  *  * (ping.c) Status -  *	Public Domain.  Distribution Unlimited.  *  *			I N _ C K S U M  *  * Checksum routine for Internet Protocol family headers (C Version)  *  */
end_comment

begin_function
name|int
name|inet_cksum
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|u_short
modifier|*
name|addr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|nleft
init|=
operator|(
name|int
operator|)
name|len
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|w
init|=
name|addr
decl_stmt|;
name|u_short
name|answer
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|sum
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Our algorithm is simple, using a 32 bit accumulator (sum), 	 *  we add sequential 16 bit words to it, and at the end, fold 	 *  back all the carry bits from the top 16 bits into the lower 	 *  16 bits. 	 */
while|while
condition|(
name|nleft
operator|>
literal|1
condition|)
block|{
name|sum
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
name|nleft
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|nleft
operator|==
literal|1
condition|)
block|{
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|answer
operator|)
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|w
expr_stmt|;
name|sum
operator|+=
name|answer
expr_stmt|;
block|}
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|answer
operator|=
operator|~
name|sum
expr_stmt|;
comment|/* truncate to 16 bits */
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
name|void
name|k_set_rcvbuf
parameter_list|(
name|bufsize
parameter_list|)
name|int
name|bufsize
decl_stmt|;
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|bufsize
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"setsockopt SO_RCVBUF %u"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|k_hdr_include
parameter_list|(
name|bool
parameter_list|)
name|int
name|bool
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IP_HDRINCL
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_HDRINCL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bool
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"setsockopt IP_HDRINCL %u"
argument_list|,
name|bool
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|k_set_ttl
parameter_list|(
name|t
parameter_list|)
name|int
name|t
decl_stmt|;
block|{
name|u_char
name|ttl
decl_stmt|;
name|ttl
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL %u"
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|k_set_loop
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|u_char
name|loop
decl_stmt|;
name|loop
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_LOOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|loop
argument_list|,
sizeof|sizeof
argument_list|(
name|loop
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"setsockopt IP_MULTICAST_LOOP %u"
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|k_set_if
parameter_list|(
name|ifa
parameter_list|)
name|u_int32
name|ifa
decl_stmt|;
block|{
name|struct
name|in_addr
name|adr
decl_stmt|;
name|adr
operator|.
name|s_addr
operator|=
name|ifa
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|adr
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"setsockopt IP_MULTICAST_IF %s"
argument_list|,
name|inet_fmt
argument_list|(
name|ifa
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|k_join
parameter_list|(
name|grp
parameter_list|,
name|ifa
parameter_list|)
name|u_int32
name|grp
decl_stmt|;
name|u_int32
name|ifa
decl_stmt|;
block|{
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|grp
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|ifa
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"can't join group %s on interface %s"
argument_list|,
name|inet_fmt
argument_list|(
name|grp
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|ifa
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|k_leave
parameter_list|(
name|grp
parameter_list|,
name|ifa
parameter_list|)
name|u_int32
name|grp
decl_stmt|;
name|u_int32
name|ifa
decl_stmt|;
block|{
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|grp
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|ifa
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|igmp_socket
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"can't leave group %s on interface %s"
argument_list|,
name|inet_fmt
argument_list|(
name|grp
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|ifa
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert an IP address in u_long (network) format into a printable string.  */
end_comment

begin_function
name|char
modifier|*
name|inet_fmt
parameter_list|(
name|addr
parameter_list|,
name|s
parameter_list|)
name|u_int32
name|addr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|a
decl_stmt|;
name|a
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an IP subnet number in u_long (network) format into a printable  * string including the netmask as a number of bits.  */
end_comment

begin_function
name|char
modifier|*
name|inet_fmts
parameter_list|(
name|addr
parameter_list|,
name|mask
parameter_list|,
name|s
parameter_list|)
name|u_int32
name|addr
decl_stmt|,
name|mask
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|a
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|bits
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mask
operator|==
literal|0
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|a
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
name|m
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
expr_stmt|;
name|bits
operator|=
literal|33
operator|-
name|ffs
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u.%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|inet_name
parameter_list|(
name|addr
parameter_list|)
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
return|return
name|e
condition|?
name|e
operator|->
name|h_name
else|:
literal|"?"
return|;
block|}
end_function

begin_function
name|u_int32
name|host_addr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|e
init|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
literal|0
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dots
init|=
literal|3
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|ip
init|=
name|name
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|buf
decl_stmt|;
comment|/*      * Undo BSD's favor -- take fewer than 4 octets as net/subnet address      * if the name is all numeric.      */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|7
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|*
name|ip
operator|==
literal|'.'
condition|)
operator|--
name|dots
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
name|dots
operator|=
literal|0
expr_stmt|;
comment|/* Not numeric, don't add zeroes */
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dots
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
operator|*
name|op
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dots
operator|<=
literal|0
condition|)
name|e
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|&&
operator|(
name|e
operator|->
name|h_length
operator|==
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|e
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|h_addr_list
index|[
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: %s has multiple addresses, using %s\n"
argument_list|,
name|name
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|inet_addr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
operator|||
operator|(
name|IN_MULTICAST
argument_list|(
name|addr
argument_list|)
operator|&&
name|dots
operator|)
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Could not parse %s as host name or address\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|proto_type
parameter_list|(
name|type
parameter_list|)
name|u_int
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PROTO_DVMRP
case|:
return|return
operator|(
literal|"DVMRP"
operator|)
return|;
case|case
name|PROTO_MOSPF
case|:
return|return
operator|(
literal|"MOSPF"
operator|)
return|;
case|case
name|PROTO_PIM
case|:
return|return
operator|(
literal|"PIM"
operator|)
return|;
case|case
name|PROTO_CBT
case|:
return|return
operator|(
literal|"CBT"
operator|)
return|;
case|case
name|PROTO_PIM_SPECIAL
case|:
return|return
operator|(
literal|"PIM/Special"
operator|)
return|;
case|case
name|PROTO_PIM_STATIC
case|:
return|return
operator|(
literal|"PIM/Static"
operator|)
return|;
case|case
name|PROTO_DVMRP_STATIC
case|:
return|return
operator|(
literal|"DVMRP/Static"
operator|)
return|;
case|case
name|PROTO_PIM_BGP4PLUS
case|:
return|return
operator|(
literal|"PIM/BGP4+"
operator|)
return|;
case|case
name|PROTO_CBT_SPECIAL
case|:
return|return
operator|(
literal|"CBT/Special"
operator|)
return|;
case|case
name|PROTO_CBT_STATIC
case|:
return|return
operator|(
literal|"CBT/Static"
operator|)
return|;
case|case
name|PROTO_PIM_ASSERT
case|:
return|return
operator|(
literal|"PIM/Assert"
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
literal|"None"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown protocol code %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|flag_type
parameter_list|(
name|type
parameter_list|)
name|u_int
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TR_NO_ERR
case|:
return|return
operator|(
literal|""
operator|)
return|;
case|case
name|TR_WRONG_IF
case|:
return|return
operator|(
literal|"Wrong interface"
operator|)
return|;
case|case
name|TR_PRUNED
case|:
return|return
operator|(
literal|"Prune sent upstream"
operator|)
return|;
case|case
name|TR_OPRUNED
case|:
return|return
operator|(
literal|"Output pruned"
operator|)
return|;
case|case
name|TR_SCOPED
case|:
return|return
operator|(
literal|"Hit scope boundary"
operator|)
return|;
case|case
name|TR_NO_RTE
case|:
return|return
operator|(
literal|"No route"
operator|)
return|;
case|case
name|TR_NO_FWD
case|:
return|return
operator|(
literal|"Not forwarding"
operator|)
return|;
case|case
name|TR_HIT_RP
case|:
return|return
operator|(
literal|"Reached RP/Core"
operator|)
return|;
case|case
name|TR_RPF_IF
case|:
return|return
operator|(
literal|"RPF Interface"
operator|)
return|;
case|case
name|TR_NO_MULTI
case|:
return|return
operator|(
literal|"Multicast disabled"
operator|)
return|;
case|case
name|TR_OLD_ROUTER
case|:
return|return
operator|(
literal|"Next router no mtrace"
operator|)
return|;
case|case
name|TR_NO_SPACE
case|:
return|return
operator|(
literal|"No space in packet"
operator|)
return|;
case|case
name|TR_ADMIN_PROHIB
case|:
return|return
operator|(
literal|"Admin. Prohibited"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown error code %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * If destination is on a local net, get the netmask, else set the  * netmask to all ones.  There are two side effects: if the local  * address was not explicitly set, and if the destination is on a  * local net, use that one; in either case, verify that the local  * address is valid.  */
end_comment

begin_function
name|u_int32
name|get_netmask
parameter_list|(
name|s
parameter_list|,
name|dst
parameter_list|)
name|int
name|s
decl_stmt|;
name|u_int32
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifrp
decl_stmt|,
modifier|*
name|ifend
decl_stmt|;
name|u_int32
name|if_addr
decl_stmt|,
name|if_mask
decl_stmt|;
name|u_int32
name|retval
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|int
name|found
init|=
name|FALSE
decl_stmt|;
name|int
name|num_ifreq
init|=
literal|32
decl_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
name|num_ifreq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|malloc
argument_list|(
name|ifc
operator|.
name|ifc_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|ifc
operator|.
name|ifc_buf
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl SIOCGIFCONF"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* 	 * If the buffer was large enough to hold all the addresses 	 * then break out, otherwise increase the buffer size and 	 * try again. 	 * 	 * The only way to know that we definitely had enough space 	 * is to know that there was enough space for at least one 	 * more struct ifreq. ??? 	 */
if|if
condition|(
operator|(
name|num_ifreq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
operator|)
operator|>=
name|ifc
operator|.
name|ifc_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
break|break;
name|num_ifreq
operator|*=
literal|2
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
name|num_ifreq
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|realloc
argument_list|(
name|ifc
operator|.
name|ifc_buf
argument_list|,
name|ifc
operator|.
name|ifc_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifc
operator|.
name|ifc_buf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getting interface list: ran out of memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifrp
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|ifc
operator|.
name|ifc_buf
expr_stmt|;
name|ifend
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
name|ifc
operator|.
name|ifc_buf
operator|+
name|ifc
operator|.
name|ifc_len
operator|)
expr_stmt|;
comment|/*      * Loop through all of the interfaces.      */
for|for
control|(
init|;
name|ifrp
operator|<
name|ifend
operator|&&
operator|!
name|found
condition|;
name|ifrp
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifrp
operator|+
name|n
operator|)
control|)
block|{
if|#
directive|if
name|BSD
operator|>=
literal|199006
name|n
operator|=
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|+
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Ignore any interface for an address family other than IP. 	 */
if|if
condition|(
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|if_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifrp
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ifrp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SIOCGIFFLAGS on "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifrp
operator|->
name|ifr_flags
operator|&
operator|(
name|IFF_MULTICAST
operator||
name|IFF_UP
operator||
name|IFF_LOOPBACK
operator|)
operator|)
operator|!=
operator|(
name|IFF_MULTICAST
operator||
name|IFF_UP
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|dst
operator|==
literal|0
condition|)
operator|*
name|dst
operator|=
name|if_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ifrp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|if_mask
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifrp
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|if_mask
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|dst
operator|&
name|if_mask
operator|)
operator|==
operator|(
name|if_addr
operator|&
name|if_mask
operator|)
condition|)
block|{
name|retval
operator|=
name|if_mask
expr_stmt|;
if|if
condition|(
name|lcl_addr
operator|==
literal|0
condition|)
name|lcl_addr
operator|=
name|if_addr
expr_stmt|;
comment|/* XXX what about aliases? */
block|}
block|}
if|if
condition|(
name|lcl_addr
operator|==
name|if_addr
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|lcl_addr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Interface address is not valid\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to pick a TTL that will get past all the thresholds in the path.  */
end_comment

begin_function
name|int
name|get_ttl
parameter_list|(
name|buf
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|b
decl_stmt|;
name|u_int
name|ttl
decl_stmt|;
if|if
condition|(
name|buf
operator|&&
operator|(
name|rno
operator|=
name|buf
operator|->
name|len
operator|)
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|buf
operator|->
name|resps
operator|+
name|rno
operator|-
literal|1
expr_stmt|;
name|ttl
operator|=
name|b
operator|->
name|tr_fttl
expr_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>
literal|0
condition|)
block|{
operator|--
name|b
expr_stmt|;
if|if
condition|(
name|ttl
operator|<
name|b
operator|->
name|tr_fttl
condition|)
name|ttl
operator|=
name|b
operator|->
name|tr_fttl
expr_stmt|;
else|else
operator|++
name|ttl
expr_stmt|;
block|}
name|ttl
operator|+=
name|MULTICAST_TTL_INC
expr_stmt|;
if|if
condition|(
name|ttl
operator|<
name|MULTICAST_TTL1
condition|)
name|ttl
operator|=
name|MULTICAST_TTL1
expr_stmt|;
if|if
condition|(
name|ttl
operator|>
name|MULTICAST_TTL_MAX
condition|)
name|ttl
operator|=
name|MULTICAST_TTL_MAX
expr_stmt|;
return|return
operator|(
name|ttl
operator|)
return|;
block|}
else|else
return|return
operator|(
name|MULTICAST_TTL1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the difference between two 32-bit NTP timestamps and return  * the result in milliseconds.  */
end_comment

begin_function
name|int
name|t_diff
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|u_long
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|d
init|=
name|a
operator|-
name|b
decl_stmt|;
return|return
operator|(
operator|(
name|d
operator|*
literal|125
operator|)
operator|>>
literal|13
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Swap bytes for poor little-endian machines that don't byte-swap  */
end_comment

begin_function
name|u_long
name|byteswap
parameter_list|(
name|v
parameter_list|)
name|u_long
name|v
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|v
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|v
operator|&
literal|0xff00
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|v
operator|>>
literal|24
operator|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * XXX incomplete - need private callback data, too?  * XXX since dst doesn't get passed through?  */
end_comment

begin_comment
unit|int neighbors_callback(tmo, buf, buflen, igmp, igmplen, addr, addrlen, ts)     int tmo;     u_char *buf;     int buflen;     struct igmp *igmp;     int igmplen;     struct sockaddr *addr;     int *addrlen;     struct timeval *ts; {     int len;     u_int32 dst;     struct ip *ip = (struct ip *)buf;      if (tmo) 	return 0;      if (igmp->igmp_code != DVMRP_NEIGHBORS2) 	return 0;     len = igmplen;
comment|/*      * Accept DVMRP_NEIGHBORS2 response if it comes from the      * address queried or if that address is one of the local      * addresses in the response.      */
end_comment

begin_comment
unit|if (ip->ip_src.s_addr != dst) { 	u_int32 *p = (u_int32 *)(igmp + 1); 	u_int32 *ep = p + (len>> 2); 	while (p< ep) { 	    u_int32 laddr = *p++; 	    int n = ntohl(*p++)& 0xFF; 	    if (laddr == dst) { 		ep = p + 1;
comment|/* ensure p< ep after loop */
end_comment

begin_endif
unit|break; 	    } 	    p += n; 	} 	if (p>= ep) 	    return 0;     }     return buflen; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|mtrace_callback
parameter_list|(
name|tmo
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|igmp
parameter_list|,
name|igmplen
parameter_list|,
name|addr
parameter_list|,
name|addrlen
parameter_list|,
name|ts
parameter_list|)
name|int
name|tmo
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|int
name|igmplen
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|int
modifier|*
name|addrlen
decl_stmt|;
name|struct
name|timeval
modifier|*
name|ts
decl_stmt|;
block|{
specifier|static
name|u_char
modifier|*
name|savbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|savbuflen
decl_stmt|;
specifier|static
name|struct
name|sockaddr
modifier|*
name|savaddr
decl_stmt|;
specifier|static
name|int
name|savaddrlen
decl_stmt|;
specifier|static
name|struct
name|timeval
name|savts
decl_stmt|;
name|int
name|len
init|=
operator|(
name|igmplen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
init|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
operator|(
operator|(
expr|struct
name|tr_query
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|tmo
operator|==
literal|1
condition|)
block|{
comment|/* 	 * If we timed out with a packet saved, then return that packet. 	 * send_recv won't send this same packet to the callback again. 	 */
if|if
condition|(
name|savbuf
condition|)
block|{
name|bcopy
argument_list|(
name|savbuf
argument_list|,
name|buf
argument_list|,
name|savbuflen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|savbuf
argument_list|)
expr_stmt|;
name|savbuf
operator|=
name|NULL
expr_stmt|;
name|bcopy
argument_list|(
name|savaddr
argument_list|,
name|addr
argument_list|,
name|savaddrlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|savaddr
argument_list|)
expr_stmt|;
operator|*
name|addrlen
operator|=
name|savaddrlen
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|savts
argument_list|,
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|savts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|savbuflen
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|savbuf
condition|)
block|{
name|free
argument_list|(
name|savbuf
argument_list|)
expr_stmt|;
name|savbuf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|savaddr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check for IOS bug described in CSCdi68628, where a router that does      *  not have multicast enabled responds to an mtrace request with a 1-hop      *  error packet.      * Heuristic is:      *  If there is only one hop reported in the packet,      *	And the protocol code is 0,      *  And there is no previous hop,      *	And the forwarding information is "Not Forwarding",      *	And the router is not on the same subnet as the destination of the      *		trace,      *  then drop this packet.  The "#if 0"'d code saves it and returns      *   it on timeout, but timeouts are too common (e.g. routers with      *   limited unicast routing tables, etc).      */
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|r
operator|->
name|tr_rproto
operator|==
literal|0
operator|&&
name|r
operator|->
name|tr_rmtaddr
operator|==
literal|0
operator|&&
name|r
operator|->
name|tr_rflags
operator|==
name|TR_NO_FWD
condition|)
block|{
name|u_int32
name|smask
decl_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tr_outaddr
operator|&
name|smask
operator|)
operator|!=
operator|(
name|qdst
operator|&
name|smask
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX should do this silently? */
block|fprintf(stderr, "mtrace: probably IOS-buggy packet from %s\n", 		inet_fmt(((struct sockaddr_in *)addr)->sin_addr.s_addr, s1));
comment|/* Save the packet to return if a timeout occurs. */
block|savbuf = (u_char *)malloc(buflen); 	    if (savbuf != NULL) { 		bcopy(buf, savbuf, buflen); 		savbuflen = buflen; 		savaddr = (struct sockaddr *)malloc(*addrlen); 		if (savaddr != NULL) { 		    bcopy(addr, savaddr, *addrlen); 		    savaddrlen = *addrlen; 		    bcopy(ts,&savts, sizeof(savts)); 		} else { 		    free(savbuf); 		    savbuf = NULL; 		} 	    }
endif|#
directive|endif
return|return
literal|0
return|;
block|}
block|}
return|return
name|buflen
return|;
block|}
end_function

begin_function
name|int
name|send_recv
parameter_list|(
name|dst
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|,
name|tries
parameter_list|,
name|save
parameter_list|,
name|callback
parameter_list|)
name|u_int32
name|dst
decl_stmt|;
name|int
name|type
decl_stmt|,
name|code
decl_stmt|,
name|tries
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|save
decl_stmt|;
name|callback_t
name|callback
decl_stmt|;
block|{
name|fd_set
name|fds
decl_stmt|;
name|struct
name|timeval
name|tq
decl_stmt|,
name|tr
decl_stmt|,
name|tv
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|struct
name|tr_query
modifier|*
name|query
decl_stmt|,
modifier|*
name|rquery
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|;
name|struct
name|sockaddr_in
name|recvaddr
decl_stmt|;
name|u_int32
name|local
decl_stmt|,
name|group
decl_stmt|;
name|int
name|ipdatalen
decl_stmt|,
name|iphdrlen
decl_stmt|,
name|igmpdatalen
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|count
decl_stmt|,
name|recvlen
decl_stmt|,
name|socklen
init|=
sizeof|sizeof
argument_list|(
name|recvaddr
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|IGMP_MTRACE
condition|)
block|{
name|group
operator|=
name|qgrp
expr_stmt|;
name|datalen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tr_query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|group
operator|=
name|htonl
argument_list|(
literal|0xff03
argument_list|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|local
operator|=
name|lcl_addr
expr_stmt|;
else|else
name|local
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/*      * If the reply address was not explictly specified, start off      * with the standard multicast reply address, or the unicast      * address of this host if the unicast flag was specified.      * Then, if there is no response after trying half the tries      * with multicast, switch to the unicast address of this host      * if the multicast flag was not specified.  If the TTL was      * also not specified, set a multicast TTL and increase it      * for every try.      */
name|query
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|query
operator|->
name|tr_raddr
operator|=
name|raddr
condition|?
name|raddr
else|:
name|unicast
condition|?
name|lcl_addr
else|:
name|resp_cast
expr_stmt|;
name|TR_SETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
name|rttl
condition|?
name|rttl
else|:
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|query
operator|->
name|tr_raddr
argument_list|)
argument_list|)
condition|?
name|get_ttl
argument_list|(
name|save
argument_list|)
else|:
name|UNICAST_TTL
argument_list|)
expr_stmt|;
name|query
operator|->
name|tr_src
operator|=
name|qsrc
expr_stmt|;
name|query
operator|->
name|tr_dst
operator|=
name|qdst
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tries
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|oqid
decl_stmt|;
if|if
condition|(
name|tries
operator|==
name|nqueries
operator|&&
name|raddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|nqueries
operator|>>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|multicast
operator|&&
name|unicast
condition|)
block|{
name|query
operator|->
name|tr_raddr
operator|=
name|resp_cast
expr_stmt|;
if|if
condition|(
operator|!
name|rttl
condition|)
name|TR_SETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
name|get_ttl
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|multicast
condition|)
block|{
name|query
operator|->
name|tr_raddr
operator|=
name|lcl_addr
expr_stmt|;
name|TR_SETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
name|UNICAST_TTL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|tries
operator|&&
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|query
operator|->
name|tr_raddr
argument_list|)
argument_list|)
operator|&&
name|rttl
operator|==
literal|0
condition|)
block|{
name|TR_SETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
name|TR_GETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|)
operator|+
name|MULTICAST_TTL_INC
argument_list|)
expr_stmt|;
if|if
condition|(
name|TR_GETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|)
operator|>
name|MULTICAST_TTL_MAX
condition|)
name|TR_SETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
name|MULTICAST_TTL_MAX
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Change the qid for each request sent to avoid being confused 	 * by duplicate responses 	 */
name|oqid
operator|=
name|TR_GETQID
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticqid
condition|)
name|TR_SETQID
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
name|staticqid
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|SYSV
name|TR_SETQID
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
operator|(
operator|(
name|u_int32
operator|)
name|lrand48
argument_list|()
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|TR_SETQID
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|,
operator|(
operator|(
name|u_int32
operator|)
name|arc4random
argument_list|()
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set timer to calculate delays, then send query 	 */
name|gettimeofday
argument_list|(
operator|&
name|tq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|local
argument_list|,
name|dst
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for response, discarding false alarms 	 */
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|igmp_socket
operator|>=
name|FD_SETSIZE
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"descriptor too big"
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|igmp_socket
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|tq
operator|.
name|tv_sec
operator|+
name|timeout
operator|-
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|tq
operator|.
name|tv_usec
operator|-
name|tv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|tv
operator|.
name|tv_usec
operator|+=
literal|1000000L
operator|,
operator|--
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|select
argument_list|(
name|igmp_socket
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|warn
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Timed out.  Notify the callback. 		 */
if|if
condition|(
operator|!
name|callback
operator|||
operator|(
name|recvlen
operator|=
call|(
name|callback
call|)
argument_list|(
literal|1
argument_list|,
name|recv_buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|recvaddr
argument_list|,
operator|&
name|socklen
argument_list|,
operator|&
name|tr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"* "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * Data is available on the socket, so read it. 		 */
name|gettimeofday
argument_list|(
operator|&
name|tr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recvlen
operator|=
name|recvfrom
argument_list|(
name|igmp_socket
argument_list|,
name|recv_buf
argument_list|,
name|RECV_BUF_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|recvaddr
argument_list|,
operator|&
name|socklen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recvlen
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|recvlen
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|warn
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|recvlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"packet too short (%u bytes) for IP header"
argument_list|,
name|recvlen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
literal|0
condition|)
comment|/* ignore cache creation requests */
continue|continue;
name|iphdrlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|RAW_INPUT_IS_RAW
name|ipdatalen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
else|#
directive|else
name|ipdatalen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iphdrlen
operator|+
name|ipdatalen
operator|!=
name|recvlen
condition|)
block|{
name|warnx
argument_list|(
literal|"packet shorter (%u bytes) than hdr+data len (%u+%u)"
argument_list|,
name|recvlen
argument_list|,
name|iphdrlen
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
name|iphdrlen
operator|)
expr_stmt|;
name|igmpdatalen
operator|=
name|ipdatalen
operator|-
name|IGMP_MINLEN
expr_stmt|;
if|if
condition|(
name|igmpdatalen
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"IP data field too short (%u bytes) for IGMP from %s"
argument_list|,
name|ipdatalen
argument_list|,
name|inet_fmt
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|igmp
operator|->
name|igmp_type
condition|)
block|{
case|case
name|IGMP_DVMRP
case|:
if|if
condition|(
name|type
operator|!=
name|IGMP_DVMRP
operator|||
name|code
operator|!=
name|DVMRP_ASK_NEIGHBORS2
condition|)
continue|continue;
if|if
condition|(
name|igmp
operator|->
name|igmp_code
operator|!=
name|DVMRP_NEIGHBORS2
condition|)
continue|continue;
name|len
operator|=
name|igmpdatalen
expr_stmt|;
comment|/* 		 * Accept DVMRP_NEIGHBORS2 response if it comes from the 		 * address queried or if that address is one of the local 		 * addresses in the response. 		 */
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|dst
condition|)
block|{
name|u_int32
modifier|*
name|p
init|=
operator|(
name|u_int32
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
decl_stmt|;
name|u_int32
modifier|*
name|ep
init|=
name|p
operator|+
operator|(
name|len
operator|>>
literal|2
operator|)
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|ep
condition|)
block|{
name|u_int32
name|laddr
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|int
name|n
init|=
name|ntohl
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|laddr
operator|==
name|dst
condition|)
block|{
name|ep
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* ensure p< ep after loop */
break|break;
block|}
name|p
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|ep
condition|)
continue|continue;
block|}
break|break;
case|case
name|IGMP_MTRACE
case|:
comment|/* For backward compatibility with 3.3 */
case|case
name|IGMP_MTRACE_RESP
case|:
if|if
condition|(
name|type
operator|!=
name|IGMP_MTRACE
condition|)
continue|continue;
if|if
condition|(
name|igmpdatalen
operator|<=
name|QLEN
condition|)
continue|continue;
if|if
condition|(
operator|(
name|igmpdatalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
condition|)
block|{
name|printf
argument_list|(
literal|"packet with incomplete responses (%d bytes)\n"
argument_list|,
name|igmpdatalen
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ignore responses that don't match query. 		 */
name|rquery
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rquery
operator|->
name|tr_src
operator|!=
name|qsrc
operator|||
name|rquery
operator|->
name|tr_dst
operator|!=
name|qdst
condition|)
continue|continue;
if|if
condition|(
name|TR_GETQID
argument_list|(
name|rquery
operator|->
name|tr_rttlqid
argument_list|)
operator|!=
name|TR_GETQID
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|&&
name|TR_GETQID
argument_list|(
name|rquery
operator|->
name|tr_rttlqid
argument_list|)
operator|==
name|oqid
condition|)
name|printf
argument_list|(
literal|"[D]"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
operator|(
name|igmpdatalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
operator|(
name|rquery
operator|+
literal|1
operator|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Ignore trace queries passing through this node when 		 * mtrace is run on an mrouter that is in the path 		 * (needed only because IGMP_MTRACE is accepted above 		 * for backward compatibility with multicast release 3.3). 		 */
if|if
condition|(
name|igmp
operator|->
name|igmp_type
operator|==
name|IGMP_MTRACE
condition|)
block|{
name|u_int32
name|smask
decl_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|code
operator|&&
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|!=
operator|(
name|qsrc
operator|&
name|smask
operator|)
operator|&&
name|r
operator|->
name|tr_rmtaddr
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|r
operator|->
name|tr_rflags
operator|&
literal|0x80
operator|)
condition|)
continue|continue;
block|}
comment|/* 		 * Some routers will return error messages without 		 * filling in their addresses.  We fill in the address 		 * for them. 		 */
if|if
condition|(
name|r
operator|->
name|tr_outaddr
operator|==
literal|0
condition|)
name|r
operator|->
name|tr_outaddr
operator|=
name|recvaddr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 		 * A match, we'll keep this one. 		 */
if|if
condition|(
name|len
operator|>
name|code
condition|)
block|{
name|warnx
argument_list|(
literal|"num hops received (%d) exceeds request (%d)"
argument_list|,
name|len
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|rquery
operator|->
name|tr_raddr
operator|=
name|query
operator|->
name|tr_raddr
expr_stmt|;
comment|/* Insure these are */
name|TR_SETTTL
argument_list|(
name|rquery
operator|->
name|tr_rttlqid
argument_list|,
name|TR_GETTTL
argument_list|(
name|query
operator|->
name|tr_rttlqid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as we sent them */
break|break;
default|default:
continue|continue;
block|}
comment|/* 	     * We're pretty sure we want to use this packet now, 	     * but if the caller gave a callback function, it might 	     * want to handle it instead.  Give the callback a chance, 	     * unless the select timed out (in which case the only way 	     * to get here is because the callback returned a packet). 	     */
if|if
condition|(
name|callback
operator|&&
operator|(
name|count
operator|!=
literal|0
operator|)
operator|&&
operator|(
call|(
name|callback
call|)
argument_list|(
literal|0
argument_list|,
name|recv_buf
argument_list|,
name|recvlen
argument_list|,
name|igmp
argument_list|,
name|igmpdatalen
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|recvaddr
argument_list|,
operator|&
name|socklen
argument_list|,
operator|&
name|tr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The callback function didn't like this packet. 		 * Go try receiving another one. 		 */
continue|continue;
block|}
comment|/* 	     * Most of the sanity checking done at this point. 	     * Return this packet we have been waiting for. 	     */
if|if
condition|(
name|save
condition|)
block|{
name|save
operator|->
name|qtime
operator|=
operator|(
operator|(
name|tq
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|tq
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
expr_stmt|;
name|save
operator|->
name|rtime
operator|=
operator|(
operator|(
name|tr
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|tr
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
expr_stmt|;
name|save
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|igmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|save
operator|->
name|igmp
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|recvlen
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Most of this code is duplicated elsewhere.  I'm not sure if  * the duplication is absolutely required or not.  *  * Ideally, this would keep track of ongoing statistics  * collection and print out statistics.  (& keep track  * of h-b-h traces and only print the longest)  For now,  * it just snoops on what traces it can.  */
end_comment

begin_function
name|void
name|passive_mode
parameter_list|()
block|{
name|struct
name|timeval
name|tr
decl_stmt|;
name|time_t
name|tr_sec
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|;
name|struct
name|sockaddr_in
name|recvaddr
decl_stmt|;
name|struct
name|tm
modifier|*
name|now
decl_stmt|;
name|char
name|timebuf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|socklen
decl_stmt|;
name|int
name|ipdatalen
decl_stmt|,
name|iphdrlen
decl_stmt|,
name|igmpdatalen
decl_stmt|;
name|int
name|len
decl_stmt|,
name|recvlen
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|u_int32
name|smask
decl_stmt|;
name|struct
name|mtrace
modifier|*
name|remembered
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|nn
decl_stmt|;
name|int
name|pc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|raddr
condition|)
block|{
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|raddr
argument_list|)
argument_list|)
condition|)
name|k_join
argument_list|(
name|raddr
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|k_join
argument_list|(
name|htonl
argument_list|(
literal|0xE0000120
argument_list|)
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* make sure previous trace is flushed */
name|socklen
operator|=
sizeof|sizeof
argument_list|(
name|recvaddr
argument_list|)
expr_stmt|;
name|recvlen
operator|=
name|recvfrom
argument_list|(
name|igmp_socket
argument_list|,
name|recv_buf
argument_list|,
name|RECV_BUF_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|recvaddr
argument_list|,
operator|&
name|socklen
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|recvlen
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|warn
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|recvlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"packet too short (%u bytes) for IP header"
argument_list|,
name|recvlen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
literal|0
condition|)
comment|/* ignore cache creation requests */
continue|continue;
name|iphdrlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|RAW_INPUT_IS_RAW
name|ipdatalen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
else|#
directive|else
name|ipdatalen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iphdrlen
operator|+
name|ipdatalen
operator|!=
name|recvlen
condition|)
block|{
name|warnx
argument_list|(
literal|"packet shorter (%u bytes) than hdr+data len (%u+%u)"
argument_list|,
name|recvlen
argument_list|,
name|iphdrlen
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
name|iphdrlen
operator|)
expr_stmt|;
name|igmpdatalen
operator|=
name|ipdatalen
operator|-
name|IGMP_MINLEN
expr_stmt|;
if|if
condition|(
name|igmpdatalen
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"IP data field too short (%u bytes) for IGMP from %s"
argument_list|,
name|ipdatalen
argument_list|,
name|inet_fmt
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|igmp
operator|->
name|igmp_type
condition|)
block|{
case|case
name|IGMP_MTRACE
case|:
comment|/* For backward compatibility with 3.3 */
case|case
name|IGMP_MTRACE_RESP
case|:
if|if
condition|(
name|igmpdatalen
operator|<
name|QLEN
condition|)
continue|continue;
if|if
condition|(
operator|(
name|igmpdatalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
condition|)
block|{
name|printf
argument_list|(
literal|"packet with incorrect datalen\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
operator|(
name|igmpdatalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|base
operator|.
name|qtime
operator|=
operator|(
operator|(
name|tr
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|tr
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
expr_stmt|;
name|base
operator|.
name|rtime
operator|=
operator|(
operator|(
name|tr
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|tr
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
expr_stmt|;
name|base
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|igmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|base
operator|.
name|igmp
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
comment|/* 	 * If the user specified which traces to monitor, 	 * only accept traces that correspond to the 	 * request 	 */
if|if
condition|(
operator|(
name|qsrc
operator|!=
literal|0
operator|&&
name|qsrc
operator|!=
name|base
operator|.
name|qhdr
operator|.
name|tr_src
operator|)
operator|||
operator|(
name|qdst
operator|!=
literal|0
operator|&&
name|qdst
operator|!=
name|base
operator|.
name|qhdr
operator|.
name|tr_dst
operator|)
operator|||
operator|(
name|qgrp
operator|!=
literal|0
operator|&&
name|qgrp
operator|!=
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|)
condition|)
continue|continue;
comment|/* XXX This should be a hash table */
comment|/* XXX garbage-collection should be more efficient */
for|for
control|(
name|nn
operator|=
operator|&
name|remembered
operator|,
name|n
operator|=
operator|*
name|nn
operator|,
name|m
operator|=
literal|0
init|;
name|n
condition|;
name|n
operator|=
operator|*
name|nn
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|base
operator|.
name|qhdr
operator|.
name|tr_src
operator|==
name|base
operator|.
name|qhdr
operator|.
name|tr_src
operator|)
operator|&&
operator|(
name|n
operator|->
name|base
operator|.
name|qhdr
operator|.
name|tr_dst
operator|==
name|base
operator|.
name|qhdr
operator|.
name|tr_dst
operator|)
operator|&&
operator|(
name|n
operator|->
name|base
operator|.
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
operator|==
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
operator|)
condition|)
block|{
name|m
operator|=
name|n
expr_stmt|;
name|m
operator|->
name|last
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|tr
operator|.
name|tv_sec
operator|-
name|n
operator|->
name|last
operator|.
name|tv_sec
operator|>
literal|500
condition|)
block|{
comment|/* XXX don't hardcode */
operator|*
name|nn
operator|=
name|n
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nn
operator|=
operator|&
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
name|tr_sec
operator|=
name|tr
operator|.
name|tv_sec
expr_stmt|;
name|now
operator|=
name|localtime
argument_list|(
operator|&
name|tr_sec
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|timebuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%b %e %k:%M:%S"
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Mtrace %s at %s"
argument_list|,
name|len
operator|==
literal|0
condition|?
literal|"query"
else|:
name|igmp
operator|->
name|igmp_type
operator|==
name|IGMP_MTRACE_RESP
condition|?
literal|"response"
else|:
literal|"in transit"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" by %s"
argument_list|,
name|inet_fmt
argument_list|(
name|recvaddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_raddr
argument_list|)
condition|)
name|printf
argument_list|(
literal|", resp to %s"
argument_list|,
operator|(
name|len
operator|==
literal|0
operator|&&
name|recvaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|base
operator|.
name|qhdr
operator|.
name|tr_raddr
operator|)
condition|?
literal|"same"
else|:
name|inet_fmt
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_raddr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", respttl %d"
argument_list|,
name|TR_GETTTL
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_rttlqid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", qid %06x\n"
argument_list|,
name|qid
operator|=
name|TR_GETQID
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_rttlqid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"packet from %s to %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"from %s to %s via group %s (mxhop=%d)\n"
argument_list|,
name|inet_fmt
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_src
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|igmp
operator|->
name|igmp_group
operator|.
name|s_addr
argument_list|,
name|s3
argument_list|)
argument_list|,
name|igmp
operator|->
name|igmp_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|r
operator|=
name|base
operator|.
name|resps
operator|+
name|base
operator|.
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Some routers will return error messages without 	 * filling in their addresses.  We fill in the address 	 * for them. 	 */
if|if
condition|(
name|r
operator|->
name|tr_outaddr
operator|==
literal|0
condition|)
name|r
operator|->
name|tr_outaddr
operator|=
name|recvaddr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * If there was a previous trace, it see if this is a 	 * statistics candidate. 	 */
if|if
condition|(
name|m
operator|&&
name|base
operator|.
name|len
operator|==
name|m
operator|->
name|base
operator|.
name|len
operator|&&
operator|!
operator|(
name|pc
operator|=
name|path_changed
argument_list|(
operator|&
name|m
operator|->
name|base
argument_list|,
operator|&
name|base
argument_list|)
operator|)
condition|)
block|{
comment|/* 	     * Some mtrace responders send multiple copies of the same 	     * reply.  Skip this packet if it's got the same query-id 	     * as the last one. 	     */
if|if
condition|(
name|m
operator|->
name|lastqid
operator|==
name|qid
condition|)
block|{
name|printf
argument_list|(
literal|"Skipping duplicate reply\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|lastqid
operator|=
name|qid
expr_stmt|;
operator|++
name|m
operator|->
name|nresp
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|base
argument_list|,
name|m
operator|->
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Results after %d seconds:\n\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|m
operator|->
name|new
operator|->
name|qtime
operator|-
name|m
operator|->
name|base
operator|.
name|qtime
operator|)
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|fixup_stats
argument_list|(
operator|&
name|m
operator|->
name|base
argument_list|,
name|m
operator|->
name|prev
argument_list|,
name|m
operator|->
name|new
argument_list|,
name|m
operator|->
name|bugs
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
operator|&
name|m
operator|->
name|base
argument_list|,
name|m
operator|->
name|prev
argument_list|,
name|m
operator|->
name|new
argument_list|,
name|m
operator|->
name|bugs
argument_list|,
name|m
operator|->
name|names
argument_list|)
expr_stmt|;
name|m
operator|->
name|prev
operator|=
name|m
operator|->
name|new
expr_stmt|;
name|m
operator|->
name|new
operator|=
operator|&
name|m
operator|->
name|incr
index|[
operator|(
name|m
operator|->
name|nresp
operator|&
literal|1
operator|)
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|mtrace
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mtrace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtrace
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|remembered
expr_stmt|;
name|remembered
operator|=
name|m
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tr
argument_list|,
operator|&
name|m
operator|->
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|tr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Either it's a hop-by-hop in progress, or the path changed. */
if|if
condition|(
name|pc
condition|)
block|{
name|printf
argument_list|(
literal|"[Path Changed...]\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|m
operator|->
name|bugs
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|bugs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|base
argument_list|,
operator|&
name|m
operator|->
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|prev
operator|=
operator|&
name|m
operator|->
name|base
expr_stmt|;
name|m
operator|->
name|new
operator|=
operator|&
name|m
operator|->
name|incr
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|->
name|nresp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"  0  "
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
literal|1
argument_list|,
operator|&
name|base
argument_list|,
name|m
operator|->
name|names
argument_list|)
expr_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|base
operator|.
name|qhdr
operator|.
name|tr_src
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_src
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|tr_rmtaddr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|r
operator|->
name|tr_rmtaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|r
operator|->
name|tr_rflags
operator|==
name|TR_OLD_ROUTER
condition|?
literal|"doesn't support mtrace"
else|:
literal|"is the next hop"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|print_host
parameter_list|(
name|addr
parameter_list|)
name|u_int32
name|addr
decl_stmt|;
block|{
return|return
name|print_host2
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * On some routers, one interface has a name and the other doesn't.  * We always print the address of the outgoing interface, but can  * sometimes get the name from the incoming interface.  This might be  * confusing but should be slightly more helpful than just a "?".  */
end_comment

begin_function
name|char
modifier|*
name|print_host2
parameter_list|(
name|addr1
parameter_list|,
name|addr2
parameter_list|)
name|u_int32
name|addr1
decl_stmt|,
name|addr2
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|numeric
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|inet_fmt
argument_list|(
name|addr1
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
name|name
operator|=
name|inet_name
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'?'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'\0'
operator|&&
name|addr2
operator|!=
literal|0
condition|)
name|name
operator|=
name|inet_name
argument_list|(
name|addr2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s (%s)"
argument_list|,
name|name
argument_list|,
name|inet_fmt
argument_list|(
name|addr1
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print responses as received (reverse path from dst to src)  */
end_comment

begin_function
name|void
name|print_trace
parameter_list|(
name|idx
parameter_list|,
name|buf
parameter_list|,
name|names
parameter_list|)
name|int
name|idx
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
block|{
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hop
decl_stmt|;
name|char
modifier|*
name|ms
decl_stmt|;
name|i
operator|=
name|abs
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|r
operator|=
name|buf
operator|->
name|resps
operator|+
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|buf
operator|->
name|len
condition|;
operator|++
name|i
operator|,
operator|++
name|r
control|)
block|{
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|name
operator|=
name|print_host2
argument_list|(
name|r
operator|->
name|tr_outaddr
argument_list|,
name|r
operator|->
name|tr_inaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|!=
name|TR_NO_RTE
condition|)
name|printf
argument_list|(
literal|"  %s  thresh^ %d"
argument_list|,
name|proto_type
argument_list|(
name|r
operator|->
name|tr_rproto
argument_list|)
argument_list|,
name|r
operator|->
name|tr_fttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|hop
operator|=
name|t_diff
argument_list|(
name|ntohl
argument_list|(
name|r
operator|->
name|tr_qarr
argument_list|)
argument_list|,
name|buf
operator|->
name|qtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %d%s"
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  %s"
argument_list|,
name|flag_type
argument_list|(
name|r
operator|->
name|tr_rflags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|r
operator|->
name|tr_outaddr
operator|!=
operator|(
name|r
operator|-
literal|1
operator|)
operator|->
name|tr_rmtaddr
condition|)
block|{
name|printf
argument_list|(
literal|" !RPF!"
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
operator|(
name|r
operator|-
literal|1
operator|)
operator|->
name|tr_rmtaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|!=
name|TR_NO_RTE
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|tr_smask
operator|<=
literal|1
condition|)
comment|/* MASK_TO_VAL() returns 1 for default */
name|printf
argument_list|(
literal|" [default]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|u_int32
name|smask
decl_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [%s]"
argument_list|,
name|inet_fmts
argument_list|(
name|buf
operator|->
name|qhdr
operator|.
name|tr_src
operator|&
name|smask
argument_list|,
name|smask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
index|[
name|i
operator|-
literal|1
index|]
condition|)
name|free
argument_list|(
name|names
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|names
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|names
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * See what kind of router is the next hop  */
end_comment

begin_function
name|int
name|what_kind
parameter_list|(
name|buf
parameter_list|,
name|why
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|u_int32
name|smask
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|hops
init|=
name|buf
operator|->
name|len
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
init|=
name|buf
operator|->
name|resps
operator|+
name|hops
operator|-
literal|1
decl_stmt|;
name|u_int32
name|next
init|=
name|r
operator|->
name|tr_rmtaddr
decl_stmt|;
name|retval
operator|=
name|send_recv
argument_list|(
name|next
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_ASK_NEIGHBORS2
argument_list|,
literal|1
argument_list|,
operator|&
name|incr
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|u_int32
name|version
init|=
name|ntohl
argument_list|(
name|incr
index|[
literal|0
index|]
operator|.
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
argument_list|)
decl_stmt|;
name|u_int32
modifier|*
name|p
init|=
operator|(
name|u_int32
operator|*
operator|)
name|incr
index|[
literal|0
index|]
operator|.
name|ndata
decl_stmt|;
name|u_int32
modifier|*
name|ep
init|=
name|p
operator|+
operator|(
name|incr
index|[
literal|0
index|]
operator|.
name|len
operator|>>
literal|2
operator|)
decl_stmt|;
name|char
modifier|*
name|type
init|=
literal|"version "
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|version
operator|&
literal|0xFF
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
literal|"proteon/mrouted "
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|10
case|:
case|case
literal|11
case|:
name|type
operator|=
literal|"cisco "
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" [%s%d.%d] %s\n"
argument_list|,
name|type
argument_list|,
name|version
operator|&
literal|0xFF
argument_list|,
operator|(
name|version
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|ep
condition|)
block|{
name|u_int32
name|laddr
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|ntohl
argument_list|(
operator|*
name|p
argument_list|)
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
decl_stmt|;
name|int
name|n
init|=
name|ntohl
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|DVMRP_NF_DOWN
operator||
name|DVMRP_NF_DISABLED
operator|)
operator|)
operator|&&
operator|(
name|laddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|hops
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qsrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|why
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scale
parameter_list|(
name|hop
parameter_list|)
name|int
modifier|*
name|hop
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|hop
operator|>
operator|-
literal|1000
operator|&&
operator|*
name|hop
operator|<
literal|10000
condition|)
return|return
operator|(
literal|" ms"
operator|)
return|;
operator|*
name|hop
operator|/=
literal|1000
expr_stmt|;
if|if
condition|(
operator|*
name|hop
operator|>
operator|-
literal|1000
operator|&&
operator|*
name|hop
operator|<
literal|10000
condition|)
return|return
operator|(
literal|" s "
operator|)
return|;
return|return
operator|(
literal|"s "
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate and print one line of packet loss and packet rate statistics.  * Checks for count of all ones from mrouted 2.3 that doesn't have counters.  */
end_comment

begin_define
define|#
directive|define
name|NEITHER
value|0
end_define

begin_define
define|#
directive|define
name|INS
value|1
end_define

begin_define
define|#
directive|define
name|OUTS
value|2
end_define

begin_define
define|#
directive|define
name|BOTH
value|3
end_define

begin_function
name|void
name|stat_line
parameter_list|(
name|r
parameter_list|,
name|s
parameter_list|,
name|have_next
parameter_list|,
name|rst
parameter_list|)
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|have_next
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|rst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|timediff
init|=
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_qarr
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_qarr
argument_list|)
operator|)
operator|>>
literal|16
decl_stmt|;
name|int
name|v_lost
decl_stmt|,
name|v_pct
decl_stmt|;
name|int
name|g_lost
decl_stmt|,
name|g_pct
decl_stmt|;
name|int
name|v_out
init|=
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
decl_stmt|;
name|int
name|g_out
init|=
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
decl_stmt|;
name|int
name|v_pps
decl_stmt|,
name|g_pps
decl_stmt|;
name|char
name|v_str
index|[
literal|8
index|]
decl_stmt|,
name|g_str
index|[
literal|8
index|]
decl_stmt|;
name|int
name|vhave
init|=
name|NEITHER
decl_stmt|;
name|int
name|ghave
init|=
name|NEITHER
decl_stmt|;
name|int
name|gmissing
init|=
name|NEITHER
decl_stmt|;
name|char
name|whochar
decl_stmt|;
name|int
name|badtime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timediff
operator|==
literal|0
condition|)
block|{
name|badtime
operator|=
literal|1
expr_stmt|;
comment|/* Might be 32 bits of int seconds instead of 16int+16frac */
name|timediff
operator|=
name|ntohl
argument_list|(
name|s
operator|->
name|tr_qarr
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_qarr
argument_list|)
expr_stmt|;
if|if
condition|(
name|timediff
operator|==
literal|0
operator|||
name|abs
argument_list|(
name|timediff
operator|-
name|statint
argument_list|)
operator|>
name|statint
condition|)
name|timediff
operator|=
literal|1
expr_stmt|;
block|}
name|v_pps
operator|=
name|v_out
operator|/
name|timediff
expr_stmt|;
name|g_pps
operator|=
name|g_out
operator|/
name|timediff
expr_stmt|;
define|#
directive|define
name|STATS_MISSING
parameter_list|(
name|x
parameter_list|)
value|((x) == 0xFFFFFFFF)
if|if
condition|(
operator|!
name|STATS_MISSING
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
operator|&&
operator|!
name|STATS_MISSING
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
condition|)
name|vhave
operator||=
name|OUTS
expr_stmt|;
if|if
condition|(
name|STATS_MISSING
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|||
name|STATS_MISSING
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
condition|)
name|gmissing
operator||=
name|OUTS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|rst
operator|&
name|BUG_NOPRINT
operator|)
condition|)
name|ghave
operator||=
name|OUTS
expr_stmt|;
if|if
condition|(
name|have_next
condition|)
block|{
operator|--
name|r
operator|,
operator|--
name|s
operator|,
operator|--
name|rst
expr_stmt|;
if|if
condition|(
operator|!
name|STATS_MISSING
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|&&
operator|!
name|STATS_MISSING
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
condition|)
name|vhave
operator||=
name|INS
expr_stmt|;
if|if
condition|(
name|STATS_MISSING
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|||
name|STATS_MISSING
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
condition|)
name|gmissing
operator||=
name|INS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|rst
operator|&
name|BUG_NOPRINT
operator|)
condition|)
name|ghave
operator||=
name|INS
expr_stmt|;
block|}
comment|/*      * Stats can be missing for any number of reasons:      * - The hop may not be capable of collecting stats      * - Traffic may be getting dropped at the previous hop      *   and so this hop may not have any state      *      * We need a stronger heuristic to tell between these      * two cases; in case 1 we don't want to print the stats      * and in case 2 we want to print 100% loss.  We used to      * err on the side of not printing, which is less useful      * than printing 100% loss and dealing with it.      */
if|#
directive|if
literal|0
comment|/*      * If both hops report as missing, then it's likely that there's just      * no traffic flowing.      *      * If just one hop is missing, then we really don't have it.      */
block|if (gmissing != BOTH) 	ghave&= ~gmissing;
endif|#
directive|endif
name|whochar
operator|=
name|have_next
condition|?
literal|'^'
else|:
literal|' '
expr_stmt|;
switch|switch
condition|(
name|vhave
condition|)
block|{
case|case
name|BOTH
case|:
name|v_lost
operator|=
name|v_out
operator|-
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|v_out
condition|)
name|v_pct
operator|=
name|v_lost
operator|*
literal|100
operator|/
name|v_out
expr_stmt|;
else|else
name|v_pct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|-
literal|20
operator|<
name|v_pct
operator|&&
name|v_pct
operator|<
literal|101
operator|&&
name|v_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|v_str
argument_list|,
literal|"%3d%%"
argument_list|,
name|v_pct
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v_pct
operator|<
operator|-
literal|900
operator|&&
name|v_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|v_str
argument_list|,
literal|"%3dx"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|-
name|v_pct
operator|/
literal|100.
operator|+
literal|1.
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v_pct
operator|<=
operator|-
literal|20
operator|&&
name|v_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|v_str
argument_list|,
literal|"%1.1fx"
argument_list|,
operator|-
name|v_pct
operator|/
literal|100.
operator|+
literal|1.
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|v_str
argument_list|,
literal|" -- "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"%6d/%-5d=%s"
argument_list|,
name|v_lost
argument_list|,
name|v_out
argument_list|,
name|v_str
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%4d pps"
argument_list|,
name|v_pps
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_pps
operator|&&
name|badtime
condition|)
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS
case|:
name|v_out
operator|=
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
expr_stmt|;
name|v_pps
operator|=
name|v_out
operator|/
name|timediff
expr_stmt|;
name|whochar
operator|=
literal|'v'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|OUTS
case|:
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"      %c%-5d     "
argument_list|,
name|whochar
argument_list|,
name|v_out
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %c"
argument_list|,
name|whochar
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%4d pps"
argument_list|,
name|v_pps
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_pps
operator|&&
name|badtime
condition|)
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEITHER
case|:
if|if
condition|(
name|ghave
operator|!=
name|NEITHER
condition|)
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"                         "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"           "
argument_list|)
expr_stmt|;
break|break;
block|}
name|whochar
operator|=
name|have_next
condition|?
literal|'^'
else|:
literal|' '
expr_stmt|;
switch|switch
condition|(
name|ghave
condition|)
block|{
case|case
name|BOTH
case|:
name|g_lost
operator|=
name|g_out
operator|-
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|g_out
condition|)
name|g_pct
operator|=
name|g_lost
operator|*
literal|100
operator|/
name|g_out
expr_stmt|;
else|else
name|g_pct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|-
literal|20
operator|<
name|g_pct
operator|&&
name|g_pct
operator|<
literal|101
operator|&&
name|g_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|g_str
argument_list|,
literal|"%3d%%"
argument_list|,
name|g_pct
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|g_pct
operator|<
operator|-
literal|900
operator|&&
name|g_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|g_str
argument_list|,
literal|"%3dx"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|-
name|g_pct
operator|/
literal|100.
operator|+
literal|1.
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|g_pct
operator|<=
operator|-
literal|20
operator|&&
name|g_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|g_str
argument_list|,
literal|"%1.1fx"
argument_list|,
operator|-
name|g_pct
operator|/
literal|100.
operator|+
literal|1.
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|g_str
argument_list|,
literal|" -- "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%6d/%-5d=%s%4d pps"
argument_list|,
name|tunstats
condition|?
literal|""
else|:
literal|"   "
argument_list|,
name|g_lost
argument_list|,
name|g_out
argument_list|,
name|g_str
argument_list|,
name|g_pps
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_pps
operator|&&
name|badtime
condition|)
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case INS: 	g_out = ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt); 	g_pps = g_out / timediff; 	whochar = 'v';
comment|/* FALLTHROUGH */
endif|#
directive|endif
case|case
name|OUTS
case|:
name|printf
argument_list|(
literal|"%s     ?/%-5d     %4d pps"
argument_list|,
name|tunstats
condition|?
literal|""
else|:
literal|"   "
argument_list|,
name|g_out
argument_list|,
name|g_pps
argument_list|)
expr_stmt|;
if|if
condition|(
name|badtime
condition|)
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS
case|:
case|case
name|NEITHER
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"time: %d\n"
argument_list|,
name|timediff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\treset: %x hoptime: %lx\n"
argument_list|,
operator|*
name|rst
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_qarr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * A fixup to check if any pktcnt has been reset, and to fix the  * byteorder bugs in mrouted 3.6 on little-endian machines.  *  * XXX Since periodic traffic sources are likely to have their  *     pktcnt periodically reset, should we save old values when  *     the reset occurs to keep slightly better statistics over  *     the long term?  (e.g. SAP)  */
end_comment

begin_function
name|void
name|fixup_stats
parameter_list|(
name|base
parameter_list|,
name|prev
parameter_list|,
name|new
parameter_list|,
name|bugs
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|base
decl_stmt|,
decl|*
name|prev
decl_stmt|,
modifier|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|bugs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rno
init|=
name|base
operator|->
name|len
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|b
init|=
name|base
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|p
init|=
name|prev
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|new
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|int
modifier|*
name|r
init|=
name|bugs
operator|+
name|rno
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|cleanup
init|=
literal|0
decl_stmt|;
comment|/* Check for byte-swappers.  Only check on the first trace,      * since long-running traces can wrap around and falsely trigger. */
while|while
condition|(
operator|--
name|rno
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TEST_ONLY
name|u_int32
name|nvifout
init|=
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifout
argument_list|)
decl_stmt|;
name|u_int32
name|pvifout
init|=
name|ntohl
argument_list|(
name|p
operator|->
name|tr_vifout
argument_list|)
decl_stmt|;
endif|#
directive|endif
operator|--
name|n
expr_stmt|;
operator|--
name|p
expr_stmt|;
operator|--
name|b
expr_stmt|;
ifdef|#
directive|ifdef
name|TEST_ONLY
comment|/*XXX this is still buggy, so disable it for release */
if|if
condition|(
operator|(
operator|*
name|r
operator|&
name|BUG_SWAP
operator|)
operator|||
operator|(
operator|(
name|base
operator|==
name|prev
operator|)
operator|&&
operator|(
name|nvifout
operator|-
name|pvifout
operator|)
operator|>
operator|(
name|byteswap
argument_list|(
name|nvifout
argument_list|)
operator|-
name|byteswap
argument_list|(
name|pvifout
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|||
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"ip %s swaps; b %08x p %08x n %08x\n"
argument_list|,
name|inet_fmt
argument_list|(
name|n
operator|->
name|tr_inaddr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifout
argument_list|)
argument_list|,
name|pvifout
argument_list|,
name|nvifout
argument_list|)
expr_stmt|;
block|}
comment|/* This host sends byteswapped reports; swap 'em */
if|if
condition|(
operator|!
operator|(
operator|*
name|r
operator|&
name|BUG_SWAP
operator|)
condition|)
block|{
operator|*
name|r
operator||=
name|BUG_SWAP
expr_stmt|;
name|b
operator|->
name|tr_qarr
operator|=
name|byteswap
argument_list|(
name|b
operator|->
name|tr_qarr
argument_list|)
expr_stmt|;
name|b
operator|->
name|tr_vifin
operator|=
name|byteswap
argument_list|(
name|b
operator|->
name|tr_vifin
argument_list|)
expr_stmt|;
name|b
operator|->
name|tr_vifout
operator|=
name|byteswap
argument_list|(
name|b
operator|->
name|tr_vifout
argument_list|)
expr_stmt|;
name|b
operator|->
name|tr_pktcnt
operator|=
name|byteswap
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|tr_qarr
operator|=
name|byteswap
argument_list|(
name|n
operator|->
name|tr_qarr
argument_list|)
expr_stmt|;
name|n
operator|->
name|tr_vifin
operator|=
name|byteswap
argument_list|(
name|n
operator|->
name|tr_vifin
argument_list|)
expr_stmt|;
name|n
operator|->
name|tr_vifout
operator|=
name|byteswap
argument_list|(
name|n
operator|->
name|tr_vifout
argument_list|)
expr_stmt|;
name|n
operator|->
name|tr_pktcnt
operator|=
name|byteswap
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * A missing parenthesis in mrouted 3.5-3.8's prune.c 	 * causes extremely bogus time diff's. 	 * One half of the time calculation was 	 * inside an htonl() and one half wasn't.  Therefore, on 	 * a little-endian machine, both halves of the calculation 	 * would get added together in the little end.  Thus, the 	 * low-order 2 bytes are either 0000 (no overflow) or 	 * 0100 (overflow from the addition). 	 * 	 * Odds are against these particular bit patterns 	 * happening in both prev and new for actual time values. 	 */
if|if
condition|(
operator|(
operator|*
name|r
operator|&
name|BUG_BOGUSTIME
operator|)
operator|||
operator|(
operator|(
operator|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_qarr
argument_list|)
operator|&
literal|0xfeff
operator|)
operator|==
literal|0x0000
operator|)
operator|&&
operator|(
operator|(
name|ntohl
argument_list|(
name|p
operator|->
name|tr_qarr
argument_list|)
operator|&
literal|0xfeff
operator|)
operator|==
literal|0x0000
operator|)
operator|)
condition|)
block|{
operator|*
name|r
operator||=
name|BUG_BOGUSTIME
expr_stmt|;
name|n
operator|->
name|tr_qarr
operator|=
name|new
operator|->
name|rtime
expr_stmt|;
name|p
operator|->
name|tr_qarr
operator|=
name|prev
operator|->
name|rtime
expr_stmt|;
name|b
operator|->
name|tr_qarr
operator|=
name|base
operator|->
name|rtime
expr_stmt|;
block|}
block|}
name|rno
operator|=
name|base
operator|->
name|len
expr_stmt|;
name|b
operator|=
name|base
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
name|p
operator|=
name|prev
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
name|n
operator|=
name|new
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
name|r
operator|=
name|bugs
operator|+
name|rno
expr_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>=
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
operator|--
name|p
expr_stmt|;
operator|--
name|b
expr_stmt|;
operator|--
name|r
expr_stmt|;
comment|/* 	 * This hop has reset if: 	 * - There were statistics in the base AND previous pass, AND 	 *   - There are less packets this time than the first time and 	 *     we didn't reset last time, OR 	 *   - There are less packets this time than last time, OR 	 *   - There are no statistics on this pass. 	 * 	 * The "and we didn't reset last time" is necessary in the 	 * first branch of the OR because if the base is large and 	 * we reset last time but the constant-resetter-avoidance 	 * code kicked in so we delayed the copy of prev to base, 	 * new could still be below base so we trigger the 	 * constant-resetter code even though it was really only 	 * a single reset. 	 */
name|res
operator|=
operator|(
operator|(
name|b
operator|->
name|tr_pktcnt
operator|!=
literal|0xFFFFFFFF
operator|)
operator|&&
operator|(
name|p
operator|->
name|tr_pktcnt
operator|!=
literal|0xFFFFFFFF
operator|)
operator|&&
operator|(
operator|(
operator|!
operator|(
operator|*
name|r
operator|&
name|BUG_RESET
operator|)
operator|&&
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
operator|<
name|ntohl
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
operator|<
name|ntohl
argument_list|(
name|p
operator|->
name|tr_pktcnt
argument_list|)
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_pktcnt
operator|==
literal|0xFFFFFFFF
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\t\tip=%s, r=%d, res=%d\n"
argument_list|,
name|inet_fmt
argument_list|(
name|b
operator|->
name|tr_inaddr
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|*
name|r
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|printf
argument_list|(
literal|"\t\tbase=%ld, prev=%ld, new=%ld\n"
argument_list|,
name|ntohl
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|p
operator|->
name|tr_pktcnt
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|r
operator|&
name|BUG_RESET
condition|)
block|{
if|if
condition|(
name|res
operator|||
operator|(
operator|*
name|r
operator|&
name|BUG_RESET2X
operator|)
condition|)
block|{
comment|/* 		 * This router appears to be a 3.4 with that nasty ol' 		 * neighbor version bug, which causes it to constantly 		 * reset.  Just nuke the statistics for this node, and 		 * don't even bother giving it the benefit of the 		 * doubt from now on. 		 */
name|p
operator|->
name|tr_pktcnt
operator|=
name|b
operator|->
name|tr_pktcnt
operator|=
name|n
operator|->
name|tr_pktcnt
expr_stmt|;
operator|*
name|r
operator||=
name|BUG_RESET2X
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is simply the situation that the original 		 * fixup_stats was meant to deal with -- that a 		 * 3.3 or 3.4 router deleted a cache entry while 		 * traffic was still active. 		 */
operator|*
name|r
operator|&=
operator|~
name|BUG_RESET
expr_stmt|;
name|cleanup
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|res
condition|)
operator|*
name|r
operator||=
name|BUG_RESET
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
operator|==
literal|0
condition|)
return|return;
comment|/*      * If some hop reset its counters and didn't continue to      * reset, then we pretend that the previous      * trace was the first one.      */
name|rno
operator|=
name|base
operator|->
name|len
expr_stmt|;
name|b
operator|=
name|base
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
name|p
operator|=
name|prev
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>=
literal|0
condition|)
operator|(
operator|--
name|b
operator|)
operator|->
name|tr_pktcnt
operator|=
operator|(
operator|--
name|p
operator|)
operator|->
name|tr_pktcnt
expr_stmt|;
name|base
operator|->
name|qtime
operator|=
name|prev
operator|->
name|qtime
expr_stmt|;
name|base
operator|->
name|rtime
operator|=
name|prev
operator|->
name|rtime
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check per-source losses along path and compare with threshold.  */
end_comment

begin_function
name|int
name|check_thresh
parameter_list|(
name|thresh
parameter_list|,
name|base
parameter_list|,
name|prev
parameter_list|,
name|new
parameter_list|)
name|int
name|thresh
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|base
decl_stmt|,
decl|*
name|prev
decl_stmt|,
modifier|*
name|new
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rno
init|=
name|base
operator|->
name|len
operator|-
literal|1
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|b
init|=
name|base
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|p
init|=
name|prev
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|new
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|int
name|g_out
decl_stmt|,
name|g_lost
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|b
operator|->
name|tr_inaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_outaddr
operator|!=
name|b
operator|->
name|tr_outaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_rmtaddr
operator|!=
name|b
operator|->
name|tr_rmtaddr
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Route changed */
if|if
condition|(
name|rno
operator|--
operator|<
literal|1
condition|)
break|break;
name|g_out
operator|=
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|p
operator|->
name|tr_pktcnt
argument_list|)
expr_stmt|;
name|b
operator|--
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|p
operator|--
expr_stmt|;
name|g_lost
operator|=
name|g_out
operator|-
operator|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|p
operator|->
name|tr_pktcnt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|g_out
operator|&&
operator|(
operator|(
name|g_lost
operator|*
literal|100
operator|+
operator|(
name|g_out
operator|>>
literal|1
operator|)
operator|)
operator|/
name|g_out
operator|)
operator|>
name|thresh
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Print responses with statistics for forward path (from src to dst)  */
end_comment

begin_function
name|int
name|print_stats
parameter_list|(
name|base
parameter_list|,
name|prev
parameter_list|,
name|new
parameter_list|,
name|bugs
parameter_list|,
name|names
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|base
decl_stmt|,
decl|*
name|prev
decl_stmt|,
modifier|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|bugs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rtt
decl_stmt|,
name|hop
decl_stmt|;
name|char
modifier|*
name|ms
decl_stmt|;
name|u_int32
name|smask
decl_stmt|;
name|int
name|rno
init|=
name|base
operator|->
name|len
operator|-
literal|1
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|b
init|=
name|base
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|p
init|=
name|prev
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|new
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|int
modifier|*
name|r
init|=
name|bugs
operator|+
name|rno
decl_stmt|;
name|u_long
name|resptime
init|=
name|new
operator|->
name|rtime
decl_stmt|;
name|u_long
name|qarrtime
init|=
name|ntohl
argument_list|(
name|n
operator|->
name|tr_qarr
argument_list|)
decl_stmt|;
name|u_int
name|ttl
init|=
name|MaX
argument_list|(
literal|1
argument_list|,
name|n
operator|->
name|tr_fttl
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|first
init|=
operator|(
name|base
operator|==
name|prev
operator|)
decl_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|b
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Source        Response Dest    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"Packet Statistics For     Only For Traffic\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Overall     Packet Statistics For Traffic From\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inet_fmt
argument_list|(
name|base
operator|->
name|qhdr
operator|.
name|tr_src
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-15s %-15s  "
argument_list|,
operator|(
operator|(
name|b
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|base
operator|->
name|qhdr
operator|.
name|tr_src
operator|&
name|smask
operator|)
operator|)
condition|?
name|s1
else|:
literal|"   * * *       "
argument_list|,
name|inet_fmt
argument_list|(
name|base
operator|->
name|qhdr
operator|.
name|tr_raddr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inet_fmt
argument_list|(
name|base
operator|->
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"All Multicast Traffic     From %s\n"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Packet      %s To %s\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|rtt
operator|=
name|t_diff
argument_list|(
name|resptime
argument_list|,
name|new
operator|->
name|qtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|rtt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     %c       __/  rtt%5d%s    "
argument_list|,
operator|(
name|first
operator|&&
operator|!
name|verbose
operator|)
condition|?
literal|'v'
else|:
literal|'|'
argument_list|,
name|rtt
argument_list|,
name|ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"Lost/Sent = Pct  Rate       To %s\n"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" Rate       Lost/Sent = Pct  Rate\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
name|verbose
condition|)
block|{
name|hop
operator|=
name|t_diff
argument_list|(
name|resptime
argument_list|,
name|qarrtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v      /     hop%5d%s    "
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|tunstats
condition|)
name|printf
argument_list|(
literal|"---------------------     --------------------\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"-------     ---------------------\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|b
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|!=
operator|(
name|base
operator|->
name|qhdr
operator|.
name|tr_src
operator|&
name|smask
operator|)
operator|&&
name|b
operator|->
name|tr_rmtaddr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%-15s %-14s is the previous hop\n"
argument_list|,
name|inet_fmt
argument_list|(
name|b
operator|->
name|tr_rmtaddr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_name
argument_list|(
name|b
operator|->
name|tr_rmtaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v     ^\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifin
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifout
argument_list|)
operator|-
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifout
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\treset: %x hoptime: %lx\n"
argument_list|,
operator|*
name|r
argument_list|,
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|n
operator|->
name|tr_qarr
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|b
operator|->
name|tr_inaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_outaddr
operator|!=
name|b
operator|->
name|tr_outaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_rmtaddr
operator|!=
name|b
operator|->
name|tr_rmtaddr
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Route changed */
if|if
condition|(
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|n
operator|->
name|tr_outaddr
operator|)
operator|&&
name|n
operator|->
name|tr_inaddr
condition|)
name|printf
argument_list|(
literal|"%-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|n
operator|->
name|tr_inaddr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-15s %-14s %s%s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|n
operator|->
name|tr_outaddr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|names
index|[
name|rno
index|]
argument_list|,
name|flag_type
argument_list|(
name|n
operator|->
name|tr_rflags
argument_list|)
argument_list|,
operator|(
operator|*
name|r
operator|&
name|BUG_NOPRINT
operator|)
condition|?
literal|" [reset counters]"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|rno
operator|--
operator|<
literal|1
condition|)
break|break;
name|printf
argument_list|(
literal|"     %c     ^      ttl%5d   "
argument_list|,
operator|(
name|first
operator|&&
operator|!
name|verbose
operator|)
condition|?
literal|'v'
else|:
literal|'|'
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|stat_line
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|TRUE
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
name|verbose
condition|)
block|{
name|resptime
operator|=
name|qarrtime
expr_stmt|;
name|qarrtime
operator|=
name|ntohl
argument_list|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|->
name|tr_qarr
argument_list|)
expr_stmt|;
name|hop
operator|=
name|t_diff
argument_list|(
name|resptime
argument_list|,
name|qarrtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v     |      hop%5d%s"
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|stat_line
argument_list|(
name|b
argument_list|,
name|n
argument_list|,
name|TRUE
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
operator|--
name|b
operator|,
operator|--
name|p
operator|,
operator|--
name|n
operator|,
operator|--
name|r
expr_stmt|;
name|ttl
operator|=
name|MaX
argument_list|(
name|ttl
argument_list|,
name|MaX
argument_list|(
literal|1
argument_list|,
name|n
operator|->
name|tr_fttl
argument_list|)
operator|+
name|base
operator|->
name|len
operator|-
name|rno
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"     %c      \\__   ttl%5d   "
argument_list|,
operator|(
name|first
operator|&&
operator|!
name|verbose
operator|)
condition|?
literal|'v'
else|:
literal|'|'
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|stat_line
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|FALSE
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
name|verbose
condition|)
block|{
name|hop
operator|=
name|t_diff
argument_list|(
name|qarrtime
argument_list|,
name|new
operator|->
name|qtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v         \\  hop%5d%s"
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|stat_line
argument_list|(
name|b
argument_list|,
name|n
argument_list|,
name|FALSE
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%-15s %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|base
operator|->
name|qhdr
operator|.
name|tr_dst
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|!
name|passive
condition|?
name|inet_fmt
argument_list|(
name|lcl_addr
argument_list|,
name|s2
argument_list|)
else|:
literal|"   * * *       "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Receiver      Query Source\n\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Determine whether or not the path has changed.  */
end_comment

begin_function
name|int
name|path_changed
parameter_list|(
name|base
parameter_list|,
name|new
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|base
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rno
init|=
name|base
operator|->
name|len
operator|-
literal|1
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|b
init|=
name|base
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|new
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
while|while
condition|(
name|rno
operator|--
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|b
operator|->
name|tr_inaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_outaddr
operator|!=
name|b
operator|->
name|tr_outaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_rmtaddr
operator|!=
name|b
operator|->
name|tr_rmtaddr
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Route changed */
if|if
condition|(
operator|(
name|b
operator|->
name|tr_rflags
operator|==
name|TR_NO_RTE
operator|)
operator|&&
operator|(
name|n
operator|->
name|tr_rflags
operator|!=
name|TR_NO_RTE
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Route got longer? */
operator|--
name|n
expr_stmt|;
operator|--
name|b
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/***************************************************************************  *	main  ***************************************************************************/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|udp
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|addrlen
init|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|int
name|recvlen
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|prev
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|;
name|u_int32
name|smask
decl_stmt|;
name|int
name|rno
decl_stmt|;
name|int
name|hops
decl_stmt|,
name|nexthop
decl_stmt|,
name|tries
decl_stmt|;
name|u_int32
name|lastout
init|=
literal|0
decl_stmt|;
name|int
name|numstats
init|=
literal|1
decl_stmt|;
name|int
name|waittime
decl_stmt|;
name|int
name|seed
decl_stmt|;
name|int
name|hopbyhop
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"must be root"
argument_list|)
expr_stmt|;
comment|/*      * We might get spawned by vat with the audio device open.      * Close everything but stdin, stdout, stderr.      */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|255
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|init_igmp
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|argv
operator|++
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
do|do
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|char
modifier|*
name|arg
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|arg
operator|=
name|p
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|arg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* Unlisted debug print option */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|debug
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|0
condition|)
name|debug
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|debug
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'M'
case|:
comment|/* Use multicast for reponse */
name|multicast
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Use unicast for response */
name|unicast
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Trace w/ loss threshold */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|lossthresh
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lossthresh
operator|<
literal|0
condition|)
name|lossthresh
operator|=
literal|0
expr_stmt|;
name|numstats
operator|=
literal|3153600
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* Don't use IP options */
name|sendopts
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Just watch the path */
name|printstats
operator|=
name|FALSE
expr_stmt|;
name|numstats
operator|=
literal|3153600
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* (undoc.) always use this QID */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|staticqid
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticqid
operator|<
literal|0
condition|)
name|staticqid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Print confusing tunnel stats */
name|tunstats
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Cisco's "weak" mtrace */
name|weak
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Print version and exit */
comment|/* 		 * FreeBSD wants to have its own Id string, so 		 * determination of the version number has to change. 		 * XXX Note that this must be changed by hand on importing 		 * XXX new versions! 		 */
block|{
name|char
modifier|*
name|r
init|=
name|strdup
argument_list|(
name|rcsid
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|strchr
argument_list|(
name|r
argument_list|,
literal|','
argument_list|)
decl_stmt|;
while|while
condition|(
name|s
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|!=
literal|'v'
condition|)
name|s
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
comment|/* , v sp */
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtrace version 5.2/%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtrace could not determine version number!?\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* Loop updating stats indefinitely */
name|numstats
operator|=
literal|3153600
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Don't reverse map host addresses */
name|numeric
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Passive listen for traces */
name|passive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Verbosity */
name|verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Short form, don't wait for stats */
name|numstats
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Time to wait for packet arrival */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|1
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'f'
case|:
comment|/* first hop */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|qno
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qno
operator|>
name|MAXHOPS
condition|)
name|qno
operator|=
name|MAXHOPS
expr_stmt|;
elseif|else
if|if
condition|(
name|qno
operator|<
literal|1
condition|)
name|qno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
name|fflag
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'m'
case|:
comment|/* Max number of hops to trace */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|qno
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qno
operator|>
name|MAXHOPS
condition|)
name|qno
operator|=
name|MAXHOPS
expr_stmt|;
elseif|else
if|if
condition|(
name|qno
operator|<
literal|1
condition|)
name|qno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'q'
case|:
comment|/* Number of query retries */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|nqueries
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nqueries
operator|<
literal|1
condition|)
name|nqueries
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'g'
case|:
comment|/* Last-hop gateway (dest of query) */
if|if
condition|(
name|arg
operator|&&
operator|(
name|gwy
operator|=
name|host_addr
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'t'
case|:
comment|/* TTL for query packet */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|qttl
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qttl
operator|<
literal|1
condition|)
name|qttl
operator|=
literal|1
expr_stmt|;
name|rttl
operator|=
name|qttl
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'e'
case|:
comment|/* Extra hops past non-responder */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|extrahops
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|extrahops
operator|<
literal|0
condition|)
name|extrahops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'r'
case|:
comment|/* Dest for response packet */
if|if
condition|(
name|arg
operator|&&
operator|(
name|raddr
operator|=
name|host_addr
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'i'
case|:
comment|/* Local interface address */
if|if
condition|(
name|arg
operator|&&
operator|(
name|lcl_addr
operator|=
name|host_addr
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'S'
case|:
comment|/* Stat accumulation interval */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|statint
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|statint
operator|<
literal|1
condition|)
name|statint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|p
condition|)
do|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|qsrc
operator|=
name|host_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Source of path */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qsrc
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|gwy
condition|)
block|{
comment|/* Should probably rewrite arg parsing at some point, as 		 * this makes "mtrace -g foo 224.1.2.3 224.2.3.4" valid!... */
name|qgrp
operator|=
name|qsrc
expr_stmt|;
name|qsrc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|qdst
operator|=
name|host_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Dest of path */
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|qgrp
operator|=
name|host_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Path via group */
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qdst
argument_list|)
argument_list|)
condition|)
block|{
name|u_int32
name|temp
init|=
name|qdst
decl_stmt|;
name|qdst
operator|=
name|qgrp
expr_stmt|;
name|qgrp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qdst
argument_list|)
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qgrp
operator|&&
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qgrp
argument_list|)
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|passive
condition|)
block|{
name|passive_mode
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUNOS5
if|if
condition|(
name|sendopts
condition|)
name|checkforsolarisbug
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Set useful defaults for as many parameters as possible.      */
name|defgrp
operator|=
literal|0
expr_stmt|;
comment|/* Default to no group */
name|query_cast
operator|=
name|htonl
argument_list|(
literal|0xE0000002
argument_list|)
expr_stmt|;
comment|/* All routers multicast addr */
name|resp_cast
operator|=
name|htonl
argument_list|(
literal|0xE0000120
argument_list|)
expr_stmt|;
comment|/* Mtrace response multicast addr */
if|if
condition|(
name|qgrp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|weak
condition|)
name|qgrp
operator|=
name|defgrp
expr_stmt|;
if|if
condition|(
name|printstats
operator|&&
name|numstats
operator|!=
literal|0
operator|&&
operator|!
name|tunstats
condition|)
block|{
comment|/* Stats are useless without a group */
name|warnx
argument_list|(
literal|"WARNING: no multicast group specified, so no statistics printed"
argument_list|)
expr_stmt|;
name|numstats
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|weak
condition|)
name|warnx
argument_list|(
literal|"WARNING: group was specified so not performing \"weak\" mtrace"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Get default local address for multicasts to use in setting defaults.      */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|addr
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|qgrp
condition|?
name|qgrp
else|:
name|query_cast
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* Any port above 1024 will do */
comment|/*      * Note that getsockname() can return 0 on some systems      * (notably SunOS 5.x, x< 6).  This is taken care of in      * get_netmask().  If the default multicast interface (set      * with the route for 224.0.0.0) is not the same as the      * hostname, mtrace -i [if_addr] will have to be used.      */
if|if
condition|(
operator|(
operator|(
name|udp
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|connect
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|getsockname
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"determining local address"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNOS5
comment|/*      * SunOS 5.X prior to SunOS 2.6, getsockname returns 0 for udp socket.      * This call to sysinfo will return the hostname.      * If the default multicast interfface (set with the route      * for 224.0.0.0) is not the same as the hostname,      * mtrace -i [if_addr] will have to be used.      */
if|if
condition|(
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|char
name|myhostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysinfo
argument_list|(
name|SI_HOSTNAME
argument_list|,
name|myhostname
argument_list|,
sizeof|sizeof
argument_list|(
name|myhostname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"getting my hostname"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|myhostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|||
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
operator|||
name|hp
operator|->
name|h_length
operator|!=
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sin_addr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"finding IP address for my hostname"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Default destination for path to be queried is the local host.      * When gateway specified, default destination is that gateway      *  and default source is local host.      */
if|if
condition|(
name|qdst
operator|==
literal|0
condition|)
block|{
name|qdst
operator|=
name|lcl_addr
condition|?
name|lcl_addr
else|:
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|dst_netmask
operator|=
name|get_netmask
argument_list|(
name|udp
argument_list|,
operator|&
name|qdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|gwy
operator|&&
operator|(
name|gwy
operator|&
name|dst_netmask
operator|)
operator|!=
operator|(
name|qdst
operator|&
name|dst_netmask
operator|)
operator|&&
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gwy
argument_list|)
argument_list|)
condition|)
name|qdst
operator|=
name|gwy
expr_stmt|;
block|}
if|if
condition|(
name|qsrc
operator|==
literal|0
operator|&&
name|gwy
condition|)
name|qsrc
operator|=
name|lcl_addr
condition|?
name|lcl_addr
else|:
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|qsrc
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dst_netmask
condition|)
name|dst_netmask
operator|=
name|get_netmask
argument_list|(
name|udp
argument_list|,
operator|&
name|qdst
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|udp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcl_addr
operator|==
literal|0
condition|)
name|lcl_addr
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/*      * Initialize the seed for random query identifiers.      */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seed
operator|=
name|tv
operator|.
name|tv_usec
operator|^
name|lcl_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|srand48
argument_list|(
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Protect against unicast queries to mrouted versions that might crash.      * Also use the obsolete "can mtrace" neighbor bit to warn about      * older implementations.      */
if|if
condition|(
name|gwy
operator|&&
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gwy
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|send_recv
argument_list|(
name|gwy
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_ASK_NEIGHBORS2
argument_list|,
literal|1
argument_list|,
operator|&
name|incr
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|int
name|flags
init|=
name|ntohl
argument_list|(
name|incr
index|[
literal|0
index|]
operator|.
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
argument_list|)
decl_stmt|;
name|int
name|version
init|=
name|flags
operator|&
literal|0xFFFF
decl_stmt|;
name|int
name|info
init|=
operator|(
name|flags
operator|&
literal|0xFF0000
operator|)
operator|>>
literal|16
decl_stmt|;
if|if
condition|(
name|version
operator|==
literal|0x0303
operator|||
name|version
operator|==
literal|0x0503
condition|)
block|{
name|printf
argument_list|(
literal|"Don't use -g to address an mrouted 3.%d, it might crash\n"
argument_list|,
operator|(
name|version
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|info
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"mtrace: "
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|gwy
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" probably doesn't support mtrace, trying anyway...\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Mtrace from %s to %s via group %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qdst
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qgrp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qdst
operator|&
name|dst_netmask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|dst_netmask
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtrace: Source& receiver appear to be directly connected\n"
argument_list|)
expr_stmt|;
comment|/*      * If the response is to be a multicast address, make sure we       * are listening on that multicast address.      */
if|if
condition|(
name|raddr
condition|)
block|{
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|raddr
argument_list|)
argument_list|)
condition|)
name|k_join
argument_list|(
name|raddr
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|k_join
argument_list|(
name|resp_cast
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|base
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If the destination is on the local net, the last-hop router can      * be found by multicast to the all-routers multicast group.      * Otherwise, use the group address that is the subject of the      * query since by definition the last-hop router will be a member.      * Set default TTLs for local remote multicasts.      */
if|if
condition|(
name|gwy
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|qdst
operator|&
name|dst_netmask
operator|)
operator|==
operator|(
name|lcl_addr
operator|&
name|dst_netmask
operator|)
condition|)
name|tdst
operator|=
name|query_cast
expr_stmt|;
else|else
name|tdst
operator|=
name|qgrp
expr_stmt|;
else|else
name|tdst
operator|=
name|gwy
expr_stmt|;
if|if
condition|(
name|tdst
operator|==
literal|0
operator|&&
name|qgrp
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mtrace: weak mtrace requires -g if destination is not local.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|tdst
argument_list|)
argument_list|)
condition|)
block|{
name|k_set_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If I am running on a router, I need to hear this */
if|if
condition|(
name|tdst
operator|==
name|query_cast
condition|)
name|k_set_ttl
argument_list|(
name|qttl
condition|?
name|qttl
else|:
literal|1
argument_list|)
expr_stmt|;
else|else
name|k_set_ttl
argument_list|(
name|qttl
condition|?
name|qttl
else|:
name|MULTICAST_TTL1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Try a query at the requested number of hops or MAXHOPS if unspecified.      */
if|if
condition|(
name|qno
operator|==
literal|0
condition|)
block|{
name|hops
operator|=
name|MAXHOPS
expr_stmt|;
name|tries
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Querying full reverse path... "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hops
operator|=
name|qno
expr_stmt|;
name|tries
operator|=
name|nqueries
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
name|printf
argument_list|(
literal|"Querying full reverse path, starting at hop %d..."
argument_list|,
name|qno
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Querying reverse path, maximum %d hops... "
argument_list|,
name|qno
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|base
operator|.
name|rtime
operator|=
literal|0
expr_stmt|;
name|base
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|hopbyhop
operator|=
name|FALSE
expr_stmt|;
name|recvlen
operator|=
name|send_recv
argument_list|(
name|tdst
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|hops
argument_list|,
name|tries
argument_list|,
operator|&
name|base
argument_list|,
name|mtrace_callback
argument_list|)
expr_stmt|;
comment|/*      * If the initial query was successful, print it.  Otherwise, if      * the query max hop count is the default of zero, loop starting      * from one until there is no response for extrahops more hops.  The      * extra hops allow getting past an mtrace-capable mrouter that can't      * send multicast packets because all phyints are disabled.      */
if|if
condition|(
name|recvlen
condition|)
block|{
name|printf
argument_list|(
literal|"\n  0  "
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qdst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
literal|1
argument_list|,
operator|&
name|base
argument_list|,
name|names
argument_list|)
expr_stmt|;
name|r
operator|=
name|base
operator|.
name|resps
operator|+
name|base
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|==
name|TR_OLD_ROUTER
operator|||
name|r
operator|->
name|tr_rflags
operator|==
name|TR_NO_SPACE
operator|||
operator|(
name|qno
operator|!=
literal|0
operator|&&
name|r
operator|->
name|tr_rmtaddr
operator|!=
literal|0
operator|&&
operator|!
name|fflag
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|what_kind
argument_list|(
operator|&
name|base
argument_list|,
name|r
operator|->
name|tr_rflags
operator|==
name|TR_OLD_ROUTER
condition|?
literal|"doesn't support mtrace"
else|:
literal|"is the next hop"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fflag
condition|)
block|{
name|nexthop
operator|=
name|hops
operator|=
name|qno
expr_stmt|;
goto|goto
name|continuehop
goto|;
block|}
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qsrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|qno
operator|==
literal|0
condition|)
block|{
name|hopbyhop
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"switching to hop-by-hop:\n  0  "
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qdst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hops
operator|=
literal|1
operator|,
name|nexthop
operator|=
literal|1
init|;
name|hops
operator|<=
name|MAXHOPS
condition|;
operator|++
name|hops
control|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
name|hops
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* 	     * After a successful first hop, try switching to the unicast 	     * address of the last-hop router instead of multicasting the 	     * trace query.  This should be safe for mrouted versions 3.3 	     * and 3.5 because there is a long route timeout with metric 	     * infinity before a route disappears.  Switching to unicast 	     * reduces the amount of multicast traffic and avoids a bug 	     * with duplicate suppression in mrouted 3.5. 	     */
if|if
condition|(
name|hops
operator|==
literal|2
operator|&&
name|gwy
operator|==
literal|0
operator|&&
name|lastout
operator|!=
literal|0
operator|&&
operator|(
name|recvlen
operator|=
name|send_recv
argument_list|(
name|lastout
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|hops
argument_list|,
literal|1
argument_list|,
operator|&
name|base
argument_list|,
name|mtrace_callback
argument_list|)
operator|)
condition|)
name|tdst
operator|=
name|lastout
expr_stmt|;
else|else
name|recvlen
operator|=
name|send_recv
argument_list|(
name|tdst
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|hops
argument_list|,
name|nqueries
argument_list|,
operator|&
name|base
argument_list|,
name|mtrace_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
operator|==
literal|0
condition|)
block|{
comment|/*if (hops == 1) break;*/
if|if
condition|(
name|hops
operator|==
name|nexthop
condition|)
block|{
if|if
condition|(
name|hops
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what_kind
argument_list|(
operator|&
name|base
argument_list|,
literal|"didn't respond"
argument_list|)
condition|)
block|{
comment|/* the ask_neighbors determined that the 			 * not-responding router is the first-hop. */
break|break;
block|}
if|if
condition|(
name|extrahops
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|hops
operator|<
name|nexthop
operator|+
name|extrahops
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"...giving up\n"
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|base
operator|.
name|len
operator|==
name|hops
operator|&&
operator|(
name|hops
operator|==
literal|1
operator|||
operator|(
name|base
operator|.
name|resps
operator|+
name|nexthop
operator|-
literal|2
operator|)
operator|->
name|tr_outaddr
operator|==
name|lastout
operator|)
condition|)
block|{
if|if
condition|(
name|hops
operator|==
name|nexthop
condition|)
block|{
name|print_trace
argument_list|(
operator|-
name|hops
argument_list|,
operator|&
name|base
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nResuming...\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
name|nexthop
argument_list|,
operator|&
name|base
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|base
operator|.
name|len
operator|<
name|hops
condition|)
block|{
comment|/* 		     * A shorter trace than requested means a fatal error 		     * occurred along the path, or that the route changed 		     * to a shorter one. 		     * 		     * If the trace is longer than the last one we received, 		     * then we are resuming from a skipped router (but there 		     * is still probably a problem). 		     * 		     * If the trace is shorter than the last one we 		     * received, then the route must have changed (and 		     * there is still probably a problem). 		     */
if|if
condition|(
name|nexthop
operator|<=
name|base
operator|.
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"\nResuming...\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
name|nexthop
argument_list|,
operator|&
name|base
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nexthop
operator|>
name|base
operator|.
name|len
operator|+
literal|1
condition|)
block|{
name|hops
operator|=
name|base
operator|.
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"\nRoute must have changed...\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
literal|1
argument_list|,
operator|&
name|base
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * The last hop address is not the same as it was. 		     * If we didn't know the last hop then we just 		     * got the first response from a hop-by-hop trace; 		     * if we did know the last hop then 		     * the route probably changed underneath us. 		     */
name|hops
operator|=
name|base
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|lastout
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\nRoute must have changed...\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\nResuming...\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
literal|1
argument_list|,
operator|&
name|base
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
block|}
name|continuehop
label|:
name|r
operator|=
name|base
operator|.
name|resps
operator|+
name|base
operator|.
name|len
operator|-
literal|1
expr_stmt|;
name|lastout
operator|=
name|r
operator|->
name|tr_outaddr
expr_stmt|;
if|if
condition|(
name|base
operator|.
name|len
operator|<
name|hops
operator|||
name|r
operator|->
name|tr_rmtaddr
operator|==
literal|0
operator|||
operator|(
name|r
operator|->
name|tr_rflags
operator|&
literal|0x80
operator|)
condition|)
block|{
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tr_rmtaddr
condition|)
block|{
if|if
condition|(
name|hops
operator|!=
name|nexthop
condition|)
block|{
name|printf
argument_list|(
literal|"\n%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|what_kind
argument_list|(
operator|&
name|base
argument_list|,
name|r
operator|->
name|tr_rflags
operator|==
name|TR_OLD_ROUTER
condition|?
literal|"doesn't support mtrace"
else|:
literal|"would be the next hop"
argument_list|)
expr_stmt|;
comment|/* XXX could do segmented trace if TR_NO_SPACE */
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|==
name|TR_NO_ERR
operator|&&
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|hops
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qsrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|nexthop
operator|=
name|hops
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base
operator|.
name|rtime
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timed out receiving responses\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|tdst
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|tdst
operator|==
name|query_cast
condition|)
name|printf
argument_list|(
literal|"Perhaps no local router has a route for source %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Perhaps receiver %s is not a member of group %s,\n\ or no router local to it has a route for source %s,\n\ or multicast at ttl %d doesn't reach its last-hop router for that source\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qdst
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qgrp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|,
name|qttl
condition|?
name|qttl
else|:
name|MULTICAST_TTL1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Round trip time %d ms; "
argument_list|,
name|t_diff
argument_list|(
name|base
operator|.
name|rtime
argument_list|,
name|base
operator|.
name|qtime
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|base
operator|.
name|resps
operator|+
name|base
operator|.
name|len
operator|-
literal|1
decl_stmt|;
name|u_int
name|ttl
init|=
name|n
operator|->
name|tr_fttl
operator|+
literal|1
decl_stmt|;
name|rno
operator|=
name|base
operator|.
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|ttl
operator|=
name|MaX
argument_list|(
name|ttl
argument_list|,
name|MaX
argument_list|(
literal|1
argument_list|,
name|n
operator|->
name|tr_fttl
argument_list|)
operator|+
name|base
operator|.
name|len
operator|-
name|rno
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"total ttl of %d required.\n\n"
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
comment|/*      * Use the saved response which was the longest one received,      * and make additional probes after delay to measure loss.      */
name|raddr
operator|=
name|base
operator|.
name|qhdr
operator|.
name|tr_raddr
expr_stmt|;
name|rttl
operator|=
name|TR_GETTTL
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_rttlqid
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waittime
operator|=
name|statint
operator|-
operator|(
operator|(
operator|(
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|&
literal|0xFFFF
operator|)
operator|-
operator|(
name|base
operator|.
name|qtime
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|prev
operator|=
operator|&
name|base
expr_stmt|;
name|new
operator|=
operator|&
name|incr
index|[
name|numstats
operator|&
literal|1
index|]
expr_stmt|;
comment|/*      * Zero out bug-avoidance counters      */
name|memset
argument_list|(
name|bugs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bugs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|printstats
condition|)
name|printf
argument_list|(
literal|"Monitoring path.."
argument_list|)
expr_stmt|;
while|while
condition|(
name|numstats
operator|--
condition|)
block|{
if|if
condition|(
name|waittime
operator|<
literal|1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|printstats
operator|&&
operator|(
name|lossthresh
operator|==
literal|0
operator|||
name|printed
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Waiting to accumulate statistics..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
name|waittime
argument_list|)
expr_stmt|;
block|}
name|printed
operator|=
literal|0
expr_stmt|;
name|rno
operator|=
name|hopbyhop
condition|?
name|base
operator|.
name|len
else|:
name|qno
condition|?
name|qno
else|:
name|MAXHOPS
expr_stmt|;
name|recvlen
operator|=
name|send_recv
argument_list|(
name|tdst
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|rno
argument_list|,
name|nqueries
argument_list|,
name|new
argument_list|,
name|mtrace_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numstats
condition|)
block|{
name|numstats
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|.
name|len
operator|!=
name|new
operator|->
name|len
operator|||
name|path_changed
argument_list|(
operator|&
name|base
argument_list|,
name|new
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|base
operator|.
name|len
operator|==
name|new
operator|->
name|len
condition|?
literal|"Route changed"
else|:
literal|"Trace length doesn't match"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|printstats
condition|)
name|printf
argument_list|(
literal|" after %d seconds"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|new
operator|->
name|qtime
operator|-
name|base
operator|.
name|qtime
operator|)
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|printandcontinue
label|:
name|print_trace
argument_list|(
literal|1
argument_list|,
name|new
argument_list|,
name|names
argument_list|)
expr_stmt|;
name|numstats
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|new
argument_list|,
operator|&
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|nexthop
operator|=
name|hops
operator|=
name|new
operator|->
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"Continuing with hop-by-hop...\n"
argument_list|)
expr_stmt|;
goto|goto
name|continuehop
goto|;
block|}
if|if
condition|(
name|printstats
condition|)
block|{
if|if
condition|(
name|new
operator|->
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
operator|!=
name|qgrp
operator|||
name|new
operator|->
name|qhdr
operator|.
name|tr_src
operator|!=
name|qsrc
operator|||
name|new
operator|->
name|qhdr
operator|.
name|tr_dst
operator|!=
name|qdst
condition|)
name|printf
argument_list|(
literal|"\nWARNING: trace modified en route; statistics may be incorrect\n"
argument_list|)
expr_stmt|;
name|fixup_stats
argument_list|(
operator|&
name|base
argument_list|,
name|prev
argument_list|,
name|new
argument_list|,
name|bugs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lossthresh
operator|==
literal|0
operator|)
operator|||
name|check_thresh
argument_list|(
name|lossthresh
argument_list|,
operator|&
name|base
argument_list|,
name|prev
argument_list|,
name|new
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Results after %d seconds"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|new
operator|->
name|qtime
operator|-
name|base
operator|.
name|qtime
operator|)
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lossthresh
condition|)
name|printf
argument_list|(
literal|" (this trace %d seconds)"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|new
operator|->
name|qtime
operator|-
name|prev
operator|->
name|qtime
operator|)
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|time_t
name|t
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|qr
init|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|" qid 0x%06x at %2d:%02d:%02d"
argument_list|,
name|TR_GETQID
argument_list|(
name|base
operator|.
name|qhdr
operator|.
name|tr_rttlqid
argument_list|)
argument_list|,
name|qr
operator|->
name|tm_hour
argument_list|,
name|qr
operator|->
name|tm_min
argument_list|,
name|qr
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|":\n\n"
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|print_stats
argument_list|(
operator|&
name|base
argument_list|,
name|prev
argument_list|,
name|new
argument_list|,
name|bugs
argument_list|,
name|names
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"This should have been detected earlier, but "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Route changed:\n"
argument_list|)
expr_stmt|;
goto|goto
name|printandcontinue
goto|;
block|}
block|}
block|}
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|=
operator|&
name|incr
index|[
name|numstats
operator|&
literal|1
index|]
expr_stmt|;
name|waittime
operator|=
name|statint
expr_stmt|;
block|}
comment|/*      * If the response was multicast back, leave the group      */
if|if
condition|(
name|raddr
condition|)
block|{
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|raddr
argument_list|)
argument_list|)
condition|)
name|k_leave
argument_list|(
name|raddr
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|k_leave
argument_list|(
name|resp_cast
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n"
argument_list|,
literal|"usage: mtrace [-MUOPTWVlnpvs] [-e extra_hops] [-f first_hop] [-i if_addr]"
argument_list|,
literal|"              [-g gateway] [-m max_hops] [-q nqueries] [-r resp_dest]"
argument_list|,
literal|"              [-S statint] [-t ttl] [-w wait] source [receiver] [group]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"sendto"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log errors and other messages to stderr, according to the severity  * of the message and the current debug level.  For errors of severity  * LOG_ERR or worse, terminate the program.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|void
name|log
parameter_list|(
name|int
name|severity
parameter_list|,
name|int
name|syserr
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|fmt
index|[
literal|100
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*VARARGS3*/
name|void
name|log
parameter_list|(
name|severity
parameter_list|,
name|syserr
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|severity
decl_stmt|,
name|syserr
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|fmt
index|[
literal|100
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|debug
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|severity
operator|>
name|LOG_WARNING
condition|)
return|return;
case|case
literal|1
case|:
if|if
condition|(
name|severity
operator|>
name|LOG_NOTICE
condition|)
return|return;
case|case
literal|2
case|:
if|if
condition|(
name|severity
operator|>
name|LOG_INFO
condition|)
return|return;
default|default:
name|fmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|severity
operator|==
name|LOG_WARNING
condition|)
name|strcpy
argument_list|(
name|fmt
argument_list|,
literal|"warning - "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|fmt
argument_list|,
name|format
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|-
name|strlen
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
index|[
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|syserr
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syserr
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|sys_errlist
index|[
name|syserr
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": errno %d\n"
argument_list|,
name|syserr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|severity
operator|<=
name|LOG_ERR
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

