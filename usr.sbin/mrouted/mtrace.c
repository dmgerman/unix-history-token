begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * mtrace.c  *  * This tool traces the branch of a multicast tree from a source to a  * receiver for a particular multicast group and gives statistics  * about packet rate and loss for each hop along the path.  It can  * usually be invoked just as  *  * 	mtrace source  *  * to trace the route from that source to the local host for a default  * group when only the route is desired and not group-specific packet  * counts.  See the usage line for more complex forms.  *  *  * Released 4 Apr 1995.  This program was adapted by Steve Casner  * (USC/ISI) from a prototype written by Ajit Thyagarajan (UDel and  * Xerox PARC).  It attempts to parallel in command syntax and output  * format the unicast traceroute program written by Van Jacobson (LBL)  * for the parts where that makes sense.  *   * Copyright (c) 1995 by the University of Southern California  * All rights reserved.  *  * Permission to use, copy, modify, and distribute this software and its  * documentation in source and binary forms for non-commercial purposes  * and without fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both the copyright notice and  * this permission notice appear in supporting documentation, and that  * any documentation, advertising materials, and other materials related  * to such distribution and use acknowledge that the software was  * developed by the University of Southern California, Information  * Sciences Institute.  The name of the University may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  *  * THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about  * the suitability of this software for any purpose.  THIS SOFTWARE IS  * PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Other copyrights might apply to parts of this software and are so  * noted when applicable.  *  * In particular, parts of the prototype version of this program may  * have been derived from mrouted programs sources covered by the  * license in the accompanying file named "LICENSE".  *  * $Id: mtrace.c,v 3.5 1995/05/09 01:24:19 fenner Exp $  */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_define
define|#
directive|define
name|DEFAULT_TIMEOUT
value|3
end_define

begin_comment
comment|/* How long to wait before retrying requests */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_RETRIES
value|3
end_define

begin_comment
comment|/* How many times to try */
end_comment

begin_define
define|#
directive|define
name|MAXHOPS
value|UNREACHABLE
end_define

begin_comment
comment|/* Don't need more hops than max metric */
end_comment

begin_define
define|#
directive|define
name|UNICAST_TTL
value|255
end_define

begin_comment
comment|/* TTL for unicast response */
end_comment

begin_define
define|#
directive|define
name|MULTICAST_TTL1
value|64
end_define

begin_comment
comment|/* Default TTL for multicast query/response */
end_comment

begin_define
define|#
directive|define
name|MULTICAST_TTL_INC
value|32
end_define

begin_comment
comment|/* TTL increment for increase after timeout */
end_comment

begin_define
define|#
directive|define
name|MULTICAST_TTL_MAX
value|192
end_define

begin_comment
comment|/* Maximum TTL allowed (protect low-BW links */
end_comment

begin_struct
struct|struct
name|resp_buf
block|{
name|u_long
name|qtime
decl_stmt|;
comment|/* Time query was issued */
name|u_long
name|rtime
decl_stmt|;
comment|/* Time response was received */
name|int
name|len
decl_stmt|;
comment|/* Number of reports or length of data */
name|struct
name|igmp
name|igmp
decl_stmt|;
comment|/* IGMP header */
union|union
block|{
struct|struct
block|{
name|struct
name|tr_query
name|q
decl_stmt|;
comment|/* Query/response header */
name|struct
name|tr_resp
name|r
index|[
name|MAXHOPS
index|]
decl_stmt|;
comment|/* Per-hop reports */
block|}
name|t
struct|;
name|char
name|d
index|[
name|MAX_DVMRP_DATA_LEN
index|]
decl_stmt|;
comment|/* Neighbor data */
block|}
name|u
union|;
block|}
name|base
struct|,
name|incr
index|[
literal|2
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|qhdr
value|u.t.q
end_define

begin_define
define|#
directive|define
name|resps
value|u.t.r
end_define

begin_define
define|#
directive|define
name|ndata
value|u.d
end_define

begin_decl_stmt
name|char
name|names
index|[
name|MAXHOPS
index|]
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeout
init|=
name|DEFAULT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nqueries
init|=
name|DEFAULT_RETRIES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numeric
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|passive
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|multicast
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|defgrp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default group if not specified */
end_comment

begin_decl_stmt
name|u_int32
name|query_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All routers multicast addr */
end_comment

begin_decl_stmt
name|u_int32
name|resp_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mtrace response multicast addr */
end_comment

begin_decl_stmt
name|u_int32
name|lcl_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This host address, in NET order */
end_comment

begin_decl_stmt
name|u_int32
name|dst_netmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* netmask to go with qdst */
end_comment

begin_comment
comment|/*  * Query/response parameters, all initialized to zero and set later  * to default values or from options.  */
end_comment

begin_decl_stmt
name|u_int32
name|qsrc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|qgrp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|qdst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|qno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|raddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qttl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|rttl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|gwy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to keep loader happy */
end_comment

begin_comment
comment|/* (see kern.c) */
end_comment

begin_function_decl
specifier|extern
name|void
name|k_join
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|k_leave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|k_set_ttl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV
end_ifndef

begin_function_decl
specifier|extern
name|long
name|random
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|inet_name
parameter_list|(
name|addr
parameter_list|)
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
return|return
name|e
condition|?
name|e
operator|->
name|h_name
else|:
literal|"?"
return|;
block|}
end_function

begin_function
name|u_int32
name|host_addr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|e
init|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dots
init|=
literal|3
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|ip
init|=
name|name
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|e
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|h_length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 	 * Undo BSD's favor -- take fewer than 4 octets as net/subnet address. 	 */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|7
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|*
name|ip
operator|==
literal|'.'
condition|)
operator|--
name|dots
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dots
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
operator|*
name|op
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|inet_addr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Could not parse %s as host name or address\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|proto_type
parameter_list|(
name|type
parameter_list|)
name|u_char
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PROTO_DVMRP
case|:
return|return
operator|(
literal|"DVMRP"
operator|)
return|;
case|case
name|PROTO_MOSPF
case|:
return|return
operator|(
literal|"MOSPF"
operator|)
return|;
case|case
name|PROTO_PIM
case|:
return|return
operator|(
literal|"PIM"
operator|)
return|;
case|case
name|PROTO_CBT
case|:
return|return
operator|(
literal|"CBT"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown protocol code %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|flag_type
parameter_list|(
name|type
parameter_list|)
name|u_char
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TR_NO_ERR
case|:
return|return
operator|(
literal|""
operator|)
return|;
case|case
name|TR_WRONG_IF
case|:
return|return
operator|(
literal|"Wrong interface"
operator|)
return|;
case|case
name|TR_PRUNED
case|:
return|return
operator|(
literal|"Prune sent upstream"
operator|)
return|;
case|case
name|TR_OPRUNED
case|:
return|return
operator|(
literal|"Output pruned"
operator|)
return|;
case|case
name|TR_SCOPED
case|:
return|return
operator|(
literal|"Hit scope boundary"
operator|)
return|;
case|case
name|TR_NO_RTE
case|:
return|return
operator|(
literal|"No route"
operator|)
return|;
case|case
name|TR_OLD_ROUTER
case|:
return|return
operator|(
literal|"Next router no mtrace"
operator|)
return|;
case|case
name|TR_NO_FWD
case|:
return|return
operator|(
literal|"Not forwarding"
operator|)
return|;
case|case
name|TR_NO_SPACE
case|:
return|return
operator|(
literal|"No space in packet"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown error code %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * If destination is on a local net, get the netmask, else set the  * netmask to all ones.  There are two side effects: if the local  * address was not explicitly set, and if the destination is on a  * local net, use that one; in either case, verify that the local  * address is valid.  */
end_comment

begin_function
name|u_int32
name|get_netmask
parameter_list|(
name|s
parameter_list|,
name|dst
parameter_list|)
name|int
name|s
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|ifbuf
index|[
literal|5000
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|u_int32
name|if_addr
decl_stmt|,
name|if_mask
decl_stmt|;
name|u_int32
name|retval
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|int
name|found
init|=
name|FALSE
decl_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|ifbuf
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|ifbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (SIOCGIFCONF)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|i
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|ifr
operator|++
control|)
block|{
name|if_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ifr
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|if_mask
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|->
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
name|if_mask
operator|)
operator|==
operator|(
name|if_addr
operator|&
name|if_mask
operator|)
condition|)
block|{
name|retval
operator|=
name|if_mask
expr_stmt|;
if|if
condition|(
name|lcl_addr
operator|==
literal|0
condition|)
name|lcl_addr
operator|=
name|if_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lcl_addr
operator|==
name|if_addr
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|lcl_addr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Interface address is not valid\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|get_ttl
parameter_list|(
name|buf
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|rno
expr_stmt|;
specifier|register
name|struct
name|tr_resp
modifier|*
name|b
decl_stmt|;
specifier|register
name|ttl
expr_stmt|;
if|if
condition|(
name|buf
operator|&&
operator|(
name|rno
operator|=
name|buf
operator|->
name|len
operator|)
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|buf
operator|->
name|resps
operator|+
name|rno
operator|-
literal|1
expr_stmt|;
name|ttl
operator|=
name|b
operator|->
name|tr_fttl
expr_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>
literal|0
condition|)
block|{
operator|--
name|b
expr_stmt|;
if|if
condition|(
name|ttl
operator|<
name|b
operator|->
name|tr_fttl
condition|)
name|ttl
operator|=
name|b
operator|->
name|tr_fttl
expr_stmt|;
else|else
operator|++
name|ttl
expr_stmt|;
block|}
name|ttl
operator|+=
name|MULTICAST_TTL_INC
expr_stmt|;
if|if
condition|(
name|ttl
operator|<
name|MULTICAST_TTL1
condition|)
name|ttl
operator|=
name|MULTICAST_TTL1
expr_stmt|;
if|if
condition|(
name|ttl
operator|>
name|MULTICAST_TTL_MAX
condition|)
name|ttl
operator|=
name|MULTICAST_TTL_MAX
expr_stmt|;
return|return
operator|(
name|ttl
operator|)
return|;
block|}
else|else
return|return
operator|(
name|MULTICAST_TTL1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the difference between two 32-bit NTP timestamps and return  * the result in milliseconds.  */
end_comment

begin_function
name|int
name|t_diff
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|u_long
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|d
init|=
name|a
operator|-
name|b
decl_stmt|;
return|return
operator|(
operator|(
name|d
operator|*
literal|125
operator|)
operator|>>
literal|13
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fixup for incorrect time format in 3.3 mrouted.  * This is possible because (JAN_1970 mod 64K) is quite close to 32K,  * so correct and incorrect times will be far apart.  */
end_comment

begin_function
name|u_long
name|fixtime
parameter_list|(
name|time
parameter_list|)
name|u_long
name|time
decl_stmt|;
block|{
if|if
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|time
operator|-
name|base
operator|.
name|qtime
argument_list|)
argument_list|)
operator|>
literal|0x3FFFFFFF
condition|)
name|time
operator|=
operator|(
operator|(
name|time
operator|&
literal|0xFFFF0000
operator|)
operator|+
operator|(
name|JAN_1970
operator|<<
literal|16
operator|)
operator|)
operator|+
operator|(
operator|(
name|time
operator|&
literal|0xFFFF
operator|)
operator|<<
literal|14
operator|)
operator|/
literal|15625
expr_stmt|;
return|return
operator|(
name|time
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_recv
parameter_list|(
name|dst
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|,
name|tries
parameter_list|,
name|save
parameter_list|)
name|u_int32
name|dst
decl_stmt|;
name|int
name|type
decl_stmt|,
name|code
decl_stmt|,
name|tries
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|save
decl_stmt|;
block|{
name|fd_set
name|fds
decl_stmt|;
name|struct
name|timeval
name|tq
decl_stmt|,
name|tr
decl_stmt|,
name|tv
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|igmp
modifier|*
name|igmp
decl_stmt|;
name|struct
name|tr_query
modifier|*
name|query
decl_stmt|,
modifier|*
name|rquery
decl_stmt|;
name|int
name|ipdatalen
decl_stmt|,
name|iphdrlen
decl_stmt|,
name|igmpdatalen
decl_stmt|;
name|u_int32
name|local
decl_stmt|,
name|group
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|count
decl_stmt|,
name|recvlen
decl_stmt|,
name|dummy
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|IGMP_MTRACE
condition|)
block|{
name|group
operator|=
name|qgrp
expr_stmt|;
name|datalen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tr_query
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|group
operator|=
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|local
operator|=
name|lcl_addr
expr_stmt|;
else|else
name|local
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/*      * If the reply address was not explictly specified, start off      * with the unicast address of this host.  Then, if there is no      * response after trying half the tries with unicast, switch to      * the standard multicast reply address.  If the TTL was also not      * specified, set a multicast TTL and if needed increase it for the      * last quarter of the tries.      */
name|query
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|query
operator|->
name|tr_raddr
operator|=
name|raddr
condition|?
name|raddr
else|:
name|multicast
condition|?
name|resp_cast
else|:
name|lcl_addr
expr_stmt|;
name|query
operator|->
name|tr_rttl
operator|=
name|rttl
condition|?
name|rttl
else|:
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|query
operator|->
name|tr_raddr
argument_list|)
argument_list|)
condition|?
name|get_ttl
argument_list|(
name|save
argument_list|)
else|:
name|UNICAST_TTL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tries
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|tries
operator|==
name|nqueries
operator|&&
name|raddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
operator|(
name|nqueries
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|query
operator|->
name|tr_raddr
operator|=
name|resp_cast
expr_stmt|;
if|if
condition|(
name|rttl
operator|==
literal|0
condition|)
name|query
operator|->
name|tr_rttl
operator|=
name|get_ttl
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
operator|(
operator|(
name|nqueries
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|&&
name|rttl
operator|==
literal|0
condition|)
block|{
name|query
operator|->
name|tr_rttl
operator|+=
name|MULTICAST_TTL_INC
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|tr_rttl
operator|>
name|MULTICAST_TTL_MAX
condition|)
name|query
operator|->
name|tr_rttl
operator|=
name|MULTICAST_TTL_MAX
expr_stmt|;
block|}
block|}
comment|/* 	 * Change the qid for each request sent to avoid being confused 	 * by duplicate responses 	 */
ifdef|#
directive|ifdef
name|SYSV
name|query
operator|->
name|tr_qid
operator|=
operator|(
operator|(
name|u_int32
operator|)
name|lrand48
argument_list|()
operator|>>
literal|8
operator|)
expr_stmt|;
else|#
directive|else
name|query
operator|->
name|tr_qid
operator|=
operator|(
operator|(
name|u_int32
operator|)
name|random
argument_list|()
operator|>>
literal|8
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set timer to calculate delays, then send query 	 */
name|gettimeofday
argument_list|(
operator|&
name|tq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|local
argument_list|,
name|dst
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for response, discarding false alarms 	 */
while|while
condition|(
name|TRUE
condition|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|igmp_socket
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|tq
operator|.
name|tv_sec
operator|+
name|timeout
operator|-
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|tq
operator|.
name|tv_usec
operator|-
name|tv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|tv
operator|.
name|tv_usec
operator|+=
literal|1000000L
operator|,
operator|--
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|select
argument_list|(
name|igmp_socket
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"* "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
name|gettimeofday
argument_list|(
operator|&
name|tr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recvlen
operator|=
name|recvfrom
argument_list|(
name|igmp_socket
argument_list|,
name|recv_buf
argument_list|,
name|RECV_BUF_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|recvlen
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|perror
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|recvlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"packet too short (%u bytes) for IP header"
argument_list|,
name|recvlen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|recv_buf
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
literal|0
condition|)
comment|/* ignore cache creation requests */
continue|continue;
name|iphdrlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipdatalen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
if|if
condition|(
name|iphdrlen
operator|+
name|ipdatalen
operator|!=
name|recvlen
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"packet shorter (%u bytes) than hdr+data len (%u+%u)\n"
argument_list|,
name|recvlen
argument_list|,
name|iphdrlen
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|igmp
operator|=
operator|(
expr|struct
name|igmp
operator|*
operator|)
operator|(
name|recv_buf
operator|+
name|iphdrlen
operator|)
expr_stmt|;
name|igmpdatalen
operator|=
name|ipdatalen
operator|-
name|IGMP_MINLEN
expr_stmt|;
if|if
condition|(
name|igmpdatalen
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IP data field too short (%u bytes) for IGMP from %s\n"
argument_list|,
name|ipdatalen
argument_list|,
name|inet_fmt
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|igmp
operator|->
name|igmp_type
condition|)
block|{
case|case
name|IGMP_DVMRP
case|:
if|if
condition|(
name|igmp
operator|->
name|igmp_code
operator|!=
name|DVMRP_NEIGHBORS2
condition|)
continue|continue;
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|dst
condition|)
continue|continue;
name|len
operator|=
name|igmpdatalen
expr_stmt|;
break|break;
case|case
name|IGMP_MTRACE
case|:
comment|/* For backward compatibility with 3.3 */
case|case
name|IGMP_MTRACE_RESP
case|:
if|if
condition|(
name|igmpdatalen
operator|<=
name|QLEN
condition|)
continue|continue;
if|if
condition|(
operator|(
name|igmpdatalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
condition|)
block|{
name|printf
argument_list|(
literal|"packet with incorrect datalen\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ignore responses that don't match query. 		 */
name|rquery
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
operator|(
name|igmp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rquery
operator|->
name|tr_qid
operator|!=
name|query
operator|->
name|tr_qid
condition|)
continue|continue;
if|if
condition|(
name|rquery
operator|->
name|tr_src
operator|!=
name|qsrc
condition|)
continue|continue;
if|if
condition|(
name|rquery
operator|->
name|tr_dst
operator|!=
name|qdst
condition|)
continue|continue;
name|len
operator|=
operator|(
name|igmpdatalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
expr_stmt|;
comment|/* 		 * Ignore trace queries passing through this node when 		 * mtrace is run on an mrouter that is in the path 		 * (needed only because IGMP_MTRACE is accepted above 		 * for backward compatibility with multicast release 3.3). 		 */
if|if
condition|(
name|igmp
operator|->
name|igmp_type
operator|==
name|IGMP_MTRACE
condition|)
block|{
name|struct
name|tr_resp
modifier|*
name|r
init|=
operator|(
expr|struct
name|tr_resp
operator|*
operator|)
operator|(
name|rquery
operator|+
literal|1
operator|)
operator|+
name|len
operator|-
literal|1
decl_stmt|;
name|u_int32
name|smask
decl_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|code
operator|&&
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|!=
operator|(
name|qsrc
operator|&
name|smask
operator|)
operator|&&
name|r
operator|->
name|tr_rmtaddr
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|r
operator|->
name|tr_rflags
operator|&
literal|0x80
operator|)
condition|)
continue|continue;
block|}
comment|/* 		 * A match, we'll keep this one. 		 */
if|if
condition|(
name|len
operator|>
name|code
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Num hops received (%d) exceeds request (%d)\n"
argument_list|,
name|len
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|rquery
operator|->
name|tr_raddr
operator|=
name|query
operator|->
name|tr_raddr
expr_stmt|;
comment|/* Insure these are */
name|rquery
operator|->
name|tr_rttl
operator|=
name|query
operator|->
name|tr_rttl
expr_stmt|;
comment|/* as we sent them */
break|break;
default|default:
continue|continue;
block|}
comment|/* 	     * Most of the sanity checking done at this point. 	     * Return this packet we have been waiting for. 	     */
if|if
condition|(
name|save
condition|)
block|{
name|save
operator|->
name|qtime
operator|=
operator|(
operator|(
name|tq
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|tq
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
expr_stmt|;
name|save
operator|->
name|rtime
operator|=
operator|(
operator|(
name|tr
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|tr
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
expr_stmt|;
name|save
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|igmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|save
operator|->
name|igmp
argument_list|,
name|ipdatalen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|recvlen
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|print_host
parameter_list|(
name|addr
parameter_list|)
name|u_int32
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|numeric
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
name|name
operator|=
name|inet_name
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s (%s)"
argument_list|,
name|name
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print responses as received (reverse path from dst to src)  */
end_comment

begin_function
name|void
name|print_trace
parameter_list|(
name|index
parameter_list|,
name|buf
parameter_list|)
name|int
name|index
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|abs
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|r
operator|=
name|buf
operator|->
name|resps
operator|+
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|buf
operator|->
name|len
condition|;
operator|++
name|i
operator|,
operator|++
name|r
control|)
block|{
if|if
condition|(
name|index
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|name
operator|=
name|print_host
argument_list|(
name|r
operator|->
name|tr_outaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s  thresh^ %d  %d ms  %s\n"
argument_list|,
name|proto_type
argument_list|(
name|r
operator|->
name|tr_rproto
argument_list|)
argument_list|,
name|r
operator|->
name|tr_fttl
argument_list|,
name|t_diff
argument_list|(
name|fixtime
argument_list|(
name|ntohl
argument_list|(
name|r
operator|->
name|tr_qarr
argument_list|)
argument_list|)
argument_list|,
name|buf
operator|->
name|qtime
argument_list|)
argument_list|,
name|flag_type
argument_list|(
name|r
operator|->
name|tr_rflags
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|names
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|names
index|[
name|i
operator|-
literal|1
index|]
index|[
sizeof|sizeof
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * See what kind of router is the next hop  */
end_comment

begin_function
name|void
name|what_kind
parameter_list|(
name|buf
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|buf
decl_stmt|;
block|{
name|u_int32
name|smask
decl_stmt|;
name|int
name|recvlen
decl_stmt|;
name|int
name|hops
init|=
name|buf
operator|->
name|len
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
init|=
name|buf
operator|->
name|resps
operator|+
name|hops
operator|-
literal|1
decl_stmt|;
name|u_int32
name|next
init|=
name|r
operator|->
name|tr_rmtaddr
decl_stmt|;
name|recvlen
operator|=
name|send_recv
argument_list|(
name|next
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_ASK_NEIGHBORS2
argument_list|,
literal|1
argument_list|,
operator|&
name|incr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
condition|)
block|{
name|u_int32
name|version
init|=
name|ntohl
argument_list|(
name|incr
index|[
literal|0
index|]
operator|.
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
argument_list|)
decl_stmt|;
name|u_int32
modifier|*
name|p
init|=
operator|(
name|u_int32
operator|*
operator|)
name|incr
index|[
literal|0
index|]
operator|.
name|ndata
decl_stmt|;
name|u_int32
modifier|*
name|ep
init|=
name|p
operator|+
operator|(
name|incr
index|[
literal|0
index|]
operator|.
name|len
operator|>>
literal|2
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|" [%s%d.%d] didn't respond\n"
argument_list|,
operator|(
name|version
operator|==
literal|1
operator|)
condition|?
literal|"proteon/mrouted "
else|:
operator|(
operator|(
name|version
operator|&
literal|0xff
operator|)
operator|==
literal|2
operator|)
condition|?
literal|"mrouted "
else|:
operator|(
operator|(
name|version
operator|&
literal|0xff
operator|)
operator|==
literal|3
operator|)
condition|?
literal|"mrouted "
else|:
operator|(
operator|(
name|version
operator|&
literal|0xff
operator|)
operator|==
literal|4
operator|)
condition|?
literal|"mrouted "
else|:
operator|(
operator|(
name|version
operator|&
literal|0xff
operator|)
operator|==
literal|10
operator|)
condition|?
literal|"cisco "
else|:
literal|""
argument_list|,
name|version
operator|&
literal|0xff
argument_list|,
operator|(
name|version
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|ep
condition|)
block|{
specifier|register
name|u_int32
name|laddr
init|=
operator|*
name|p
operator|++
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|ntohl
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
operator|(
name|laddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|hops
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qsrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|n
expr_stmt|;
block|}
return|return;
block|}
name|printf
argument_list|(
literal|" didn't respond\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|scale
parameter_list|(
name|hop
parameter_list|)
name|int
modifier|*
name|hop
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|hop
operator|>
operator|-
literal|1000
operator|&&
operator|*
name|hop
operator|<
literal|10000
condition|)
return|return
operator|(
literal|" ms"
operator|)
return|;
operator|*
name|hop
operator|/=
literal|1000
expr_stmt|;
if|if
condition|(
operator|*
name|hop
operator|>
operator|-
literal|1000
operator|&&
operator|*
name|hop
operator|<
literal|10000
condition|)
return|return
operator|(
literal|" s "
operator|)
return|;
return|return
operator|(
literal|"s "
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate and print one line of packet loss and packet rate statistics.  * Checks for count of all ones from mrouted 2.3 that doesn't have counters.  */
end_comment

begin_define
define|#
directive|define
name|NEITHER
value|0
end_define

begin_define
define|#
directive|define
name|INS
value|1
end_define

begin_define
define|#
directive|define
name|OUTS
value|2
end_define

begin_define
define|#
directive|define
name|BOTH
value|3
end_define

begin_function
name|void
name|stat_line
parameter_list|(
name|r
parameter_list|,
name|s
parameter_list|,
name|have_next
parameter_list|)
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|have_next
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|timediff
operator|=
operator|(
name|fixtime
argument_list|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_qarr
argument_list|)
argument_list|)
operator|-
name|fixtime
argument_list|(
name|ntohl
argument_list|(
name|r
operator|->
name|tr_qarr
argument_list|)
argument_list|)
operator|)
operator|>>
literal|16
expr_stmt|;
specifier|register
name|v_lost
operator|,
name|v_pct
expr_stmt|;
specifier|register
name|g_lost
operator|,
name|g_pct
expr_stmt|;
specifier|register
name|v_out
operator|=
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
expr_stmt|;
specifier|register
name|g_out
operator|=
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
expr_stmt|;
specifier|register
name|v_pps
operator|,
name|g_pps
expr_stmt|;
name|char
name|v_str
index|[
literal|8
index|]
decl_stmt|,
name|g_str
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|have
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
name|timediff
operator|==
literal|0
condition|)
name|timediff
operator|=
literal|1
expr_stmt|;
name|v_pps
operator|=
name|v_out
operator|/
name|timediff
expr_stmt|;
name|g_pps
operator|=
name|g_out
operator|/
name|timediff
expr_stmt|;
if|if
condition|(
name|v_out
operator|||
name|s
operator|->
name|tr_vifout
operator|!=
literal|0xFFFFFFFF
condition|)
name|have
operator||=
name|OUTS
expr_stmt|;
if|if
condition|(
name|have_next
condition|)
block|{
operator|--
name|r
operator|,
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tr_vifin
operator|!=
literal|0xFFFFFFFF
operator|||
name|r
operator|->
name|tr_vifin
operator|!=
literal|0xFFFFFFFF
condition|)
name|have
operator||=
name|INS
expr_stmt|;
block|}
switch|switch
condition|(
name|have
condition|)
block|{
case|case
name|BOTH
case|:
name|v_lost
operator|=
name|v_out
operator|-
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|v_out
condition|)
name|v_pct
operator|=
operator|(
name|v_lost
operator|*
literal|100
operator|+
operator|(
name|v_out
operator|>>
literal|1
operator|)
operator|)
operator|/
name|v_out
expr_stmt|;
else|else
name|v_pct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|-
literal|100
operator|<
name|v_pct
operator|&&
name|v_pct
operator|<
literal|101
operator|&&
name|v_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|v_str
argument_list|,
literal|"%3d"
argument_list|,
name|v_pct
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|v_str
argument_list|,
literal|" --"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|g_lost
operator|=
name|g_out
operator|-
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|g_out
condition|)
name|g_pct
operator|=
operator|(
name|g_lost
operator|*
literal|100
operator|+
operator|(
name|g_out
operator|>>
literal|1
operator|)
operator|)
operator|/
name|g_out
expr_stmt|;
else|else
name|g_pct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|-
literal|100
operator|<
name|g_pct
operator|&&
name|g_pct
operator|<
literal|101
operator|&&
name|g_out
operator|>
literal|10
condition|)
name|sprintf
argument_list|(
name|g_str
argument_list|,
literal|"%3d"
argument_list|,
name|g_pct
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|g_str
argument_list|,
literal|" --"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%6d/%-5d=%s%%%4d pps%6d/%-5d=%s%%%4d pps\n"
argument_list|,
name|v_lost
argument_list|,
name|v_out
argument_list|,
name|v_str
argument_list|,
name|v_pps
argument_list|,
name|g_lost
argument_list|,
name|g_out
argument_list|,
name|g_str
argument_list|,
name|g_pps
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifout
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld "
argument_list|,
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"time: %d\n"
argument_list|,
name|timediff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INS
case|:
name|v_out
operator|=
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_vifin
argument_list|)
operator|)
expr_stmt|;
name|g_out
operator|=
operator|(
name|ntohl
argument_list|(
name|s
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|r
operator|->
name|tr_pktcnt
argument_list|)
operator|)
expr_stmt|;
name|v_pps
operator|=
name|v_out
operator|/
name|timediff
expr_stmt|;
name|g_pps
operator|=
name|g_out
operator|/
name|timediff
expr_stmt|;
comment|/* Fall through */
case|case
name|OUTS
case|:
name|printf
argument_list|(
literal|"       %-5d     %4d pps       %-5d     %4d pps\n"
argument_list|,
name|v_out
argument_list|,
name|v_pps
argument_list|,
name|g_out
argument_list|,
name|g_pps
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEITHER
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * A fixup to check if any pktcnt has been reset.  */
end_comment

begin_function
name|void
name|fixup_stats
parameter_list|(
name|base
parameter_list|,
name|new
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|base
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rno
operator|=
name|base
operator|->
name|len
expr_stmt|;
specifier|register
name|struct
name|tr_resp
modifier|*
name|b
init|=
name|base
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
specifier|register
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|new
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>=
literal|0
condition|)
if|if
condition|(
name|ntohl
argument_list|(
operator|(
operator|--
name|n
operator|)
operator|->
name|tr_pktcnt
argument_list|)
operator|<
name|ntohl
argument_list|(
operator|(
operator|--
name|b
operator|)
operator|->
name|tr_pktcnt
argument_list|)
condition|)
break|break;
if|if
condition|(
name|rno
operator|<
literal|0
condition|)
return|return;
name|rno
operator|=
name|base
operator|->
name|len
expr_stmt|;
name|b
operator|=
name|base
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
name|n
operator|=
name|new
operator|->
name|resps
operator|+
name|rno
expr_stmt|;
while|while
condition|(
operator|--
name|rno
operator|>=
literal|0
condition|)
operator|(
operator|--
name|b
operator|)
operator|->
name|tr_pktcnt
operator|=
operator|(
operator|--
name|n
operator|)
operator|->
name|tr_pktcnt
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print responses with statistics for forward path (from src to dst)  */
end_comment

begin_function
name|void
name|print_stats
parameter_list|(
name|base
parameter_list|,
name|prev
parameter_list|,
name|new
parameter_list|)
name|struct
name|resp_buf
modifier|*
name|base
decl_stmt|,
decl|*
name|prev
decl_stmt|,
modifier|*
name|new
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rtt
decl_stmt|,
name|hop
decl_stmt|;
specifier|register
name|char
modifier|*
name|ms
decl_stmt|;
specifier|register
name|u_int32
name|smask
decl_stmt|;
specifier|register
name|rno
operator|=
name|base
operator|->
name|len
operator|-
literal|1
expr_stmt|;
specifier|register
name|struct
name|tr_resp
modifier|*
name|b
init|=
name|base
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
specifier|register
name|struct
name|tr_resp
modifier|*
name|p
init|=
name|prev
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
specifier|register
name|struct
name|tr_resp
modifier|*
name|n
init|=
name|new
operator|->
name|resps
operator|+
name|rno
decl_stmt|;
specifier|register
name|u_long
name|resptime
init|=
name|new
operator|->
name|rtime
decl_stmt|;
specifier|register
name|u_long
name|qarrtime
init|=
name|fixtime
argument_list|(
name|ntohl
argument_list|(
name|n
operator|->
name|tr_qarr
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|ttl
operator|=
name|n
operator|->
name|tr_fttl
expr_stmt|;
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|b
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Source        Response Dest"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Packet Statistics For     Only For Traffic\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-15s %-15s  All Multicast Traffic     From %s\n"
argument_list|,
operator|(
operator|(
name|b
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
operator|)
condition|?
name|s1
else|:
literal|"   * * *       "
argument_list|,
name|inet_fmt
argument_list|(
name|base
operator|->
name|qhdr
operator|.
name|tr_raddr
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|rtt
operator|=
name|t_diff
argument_list|(
name|resptime
argument_list|,
name|new
operator|->
name|qtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|rtt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     |       __/  rtt%5d%s    Lost/Sent = Pct  Rate       To %s\n"
argument_list|,
name|rtt
argument_list|,
name|ms
argument_list|,
name|inet_fmt
argument_list|(
name|qgrp
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|hop
operator|=
name|t_diff
argument_list|(
name|resptime
argument_list|,
name|qarrtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v      /     hop%5d%s"
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ---------------------     --------------------\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
name|ntohl
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t\tv_in: %ld "
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifin
argument_list|)
operator|-
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifin
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"v_out: %ld "
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_vifout
argument_list|)
operator|-
name|ntohl
argument_list|(
name|b
operator|->
name|tr_vifout
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pkts: %ld\n"
argument_list|,
name|ntohl
argument_list|(
name|n
operator|->
name|tr_pktcnt
argument_list|)
operator|-
name|ntohl
argument_list|(
name|b
operator|->
name|tr_pktcnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|b
operator|->
name|tr_inaddr
operator|)
operator|||
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|b
operator|->
name|tr_inaddr
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Route changed, start again.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|->
name|tr_inaddr
operator|!=
name|n
operator|->
name|tr_outaddr
operator|)
condition|)
name|printf
argument_list|(
literal|"%-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|n
operator|->
name|tr_inaddr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-15s %-14s %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|n
operator|->
name|tr_outaddr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|names
index|[
name|rno
index|]
argument_list|,
name|flag_type
argument_list|(
name|n
operator|->
name|tr_rflags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rno
operator|--
operator|<
literal|1
condition|)
break|break;
name|printf
argument_list|(
literal|"     |     ^      ttl%5d   "
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|new
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|stat_line
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|resptime
operator|=
name|qarrtime
expr_stmt|;
name|qarrtime
operator|=
name|fixtime
argument_list|(
name|ntohl
argument_list|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|->
name|tr_qarr
argument_list|)
argument_list|)
expr_stmt|;
name|hop
operator|=
name|t_diff
argument_list|(
name|resptime
argument_list|,
name|qarrtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v     |      hop%5d%s"
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|stat_line
argument_list|(
name|b
argument_list|,
name|n
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|--
name|b
operator|,
operator|--
name|p
operator|,
operator|--
name|n
expr_stmt|;
if|if
condition|(
name|ttl
operator|<
name|n
operator|->
name|tr_fttl
condition|)
name|ttl
operator|=
name|n
operator|->
name|tr_fttl
expr_stmt|;
else|else
operator|++
name|ttl
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"     |      \\__   ttl%5d   "
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|new
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|stat_line
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hop
operator|=
name|t_diff
argument_list|(
name|qarrtime
argument_list|,
name|new
operator|->
name|qtime
argument_list|)
expr_stmt|;
name|ms
operator|=
name|scale
argument_list|(
operator|&
name|hop
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     v         \\  hop%5d%s"
argument_list|,
name|hop
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|stat_line
argument_list|(
name|b
argument_list|,
name|n
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-15s %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qdst
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|lcl_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Receiver      Query Source\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***************************************************************************  *	main  ***************************************************************************/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|udp
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|addrlen
init|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|int
name|recvlen
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|resp_buf
modifier|*
name|prev
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|struct
name|tr_query
modifier|*
name|query
decl_stmt|;
name|struct
name|tr_resp
modifier|*
name|r
decl_stmt|;
name|u_int32
name|smask
decl_stmt|;
name|int
name|rno
decl_stmt|;
name|int
name|hops
decl_stmt|,
name|tries
decl_stmt|;
name|int
name|numstats
init|=
literal|1
decl_stmt|;
name|int
name|waittime
decl_stmt|;
name|int
name|seed
decl_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtrace: must be root\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|argv
operator|++
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
do|do
block|{
specifier|register
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|arg
operator|=
name|p
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|arg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* Unlisted debug print option */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|debug
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|0
condition|)
name|debug
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|debug
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'M'
case|:
comment|/* Use multicast for reponse */
name|multicast
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Loop updating stats indefinitely */
name|numstats
operator|=
literal|3153600
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Don't reverse map host addresses */
name|numeric
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Passive listen for traces */
name|passive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Short form, don't wait for stats */
name|numstats
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Time to wait for packet arrival */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|1
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'m'
case|:
comment|/* Max number of hops to trace */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|qno
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qno
operator|>
name|MAXHOPS
condition|)
name|qno
operator|=
name|MAXHOPS
expr_stmt|;
elseif|else
if|if
condition|(
name|qno
operator|<
literal|1
condition|)
name|qno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'q'
case|:
comment|/* Number of query retries */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|nqueries
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nqueries
operator|<
literal|1
condition|)
name|nqueries
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'g'
case|:
comment|/* Last-hop gateway (dest of query) */
if|if
condition|(
name|arg
operator|&&
operator|(
name|gwy
operator|=
name|host_addr
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'t'
case|:
comment|/* TTL for query packet */
if|if
condition|(
name|arg
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|qttl
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qttl
operator|<
literal|1
condition|)
name|qttl
operator|=
literal|1
expr_stmt|;
name|rttl
operator|=
name|qttl
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'r'
case|:
comment|/* Dest for response packet */
if|if
condition|(
name|arg
operator|&&
operator|(
name|raddr
operator|=
name|host_addr
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
case|case
literal|'i'
case|:
comment|/* Local interface address */
if|if
condition|(
name|arg
operator|&&
operator|(
name|lcl_addr
operator|=
name|host_addr
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|argv
index|[
literal|0
index|]
condition|)
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|usage
goto|;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
do|while
condition|(
operator|*
name|p
condition|)
do|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|qsrc
operator|=
name|host_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Source of path */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qsrc
argument_list|)
argument_list|)
condition|)
goto|goto
name|usage
goto|;
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|qdst
operator|=
name|host_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Dest of path */
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|qgrp
operator|=
name|host_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Path via group */
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qdst
argument_list|)
argument_list|)
condition|)
block|{
name|u_int32
name|temp
init|=
name|qdst
decl_stmt|;
name|qdst
operator|=
name|qgrp
expr_stmt|;
name|qgrp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qdst
argument_list|)
argument_list|)
condition|)
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|qgrp
operator|&&
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|qgrp
argument_list|)
argument_list|)
condition|)
goto|goto
name|usage
goto|;
block|}
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|||
name|qsrc
operator|==
literal|0
condition|)
block|{
name|usage
label|:
name|printf
argument_list|(
literal|"\ Usage: mtrace [-Mlnps] [-w wait] [-m max_hops] [-q nqueries] [-g gateway]\n\               [-t ttl] [-r resp_dest] [-i if_addr] source [receiver] [group]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|init_igmp
argument_list|()
expr_stmt|;
comment|/*      * Set useful defaults for as many parameters as possible.      */
name|defgrp
operator|=
name|htonl
argument_list|(
literal|0xE0020001
argument_list|)
expr_stmt|;
comment|/* MBone Audio (224.2.0.1) */
name|query_cast
operator|=
name|htonl
argument_list|(
literal|0xE0000002
argument_list|)
expr_stmt|;
comment|/* All routers multicast addr */
name|resp_cast
operator|=
name|htonl
argument_list|(
literal|0xE0000120
argument_list|)
expr_stmt|;
comment|/* Mtrace response multicast addr */
if|if
condition|(
name|qgrp
operator|==
literal|0
condition|)
name|qgrp
operator|=
name|defgrp
expr_stmt|;
comment|/*      * Get default local address for multicasts to use in setting defaults.      */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|addr
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|qgrp
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* Any port above 1024 will do */
if|if
condition|(
operator|(
operator|(
name|udp
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|connect
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|getsockname
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Determining local address"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Default destination for path to be queried is the local host.      */
if|if
condition|(
name|qdst
operator|==
literal|0
condition|)
name|qdst
operator|=
name|lcl_addr
condition|?
name|lcl_addr
else|:
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/*      * If the destination is on the local net, the last-hop router can      * be found by multicast to the all-routers multicast group.      * Otherwise, use the group address that is the subject of the      * query since by definition the last hop router will be a member.      * Set default TTLs for local remote multicasts.      */
name|dst_netmask
operator|=
name|get_netmask
argument_list|(
name|udp
argument_list|,
name|qdst
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|udp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcl_addr
operator|==
literal|0
condition|)
name|lcl_addr
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|gwy
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|qdst
operator|&
name|dst_netmask
operator|)
operator|==
operator|(
name|lcl_addr
operator|&
name|dst_netmask
operator|)
condition|)
name|gwy
operator|=
name|query_cast
expr_stmt|;
else|else
name|gwy
operator|=
name|qgrp
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gwy
argument_list|)
argument_list|)
condition|)
block|{
name|k_set_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If I am running on a router, I need to hear this */
if|if
condition|(
name|gwy
operator|==
name|query_cast
condition|)
name|k_set_ttl
argument_list|(
name|qttl
condition|?
name|qttl
else|:
literal|1
argument_list|)
expr_stmt|;
else|else
name|k_set_ttl
argument_list|(
name|qttl
condition|?
name|qttl
else|:
name|MULTICAST_TTL1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|send_recv
argument_list|(
name|gwy
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_ASK_NEIGHBORS2
argument_list|,
literal|1
argument_list|,
operator|&
name|incr
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
name|ntohl
argument_list|(
name|incr
index|[
literal|0
index|]
operator|.
name|igmp
operator|.
name|igmp_group
operator|.
name|s_addr
argument_list|)
operator|==
literal|0x0303
condition|)
block|{
name|printf
argument_list|(
literal|"Don't use -g to address an mrouted 3.3, it might crash\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Mtrace from %s to %s via group %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qdst
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qgrp
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qdst
operator|&
name|dst_netmask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|dst_netmask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Source& receiver are directly connected, no path to trace\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make up the IGMP_MTRACE query packet to send (some parameters      * are set later), including initializing the seed for random      * query identifiers.      */
name|query
operator|=
operator|(
expr|struct
name|tr_query
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|query
operator|->
name|tr_src
operator|=
name|qsrc
expr_stmt|;
name|query
operator|->
name|tr_dst
operator|=
name|qdst
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seed
operator|=
name|tv
operator|.
name|tv_usec
operator|^
name|lcl_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|srand48
argument_list|(
name|seed
argument_list|)
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * If the response is to be a multicast address, make sure we       * are listening on that multicast address.      */
if|if
condition|(
name|raddr
operator|&&
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|raddr
argument_list|)
argument_list|)
condition|)
name|k_join
argument_list|(
name|raddr
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
else|else
name|k_join
argument_list|(
name|resp_cast
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
comment|/*      * Try a query at the requested number of hops or MAXOPS if unspecified.      */
if|if
condition|(
name|qno
operator|==
literal|0
condition|)
block|{
name|hops
operator|=
name|MAXHOPS
expr_stmt|;
name|tries
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Querying full reverse path... "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hops
operator|=
name|qno
expr_stmt|;
name|tries
operator|=
name|nqueries
expr_stmt|;
name|printf
argument_list|(
literal|"Querying reverse path, maximum %d hops... "
argument_list|,
name|qno
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|base
operator|.
name|rtime
operator|=
literal|0
expr_stmt|;
name|base
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|recvlen
operator|=
name|send_recv
argument_list|(
name|gwy
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|hops
argument_list|,
name|tries
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
comment|/*      * If the initial query was successful, print it.  Otherwise, if      * the query max hop count is the default of zero, loop starting      * from one until a timeout occurs.      */
if|if
condition|(
name|recvlen
condition|)
block|{
name|printf
argument_list|(
literal|"\n  0  "
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qdst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
literal|1
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
name|r
operator|=
name|base
operator|.
name|resps
operator|+
name|base
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|==
name|TR_OLD_ROUTER
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|what_kind
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|base
operator|.
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qsrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|qno
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"switching to hop-by-hop:\n  0  "
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qdst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hops
operator|=
literal|1
init|;
name|hops
operator|<=
name|MAXHOPS
condition|;
operator|++
name|hops
control|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
name|hops
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|recvlen
operator|=
name|send_recv
argument_list|(
name|gwy
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|hops
argument_list|,
name|nqueries
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|hops
operator|==
literal|0
condition|)
break|break;
name|what_kind
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|base
operator|.
name|resps
operator|+
name|base
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|base
operator|.
name|len
operator|==
name|hops
condition|)
name|print_trace
argument_list|(
operator|-
name|hops
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
else|else
block|{
name|hops
operator|=
name|base
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|==
name|TR_OLD_ROUTER
condition|)
block|{
name|what_kind
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|->
name|tr_rflags
operator|==
name|TR_NO_SPACE
condition|)
block|{
name|printf
argument_list|(
literal|"No space left in trace packet for further hops\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* XXX could do segmented trace */
block|}
name|printf
argument_list|(
literal|"Route must have changed...\n\n"
argument_list|)
expr_stmt|;
name|print_trace
argument_list|(
literal|1
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
block|}
name|VAL_TO_MASK
argument_list|(
name|smask
argument_list|,
name|r
operator|->
name|tr_smask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|tr_inaddr
operator|&
name|smask
operator|)
operator|==
operator|(
name|qsrc
operator|&
name|smask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%3d  "
argument_list|,
operator|-
operator|(
name|hops
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
name|qsrc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|->
name|tr_rmtaddr
operator|==
literal|0
operator|||
operator|(
name|r
operator|->
name|tr_rflags
operator|&
literal|0x80
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|base
operator|.
name|rtime
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timed out receiving responses\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gwy
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|gwy
operator|==
name|query_cast
condition|)
name|printf
argument_list|(
literal|"Perhaps no local router has a route for source %s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Perhaps receiver %s is not a member of group %s,\n\ or no router local to it has a route for source %s,\n\ or multicast at ttl %d doesn't reach its last-hop router for that source\n"
argument_list|,
name|inet_fmt
argument_list|(
name|qdst
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qgrp
argument_list|,
name|s3
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|qsrc
argument_list|,
name|s1
argument_list|)
argument_list|,
name|qttl
condition|?
name|qttl
else|:
name|MULTICAST_TTL1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Round trip time %d ms\n\n"
argument_list|,
name|t_diff
argument_list|(
name|base
operator|.
name|rtime
argument_list|,
name|base
operator|.
name|qtime
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Use the saved response which was the longest one received,      * and make additional probes after delay to measure loss.      */
name|raddr
operator|=
name|base
operator|.
name|qhdr
operator|.
name|tr_raddr
expr_stmt|;
name|rttl
operator|=
name|base
operator|.
name|qhdr
operator|.
name|tr_rttl
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waittime
operator|=
literal|10
operator|-
operator|(
operator|(
operator|(
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|&
literal|0xFFFF
operator|)
operator|-
operator|(
name|base
operator|.
name|qtime
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|prev
operator|=
name|new
operator|=
operator|&
name|incr
index|[
name|numstats
operator|&
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|numstats
operator|--
condition|)
block|{
if|if
condition|(
name|waittime
operator|<
literal|1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Waiting to accumulate statistics... "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
name|waittime
argument_list|)
expr_stmt|;
block|}
name|rno
operator|=
name|base
operator|.
name|len
expr_stmt|;
name|recvlen
operator|=
name|send_recv
argument_list|(
name|gwy
argument_list|,
name|IGMP_MTRACE
argument_list|,
name|rno
argument_list|,
name|nqueries
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvlen
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rno
operator|!=
name|new
operator|->
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"Trace length doesn't match.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Results after %d seconds:\n\n"
argument_list|,
operator|(
name|new
operator|->
name|qtime
operator|-
name|base
operator|.
name|qtime
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fixup_stats
argument_list|(
operator|&
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
operator|&
name|base
argument_list|,
name|prev
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|=
operator|&
name|incr
index|[
name|numstats
operator|&
literal|1
index|]
expr_stmt|;
name|waittime
operator|=
literal|10
expr_stmt|;
block|}
comment|/*      * If the response was multicast back, leave the group      */
if|if
condition|(
name|raddr
operator|&&
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|raddr
argument_list|)
argument_list|)
condition|)
name|k_leave
argument_list|(
name|raddr
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
else|else
name|k_leave
argument_list|(
name|resp_cast
argument_list|,
name|lcl_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"sendto"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log errors and other messages to stderr, according to the severity  * of the message and the current debug level.  For errors of severity  * LOG_ERR or worse, terminate the program.  */
end_comment

begin_comment
comment|/*VARARGS3*/
end_comment

begin_function
name|void
name|log
parameter_list|(
name|severity
parameter_list|,
name|syserr
parameter_list|,
name|format
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
name|int
name|severity
decl_stmt|,
name|syserr
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|;
block|{
name|char
name|fmt
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|debug
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|severity
operator|>
name|LOG_WARNING
condition|)
return|return;
case|case
literal|1
case|:
if|if
condition|(
name|severity
operator|>
name|LOG_NOTICE
condition|)
return|return;
case|case
literal|2
case|:
if|if
condition|(
name|severity
operator|>
name|LOG_INFO
condition|)
return|return;
default|default:
name|fmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|severity
operator|==
name|LOG_WARNING
condition|)
name|strcat
argument_list|(
name|fmt
argument_list|,
literal|"warning - "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|fmt
argument_list|,
name|format
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|syserr
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syserr
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|sys_errlist
index|[
name|syserr
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": errno %d\n"
argument_list|,
name|syserr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|severity
operator|<=
name|LOG_ERR
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dummies */
end_comment

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_probe
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_group_report
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_neighbors
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_neighbors2
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_neighbor_request
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_neighbor_request2
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_report
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_prune
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_graft
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_g_ack
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|add_table_entry
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_mtrace
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_leave_message
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|accept_membership_query
parameter_list|()
block|{}
end_function

begin_comment
comment|/*VARARGS*/
end_comment

end_unit

