begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * $Id: inet.c,v 1.5 1996/01/06 21:09:45 peter Exp $  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|char
name|s1
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers to hold the string representations  */
end_comment

begin_decl_stmt
name|char
name|s2
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* of IP addresses, to be passed to inet_fmt() */
end_comment

begin_decl_stmt
name|char
name|s3
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* or inet_fmts().                             */
end_comment

begin_decl_stmt
name|char
name|s4
index|[
literal|19
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Verify that a given IP address is credible as a host address.  * (Without a mask, cannot detect addresses of the form {subnet,0} or  * {subnet,-1}.)  */
end_comment

begin_function
name|int
name|inet_valid_host
parameter_list|(
name|naddr
parameter_list|)
name|u_int32
name|naddr
decl_stmt|;
block|{
specifier|register
name|u_int32
name|addr
decl_stmt|;
name|addr
operator|=
name|ntohl
argument_list|(
name|naddr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|IN_MULTICAST
argument_list|(
name|addr
argument_list|)
operator|||
name|IN_BADCLASS
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
name|addr
operator|&
literal|0xff000000
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that a given netmask is plausible;  * make sure that it is a series of 1's followed by  * a series of 0's with no discontiguous 1's.  */
end_comment

begin_function
name|int
name|inet_valid_mask
parameter_list|(
name|mask
parameter_list|)
name|u_int32
name|mask
decl_stmt|;
block|{
if|if
condition|(
operator|~
operator|(
operator|(
operator|(
name|mask
operator|&
operator|-
name|mask
operator|)
operator|-
literal|1
operator|)
operator||
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Mask is not contiguous */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that a given subnet number and mask pair are credible.  *  * With CIDR, almost any subnet and mask are credible.  mrouted still  * can't handle aggregated class A's, so we still check that, but  * otherwise the only requirements are that the subnet address is  * within the [ABC] range and that the host bits of the subnet  * are all 0.  */
end_comment

begin_function
name|int
name|inet_valid_subnet
parameter_list|(
name|nsubnet
parameter_list|,
name|nmask
parameter_list|)
name|u_int32
name|nsubnet
decl_stmt|,
name|nmask
decl_stmt|;
block|{
specifier|register
name|u_int32
name|subnet
decl_stmt|,
name|mask
decl_stmt|;
name|subnet
operator|=
name|ntohl
argument_list|(
name|nsubnet
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ntohl
argument_list|(
name|nmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|subnet
operator|&
name|mask
operator|)
operator|!=
name|subnet
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|subnet
operator|==
literal|0
condition|)
return|return
operator|(
name|mask
operator|==
literal|0
operator|)
return|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|subnet
argument_list|)
condition|)
block|{
if|if
condition|(
name|mask
operator|<
literal|0xff000000
operator|||
operator|(
name|subnet
operator|&
literal|0xff000000
operator|)
operator|==
literal|0x7f000000
operator|||
operator|(
name|subnet
operator|&
literal|0xff000000
operator|)
operator|==
literal|0x00000000
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|IN_CLASSD
argument_list|(
name|subnet
argument_list|)
operator|||
name|IN_BADCLASS
argument_list|(
name|subnet
argument_list|)
condition|)
block|{
comment|/* Above Class C address space */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|subnet
operator|&
operator|~
name|mask
condition|)
block|{
comment|/* Host bits are set in the subnet */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|inet_valid_mask
argument_list|(
name|mask
argument_list|)
condition|)
block|{
comment|/* Netmask is not contiguous */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an IP address in u_long (network) format into a printable string.  */
end_comment

begin_function
name|char
modifier|*
name|inet_fmt
parameter_list|(
name|addr
parameter_list|,
name|s
parameter_list|)
name|u_int32
name|addr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|a
decl_stmt|;
name|a
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an IP subnet number in u_long (network) format into a printable  * string including the netmask as a number of bits.  */
end_comment

begin_function
name|char
modifier|*
name|inet_fmts
parameter_list|(
name|addr
parameter_list|,
name|mask
parameter_list|,
name|s
parameter_list|)
name|u_int32
name|addr
decl_stmt|,
name|mask
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|a
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|bits
decl_stmt|;
if|if
condition|(
operator|(
name|addr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mask
operator|==
literal|0
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|a
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
name|m
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
expr_stmt|;
name|bits
operator|=
literal|33
operator|-
name|ffs
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u.%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u.%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%u/%d"
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|bits
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert the printable string representation of an IP address into the  * u_long (network) format.  Return 0xffffffff on error.  (To detect the  * legal address with that value, you must explicitly compare the string  * with "255.255.255.255".)  */
end_comment

begin_function
name|u_int32
name|inet_parse
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|u_int32
name|a
init|=
literal|0
decl_stmt|;
name|u_int
name|a0
init|=
literal|0
decl_stmt|,
name|a1
init|=
literal|0
decl_stmt|,
name|a2
init|=
literal|0
decl_stmt|,
name|a3
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%u.%u.%u.%u%c"
argument_list|,
operator|&
name|a0
argument_list|,
operator|&
name|a1
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|a3
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
operator|||
name|i
operator|>
literal|4
operator|||
name|a0
operator|>
literal|255
operator|||
name|a1
operator|>
literal|255
operator|||
name|a2
operator|>
literal|255
operator|||
name|a3
operator|>
literal|255
condition|)
return|return
operator|(
literal|0xffffffff
operator|)
return|;
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|a
operator|)
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|a
operator|)
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|a
operator|)
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|a
operator|)
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inet_cksum extracted from:  *			P I N G . C  *  * Author -  *	Mike Muuss  *	U. S. Army Ballistic Research Laboratory  *	December, 1983  * Modified at Uc Berkeley  *  * (ping.c) Status -  *	Public Domain.  Distribution Unlimited.  *  *			I N _ C K S U M  *  * Checksum routine for Internet Protocol family headers (C Version)  *  */
end_comment

begin_function
name|int
name|inet_cksum
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|u_short
modifier|*
name|addr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|nleft
init|=
operator|(
name|int
operator|)
name|len
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|w
init|=
name|addr
decl_stmt|;
name|u_short
name|answer
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|sum
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Our algorithm is simple, using a 32 bit accumulator (sum), 	 *  we add sequential 16 bit words to it, and at the end, fold 	 *  back all the carry bits from the top 16 bits into the lower 	 *  16 bits. 	 */
while|while
condition|(
name|nleft
operator|>
literal|1
condition|)
block|{
name|sum
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
name|nleft
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|nleft
operator|==
literal|1
condition|)
block|{
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|answer
operator|)
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|w
expr_stmt|;
name|sum
operator|+=
name|answer
expr_stmt|;
block|}
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|answer
operator|=
operator|~
name|sum
expr_stmt|;
comment|/* truncate to 16 bits */
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

end_unit

