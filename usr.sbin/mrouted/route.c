begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * This define statement saves a lot of space later  */
end_comment

begin_define
define|#
directive|define
name|RT_ADDR
value|(struct rtentry *)&routing_table
end_define

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|int
name|routes_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>some routes have changed */
end_comment

begin_decl_stmt
name|int
name|delay_change_reports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>postpone change reports  */
end_comment

begin_comment
comment|/*  * The routing table is shared with prune.c , so must not be static.  */
end_comment

begin_decl_stmt
name|struct
name|rtentry
modifier|*
name|routing_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to list of route entries */
end_comment

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rtentry
modifier|*
name|rtp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to a route entry         */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rtentry
modifier|*
name|rt_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to last route entry      */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|nroutes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current number of route entries  */
end_comment

begin_comment
comment|/*  * Private functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|init_children_and_leaves
name|__P
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
name|r
operator|,
name|vifi_t
name|parent
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_route
name|__P
argument_list|(
operator|(
name|u_int32
name|origin
operator|,
name|u_int32
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_route
name|__P
argument_list|(
operator|(
name|u_int32
name|origin
operator|,
name|u_int32
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|discard_route
name|__P
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
name|prev_r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_rts
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|rt1
operator|,
specifier|const
name|void
operator|*
name|rt2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|report_chunk
name|__P
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
name|start_rt
operator|,
name|vifi_t
name|vifi
operator|,
name|u_int32
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the routing table and associated variables.  */
end_comment

begin_function
name|void
name|init_routes
parameter_list|()
block|{
name|routing_table
operator|=
name|NULL
expr_stmt|;
name|rt_end
operator|=
name|RT_ADDR
expr_stmt|;
name|nroutes
operator|=
literal|0
expr_stmt|;
name|routes_changed
operator|=
name|FALSE
expr_stmt|;
name|delay_change_reports
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the children and leaf bits for route 'r', along with the  * associated dominant, subordinate, and leaf timing data structures.  * Return TRUE if this changes the value of either the children or  * leaf bitmaps for 'r'.  */
end_comment

begin_function
specifier|static
name|int
name|init_children_and_leaves
parameter_list|(
name|r
parameter_list|,
name|parent
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|vifi_t
name|parent
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifbitmap_t
name|old_children
decl_stmt|,
name|old_leaves
decl_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_children
argument_list|,
name|old_children
argument_list|)
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_leaves
argument_list|,
name|old_leaves
argument_list|)
expr_stmt|;
name|VIFM_CLRALL
argument_list|(
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|VIFM_CLRALL
argument_list|(
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LEAF_TIMING
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vifi
operator|!=
name|parent
operator|&&
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
block|}
else|else
block|{
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|!
name|VIFM_SAME
argument_list|(
name|r
operator|->
name|rt_children
argument_list|,
name|old_children
argument_list|)
operator|||
operator|!
name|VIFM_SAME
argument_list|(
name|r
operator|->
name|rt_leaves
argument_list|,
name|old_leaves
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A new vif has come up -- update the children and leaf bitmaps in all route  * entries to take that into account.  */
end_comment

begin_function
name|void
name|add_vif_to_routes
parameter_list|(
name|vifi
parameter_list|)
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A vif has gone down -- expire all routes that have that vif as parent,  * and update the children bitmaps in all other route entries to take into  * account the failed vif.  */
end_comment

begin_function
name|void
name|delete_vif_from_routes
parameter_list|(
name|vifi
parameter_list|)
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
block|{
if|if
condition|(
name|vifi
operator|==
name|r
operator|->
name|rt_parent
condition|)
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
name|ROUTE_EXPIRE_TIME
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A neighbor has failed or become unreachable.  If that neighbor was  * considered a dominant or subordinate router in any route entries,  * take appropriate action.  */
end_comment

begin_function
name|void
name|delete_neighbor_from_routes
parameter_list|(
name|addr
parameter_list|,
name|vifi
parameter_list|)
specifier|register
name|u_int32
name|addr
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|==
name|addr
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|==
name|addr
condition|)
block|{
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
operator|&&
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|!=
literal|0
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Prepare for a sequence of ordered route updates by initializing a pointer  * to the start of the routing table.  The pointer is used to remember our  * position in the routing table in order to avoid searching from the  * beginning for each update; this relies on having the route reports in  * a single message be in the same order as the route entries in the routing  * table.  */
end_comment

begin_function
name|void
name|start_route_updates
parameter_list|()
block|{
name|rtp
operator|=
name|RT_ADDR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Starting at the route entry following the one to which 'rtp' points,  * look for a route entry matching the specified origin and mask.  If a  * match is found, return TRUE and leave 'rtp' pointing at the found entry.  * If no match is found, return FALSE and leave 'rtp' pointing to the route  * entry preceding the point at which the new origin should be inserted.  * This code is optimized for the normal case in which the first entry to  * be examined is the matching entry.  */
end_comment

begin_function
specifier|static
name|int
name|find_route
parameter_list|(
name|origin
parameter_list|,
name|mask
parameter_list|)
specifier|register
name|u_int32
name|origin
decl_stmt|,
name|mask
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|rtp
operator|->
name|rt_next
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|origin
operator|==
name|r
operator|->
name|rt_origin
operator|&&
name|mask
operator|==
name|r
operator|->
name|rt_originmask
condition|)
block|{
name|rtp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|<
name|ntohl
argument_list|(
name|r
operator|->
name|rt_originmask
argument_list|)
operator|||
operator|(
name|mask
operator|==
name|r
operator|->
name|rt_originmask
operator|&&
name|ntohl
argument_list|(
name|origin
argument_list|)
operator|<
name|ntohl
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|)
operator|)
condition|)
block|{
name|rtp
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|rt_next
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new routing table entry for the specified origin and link it into  * the routing table.  The shared variable 'rtp' is assumed to point to the  * routing entry after which the new one should be inserted.  It is left  * pointing to the new entry.  *  * Only the origin, originmask, originwidth and flags fields are initialized  * in the new route entry; the caller is responsible for filling in the the  * rest.  */
end_comment

begin_function
specifier|static
name|void
name|create_route
parameter_list|(
name|origin
parameter_list|,
name|mask
parameter_list|)
name|u_int32
name|origin
decl_stmt|,
name|mask
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtentry
argument_list|)
operator|+
operator|(
literal|2
operator|*
name|numvifs
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|)
operator|+
operator|(
name|numvifs
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
block|}
name|r
operator|->
name|rt_origin
operator|=
name|origin
expr_stmt|;
name|r
operator|->
name|rt_originmask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|r
operator|->
name|rt_originwidth
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|r
operator|->
name|rt_originwidth
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|r
operator|->
name|rt_originwidth
operator|=
literal|2
expr_stmt|;
else|else
name|r
operator|->
name|rt_originwidth
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|rt_flags
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_dominants
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|(
name|r
operator|+
literal|1
operator|)
expr_stmt|;
name|r
operator|->
name|rt_subordinates
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|(
name|r
operator|->
name|rt_dominants
operator|+
name|numvifs
operator|)
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|(
name|r
operator|->
name|rt_subordinates
operator|+
name|numvifs
operator|)
expr_stmt|;
name|r
operator|->
name|rt_groups
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|rt_next
operator|=
name|rtp
operator|->
name|rt_next
expr_stmt|;
name|rtp
operator|->
name|rt_next
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|rt_prev
operator|=
name|rtp
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt_next
operator|!=
name|NULL
condition|)
operator|(
name|r
operator|->
name|rt_next
operator|)
operator|->
name|rt_prev
operator|=
name|r
expr_stmt|;
else|else
name|rt_end
operator|=
name|r
expr_stmt|;
name|rtp
operator|=
name|r
expr_stmt|;
operator|++
name|nroutes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard the routing table entry following the one to which 'prev_r' points.  */
end_comment

begin_function
specifier|static
name|void
name|discard_route
parameter_list|(
name|prev_r
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|prev_r
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|prev_r
operator|->
name|rt_next
expr_stmt|;
name|prev_r
operator|->
name|rt_next
operator|=
name|r
operator|->
name|rt_next
expr_stmt|;
if|if
condition|(
name|prev_r
operator|->
name|rt_next
operator|!=
name|NULL
condition|)
operator|(
name|prev_r
operator|->
name|rt_next
operator|)
operator|->
name|rt_prev
operator|=
name|prev_r
expr_stmt|;
else|else
name|rt_end
operator|=
name|prev_r
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
operator|--
name|nroutes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a route report for a single origin, creating or updating the  * corresponding routing table entry if necessary.  'src' is either the  * address of a neighboring router from which the report arrived, or zero  * to indicate a change of status of one of our own interfaces.  */
end_comment

begin_function
name|void
name|update_route
parameter_list|(
name|origin
parameter_list|,
name|mask
parameter_list|,
name|metric
parameter_list|,
name|src
parameter_list|,
name|vifi
parameter_list|)
name|u_int32
name|origin
decl_stmt|,
name|mask
decl_stmt|;
name|u_int
name|metric
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|u_int
name|adj_metric
decl_stmt|;
comment|/*      * Compute an adjusted metric, taking into account the cost of the      * subnet or tunnel over which the report arrived, and normalizing      * all unreachable/poisoned metrics into a single value.      */
if|if
condition|(
name|src
operator|!=
literal|0
operator|&&
operator|(
name|metric
operator|<
literal|1
operator|||
name|metric
operator|>=
literal|2
operator|*
name|UNREACHABLE
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports out-of-range metric %u for origin %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|metric
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|adj_metric
operator|=
name|metric
operator|+
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_metric
expr_stmt|;
if|if
condition|(
name|adj_metric
operator|>
name|UNREACHABLE
condition|)
name|adj_metric
operator|=
name|UNREACHABLE
expr_stmt|;
comment|/*      * Look up the reported origin in the routing table.      */
if|if
condition|(
operator|!
name|find_route
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|)
condition|)
block|{
comment|/* 	 * Not found. 	 * Don't create a new entry if the report says it's unreachable, 	 * or if the reported origin and mask are invalid. 	 */
if|if
condition|(
name|adj_metric
operator|==
name|UNREACHABLE
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|src
operator|!=
literal|0
operator|&&
operator|!
name|inet_valid_subnet
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports an invalid origin (%s) and/or mask (%08x)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s2
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * OK, create the new routing entry.  'rtp' will be left pointing 	 * to the new entry. 	 */
name|create_route
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 	 * Now "steal away" any sources that belong under this route 	 * by deleting any cache entries they might have created 	 * and allowing the kernel to re-request them. 	 */
name|steal_sources
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
comment|/* temporary; updated below */
block|}
comment|/*      * We now have a routing entry for the reported origin.  Update it?      */
name|r
operator|=
name|rtp
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|==
name|UNREACHABLE
condition|)
block|{
comment|/* 	 * The routing entry is for a formerly-unreachable or new origin. 	 * If the report claims reachability, update the entry to use 	 * the reported route. 	 */
if|if
condition|(
name|adj_metric
operator|==
name|UNREACHABLE
condition|)
return|return;
name|r
operator|->
name|rt_parent
operator|=
name|vifi
expr_stmt|;
name|init_children_and_leaves
argument_list|(
name|r
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_gateway
operator|=
name|src
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|adj_metric
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|==
name|r
operator|->
name|rt_gateway
condition|)
block|{
comment|/* 	 * The report has come either from the interface directly-connected 	 * to the origin subnet (src and r->rt_gateway both equal zero) or 	 * from the gateway we have chosen as the best first-hop gateway back 	 * towards the origin (src and r->rt_gateway not equal zero).  Reset 	 * the route timer and, if the reported metric has changed, update 	 * our entry accordingly. 	 */
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adj_metric
operator|==
name|r
operator|->
name|rt_metric
condition|)
return|return;
if|if
condition|(
name|adj_metric
operator|==
name|UNREACHABLE
condition|)
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
name|ROUTE_EXPIRE_TIME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adj_metric
operator|<
name|r
operator|->
name|rt_metric
condition|)
block|{
if|if
condition|(
name|init_children_and_leaves
argument_list|(
name|r
argument_list|,
name|vifi
argument_list|)
condition|)
block|{
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|->
name|rt_metric
operator|=
name|adj_metric
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|==
literal|0
operator|||
operator|(
name|r
operator|->
name|rt_gateway
operator|!=
literal|0
operator|&&
operator|(
name|adj_metric
operator|<
name|r
operator|->
name|rt_metric
operator|||
operator|(
name|adj_metric
operator|==
name|r
operator|->
name|rt_metric
operator|&&
operator|(
name|ntohl
argument_list|(
name|src
argument_list|)
operator|<
name|ntohl
argument_list|(
name|r
operator|->
name|rt_gateway
argument_list|)
operator|||
name|r
operator|->
name|rt_timer
operator|>=
name|ROUTE_SWITCH_TIME
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 	 * The report is for an origin we consider reachable; the report 	 * comes either from one of our own interfaces or from a gateway 	 * other than the one we have chosen as the best first-hop gateway 	 * back towards the origin.  If the source of the update is one of 	 * our own interfaces, or if the origin is not a directly-connected 	 * subnet and the reported metric for that origin is better than 	 * what our routing entry says, update the entry to use the new 	 * gateway and metric.  We also switch gateways if the reported 	 * metric is the same as the one in the route entry and the gateway 	 * associated with the route entry has not been heard from recently, 	 * or if the metric is the same but the reporting gateway has a lower 	 * IP address than the gateway associated with the route entry. 	 * Did you get all that? 	 */
if|if
condition|(
name|r
operator|->
name|rt_parent
operator|!=
name|vifi
operator|||
name|adj_metric
operator|<
name|r
operator|->
name|rt_metric
condition|)
block|{
comment|/* 	     * XXX Why do we do this if we are just changing the metric? 	     */
name|r
operator|->
name|rt_parent
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|init_children_and_leaves
argument_list|(
name|r
argument_list|,
name|vifi
argument_list|)
condition|)
block|{
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|->
name|rt_gateway
operator|=
name|src
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|adj_metric
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vifi
operator|!=
name|r
operator|->
name|rt_parent
condition|)
block|{
comment|/* 	 * The report came from a vif other than the route's parent vif. 	 * Update the children and leaf info, if necessary. 	 */
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
comment|/* 	     * Vif is a child vif for this route. 	     */
if|if
condition|(
name|metric
operator|<
name|r
operator|->
name|rt_metric
operator|||
operator|(
name|metric
operator|==
name|r
operator|->
name|rt_metric
operator|&&
name|ntohl
argument_list|(
name|src
argument_list|)
operator|<
name|ntohl
argument_list|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Neighbor has lower metric to origin (or has same metric 		 * and lower IP address) -- it becomes the dominant router, 		 * and vif is no longer a child for me. 		 */
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
name|src
expr_stmt|;
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
block|{
comment|/* "poisoned reverse" */
comment|/* 		 * Neighbor considers this vif to be on path to route's 		 * origin; if no subordinate recorded, record this neighbor 		 * as subordinate and clear the leaf flag. 		 */
if|if
condition|(
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|==
literal|0
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
name|src
expr_stmt|;
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|==
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
condition|)
block|{
comment|/* 		 * Current subordinate no longer considers this vif to be on 		 * path to route's origin; it is no longer a subordinate 		 * router, and we set the leaf confirmation timer to give 		 * us time to hear from other subordinates. 		 */
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
operator|==
name|NULL
operator|||
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
operator|->
name|al_next
operator|==
name|NULL
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|==
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|&&
operator|(
name|metric
operator|>
name|r
operator|->
name|rt_metric
operator|||
operator|(
name|metric
operator|==
name|r
operator|->
name|rt_metric
operator|&&
name|ntohl
argument_list|(
name|src
argument_list|)
operator|>
name|ntohl
argument_list|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 	     * Current dominant no longer has a lower metric to origin 	     * (or same metric and lower IP address); we adopt the vif 	     * as our own child. 	     */
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
block|{
name|r
operator|->
name|rt_subordinates
index|[
name|vifi
index|]
operator|=
name|src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
operator|==
name|NULL
operator|||
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
operator|->
name|al_next
operator|==
name|NULL
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance the timer in each routing entry.  */
end_comment

begin_function
name|void
name|age_routes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|prev_r
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
for|for
control|(
name|prev_r
operator|=
name|RT_ADDR
operator|,
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|prev_r
operator|=
name|r
operator|,
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|->
name|rt_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|<
name|ROUTE_EXPIRE_TIME
condition|)
block|{
comment|/* 	     * Route is still good; see if any leaf timers need to be 	     * advanced. 	     */
if|if
condition|(
name|r
operator|->
name|rt_flags
operator|&
name|RTF_LEAF_TIMING
condition|)
block|{
name|r
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LEAF_TIMING
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Unlike other timers, leaf timers decrement. 			 */
if|if
condition|(
operator|(
name|r
operator|->
name|rt_leaf_timers
index|[
name|vifi
index|]
operator|-=
name|TIMER_INTERVAL
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NOTYET
comment|/* If the vif is a physical leaf but has neighbors, 			     * it is not a tree leaf.  If I am a leaf, then no 			     * interface with neighbors is a tree leaf. */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
operator|||
operator|(
name|vifs_with_neighbors
operator|==
literal|1
operator|)
operator|)
operator|&&
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTYET
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|r
operator|->
name|rt_flags
operator||=
name|RTF_LEAF_TIMING
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|rt_timer
operator|>=
name|ROUTE_DISCARD_TIME
condition|)
block|{
comment|/* 	     * Time to garbage-collect the route entry. 	     */
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|discard_route
argument_list|(
name|prev_r
argument_list|)
expr_stmt|;
name|r
operator|=
name|prev_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
block|{
comment|/* 	     * Time to expire the route entry.  If the gateway is zero, 	     * i.e., it is a route to a directly-connected subnet, just 	     * set the timer back to zero; such routes expire only when 	     * the interface to the subnet goes down. 	     */
if|if
condition|(
name|r
operator|->
name|rt_gateway
operator|==
literal|0
condition|)
block|{
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Mark all routes as unreachable.  This function is called only from  * hup() in preparation for informing all neighbors that we are going  * off the air.  For consistency, we ought also to delete all reachable  * route entries from the kernel, but since we are about to exit we rely  * on the kernel to do its own cleanup -- no point in making all those  * expensive kernel calls now.  */
end_comment

begin_function
name|void
name|expire_all_routes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete all the routes in the routing table.  */
end_comment

begin_function
name|void
name|free_all_routes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|RT_ADDR
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|rt_next
condition|)
name|discard_route
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor probe message.  */
end_comment

begin_function
name|void
name|accept_probe
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|level
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring probe from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|update_neighbor
argument_list|(
name|vifi
argument_list|,
name|src
argument_list|,
name|DVMRP_PROBE
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|newrt
block|{
name|u_int32
name|mask
decl_stmt|;
name|u_int32
name|origin
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|int
name|pad
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|compare_rts
parameter_list|(
name|rt1
parameter_list|,
name|rt2
parameter_list|)
specifier|const
name|void
modifier|*
name|rt1
decl_stmt|;
specifier|const
name|void
modifier|*
name|rt2
decl_stmt|;
block|{
specifier|register
name|struct
name|newrt
modifier|*
name|r1
init|=
operator|(
expr|struct
name|newrt
operator|*
operator|)
name|rt1
decl_stmt|;
specifier|register
name|struct
name|newrt
modifier|*
name|r2
init|=
operator|(
expr|struct
name|newrt
operator|*
operator|)
name|rt2
decl_stmt|;
specifier|register
name|u_int32
name|m1
init|=
name|ntohl
argument_list|(
name|r1
operator|->
name|mask
argument_list|)
decl_stmt|;
specifier|register
name|u_int32
name|m2
init|=
name|ntohl
argument_list|(
name|r2
operator|->
name|mask
argument_list|)
decl_stmt|;
specifier|register
name|u_int32
name|o1
decl_stmt|,
name|o2
decl_stmt|;
if|if
condition|(
name|m1
operator|>
name|m2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|m1
operator|<
name|m2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* masks are equal */
name|o1
operator|=
name|ntohl
argument_list|(
name|r1
operator|->
name|origin
argument_list|)
expr_stmt|;
name|o2
operator|=
name|ntohl
argument_list|(
name|r2
operator|->
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|o1
operator|>
name|o2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|o1
operator|<
name|o2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming route report message.  */
end_comment

begin_function
name|void
name|accept_report
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|datalen
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|int
name|width
decl_stmt|,
name|i
decl_stmt|,
name|nrt
init|=
literal|0
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|u_int32
name|origin
decl_stmt|;
name|struct
name|newrt
name|rt
index|[
literal|4096
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring route report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|update_neighbor
argument_list|(
name|vifi
argument_list|,
name|src
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
condition|)
return|return;
if|if
condition|(
name|datalen
operator|>
literal|2
operator|*
literal|4096
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring oversize (%d bytes) route report from %s"
argument_list|,
name|datalen
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
comment|/* Loop through per-mask lists. */
if|if
condition|(
name|datalen
operator|<
literal|3
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated route report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|width
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|width
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|width
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|inet_valid_mask
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports bogus netmask 0x%08x (%s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|datalen
operator|-=
literal|3
expr_stmt|;
do|do
block|{
comment|/* Loop through (origin, metric) pairs */
if|if
condition|(
name|datalen
operator|<
name|width
operator|+
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated route report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|origin
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|origin
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|metric
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|datalen
operator|-=
name|width
operator|+
literal|1
expr_stmt|;
name|rt
index|[
name|nrt
index|]
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|rt
index|[
name|nrt
index|]
operator|.
name|origin
operator|=
name|origin
expr_stmt|;
name|rt
index|[
name|nrt
index|]
operator|.
name|metric
operator|=
operator|(
name|metric
operator|&
literal|0x7f
operator|)
expr_stmt|;
operator|++
name|nrt
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|metric
operator|&
literal|0x80
operator|)
condition|)
do|;
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
argument_list|,
name|nrt
argument_list|,
sizeof|sizeof
argument_list|(
name|rt
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_rts
argument_list|)
expr_stmt|;
name|start_route_updates
argument_list|()
expr_stmt|;
comment|/*      * If the last entry is default, change mask from 0xff000000 to 0      */
if|if
condition|(
name|rt
index|[
name|nrt
operator|-
literal|1
index|]
operator|.
name|origin
operator|==
literal|0
condition|)
name|rt
index|[
name|nrt
operator|-
literal|1
index|]
operator|.
name|mask
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Updating %d routes from %s to %s"
argument_list|,
name|nrt
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|rt
index|[
name|i
index|]
operator|.
name|origin
operator|==
name|rt
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|origin
operator|&&
name|rt
index|[
name|i
index|]
operator|.
name|mask
operator|==
name|rt
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|mask
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports duplicate route for %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|rt
index|[
name|i
index|]
operator|.
name|origin
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|update_route
argument_list|(
name|rt
index|[
name|i
index|]
operator|.
name|origin
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|metric
argument_list|,
name|src
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|routes_changed
operator|&&
operator|!
name|delay_change_reports
condition|)
name|report_to_all_neighbors
argument_list|(
name|CHANGED_ROUTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a route report message to destination 'dst', via virtual interface  * 'vifi'.  'which_routes' specifies ALL_ROUTES or CHANGED_ROUTES.  */
end_comment

begin_function
name|void
name|report
parameter_list|(
name|which_routes
parameter_list|,
name|vifi
parameter_list|,
name|dst
parameter_list|)
name|int
name|which_routes
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|u_int32
name|mask
init|=
literal|0
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|nflags
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|int
name|admetric
init|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_admetric
decl_stmt|;
name|src
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTYET
comment|/* If I'm not a leaf, but the neighbor is a leaf, only advertise default */
if|if
condition|(
operator|(
name|vifs_with_neighbors
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 0xff000000 mask */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* class A net 0.0.0.0 == default */
operator|*
name|p
operator|++
operator|=
literal|0x81
expr_stmt|;
comment|/*XXX metric 1, is this safe? */
name|datalen
operator|+=
literal|5
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|nflags
operator|=
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
condition|?
literal|0
else|:
name|LEAF_FLAGS
expr_stmt|;
for|for
control|(
name|r
operator|=
name|rt_end
init|;
name|r
operator|!=
name|RT_ADDR
condition|;
name|r
operator|=
name|r
operator|->
name|rt_prev
control|)
block|{
if|if
condition|(
name|which_routes
operator|==
name|CHANGED_ROUTES
operator|&&
operator|!
operator|(
name|r
operator|->
name|rt_flags
operator|&
name|RTF_CHANGED
operator|)
condition|)
continue|continue;
comment|/* 	 * If there is no room for this route in the current message, 	 * send the message and start a new one. 	 */
if|if
condition|(
name|datalen
operator|+
operator|(
operator|(
name|r
operator|->
name|rt_originmask
operator|==
name|mask
operator|)
condition|?
operator|(
name|width
operator|+
literal|1
operator|)
else|:
operator|(
name|r
operator|->
name|rt_originwidth
operator|+
literal|4
operator|)
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
operator||
name|nflags
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|rt_originmask
operator|!=
name|mask
operator|||
name|datalen
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|r
operator|->
name|rt_originmask
expr_stmt|;
name|width
operator|=
name|r
operator|->
name|rt_originwidth
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|datalen
operator|+=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|r
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|metric
operator|=
name|r
operator|->
name|rt_metric
operator|+
name|admetric
expr_stmt|;
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
name|metric
operator|=
name|UNREACHABLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|r
operator|->
name|rt_parent
operator|==
name|vifi
operator|&&
name|metric
operator|!=
name|UNREACHABLE
operator|)
condition|?
call|(
name|char
call|)
argument_list|(
name|metric
operator|+
name|UNREACHABLE
argument_list|)
else|:
comment|/* "poisoned reverse" */
call|(
name|char
call|)
argument_list|(
name|metric
argument_list|)
expr_stmt|;
name|datalen
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
operator||
name|nflags
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a route report message to all neighboring routers.  * 'which_routes' specifies ALL_ROUTES or CHANGED_ROUTES.  */
end_comment

begin_function
name|void
name|report_to_all_neighbors
parameter_list|(
name|which_routes
parameter_list|)
name|int
name|which_routes
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|int
name|routes_changed_before
decl_stmt|;
comment|/*      * Remember the state of the global routes_changed flag before      * generating the reports, and clear the flag.      */
name|routes_changed_before
operator|=
name|routes_changed
expr_stmt|;
name|routes_changed
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|report
argument_list|(
name|which_routes
argument_list|,
name|vifi
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|v
operator|->
name|uv_rmt_addr
else|:
name|dvmrp_group
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If there were changed routes before we sent the reports AND      * if no new changes occurred while sending the reports, clear      * the change flags in the individual route entries.  If changes      * did occur while sending the reports, new reports will be      * generated at the next timer interrupt.      */
if|if
condition|(
name|routes_changed_before
operator|&&
operator|!
name|routes_changed
condition|)
block|{
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|r
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_CHANGED
expr_stmt|;
block|}
block|}
comment|/*      * Set a flag to inhibit further reports of changed routes until the      * next timer interrupt.  This is to alleviate update storms.      */
name|delay_change_reports
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a route report message to destination 'dst', via virtual interface  * 'vifi'.  'which_routes' specifies ALL_ROUTES or CHANGED_ROUTES.  */
end_comment

begin_function
specifier|static
name|int
name|report_chunk
parameter_list|(
name|start_rt
parameter_list|,
name|vifi
parameter_list|,
name|dst
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|start_rt
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nrt
init|=
literal|0
decl_stmt|;
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|u_int32
name|mask
init|=
literal|0
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|nflags
decl_stmt|;
name|int
name|admetric
init|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_admetric
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|src
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
name|nflags
operator|=
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
condition|?
literal|0
else|:
name|LEAF_FLAGS
expr_stmt|;
for|for
control|(
name|r
operator|=
name|start_rt
init|;
name|r
operator|!=
name|RT_ADDR
condition|;
name|r
operator|=
name|r
operator|->
name|rt_prev
control|)
block|{
ifdef|#
directive|ifdef
name|NOTYET
comment|/* Don't send poisoned routes back to parents if I am a leaf */
if|if
condition|(
operator|(
name|vifs_with_neighbors
operator|==
literal|1
operator|)
operator|&&
operator|(
name|r
operator|->
name|rt_parent
operator|==
name|vifi
operator|)
operator|&&
operator|(
name|r
operator|->
name|rt_metric
operator|>
literal|1
operator|)
condition|)
block|{
operator|++
name|nrt
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* 	 * If there is no room for this route in the current message, 	 * send it& return how many routes we sent. 	 */
if|if
condition|(
name|datalen
operator|+
operator|(
operator|(
name|r
operator|->
name|rt_originmask
operator|==
name|mask
operator|)
condition|?
operator|(
name|width
operator|+
literal|1
operator|)
else|:
operator|(
name|r
operator|->
name|rt_originwidth
operator|+
literal|4
operator|)
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
operator||
name|nflags
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
name|nrt
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|->
name|rt_originmask
operator|!=
name|mask
operator|||
name|datalen
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|r
operator|->
name|rt_originmask
expr_stmt|;
name|width
operator|=
name|r
operator|->
name|rt_originwidth
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|datalen
operator|+=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|r
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|metric
operator|=
name|r
operator|->
name|rt_metric
operator|+
name|admetric
expr_stmt|;
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
name|metric
operator|=
name|UNREACHABLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|r
operator|->
name|rt_parent
operator|==
name|vifi
operator|&&
name|metric
operator|!=
name|UNREACHABLE
operator|)
condition|?
call|(
name|char
call|)
argument_list|(
name|metric
operator|+
name|UNREACHABLE
argument_list|)
else|:
comment|/* "poisoned reverse" */
call|(
name|char
call|)
argument_list|(
name|metric
argument_list|)
expr_stmt|;
operator|++
name|nrt
expr_stmt|;
name|datalen
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
operator||
name|nflags
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nrt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * send the next chunk of our routing table to all neighbors.  * return the length of the smallest chunk we sent out.  */
end_comment

begin_function
name|int
name|report_next_chunk
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|sr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|min
init|=
literal|20000
decl_stmt|;
specifier|static
name|int
name|start_rt
decl_stmt|;
if|if
condition|(
name|nroutes
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * find this round's starting route.      */
for|for
control|(
name|sr
operator|=
name|rt_end
operator|,
name|i
operator|=
name|start_rt
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|sr
operator|=
name|sr
operator|->
name|rt_prev
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|RT_ADDR
condition|)
name|sr
operator|=
name|rt_end
expr_stmt|;
block|}
comment|/*      * send one chunk of routes starting at this round's start to      * all our neighbors.      */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
operator|)
ifdef|#
directive|ifdef
name|NOTYET
operator|&&
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
endif|#
directive|endif
condition|)
block|{
name|n
operator|=
name|report_chunk
argument_list|(
name|sr
argument_list|,
name|vifi
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|v
operator|->
name|uv_rmt_addr
else|:
name|dvmrp_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|min
condition|)
name|min
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
literal|20000
condition|)
name|min
operator|=
literal|0
expr_stmt|;
comment|/* Neighborless router didn't send any routes */
name|n
operator|=
name|min
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"update %d starting at %d of %d"
argument_list|,
name|n
argument_list|,
operator|(
name|nroutes
operator|-
name|start_rt
operator|)
argument_list|,
name|nroutes
argument_list|)
expr_stmt|;
name|start_rt
operator|=
operator|(
name|start_rt
operator|+
name|n
operator|)
operator|%
name|nroutes
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the contents of the routing table on file 'fp'.  */
end_comment

begin_function
name|void
name|dump_routes
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|vifi_t
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Multicast Routing Table (%u %s)\n%s\n"
argument_list|,
name|nroutes
argument_list|,
operator|(
name|nroutes
operator|==
literal|1
operator|)
condition|?
literal|"entry"
else|:
literal|"entries"
argument_list|,
literal|" Origin-Subnet      From-Gateway    Metric Tmr In-Vif  Out-Vifs"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-18s %-15s "
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|(
name|r
operator|->
name|rt_gateway
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|inet_fmt
argument_list|(
name|r
operator|->
name|rt_gateway
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
operator|(
name|r
operator|->
name|rt_metric
operator|==
name|UNREACHABLE
operator|)
condition|?
literal|"  NR "
else|:
literal|"%4u "
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  %3u %3u   "
argument_list|,
name|r
operator|->
name|rt_timer
argument_list|,
name|r
operator|->
name|rt_parent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %u%c"
argument_list|,
name|i
argument_list|,
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_leaves
argument_list|)
condition|?
literal|'*'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|rtentry
modifier|*
name|determine_route
parameter_list|(
name|src
parameter_list|)
name|u_int32
name|src
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|routing_table
init|;
name|rt
operator|!=
name|NULL
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_origin
operator|==
operator|(
name|src
operator|&
name|rt
operator|->
name|rt_originmask
operator|)
condition|)
break|break;
block|}
return|return
name|rt
return|;
block|}
end_function

end_unit

