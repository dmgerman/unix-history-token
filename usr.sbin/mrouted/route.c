begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * route.c,v 3.8.4.41 1998/01/15 00:08:34 fenner Exp  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Id: \ route.c,v 3.8.4.41 1998/01/15 00:08:34 fenner Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This define statement saves a lot of space later  */
end_comment

begin_define
define|#
directive|define
name|RT_ADDR
value|(struct rtentry *)&routing_table
end_define

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|int
name|routes_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>some routes have changed */
end_comment

begin_decl_stmt
name|int
name|delay_change_reports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>postpone change reports  */
end_comment

begin_comment
comment|/*  * The routing table is shared with prune.c , so must not be static.  */
end_comment

begin_decl_stmt
name|struct
name|rtentry
modifier|*
name|routing_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to list of route entries */
end_comment

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rtentry
modifier|*
name|rtp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to a route entry         */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rtentry
modifier|*
name|rt_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to last route entry      */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|nroutes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current number of route entries  */
end_comment

begin_comment
comment|/*  * Private functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|init_children_and_leaves
name|__P
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
name|r
operator|,
name|vifi_t
name|parent
operator|,
name|int
name|first
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_route
name|__P
argument_list|(
operator|(
name|u_int32
name|origin
operator|,
name|u_int32
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_route
name|__P
argument_list|(
operator|(
name|u_int32
name|origin
operator|,
name|u_int32
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|discard_route
name|__P
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
name|prev_r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_rts
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|rt1
operator|,
specifier|const
name|void
operator|*
name|rt2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|report_chunk
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|rtentry
operator|*
name|start_rt
operator|,
name|vifi_t
name|vifi
operator|,
name|u_int32
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_blaster_report
name|__P
argument_list|(
operator|(
name|vifi_t
operator|,
name|u_int32
operator|,
name|u_int32
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|u_int32
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_blaster_report
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SNMP
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"snmp.h"
end_include

begin_comment
comment|/*  * Return pointer to a specific route entry.  This must be a separate  * function from find_route() which modifies rtp.  */
end_comment

begin_function
name|struct
name|rtentry
modifier|*
name|snmp_find_route
parameter_list|(
name|src
parameter_list|,
name|mask
parameter_list|)
specifier|register
name|u_int32
name|src
decl_stmt|,
name|mask
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|routing_table
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|src
operator|==
name|rt
operator|->
name|rt_origin
operator|&&
name|mask
operator|==
name|rt
operator|->
name|rt_originmask
condition|)
return|return
name|rt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Find next route entry> specification   */
end_comment

begin_function
name|int
name|next_route
parameter_list|(
name|rtpp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|)
name|struct
name|rtentry
modifier|*
modifier|*
name|rtpp
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|,
modifier|*
name|rbest
init|=
name|NULL
decl_stmt|;
comment|/* Among all entries> spec, find "lowest" one in order */
for|for
control|(
name|rt
operator|=
name|routing_table
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|>
name|ntohl
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|==
name|ntohl
argument_list|(
name|src
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|)
operator|>
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|rbest
operator|||
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|<
name|ntohl
argument_list|(
name|rbest
operator|->
name|rt_origin
argument_list|)
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_origin
argument_list|)
operator|==
name|ntohl
argument_list|(
name|rbest
operator|->
name|rt_origin
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|rt
operator|->
name|rt_originmask
argument_list|)
operator|<
name|ntohl
argument_list|(
name|rbest
operator|->
name|rt_originmask
argument_list|)
operator|)
operator|)
condition|)
name|rbest
operator|=
name|rt
expr_stmt|;
block|}
operator|(
operator|*
name|rtpp
operator|)
operator|=
name|rbest
expr_stmt|;
return|return
operator|(
operator|*
name|rtpp
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a routing table entry, and a vifi, find the next vifi/entry  */
end_comment

begin_function
name|int
name|next_route_child
parameter_list|(
name|rtpp
parameter_list|,
name|src
parameter_list|,
name|mask
parameter_list|,
name|vifi
parameter_list|)
name|struct
name|rtentry
modifier|*
modifier|*
name|rtpp
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|vifi_t
modifier|*
name|vifi
decl_stmt|;
comment|/* vif at which to start looking */
block|{
comment|/* Get (S,M) entry */
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|rtpp
operator|)
operator|=
name|snmp_find_route
argument_list|(
name|src
argument_list|,
name|mask
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
name|next_route
argument_list|(
name|rtpp
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Continue until we get one with a valid next vif */
do|do
block|{
for|for
control|(
init|;
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_children
operator|&&
operator|*
name|vifi
operator|<
name|numvifs
condition|;
operator|(
operator|*
name|vifi
operator|)
operator|++
control|)
if|if
condition|(
name|VIFM_ISSET
argument_list|(
operator|*
name|vifi
argument_list|,
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_children
argument_list|)
condition|)
return|return
literal|1
return|;
operator|*
name|vifi
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|next_route
argument_list|(
name|rtpp
argument_list|,
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_origin
argument_list|,
operator|(
operator|*
name|rtpp
operator|)
operator|->
name|rt_originmask
argument_list|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize the routing table and associated variables.  */
end_comment

begin_function
name|void
name|init_routes
parameter_list|()
block|{
name|routing_table
operator|=
name|NULL
expr_stmt|;
name|rt_end
operator|=
name|RT_ADDR
expr_stmt|;
name|nroutes
operator|=
literal|0
expr_stmt|;
name|routes_changed
operator|=
name|FALSE
expr_stmt|;
name|delay_change_reports
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the children bits for route 'r', along with the  * associated dominant and subordinate data structures.  * If first is set, initialize dominants, otherwise keep old  * dominants on non-parent interfaces.  * XXX Does this need a return value?  */
end_comment

begin_function
specifier|static
name|int
name|init_children_and_leaves
parameter_list|(
name|r
parameter_list|,
name|parent
parameter_list|,
name|first
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|vifi_t
name|parent
decl_stmt|;
name|int
name|first
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifbitmap_t
name|old_children
decl_stmt|;
name|nbrbitmap_t
name|old_subords
decl_stmt|;
name|VIFM_COPY
argument_list|(
name|r
operator|->
name|rt_children
argument_list|,
name|old_children
argument_list|)
expr_stmt|;
name|NBRM_COPY
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|old_subords
argument_list|)
expr_stmt|;
name|VIFM_CLRALL
argument_list|(
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|first
operator|||
name|vifi
operator|==
name|parent
condition|)
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vifi
operator|==
name|parent
operator|||
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_NOFLOOD
operator|||
name|AVOID_TRANSIT
argument_list|(
name|vifi
argument_list|,
name|r
argument_list|)
operator|||
operator|(
operator|!
name|first
operator|&&
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|)
condition|)
name|NBRM_CLRMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
else|else
name|NBRM_SETMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifi
operator|!=
name|parent
operator|&&
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|!
name|first
operator|&&
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|!
name|VIFM_SAME
argument_list|(
name|r
operator|->
name|rt_children
argument_list|,
name|old_children
argument_list|)
operator|||
operator|!
name|NBRM_SAME
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|old_subords
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A new vif has come up -- update the children bitmaps in all route  * entries to take that into account.  */
end_comment

begin_function
name|void
name|add_vif_to_routes
parameter_list|(
name|vifi
parameter_list|)
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
operator|&&
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
comment|/*XXX isn't uv_nbrmap going to be empty?*/
name|NBRM_CLRMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A vif has gone down -- expire all routes that have that vif as parent,  * and update the children bitmaps in all other route entries to take into  * account the failed vif.  */
end_comment

begin_function
name|void
name|delete_vif_from_routes
parameter_list|(
name|vifi
parameter_list|)
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
block|{
if|if
condition|(
name|vifi
operator|==
name|r
operator|->
name|rt_parent
condition|)
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
name|ROUTE_EXPIRE_TIME
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|NBRM_CLRMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A new neighbor has come up.  If we're flooding on the neighbor's  * vif, mark that neighbor as subordinate for all routes whose parent  * is not this vif.  */
end_comment

begin_function
name|void
name|add_neighbor_to_routes
parameter_list|(
name|vifi
parameter_list|,
name|index
parameter_list|)
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_NOFLOOD
condition|)
return|return;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
operator|&&
name|r
operator|->
name|rt_parent
operator|!=
name|vifi
operator|&&
operator|!
name|AVOID_TRANSIT
argument_list|(
name|vifi
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|NBRM_SET
argument_list|(
name|index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A neighbor has failed or become unreachable.  If that neighbor was  * considered a dominant or subordinate router in any route entries,  * take appropriate action.  Expire all routes this neighbor advertised  * to us.  */
end_comment

begin_function
name|void
name|delete_neighbor_from_routes
parameter_list|(
name|addr
parameter_list|,
name|vifi
parameter_list|,
name|index
parameter_list|)
specifier|register
name|u_int32
name|addr
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|rt_parent
operator|==
name|vifi
operator|&&
name|r
operator|->
name|rt_gateway
operator|==
name|addr
condition|)
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
name|ROUTE_EXPIRE_TIME
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|==
name|addr
condition|)
block|{
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_NOFLOOD
operator|)
operator|||
name|AVOID_TRANSIT
argument_list|(
name|vifi
argument_list|,
name|r
argument_list|)
condition|)
name|NBRM_CLRMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
else|else
name|NBRM_SETMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NBRM_ISSET
argument_list|(
name|index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
block|{
name|NBRM_CLR
argument_list|(
name|index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Prepare for a sequence of ordered route updates by initializing a pointer  * to the start of the routing table.  The pointer is used to remember our  * position in the routing table in order to avoid searching from the  * beginning for each update; this relies on having the route reports in  * a single message be in the same order as the route entries in the routing  * table.  */
end_comment

begin_function
name|void
name|start_route_updates
parameter_list|()
block|{
name|rtp
operator|=
name|RT_ADDR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Starting at the route entry following the one to which 'rtp' points,  * look for a route entry matching the specified origin and mask.  If a  * match is found, return TRUE and leave 'rtp' pointing at the found entry.  * If no match is found, return FALSE and leave 'rtp' pointing to the route  * entry preceding the point at which the new origin should be inserted.  * This code is optimized for the normal case in which the first entry to  * be examined is the matching entry.  */
end_comment

begin_function
specifier|static
name|int
name|find_route
parameter_list|(
name|origin
parameter_list|,
name|mask
parameter_list|)
specifier|register
name|u_int32
name|origin
decl_stmt|,
name|mask
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|rtp
operator|->
name|rt_next
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|origin
operator|==
name|r
operator|->
name|rt_origin
operator|&&
name|mask
operator|==
name|r
operator|->
name|rt_originmask
condition|)
block|{
name|rtp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|mask
argument_list|)
operator|<
name|ntohl
argument_list|(
name|r
operator|->
name|rt_originmask
argument_list|)
operator|||
operator|(
name|mask
operator|==
name|r
operator|->
name|rt_originmask
operator|&&
name|ntohl
argument_list|(
name|origin
argument_list|)
operator|<
name|ntohl
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|)
operator|)
condition|)
block|{
name|rtp
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|rt_next
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new routing table entry for the specified origin and link it into  * the routing table.  The shared variable 'rtp' is assumed to point to the  * routing entry after which the new one should be inserted.  It is left  * pointing to the new entry.  *  * Only the origin, originmask, originwidth and flags fields are initialized  * in the new route entry; the caller is responsible for filling in the the  * rest.  */
end_comment

begin_function
specifier|static
name|void
name|create_route
parameter_list|(
name|origin
parameter_list|,
name|mask
parameter_list|)
name|u_int32
name|origin
decl_stmt|,
name|mask
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtentry
argument_list|)
operator|+
operator|(
name|numvifs
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
block|}
name|r
operator|->
name|rt_origin
operator|=
name|origin
expr_stmt|;
name|r
operator|->
name|rt_originmask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|r
operator|->
name|rt_originwidth
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|r
operator|->
name|rt_originwidth
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|r
operator|->
name|rt_originwidth
operator|=
literal|2
expr_stmt|;
else|else
name|r
operator|->
name|rt_originwidth
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|rt_flags
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_dominants
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|(
name|r
operator|+
literal|1
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|r
operator|->
name|rt_dominants
argument_list|,
name|numvifs
operator|*
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_groups
operator|=
name|NULL
expr_stmt|;
name|VIFM_CLRALL
argument_list|(
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|NBRM_CLRALL
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|)
expr_stmt|;
name|NBRM_CLRALL
argument_list|(
name|r
operator|->
name|rt_subordadv
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_next
operator|=
name|rtp
operator|->
name|rt_next
expr_stmt|;
name|rtp
operator|->
name|rt_next
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|rt_prev
operator|=
name|rtp
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt_next
operator|!=
name|NULL
condition|)
operator|(
name|r
operator|->
name|rt_next
operator|)
operator|->
name|rt_prev
operator|=
name|r
expr_stmt|;
else|else
name|rt_end
operator|=
name|r
expr_stmt|;
name|rtp
operator|=
name|r
expr_stmt|;
operator|++
name|nroutes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard the routing table entry following the one to which 'prev_r' points.  */
end_comment

begin_function
specifier|static
name|void
name|discard_route
parameter_list|(
name|prev_r
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|prev_r
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|prev_r
operator|->
name|rt_next
expr_stmt|;
name|uvifs
index|[
name|r
operator|->
name|rt_parent
index|]
operator|.
name|uv_nroutes
operator|--
expr_stmt|;
comment|/*???nbr???.al_nroutes--;*/
name|prev_r
operator|->
name|rt_next
operator|=
name|r
operator|->
name|rt_next
expr_stmt|;
if|if
condition|(
name|prev_r
operator|->
name|rt_next
operator|!=
name|NULL
condition|)
operator|(
name|prev_r
operator|->
name|rt_next
operator|)
operator|->
name|rt_prev
operator|=
name|prev_r
expr_stmt|;
else|else
name|rt_end
operator|=
name|prev_r
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
operator|--
name|nroutes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a route report for a single origin, creating or updating the  * corresponding routing table entry if necessary.  'src' is either the  * address of a neighboring router from which the report arrived, or zero  * to indicate a change of status of one of our own interfaces.  */
end_comment

begin_function
name|void
name|update_route
parameter_list|(
name|origin
parameter_list|,
name|mask
parameter_list|,
name|metric
parameter_list|,
name|src
parameter_list|,
name|vifi
parameter_list|,
name|n
parameter_list|)
name|u_int32
name|origin
decl_stmt|,
name|mask
decl_stmt|;
name|u_int
name|metric
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|u_int
name|adj_metric
decl_stmt|;
comment|/*      * Compute an adjusted metric, taking into account the cost of the      * subnet or tunnel over which the report arrived, and normalizing      * all unreachable/poisoned metrics into a single value.      */
if|if
condition|(
name|src
operator|!=
literal|0
operator|&&
operator|(
name|metric
operator|<
literal|1
operator|||
name|metric
operator|>=
literal|2
operator|*
name|UNREACHABLE
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports out-of-range metric %u for origin %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|metric
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|adj_metric
operator|=
name|metric
operator|+
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_metric
expr_stmt|;
if|if
condition|(
name|adj_metric
operator|>
name|UNREACHABLE
condition|)
name|adj_metric
operator|=
name|UNREACHABLE
expr_stmt|;
comment|/*      * Look up the reported origin in the routing table.      */
if|if
condition|(
operator|!
name|find_route
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|)
condition|)
block|{
comment|/* 	 * Not found. 	 * Don't create a new entry if the report says it's unreachable, 	 * or if the reported origin and mask are invalid. 	 */
if|if
condition|(
name|adj_metric
operator|==
name|UNREACHABLE
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|src
operator|!=
literal|0
operator|&&
operator|!
name|inet_valid_subnet
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports an invalid origin (%s) and/or mask (%08x)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|origin
argument_list|,
name|s2
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s advertises new route %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * OK, create the new routing entry.  'rtp' will be left pointing 	 * to the new entry. 	 */
name|create_route
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nroutes
operator|++
expr_stmt|;
comment|/*n->al_nroutes++;*/
name|rtp
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
comment|/* temporary; updated below */
block|}
comment|/*      * We now have a routing entry for the reported origin.  Update it?      */
name|r
operator|=
name|rtp
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt_metric
operator|==
name|UNREACHABLE
condition|)
block|{
comment|/* 	 * The routing entry is for a formerly-unreachable or new origin. 	 * If the report claims reachability, update the entry to use 	 * the reported route. 	 */
if|if
condition|(
name|adj_metric
operator|==
name|UNREACHABLE
condition|)
return|return;
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s advertises %s with adj_metric %d (ours was %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|adj_metric
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
comment|/* 	 * Now "steal away" any sources that belong under this route 	 * by deleting any cache entries they might have created 	 * and allowing the kernel to re-request them. 	 * 	 * If we haven't performed final initialization yet and are 	 * just collecting the routing table, we can't have any 	 * sources so we don't perform this step. 	 */
if|if
condition|(
name|did_final_init
condition|)
name|steal_sources
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_parent
operator|=
name|vifi
expr_stmt|;
name|r
operator|->
name|rt_gateway
operator|=
name|src
expr_stmt|;
name|init_children_and_leaves
argument_list|(
name|r
argument_list|,
name|vifi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|adj_metric
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|==
name|r
operator|->
name|rt_gateway
condition|)
block|{
comment|/* 	 * The report has come either from the interface directly-connected 	 * to the origin subnet (src and r->rt_gateway both equal zero) or 	 * from the gateway we have chosen as the best first-hop gateway back 	 * towards the origin (src and r->rt_gateway not equal zero).  Reset 	 * the route timer and, if the reported metric has changed, update 	 * our entry accordingly. 	 */
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (current parent) advertises %s with adj_metric %d (ours was %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|adj_metric
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj_metric
operator|==
name|r
operator|->
name|rt_metric
condition|)
return|return;
if|if
condition|(
name|adj_metric
operator|==
name|UNREACHABLE
condition|)
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_timer
operator|=
name|ROUTE_EXPIRE_TIME
expr_stmt|;
block|}
name|r
operator|->
name|rt_metric
operator|=
name|adj_metric
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|==
literal|0
operator|||
operator|(
name|r
operator|->
name|rt_gateway
operator|!=
literal|0
operator|&&
operator|(
name|adj_metric
operator|<
name|r
operator|->
name|rt_metric
operator|||
operator|(
name|adj_metric
operator|==
name|r
operator|->
name|rt_metric
operator|&&
operator|(
name|ntohl
argument_list|(
name|src
argument_list|)
operator|<
name|ntohl
argument_list|(
name|r
operator|->
name|rt_gateway
argument_list|)
operator|||
name|r
operator|->
name|rt_timer
operator|>=
name|ROUTE_SWITCH_TIME
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 	 * The report is for an origin we consider reachable; the report 	 * comes either from one of our own interfaces or from a gateway 	 * other than the one we have chosen as the best first-hop gateway 	 * back towards the origin.  If the source of the update is one of 	 * our own interfaces, or if the origin is not a directly-connected 	 * subnet and the reported metric for that origin is better than 	 * what our routing entry says, update the entry to use the new 	 * gateway and metric.  We also switch gateways if the reported 	 * metric is the same as the one in the route entry and the gateway 	 * associated with the route entry has not been heard from recently, 	 * or if the metric is the same but the reporting gateway has a lower 	 * IP address than the gateway associated with the route entry. 	 * Did you get all that? 	 */
name|u_int32
name|old_gateway
decl_stmt|;
name|vifi_t
name|old_parent
decl_stmt|;
name|old_gateway
operator|=
name|r
operator|->
name|rt_gateway
expr_stmt|;
name|old_parent
operator|=
name|r
operator|->
name|rt_parent
expr_stmt|;
name|r
operator|->
name|rt_gateway
operator|=
name|src
expr_stmt|;
name|r
operator|->
name|rt_parent
operator|=
name|vifi
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (new parent) on vif %d advertises %s with adj_metric %d (old parent was %s on vif %d, metric %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|adj_metric
argument_list|,
name|inet_fmt
argument_list|(
name|old_gateway
argument_list|,
name|s3
argument_list|)
argument_list|,
name|old_parent
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_parent
operator|!=
name|vifi
condition|)
block|{
name|init_children_and_leaves
argument_list|(
name|r
argument_list|,
name|vifi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|old_parent
index|]
operator|.
name|uv_nroutes
operator|--
expr_stmt|;
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nroutes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|old_gateway
operator|!=
name|src
condition|)
block|{
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|old_gateway
argument_list|)
expr_stmt|;
comment|/*???old_gateway???->al_nroutes--;*/
comment|/*n->al_nroutes++;*/
block|}
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|adj_metric
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vifi
operator|!=
name|r
operator|->
name|rt_parent
condition|)
block|{
comment|/* 	 * The report came from a vif other than the route's parent vif. 	 * Update the children info, if necessary. 	 */
if|if
condition|(
name|AVOID_TRANSIT
argument_list|(
name|vifi
argument_list|,
name|r
argument_list|)
condition|)
block|{
comment|/* 	     * The route's parent is a vif from which we're not supposed 	     * to transit onto this vif.  Simply ignore the update. 	     */
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d advertises %s with metric %d (ignored due to NOTRANSIT)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
comment|/* 	     * Vif is a child vif for this route. 	     */
if|if
condition|(
name|metric
operator|<
name|r
operator|->
name|rt_metric
operator|||
operator|(
name|metric
operator|==
name|r
operator|->
name|rt_metric
operator|&&
name|ntohl
argument_list|(
name|src
argument_list|)
operator|<
name|ntohl
argument_list|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Neighbor has lower metric to origin (or has same metric 		 * and lower IP address) -- it becomes the dominant router, 		 * and vif is no longer a child for me. 		 */
name|VIFM_CLR
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
name|src
expr_stmt|;
comment|/* XXX 		 * We don't necessarily want to forget about subordinateness 		 * so that we can become the dominant quickly if the current 		 * dominant fails. 		 */
name|NBRM_CLRMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d becomes dominant for %s with metric %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
block|{
comment|/* "poisoned reverse" */
comment|/* 		 * Neighbor considers this vif to be on path to route's 		 * origin; record this neighbor as subordinate 		 */
if|if
condition|(
operator|!
name|NBRM_ISSET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d becomes subordinate for %s with poison-reverse metric %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
operator|-
name|UNREACHABLE
argument_list|)
expr_stmt|;
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d confirms subordinateness for %s with poison-reverse metric %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
operator|-
name|UNREACHABLE
argument_list|)
expr_stmt|;
block|}
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordadv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NBRM_ISSET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
block|{
comment|/* 		 * Current subordinate no longer considers this vif to be on 		 * path to route's origin; it is no longer a subordinate 		 * router. 		 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d is no longer a subordinate for %s with metric %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
argument_list|)
expr_stmt|;
name|NBRM_CLR
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|==
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|&&
operator|(
name|metric
operator|>
name|r
operator|->
name|rt_metric
operator|||
operator|(
name|metric
operator|==
name|r
operator|->
name|rt_metric
operator|&&
name|ntohl
argument_list|(
name|src
argument_list|)
operator|>
name|ntohl
argument_list|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_lcl_addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 	     * Current dominant no longer has a lower metric to origin 	     * (or same metric and lower IP address); we adopt the vif 	     * as our own child. 	     */
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s (current dominant) on vif %d is no longer dominant for %s with metric %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
argument_list|)
expr_stmt|;
name|VIFM_SET
argument_list|(
name|vifi
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_dominants
index|[
name|vifi
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_NOFLOOD
condition|)
name|NBRM_CLRMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
else|else
name|NBRM_SETMASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_nbrmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
block|{
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
expr_stmt|;
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordadv
argument_list|)
expr_stmt|;
block|}
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_RTDETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d advertises %s with metric %d (ignored)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|inet_fmts
argument_list|(
name|origin
argument_list|,
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance the timer in each routing entry.  */
end_comment

begin_function
name|void
name|age_routes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|prev_r
decl_stmt|;
specifier|extern
name|u_long
name|virtual_time
decl_stmt|;
comment|/* from main.c */
for|for
control|(
name|prev_r
operator|=
name|RT_ADDR
operator|,
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|prev_r
operator|=
name|r
operator|,
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|->
name|rt_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|>=
name|ROUTE_DISCARD_TIME
condition|)
block|{
comment|/* 	     * Time to garbage-collect the route entry. 	     */
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|discard_route
argument_list|(
name|prev_r
argument_list|)
expr_stmt|;
name|r
operator|=
name|prev_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|rt_timer
operator|>=
name|ROUTE_EXPIRE_TIME
operator|&&
name|r
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
block|{
comment|/* 	     * Time to expire the route entry.  If the gateway is zero, 	     * i.e., it is a route to a directly-connected subnet, just 	     * set the timer back to zero; such routes expire only when 	     * the interface to the subnet goes down. 	     */
if|if
condition|(
name|r
operator|->
name|rt_gateway
operator|==
literal|0
condition|)
block|{
name|r
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|del_table_entry
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|DEL_ALL_ROUTES
argument_list|)
expr_stmt|;
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|virtual_time
operator|%
operator|(
name|ROUTE_REPORT_INTERVAL
operator|*
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Time out subordinateness that hasn't been reported in 	     * the last 2 intervals. 	     */
if|if
condition|(
operator|!
name|NBRM_SAME
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|r
operator|->
name|rt_subordadv
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rt %s sub 0x%08x%08x subadv 0x%08x%08x metric %d"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|r
operator|->
name|rt_subordinates
operator|.
name|hi
argument_list|,
name|r
operator|->
name|rt_subordinates
operator|.
name|lo
argument_list|,
name|r
operator|->
name|rt_subordadv
operator|.
name|hi
argument_list|,
name|r
operator|->
name|rt_subordadv
operator|.
name|lo
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
name|NBRM_MASK
argument_list|(
name|r
operator|->
name|rt_subordinates
argument_list|,
name|r
operator|->
name|rt_subordadv
argument_list|)
expr_stmt|;
name|update_table_entry
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
block|}
name|NBRM_CLRALL
argument_list|(
name|r
operator|->
name|rt_subordadv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Mark all routes as unreachable.  This function is called only from  * hup() in preparation for informing all neighbors that we are going  * off the air.  For consistency, we ought also to delete all reachable  * route entries from the kernel, but since we are about to exit we rely  * on the kernel to do its own cleanup -- no point in making all those  * expensive kernel calls now.  */
end_comment

begin_function
name|void
name|expire_all_routes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|r
operator|->
name|rt_metric
operator|=
name|UNREACHABLE
expr_stmt|;
name|r
operator|->
name|rt_flags
operator||=
name|RTF_CHANGED
expr_stmt|;
name|routes_changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete all the routes in the routing table.  */
end_comment

begin_function
name|void
name|free_all_routes
parameter_list|()
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|RT_ADDR
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|rt_next
condition|)
name|discard_route
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor probe message.  */
end_comment

begin_function
name|void
name|accept_probe
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|level
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|static
name|struct
name|listaddr
modifier|*
name|unknowns
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|match
init|=
name|NULL
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|unknowns
operator|,
name|a
operator|=
operator|*
name|prev
init|;
name|a
condition|;
name|a
operator|=
operator|*
name|prev
control|)
block|{
if|if
condition|(
name|a
operator|->
name|al_addr
operator|==
name|src
condition|)
name|match
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|al_ctime
operator|+
literal|2
operator|*
name|a
operator|->
name|al_timer
operator|<
name|now
condition|)
block|{
comment|/* We haven't heard from it in a long time */
operator|*
name|prev
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
operator|&
name|a
operator|->
name|al_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
block|{
name|match
operator|=
operator|*
name|prev
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
name|match
operator|->
name|al_next
operator|=
name|NULL
expr_stmt|;
name|match
operator|->
name|al_addr
operator|=
name|src
expr_stmt|;
name|match
operator|->
name|al_timer
operator|=
name|OLD_NEIGHBOR_EXPIRE_TIME
expr_stmt|;
name|match
operator|->
name|al_ctime
operator|=
name|now
operator|-
name|match
operator|->
name|al_timer
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|->
name|al_ctime
operator|+
name|match
operator|->
name|al_timer
operator|<=
name|now
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"ignoring probe from non-neighbor %s, check for misconfigured tunnel or routing on %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|match
operator|->
name|al_timer
operator|*=
literal|2
expr_stmt|;
block|}
else|else
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring probe from non-neighbor %s (%d seconds until next warning)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|match
operator|->
name|al_ctime
operator|+
name|match
operator|->
name|al_timer
operator|-
name|now
argument_list|)
expr_stmt|;
return|return;
block|}
name|update_neighbor
argument_list|(
name|vifi
argument_list|,
name|src
argument_list|,
name|DVMRP_PROBE
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|newrt
block|{
name|u_int32
name|mask
decl_stmt|;
name|u_int32
name|origin
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|int
name|pad
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|compare_rts
parameter_list|(
name|rt1
parameter_list|,
name|rt2
parameter_list|)
specifier|const
name|void
modifier|*
name|rt1
decl_stmt|;
specifier|const
name|void
modifier|*
name|rt2
decl_stmt|;
block|{
specifier|register
name|struct
name|newrt
modifier|*
name|r1
init|=
operator|(
expr|struct
name|newrt
operator|*
operator|)
name|rt1
decl_stmt|;
specifier|register
name|struct
name|newrt
modifier|*
name|r2
init|=
operator|(
expr|struct
name|newrt
operator|*
operator|)
name|rt2
decl_stmt|;
specifier|register
name|u_int32
name|m1
init|=
name|ntohl
argument_list|(
name|r1
operator|->
name|mask
argument_list|)
decl_stmt|;
specifier|register
name|u_int32
name|m2
init|=
name|ntohl
argument_list|(
name|r2
operator|->
name|mask
argument_list|)
decl_stmt|;
specifier|register
name|u_int32
name|o1
decl_stmt|,
name|o2
decl_stmt|;
if|if
condition|(
name|m1
operator|>
name|m2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|m1
operator|<
name|m2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* masks are equal */
name|o1
operator|=
name|ntohl
argument_list|(
name|r1
operator|->
name|origin
argument_list|)
expr_stmt|;
name|o2
operator|=
name|ntohl
argument_list|(
name|r2
operator|->
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|o1
operator|>
name|o2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|o1
operator|<
name|o2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|blaster_alloc
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_blasterbuf
condition|)
name|free
argument_list|(
name|v
operator|->
name|uv_blasterbuf
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blasterlen
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|v
operator|->
name|uv_blasterbuf
operator|=
name|malloc
argument_list|(
name|v
operator|->
name|uv_blasterlen
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blastercur
operator|=
name|v
operator|->
name|uv_blasterend
operator|=
name|v
operator|->
name|uv_blasterbuf
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_blastertimer
condition|)
name|timer_clearTimer
argument_list|(
name|v
operator|->
name|uv_blastertimer
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blastertimer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|blaster_hdr
block|{
name|u_int32
name|bh_src
decl_stmt|;
name|u_int32
name|bh_dst
decl_stmt|;
name|u_int32
name|bh_level
decl_stmt|;
name|int
name|bh_datalen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Queue a route report from a route-blaster.  * If the timer isn't running to process these reports,  * start it.  */
end_comment

begin_function
specifier|static
name|void
name|queue_blaster_report
parameter_list|(
name|vifi
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|datalen
decl_stmt|;
block|{
specifier|register
name|struct
name|blaster_hdr
modifier|*
name|bh
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|bblen
init|=
sizeof|sizeof
argument_list|(
operator|*
name|bh
argument_list|)
operator|+
operator|(
operator|(
name|datalen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_blasterend
operator|-
name|v
operator|->
name|uv_blasterbuf
operator|+
name|bblen
operator|>
name|v
operator|->
name|uv_blasterlen
condition|)
block|{
name|int
name|end
init|=
name|v
operator|->
name|uv_blasterend
operator|-
name|v
operator|->
name|uv_blasterbuf
decl_stmt|;
name|int
name|cur
init|=
name|v
operator|->
name|uv_blastercur
operator|-
name|v
operator|->
name|uv_blasterbuf
decl_stmt|;
name|v
operator|->
name|uv_blasterlen
operator|*=
literal|2
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"increasing blasterbuf to %d bytes"
argument_list|,
name|v
operator|->
name|uv_blasterlen
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blasterbuf
operator|=
name|realloc
argument_list|(
name|v
operator|->
name|uv_blasterbuf
argument_list|,
name|v
operator|->
name|uv_blasterlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_blasterbuf
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|ENOMEM
argument_list|,
literal|"turning off blaster on vif %d"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blasterlen
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_blasterend
operator|=
name|v
operator|->
name|uv_blastercur
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_BLASTER
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|uv_blasterend
operator|=
name|v
operator|->
name|uv_blasterbuf
operator|+
name|end
expr_stmt|;
name|v
operator|->
name|uv_blastercur
operator|=
name|v
operator|->
name|uv_blasterbuf
operator|+
name|cur
expr_stmt|;
block|}
name|bh
operator|=
operator|(
expr|struct
name|blaster_hdr
operator|*
operator|)
name|v
operator|->
name|uv_blasterend
expr_stmt|;
name|bh
operator|->
name|bh_src
operator|=
name|src
expr_stmt|;
name|bh
operator|->
name|bh_dst
operator|=
name|dst
expr_stmt|;
name|bh
operator|->
name|bh_level
operator|=
name|level
expr_stmt|;
name|bh
operator|->
name|bh_datalen
operator|=
name|datalen
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|bh
operator|+
literal|1
operator|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blasterend
operator|+=
name|bblen
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_blastertimer
operator|==
literal|0
condition|)
block|{
name|int
modifier|*
name|i
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
name|vifi
expr_stmt|;
name|v
operator|->
name|uv_blastertimer
operator|=
name|timer_setTimer
argument_list|(
literal|5
argument_list|,
name|process_blaster_report
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Periodic process; process up to 5 of the routes in the route-blaster  * queue.  If there are more routes remaining, reschedule myself to run  * in 1 second.  */
end_comment

begin_function
specifier|static
name|void
name|process_blaster_report
parameter_list|(
name|vifip
parameter_list|)
name|void
modifier|*
name|vifip
decl_stmt|;
block|{
name|vifi_t
name|vifi
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|vifip
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|blaster_hdr
modifier|*
name|bh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"processing vif %d blasted routes"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_blastercur
operator|>=
name|v
operator|->
name|uv_blasterend
condition|)
break|break;
name|bh
operator|=
operator|(
expr|struct
name|blaster_hdr
operator|*
operator|)
name|v
operator|->
name|uv_blastercur
expr_stmt|;
name|v
operator|->
name|uv_blastercur
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|bh
argument_list|)
operator|+
operator|(
operator|(
name|bh
operator|->
name|bh_datalen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|accept_report
argument_list|(
name|bh
operator|->
name|bh_src
argument_list|,
name|bh
operator|->
name|bh_dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|bh
operator|+
literal|1
operator|)
argument_list|,
operator|-
name|bh
operator|->
name|bh_datalen
argument_list|,
name|bh
operator|->
name|bh_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|uv_blastercur
operator|>=
name|v
operator|->
name|uv_blasterend
condition|)
block|{
name|v
operator|->
name|uv_blastercur
operator|=
name|v
operator|->
name|uv_blasterbuf
expr_stmt|;
name|v
operator|->
name|uv_blasterend
operator|=
name|v
operator|->
name|uv_blasterbuf
expr_stmt|;
name|v
operator|->
name|uv_blastertimer
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|vifip
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"finish processing vif %d blaster"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"more blasted routes to come on vif %d"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_blastertimer
operator|=
name|timer_setTimer
argument_list|(
literal|1
argument_list|,
name|process_blaster_report
argument_list|,
name|vifip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an incoming route report message.  * If the report arrived on a vif marked as a "blaster", then just  * queue it and return; queue_blaster_report() will schedule it for  * processing later.  If datalen is negative, then this is actually  * a queued report so actually process it instead of queueing it.  */
end_comment

begin_function
name|void
name|accept_report
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|datalen
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|int
name|width
decl_stmt|,
name|i
decl_stmt|,
name|nrt
init|=
literal|0
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|u_int32
name|mask
decl_stmt|;
name|u_int32
name|origin
decl_stmt|;
name|struct
name|newrt
name|rt
index|[
literal|4096
index|]
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|nbr
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring route report from non-neighbor %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_BLASTER
condition|)
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|queue_blaster_report
argument_list|(
name|vifi
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|datalen
operator|=
operator|-
name|datalen
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|nbr
operator|=
name|update_neighbor
argument_list|(
name|vifi
argument_list|,
name|src
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|datalen
operator|>
literal|2
operator|*
literal|4096
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring oversize (%d bytes) route report from %s"
argument_list|,
name|datalen
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
comment|/* Loop through per-mask lists. */
if|if
condition|(
name|datalen
operator|<
literal|3
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated route report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|width
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|width
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|width
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|inet_valid_mask
argument_list|(
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports bogus netmask 0x%08x (%s)"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mask
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|datalen
operator|-=
literal|3
expr_stmt|;
do|do
block|{
comment|/* Loop through (origin, metric) pairs */
if|if
condition|(
name|datalen
operator|<
name|width
operator|+
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated route report from %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|origin
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|origin
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|metric
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|datalen
operator|-=
name|width
operator|+
literal|1
expr_stmt|;
name|rt
index|[
name|nrt
index|]
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|rt
index|[
name|nrt
index|]
operator|.
name|origin
operator|=
name|origin
expr_stmt|;
name|rt
index|[
name|nrt
index|]
operator|.
name|metric
operator|=
operator|(
name|metric
operator|&
literal|0x7f
operator|)
expr_stmt|;
operator|++
name|nrt
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|metric
operator|&
literal|0x80
operator|)
condition|)
do|;
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
argument_list|,
name|nrt
argument_list|,
sizeof|sizeof
argument_list|(
name|rt
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_rts
argument_list|)
expr_stmt|;
name|start_route_updates
argument_list|()
expr_stmt|;
comment|/*      * If the last entry is default, change mask from 0xff000000 to 0      */
if|if
condition|(
name|rt
index|[
name|nrt
operator|-
literal|1
index|]
operator|.
name|origin
operator|==
literal|0
condition|)
name|rt
index|[
name|nrt
operator|-
literal|1
index|]
operator|.
name|mask
operator|=
literal|0
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Updating %d routes from %s to %s"
argument_list|,
name|nrt
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|rt
index|[
name|i
index|]
operator|.
name|origin
operator|==
name|rt
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|origin
operator|&&
name|rt
index|[
name|i
index|]
operator|.
name|mask
operator|==
name|rt
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|mask
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s reports duplicate route for %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmts
argument_list|(
name|rt
index|[
name|i
index|]
operator|.
name|origin
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Only filter non-poisoned updates. */
if|if
condition|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_filter
operator|&&
name|rt
index|[
name|i
index|]
operator|.
name|metric
operator|<
name|UNREACHABLE
condition|)
block|{
name|struct
name|vf_element
modifier|*
name|vfe
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
for|for
control|(
name|vfe
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_filter
operator|->
name|vf_filter
init|;
name|vfe
condition|;
name|vfe
operator|=
name|vfe
operator|->
name|vfe_next
control|)
block|{
if|if
condition|(
name|vfe
operator|->
name|vfe_flags
operator|&
name|VFEF_EXACT
condition|)
block|{
if|if
condition|(
operator|(
name|vfe
operator|->
name|vfe_addr
operator|==
name|rt
index|[
name|i
index|]
operator|.
name|origin
operator|)
operator|&&
operator|(
name|vfe
operator|->
name|vfe_mask
operator|==
name|rt
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rt
index|[
name|i
index|]
operator|.
name|origin
operator|&
name|vfe
operator|->
name|vfe_mask
operator|)
operator|==
name|vfe
operator|->
name|vfe_addr
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_filter
operator|->
name|vf_type
operator|==
name|VFT_ACCEPT
operator|&&
name|match
operator|==
literal|0
operator|)
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_filter
operator|->
name|vf_type
operator|==
name|VFT_DENY
operator|&&
name|match
operator|==
literal|1
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s skipped on vif %d because it %s %s"
argument_list|,
name|inet_fmts
argument_list|(
name|rt
index|[
name|i
index|]
operator|.
name|origin
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|match
condition|?
literal|"matches"
else|:
literal|"doesn't match"
argument_list|,
name|match
condition|?
name|inet_fmts
argument_list|(
name|vfe
operator|->
name|vfe_addr
argument_list|,
name|vfe
operator|->
name|vfe_mask
argument_list|,
name|s2
argument_list|)
else|:
literal|"the filter"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|rt[i].metric += vfe->vfe_addmetric; 		    if (rt[i].metric> UNREACHABLE)
endif|#
directive|endif
name|rt
index|[
name|i
index|]
operator|.
name|metric
operator|=
name|UNREACHABLE
expr_stmt|;
block|}
block|}
name|update_route
argument_list|(
name|rt
index|[
name|i
index|]
operator|.
name|origin
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|rt
index|[
name|i
index|]
operator|.
name|metric
argument_list|,
name|src
argument_list|,
name|vifi
argument_list|,
name|nbr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|routes_changed
operator|&&
operator|!
name|delay_change_reports
condition|)
name|report_to_all_neighbors
argument_list|(
name|CHANGED_ROUTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a route report message to destination 'dst', via virtual interface  * 'vifi'.  'which_routes' specifies ALL_ROUTES or CHANGED_ROUTES.  */
end_comment

begin_function
name|void
name|report
parameter_list|(
name|which_routes
parameter_list|,
name|vifi
parameter_list|,
name|dst
parameter_list|)
name|int
name|which_routes
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|r
operator|=
name|rt_end
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|RT_ADDR
condition|)
block|{
name|i
operator|=
name|report_chunk
argument_list|(
name|which_routes
argument_list|,
name|r
argument_list|,
name|vifi
argument_list|,
name|dst
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|r
operator|=
name|r
operator|->
name|rt_prev
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a route report message to all neighboring routers.  * 'which_routes' specifies ALL_ROUTES or CHANGED_ROUTES.  */
end_comment

begin_function
name|void
name|report_to_all_neighbors
parameter_list|(
name|which_routes
parameter_list|)
name|int
name|which_routes
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
name|int
name|routes_changed_before
decl_stmt|;
comment|/*      * Remember the state of the global routes_changed flag before      * generating the reports, and clear the flag.      */
name|routes_changed_before
operator|=
name|routes_changed
expr_stmt|;
name|routes_changed
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|which_routes
argument_list|,
name|vifi
argument_list|,
name|v
operator|->
name|uv_dst_addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If there were changed routes before we sent the reports AND      * if no new changes occurred while sending the reports, clear      * the change flags in the individual route entries.  If changes      * did occur while sending the reports, new reports will be      * generated at the next timer interrupt.      */
if|if
condition|(
name|routes_changed_before
operator|&&
operator|!
name|routes_changed
condition|)
block|{
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|r
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_CHANGED
expr_stmt|;
block|}
block|}
comment|/*      * Set a flag to inhibit further reports of changed routes until the      * next timer interrupt.  This is to alleviate update storms.      */
name|delay_change_reports
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a route report message to destination 'dst', via virtual interface  * 'vifi'.  'which_routes' specifies ALL_ROUTES or CHANGED_ROUTES.  */
end_comment

begin_function
specifier|static
name|int
name|report_chunk
parameter_list|(
name|which_routes
parameter_list|,
name|start_rt
parameter_list|,
name|vifi
parameter_list|,
name|dst
parameter_list|)
name|int
name|which_routes
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|start_rt
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nrt
init|=
literal|0
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|vifi
index|]
decl_stmt|;
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|u_int32
name|mask
init|=
literal|0
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|int
name|admetric
init|=
name|v
operator|->
name|uv_admetric
decl_stmt|;
name|int
name|metric
decl_stmt|;
name|src
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
for|for
control|(
name|r
operator|=
name|start_rt
init|;
name|r
operator|!=
name|RT_ADDR
condition|;
name|r
operator|=
name|r
operator|->
name|rt_prev
control|)
block|{
if|if
condition|(
name|which_routes
operator|==
name|CHANGED_ROUTES
operator|&&
operator|!
operator|(
name|r
operator|->
name|rt_flags
operator|&
name|RTF_CHANGED
operator|)
condition|)
block|{
name|nrt
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Do not poison-reverse a route for a directly-connected 	 * subnetwork on that subnetwork.  This can cause loops when 	 * some router on the subnetwork is misconfigured. 	 */
if|if
condition|(
name|r
operator|->
name|rt_gateway
operator|==
literal|0
operator|&&
name|r
operator|->
name|rt_parent
operator|==
name|vifi
condition|)
block|{
name|nrt
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|v
operator|->
name|uv_filter
operator|&&
name|v
operator|->
name|uv_filter
operator|->
name|vf_flags
operator|&
name|VFF_BIDIR
condition|)
block|{
name|struct
name|vf_element
modifier|*
name|vfe
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
for|for
control|(
name|vfe
operator|=
name|v
operator|->
name|uv_filter
operator|->
name|vf_filter
init|;
name|vfe
condition|;
name|vfe
operator|=
name|vfe
operator|->
name|vfe_next
control|)
block|{
if|if
condition|(
name|vfe
operator|->
name|vfe_flags
operator|&
name|VFEF_EXACT
condition|)
block|{
if|if
condition|(
operator|(
name|vfe
operator|->
name|vfe_addr
operator|==
name|r
operator|->
name|rt_origin
operator|)
operator|&&
operator|(
name|vfe
operator|->
name|vfe_mask
operator|==
name|r
operator|->
name|rt_originmask
operator|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|->
name|rt_origin
operator|&
name|vfe
operator|->
name|vfe_mask
operator|)
operator|==
name|vfe
operator|->
name|vfe_addr
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|v
operator|->
name|uv_filter
operator|->
name|vf_type
operator|==
name|VFT_ACCEPT
operator|&&
name|match
operator|==
literal|0
operator|)
operator|||
operator|(
name|v
operator|->
name|uv_filter
operator|->
name|vf_type
operator|==
name|VFT_DENY
operator|&&
name|match
operator|==
literal|1
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s not reported on vif %d because it %s %s"
argument_list|,
name|RT_FMT
argument_list|(
name|r
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|match
condition|?
literal|"matches"
else|:
literal|"doesn't match"
argument_list|,
name|match
condition|?
name|inet_fmts
argument_list|(
name|vfe
operator|->
name|vfe_addr
argument_list|,
name|vfe
operator|->
name|vfe_mask
argument_list|,
name|s2
argument_list|)
else|:
literal|"the filter"
argument_list|)
expr_stmt|;
name|nrt
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	 * If there is no room for this route in the current message, 	 * send it& return how many routes we sent. 	 */
if|if
condition|(
name|datalen
operator|+
operator|(
operator|(
name|r
operator|->
name|rt_originmask
operator|==
name|mask
operator|)
condition|?
operator|(
name|width
operator|+
literal|1
operator|)
else|:
operator|(
name|r
operator|->
name|rt_originwidth
operator|+
literal|4
operator|)
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
name|send_on_vif
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
name|nrt
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|->
name|rt_originmask
operator|!=
name|mask
operator|||
name|datalen
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|r
operator|->
name|rt_originmask
expr_stmt|;
name|width
operator|=
name|r
operator|->
name|rt_originwidth
expr_stmt|;
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|datalen
operator|+=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|r
operator|->
name|rt_origin
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|metric
operator|=
name|r
operator|->
name|rt_metric
operator|+
name|admetric
expr_stmt|;
if|if
condition|(
name|metric
operator|>
name|UNREACHABLE
condition|)
name|metric
operator|=
name|UNREACHABLE
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rt_parent
operator|!=
name|vifi
operator|&&
name|AVOID_TRANSIT
argument_list|(
name|vifi
argument_list|,
name|r
argument_list|)
condition|)
name|metric
operator|=
name|UNREACHABLE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|r
operator|->
name|rt_parent
operator|==
name|vifi
operator|&&
name|metric
operator|!=
name|UNREACHABLE
operator|)
condition|?
call|(
name|char
call|)
argument_list|(
name|metric
operator|+
name|UNREACHABLE
argument_list|)
else|:
comment|/* "poisoned reverse" */
call|(
name|char
call|)
argument_list|(
name|metric
argument_list|)
expr_stmt|;
operator|++
name|nrt
expr_stmt|;
name|datalen
operator|+=
name|width
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator||=
literal|0x80
expr_stmt|;
name|send_on_vif
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|DVMRP_REPORT
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nrt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * send the next chunk of our routing table to all neighbors.  * return the length of the smallest chunk we sent out.  */
end_comment

begin_function
name|int
name|report_next_chunk
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|sr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|min
init|=
literal|20000
decl_stmt|;
specifier|static
name|int
name|start_rt
decl_stmt|;
if|if
condition|(
name|nroutes
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * find this round's starting route.      */
for|for
control|(
name|sr
operator|=
name|rt_end
operator|,
name|i
operator|=
name|start_rt
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|sr
operator|=
name|sr
operator|->
name|rt_prev
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|RT_ADDR
condition|)
name|sr
operator|=
name|rt_end
expr_stmt|;
block|}
comment|/*      * send one chunk of routes starting at this round's start to      * all our neighbors.      */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
block|{
name|n
operator|=
name|report_chunk
argument_list|(
name|ALL_ROUTES
argument_list|,
name|sr
argument_list|,
name|vifi
argument_list|,
name|v
operator|->
name|uv_dst_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|min
condition|)
name|min
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
literal|20000
condition|)
name|min
operator|=
literal|0
expr_stmt|;
comment|/* Neighborless router didn't send any routes */
name|n
operator|=
name|min
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_ROUTE
argument_list|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"update %d starting at %d of %d"
argument_list|,
name|n
argument_list|,
operator|(
name|nroutes
operator|-
name|start_rt
operator|)
argument_list|,
name|nroutes
argument_list|)
expr_stmt|;
name|start_rt
operator|=
operator|(
name|start_rt
operator|+
name|n
operator|)
operator|%
name|nroutes
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the contents of the routing table on file 'fp'.  */
end_comment

begin_function
name|void
name|dump_routes
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|r
decl_stmt|;
specifier|register
name|vifi_t
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Multicast Routing Table (%u %s)\n%s\n"
argument_list|,
name|nroutes
argument_list|,
operator|(
name|nroutes
operator|==
literal|1
operator|)
condition|?
literal|"entry"
else|:
literal|"entries"
argument_list|,
literal|" Origin-Subnet      From-Gateway    Metric Tmr Fl In-Vif  Out-Vifs"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|routing_table
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|rt_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-18s %-15s "
argument_list|,
name|inet_fmts
argument_list|(
name|r
operator|->
name|rt_origin
argument_list|,
name|r
operator|->
name|rt_originmask
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|(
name|r
operator|->
name|rt_gateway
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|inet_fmt
argument_list|(
name|r
operator|->
name|rt_gateway
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
operator|(
name|r
operator|->
name|rt_metric
operator|==
name|UNREACHABLE
operator|)
condition|?
literal|"  NR "
else|:
literal|"%4u "
argument_list|,
name|r
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  %3u %c%c %3u   "
argument_list|,
name|r
operator|->
name|rt_timer
argument_list|,
operator|(
name|r
operator|->
name|rt_flags
operator|&
name|RTF_CHANGED
operator|)
condition|?
literal|'C'
else|:
literal|'.'
argument_list|,
operator|(
name|r
operator|->
name|rt_flags
operator|&
name|RTF_HOLDDOWN
operator|)
condition|?
literal|'H'
else|:
literal|'.'
argument_list|,
name|r
operator|->
name|rt_parent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|listaddr
modifier|*
name|n
decl_stmt|;
name|char
name|l
init|=
literal|'['
decl_stmt|;
if|if
condition|(
name|VIFM_ISSET
argument_list|(
name|i
argument_list|,
name|r
operator|->
name|rt_children
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
operator|!
name|NBRM_ISSETMASK
argument_list|(
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
comment|/* Don't print out parenthood of a leaf tunnel. */
continue|continue;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NBRM_ISSETMASK
argument_list|(
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_nbrmap
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_neighbors
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|NBRM_ISSET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|r
operator|->
name|rt_subordinates
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c%d"
argument_list|,
name|l
argument_list|,
name|n
operator|->
name|al_index
argument_list|)
expr_stmt|;
name|l
operator|=
literal|','
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|==
literal|','
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|rtentry
modifier|*
name|determine_route
parameter_list|(
name|src
parameter_list|)
name|u_int32
name|src
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|routing_table
init|;
name|rt
operator|!=
name|NULL
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_origin
operator|==
operator|(
name|src
operator|&
name|rt
operator|->
name|rt_originmask
operator|)
operator|&&
name|rt
operator|->
name|rt_metric
operator|!=
name|UNREACHABLE
condition|)
break|break;
block|}
return|return
name|rt
return|;
block|}
end_function

end_unit

