begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  *  * vif.c,v 3.8.4.56.2.1 1999/01/20 05:18:50 fenner Exp  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|struct
name|uvif
name|uvifs
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of virtual interfaces		    */
end_comment

begin_decl_stmt
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of vifs in use	    	    */
end_comment

begin_decl_stmt
name|int
name|vifs_down
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>some interfaces are down	    	    */
end_comment

begin_decl_stmt
name|int
name|phys_vif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An enabled vif		    	    */
end_comment

begin_decl_stmt
name|int
name|udp_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since the honkin' kernel doesn't support */
end_comment

begin_comment
comment|/* ioctls on raw IP sockets, we need a UDP  */
end_comment

begin_comment
comment|/* socket as well as our IGMP (raw) socket. */
end_comment

begin_comment
comment|/* How dumb.                                */
end_comment

begin_decl_stmt
name|int
name|vifs_with_neighbors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* == 1 if I am a leaf		    */
end_comment

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
name|struct
name|listaddr
modifier|*
name|nbrs
index|[
name|MAXNBRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of neighbors			    */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
name|int
name|q_time
decl_stmt|;
block|}
name|cbk_t
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|start_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_vif2
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stop_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|age_old_hosts
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_probe_on_vif
name|__P
argument_list|(
operator|(
expr|struct
name|uvif
operator|*
name|v
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_query
name|__P
argument_list|(
operator|(
expr|struct
name|uvif
operator|*
name|v
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_version
name|__P
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|int
name|plen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DelVif
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetTimer
name|__P
argument_list|(
operator|(
name|int
name|vifi
operator|,
expr|struct
name|listaddr
operator|*
name|g
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteTimer
name|__P
argument_list|(
operator|(
name|int
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SendQuery
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetQueryTimer
name|__P
argument_list|(
operator|(
expr|struct
name|listaddr
operator|*
name|g
operator|,
name|vifi_t
name|vifi
operator|,
name|int
name|to_expire
operator|,
name|int
name|q_time
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the virtual interfaces, but do not install  * them in the kernel.  Start routing on all vifs that are  * not down or disabled.  */
end_comment

begin_function
name|void
name|init_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|enabled_vifs
decl_stmt|,
name|enabled_phyints
decl_stmt|;
specifier|extern
name|char
modifier|*
name|configfilename
decl_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|vifs_with_neighbors
operator|=
literal|0
expr_stmt|;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Configure the vifs based on the interface configuration of the      * the kernel and the contents of the configuration file.      * (Open a UDP socket for ioctl use in the config procedures if      * the kernel can't handle IOCTL's on the IGMP socket.)      */
ifdef|#
directive|ifdef
name|IOCTL_OK_ON_RAW_SOCKET
name|udp_socket
operator|=
name|igmp_socket
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|udp_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"UDP socket"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Getting vifs from kernel interfaces"
argument_list|)
expr_stmt|;
name|config_vifs_from_kernel
argument_list|()
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Getting vifs from %s"
argument_list|,
name|configfilename
argument_list|)
expr_stmt|;
name|config_vifs_from_file
argument_list|()
expr_stmt|;
comment|/*      * Quit if there are fewer than two enabled vifs.      */
name|enabled_vifs
operator|=
literal|0
expr_stmt|;
name|enabled_phyints
operator|=
literal|0
expr_stmt|;
name|phys_vif
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
operator|++
name|enabled_vifs
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
if|if
condition|(
name|phys_vif
operator|==
operator|-
literal|1
condition|)
name|phys_vif
operator|=
name|vifi
expr_stmt|;
operator|++
name|enabled_phyints
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|enabled_vifs
operator|<
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"can't forward: %s"
argument_list|,
name|enabled_vifs
operator|==
literal|0
condition|?
literal|"no enabled vifs"
else|:
literal|"only one enabled vif"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled_phyints
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"no enabled interfaces, forwarding via tunnels only"
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Installing vifs in mrouted..."
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, tunnel %s -> %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, phyint %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|start_vif2
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is not yet up; vif #%u not in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the passed vif with all appropriate default values.  * "t" is true if a tunnel, or false if a phyint.  */
end_comment

begin_function
name|void
name|zero_vif
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|t
decl_stmt|;
block|{
name|v
operator|->
name|uv_flags
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_metric
operator|=
name|DEFAULT_METRIC
expr_stmt|;
name|v
operator|->
name|uv_admetric
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_threshold
operator|=
name|DEFAULT_THRESHOLD
expr_stmt|;
name|v
operator|->
name|uv_rate_limit
operator|=
name|t
condition|?
name|DEFAULT_TUN_RATE_LIMIT
else|:
name|DEFAULT_PHY_RATE_LIMIT
expr_stmt|;
name|v
operator|->
name|uv_lcl_addr
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_rmt_addr
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_dst_addr
operator|=
name|t
condition|?
literal|0
else|:
name|dvmrp_group
expr_stmt|;
name|v
operator|->
name|uv_subnet
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_subnetmask
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_subnetbcast
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|NULL
expr_stmt|;
name|NBRM_CLRALL
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_igmpv1_warn
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_prune_lifetime
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_leaf_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_acl
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_addrs
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_filter
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_blasterbuf
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_blastercur
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_blasterend
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_blasterlen
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_blastertimer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_nbrup
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_icmp_warn
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_nroutes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start routing on all virtual interfaces that are not down or  * administratively disabled.  */
end_comment

begin_function
name|void
name|init_installvifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Installing vifs in kernel..."
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, tunnel %s -> %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, phyint %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|k_add_vif
argument_list|(
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is not yet up; vif #%u not in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * See if any interfaces have changed from up state to down, or vice versa,  * including any non-multicast-capable interfaces that are in use as local  * tunnel end-points.  Ignore interfaces that have been administratively  * disabled.  */
end_comment

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
specifier|static
name|int
name|checking_vifs
init|=
literal|0
decl_stmt|;
comment|/*      * If we get an error while checking, (e.g. two interfaces go down      * at once, and we decide to send a prune out one of the failed ones)      * then don't go into an infinite loop!      */
if|if
condition|(
name|checking_vifs
condition|)
return|return;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
name|checking_vifs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"ioctl SIOCGIFFLAGS for %s"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has come up; vif #%u now in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_DOWN
expr_stmt|;
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has gone down; vif #%u taken out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_DOWN
expr_stmt|;
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|checking_vifs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a DVMRP message on the specified vif.  If DVMRP messages are  * to be encapsulated and sent "inside" the tunnel, use the special  * encapsulator.  If it's not a tunnel or DVMRP messages are to be  * sent "beside" the tunnel, as required by earlier versions of mrouted,  * then just send the message.  */
end_comment

begin_function
name|void
name|send_on_vif
parameter_list|(
name|v
parameter_list|,
name|dst
parameter_list|,
name|code
parameter_list|,
name|datalen
parameter_list|)
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int32
name|dst
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_int32
name|group
init|=
name|htonl
argument_list|(
name|MROUTED_LEVEL
operator||
operator|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
condition|?
literal|0
else|:
name|LEAF_FLAGS
operator|)
argument_list|)
decl_stmt|;
comment|/*      * The UNIX kernel will not decapsulate unicasts.      * Therefore, we don't send encapsulated unicasts.      */
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_TUNNEL
operator||
name|VIFF_OTUNNEL
operator|)
operator|)
operator|==
name|VIFF_TUNNEL
operator|&&
operator|(
operator|(
name|dst
operator|==
literal|0
operator|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|)
condition|)
name|send_ipip
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|dst
condition|?
name|dst
else|:
name|dvmrp_group
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|code
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|dst
condition|?
name|dst
else|:
name|v
operator|->
name|uv_dst_addr
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|code
argument_list|,
name|group
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a probe message on vif v  */
end_comment

begin_function
specifier|static
name|void
name|send_probe_on_vif
parameter_list|(
name|v
parameter_list|)
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|nbr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_PASSIVE
operator|&&
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
operator|)
operator|||
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_FORCE_LEAF
operator|)
condition|)
return|return;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|dvmrp_genid
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
comment|/*      * add the neighbor list on the interface to the message      */
name|nbr
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
while|while
condition|(
name|nbr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nbr
operator|->
name|al_addr
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
name|nbr
operator|=
name|nbr
operator|->
name|al_next
expr_stmt|;
block|}
name|send_on_vif
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|DVMRP_PROBE
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_query
parameter_list|(
name|v
parameter_list|)
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"sending %squery on vif %d"
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
condition|?
literal|"v1 "
else|:
literal|""
argument_list|,
name|v
operator|-
name|uvifs
argument_list|)
expr_stmt|;
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|allhosts_group
argument_list|,
name|IGMP_MEMBERSHIP_QUERY
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
condition|?
literal|0
else|:
name|IGMP_MAX_HOST_REPORT_DELAY
operator|*
name|IGMP_TIMER_SCALE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a vifi to the kernel and start routing on it.  */
end_comment

begin_function
specifier|static
name|void
name|start_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
comment|/*      * Install the interface in the kernel's vif structure.      */
name|k_add_vif
argument_list|(
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
name|start_vif2
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a vifi to all the user-level data structures but don't add  * it to the kernel yet.  */
end_comment

begin_function
specifier|static
name|void
name|start_vif2
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
name|src
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
comment|/*      * Update the existing route entries to take into account the new vif.      */
name|add_vif_to_routes
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
comment|/* 	 * Join the DVMRP multicast group on the interface. 	 * (This is not strictly necessary, since the kernel promiscuously 	 * receives IGMP packets addressed to ANY IP multicast group while 	 * multicast routing is enabled.  However, joining the group allows 	 * this host to receive non-IGMP packets as well, such as 'pings'.) 	 */
name|k_join
argument_list|(
name|dvmrp_group
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * Join the ALL-ROUTERS multicast group on the interface. 	 * This allows mtrace requests to loop back if they are run 	 * on the multicast router. 	 */
name|k_join
argument_list|(
name|allrtrs_group
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * Install an entry in the routing table for the subnet to which 	 * the interface is connected. 	 */
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|p
operator|->
name|pa_subnet
argument_list|,
name|p
operator|->
name|pa_subnetmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Until neighbors are discovered, assume responsibility for sending 	 * periodic group membership queries to the subnet.  Send the first 	 * query. 	 */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"assuming querier duties on vif %d"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|send_query
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_leaf_timer
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
comment|/*      * Send a probe via the new vif to look for neighbors.      */
name|send_probe_on_vif
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop routing on the specified virtual interface.  */
end_comment

begin_function
specifier|static
name|void
name|stop_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
comment|/* 	 * Depart from the DVMRP multicast group on the interface. 	 */
name|k_leave
argument_list|(
name|dvmrp_group
argument_list|,
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Depart from the ALL-ROUTERS multicast group on the interface. 	 */
name|k_leave
argument_list|(
name|allrtrs_group
argument_list|,
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Update the entry in the routing table for the subnet to which 	 * the interface is connected, to take into account the interface 	 * failure. 	 */
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
name|UNREACHABLE
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|p
operator|->
name|pa_subnet
argument_list|,
name|p
operator|->
name|pa_subnetmask
argument_list|,
name|UNREACHABLE
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Discard all group addresses.  (No need to tell kernel; 	 * the k_del_vif() call, below, will clean up kernel state.) 	 */
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"releasing querier duties on vif %d"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
comment|/*      * Update the existing route entries to take into account the vif failure.      */
name|delete_vif_from_routes
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Delete the interface from the kernel's vif structure.      */
name|k_del_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Discard all neighbor addresses.      */
if|if
condition|(
operator|!
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
name|vifs_with_neighbors
operator|--
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|nbrs
index|[
name|a
operator|->
name|al_index
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
name|NBRM_CLRALL
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stop routing on all vifs  */
end_comment

begin_function
name|void
name|stop_all_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|nbrs
index|[
name|a
operator|->
name|al_index
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|v
operator|->
name|uv_acl
operator|!=
name|NULL
condition|)
block|{
name|acl
operator|=
name|v
operator|->
name|uv_acl
expr_stmt|;
name|v
operator|->
name|uv_acl
operator|=
name|acl
operator|->
name|acl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|acl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find the virtual interface from which an incoming packet arrived,  * based on the packet's source and destination IP addresses.  */
end_comment

begin_function
name|vifi_t
name|find_vif
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
specifier|register
name|u_int32
name|src
decl_stmt|;
specifier|register
name|u_int32
name|dst
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|v
operator|->
name|uv_rmt_addr
operator|&&
operator|(
name|dst
operator|==
name|v
operator|->
name|uv_lcl_addr
operator|||
name|dst
operator|==
name|dvmrp_group
operator|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|src
operator|&
name|v
operator|->
name|uv_subnetmask
operator|)
operator|==
name|v
operator|->
name|uv_subnet
operator|&&
operator|(
operator|(
name|v
operator|->
name|uv_subnetmask
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
name|src
operator|!=
name|v
operator|->
name|uv_subnetbcast
operator|)
operator|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|(
name|src
operator|&
name|p
operator|->
name|pa_subnetmask
operator|)
operator|==
name|p
operator|->
name|pa_subnet
operator|&&
operator|(
operator|(
name|p
operator|->
name|pa_subnetmask
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
name|src
operator|!=
name|p
operator|->
name|pa_subnetbcast
operator|)
operator|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|age_old_hosts
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
comment|/*      * Decrement the old-hosts-present timer for each      * active group on each vif.      */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
if|if
condition|(
name|g
operator|->
name|al_old
condition|)
name|g
operator|->
name|al_old
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send group membership queries on each interface for which I am querier.  * Note that technically, there should be a timer per interface, as the  * dynamics of querier election can cause the "right" time to send a  * query to be different on different interfaces.  However, this simple  * implementation only ever sends queries sooner than the "right" time,  * so can not cause loss of membership (but can send more packets than  * necessary)  */
end_comment

begin_function
name|void
name|query_groups
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
condition|)
block|{
name|send_query
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|age_old_hosts
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming host membership query.  Warn about  * IGMP version mismatches, perform querier election, and  * handle group-specific queries when we're not the querier.  */
end_comment

begin_function
name|void
name|accept_membership_query
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|tmo
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
name|int
name|tmo
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group membership query from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmo
operator|==
literal|0
operator|&&
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
operator|)
operator|||
operator|(
name|tmo
operator|!=
literal|0
operator|&&
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Exponentially back-off warning rate 	 */
name|i
operator|=
operator|++
name|v
operator|->
name|uv_igmpv1_warn
expr_stmt|;
while|while
condition|(
name|i
operator|&&
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
name|i
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s %s on vif %d, %s"
argument_list|,
name|tmo
operator|==
literal|0
condition|?
literal|"Received IGMPv1 report from"
else|:
literal|"Received IGMPv2 report from"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|tmo
operator|==
literal|0
condition|?
literal|"please configure vif for IGMPv1"
else|:
literal|"but I am configured for IGMPv1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|uv_querier
operator|==
name|NULL
operator|||
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
operator|!=
name|src
condition|)
block|{
comment|/* 	 * This might be: 	 * - A query from a new querier, with a lower source address 	 *   than the current querier (who might be me) 	 * - A query from a new router that just started up and doesn't 	 *   know who the querier is. 	 */
if|if
condition|(
name|ntohl
argument_list|(
name|src
argument_list|)
operator|<
operator|(
name|v
operator|->
name|uv_querier
condition|?
name|ntohl
argument_list|(
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
argument_list|)
else|:
name|ntohl
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"new querier %s (was %s) on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|v
operator|->
name|uv_querier
condition|?
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
argument_list|,
name|s2
argument_list|)
else|:
literal|"me"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|uv_querier
condition|)
block|{
name|v
operator|->
name|uv_querier
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|v
operator|->
name|uv_querier
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
operator|=
name|src
expr_stmt|;
block|}
else|else
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring query from %s; querier on vif %d is still %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|v
operator|->
name|uv_querier
condition|?
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
argument_list|,
name|s2
argument_list|)
else|:
literal|"me"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*      * Reset the timer since we've received a query.      */
if|if
condition|(
name|v
operator|->
name|uv_querier
operator|&&
name|src
operator|==
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
condition|)
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
comment|/*      * If this is a Group-Specific query which we did not source,      * we must set our membership timer to [Last Member Query Count] *      * the [Max Response Time] in the packet.      */
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_IGMPV1
operator||
name|VIFF_QUERIER
operator|)
operator|)
operator|&&
name|group
operator|!=
literal|0
operator|&&
name|src
operator|!=
name|v
operator|->
name|uv_lcl_addr
condition|)
block|{
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s for %s from %s on vif %d, timer %d"
argument_list|,
literal|"Group-specific membership query"
argument_list|,
name|inet_fmt
argument_list|(
name|group
argument_list|,
name|s2
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|tmo
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|g
operator|->
name|al_addr
operator|&&
name|g
operator|->
name|al_query
operator|==
literal|0
condition|)
block|{
comment|/* setup a timeout to remove the group membership */
if|if
condition|(
name|g
operator|->
name|al_timerid
condition|)
name|g
operator|->
name|al_timerid
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_timerid
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_timer
operator|=
name|IGMP_LAST_MEMBER_QUERY_COUNT
operator|*
name|tmo
operator|/
name|IGMP_TIMER_SCALE
expr_stmt|;
comment|/* use al_query to record our presence in last-member state */
name|g
operator|->
name|al_query
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"timer for grp %s on vif %d set to %d"
argument_list|,
name|inet_fmt
argument_list|(
name|group
argument_list|,
name|s2
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|g
operator|->
name|al_timer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process an incoming group membership report.  */
end_comment

begin_function
name|void
name|accept_group_report
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|r_type
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
name|int
name|r_type
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group membership report from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/*      * Look for the group in our group list; if found, reset its timer.      */
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|g
operator|->
name|al_addr
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|IGMP_V1_MEMBERSHIP_REPORT
condition|)
name|g
operator|->
name|al_old
operator|=
name|OLD_AGE_THRESHOLD
expr_stmt|;
name|g
operator|->
name|al_reporter
operator|=
name|src
expr_stmt|;
comment|/** delete old timers, set a timer for expiration **/
name|g
operator|->
name|al_timer
operator|=
name|IGMP_GROUP_MEMBERSHIP_INTERVAL
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|al_query
condition|)
name|g
operator|->
name|al_query
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_query
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|al_timerid
condition|)
name|g
operator|->
name|al_timerid
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_timerid
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*      * If not found, add it to the list and update kernel cache.      */
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|g
operator|->
name|al_addr
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|IGMP_V1_MEMBERSHIP_REPORT
condition|)
name|g
operator|->
name|al_old
operator|=
name|OLD_AGE_THRESHOLD
expr_stmt|;
else|else
name|g
operator|->
name|al_old
operator|=
literal|0
expr_stmt|;
comment|/** set a timer for expiration **/
name|g
operator|->
name|al_query
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|al_timer
operator|=
name|IGMP_GROUP_MEMBERSHIP_INTERVAL
expr_stmt|;
name|g
operator|->
name|al_reporter
operator|=
name|src
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_next
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|g
expr_stmt|;
name|time
argument_list|(
operator|&
name|g
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
name|update_lclgrp
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
comment|/*       * Check if a graft is necessary for this group      */
name|chkgrp_graft
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming IGMPv2 Leave Group message.  */
end_comment

begin_function
name|void
name|accept_leave_message
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group leave report from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
operator|)
operator|||
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
condition|)
return|return;
comment|/*      * Look for the group in our group list in order to set up a short-timeout      * query.      */
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|g
operator|->
name|al_addr
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"[vif.c, _accept_leave_message] %d %d \n"
argument_list|,
name|g
operator|->
name|al_old
argument_list|,
name|g
operator|->
name|al_query
argument_list|)
expr_stmt|;
comment|/* Ignore the leave message if there are old hosts present */
if|if
condition|(
name|g
operator|->
name|al_old
condition|)
return|return;
comment|/* still waiting for a reply to a query, ignore the leave */
if|if
condition|(
name|g
operator|->
name|al_query
condition|)
return|return;
comment|/** delete old timer set a timer for expiration **/
if|if
condition|(
name|g
operator|->
name|al_timerid
condition|)
name|g
operator|->
name|al_timerid
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_timerid
argument_list|)
expr_stmt|;
if|#
directive|if
name|IGMP_LAST_MEMBER_QUERY_COUNT
operator|!=
literal|2
name|This
name|code
name|needs
name|to
name|be
name|updated
name|to
name|keep
name|a
name|counter
name|of
name|the
name|number
name|of
name|queries
name|remaining
operator|.
endif|#
directive|endif
comment|/** send a group specific querry **/
name|g
operator|->
name|al_timer
init|=
name|IGMP_LAST_MEMBER_QUERY_INTERVAL
operator|*
operator|(
name|IGMP_LAST_MEMBER_QUERY_COUNT
operator|+
literal|1
operator|)
decl_stmt|;
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|g
operator|->
name|al_addr
argument_list|,
name|IGMP_MEMBERSHIP_QUERY
argument_list|,
name|IGMP_LAST_MEMBER_QUERY_INTERVAL
operator|*
name|IGMP_TIMER_SCALE
argument_list|,
name|g
operator|->
name|al_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_query
operator|=
name|SetQueryTimer
argument_list|(
name|g
argument_list|,
name|vifi
argument_list|,
name|IGMP_LAST_MEMBER_QUERY_INTERVAL
argument_list|,
name|IGMP_LAST_MEMBER_QUERY_INTERVAL
operator|*
name|IGMP_TIMER_SCALE
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a periodic probe on all vifs.  * Useful to determine one-way interfaces.  * Detect neighbor loss faster.  */
end_comment

begin_function
name|void
name|probe_for_neighbors
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
name|send_probe_on_vif
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a list of all of our neighbors to the requestor, `src'.  */
end_comment

begin_function
name|void
name|accept_neighbor_request
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ncount
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|la
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|temp_addr
decl_stmt|,
name|them
init|=
name|src
decl_stmt|;
define|#
directive|define
name|PUT_ADDR
parameter_list|(
name|a
parameter_list|)
value|temp_addr = ntohl(a); \ 			*p++ = temp_addr>> 24; \ 			*p++ = (temp_addr>> 16)& 0xFF; \ 			*p++ = (temp_addr>> 8)& 0xFF; \ 			*p++ = temp_addr& 0xFF;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|ncount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|la
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|la
condition|;
name|la
operator|=
name|la
operator|->
name|al_next
control|)
block|{
comment|/* Make sure that there's room for this neighbor... */
if|if
condition|(
name|datalen
operator|+
operator|(
name|ncount
operator|==
literal|0
condition|?
literal|4
operator|+
literal|3
operator|+
literal|4
else|:
literal|4
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put out the header for this neighbor list... */
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
block|{
name|PUT_ADDR
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
name|ncount
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|datalen
operator|+=
literal|4
operator|+
literal|3
expr_stmt|;
block|}
name|PUT_ADDR
argument_list|(
name|la
operator|->
name|al_addr
argument_list|)
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a list of all of our neighbors to the requestor, `src'.  */
end_comment

begin_function
name|void
name|accept_neighbor_request2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ncount
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|la
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|them
init|=
name|src
decl_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
specifier|register
name|u_short
name|vflags
init|=
name|v
operator|->
name|uv_flags
decl_stmt|;
specifier|register
name|u_char
name|rflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_TUNNEL
condition|)
name|rflags
operator||=
name|DVMRP_NF_TUNNEL
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_SRCRT
condition|)
name|rflags
operator||=
name|DVMRP_NF_SRCRT
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_DOWN
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_DISABLED
condition|)
name|rflags
operator||=
name|DVMRP_NF_DISABLED
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_QUERIER
condition|)
name|rflags
operator||=
name|DVMRP_NF_QUERIER
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_LEAF
condition|)
name|rflags
operator||=
name|DVMRP_NF_LEAF
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
name|la
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * include down& disabled interfaces and interfaces on 	     * leaf nets. 	     */
if|if
condition|(
name|rflags
operator|&
name|DVMRP_NF_TUNNEL
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|MAX_DVMRP_DATA_LEN
operator|-
literal|12
condition|)
block|{
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rflags
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_rmt_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|12
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|la
condition|;
name|la
operator|=
name|la
operator|->
name|al_next
control|)
block|{
comment|/* Make sure that there's room for this neighbor... */
if|if
condition|(
name|datalen
operator|+
operator|(
name|ncount
operator|==
literal|0
condition|?
literal|4
operator|+
literal|4
operator|+
literal|4
else|:
literal|4
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put out the header for this neighbor list... */
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
block|{
comment|/* If it's a one-way tunnel, mark it down. */
if|if
condition|(
name|rflags
operator|&
name|DVMRP_NF_TUNNEL
operator|&&
name|la
operator|->
name|al_flags
operator|&
name|NBRF_ONEWAY
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rflags
expr_stmt|;
name|ncount
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|datalen
operator|+=
literal|4
operator|+
literal|4
expr_stmt|;
block|}
comment|/* Don't report one-way peering on phyint at all */
if|if
condition|(
operator|!
operator|(
name|rflags
operator|&
name|DVMRP_NF_TUNNEL
operator|)
operator|&&
name|la
operator|->
name|al_flags
operator|&
name|NBRF_ONEWAY
condition|)
continue|continue;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|la
operator|->
name|al_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ncount
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_rmt_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|accept_info_request
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_char
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|outlen
init|=
literal|0
decl_stmt|;
name|q
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
comment|/* To be general, this must deal properly with breaking up over-sized      * packets.  That implies passing a length to each function, and      * allowing each function to request to be called again.  Right now,      * we're only implementing the one thing we are positive will fit into      * a single packet, so we wimp out.      */
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|DVMRP_INFO_VERSION
case|:
name|len
operator|=
name|info_version
argument_list|(
name|q
argument_list|,
name|RECV_BUF_SIZE
operator|-
operator|(
name|q
operator|-
operator|(
name|u_char
operator|*
operator|)
name|send_buf
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_INFO_NEIGHBORS
case|:
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring unknown info type %d"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
name|len
operator|++
expr_stmt|;
name|outlen
operator|+=
name|len
operator|*
literal|4
expr_stmt|;
name|q
operator|+=
name|len
operator|*
literal|4
expr_stmt|;
name|len
operator|=
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|datalen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|outlen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|src
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_INFO_REPLY
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|outlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Information response -- return version string  */
end_comment

begin_function
specifier|static
name|int
name|info_version
parameter_list|(
name|p
parameter_list|,
name|plen
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|plen
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
specifier|extern
name|char
name|versionstring
index|[]
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|DVMRP_INFO_VERSION
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* skip over length */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* zero out */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* reserved fields */
name|strncpy
argument_list|(
name|p
argument_list|,
name|versionstring
argument_list|,
name|plen
operator|-
literal|4
argument_list|)
expr_stmt|;
name|p
index|[
name|plen
operator|-
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|versionstring
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor-list message.  */
end_comment

begin_function
name|void
name|accept_neighbors
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP neighbor list from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor-list message.  */
end_comment

begin_function
name|void
name|accept_neighbors2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PKT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP neighbor list2 from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming info reply message.  */
end_comment

begin_function
name|void
name|accept_info_reply
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PKT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP info reply from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the neighbor entry for neighbor 'addr' on vif 'vifi'.  * 'msgtype' is the type of DVMRP message received from the neighbor.  * Return the neighbor entry if 'addr' is a valid neighbor, FALSE otherwise.  */
end_comment

begin_function
name|struct
name|listaddr
modifier|*
name|update_neighbor
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|,
name|msgtype
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
name|int
name|msgtype
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|n
decl_stmt|;
name|int
name|pv
init|=
name|level
operator|&
literal|0xff
decl_stmt|;
name|int
name|mv
init|=
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
decl_stmt|;
name|int
name|has_genid
init|=
literal|0
decl_stmt|;
name|int
name|in_router_list
init|=
literal|0
decl_stmt|;
name|int
name|dvmrpspec
init|=
literal|0
decl_stmt|;
name|u_int32
name|genid
decl_stmt|;
name|u_int32
name|send_tables
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|do_reset
init|=
name|FALSE
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/*      * Confirm that 'addr' is a valid neighbor address on vif 'vifi'.      * IT IS ASSUMED that this was preceded by a call to find_vif(), which      * checks that 'addr' is either a valid remote tunnel endpoint or a      * non-broadcast address belonging to a directly-connected subnet.      * Therefore, here we check only that 'addr' is not our own address      * (due to an impostor or erroneous loopback) or an address of the form      * {subnet,0} ("the unknown host").  These checks are not performed in      * find_vif() because those types of address are acceptable for some      * types of IGMP message (such as group membership reports).      */
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
operator|(
name|addr
operator|==
name|v
operator|->
name|uv_lcl_addr
operator|||
name|addr
operator|==
name|v
operator|->
name|uv_subnet
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received DVMRP message from %s: %s"
argument_list|,
operator|(
name|addr
operator|==
name|v
operator|->
name|uv_lcl_addr
operator|)
condition|?
literal|"self (check device loopback)"
else|:
literal|"'the unknown host'"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Ignore all neighbors on vifs forced into leaf mode      */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_FORCE_LEAF
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*      * mrouted's version 3.3 and later include the generation ID      * and the list of neighbors on the vif in their probe messages.      */
if|if
condition|(
name|msgtype
operator|==
name|DVMRP_PROBE
operator|&&
operator|(
operator|(
name|pv
operator|==
literal|3
operator|&&
name|mv
operator|>
literal|2
operator|)
operator|||
operator|(
name|pv
operator|>
literal|3
operator|&&
name|pv
operator|<
literal|10
operator|)
operator|)
condition|)
block|{
name|u_int32
name|router
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"checking probe from %s (%d.%d) on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|pv
argument_list|,
name|mv
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|<
literal|4
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated probe message from %s (len %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|has_genid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|genid
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|datalen
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|datalen
operator|<
literal|4
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated probe message from %s (len %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|router
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|datalen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|router
operator|==
name|v
operator|->
name|uv_lcl_addr
condition|)
block|{
name|in_router_list
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|pv
operator|==
literal|3
operator|&&
name|mv
operator|==
literal|255
operator|)
operator|||
operator|(
name|pv
operator|>
literal|3
operator|&&
name|pv
operator|<
literal|10
operator|)
condition|)
name|dvmrpspec
operator|=
literal|1
expr_stmt|;
comment|/*      * Look for addr in list of neighbors.      */
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|addr
operator|==
name|n
operator|->
name|al_addr
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * New neighbor. 	 * 	 * If this neighbor follows the DVMRP spec, start the probe 	 * handshake.  If not, then it doesn't require the probe 	 * handshake, so establish the peering immediately. 	 */
if|if
condition|(
name|dvmrpspec
operator|&&
operator|(
name|msgtype
operator|!=
name|DVMRP_PROBE
operator|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNBRS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nbrs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXNBRS
condition|)
block|{
comment|/* XXX This is a severe new restriction. */
comment|/* XXX want extensible bitmaps! */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"Can't handle %dth neighbor %s on vif %d!"
argument_list|,
name|MAXNBRS
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * Add it to our list of neighbors. 	 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"New neighbor %s on vif %d v%d.%d nf 0x%02x idx %d"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|level
operator|&
literal|0xff
argument_list|,
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|level
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|n
operator|->
name|al_addr
operator|=
name|addr
expr_stmt|;
name|n
operator|->
name|al_pv
operator|=
name|pv
expr_stmt|;
name|n
operator|->
name|al_mv
operator|=
name|mv
expr_stmt|;
name|n
operator|->
name|al_genid
operator|=
name|has_genid
condition|?
name|genid
else|:
literal|0
expr_stmt|;
name|n
operator|->
name|al_index
operator|=
name|i
expr_stmt|;
name|nbrs
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|time
argument_list|(
operator|&
name|n
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|al_flags
operator|=
name|has_genid
condition|?
name|NBRF_GENID
else|:
literal|0
expr_stmt|;
name|n
operator|->
name|al_next
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|n
expr_stmt|;
comment|/* 	 * If we are not configured to peer with non-pruning routers, 	 * check the deprecated "I-know-how-to-prune" bit.  This bit 	 * was MBZ in early mrouted implementations (<3.5) and is required 	 * to be set by the DVMRPv3 specification. 	 */
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_ALLOW_NONPRUNERS
operator|)
operator|&&
operator|!
operator|(
operator|(
name|level
operator|&
literal|0x020000
operator|)
operator|||
operator|(
name|pv
operator|==
literal|3
operator|&&
name|mv
operator|<
literal|5
operator|)
operator|)
condition|)
block|{
name|n
operator|->
name|al_flags
operator||=
name|NBRF_TOOOLD
expr_stmt|;
block|}
comment|/* 	 * If this router implements the DVMRPv3 spec, then don't peer 	 * with him if we haven't yet established a bidirectional connection. 	 */
if|if
condition|(
name|dvmrpspec
condition|)
block|{
if|if
condition|(
operator|!
name|in_router_list
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"waiting for probe from %s with my addr"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_flags
operator||=
name|NBRF_WAITING
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NBRF_DONTPEER
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"not peering with %s on vif %d because %x"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|n
operator|->
name|al_flags
operator|&
name|NBRF_DONTPEER
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * If we thought that we had no neighbors on this vif, send a route 	 * report to the vif.  If this is just a new neighbor on the same 	 * vif, send the route report just to the new neighbor. 	 */
if|if
condition|(
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
block|{
name|send_tables
operator|=
name|v
operator|->
name|uv_dst_addr
expr_stmt|;
name|vifs_with_neighbors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|send_tables
operator|=
name|addr
expr_stmt|;
block|}
name|NBRM_SET
argument_list|(
name|i
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|add_neighbor_to_routes
argument_list|(
name|vifi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Found it.  Reset its timer. 	 */
name|n
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NBRF_WAITING
operator|&&
name|msgtype
operator|==
name|DVMRP_PROBE
condition|)
block|{
name|n
operator|->
name|al_flags
operator|&=
operator|~
name|NBRF_WAITING
expr_stmt|;
if|if
condition|(
operator|!
name|in_router_list
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"possible one-way peering with %s on vif %d"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_flags
operator||=
name|NBRF_ONEWAY
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
block|{
name|send_tables
operator|=
name|v
operator|->
name|uv_dst_addr
expr_stmt|;
name|vifs_with_neighbors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|send_tables
operator|=
name|addr
expr_stmt|;
block|}
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|add_neighbor_to_routes
argument_list|(
name|vifi
argument_list|,
name|n
operator|->
name|al_index
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d exits WAITING"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NBRF_ONEWAY
operator|&&
name|msgtype
operator|==
name|DVMRP_PROBE
condition|)
block|{
if|if
condition|(
name|in_router_list
condition|)
block|{
if|if
condition|(
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
name|vifs_with_neighbors
operator|++
expr_stmt|;
name|NBRM_SET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|add_neighbor_to_routes
argument_list|(
name|vifi
argument_list|,
name|n
operator|->
name|al_index
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"peering with %s on vif %d is no longer one-way"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_flags
operator|&=
operator|~
name|NBRF_ONEWAY
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX rate-limited warning message? */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on vif %d is still ONEWAY"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * When peering with a genid-capable but pre-DVMRP spec peer, 	 * we might bring up the peering with a route report and not 	 * remember his genid.  Assume that he doesn't send a route 	 * report and then reboot before sending a probe. 	 */
if|if
condition|(
name|has_genid
operator|&&
operator|!
operator|(
name|n
operator|->
name|al_flags
operator|&
name|NBRF_GENID
operator|)
condition|)
block|{
name|n
operator|->
name|al_flags
operator||=
name|NBRF_GENID
expr_stmt|;
name|n
operator|->
name|al_genid
operator|=
name|genid
expr_stmt|;
block|}
comment|/* 	 * update the neighbors version and protocol number and genid 	 * if changed => router went down and came up,  	 * so take action immediately. 	 */
if|if
condition|(
operator|(
name|n
operator|->
name|al_pv
operator|!=
name|pv
operator|)
operator|||
operator|(
name|n
operator|->
name|al_mv
operator|!=
name|mv
operator|)
operator|||
operator|(
name|has_genid
operator|&&
name|n
operator|->
name|al_genid
operator|!=
name|genid
operator|)
condition|)
block|{
name|do_reset
operator|=
name|TRUE
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"version/genid change neighbor %s [old:%d.%d/%8x, new:%d.%d/%8x]"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|n
operator|->
name|al_pv
argument_list|,
name|n
operator|->
name|al_mv
argument_list|,
name|n
operator|->
name|al_genid
argument_list|,
name|pv
argument_list|,
name|mv
argument_list|,
name|genid
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_pv
operator|=
name|pv
expr_stmt|;
name|n
operator|->
name|al_mv
operator|=
name|mv
expr_stmt|;
name|n
operator|->
name|al_genid
operator|=
name|genid
expr_stmt|;
name|time
argument_list|(
operator|&
name|n
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pv
operator|==
literal|3
operator|&&
name|mv
operator|>
literal|2
operator|)
operator|||
operator|(
name|pv
operator|>
literal|3
operator|&&
name|pv
operator|<
literal|10
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|al_flags
operator|&
name|VIFF_ONEWAY
operator|)
operator|&&
name|has_genid
operator|&&
operator|!
name|in_router_list
operator|&&
operator|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|n
operator|->
name|al_ctime
operator|>
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|NBRM_ISSET
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
block|{
name|NBRM_CLR
argument_list|(
name|n
operator|->
name|al_index
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
name|vifs_with_neighbors
operator|--
expr_stmt|;
block|}
name|delete_neighbor_from_routes
argument_list|(
name|addr
argument_list|,
name|vifi
argument_list|,
name|n
operator|->
name|al_index
argument_list|)
expr_stmt|;
name|reset_neighbor_state
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"peering with %s on vif %d is one-way"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_flags
operator||=
name|NBRF_ONEWAY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NBRF_DONTPEER
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"not peering with %s on vif %d because %x"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|n
operator|->
name|al_flags
operator|&
name|NBRF_DONTPEER
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check "leaf" flag */
block|}
if|if
condition|(
name|do_reset
condition|)
block|{
name|reset_neighbor_state
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|send_tables
condition|)
name|send_tables
operator|=
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|send_tables
condition|)
block|{
name|send_probe_on_vif
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|ALL_ROUTES
argument_list|,
name|vifi
argument_list|,
name|send_tables
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_leaf_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_LEAF
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance the timer in each neighbor and  * group entry on every vif.  */
end_comment

begin_function
name|void
name|age_vifs
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|,
modifier|*
name|prev_a
decl_stmt|;
specifier|register
name|u_int32
name|addr
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_leaf_timer
operator|&&
operator|(
name|v
operator|->
name|uv_leaf_timer
operator|-=
name|TIMER_INTERVAL
operator|==
literal|0
operator|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_LEAF
expr_stmt|;
block|}
for|for
control|(
name|prev_a
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
operator|&
operator|(
name|v
operator|->
name|uv_neighbors
operator|)
operator|,
name|a
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|a
operator|!=
name|NULL
condition|;
name|prev_a
operator|=
name|a
operator|,
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|int
name|exp_time
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|a
operator|->
name|al_pv
operator|==
literal|3
operator|)
operator|&&
operator|(
name|a
operator|->
name|al_mv
operator|>=
literal|3
operator|)
operator|)
operator|||
operator|(
operator|(
name|a
operator|->
name|al_pv
operator|>
literal|3
operator|)
operator|&&
operator|(
name|a
operator|->
name|al_pv
operator|<
literal|10
operator|)
operator|)
condition|)
name|exp_time
operator|=
name|NEIGHBOR_EXPIRE_TIME
expr_stmt|;
else|else
name|exp_time
operator|=
name|OLD_NEIGHBOR_EXPIRE_TIME
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|al_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|<
name|exp_time
condition|)
continue|continue;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PEER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Neighbor %s (%d.%d) expired after %d seconds"
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|a
operator|->
name|al_pv
argument_list|,
name|a
operator|->
name|al_mv
argument_list|,
name|exp_time
argument_list|)
expr_stmt|;
comment|/* 	     * Neighbor has expired; delete it from the neighbor list, 	     * delete it from the 'dominants' and 'subordinates arrays of 	     * any route entries. 	     */
name|NBRM_CLR
argument_list|(
name|a
operator|->
name|al_index
argument_list|,
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|nbrs
index|[
name|a
operator|->
name|al_index
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* XXX is it a good idea to reuse indxs? */
name|idx
operator|=
name|a
operator|->
name|al_index
expr_stmt|;
name|addr
operator|=
name|a
operator|->
name|al_addr
expr_stmt|;
name|prev_a
operator|->
name|al_next
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|prev_a
expr_stmt|;
comment|/*XXX use ** */
name|delete_neighbor_from_routes
argument_list|(
name|addr
argument_list|,
name|vifi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|reset_neighbor_state
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NBRM_ISEMPTY
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
condition|)
name|vifs_with_neighbors
operator|--
expr_stmt|;
name|v
operator|->
name|uv_leaf_timer
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|uv_querier
operator|&&
operator|(
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|>
name|IGMP_OTHER_QUERIER_PRESENT_INTERVAL
condition|)
block|{
comment|/* 	     * The current querier has timed out.  We must become the 	     * querier. 	     */
name|IF_DEBUG
argument_list|(
argument|DEBUG_IGMP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"querier %s timed out"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
operator|->
name|uv_querier
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
name|send_query
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the neighbor info struct for a given neighbor  */
end_comment

begin_function
name|struct
name|listaddr
modifier|*
name|neighbor_info
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|al_next
control|)
if|if
condition|(
name|u
operator|->
name|al_addr
operator|==
name|addr
condition|)
return|return
name|u
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|vnflags
block|{
name|int
name|vn_flag
decl_stmt|;
name|char
modifier|*
name|vn_name
decl_stmt|;
block|}
name|vifflags
index|[]
init|=
block|{
block|{
name|VIFF_DOWN
block|,
literal|"down"
block|}
block|,
block|{
name|VIFF_DISABLED
block|,
literal|"disabled"
block|}
block|,
block|{
name|VIFF_QUERIER
block|,
literal|"querier"
block|}
block|,
block|{
name|VIFF_ONEWAY
block|,
literal|"one-way"
block|}
block|,
block|{
name|VIFF_LEAF
block|,
literal|"leaf"
block|}
block|,
block|{
name|VIFF_IGMPV1
block|,
literal|"IGMPv1"
block|}
block|,
block|{
name|VIFF_REXMIT_PRUNES
block|,
literal|"rexmit_prunes"
block|}
block|,
block|{
name|VIFF_PASSIVE
block|,
literal|"passive"
block|}
block|,
block|{
name|VIFF_ALLOW_NONPRUNERS
block|,
literal|"allow_nonpruners"
block|}
block|,
block|{
name|VIFF_NOFLOOD
block|,
literal|"noflood"
block|}
block|,
block|{
name|VIFF_NOTRANSIT
block|,
literal|"notransit"
block|}
block|,
block|{
name|VIFF_BLASTER
block|,
literal|"blaster"
block|}
block|,
block|{
name|VIFF_FORCE_LEAF
block|,
literal|"force_leaf"
block|}
block|,
block|{
name|VIFF_OTUNNEL
block|,
literal|"old-tunnel"
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vnflags
name|nbrflags
index|[]
init|=
block|{
block|{
name|NBRF_LEAF
block|,
literal|"leaf"
block|}
block|,
block|{
name|NBRF_GENID
block|,
literal|"have-genid"
block|}
block|,
block|{
name|NBRF_WAITING
block|,
literal|"waiting"
block|}
block|,
block|{
name|NBRF_ONEWAY
block|,
literal|"one-way"
block|}
block|,
block|{
name|NBRF_TOOOLD
block|,
literal|"too old"
block|}
block|,
block|{
name|NBRF_TOOMANYROUTES
block|,
literal|"too many routes"
block|}
block|,
block|{
name|NBRF_NOTPRUNING
block|,
literal|"not pruning?"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the contents of the uvifs array on file 'fp'.  */
end_comment

begin_function
name|void
name|dump_vifs
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sioc_vif_req
name|v_req
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"vifs_with_neighbors = %d\n"
argument_list|,
name|vifs_with_neighbors
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifs_with_neighbors
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[This host is a leaf]\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nVirtual Interface Table\n%s"
argument_list|,
literal|"Vif  Name  Local-Address                               "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"M  Thr  Rate   Flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%2u %6s  %-15s %6s: %-18s %2u %3u  %5u  "
argument_list|,
name|vifi
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
literal|"tunnel"
else|:
literal|"subnet"
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
else|:
name|inet_fmts
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
name|s3
argument_list|)
argument_list|,
name|v
operator|->
name|uv_metric
argument_list|,
name|v
operator|->
name|uv_threshold
argument_list|,
name|v
operator|->
name|uv_rate_limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vifflags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|vnflags
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|vifflags
index|[
name|i
index|]
operator|.
name|vn_flag
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|vifflags
index|[
name|i
index|]
operator|.
name|vn_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	fprintf(fp, "                          #routes: %d\n", v->uv_nroutes); 	*/
if|if
condition|(
name|v
operator|->
name|uv_admetric
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                                        advert-metric %2u\n"
argument_list|,
name|v
operator|->
name|uv_admetric
argument_list|)
expr_stmt|;
name|label
operator|=
literal|"alternate subnets:"
expr_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                %18s %s\n"
argument_list|,
name|label
argument_list|,
name|inet_fmts
argument_list|(
name|p
operator|->
name|pa_subnet
argument_list|,
name|p
operator|->
name|pa_subnetmask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
literal|""
expr_stmt|;
block|}
name|label
operator|=
literal|"peers:"
expr_stmt|;
for|for
control|(
name|a
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                            %6s %s (%d.%d) [%d]"
argument_list|,
name|label
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|a
operator|->
name|al_pv
argument_list|,
name|a
operator|->
name|al_mv
argument_list|,
name|a
operator|->
name|al_index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nbrflags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|vnflags
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a
operator|->
name|al_flags
operator|&
name|nbrflags
index|[
name|i
index|]
operator|.
name|vn_flag
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|nbrflags
index|[
name|i
index|]
operator|.
name|vn_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" up %s\n"
argument_list|,
name|scaletime
argument_list|(
name|now
operator|-
name|a
operator|->
name|al_ctime
argument_list|)
argument_list|)
expr_stmt|;
comment|/*fprintf(fp, " #routes %d\n", a->al_nroutes);*/
name|label
operator|=
literal|""
expr_stmt|;
block|}
name|label
operator|=
literal|"group host (time left):"
expr_stmt|;
for|for
control|(
name|a
operator|=
name|v
operator|->
name|uv_groups
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"           %23s %-15s %-15s (%s)\n"
argument_list|,
name|label
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_reporter
argument_list|,
name|s2
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|timer_leftTimer
argument_list|(
name|a
operator|->
name|al_timerid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
literal|""
expr_stmt|;
block|}
name|label
operator|=
literal|"boundaries:"
expr_stmt|;
for|for
control|(
name|acl
operator|=
name|v
operator|->
name|uv_acl
init|;
name|acl
operator|!=
name|NULL
condition|;
name|acl
operator|=
name|acl
operator|->
name|acl_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                       %11s %-18s\n"
argument_list|,
name|label
argument_list|,
name|inet_fmts
argument_list|(
name|acl
operator|->
name|acl_addr
argument_list|,
name|acl
operator|->
name|acl_mask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|uv_filter
condition|)
block|{
name|struct
name|vf_element
modifier|*
name|vfe
decl_stmt|;
name|char
name|lbuf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"%5s %7s filter:"
argument_list|,
name|v
operator|->
name|uv_filter
operator|->
name|vf_flags
operator|&
name|VFF_BIDIR
condition|?
literal|"bidir"
else|:
literal|"     "
argument_list|,
name|v
operator|->
name|uv_filter
operator|->
name|vf_type
operator|==
name|VFT_ACCEPT
condition|?
literal|"accept"
else|:
literal|"deny"
argument_list|)
expr_stmt|;
name|label
operator|=
name|lbuf
expr_stmt|;
for|for
control|(
name|vfe
operator|=
name|v
operator|->
name|uv_filter
operator|->
name|vf_filter
init|;
name|vfe
operator|!=
name|NULL
condition|;
name|vfe
operator|=
name|vfe
operator|->
name|vfe_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"           %23s %-18s%s\n"
argument_list|,
name|label
argument_list|,
name|inet_fmts
argument_list|(
name|vfe
operator|->
name|vfe_addr
argument_list|,
name|vfe
operator|->
name|vfe_mask
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vfe
operator|->
name|vfe_flags
operator|&
name|VFEF_EXACT
condition|?
literal|" (exact)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|label
operator|=
literal|""
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_TUNNEL
operator||
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                     IGMP querier: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_querier
operator|==
name|NULL
condition|)
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-18s (this system)\n"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NONE - querier election failure?\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-18s up %s last heard %s ago\n"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|now
operator|-
name|v
operator|->
name|uv_querier
operator|->
name|al_ctime
argument_list|)
argument_list|,
name|scaletime
argument_list|(
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_BLASTER
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                  blasterbuf size: %dk\n"
argument_list|,
name|v
operator|->
name|uv_blasterlen
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                      Nbr bitmaps: 0x%08lx%08lx\n"
argument_list|,
comment|/*XXX*/
name|v
operator|->
name|uv_nbrmap
operator|.
name|hi
argument_list|,
name|v
operator|->
name|uv_nbrmap
operator|.
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_prune_lifetime
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                   Prune Lifetime: %d seconds\n"
argument_list|,
name|v
operator|->
name|uv_prune_lifetime
argument_list|)
expr_stmt|;
name|v_req
operator|.
name|vifi
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|did_final_init
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"SIOCGETVIFCNT fails on vif %d"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                   pkts/bytes in : %lu/%lu\n"
argument_list|,
name|v_req
operator|.
name|icount
argument_list|,
name|v_req
operator|.
name|ibytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                   pkts/bytes out: %lu/%lu\n"
argument_list|,
name|v_req
operator|.
name|ocount
argument_list|,
name|v_req
operator|.
name|obytes
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Time out record of a group membership on a vif  */
end_comment

begin_function
specifier|static
name|void
name|DelVif
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
init|=
operator|(
name|cbk_t
operator|*
operator|)
name|arg
decl_stmt|;
name|vifi_t
name|vifi
init|=
name|cbk
operator|->
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|vifi
index|]
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|anp
decl_stmt|,
modifier|*
name|g
init|=
name|cbk
operator|->
name|g
decl_stmt|;
comment|/*      * Group has expired      * delete all kernel cache entries with this group      */
if|if
condition|(
name|g
operator|->
name|al_query
condition|)
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_query
argument_list|)
expr_stmt|;
name|delete_lclgrp
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|al_addr
argument_list|)
expr_stmt|;
name|anp
operator|=
operator|&
operator|(
name|v
operator|->
name|uv_groups
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
operator|*
name|anp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|==
name|g
condition|)
block|{
operator|*
name|anp
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|anp
operator|=
operator|&
name|a
operator|->
name|al_next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a timer to delete the record of a group membership on a vif.  */
end_comment

begin_function
specifier|static
name|int
name|SetTimer
parameter_list|(
name|vifi
parameter_list|,
name|g
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
decl_stmt|;
name|cbk
operator|=
operator|(
name|cbk_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cbk_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|cbk
operator|->
name|vifi
operator|=
name|vifi
expr_stmt|;
return|return
name|timer_setTimer
argument_list|(
name|g
operator|->
name|al_timer
argument_list|,
name|DelVif
argument_list|,
name|cbk
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a timer that was set above.  */
end_comment

begin_function
specifier|static
name|int
name|DeleteTimer
parameter_list|(
name|id
parameter_list|)
name|int
name|id
decl_stmt|;
block|{
name|timer_clearTimer
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a group-specific query.  */
end_comment

begin_function
specifier|static
name|void
name|SendQuery
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
init|=
operator|(
name|cbk_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|cbk
operator|->
name|vifi
index|]
decl_stmt|;
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|cbk
operator|->
name|g
operator|->
name|al_addr
argument_list|,
name|IGMP_MEMBERSHIP_QUERY
argument_list|,
name|cbk
operator|->
name|q_time
argument_list|,
name|cbk
operator|->
name|g
operator|->
name|al_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|g
operator|->
name|al_query
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a timer to send a group-specific query.  */
end_comment

begin_function
specifier|static
name|int
name|SetQueryTimer
parameter_list|(
name|g
parameter_list|,
name|vifi
parameter_list|,
name|to_expire
parameter_list|,
name|q_time
parameter_list|)
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|to_expire
decl_stmt|,
name|q_time
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
decl_stmt|;
name|cbk
operator|=
operator|(
name|cbk_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cbk_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|cbk
operator|->
name|q_time
operator|=
name|q_time
expr_stmt|;
name|cbk
operator|->
name|vifi
operator|=
name|vifi
expr_stmt|;
return|return
name|timer_setTimer
argument_list|(
name|to_expire
argument_list|,
name|SendQuery
argument_list|,
name|cbk
argument_list|)
return|;
block|}
end_function

end_unit

