begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE".  Use of the mrouted program represents acceptance of  * the terms and conditions listed in that file.  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|struct
name|uvif
name|uvifs
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of virtual interfaces		    */
end_comment

begin_decl_stmt
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of vifs in use	    	    */
end_comment

begin_decl_stmt
name|int
name|vifs_down
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>some interfaces are down	    	    */
end_comment

begin_decl_stmt
name|int
name|phys_vif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An enabled vif		    	    */
end_comment

begin_decl_stmt
name|int
name|udp_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since the honkin' kernel doesn't support */
end_comment

begin_comment
comment|/* ioctls on raw IP sockets, we need a UDP  */
end_comment

begin_comment
comment|/* socket as well as our IGMP (raw) socket. */
end_comment

begin_comment
comment|/* How dumb.                                */
end_comment

begin_decl_stmt
name|int
name|vifs_with_neighbors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* == 1 if I am a leaf		    */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
name|int
name|q_time
decl_stmt|;
block|}
name|cbk_t
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|start_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_vif2
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stop_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|age_old_hosts
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_probe_on_vif
name|__P
argument_list|(
operator|(
expr|struct
name|uvif
operator|*
name|v
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_version
name|__P
argument_list|(
operator|(
name|char
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DelVif
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetTimer
name|__P
argument_list|(
operator|(
name|int
name|vifi
operator|,
expr|struct
name|listaddr
operator|*
name|g
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DeleteTimer
name|__P
argument_list|(
operator|(
name|int
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SendQuery
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SetQueryTimer
name|__P
argument_list|(
operator|(
expr|struct
name|listaddr
operator|*
name|g
operator|,
name|vifi_t
name|vifi
operator|,
name|int
name|to_expire
operator|,
name|int
name|q_time
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the virtual interfaces, but do not install  * them in the kernel.  Start routing on all vifs that are  * not down or disabled.  */
end_comment

begin_function
name|void
name|init_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|enabled_vifs
decl_stmt|,
name|enabled_phyints
decl_stmt|;
specifier|extern
name|char
modifier|*
name|configfilename
decl_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|vifs_with_neighbors
operator|=
literal|0
expr_stmt|;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Configure the vifs based on the interface configuration of the      * the kernel and the contents of the configuration file.      * (Open a UDP socket for ioctl use in the config procedures.)      */
if|if
condition|(
operator|(
name|udp_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"UDP socket"
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Getting vifs from kernel interfaces"
argument_list|)
expr_stmt|;
name|config_vifs_from_kernel
argument_list|()
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Getting vifs from %s"
argument_list|,
name|configfilename
argument_list|)
expr_stmt|;
name|config_vifs_from_file
argument_list|()
expr_stmt|;
comment|/*      * Quit if there are fewer than two enabled vifs.      */
name|enabled_vifs
operator|=
literal|0
expr_stmt|;
name|enabled_phyints
operator|=
literal|0
expr_stmt|;
name|phys_vif
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
operator|++
name|enabled_vifs
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
if|if
condition|(
name|phys_vif
operator|==
operator|-
literal|1
condition|)
name|phys_vif
operator|=
name|vifi
expr_stmt|;
operator|++
name|enabled_phyints
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|enabled_vifs
operator|<
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"can't forward: %s"
argument_list|,
name|enabled_vifs
operator|==
literal|0
condition|?
literal|"no enabled vifs"
else|:
literal|"only one enabled vif"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled_phyints
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"no enabled interfaces, forwarding via tunnels only"
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Installing vifs in mrouted..."
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, tunnel %s -> %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, phyint %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|start_vif2
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is not yet up; vif #%u not in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start routing on all virtual interfaces that are not down or  * administratively disabled.  */
end_comment

begin_function
name|void
name|init_installvifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Installing vifs in kernel..."
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, tunnel %s -> %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"vif #%d, phyint %s"
argument_list|,
name|vifi
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|k_add_vif
argument_list|(
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is not yet up; vif #%u not in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * See if any interfaces have changed from up state to down, or vice versa,  * including any non-multicast-capable interfaces that are in use as local  * tunnel end-points.  Ignore interfaces that have been administratively  * disabled.  */
end_comment

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
specifier|static
name|int
name|checking_vifs
init|=
literal|0
decl_stmt|;
comment|/*      * If we get an error while checking, (e.g. two interfaces go down      * at once, and we decide to send a prune out one of the failed ones)      * then don't go into an infinite loop!      */
if|if
condition|(
name|checking_vifs
condition|)
return|return;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
name|checking_vifs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"ioctl SIOCGIFFLAGS for %s"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has come up; vif #%u now in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_DOWN
expr_stmt|;
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has gone down; vif #%u taken out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_DOWN
expr_stmt|;
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|checking_vifs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a probe message on vif v  */
end_comment

begin_function
specifier|static
name|void
name|send_probe_on_vif
parameter_list|(
name|v
parameter_list|)
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|nbr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|dvmrp_genid
operator|)
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
comment|/*      * add the neighbor list on the interface to the message      */
name|nbr
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
while|while
condition|(
name|nbr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nbr
operator|->
name|al_addr
operator|)
index|[
name|i
index|]
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
name|nbr
operator|=
name|nbr
operator|->
name|al_next
expr_stmt|;
block|}
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|v
operator|->
name|uv_rmt_addr
else|:
name|dvmrp_group
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_PROBE
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
operator||
operator|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_LEAF
operator|)
condition|?
literal|0
else|:
name|LEAF_FLAGS
operator|)
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a vifi to the kernel and start routing on it.  */
end_comment

begin_function
specifier|static
name|void
name|start_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
comment|/*      * Install the interface in the kernel's vif structure.      */
name|k_add_vif
argument_list|(
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
name|start_vif2
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a vifi to all the user-level data structures but don't add  * it to the kernel yet.  */
end_comment

begin_function
specifier|static
name|void
name|start_vif2
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int32
name|src
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
name|src
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
comment|/*      * Update the existing route entries to take into account the new vif.      */
name|add_vif_to_routes
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
comment|/* 	 * Join the DVMRP multicast group on the interface. 	 * (This is not strictly necessary, since the kernel promiscuously 	 * receives IGMP packets addressed to ANY IP multicast group while 	 * multicast routing is enabled.  However, joining the group allows 	 * this host to receive non-IGMP packets as well, such as 'pings'.) 	 */
name|k_join
argument_list|(
name|dvmrp_group
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * Join the ALL-ROUTERS multicast group on the interface. 	 * This allows mtrace requests to loop back if they are run 	 * on the multicast router. 	 */
name|k_join
argument_list|(
name|allrtrs_group
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * Install an entry in the routing table for the subnet to which 	 * the interface is connected. 	 */
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|p
operator|->
name|pa_subnet
argument_list|,
name|p
operator|->
name|pa_subnetmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Until neighbors are discovered, assume responsibility for sending 	 * periodic group membership queries to the subnet.  Send the first 	 * query. 	 */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
name|send_igmp
argument_list|(
name|src
argument_list|,
name|allhosts_group
argument_list|,
name|IGMP_HOST_MEMBERSHIP_QUERY
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
condition|?
literal|0
else|:
name|IGMP_MAX_HOST_REPORT_DELAY
operator|*
name|IGMP_TIMER_SCALE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|age_old_hosts
argument_list|()
expr_stmt|;
block|}
name|v
operator|->
name|uv_leaf_timer
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
comment|/*      * Send a probe via the new vif to look for neighbors.      */
name|send_probe_on_vif
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop routing on the specified virtual interface.  */
end_comment

begin_function
specifier|static
name|void
name|stop_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
comment|/* 	 * Depart from the DVMRP multicast group on the interface. 	 */
name|k_leave
argument_list|(
name|dvmrp_group
argument_list|,
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Depart from the ALL-ROUTERS multicast group on the interface. 	 */
name|k_leave
argument_list|(
name|allrtrs_group
argument_list|,
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Update the entry in the routing table for the subnet to which 	 * the interface is connected, to take into account the interface 	 * failure. 	 */
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
name|UNREACHABLE
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
name|start_route_updates
argument_list|()
expr_stmt|;
name|update_route
argument_list|(
name|p
operator|->
name|pa_subnet
argument_list|,
name|p
operator|->
name|pa_subnetmask
argument_list|,
name|UNREACHABLE
argument_list|,
literal|0
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Discard all group addresses.  (No need to tell kernel; 	 * the k_del_vif() call, below, will clean up kernel state.) 	 */
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
comment|/*      * Update the existing route entries to take into account the vif failure.      */
name|delete_vif_from_routes
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Delete the interface from the kernel's vif structure.      */
name|k_del_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Discard all neighbor addresses.      */
if|if
condition|(
name|v
operator|->
name|uv_neighbors
condition|)
name|vifs_with_neighbors
operator|--
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * stop routing on all vifs  */
end_comment

begin_function
name|void
name|stop_all_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
name|v
operator|->
name|uv_neighbors
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|v
operator|->
name|uv_acl
operator|!=
name|NULL
condition|)
block|{
name|acl
operator|=
name|v
operator|->
name|uv_acl
expr_stmt|;
name|v
operator|->
name|uv_acl
operator|=
name|acl
operator|->
name|acl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|acl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find the virtual interface from which an incoming packet arrived,  * based on the packet's source and destination IP addresses.  */
end_comment

begin_function
name|vifi_t
name|find_vif
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
specifier|register
name|u_int32
name|src
decl_stmt|;
specifier|register
name|u_int32
name|dst
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|v
operator|->
name|uv_rmt_addr
operator|&&
name|dst
operator|==
name|v
operator|->
name|uv_lcl_addr
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|src
operator|&
name|v
operator|->
name|uv_subnetmask
operator|)
operator|==
name|v
operator|->
name|uv_subnet
operator|&&
operator|(
operator|(
name|v
operator|->
name|uv_subnetmask
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
name|src
operator|!=
name|v
operator|->
name|uv_subnetbcast
operator|)
operator|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|(
name|src
operator|&
name|p
operator|->
name|pa_subnetmask
operator|)
operator|==
name|p
operator|->
name|pa_subnet
operator|&&
operator|(
operator|(
name|p
operator|->
name|pa_subnetmask
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
name|src
operator|!=
name|p
operator|->
name|pa_subnetbcast
operator|)
operator|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|age_old_hosts
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
comment|/*      * Decrement the old-hosts-present timer for each      * active group on each vif.      */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
if|if
condition|(
name|g
operator|->
name|al_old
condition|)
name|g
operator|->
name|al_old
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send group membership queries to all subnets for which I am querier.  */
end_comment

begin_function
name|void
name|query_groups
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
condition|)
block|{
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|allhosts_group
argument_list|,
name|IGMP_HOST_MEMBERSHIP_QUERY
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
condition|?
literal|0
else|:
name|IGMP_MAX_HOST_REPORT_DELAY
operator|*
name|IGMP_TIMER_SCALE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|age_old_hosts
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming host membership query  */
end_comment

begin_function
name|void
name|accept_membership_query
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|tmo
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
name|int
name|tmo
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group membership query from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/*      * If we consider ourselves the querier for this vif, but hear a      * query from a router with a lower IP address, yield to them.      *      * This is done here as well as in the neighbor discovery in case      * there is a querier that doesn't speak DVMRP.      *      * XXX If this neighbor doesn't speak DVMRP, then we need to create      * some neighbor state for him so that we can time him out!      */
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
operator|)
operator|&&
operator|(
name|ntohl
argument_list|(
name|src
argument_list|)
operator|<
name|ntohl
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
operator|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an incoming group membership report.  */
end_comment

begin_function
name|void
name|accept_group_report
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|r_type
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
name|int
name|r_type
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group membership report from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/*      * Look for the group in our group list; if found, reset its timer.      */
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|g
operator|->
name|al_addr
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|IGMP_HOST_MEMBERSHIP_REPORT
condition|)
name|g
operator|->
name|al_old
operator|=
name|OLD_AGE_THRESHOLD
expr_stmt|;
ifdef|#
directive|ifdef
name|SNMP
name|g
operator|->
name|al_genid
operator|=
name|src
expr_stmt|;
endif|#
directive|endif
comment|/* SNMP */
comment|/** delete old timers, set a timer for expiration **/
name|g
operator|->
name|al_timer
operator|=
name|GROUP_EXPIRE_TIME
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|al_query
condition|)
name|g
operator|->
name|al_query
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_query
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|al_timerid
condition|)
name|g
operator|->
name|al_timerid
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_timerid
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*      * If not found, add it to the list and update kernel cache.      */
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|g
operator|->
name|al_addr
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|IGMP_HOST_NEW_MEMBERSHIP_REPORT
condition|)
name|g
operator|->
name|al_old
operator|=
literal|0
expr_stmt|;
else|else
name|g
operator|->
name|al_old
operator|=
name|OLD_AGE_THRESHOLD
expr_stmt|;
ifdef|#
directive|ifdef
name|SNMP
name|g
operator|->
name|al_genid
operator|=
name|src
expr_stmt|;
endif|#
directive|endif
comment|/** set a timer for expiration **/
name|g
operator|->
name|al_query
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|al_timer
operator|=
name|GROUP_EXPIRE_TIME
expr_stmt|;
name|time
argument_list|(
operator|&
name|g
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_next
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|g
expr_stmt|;
name|update_lclgrp
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
comment|/*       * Check if a graft is necessary for this group      */
name|chkgrp_graft
argument_list|(
name|vifi
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|accept_leave_message
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|group
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NO_VIF
operator|||
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring group leave report from non-adjacent host %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
operator|)
operator|||
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
operator|)
condition|)
return|return;
comment|/*      * Look for the group in our group list in order to set up a short-timeout      * query.      */
for|for
control|(
name|g
operator|=
name|v
operator|->
name|uv_groups
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|g
operator|->
name|al_addr
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"[vif.c, _accept_leave_message] %d %d \n"
argument_list|,
name|g
operator|->
name|al_old
argument_list|,
name|g
operator|->
name|al_query
argument_list|)
expr_stmt|;
comment|/* Ignore the leave message if there are old hosts present */
if|if
condition|(
name|g
operator|->
name|al_old
condition|)
return|return;
comment|/* still waiting for a reply to a query, ignore the leave */
if|if
condition|(
name|g
operator|->
name|al_query
condition|)
return|return;
comment|/** delete old timer set a timer for expiration **/
if|if
condition|(
name|g
operator|->
name|al_timerid
condition|)
name|g
operator|->
name|al_timerid
operator|=
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_timerid
argument_list|)
expr_stmt|;
comment|/** send a group specific querry **/
name|g
operator|->
name|al_timer
operator|=
name|LEAVE_EXPIRE_TIME
expr_stmt|;
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|g
operator|->
name|al_addr
argument_list|,
name|IGMP_HOST_MEMBERSHIP_QUERY
argument_list|,
name|LEAVE_EXPIRE_TIME
operator|/
literal|3
operator|*
name|IGMP_TIMER_SCALE
argument_list|,
name|g
operator|->
name|al_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_query
operator|=
name|SetQueryTimer
argument_list|(
name|g
argument_list|,
name|vifi
argument_list|,
name|g
operator|->
name|al_timer
operator|/
literal|3
argument_list|,
name|LEAVE_EXPIRE_TIME
operator|/
literal|3
operator|*
name|IGMP_TIMER_SCALE
argument_list|)
expr_stmt|;
name|g
operator|->
name|al_timerid
operator|=
name|SetTimer
argument_list|(
name|vifi
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a periodic probe on all vifs.  * Useful to determine one-way interfaces.  * Detect neighbor loss faster.  */
end_comment

begin_function
name|void
name|probe_for_neighbors
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
operator|)
condition|)
block|{
name|send_probe_on_vif
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Send a list of all of our neighbors to the requestor, `src'.  */
end_comment

begin_function
name|void
name|accept_neighbor_request
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ncount
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|la
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|temp_addr
decl_stmt|,
name|them
init|=
name|src
decl_stmt|;
define|#
directive|define
name|PUT_ADDR
parameter_list|(
name|a
parameter_list|)
value|temp_addr = ntohl(a); \ 			*p++ = temp_addr>> 24; \ 			*p++ = (temp_addr>> 16)& 0xFF; \ 			*p++ = (temp_addr>> 8)& 0xFF; \ 			*p++ = temp_addr& 0xFF;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|ncount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|la
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|la
condition|;
name|la
operator|=
name|la
operator|->
name|al_next
control|)
block|{
comment|/* Make sure that there's room for this neighbor... */
if|if
condition|(
name|datalen
operator|+
operator|(
name|ncount
operator|==
literal|0
condition|?
literal|4
operator|+
literal|3
operator|+
literal|4
else|:
literal|4
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put out the header for this neighbor list... */
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
block|{
name|PUT_ADDR
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
name|ncount
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|datalen
operator|+=
literal|4
operator|+
literal|3
expr_stmt|;
block|}
name|PUT_ADDR
argument_list|(
name|la
operator|->
name|al_addr
argument_list|)
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a list of all of our neighbors to the requestor, `src'.  */
end_comment

begin_function
name|void
name|accept_neighbor_request2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ncount
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|la
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|them
init|=
name|src
decl_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
specifier|register
name|u_short
name|vflags
init|=
name|v
operator|->
name|uv_flags
decl_stmt|;
specifier|register
name|u_char
name|rflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_TUNNEL
condition|)
name|rflags
operator||=
name|DVMRP_NF_TUNNEL
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_SRCRT
condition|)
name|rflags
operator||=
name|DVMRP_NF_SRCRT
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_DOWN
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_DISABLED
condition|)
name|rflags
operator||=
name|DVMRP_NF_DISABLED
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_QUERIER
condition|)
name|rflags
operator||=
name|DVMRP_NF_QUERIER
expr_stmt|;
if|if
condition|(
name|vflags
operator|&
name|VIFF_LEAF
condition|)
name|rflags
operator||=
name|DVMRP_NF_LEAF
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
name|la
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * include down& disabled interfaces and interfaces on 	     * leaf nets. 	     */
if|if
condition|(
name|rflags
operator|&
name|DVMRP_NF_TUNNEL
condition|)
name|rflags
operator||=
name|DVMRP_NF_DOWN
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|MAX_DVMRP_DATA_LEN
operator|-
literal|12
condition|)
block|{
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rflags
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_rmt_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|12
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|la
condition|;
name|la
operator|=
name|la
operator|->
name|al_next
control|)
block|{
comment|/* Make sure that there's room for this neighbor... */
if|if
condition|(
name|datalen
operator|+
operator|(
name|ncount
operator|==
literal|0
condition|?
literal|4
operator|+
literal|4
operator|+
literal|4
else|:
literal|4
operator|)
operator|>
name|MAX_DVMRP_DATA_LEN
condition|)
block|{
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Put out the header for this neighbor list... */
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|v
operator|->
name|uv_lcl_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_metric
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|v
operator|->
name|uv_threshold
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rflags
expr_stmt|;
name|ncount
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|datalen
operator|+=
literal|4
operator|+
literal|4
expr_stmt|;
block|}
operator|*
operator|(
name|u_int
operator|*
operator|)
name|p
operator|=
name|la
operator|->
name|al_addr
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|datalen
operator|+=
literal|4
expr_stmt|;
operator|(
operator|*
name|ncount
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|them
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_NEIGHBORS2
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|accept_info_request
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|u_char
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|outlen
init|=
literal|0
decl_stmt|;
name|q
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|send_buf
operator|+
name|MIN_IP_HEADER_LEN
operator|+
name|IGMP_MINLEN
operator|)
expr_stmt|;
comment|/* To be general, this must deal properly with breaking up over-sized      * packets.  That implies passing a length to each function, and      * allowing each function to request to be called again.  Right now,      * we're only implementing the one thing we are positive will fit into      * a single packet, so we wimp out.      */
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|DVMRP_INFO_VERSION
case|:
name|len
operator|=
name|info_version
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_INFO_NEIGHBORS
case|:
default|default:
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring unknown info type %d"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
name|len
operator|++
expr_stmt|;
name|outlen
operator|+=
name|len
operator|*
literal|4
expr_stmt|;
name|q
operator|+=
name|len
operator|*
literal|4
expr_stmt|;
name|len
operator|=
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|datalen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|outlen
operator|!=
literal|0
condition|)
name|send_igmp
argument_list|(
name|INADDR_ANY
argument_list|,
name|src
argument_list|,
name|IGMP_DVMRP
argument_list|,
name|DVMRP_INFO_REPLY
argument_list|,
name|htonl
argument_list|(
name|MROUTED_LEVEL
argument_list|)
argument_list|,
name|outlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Information response -- return version string  */
end_comment

begin_function
specifier|static
name|int
name|info_version
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
specifier|extern
name|char
name|versionstring
index|[]
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|DVMRP_INFO_VERSION
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* skip over length */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* zero out */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* reserved fields */
name|strcpy
argument_list|(
name|p
argument_list|,
name|versionstring
argument_list|)
expr_stmt|;
comment|/* XXX strncpy!!! */
name|len
operator|=
name|strlen
argument_list|(
name|versionstring
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor-list message.  */
end_comment

begin_function
name|void
name|accept_neighbors
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP neighbor list from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming neighbor-list message.  */
end_comment

begin_function
name|void
name|accept_neighbors2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|level
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP neighbor list2 from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an incoming info reply message.  */
end_comment

begin_function
name|void
name|accept_info_reply
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|)
name|u_int32
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"ignoring spurious DVMRP info reply from %s to %s"
argument_list|,
name|inet_fmt
argument_list|(
name|src
argument_list|,
name|s1
argument_list|)
argument_list|,
name|inet_fmt
argument_list|(
name|dst
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the neighbor entry for neighbor 'addr' on vif 'vifi'.  * 'msgtype' is the type of DVMRP message received from the neighbor.  * Return TRUE if 'addr' is a valid neighbor, FALSE otherwise.  */
end_comment

begin_function
name|int
name|update_neighbor
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|,
name|msgtype
parameter_list|,
name|p
parameter_list|,
name|datalen
parameter_list|,
name|level
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
name|int
name|msgtype
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int32
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|n
decl_stmt|;
name|u_int32
name|genid
init|=
literal|0
decl_stmt|;
name|u_int32
name|router
decl_stmt|;
name|u_int32
name|send_tables
init|=
literal|0
decl_stmt|;
name|int
name|do_reset
init|=
name|FALSE
decl_stmt|;
name|int
name|nflags
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
name|nflags
operator|=
operator|(
name|level
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/*      * Confirm that 'addr' is a valid neighbor address on vif 'vifi'.      * IT IS ASSUMED that this was preceded by a call to find_vif(), which      * checks that 'addr' is either a valid remote tunnel endpoint or a      * non-broadcast address belonging to a directly-connected subnet.      * Therefore, here we check only that 'addr' is not our own address      * (due to an impostor or erroneous loopback) or an address of the form      * {subnet,0} ("the unknown host").  These checks are not performed in      * find_vif() because those types of address are acceptable for some      * types of IGMP message (such as group membership reports).      */
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
operator|(
name|addr
operator|==
name|v
operator|->
name|uv_lcl_addr
operator|||
name|addr
operator|==
name|v
operator|->
name|uv_subnet
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received DVMRP message from 'the unknown host' or self: %s"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*      * Look for addr in list of neighbors.      */
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|addr
operator|==
name|n
operator|->
name|al_addr
condition|)
block|{
break|break;
block|}
block|}
comment|/*      * Found it.  Reset its timer, and check for a version change      */
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * update the neighbors version and protocol number 	 * if changed => router went down and came up,  	 * so take action immediately. 	 */
if|if
condition|(
operator|(
name|n
operator|->
name|al_pv
operator|!=
operator|(
name|level
operator|&
literal|0xff
operator|)
operator|)
operator|||
operator|(
name|n
operator|->
name|al_mv
operator|!=
operator|(
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|do_reset
operator|=
name|TRUE
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"version change neighbor %s [old:%d.%d, new:%d.%d]"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|n
operator|->
name|al_pv
argument_list|,
name|n
operator|->
name|al_mv
argument_list|,
name|level
operator|&
literal|0xff
argument_list|,
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_pv
operator|=
name|level
operator|&
literal|0xff
expr_stmt|;
name|n
operator|->
name|al_mv
operator|=
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * If not found, add it to the list.  If the neighbor has a lower 	 * IP address than me, yield querier duties to it. 	 */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"New neighbor %s on vif %d v%d.%d nf 0x%02x"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|level
operator|&
literal|0xff
argument_list|,
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|level
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
comment|/* fatal */
name|n
operator|->
name|al_addr
operator|=
name|addr
expr_stmt|;
name|n
operator|->
name|al_pv
operator|=
name|level
operator|&
literal|0xff
expr_stmt|;
name|n
operator|->
name|al_mv
operator|=
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|n
operator|->
name|al_genid
operator|=
literal|0
expr_stmt|;
name|time
argument_list|(
operator|&
name|n
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_timer
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|al_next
operator|=
name|v
operator|->
name|uv_neighbors
expr_stmt|;
comment|/* 	 * If we thought that we had no neighbors on this vif, send a route 	 * report to the vif.  If this is just a new neighbor on the same 	 * vif, send the route report just to the new neighbor. 	 */
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
block|{
name|send_tables
operator|=
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|addr
else|:
name|dvmrp_group
expr_stmt|;
name|vifs_with_neighbors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|send_tables
operator|=
name|addr
expr_stmt|;
block|}
name|v
operator|->
name|uv_neighbors
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|&&
name|ntohl
argument_list|(
name|addr
argument_list|)
operator|<
name|ntohl
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
condition|)
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
comment|/*      * Check if the router gen-ids are the same.      * Need to reset the prune state of the router if not.      * Also check for one-way interfaces by seeing if we are in our      * neighbor's list of known routers.      */
if|if
condition|(
name|msgtype
operator|==
name|DVMRP_PROBE
condition|)
block|{
comment|/* Check genid neighbor flag.  Also check version number; 3.3 and 	 * 3.4 didn't set this flag. */
if|if
condition|(
operator|(
operator|(
operator|(
name|level
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|&
name|NF_GENID
operator|)
operator|||
operator|(
operator|(
operator|(
name|level
operator|&
literal|0xff
operator|)
operator|==
literal|3
operator|)
operator|&&
operator|(
operator|(
operator|(
name|level
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|>
literal|2
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|datalen
operator|<
literal|4
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated probe message from %s (len %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|genid
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|datalen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|al_genid
operator|==
literal|0
condition|)
name|n
operator|->
name|al_genid
operator|=
name|genid
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|al_genid
operator|!=
name|genid
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"new genid neigbor %s on vif %d [old:%x, new:%x]"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|vifi
argument_list|,
name|n
operator|->
name|al_genid
argument_list|,
name|genid
argument_list|)
expr_stmt|;
name|n
operator|->
name|al_genid
operator|=
name|genid
expr_stmt|;
name|do_reset
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*  	     * loop through router list and check for one-way ifs. 	     */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_ONEWAY
expr_stmt|;
while|while
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|datalen
operator|<
literal|4
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"received truncated probe message from %s (len %d)"
argument_list|,
name|inet_fmt
argument_list|(
name|addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|router
operator|)
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|datalen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|router
operator|==
name|v
operator|->
name|uv_lcl_addr
condition|)
block|{
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_ONEWAY
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|n
operator|->
name|al_flags
operator|!=
name|nflags
condition|)
block|{
name|n
operator|->
name|al_flags
operator|=
name|nflags
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|al_flags
operator|&
name|NF_LEAF
condition|)
block|{
comment|/*XXX If we have non-leaf neighbors then we know we shouldn't 	     * mark this vif as a leaf.  For now we just count on other 	     * probes and/or reports resetting the timer. */
if|if
condition|(
operator|!
name|v
operator|->
name|uv_leaf_timer
condition|)
name|v
operator|->
name|uv_leaf_timer
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
block|}
else|else
block|{
comment|/* If we get a leaf to non-leaf transition, we *must* update 	     * the routing table. */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_LEAF
operator|&&
name|send_tables
operator|==
literal|0
condition|)
name|send_tables
operator|=
name|addr
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_LEAF
expr_stmt|;
name|v
operator|->
name|uv_leaf_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_reset
condition|)
block|{
name|reset_neighbor_state
argument_list|(
name|vifi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|send_tables
condition|)
name|send_tables
operator|=
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|send_tables
condition|)
name|report
argument_list|(
name|ALL_ROUTES
argument_list|,
name|vifi
argument_list|,
name|send_tables
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance the timer in each neighbor and  * group entry on every vif.  */
end_comment

begin_function
name|void
name|age_vifs
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|,
modifier|*
name|prev_a
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|register
name|u_int32
name|addr
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_leaf_timer
operator|&&
operator|(
name|v
operator|->
name|uv_leaf_timer
operator|-=
name|TIMER_INTERVAL
operator|==
literal|0
operator|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_LEAF
expr_stmt|;
block|}
for|for
control|(
name|prev_a
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
operator|&
operator|(
name|v
operator|->
name|uv_neighbors
operator|)
operator|,
name|a
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|a
operator|!=
name|NULL
condition|;
name|prev_a
operator|=
name|a
operator|,
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|al_timer
operator|+=
name|TIMER_INTERVAL
operator|)
operator|<
name|NEIGHBOR_EXPIRE_TIME
condition|)
continue|continue;
comment|/* 	     * Neighbor has expired; delete it from the neighbor list, 	     * delete it from the 'dominants' and 'subordinates arrays of 	     * any route entries and assume querier duties unless there is 	     * another neighbor with a lower IP address than mine. 	     */
name|addr
operator|=
name|a
operator|->
name|al_addr
expr_stmt|;
name|prev_a
operator|->
name|al_next
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|prev_a
expr_stmt|;
name|delete_neighbor_from_routes
argument_list|(
name|addr
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|==
name|NULL
condition|)
name|vifs_with_neighbors
operator|--
expr_stmt|;
name|v
operator|->
name|uv_leaf_timer
operator|=
name|LEAF_CONFIRMATION_TIME
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|al_next
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|n
operator|->
name|al_addr
argument_list|)
operator|<
name|ntohl
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|)
condition|)
block|{
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_QUERIER
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|al_flags
operator|&
name|NF_LEAF
operator|)
condition|)
block|{
name|v
operator|->
name|uv_leaf_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the neighbor info struct for a given neighbor  */
end_comment

begin_function
name|struct
name|listaddr
modifier|*
name|neighbor_info
parameter_list|(
name|vifi
parameter_list|,
name|addr
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|u_int32
name|addr
decl_stmt|;
block|{
name|struct
name|listaddr
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_neighbors
init|;
name|u
condition|;
name|u
operator|=
name|u
operator|->
name|al_next
control|)
if|if
condition|(
name|u
operator|->
name|al_addr
operator|==
name|addr
condition|)
return|return
name|u
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Print the contents of the uvifs array on file 'fp'.  */
end_comment

begin_function
name|void
name|dump_vifs
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|struct
name|sioc_vif_req
name|v_req
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"vifs_with_neighbors = %d\n"
argument_list|,
name|vifs_with_neighbors
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifs_with_neighbors
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[This host is a leaf]\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nVirtual Interface Table\n%s"
argument_list|,
literal|"Vif  Name  Local-Address                               "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"M  Thr  Rate   Flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%2u %6s  %-15s %6s: %-18s %2u %3u  %5u  "
argument_list|,
name|vifi
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
literal|"tunnel"
else|:
literal|"subnet"
argument_list|,
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_rmt_addr
argument_list|,
name|s2
argument_list|)
else|:
name|inet_fmts
argument_list|(
name|v
operator|->
name|uv_subnet
argument_list|,
name|v
operator|->
name|uv_subnetmask
argument_list|,
name|s3
argument_list|)
argument_list|,
name|v
operator|->
name|uv_metric
argument_list|,
name|v
operator|->
name|uv_threshold
argument_list|,
name|v
operator|->
name|uv_rate_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_ONEWAY
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" one-way"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" querier"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_SRCRT
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" src-rt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_LEAF
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" leaf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_IGMPV1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" IGMPv1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_addrs
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                alternate subnets: %s\n"
argument_list|,
name|inet_fmts
argument_list|(
name|v
operator|->
name|uv_addrs
operator|->
name|pa_subnet
argument_list|,
name|v
operator|->
name|uv_addrs
operator|->
name|pa_subnetmask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
operator|->
name|pa_next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                                   %s\n"
argument_list|,
name|inet_fmts
argument_list|(
name|p
operator|->
name|pa_subnet
argument_list|,
name|p
operator|->
name|pa_subnetmask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|uv_neighbors
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                            peers: %s (%d.%d) (0x%x)\n"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_neighbors
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|v
operator|->
name|uv_neighbors
operator|->
name|al_pv
argument_list|,
name|v
operator|->
name|uv_neighbors
operator|->
name|al_mv
argument_list|,
name|v
operator|->
name|uv_neighbors
operator|->
name|al_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|v
operator|->
name|uv_neighbors
operator|->
name|al_next
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                                   %s (%d.%d) (0x%x)\n"
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|,
name|a
operator|->
name|al_pv
argument_list|,
name|a
operator|->
name|al_mv
argument_list|,
name|a
operator|->
name|al_flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                           groups: %-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|v
operator|->
name|uv_groups
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|v
operator|->
name|uv_groups
operator|->
name|al_next
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|al_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                                   %-15s\n"
argument_list|,
name|inet_fmt
argument_list|(
name|a
operator|->
name|al_addr
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|uv_acl
operator|!=
name|NULL
condition|)
block|{
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                       boundaries: %-18s\n"
argument_list|,
name|inet_fmts
argument_list|(
name|v
operator|->
name|uv_acl
operator|->
name|acl_addr
argument_list|,
name|v
operator|->
name|uv_acl
operator|->
name|acl_mask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|acl
operator|=
name|v
operator|->
name|uv_acl
operator|->
name|acl_next
init|;
name|acl
operator|!=
name|NULL
condition|;
name|acl
operator|=
name|acl
operator|->
name|acl_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                                 : %-18s\n"
argument_list|,
name|inet_fmts
argument_list|(
name|acl
operator|->
name|acl_addr
argument_list|,
name|acl
operator|->
name|acl_mask
argument_list|,
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|v_req
operator|.
name|vifi
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETVIFCNT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v_req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"SIOCGETVIFCNT fails"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                         pkts in : %ld\n"
argument_list|,
name|v_req
operator|.
name|icount
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"                         pkts out: %ld\n"
argument_list|,
name|v_req
operator|.
name|ocount
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Time out record of a group membership on a vif  */
end_comment

begin_function
specifier|static
name|void
name|DelVif
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
init|=
operator|(
name|cbk_t
operator|*
operator|)
name|arg
decl_stmt|;
name|vifi_t
name|vifi
init|=
name|cbk
operator|->
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|vifi
index|]
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|anp
decl_stmt|,
modifier|*
name|g
init|=
name|cbk
operator|->
name|g
decl_stmt|;
comment|/*      * Group has expired      * delete all kernel cache entries with this group      */
if|if
condition|(
name|g
operator|->
name|al_query
condition|)
name|DeleteTimer
argument_list|(
name|g
operator|->
name|al_query
argument_list|)
expr_stmt|;
name|delete_lclgrp
argument_list|(
name|vifi
argument_list|,
name|g
operator|->
name|al_addr
argument_list|)
expr_stmt|;
name|anp
operator|=
operator|&
operator|(
name|v
operator|->
name|uv_groups
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
operator|*
name|anp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|==
name|g
condition|)
block|{
operator|*
name|anp
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|anp
operator|=
operator|&
name|a
operator|->
name|al_next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a timer to delete the record of a group membership on a vif.  */
end_comment

begin_function
specifier|static
name|int
name|SetTimer
parameter_list|(
name|vifi
parameter_list|,
name|g
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
decl_stmt|;
name|cbk
operator|=
operator|(
name|cbk_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cbk_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|cbk
operator|->
name|vifi
operator|=
name|vifi
expr_stmt|;
return|return
name|timer_setTimer
argument_list|(
name|g
operator|->
name|al_timer
argument_list|,
operator|(
name|cfunc_t
operator|)
name|DelVif
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cbk
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a timer that was set above.  */
end_comment

begin_function
specifier|static
name|int
name|DeleteTimer
parameter_list|(
name|id
parameter_list|)
name|int
name|id
decl_stmt|;
block|{
name|timer_clearTimer
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a group-specific query.  */
end_comment

begin_function
specifier|static
name|void
name|SendQuery
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
init|=
operator|(
name|cbk_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|cbk
operator|->
name|vifi
index|]
decl_stmt|;
name|send_igmp
argument_list|(
name|v
operator|->
name|uv_lcl_addr
argument_list|,
name|cbk
operator|->
name|g
operator|->
name|al_addr
argument_list|,
name|IGMP_HOST_MEMBERSHIP_QUERY
argument_list|,
name|cbk
operator|->
name|q_time
argument_list|,
name|cbk
operator|->
name|g
operator|->
name|al_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|g
operator|->
name|al_query
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a timer to send a group-specific query.  */
end_comment

begin_function
specifier|static
name|int
name|SetQueryTimer
parameter_list|(
name|g
parameter_list|,
name|vifi
parameter_list|,
name|to_expire
parameter_list|,
name|q_time
parameter_list|)
name|struct
name|listaddr
modifier|*
name|g
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|to_expire
decl_stmt|,
name|q_time
decl_stmt|;
block|{
name|cbk_t
modifier|*
name|cbk
decl_stmt|;
name|cbk
operator|=
operator|(
name|cbk_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cbk_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|cbk
operator|->
name|q_time
operator|=
name|q_time
expr_stmt|;
name|cbk
operator|->
name|vifi
operator|=
name|vifi
expr_stmt|;
return|return
name|timer_setTimer
argument_list|(
name|to_expire
argument_list|,
operator|(
name|cfunc_t
operator|)
name|SendQuery
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cbk
argument_list|)
return|;
block|}
end_function

end_unit

