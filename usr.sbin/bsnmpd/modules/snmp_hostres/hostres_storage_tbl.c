begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2006 The FreeBSD Project  * All rights reserved.  *  * Author: Victor Cruceru<soc-victor@freebsd.org>  *  * Redistribution of this software and documentation and use in source and  * binary forms, with or without modification, are permitted provided that  * the following conditions are met:  *  * 1. Redistributions of source code or documentation must retain the above  *    copyright notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Host Resources MIB for SNMPd. Implementation for hrStorageTable  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<memstat.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* for getpagesize() */
end_comment

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|"hostres_snmp.h"
end_include

begin_include
include|#
directive|include
file|"hostres_oid.h"
end_include

begin_include
include|#
directive|include
file|"hostres_tree.h"
end_include

begin_comment
comment|/* maximum length for descritpion string according to MIB */
end_comment

begin_define
define|#
directive|define
name|SE_DESC_MLEN
value|(255 + 1)
end_define

begin_comment
comment|/*  * This structure is used to hold a SNMP table entry  * for HOST-RESOURCES-MIB's hrStorageTable  */
end_comment

begin_struct
struct|struct
name|storage_entry
block|{
name|int32_t
name|index
decl_stmt|;
specifier|const
name|struct
name|asn_oid
modifier|*
name|type
decl_stmt|;
name|u_char
modifier|*
name|descr
decl_stmt|;
name|int32_t
name|allocationUnits
decl_stmt|;
name|int32_t
name|size
decl_stmt|;
name|int32_t
name|used
decl_stmt|;
name|uint32_t
name|allocationFailures
decl_stmt|;
define|#
directive|define
name|HR_STORAGE_FOUND
value|0x001
name|uint32_t
name|flags
decl_stmt|;
comment|/* to be used internally*/
name|TAILQ_ENTRY
argument_list|(
argument|storage_entry
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|storage_tbl
argument_list|,
name|storage_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Next structure is used to keep o list of mappings from a specific name  * (a_name) to an entry in the hrStorageTblEntry. We are trying to keep the  * same index for a specific name at least for the duration of one SNMP agent  * run.  */
end_comment

begin_struct
struct|struct
name|storage_map_entry
block|{
name|int32_t
name|hrIndex
decl_stmt|;
comment|/* used for storage_entry::index */
comment|/* map key, also used for storage_entry::descr */
name|u_char
modifier|*
name|a_name
decl_stmt|;
comment|/* 	 * next may be NULL if the respective storage_entry 	 * is (temporally) gone 	 */
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|storage_map_entry
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|storage_map
argument_list|,
name|storage_map_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the head of the list with table's entries */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|storage_tbl
name|storage_tbl
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|storage_tbl
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*for consistent table indexing*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|storage_map
name|storage_map
init|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|storage_map
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last (agent) tick when hrStorageTable was updated */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|storage_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of ticks between two refreshs */
end_comment

begin_decl_stmt
name|uint32_t
name|storage_tbl_refresh
init|=
name|HR_STORAGE_TBL_REFRESH
operator|*
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for kvm_getswapinfo, malloc'd */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kvm_swap
modifier|*
name|swap_devs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|swap_devs_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* item count for swap_devs */
end_comment

begin_comment
comment|/* for getfsstat, malloc'd */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|statfs
modifier|*
name|fs_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|fs_buf_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* item count for fs_buf */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vmtotal
name|mem_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next int available for indexing the hrStorageTable */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|next_storage_index
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of list for memory detailed stats */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|memory_type_list
modifier|*
name|mt_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asn_oid
name|OIDX_hrStorageRam_c
init|=
name|OIDX_hrStorageRam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asn_oid
name|OIDX_hrStorageVirtualMemory_c
init|=
name|OIDX_hrStorageVirtualMemory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Create a new entry into the storage table and, if necessary, an  * entry into the storage map.  */
end_comment

begin_function
specifier|static
name|struct
name|storage_entry
modifier|*
name|storage_entry_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|storage_map_entry
modifier|*
name|map
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|map
argument_list|,
argument|&storage_map
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|map
operator|->
name|a_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
comment|/* new object - get a new index */
if|if
condition|(
name|next_storage_index
operator|>
name|INT_MAX
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: hrStorageTable index wrap"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"hrStorageTable index wrap"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStorageTable: %s: %m"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|name_len
operator|>
name|SE_DESC_MLEN
condition|)
name|name_len
operator|=
name|SE_DESC_MLEN
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|a_name
operator|=
name|malloc
argument_list|(
name|name_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|map
operator|->
name|a_name
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|map
operator|->
name|hrIndex
operator|=
name|next_storage_index
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|storage_map
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|HRDBG
argument_list|(
literal|"%s added into hrStorageMap at index=%d"
argument_list|,
name|name
argument_list|,
name|map
operator|->
name|hrIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HRDBG
argument_list|(
literal|"%s exists in hrStorageMap index=%d\n"
argument_list|,
name|name
argument_list|,
name|map
operator|->
name|hrIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: %m"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|index
operator|=
name|map
operator|->
name|hrIndex
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|descr
operator|=
name|strdup
argument_list|(
name|map
operator|->
name|a_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|map
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|INSERT_OBJECT_INT
argument_list|(
name|entry
argument_list|,
operator|&
name|storage_tbl
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Delete an entry from the storage table.  */
end_comment

begin_function
specifier|static
name|void
name|storage_entry_delete
parameter_list|(
name|struct
name|storage_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|storage_map_entry
modifier|*
name|map
decl_stmt|;
name|assert
argument_list|(
name|entry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|storage_tbl
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|map
argument_list|,
argument|&storage_map
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|map
operator|->
name|entry
operator|==
name|entry
condition|)
block|{
name|map
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|entry
operator|->
name|descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Find a table entry by its name.  */
end_comment

begin_function
specifier|static
name|struct
name|storage_entry
modifier|*
name|storage_find_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&storage_tbl
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|descr
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|entry
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VM info.  */
end_comment

begin_function
specifier|static
name|void
name|storage_OS_get_vm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|mib
index|[
literal|2
index|]
init|=
block|{
name|CTL_VM
block|,
name|VM_TOTAL
block|}
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|mem_stats
argument_list|)
decl_stmt|;
name|int
name|page_size_bytes
decl_stmt|;
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|mem_stats
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStoragetable: %s: sysctl({CTL_VM, VM_METER}) "
literal|"failed: %m"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|page_size_bytes
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
comment|/* Real Memory Metrics */
if|if
condition|(
operator|(
name|entry
operator|=
name|storage_find_by_name
argument_list|(
literal|"Real Memory Metrics"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|entry
operator|=
name|storage_entry_create
argument_list|(
literal|"Real Memory Metrics"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* I'm out of luck now, maybe next time */
name|entry
operator|->
name|flags
operator||=
name|HR_STORAGE_FOUND
expr_stmt|;
name|entry
operator|->
name|type
operator|=
operator|&
name|OIDX_hrStorageRam_c
expr_stmt|;
name|entry
operator|->
name|allocationUnits
operator|=
name|page_size_bytes
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|mem_stats
operator|.
name|t_rm
expr_stmt|;
name|entry
operator|->
name|used
operator|=
name|mem_stats
operator|.
name|t_arm
expr_stmt|;
comment|/* ACTIVE is not USED - FIXME */
name|entry
operator|->
name|allocationFailures
operator|=
literal|0
expr_stmt|;
comment|/* Shared Real Memory Metrics */
if|if
condition|(
operator|(
name|entry
operator|=
name|storage_find_by_name
argument_list|(
literal|"Shared Real Memory Metrics"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|entry
operator|=
name|storage_entry_create
argument_list|(
literal|"Shared Real Memory Metrics"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|flags
operator||=
name|HR_STORAGE_FOUND
expr_stmt|;
name|entry
operator|->
name|type
operator|=
operator|&
name|OIDX_hrStorageRam_c
expr_stmt|;
name|entry
operator|->
name|allocationUnits
operator|=
name|page_size_bytes
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|mem_stats
operator|.
name|t_rmshr
expr_stmt|;
comment|/* ACTIVE is not USED - FIXME */
name|entry
operator|->
name|used
operator|=
name|mem_stats
operator|.
name|t_armshr
expr_stmt|;
name|entry
operator|->
name|allocationFailures
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|storage_OS_get_memstat
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|memory_type
modifier|*
name|mt_item
decl_stmt|;
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|mt_list
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|mt_list
operator|=
name|memstat_mtl_alloc
argument_list|()
operator|)
operator|==
name|NULL
condition|)
comment|/* again? we have a serious problem */
return|return;
block|}
if|if
condition|(
name|memstat_sysctl_all
argument_list|(
name|mt_list
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"memstat_sysctl_all failed: %s"
argument_list|,
name|memstat_strerror
argument_list|(
name|memstat_mtl_geterror
argument_list|(
name|mt_list
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|mt_item
operator|=
name|memstat_mtl_first
argument_list|(
name|mt_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* usually this is not an error, no errno for this failure*/
name|HRDBG
argument_list|(
literal|"memstat_mtl_first failed"
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
specifier|const
name|char
modifier|*
name|memstat_name
decl_stmt|;
name|uint64_t
name|tmp_size
decl_stmt|;
name|int
name|allocator
decl_stmt|;
name|char
name|alloc_descr
index|[
name|SE_DESC_MLEN
index|]
decl_stmt|;
name|memstat_name
operator|=
name|memstat_get_name
argument_list|(
name|mt_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|memstat_name
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|memstat_name
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|allocator
operator|=
name|memstat_get_allocator
argument_list|(
name|mt_item
argument_list|)
condition|)
block|{
case|case
name|ALLOCATOR_MALLOC
case|:
name|snprintf
argument_list|(
name|alloc_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc_descr
argument_list|)
argument_list|,
literal|"MALLOC: %s"
argument_list|,
name|memstat_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALLOCATOR_UMA
case|:
name|snprintf
argument_list|(
name|alloc_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc_descr
argument_list|)
argument_list|,
literal|"UMA: %s"
argument_list|,
name|memstat_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|alloc_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc_descr
argument_list|)
argument_list|,
literal|"UNKNOWN%d: %s"
argument_list|,
name|allocator
argument_list|,
name|memstat_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|entry
operator|=
name|storage_find_by_name
argument_list|(
name|alloc_descr
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|entry
operator|=
name|storage_entry_create
argument_list|(
name|alloc_descr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|flags
operator||=
name|HR_STORAGE_FOUND
expr_stmt|;
name|entry
operator|->
name|type
operator|=
operator|&
name|OIDX_hrStorageRam_c
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_size
operator|=
name|memstat_get_size
argument_list|(
name|mt_item
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tmp_size
operator|=
name|memstat_get_sizemask
argument_list|(
name|mt_item
argument_list|)
expr_stmt|;
name|entry
operator|->
name|allocationUnits
operator|=
operator|(
name|tmp_size
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
operator|(
name|int32_t
operator|)
name|tmp_size
operator|)
expr_stmt|;
name|tmp_size
operator|=
name|memstat_get_countlimit
argument_list|(
name|mt_item
argument_list|)
expr_stmt|;
name|entry
operator|->
name|size
operator|=
operator|(
name|tmp_size
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
operator|(
name|int32_t
operator|)
name|tmp_size
operator|)
expr_stmt|;
name|tmp_size
operator|=
name|memstat_get_count
argument_list|(
name|mt_item
argument_list|)
expr_stmt|;
name|entry
operator|->
name|used
operator|=
operator|(
name|tmp_size
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
operator|(
name|int32_t
operator|)
name|tmp_size
operator|)
expr_stmt|;
name|tmp_size
operator|=
name|memstat_get_failures
argument_list|(
name|mt_item
argument_list|)
expr_stmt|;
name|entry
operator|->
name|allocationFailures
operator|=
operator|(
name|tmp_size
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
operator|(
name|int32_t
operator|)
name|tmp_size
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|mt_item
operator|=
name|memstat_mtl_next
argument_list|(
name|mt_item
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/**  * Get swap info  */
end_comment

begin_function
specifier|static
name|void
name|storage_OS_get_swap
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nswapdev
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|nswapdev
argument_list|)
decl_stmt|;
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
name|char
name|swap_w_prefix
index|[
name|SE_DESC_MLEN
index|]
decl_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"vm.nswapdev"
argument_list|,
operator|&
name|nswapdev
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStorageTable: sysctlbyname(\"vm.nswapdev\") "
literal|"failed. %m"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nswapdev
operator|<=
literal|0
condition|)
block|{
name|HRDBG
argument_list|(
literal|"vm.nswapdev is %d"
argument_list|,
name|nswapdev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nswapdev
operator|+
literal|1
operator|!=
operator|(
name|int
operator|)
name|swap_devs_len
operator|||
name|swap_devs
operator|==
name|NULL
condition|)
block|{
name|swap_devs_len
operator|=
name|nswapdev
operator|+
literal|1
expr_stmt|;
name|swap_devs
operator|=
name|reallocf
argument_list|(
name|swap_devs
argument_list|,
name|swap_devs_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kvm_swap
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|swap_devs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_devs
operator|==
name|NULL
condition|)
block|{
name|swap_devs_len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|nswapdev
operator|=
name|kvm_getswapinfo
argument_list|(
name|hr_kd
argument_list|,
name|swap_devs
argument_list|,
name|swap_devs_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nswapdev
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStorageTable: kvm_getswapinfo failed. %m\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
operator|(
name|size_t
operator|)
name|nswapdev
condition|;
name|len
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|swap_w_prefix
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|swap_w_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|swap_w_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|swap_w_prefix
argument_list|)
operator|-
literal|1
argument_list|,
literal|"Swap:%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|swap_devs
index|[
name|len
index|]
operator|.
name|ksw_devname
argument_list|)
expr_stmt|;
name|entry
operator|=
name|storage_find_by_name
argument_list|(
name|swap_w_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|entry
operator|=
name|storage_entry_create
argument_list|(
name|swap_w_prefix
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|entry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
comment|/* Out of luck */
name|entry
operator|->
name|flags
operator||=
name|HR_STORAGE_FOUND
expr_stmt|;
name|entry
operator|->
name|type
operator|=
operator|&
name|OIDX_hrStorageVirtualMemory_c
expr_stmt|;
name|entry
operator|->
name|allocationUnits
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|swap_devs
index|[
name|len
index|]
operator|.
name|ksw_total
expr_stmt|;
name|entry
operator|->
name|used
operator|=
name|swap_devs
index|[
name|len
index|]
operator|.
name|ksw_used
expr_stmt|;
name|entry
operator|->
name|allocationFailures
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Query the underlaying OS for the mounted file systems  * anf fill in the respective lists (for hrStorageTable and for hrFSTable)  */
end_comment

begin_function
specifier|static
name|void
name|storage_OS_get_fs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
name|uint64_t
name|used_blocks_count
init|=
literal|0
decl_stmt|;
name|char
name|fs_string
index|[
name|SE_DESC_MLEN
index|]
decl_stmt|;
name|int
name|mounted_fs_count
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mounted_fs_count
operator|=
name|getfsstat
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|MNT_NOWAIT
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStorageTable: getfsstat() failed: %m"
argument_list|)
expr_stmt|;
return|return;
comment|/* out of luck this time */
block|}
if|if
condition|(
name|mounted_fs_count
operator|!=
operator|(
name|int
operator|)
name|fs_buf_count
operator|||
name|fs_buf
operator|==
name|NULL
condition|)
block|{
name|fs_buf_count
operator|=
name|mounted_fs_count
expr_stmt|;
name|fs_buf
operator|=
name|reallocf
argument_list|(
name|fs_buf
argument_list|,
name|fs_buf_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_buf
operator|==
name|NULL
condition|)
block|{
name|fs_buf_count
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|mounted_fs_count
operator|=
name|getfsstat
argument_list|(
name|fs_buf
argument_list|,
name|fs_buf_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|,
name|MNT_NOWAIT
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStorageTable: getfsstat() failed: %m"
argument_list|)
expr_stmt|;
return|return;
comment|/* out of luck this time */
block|}
name|HRDBG
argument_list|(
literal|"got %d mounted FS"
argument_list|,
name|mounted_fs_count
argument_list|)
expr_stmt|;
name|fs_tbl_pre_refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mounted_fs_count
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|fs_string
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_string
argument_list|)
argument_list|,
literal|"%s, type: %s, dev: %s"
argument_list|,
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_mntonname
argument_list|,
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_fstypename
argument_list|,
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|entry
operator|=
name|storage_find_by_name
argument_list|(
name|fs_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|entry
operator|=
name|storage_entry_create
argument_list|(
name|fs_string
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|entry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
comment|/* Out of luck */
name|entry
operator|->
name|flags
operator||=
name|HR_STORAGE_FOUND
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|fs_get_type
argument_list|(
operator|&
name|fs_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*XXX - This is wrong*/
if|if
condition|(
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_bsize
operator|>
name|INT_MAX
condition|)
name|entry
operator|->
name|allocationUnits
operator|=
name|INT_MAX
expr_stmt|;
else|else
name|entry
operator|->
name|allocationUnits
operator|=
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_bsize
expr_stmt|;
if|if
condition|(
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_blocks
operator|>
name|INT_MAX
condition|)
name|entry
operator|->
name|size
operator|=
name|INT_MAX
expr_stmt|;
else|else
name|entry
operator|->
name|size
operator|=
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_blocks
expr_stmt|;
name|used_blocks_count
operator|=
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_blocks
operator|-
name|fs_buf
index|[
name|i
index|]
operator|.
name|f_bfree
expr_stmt|;
if|if
condition|(
name|used_blocks_count
operator|>
name|INT_MAX
condition|)
name|entry
operator|->
name|used
operator|=
name|INT_MAX
expr_stmt|;
else|else
name|entry
operator|->
name|used
operator|=
name|used_blocks_count
expr_stmt|;
name|entry
operator|->
name|allocationFailures
operator|=
literal|0
expr_stmt|;
comment|/* take care of hrFSTable */
name|fs_tbl_process_statfs_entry
argument_list|(
operator|&
name|fs_buf
index|[
name|i
index|]
argument_list|,
name|entry
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|fs_tbl_post_refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize storage table and populate it.  */
end_comment

begin_function
name|void
name|init_storage_tbl
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mt_list
operator|=
name|memstat_mtl_alloc
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hrStorageTable: memstat_mtl_alloc() failed: %m"
argument_list|)
expr_stmt|;
name|refresh_storage_tbl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fini_storage_tbl
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|storage_map_entry
modifier|*
name|n1
decl_stmt|;
if|if
condition|(
name|swap_devs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|swap_devs
argument_list|)
expr_stmt|;
name|swap_devs
operator|=
name|NULL
expr_stmt|;
block|}
name|swap_devs_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fs_buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fs_buf
argument_list|)
expr_stmt|;
name|fs_buf
operator|=
name|NULL
expr_stmt|;
block|}
name|fs_buf_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|storage_map
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|storage_map
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|->
name|entry
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|storage_tbl
argument_list|,
name|n1
operator|->
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n1
operator|->
name|entry
operator|->
name|descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n1
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|n1
operator|->
name|a_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|storage_tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|refresh_storage_tbl
parameter_list|(
name|int
name|force
parameter_list|)
block|{
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry_tmp
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|storage_tick
operator|!=
literal|0
operator|&&
name|this_tick
operator|-
name|storage_tick
operator|<
name|storage_tbl_refresh
condition|)
block|{
name|HRDBG
argument_list|(
literal|"no refresh needed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* mark each entry as missing */
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&storage_tbl
argument_list|,
argument|link
argument_list|)
name|entry
operator|->
name|flags
operator|&=
operator|~
name|HR_STORAGE_FOUND
expr_stmt|;
name|storage_OS_get_vm
argument_list|()
expr_stmt|;
name|storage_OS_get_swap
argument_list|()
expr_stmt|;
name|storage_OS_get_fs
argument_list|()
expr_stmt|;
name|storage_OS_get_memstat
argument_list|()
expr_stmt|;
comment|/* 	 * Purge items that disappeared 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&storage_tbl
argument_list|,
argument|link
argument_list|,
argument|entry_tmp
argument_list|)
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|HR_STORAGE_FOUND
operator|)
condition|)
name|storage_entry_delete
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|storage_tick
operator|=
name|this_tick
expr_stmt|;
name|HRDBG
argument_list|(
literal|"refresh DONE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the implementation for a generated (by our SNMP tool)  * function prototype, see hostres_tree.h  * It handles the SNMP operations for hrStorageTable  */
end_comment

begin_function
name|int
name|op_hrStorageTable
parameter_list|(
name|struct
name|snmp_context
modifier|*
name|ctx
name|__unused
parameter_list|,
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|,
name|u_int
name|sub
parameter_list|,
name|u_int
name|iidx
name|__unused
parameter_list|,
name|enum
name|snmp_op
name|curr_op
parameter_list|)
block|{
name|struct
name|storage_entry
modifier|*
name|entry
decl_stmt|;
name|refresh_storage_tbl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curr_op
condition|)
block|{
case|case
name|SNMP_OP_GETNEXT
case|:
if|if
condition|(
operator|(
name|entry
operator|=
name|NEXT_OBJECT_INT
argument_list|(
operator|&
name|storage_tbl
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|,
name|sub
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SNMP_ERR_NOSUCHNAME
operator|)
return|;
name|value
operator|->
name|var
operator|.
name|len
operator|=
name|sub
operator|+
literal|1
expr_stmt|;
name|value
operator|->
name|var
operator|.
name|subs
index|[
name|sub
index|]
operator|=
name|entry
operator|->
name|index
expr_stmt|;
goto|goto
name|get
goto|;
case|case
name|SNMP_OP_GET
case|:
if|if
condition|(
operator|(
name|entry
operator|=
name|FIND_OBJECT_INT
argument_list|(
operator|&
name|storage_tbl
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|,
name|sub
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SNMP_ERR_NOSUCHNAME
operator|)
return|;
goto|goto
name|get
goto|;
case|case
name|SNMP_OP_SET
case|:
if|if
condition|(
operator|(
name|entry
operator|=
name|FIND_OBJECT_INT
argument_list|(
operator|&
name|storage_tbl
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|,
name|sub
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SNMP_ERR_NO_CREATION
operator|)
return|;
return|return
operator|(
name|SNMP_ERR_NOT_WRITEABLE
operator|)
return|;
case|case
name|SNMP_OP_ROLLBACK
case|:
case|case
name|SNMP_OP_COMMIT
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
name|get
label|:
switch|switch
condition|(
name|value
operator|->
name|var
operator|.
name|subs
index|[
name|sub
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|LEAF_hrStorageIndex
case|:
name|value
operator|->
name|v
operator|.
name|integer
operator|=
name|entry
operator|->
name|index
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
case|case
name|LEAF_hrStorageType
case|:
name|assert
argument_list|(
name|entry
operator|->
name|type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|oid
operator|=
operator|*
name|entry
operator|->
name|type
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
case|case
name|LEAF_hrStorageDescr
case|:
name|assert
argument_list|(
name|entry
operator|->
name|descr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|string_get
argument_list|(
name|value
argument_list|,
name|entry
operator|->
name|descr
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
break|break;
case|case
name|LEAF_hrStorageAllocationUnits
case|:
name|value
operator|->
name|v
operator|.
name|integer
operator|=
name|entry
operator|->
name|allocationUnits
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
case|case
name|LEAF_hrStorageSize
case|:
name|value
operator|->
name|v
operator|.
name|integer
operator|=
name|entry
operator|->
name|size
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
case|case
name|LEAF_hrStorageUsed
case|:
name|value
operator|->
name|v
operator|.
name|integer
operator|=
name|entry
operator|->
name|used
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
case|case
name|LEAF_hrStorageAllocationFailures
case|:
name|value
operator|->
name|v
operator|.
name|uint32
operator|=
name|entry
operator|->
name|allocationFailures
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

