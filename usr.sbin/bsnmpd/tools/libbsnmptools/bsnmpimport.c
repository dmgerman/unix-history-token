begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 The FreeBSD Project  * All rights reserved.  *  * Author: Shteryana Shopova<syrinx@FreeBSD.org>  *  * Redistribution of this software and documentation and use in source and  * binary forms, with or without modification, are permitted provided that  * the following conditions are met:  *  * 1. Redistributions of source code or documentation must retain the above  *    copyright notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Read file containing table description - reuse magic from gensnmptree.c.  * Hopefully one day most of the code here will be part of libbsnmp and  * this duplication won't be necessary.  *  * Syntax is:  * ---------  * file := top | top file  *  * top := tree | typedef | include  *  * tree := head elements ')'  *  * entry := head ':' index STRING elements ')'  *  * leaf := head type STRING ACCESS ')'  *  * column := head type ACCESS ')'  *  * type := BASETYPE | BASETYPE '|' subtype | enum | bits  *  * subtype := STRING  *  * enum := ENUM '(' value ')'  *  * bits := BITS '(' value ')'  *  * value := INT STRING | INT STRING value  *  * head := '(' INT STRING  *  * elements := EMPTY | elements element  *  * element := tree | leaf | column  *  * index := type | index type  *  * typedef := 'typedef' STRING type  *  * include := 'include' filespec  *  * filespec := '"' STRING '"' | '<' STRING '>'  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<bsnmp/asn1.h>
end_include

begin_include
include|#
directive|include
file|<bsnmp/snmp.h>
end_include

begin_include
include|#
directive|include
file|<bsnmp/snmpagent.h>
end_include

begin_comment
comment|/* SNMP_INDEXES_MAX */
end_comment

begin_include
include|#
directive|include
file|"bsnmptc.h"
end_include

begin_include
include|#
directive|include
file|"bsnmptools.h"
end_include

begin_enum
enum|enum
name|snmp_tbl_entry
block|{
name|ENTRY_NONE
init|=
literal|0
block|,
name|ENTRY_INDEX
block|,
name|ENTRY_DATA
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|FL_GET
init|=
literal|0x01
block|,
name|FL_SET
init|=
literal|0x02
block|, }
enum|;
end_enum

begin_comment
comment|/************************************************************  *  * Allocate memory and panic just in the case...  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|xalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"allocing %zu bytes"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|savestr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|strcpy
argument_list|(
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *  * Input stack  */
end_comment

begin_struct
struct|struct
name|input
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|uint32_t
name|lno
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|input
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|input
argument_list|)
name|inputs
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|inputs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|input
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|pbchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_PATHS
value|100
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|paths
index|[
name|MAX_PATHS
operator|+
literal|1
index|]
init|=
block|{
literal|"/usr/share/snmp/defs"
block|,
literal|"/usr/local/share/snmp/defs"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|input_new
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|input
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|ip
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
name|savestr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ip
operator|->
name|path
operator|=
name|savestr
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inputs
argument_list|,
name|ip
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|input
operator|=
name|ip
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_close
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return;
name|fclose
argument_list|(
name|input
operator|->
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
operator|->
name|path
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|input
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inputs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|tryopen
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|fn
operator|=
name|savestr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
name|fn
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|input_fopen
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|u_int
name|p
decl_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|fname
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|tryopen
argument_list|(
name|NULL
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|input_new
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
literal|0
init|;
name|paths
index|[
name|p
index|]
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|fp
operator|=
name|tryopen
argument_list|(
name|paths
index|[
name|p
index|]
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|input_new
argument_list|(
name|fp
argument_list|,
name|paths
index|[
name|p
index|]
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|warnx
argument_list|(
literal|"cannot open '%s'"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|tgetc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|pbchar
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pbchar
expr_stmt|;
name|pbchar
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|input
operator|->
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|input_close
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int32_t
name|tungetc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|pbchar
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pbchar
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *  * Parsing input  */
end_comment

begin_enum
enum|enum
name|tok
block|{
name|TOK_EOF
init|=
literal|0200
block|,
comment|/* end-of-file seen */
name|TOK_NUM
block|,
comment|/* number */
name|TOK_STR
block|,
comment|/* string */
name|TOK_ACCESS
block|,
comment|/* access operator */
name|TOK_TYPE
block|,
comment|/* type operator */
name|TOK_ENUM
block|,
comment|/* enum token (kind of a type) */
name|TOK_TYPEDEF
block|,
comment|/* typedef directive */
name|TOK_DEFTYPE
block|,
comment|/* defined type */
name|TOK_INCLUDE
block|,
comment|/* include directive */
name|TOK_FILENAME
block|,
comment|/* filename ("foo.bar" or<foo.bar>) */
name|TOK_BITS
block|,
comment|/* bits token (kind of a type) */
name|TOK_ERR
comment|/* unexpected char - exit */
block|}
enum|;
end_enum

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|enum
name|tok
name|tok
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
block|}
name|keywords
index|[]
init|=
block|{
block|{
literal|"GET"
block|,
name|TOK_ACCESS
block|,
name|FL_GET
block|}
block|,
block|{
literal|"SET"
block|,
name|TOK_ACCESS
block|,
name|FL_SET
block|}
block|,
block|{
literal|"NULL"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_NULL
block|}
block|,
block|{
literal|"INTEGER"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_INTEGER
block|}
block|,
block|{
literal|"INTEGER32"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_INTEGER
block|}
block|,
block|{
literal|"UNSIGNED32"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_GAUGE
block|}
block|,
block|{
literal|"OCTETSTRING"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_OCTETSTRING
block|}
block|,
block|{
literal|"IPADDRESS"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_IPADDRESS
block|}
block|,
block|{
literal|"OID"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_OID
block|}
block|,
block|{
literal|"TIMETICKS"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_TIMETICKS
block|}
block|,
block|{
literal|"COUNTER"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_COUNTER
block|}
block|,
block|{
literal|"GAUGE"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_GAUGE
block|}
block|,
block|{
literal|"COUNTER64"
block|,
name|TOK_TYPE
block|,
name|SNMP_SYNTAX_COUNTER64
block|}
block|,
block|{
literal|"ENUM"
block|,
name|TOK_ENUM
block|,
name|SNMP_SYNTAX_INTEGER
block|}
block|,
block|{
literal|"BITS"
block|,
name|TOK_BITS
block|,
name|SNMP_SYNTAX_OCTETSTRING
block|}
block|,
block|{
literal|"typedef"
block|,
name|TOK_TYPEDEF
block|,
literal|0
block|}
block|,
block|{
literal|"include"
block|,
name|TOK_INCLUDE
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
block|{
comment|/* Current OID type, regarding table membership. */
name|enum
name|snmp_tbl_entry
name|tbl_type
decl_stmt|;
comment|/* A pointer to a structure in table list to add to its members. */
name|struct
name|snmp_index_entry
modifier|*
name|table_idx
decl_stmt|;
block|}
name|table_data
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|asn_oid
name|current_oid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nexttok
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* integer values */
end_comment

begin_decl_stmt
specifier|static
name|int32_t
name|all_cond
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* all conditions are true */
end_comment

begin_decl_stmt
specifier|static
name|int32_t
name|saved_token
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prepare the global data before parsing a new file. */
end_comment

begin_function
specifier|static
name|void
name|snmp_import_init
parameter_list|(
name|struct
name|asn_oid
modifier|*
name|append
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|table_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|table_data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|current_oid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|asn_oid
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nexttok
argument_list|,
literal|0
argument_list|,
name|MAXSTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|append
operator|!=
name|NULL
condition|)
name|asn_append_oid
argument_list|(
operator|&
name|current_oid
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|all_cond
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|saved_token
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|gettoken
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|enum_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|saved_token
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|saved_token
expr_stmt|;
name|saved_token
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|again
label|:
comment|/* 	 * Skip any whitespace before the next token. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|tgetc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|input
operator|->
name|lno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|TOK_EOF
operator|)
return|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected character %#2x"
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ERR
operator|)
return|;
block|}
comment|/* 	 * Skip comments. 	 */
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|tgetc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|input
operator|->
name|lno
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|warnx
argument_list|(
literal|"unexpected EOF in comment"
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ERR
operator|)
return|;
block|}
comment|/* 	 * Single character tokens. 	 */
if|if
condition|(
name|strchr
argument_list|(
literal|"():|"
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'<'
condition|)
block|{
name|int32_t
name|end
init|=
name|c
decl_stmt|;
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|'>'
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|tgetc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|end
condition|)
break|break;
if|if
condition|(
name|n
operator|==
sizeof|sizeof
argument_list|(
name|nexttok
argument_list|)
operator|-
literal|1
condition|)
block|{
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|warnx
argument_list|(
literal|"filename too long '%s...'"
argument_list|,
name|nexttok
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ERR
operator|)
return|;
block|}
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|TOK_FILENAME
operator|)
return|;
block|}
comment|/* 	 * Sort out numbers. 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|tgetc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|tungetc
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|TOK_ERR
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
sizeof|sizeof
argument_list|(
name|nexttok
argument_list|)
operator|-
literal|1
condition|)
block|{
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|warnx
argument_list|(
literal|"number too long '%s...'"
argument_list|,
name|nexttok
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ERR
operator|)
return|;
block|}
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sscanf
argument_list|(
name|nexttok
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_NUM
operator|)
return|;
block|}
comment|/* 	 * So that has to be a string. 	 */
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|tgetc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|tungetc
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|TOK_ERR
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
sizeof|sizeof
argument_list|(
name|nexttok
argument_list|)
operator|-
literal|1
condition|)
block|{
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|warnx
argument_list|(
literal|"string too long '%s...'"
argument_list|,
name|nexttok
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ERR
operator|)
return|;
block|}
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|nexttok
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Keywords. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|keywords
index|[
name|c
index|]
operator|.
name|str
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|keywords
index|[
name|c
index|]
operator|.
name|str
argument_list|,
name|nexttok
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|keywords
index|[
name|c
index|]
operator|.
name|val
expr_stmt|;
return|return
operator|(
name|keywords
index|[
name|c
index|]
operator|.
name|tok
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|=
name|snmp_enumtc_lookup
argument_list|(
name|snmptoolctx
argument_list|,
name|nexttok
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|t
operator|->
name|syntax
expr_stmt|;
return|return
operator|(
name|TOK_DEFTYPE
operator|)
return|;
block|}
return|return
operator|(
name|TOK_STR
operator|)
return|;
block|}
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"%u: unexpected character '%c'"
argument_list|,
name|input
operator|->
name|lno
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%u: unexpected character 0x%02x"
argument_list|,
name|input
operator|->
name|lno
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|TOK_ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update table information.  */
end_comment

begin_function
specifier|static
name|struct
name|snmp_index_entry
modifier|*
name|snmp_import_update_table
parameter_list|(
name|enum
name|snmp_tbl_entry
name|te
parameter_list|,
name|struct
name|snmp_index_entry
modifier|*
name|tbl
parameter_list|)
block|{
switch|switch
condition|(
name|te
condition|)
block|{
case|case
name|ENTRY_NONE
case|:
if|if
condition|(
name|table_data
operator|.
name|tbl_type
operator|==
name|ENTRY_NONE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|table_data
operator|.
name|tbl_type
operator|==
name|ENTRY_INDEX
condition|)
name|table_data
operator|.
name|table_idx
operator|=
name|NULL
expr_stmt|;
name|table_data
operator|.
name|tbl_type
operator|--
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|ENTRY_INDEX
case|:
if|if
condition|(
name|tbl
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"No table_index to add!!!"
argument_list|)
expr_stmt|;
name|table_data
operator|.
name|table_idx
operator|=
name|tbl
expr_stmt|;
name|table_data
operator|.
name|tbl_type
operator|=
name|ENTRY_INDEX
expr_stmt|;
return|return
operator|(
name|tbl
operator|)
return|;
case|case
name|ENTRY_DATA
case|:
if|if
condition|(
name|table_data
operator|.
name|tbl_type
operator|==
name|ENTRY_INDEX
condition|)
block|{
name|table_data
operator|.
name|tbl_type
operator|=
name|ENTRY_DATA
expr_stmt|;
return|return
operator|(
name|table_data
operator|.
name|table_idx
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
comment|/* NOTREACHED */
name|warnx
argument_list|(
literal|"Unknown table entry type!!!"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|parse_enum
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|int32_t
modifier|*
name|tok
parameter_list|,
name|struct
name|enum_pairs
modifier|*
name|enums
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|==
name|TOK_STR
condition|)
block|{
if|if
condition|(
name|enum_pair_insert
argument_list|(
name|enums
argument_list|,
name|val
argument_list|,
name|nexttok
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|!=
name|TOK_NUM
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|tok
operator|!=
literal|')'
condition|)
block|{
name|warnx
argument_list|(
literal|"')' at end of enums"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|parse_subtype
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|int32_t
modifier|*
name|tok
parameter_list|,
name|enum
name|snmp_tc
modifier|*
name|tc
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|!=
name|TOK_STR
condition|)
block|{
name|warnx
argument_list|(
literal|"subtype expected after '|'"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|tc
operator|=
name|snmp_get_tc
argument_list|(
name|nexttok
argument_list|)
expr_stmt|;
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|parse_type
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|int32_t
modifier|*
name|tok
parameter_list|,
name|enum
name|snmp_tc
modifier|*
name|tc
parameter_list|,
name|struct
name|enum_pairs
modifier|*
modifier|*
name|snmp_enum
parameter_list|)
block|{
name|int32_t
name|syntax
decl_stmt|,
name|mem
decl_stmt|;
name|syntax
operator|=
name|val
expr_stmt|;
operator|*
name|tc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|tok
operator|==
name|TOK_ENUM
operator|||
operator|*
name|tok
operator|==
name|TOK_BITS
condition|)
block|{
if|if
condition|(
operator|*
name|snmp_enum
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|snmp_enum
operator|=
name|enum_pairs_init
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mem
operator|=
literal|1
expr_stmt|;
operator|*
name|tc
operator|=
name|SNMP_TC_OWN
expr_stmt|;
block|}
else|else
name|mem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|!=
literal|'('
condition|)
block|{
name|warnx
argument_list|(
literal|"'(' expected after ENUM/BITS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|!=
name|TOK_NUM
condition|)
block|{
name|warnx
argument_list|(
literal|"need value for ENUM//BITS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
operator|*
name|snmp_enum
argument_list|)
expr_stmt|;
operator|*
name|snmp_enum
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|parse_enum
argument_list|(
name|snmptoolctx
argument_list|,
name|tok
argument_list|,
operator|*
name|snmp_enum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|enum_pairs_free
argument_list|(
operator|*
name|snmp_enum
argument_list|)
expr_stmt|;
operator|*
name|snmp_enum
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tok
operator|==
name|TOK_DEFTYPE
condition|)
block|{
name|struct
name|enum_type
modifier|*
name|t
decl_stmt|;
operator|*
name|tc
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|snmp_enumtc_lookup
argument_list|(
name|snmptoolctx
argument_list|,
name|nexttok
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
operator|*
name|snmp_enum
operator|=
name|t
operator|->
name|snmp_enum
expr_stmt|;
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|parse_subtype
argument_list|(
name|snmptoolctx
argument_list|,
name|tok
argument_list|,
name|tc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|syntax
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|snmp_import_head
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|)
block|{
name|enum
name|tok
name|tok
decl_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|==
literal|'('
condition|)
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|TOK_NUM
operator|||
name|val
operator|>
name|ASN_MAXID
condition|)
block|{
name|warnx
argument_list|(
literal|"Suboid expected - line %d"
argument_list|,
name|input
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|!=
name|TOK_STR
condition|)
block|{
name|warnx
argument_list|(
literal|"Node name expected at line %d"
argument_list|,
name|input
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|snmp_import_table
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|struct
name|snmp_oid2str
modifier|*
name|obj
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|,
name|tok
decl_stmt|;
name|enum
name|snmp_tc
name|tc
decl_stmt|;
name|struct
name|snmp_index_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snmp_index_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
init|;
name|i
operator|<
name|SNMP_INDEXES_MAX
condition|;
name|i
operator|++
control|)
block|{
name|int32_t
name|syntax
decl_stmt|;
name|struct
name|enum_pairs
modifier|*
name|enums
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tok
operator|!=
name|TOK_TYPE
operator|&&
name|tok
operator|!=
name|TOK_DEFTYPE
operator|&&
name|tok
operator|!=
name|TOK_ENUM
operator|&&
name|tok
operator|!=
name|TOK_BITS
condition|)
break|break;
if|if
condition|(
operator|(
name|syntax
operator|=
name|parse_type
argument_list|(
name|snmptoolctx
argument_list|,
operator|&
name|tok
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|enums
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|enum_pairs_free
argument_list|(
name|enums
argument_list|)
expr_stmt|;
name|snmp_index_listfree
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|snmp_syntax_insert
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|,
name|enums
argument_list|,
name|syntax
argument_list|,
name|tc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snmp_index_listfree
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|)
expr_stmt|;
name|enum_pairs_free
argument_list|(
name|enums
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|>
name|SNMP_INDEXES_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad number of indexes at line %d"
argument_list|,
name|input
operator|->
name|lno
argument_list|)
expr_stmt|;
name|snmp_index_listfree
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tok
operator|!=
name|TOK_STR
condition|)
block|{
name|warnx
argument_list|(
literal|"String expected after indexes at line %d"
argument_list|,
name|input
operator|->
name|lno
argument_list|)
expr_stmt|;
name|snmp_index_listfree
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|entry
operator|->
name|string
operator|=
name|obj
operator|->
name|string
expr_stmt|;
name|entry
operator|->
name|strlen
operator|=
name|obj
operator|->
name|strlen
expr_stmt|;
name|asn_append_oid
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|var
operator|)
argument_list|,
operator|&
operator|(
name|obj
operator|->
name|var
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|snmp_table_insert
argument_list|(
name|snmptoolctx
argument_list|,
name|entry
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snmp_index_listfree
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|index_list
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Same entry already present in lists. */
name|free
argument_list|(
name|entry
operator|->
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snmp_import_update_table
argument_list|(
name|ENTRY_INDEX
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read everything after the syntax type that is certainly a leaf OID info.  */
end_comment

begin_function
specifier|static
name|int32_t
name|snmp_import_leaf
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|int32_t
modifier|*
name|tok
parameter_list|,
name|struct
name|snmp_oid2str
modifier|*
name|oid2str
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|,
name|syntax
decl_stmt|;
if|if
condition|(
operator|(
name|syntax
operator|=
name|parse_type
argument_list|(
name|snmptoolctx
argument_list|,
name|tok
argument_list|,
operator|&
operator|(
name|oid2str
operator|->
name|tc
operator|)
argument_list|,
operator|&
operator|(
name|oid2str
operator|->
name|snmp_enum
operator|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|oid2str
operator|->
name|syntax
operator|=
name|syntax
expr_stmt|;
comment|/* 	 * That is the name of the function, corresponding to the entry. 	 * It is used by bsnmpd, but is not interesting for us. 	 */
if|if
condition|(
operator|*
name|tok
operator|==
name|TOK_STR
condition|)
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SNMP_ACCESS_GETSET
operator|&&
operator|*
name|tok
operator|==
name|TOK_ACCESS
condition|;
name|i
operator|++
control|)
block|{
name|oid2str
operator|->
name|access
operator||=
operator|(
name|uint32_t
operator|)
name|val
expr_stmt|;
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tok
operator|!=
literal|')'
condition|)
block|{
name|warnx
argument_list|(
literal|"')' expected at end of line %d"
argument_list|,
name|input
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|oid2str
operator|->
name|table_idx
operator|=
name|snmp_import_update_table
argument_list|(
name|ENTRY_DATA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|snmp_leaf_insert
argument_list|(
name|snmptoolctx
argument_list|,
name|oid2str
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Error adding leaf %s to list"
argument_list|,
name|oid2str
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Same entry is already present in the mapping lists and 	 * the new one was not inserted. 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|oid2str
operator|->
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid2str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snmp_import_update_table
argument_list|(
name|ENTRY_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|snmp_import_object
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int32_t
name|tok
decl_stmt|;
name|struct
name|snmp_oid2str
modifier|*
name|oid2str
decl_stmt|;
if|if
condition|(
name|snmp_import_head
argument_list|(
name|snmptoolctx
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|oid2str
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snmp_oid2str
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"calloc() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|string
operator|=
name|strdup
argument_list|(
name|nexttok
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"strdup() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid2str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|oid2str
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|oid2str
operator|->
name|strlen
operator|=
name|strlen
argument_list|(
name|nexttok
argument_list|)
expr_stmt|;
name|asn_append_oid
argument_list|(
operator|&
operator|(
name|oid2str
operator|->
name|var
operator|)
argument_list|,
operator|&
operator|(
name|current_oid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmp_suboid_append
argument_list|(
operator|&
operator|(
name|oid2str
operator|->
name|var
operator|)
argument_list|,
operator|(
name|asn_subid_t
operator|)
name|val
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Prepared the entry - now figure out where to insert it. 	 * After the object we have following options: 	 * 1) new line, blank, ) - then it is an enum oid -> snmp_enumlist; 	 * 2) new line , ( - nonleaf oid -> snmp_nodelist; 	 * 2) ':' - table entry - a variable length SYNTAX_TYPE (one or more) 	 *     may follow and second string must end line -> snmp_tablelist; 	 * 3) OID , string  ) - this is a trap entry or a leaf -> snmp_oidlist; 	 * 4) SYNTAX_TYPE, string (not always), get/set modifier - always last 	 *     and )- this is definitely a leaf. 	 */
switch|switch
condition|(
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
condition|)
block|{
case|case
literal|')'
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|snmp_enum_insert
argument_list|(
name|snmptoolctx
argument_list|,
name|oid2str
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|oid2str
operator|->
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid2str
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|snmp_suboid_append
argument_list|(
operator|&
name|current_oid
argument_list|,
operator|(
name|asn_subid_t
operator|)
name|val
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Ignore the error for nodes since the .def files currently 		 * contain different strings for 1.3.6.1.2.1 - mibII. Only make 		 * sure the memory is freed and don't complain. 		 */
if|if
condition|(
operator|(
name|i
operator|=
name|snmp_node_insert
argument_list|(
name|snmptoolctx
argument_list|,
name|oid2str
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid2str
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|snmp_import_object
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
return|;
case|case
literal|':'
case|:
if|if
condition|(
name|snmp_suboid_append
argument_list|(
operator|&
name|current_oid
argument_list|,
operator|(
name|asn_subid_t
operator|)
name|val
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|snmp_import_table
argument_list|(
name|snmptoolctx
argument_list|,
name|oid2str
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * A different table entry type was malloced and the data is 		 * contained there. 		 */
name|free
argument_list|(
name|oid2str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TOK_TYPE
case|:
comment|/* FALLTHROUGH */
case|case
name|TOK_DEFTYPE
case|:
comment|/* FALLTHROUGH */
case|case
name|TOK_ENUM
case|:
comment|/* FALLTHROUGH */
case|case
name|TOK_BITS
case|:
if|if
condition|(
name|snmp_import_leaf
argument_list|(
name|snmptoolctx
argument_list|,
operator|&
name|tok
argument_list|,
name|oid2str
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|warnx
argument_list|(
literal|"Unexpected token at line %d - %s"
argument_list|,
name|input
operator|->
name|lno
argument_list|,
name|input
operator|->
name|fname
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
label|:
name|snmp_mapping_entryfree
argument_list|(
name|oid2str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|snmp_import_tree
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|int32_t
modifier|*
name|tok
parameter_list|)
block|{
while|while
condition|(
operator|*
name|tok
operator|!=
name|TOK_EOF
condition|)
block|{
switch|switch
condition|(
operator|*
name|tok
condition|)
block|{
case|case
name|TOK_ERR
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|snmp_import_object
argument_list|(
name|snmptoolctx
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|snmp_suboid_pop
argument_list|(
operator|&
name|current_oid
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snmp_import_update_table
argument_list|(
name|ENTRY_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Anything else here would be illegal. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|snmp_import_top
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|int32_t
modifier|*
name|tok
parameter_list|)
block|{
name|enum
name|snmp_tc
name|tc
decl_stmt|;
name|struct
name|enum_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|tok
operator|==
literal|'('
condition|)
return|return
operator|(
name|snmp_import_tree
argument_list|(
name|snmptoolctx
argument_list|,
name|tok
argument_list|)
operator|)
return|;
if|if
condition|(
operator|*
name|tok
operator|==
name|TOK_TYPEDEF
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|!=
name|TOK_STR
condition|)
block|{
name|warnx
argument_list|(
literal|"type name expected after typedef - %s"
argument_list|,
name|input
operator|->
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|t
operator|=
name|snmp_enumtc_init
argument_list|(
name|nexttok
argument_list|)
expr_stmt|;
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
name|t
operator|->
name|is_enum
operator|=
operator|(
operator|*
name|tok
operator|==
name|TOK_ENUM
operator|)
expr_stmt|;
name|t
operator|->
name|is_bits
operator|=
operator|(
operator|*
name|tok
operator|==
name|TOK_BITS
operator|)
expr_stmt|;
name|t
operator|->
name|syntax
operator|=
name|parse_type
argument_list|(
name|snmptoolctx
argument_list|,
name|tok
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
operator|(
name|t
operator|->
name|snmp_enum
operator|)
argument_list|)
expr_stmt|;
name|snmp_enumtc_insert
argument_list|(
name|snmptoolctx
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|tok
operator|==
name|TOK_INCLUDE
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tok
operator|!=
name|TOK_FILENAME
condition|)
block|{
name|warnx
argument_list|(
literal|"filename expected in include directive - %s"
argument_list|,
name|nexttok
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|add_filename
argument_list|(
name|snmptoolctx
argument_list|,
name|nexttok
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|input_fopen
argument_list|(
name|nexttok
argument_list|)
expr_stmt|;
operator|*
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|warnx
argument_list|(
literal|"'(' or 'typedef' expected - %s"
argument_list|,
name|nexttok
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|snmp_import
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int32_t
name|tok
decl_stmt|;
name|tok
operator|=
name|gettoken
argument_list|(
name|snmptoolctx
argument_list|)
expr_stmt|;
do|do
name|i
operator|=
name|snmp_import_top
argument_list|(
name|snmptoolctx
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a .def file and import oid<->string mapping.  * Mappings are inserted into a global structure containing list for each OID  * syntax type.  */
end_comment

begin_function
name|int32_t
name|snmp_import_file
parameter_list|(
name|struct
name|snmp_toolinfo
modifier|*
name|snmptoolctx
parameter_list|,
name|struct
name|fname
modifier|*
name|file
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|snmp_import_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|cut
operator|)
argument_list|)
expr_stmt|;
name|input_fopen
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|idx
operator|=
name|snmp_import
argument_list|(
name|snmptoolctx
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|warnx
argument_list|(
literal|"Failed to read mappings from file %s"
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|input_close
argument_list|()
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

end_unit

