begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$Id: aldap.c,v 1.32 2016/04/27 10:53:27 schwarze Exp $ */
end_comment

begin_comment
comment|/*	$OpenBSD: aldap.c,v 1.32 2016/04/27 10:53:27 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008 Alexander Schrijver<aschrijver@openbsd.org>  * Copyright (c) 2006, 2007 Marc Balmer<mbalmer@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"aldap.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VERSION
value|3
end_define

begin_function_decl
specifier|static
name|struct
name|ber_element
modifier|*
name|ldap_parse_search_filter
parameter_list|(
name|struct
name|ber_element
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ber_element
modifier|*
name|ldap_do_parse_search_filter
parameter_list|(
name|struct
name|ber_element
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|aldap_get_stringset
parameter_list|(
name|struct
name|ber_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|utoa
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isu8cont
parameter_list|(
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|parseval
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|aldap_create_page_control
parameter_list|(
name|struct
name|ber_element
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|aldap_page_control
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|void
name|ldap_debug_elements
parameter_list|(
name|struct
name|ber_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
modifier|...
parameter_list|)
value|printf(x)
end_define

begin_define
define|#
directive|define
name|LDAP_DEBUG
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do { fprintf(stderr, "*** " x "\n"); ldap_debug_elements(y); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|LDAP_DEBUG
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|aldap_close
parameter_list|(
name|struct
name|aldap
modifier|*
name|al
parameter_list|)
block|{
if|if
condition|(
name|close
argument_list|(
name|al
operator|->
name|ber
operator|.
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ber_free
argument_list|(
operator|&
name|al
operator|->
name|ber
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|al
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|aldap
modifier|*
name|aldap_init
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|aldap
modifier|*
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|a
operator|->
name|ber
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|int
name|aldap_bind
parameter_list|(
name|struct
name|aldap
modifier|*
name|ldap
parameter_list|,
name|char
modifier|*
name|binddn
parameter_list|,
name|char
modifier|*
name|bindcred
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|root
init|=
name|NULL
decl_stmt|,
modifier|*
name|elm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|binddn
operator|==
name|NULL
condition|)
name|binddn
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|bindcred
operator|==
name|NULL
condition|)
name|bindcred
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|root
operator|=
name|ber_add_sequence
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|elm
operator|=
name|ber_printf_elements
argument_list|(
name|root
argument_list|,
literal|"d{tdsst"
argument_list|,
operator|++
name|ldap
operator|->
name|msgid
argument_list|,
name|BER_CLASS_APP
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|LDAP_REQ_BIND
argument_list|,
name|VERSION
argument_list|,
name|binddn
argument_list|,
name|bindcred
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|LDAP_AUTH_SIMPLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|LDAP_DEBUG
argument_list|(
literal|"aldap_bind"
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|error
operator|=
name|ber_write_elements
argument_list|(
operator|&
name|ldap
operator|->
name|ber
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
name|ldap
operator|->
name|msgid
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_OPERATION_FAILED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_unbind
parameter_list|(
name|struct
name|aldap
modifier|*
name|ldap
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|root
init|=
name|NULL
decl_stmt|,
modifier|*
name|elm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|root
operator|=
name|ber_add_sequence
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|elm
operator|=
name|ber_printf_elements
argument_list|(
name|root
argument_list|,
literal|"d{t"
argument_list|,
operator|++
name|ldap
operator|->
name|msgid
argument_list|,
name|BER_CLASS_APP
argument_list|,
name|LDAP_REQ_UNBIND_30
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|LDAP_DEBUG
argument_list|(
literal|"aldap_unbind"
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|error
operator|=
name|ber_write_elements
argument_list|(
operator|&
name|ldap
operator|->
name|ber
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
name|ldap
operator|->
name|msgid
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_OPERATION_FAILED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_search
parameter_list|(
name|struct
name|aldap
modifier|*
name|ldap
parameter_list|,
name|char
modifier|*
name|basedn
parameter_list|,
name|enum
name|scope
name|scope
parameter_list|,
name|char
modifier|*
name|filter
parameter_list|,
name|char
modifier|*
modifier|*
name|attrs
parameter_list|,
name|int
name|typesonly
parameter_list|,
name|int
name|sizelimit
parameter_list|,
name|int
name|timelimit
parameter_list|,
name|struct
name|aldap_page_control
modifier|*
name|page
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|root
init|=
name|NULL
decl_stmt|,
modifier|*
name|ber
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|root
operator|=
name|ber_add_sequence
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|ber
operator|=
name|ber_printf_elements
argument_list|(
name|root
argument_list|,
literal|"d{t"
argument_list|,
operator|++
name|ldap
operator|->
name|msgid
argument_list|,
name|BER_CLASS_APP
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|LDAP_REQ_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ber
operator|==
name|NULL
condition|)
block|{
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_OPERATION_FAILED
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|c
operator|=
name|ber
expr_stmt|;
name|ber
operator|=
name|ber_printf_elements
argument_list|(
name|ber
argument_list|,
literal|"sEEddb"
argument_list|,
name|basedn
argument_list|,
operator|(
name|long
name|long
operator|)
name|scope
argument_list|,
operator|(
name|long
name|long
operator|)
name|LDAP_DEREF_NEVER
argument_list|,
name|sizelimit
argument_list|,
name|timelimit
argument_list|,
name|typesonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|ber
operator|==
name|NULL
condition|)
block|{
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_OPERATION_FAILED
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|ber
operator|=
name|ldap_parse_search_filter
argument_list|(
name|ber
argument_list|,
name|filter
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_PARSER_ERROR
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|ber
operator|=
name|ber_add_sequence
argument_list|(
name|ber
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|attrs
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|attrs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ber
operator|=
name|ber_add_string
argument_list|(
name|ber
argument_list|,
name|attrs
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|aldap_create_page_control
argument_list|(
name|c
argument_list|,
literal|100
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|LDAP_DEBUG
argument_list|(
literal|"aldap_search"
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|error
operator|=
name|ber_write_elements
argument_list|(
operator|&
name|ldap
operator|->
name|ber
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_OPERATION_FAILED
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
name|ldap
operator|->
name|msgid
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_create_page_control
parameter_list|(
name|struct
name|ber_element
modifier|*
name|elm
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|aldap_page_control
modifier|*
name|page
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|ber
name|c
decl_stmt|;
name|struct
name|ber_element
modifier|*
name|ber
init|=
name|NULL
decl_stmt|;
name|c
operator|.
name|br_wbuf
operator|=
name|NULL
expr_stmt|;
name|c
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|ber
operator|=
name|ber_add_sequence
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ber_printf_elements
argument_list|(
name|ber
argument_list|,
literal|"ds"
argument_list|,
literal|50
argument_list|,
literal|""
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
if|if
condition|(
name|ber_printf_elements
argument_list|(
name|ber
argument_list|,
literal|"dx"
argument_list|,
literal|50
argument_list|,
name|page
operator|->
name|cookie
argument_list|,
name|page
operator|->
name|cookie_len
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ber_write_elements
argument_list|(
operator|&
name|c
argument_list|,
name|ber
argument_list|)
operator|)
operator|<
literal|1
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ber_printf_elements
argument_list|(
name|elm
argument_list|,
literal|"{t{sx"
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|LDAP_PAGED_OID
argument_list|,
name|c
operator|.
name|br_wbuf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|ber_free_elements
argument_list|(
name|ber
argument_list|)
expr_stmt|;
name|ber_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|len
return|;
name|fail
label|:
if|if
condition|(
name|ber
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|ber
argument_list|)
expr_stmt|;
name|ber_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|aldap_message
modifier|*
name|aldap_parse
parameter_list|(
name|struct
name|aldap
modifier|*
name|ldap
parameter_list|)
block|{
name|int
name|class
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|long
name|long
name|msgid
init|=
literal|0
decl_stmt|;
name|struct
name|aldap_message
modifier|*
name|m
decl_stmt|;
name|struct
name|ber_element
modifier|*
name|a
init|=
name|NULL
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aldap_message
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|msg
operator|=
name|ber_read_elements
argument_list|(
operator|&
name|ldap
operator|->
name|ber
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|parsefail
goto|;
name|LDAP_DEBUG
argument_list|(
literal|"message"
argument_list|,
name|m
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|m
operator|->
name|msg
argument_list|,
literal|"{ite"
argument_list|,
operator|&
name|msgid
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parsefail
goto|;
name|m
operator|->
name|msgid
operator|=
name|msgid
expr_stmt|;
name|m
operator|->
name|message_type
operator|=
name|type
expr_stmt|;
name|m
operator|->
name|protocol_op
operator|=
name|a
expr_stmt|;
switch|switch
condition|(
name|m
operator|->
name|message_type
condition|)
block|{
case|case
name|LDAP_RES_BIND
case|:
case|case
name|LDAP_RES_MODIFY
case|:
case|case
name|LDAP_RES_ADD
case|:
case|case
name|LDAP_RES_DELETE
case|:
case|case
name|LDAP_RES_MODRDN
case|:
case|case
name|LDAP_RES_COMPARE
case|:
case|case
name|LDAP_RES_SEARCH_RESULT
case|:
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|m
operator|->
name|protocol_op
argument_list|,
literal|"{EeSeSe"
argument_list|,
operator|&
name|m
operator|->
name|body
operator|.
name|res
operator|.
name|rescode
argument_list|,
operator|&
name|m
operator|->
name|dn
argument_list|,
operator|&
name|m
operator|->
name|body
operator|.
name|res
operator|.
name|diagmsg
argument_list|,
operator|&
name|a
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parsefail
goto|;
if|if
condition|(
name|m
operator|->
name|body
operator|.
name|res
operator|.
name|rescode
operator|==
name|LDAP_REFERRAL
condition|)
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|a
argument_list|,
literal|"{e"
argument_list|,
operator|&
name|m
operator|->
name|references
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parsefail
goto|;
if|if
condition|(
name|m
operator|->
name|msg
operator|->
name|be_sub
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|m
operator|->
name|msg
operator|->
name|be_sub
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|be_next
control|)
block|{
name|ber_scanf_elements
argument_list|(
name|ep
argument_list|,
literal|"t"
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
literal|2
operator|&&
name|type
operator|==
literal|0
condition|)
name|m
operator|->
name|page
operator|=
name|aldap_parse_page_control
argument_list|(
name|ep
operator|->
name|be_sub
operator|->
name|be_sub
argument_list|,
name|ep
operator|->
name|be_sub
operator|->
name|be_sub
operator|->
name|be_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|m
operator|->
name|page
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|LDAP_RES_SEARCH_ENTRY
case|:
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|m
operator|->
name|protocol_op
argument_list|,
literal|"{eS{e"
argument_list|,
operator|&
name|m
operator|->
name|dn
argument_list|,
operator|&
name|m
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parsefail
goto|;
break|break;
case|case
name|LDAP_RES_SEARCH_REFERENCE
case|:
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|m
operator|->
name|protocol_op
argument_list|,
literal|"{e"
argument_list|,
operator|&
name|m
operator|->
name|references
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parsefail
goto|;
break|break;
block|}
return|return
name|m
return|;
name|parsefail
label|:
name|ldap
operator|->
name|err
operator|=
name|ALDAP_ERR_PARSER_ERROR
expr_stmt|;
name|aldap_freemsg
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|aldap_page_control
modifier|*
name|aldap_parse_page_control
parameter_list|(
name|struct
name|ber_element
modifier|*
name|control
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|oid
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|encoded
decl_stmt|;
name|struct
name|ber
name|b
decl_stmt|;
name|struct
name|ber_element
modifier|*
name|elm
decl_stmt|;
name|struct
name|aldap_page_control
modifier|*
name|page
decl_stmt|;
name|b
operator|.
name|br_wbuf
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|ber_scanf_elements
argument_list|(
name|control
argument_list|,
literal|"ss"
argument_list|,
operator|&
name|oid
argument_list|,
operator|&
name|encoded
argument_list|)
expr_stmt|;
name|ber_set_readbuf
argument_list|(
operator|&
name|b
argument_list|,
name|encoded
argument_list|,
name|control
operator|->
name|be_next
operator|->
name|be_len
argument_list|)
expr_stmt|;
name|elm
operator|=
name|ber_read_elements
argument_list|(
operator|&
name|b
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|page
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aldap_page_control
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elm
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|elm
argument_list|)
expr_stmt|;
name|ber_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ber_scanf_elements
argument_list|(
name|elm
operator|->
name|be_sub
argument_list|,
literal|"is"
argument_list|,
operator|&
name|page
operator|->
name|size
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|page
operator|->
name|cookie_len
operator|=
name|elm
operator|->
name|be_sub
operator|->
name|be_next
operator|->
name|be_len
expr_stmt|;
if|if
condition|(
operator|(
name|page
operator|->
name|cookie
operator|=
name|malloc
argument_list|(
name|page
operator|->
name|cookie_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elm
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|elm
argument_list|)
expr_stmt|;
name|ber_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|page
operator|->
name|cookie
argument_list|,
name|s
argument_list|,
name|page
operator|->
name|cookie_len
argument_list|)
expr_stmt|;
name|ber_free_elements
argument_list|(
name|elm
argument_list|)
expr_stmt|;
name|ber_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
end_function

begin_function
name|void
name|aldap_freepage
parameter_list|(
name|struct
name|aldap_page_control
modifier|*
name|page
parameter_list|)
block|{
name|free
argument_list|(
name|page
operator|->
name|cookie
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aldap_freemsg
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|->
name|msg
condition|)
name|ber_free_elements
argument_list|(
name|msg
operator|->
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|aldap_get_resultcode
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|)
block|{
return|return
name|msg
operator|->
name|body
operator|.
name|res
operator|.
name|rescode
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|aldap_get_dn
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|dn
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|dn
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ber_get_string
argument_list|(
name|msg
operator|->
name|dn
argument_list|,
operator|&
name|dn
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
return|return
name|utoa
argument_list|(
name|dn
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|aldap_get_references
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|->
name|references
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|aldap_get_stringset
argument_list|(
name|msg
operator|->
name|references
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|aldap_free_references
parameter_list|(
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|values
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|values
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|aldap_get_diagmsg
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|body
operator|.
name|res
operator|.
name|diagmsg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ber_get_string
argument_list|(
name|msg
operator|->
name|body
operator|.
name|res
operator|.
name|diagmsg
argument_list|,
operator|&
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
return|return
name|utoa
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_count_attrs
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ber_element
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|a
operator|=
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
init|;
name|a
operator|!=
name|NULL
operator|&&
name|ber_get_eoc
argument_list|(
name|a
argument_list|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|a
operator|=
name|a
operator|->
name|be_next
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|aldap_first_attr
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
modifier|*
name|outkey
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|outvalues
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
argument_list|,
literal|"{s(e)}e"
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
operator|=
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
operator|->
name|be_next
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|aldap_get_stringset
argument_list|(
name|b
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
operator|(
operator|*
name|outvalues
operator|)
operator|=
name|ret
expr_stmt|;
operator|(
operator|*
name|outkey
operator|)
operator|=
name|utoa
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|fail
label|:
operator|(
operator|*
name|outkey
operator|)
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|outvalues
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_next_attr
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
modifier|*
name|outkey
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|outvalues
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
operator|==
name|NULL
condition|)
goto|goto
name|notfound
goto|;
name|LDAP_DEBUG
argument_list|(
literal|"attr"
argument_list|,
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ber_get_eoc
argument_list|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|notfound
goto|;
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
argument_list|,
literal|"{s(e)}e"
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
operator|=
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|iter
operator|->
name|be_next
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|aldap_get_stringset
argument_list|(
name|a
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
operator|(
operator|*
name|outvalues
operator|)
operator|=
name|ret
expr_stmt|;
operator|(
operator|*
name|outkey
operator|)
operator|=
name|utoa
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|fail
label|:
name|notfound
label|:
operator|(
operator|*
name|outkey
operator|)
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|outvalues
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_match_attr
parameter_list|(
name|struct
name|aldap_message
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|inkey
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|outvalues
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|descr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|LDAP_DEBUG
argument_list|(
literal|"attr"
argument_list|,
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|msg
operator|->
name|body
operator|.
name|search
operator|.
name|attrs
init|;
condition|;
control|)
block|{
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
goto|goto
name|notfound
goto|;
if|if
condition|(
name|ber_get_eoc
argument_list|(
name|a
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|notfound
goto|;
if|if
condition|(
name|ber_scanf_elements
argument_list|(
name|a
argument_list|,
literal|"{s(e"
argument_list|,
operator|&
name|descr
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|descr
argument_list|,
name|inkey
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|attrfound
goto|;
name|a
operator|=
name|a
operator|->
name|be_next
expr_stmt|;
block|}
name|attrfound
label|:
if|if
condition|(
operator|(
name|ret
operator|=
name|aldap_get_stringset
argument_list|(
name|b
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
operator|(
operator|*
name|outvalues
operator|)
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|fail
label|:
name|notfound
label|:
operator|(
operator|*
name|outvalues
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|aldap_free_attr
parameter_list|(
name|char
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|values
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|values
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|void aldap_free_url(struct aldap_url *lu) { 	free(lu->buffer); 	free(lu->filter); }  int aldap_parse_url(char *url, struct aldap_url *lu) { 	char		*p, *forward, *forward2; 	const char	*errstr = NULL; 	int		 i;  	if ((lu->buffer = p = strdup(url)) == NULL) 		return (-1);
comment|/* protocol */
end_comment

begin_comment
unit|if (strncasecmp(LDAP_URL, p, strlen(LDAP_URL)) != 0) 		goto fail; 	lu->protocol = LDAP; 	p += strlen(LDAP_URL);
comment|/* host and optional port */
end_comment

begin_comment
unit|if ((forward = strchr(p, '/')) != NULL) 		*forward = '\0';
comment|/* find the optional port */
end_comment

begin_comment
unit|if ((forward2 = strchr(p, ':')) != NULL) { 		*forward2 = '\0';
comment|/* if a port is given */
end_comment

begin_define
unit|if (*(forward2+1) != '\0') {
define|#
directive|define
name|PORT_MAX
value|UINT16_MAX
end_define

begin_comment
unit|lu->port = strtonum(++forward2, 0, PORT_MAX,&errstr); 			if (errstr) 				goto fail; 		} 	}
comment|/* fail if no host is given */
end_comment

begin_comment
unit|if (strlen(p) == 0) 		goto fail; 	lu->host = p; 	if (forward == NULL) 		goto done;
comment|/* p is assigned either a pointer to a character or to '\0' */
end_comment

begin_comment
unit|p = ++forward; 	if (strlen(p) == 0) 		goto done;
comment|/* dn */
end_comment

begin_comment
unit|if ((forward = strchr(p, '?')) != NULL) 		*forward = '\0'; 	lu->dn = p; 	if (forward == NULL) 		goto done;
comment|/* p is assigned either a pointer to a character or to '\0' */
end_comment

begin_comment
unit|p = ++forward; 	if (strlen(p) == 0) 		goto done;
comment|/* attributes */
end_comment

begin_comment
unit|if ((forward = strchr(p, '?')) != NULL) 		*forward = '\0'; 	for (i = 0; i< MAXATTR; i++) { 		if ((forward2 = strchr(p, ',')) == NULL) { 			if (strlen(p) == 0) 				break; 			lu->attributes[i] = p; 			break; 		} 		*forward2 = '\0'; 		lu->attributes[i] = p; 		p = ++forward2; 	} 	if (forward == NULL) 		goto done;
comment|/* p is assigned either a pointer to a character or to '\0' */
end_comment

begin_comment
unit|p = ++forward; 	if (strlen(p) == 0) 		goto done;
comment|/* scope */
end_comment

begin_comment
unit|if ((forward = strchr(p, '?')) != NULL) 		*forward = '\0'; 	if (strcmp(p, "base") == 0) 		lu->scope = LDAP_SCOPE_BASE; 	else if (strcmp(p, "one") == 0) 		lu->scope = LDAP_SCOPE_ONELEVEL; 	else if (strcmp(p, "sub") == 0) 		lu->scope = LDAP_SCOPE_SUBTREE; 	else 		goto fail; 	if (forward == NULL) 		goto done; 	p = ++forward; 	if (strlen(p) == 0) 		goto done;
comment|/* filter */
end_comment

begin_endif
unit|if (p) 		lu->filter = p; done: 	free(url); 	return (1); fail: 	free(lu->buffer); 	lu->buffer = NULL; 	return (-1); }  int aldap_search_url(struct aldap *ldap, char *url, int typesonly, int sizelimit,     int timelimit) { 	struct aldap_url *lu;  	if ((lu = calloc(1, sizeof(*lu))) == NULL) 		return (-1);  	if (aldap_parse_url(url, lu)) 		goto fail;  	if (aldap_search(ldap, lu->dn, lu->scope, lu->filter, lu->attributes, 	    typesonly, sizelimit, timelimit) == -1) 		goto fail;  	aldap_free_url(lu); 	return (ldap->msgid); fail: 	aldap_free_url(lu); 	return (-1); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  * internal functions  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|aldap_get_stringset
parameter_list|(
name|struct
name|ber_element
modifier|*
name|elm
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|elm
operator|->
name|be_type
operator|!=
name|BER_TYPE_OCTETSTRING
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|a
operator|=
name|elm
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|>
literal|0
operator|&&
name|a
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|be_type
operator|==
name|BER_TYPE_OCTETSTRING
condition|;
name|a
operator|=
name|a
operator|->
name|be_next
operator|,
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|calloc
argument_list|(
name|i
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|a
operator|=
name|elm
operator|,
name|i
operator|=
literal|0
init|;
name|a
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|be_type
operator|==
name|BER_TYPE_OCTETSTRING
condition|;
name|a
operator|=
name|a
operator|->
name|be_next
control|)
block|{
name|ber_get_string
argument_list|(
name|a
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|ret
index|[
name|i
index|]
operator|=
name|utoa
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Base case for ldap_do_parse_search_filter  *  * returns:  *	struct ber_element *, ber_element tree  *	NULL, parse failed  */
end_comment

begin_function
specifier|static
name|struct
name|ber_element
modifier|*
name|ldap_parse_search_filter
parameter_list|(
name|struct
name|ber_element
modifier|*
name|ber
parameter_list|,
name|char
modifier|*
name|filter
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|elm
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|filter
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|elm
operator|=
name|ldap_do_parse_search_filter
argument_list|(
name|ber
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|ber_free_elements
argument_list|(
name|elm
argument_list|)
expr_stmt|;
name|ber_link_elements
argument_list|(
name|ber
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|elm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate RFC4515 search filter string into ber_element tree  *  * returns:  *	struct ber_element *, ber_element tree  *	NULL, parse failed  *  * notes:  *	when cp is passed to a recursive invocation, it is updated  *	    to point one character beyond the filter that was passed  *	    i.e., cp jumps to "(filter)" upon return  *	                               ^  *	goto's used to discriminate error-handling based on error type  *	doesn't handle extended filters (yet)  *  */
end_comment

begin_function
specifier|static
name|struct
name|ber_element
modifier|*
name|ldap_do_parse_search_filter
parameter_list|(
name|struct
name|ber_element
modifier|*
name|prev
parameter_list|,
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
name|struct
name|ber_element
modifier|*
name|elm
decl_stmt|,
modifier|*
name|root
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|attr_desc
decl_stmt|,
modifier|*
name|attr_val
decl_stmt|,
modifier|*
name|parsed_val
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
comment|/* cpp should pass in pointer to opening parenthesis of "(filter)" */
name|cp
operator|=
operator|*
name|cpp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'('
condition|)
goto|goto
name|syntaxfail
goto|;
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'&'
case|:
comment|/* AND */
case|case
literal|'|'
case|:
comment|/* OR */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'&'
condition|)
name|type
operator|=
name|LDAP_FILT_AND
expr_stmt|;
else|else
name|type
operator|=
name|LDAP_FILT_OR
expr_stmt|;
if|if
condition|(
operator|(
name|elm
operator|=
name|ber_add_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|root
operator|=
name|elm
expr_stmt|;
name|ber_set_header
argument_list|(
name|elm
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
literal|'('
condition|)
comment|/* opening `(` of filter */
goto|goto
name|syntaxfail
goto|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
operator|(
name|elm
operator|=
name|ldap_do_parse_search_filter
argument_list|(
name|elm
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|')'
condition|)
comment|/* trailing `)` of filter */
goto|goto
name|syntaxfail
goto|;
break|break;
case|case
literal|'!'
case|:
comment|/* NOT */
if|if
condition|(
operator|(
name|root
operator|=
name|ber_add_sequence
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|ber_set_header
argument_list|(
name|root
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
name|LDAP_FILT_NOT
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
comment|/* now points to sub-filter */
if|if
condition|(
operator|(
name|elm
operator|=
name|ldap_do_parse_search_filter
argument_list|(
name|root
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|')'
condition|)
comment|/* trailing `)` of filter */
goto|goto
name|syntaxfail
goto|;
break|break;
default|default:
comment|/* SIMPLE || PRESENCE */
name|attr_desc
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|cp
argument_list|,
literal|"()<>~="
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'~'
case|:
name|type
operator|=
name|LDAP_FILT_APPR
expr_stmt|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|type
operator|=
name|LDAP_FILT_LE
expr_stmt|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|type
operator|=
name|LDAP_FILT_GE
expr_stmt|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|type
operator|=
name|LDAP_FILT_EQ
expr_stmt|;
comment|/* assume EQ until disproven */
break|break;
case|case
literal|'('
case|:
case|case
literal|')'
case|:
default|default:
goto|goto
name|syntaxfail
goto|;
block|}
name|attr_val
operator|=
operator|++
name|cp
expr_stmt|;
comment|/* presence filter */
if|if
condition|(
name|strncmp
argument_list|(
name|attr_val
argument_list|,
literal|"*)"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
comment|/* point to trailing `)` */
if|if
condition|(
operator|(
name|root
operator|=
name|ber_add_nstring
argument_list|(
name|prev
argument_list|,
name|attr_desc
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ber_set_header
argument_list|(
name|root
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
name|LDAP_FILT_PRES
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|root
operator|=
name|ber_add_sequence
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|ber_set_header
argument_list|(
name|root
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elm
operator|=
name|ber_add_nstring
argument_list|(
name|root
argument_list|,
name|attr_desc
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|len
operator|=
name|strcspn
argument_list|(
name|attr_val
argument_list|,
literal|"*)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|*
name|cp
operator|!=
literal|'*'
condition|)
goto|goto
name|syntaxfail
goto|;
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
goto|goto
name|syntaxfail
goto|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
comment|/* substring filter */
name|int
name|initial
decl_stmt|;
name|cp
operator|=
name|attr_val
expr_stmt|;
name|ber_set_header
argument_list|(
name|root
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
name|LDAP_FILT_SUBS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elm
operator|=
name|ber_add_sequence
argument_list|(
name|elm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
for|for
control|(
name|initial
operator|=
literal|1
init|;
condition|;
name|cp
operator|++
operator|,
name|initial
operator|=
literal|0
control|)
block|{
name|attr_val
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|attr_val
argument_list|,
literal|"*)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
condition|)
break|break;
else|else
continue|continue;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
goto|goto
name|syntaxfail
goto|;
if|if
condition|(
name|initial
condition|)
name|type
operator|=
name|LDAP_FILT_SUBS_INIT
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
condition|)
name|type
operator|=
name|LDAP_FILT_SUBS_FIN
expr_stmt|;
else|else
name|type
operator|=
name|LDAP_FILT_SUBS_ANY
expr_stmt|;
if|if
condition|(
operator|(
name|parsed_val
operator|=
name|parseval
argument_list|(
name|attr_val
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|elm
operator|=
name|ber_add_nstring
argument_list|(
name|elm
argument_list|,
name|parsed_val
argument_list|,
name|strlen
argument_list|(
name|parsed_val
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parsed_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|ber_set_header
argument_list|(
name|elm
argument_list|,
name|BER_CLASS_CONTEXT
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LDAP_FILT_SUBS_FIN
condition|)
break|break;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|parsed_val
operator|=
name|parseval
argument_list|(
name|attr_val
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
name|elm
operator|=
name|ber_add_nstring
argument_list|(
name|elm
argument_list|,
name|parsed_val
argument_list|,
name|strlen
argument_list|(
name|parsed_val
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parsed_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
goto|goto
name|callfail
goto|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
comment|/* now points one char beyond the trailing `)` */
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|root
operator|)
return|;
name|syntaxfail
label|:
comment|/* XXX -- error reporting */
name|callfail
label|:
name|bad
label|:
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
name|ber_free_elements
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ber_link_elements
argument_list|(
name|prev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Display a list of ber elements.  *  */
end_comment

begin_function
name|void
name|ldap_debug_elements
parameter_list|(
name|struct
name|ber_element
modifier|*
name|root
parameter_list|)
block|{
specifier|static
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|long
name|long
name|v
decl_stmt|;
name|int
name|d
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|constructed
decl_stmt|;
name|struct
name|ber_oid
name|o
decl_stmt|;
comment|/* calculate lengths */
name|ber_calc_len
argument_list|(
name|root
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|root
operator|->
name|be_encoding
condition|)
block|{
case|case
name|BER_TYPE_SEQUENCE
case|:
case|case
name|BER_TYPE_SET
case|:
name|constructed
operator|=
name|root
operator|->
name|be_encoding
expr_stmt|;
break|break;
default|default:
name|constructed
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*slen %lu "
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|root
operator|->
name|be_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|root
operator|->
name|be_class
condition|)
block|{
case|case
name|BER_CLASS_UNIVERSAL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"class: universal(%u) type: "
argument_list|,
name|root
operator|->
name|be_class
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|root
operator|->
name|be_type
condition|)
block|{
case|case
name|BER_TYPE_EOC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"end-of-content"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_BOOLEAN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"boolean"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_INTEGER
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"integer"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_BITSTRING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bit-string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_OCTETSTRING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"octet-string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_NULL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_OBJECT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"object"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_ENUMERATED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"enumerated"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_SEQUENCE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sequence"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_SET
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|BER_CLASS_APPLICATION
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"class: application(%u) type: "
argument_list|,
name|root
operator|->
name|be_class
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|root
operator|->
name|be_type
condition|)
block|{
case|case
name|LDAP_REQ_BIND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_BIND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_UNBIND_30
case|:
break|break;
case|case
name|LDAP_REQ_SEARCH
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"search"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_SEARCH_ENTRY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"search_entry"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_SEARCH_RESULT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"search_result"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_MODIFY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modify"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_MODIFY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modify"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_ADD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_ADD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_DELETE_30
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_DELETE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_MODRDN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modrdn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_MODRDN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modrdn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_COMPARE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compare"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_RES_COMPARE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compare"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDAP_REQ_ABANDON_30
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"abandon"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|BER_CLASS_PRIVATE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"class: private(%u) type: "
argument_list|,
name|root
operator|->
name|be_class
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"encoding (%lu) type: "
argument_list|,
name|root
operator|->
name|be_encoding
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_CLASS_CONTEXT
case|:
comment|/* XXX: this is not correct */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"class: context(%u) type: "
argument_list|,
name|root
operator|->
name|be_class
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|root
operator|->
name|be_type
condition|)
block|{
case|case
name|LDAP_AUTH_SIMPLE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"auth simple"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"class:<INVALID>(%u) type: "
argument_list|,
name|root
operator|->
name|be_class
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%lu) encoding %lu "
argument_list|,
name|root
operator|->
name|be_type
argument_list|,
name|root
operator|->
name|be_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructed
condition|)
name|root
operator|->
name|be_encoding
operator|=
name|constructed
expr_stmt|;
switch|switch
condition|(
name|root
operator|->
name|be_encoding
condition|)
block|{
case|case
name|BER_TYPE_BOOLEAN
case|:
if|if
condition|(
name|ber_get_boolean
argument_list|(
name|root
argument_list|,
operator|&
name|d
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<INVALID>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s(%d)\n"
argument_list|,
name|d
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_INTEGER
case|:
if|if
condition|(
name|ber_get_integer
argument_list|(
name|root
argument_list|,
operator|&
name|v
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<INVALID>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"value %lld\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_ENUMERATED
case|:
if|if
condition|(
name|ber_get_enumerated
argument_list|(
name|root
argument_list|,
operator|&
name|v
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<INVALID>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"value %lld\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_BITSTRING
case|:
if|if
condition|(
name|ber_get_bitstring
argument_list|(
name|root
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<INVALID>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hexdump "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_OBJECT
case|:
if|if
condition|(
name|ber_get_oid
argument_list|(
name|root
argument_list|,
operator|&
name|o
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<INVALID>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_OCTETSTRING
case|:
if|if
condition|(
name|ber_get_nstring
argument_list|(
name|root
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<INVALID>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string \"%.*s\"\n"
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|BER_TYPE_NULL
case|:
comment|/* no payload */
case|case
name|BER_TYPE_EOC
case|:
case|case
name|BER_TYPE_SEQUENCE
case|:
case|case
name|BER_TYPE_SET
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|constructed
operator|&&
name|root
operator|->
name|be_sub
condition|)
block|{
name|indent
operator|+=
literal|2
expr_stmt|;
name|ldap_debug_elements
argument_list|(
name|root
operator|->
name|be_sub
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|root
operator|->
name|be_next
condition|)
name|ldap_debug_elements
argument_list|(
name|root
operator|->
name|be_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Strip UTF-8 down to ASCII without validation.  * notes:  *	non-ASCII characters are displayed as '?'  *	the argument u should be a NULL terminated sequence of UTF-8 bytes.  */
end_comment

begin_function
name|char
modifier|*
name|utoa
parameter_list|(
name|char
modifier|*
name|u
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
comment|/* calculate the length to allocate */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|u
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isu8cont
argument_list|(
name|u
index|[
name|i
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|=
name|calloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* copy the ASCII characters to the newly allocated string */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|u
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isu8cont
argument_list|(
name|u
index|[
name|i
index|]
argument_list|)
condition|)
name|str
index|[
name|j
operator|++
index|]
operator|=
name|isascii
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|u
index|[
name|i
index|]
argument_list|)
condition|?
name|u
index|[
name|i
index|]
else|:
literal|'?'
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isu8cont
parameter_list|(
name|unsigned
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|&
operator|(
literal|0x80
operator||
literal|0x40
operator|)
operator|)
operator|==
literal|0x80
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a LDAP value  * notes:  *	the argument p should be a NUL-terminated sequence of ASCII bytes.  */
end_comment

begin_function
name|char
modifier|*
name|parseval
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|hex
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|buffer
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|j
index|]
operator|==
literal|'\\'
condition|)
block|{
name|strlcpy
argument_list|(
name|hex
argument_list|,
name|p
operator|+
name|j
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hex
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|strtoumax
argument_list|(
name|hex
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|p
index|[
name|j
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_function
name|int
name|aldap_get_errno
parameter_list|(
name|struct
name|aldap
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|estr
parameter_list|)
block|{
switch|switch
condition|(
name|a
operator|->
name|err
condition|)
block|{
case|case
name|ALDAP_ERR_SUCCESS
case|:
operator|*
name|estr
operator|=
literal|"success"
expr_stmt|;
break|break;
case|case
name|ALDAP_ERR_PARSER_ERROR
case|:
operator|*
name|estr
operator|=
literal|"parser failed"
expr_stmt|;
break|break;
case|case
name|ALDAP_ERR_INVALID_FILTER
case|:
operator|*
name|estr
operator|=
literal|"invalid filter"
expr_stmt|;
break|break;
case|case
name|ALDAP_ERR_OPERATION_FAILED
case|:
operator|*
name|estr
operator|=
literal|"operation failed"
expr_stmt|;
break|break;
default|default:
operator|*
name|estr
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|a
operator|->
name|err
operator|)
return|;
block|}
end_function

end_unit

