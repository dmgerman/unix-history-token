begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *        The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the University of  *        California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * From @(#)vnode_if.sh        8.1 (Berkeley) 6/10/93  * From @(#)makedevops.sh 1.1 1998/06/14 13:53:12 dfr Exp $  * From @(#)makedevops.sh ?.? 1998/10/05  * From src/sys/kern/makedevops.pl,v 1.12 1999/11/22 14:40:04 n_hibma Exp  * From FreeBSD: src/sys/kern/makeobjops.pl,v 1.2.2.1 2001/02/02 19:49:13 cg Exp  *	$Id: makeobjops.c,v 1.3 2001/10/10 21:22:41 db Exp $  */
end_comment

begin_comment
comment|/*  *  * Script to produce kobj front-end sugar.  *  */
end_comment

begin_comment
comment|/*  * My personal preference would have been to use yacc/lex etc.  * However, this is part of the core when we don't even have yacc/lex yet..  * So, a simple recursive descent it is..  * -db  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function_decl
specifier|static
name|void
name|process_files
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|progname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_headers
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|char
modifier|*
name|prog_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_body
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|int
name|line_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|upper_case
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|add_ext
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|progname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|strip_ext
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_code_section
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_c_body
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|char
modifier|*
name|mname
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_h_body
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|char
modifier|*
name|mtype
parameter_list|,
name|char
modifier|*
name|mname
parameter_list|,
name|int
name|max_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_method
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|char
modifier|*
name|input_buffer
parameter_list|,
name|int
name|line_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_copy
parameter_list|(
name|char
modifier|*
name|fin
parameter_list|,
name|char
modifier|*
name|fout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|first_token
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|next_token
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|trim_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|make_strdup
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|make_malloc
parameter_list|(
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAXLIST
value|32
end_define

begin_struct
struct|struct
name|type_name
block|{
name|int
name|deref
decl_stmt|;
name|char
modifier|*
name|mtype
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|type_name
name|type_name_list
index|[
name|MAXLIST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* by default do not produce any file type */
end_comment

begin_decl_stmt
name|int
name|hfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keepcurrentdir
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line_width
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXLINE
value|128
end_define

begin_comment
comment|/* Process the command line */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|progname
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Process the command line */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"chdpl:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Producing .c output files\n"
argument_list|)
expr_stmt|;
name|cfile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Producing .h output files\n"
argument_list|)
expr_stmt|;
name|hfile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Will produce files in original not in current directory\n"
argument_list|)
expr_stmt|;
name|keepcurrentdir
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|line_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|cfile
operator|&&
operator|!
name|hfile
condition|)
block|{
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
block|}
name|process_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * usage  *  * inputs	- program name  * output	- none  * side effects	- prints usage summary then exits.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|progname
parameter_list|)
block|{
comment|/* Validate the command line parameters */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-d] [-p] [-l<nr>] [-c|-h] srcfile\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"where -c  produce only .c files\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      -h  produce only .h files\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      -p  use the path component in the source file for destination dir\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      -l  set line width for output files [80]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      -d  switch on debugging\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find_tmp  *  * inputs	- none  * output	- pointer to valid tmp dir  * side effects	- exits if none found  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_tmp
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|tmpdir
decl_stmt|;
name|struct
name|stat
name|dstat
decl_stmt|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tmpdir
operator|)
return|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tmpdir
operator|)
return|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tmpdir
operator|)
return|;
name|tmpdir
operator|=
literal|"/tmp"
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmpdir
argument_list|,
operator|&
name|dstat
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|tmpdir
operator|)
return|;
name|tmpdir
operator|=
name|P_tmpdir
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmpdir
argument_list|,
operator|&
name|dstat
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|tmpdir
operator|)
return|;
name|tmpdir
operator|=
literal|"."
expr_stmt|;
return|return
operator|(
name|tmpdir
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mk_tmp  *  * inputs	- pointer to tmp dir to use  *		- pointer to basename  *		- pointer to temp ext to use  * output	- pointer to tmp file, tmp file name is formed  *		- from dirname/basename.ext{pid}  * side effects	- caller is responsible for freeing memory  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mk_tmp
parameter_list|(
name|char
modifier|*
name|tmpdir
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|tmpstr
argument_list|,
literal|"%s/%s.%s%d"
argument_list|,
name|tmpdir
argument_list|,
name|name
argument_list|,
name|ext
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmpstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process_files  *  * inputs	- file count  *		- pointer to (assumed) list of filenames  *		- given program name  * output	- none  * side effects	- given files are processed  */
end_comment

begin_function
specifier|static
name|void
name|process_files
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|char
modifier|*
name|tmpdir
decl_stmt|;
name|char
modifier|*
name|ctmpname
decl_stmt|;
name|char
modifier|*
name|htmpname
decl_stmt|;
name|char
modifier|*
name|cname
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
comment|/* actual src file name */
name|char
modifier|*
name|src_base
decl_stmt|;
comment|/* file name minus any extension */
name|char
modifier|*
name|src_path
decl_stmt|;
name|FILE
modifier|*
name|cfile_fp
decl_stmt|,
modifier|*
name|hfile_fp
decl_stmt|,
modifier|*
name|src_fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|line_count
decl_stmt|;
name|line_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|find_tmp
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Cannot find a tmp dir"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|src_base
operator|=
name|basename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"can't find basename(%s)"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|src_base
operator|=
name|strip_ext
argument_list|(
name|src_base
argument_list|,
literal|".m"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src_path
operator|=
name|dirname
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"can't find dirname(%s)"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctmpname
operator|=
name|mk_tmp
argument_list|(
name|tmpdir
argument_list|,
name|src_base
argument_list|,
literal|"ctmp"
argument_list|)
expr_stmt|;
name|htmpname
operator|=
name|mk_tmp
argument_list|(
name|tmpdir
argument_list|,
name|src_base
argument_list|,
literal|"htmp"
argument_list|)
expr_stmt|;
comment|/* The makefile wasn't clear... bah 		 * accept both file name with .m or without 		 */
if|if
condition|(
name|strstr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|".m"
argument_list|)
condition|)
name|src
operator|=
name|make_strdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|add_ext
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"m"
argument_list|)
expr_stmt|;
name|cname
operator|=
name|add_ext
argument_list|(
name|src_base
argument_list|,
literal|"c"
argument_list|)
expr_stmt|;
name|hname
operator|=
name|add_ext
argument_list|(
name|src_base
argument_list|,
literal|"h"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfile
condition|)
block|{
if|if
condition|(
operator|(
name|cfile_fp
operator|=
name|fopen
argument_list|(
name|ctmpname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Could not open %s"
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hfile
condition|)
block|{
if|if
condition|(
operator|(
name|hfile_fp
operator|=
name|fopen
argument_list|(
name|htmpname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Could not open %s"
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|src_fp
operator|=
name|fopen
argument_list|(
name|src
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Could not open %s"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|print_headers
argument_list|(
name|src
argument_list|,
name|cfile_fp
argument_list|,
name|hfile_fp
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfile
condition|)
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"#ifndef _%s_h_\n"
argument_list|,
name|src_base
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"#define _%s_h_\n\n"
argument_list|,
name|src_base
argument_list|)
expr_stmt|;
block|}
name|process_body
argument_list|(
name|src
argument_list|,
name|src_fp
argument_list|,
name|cfile_fp
argument_list|,
name|hfile_fp
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfile
condition|)
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"\n#endif /* _%s_h_ */\n"
argument_list|,
name|src_base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfile
condition|)
name|fclose
argument_list|(
name|cfile_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfile
condition|)
name|fclose
argument_list|(
name|hfile_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|src_fp
argument_list|)
expr_stmt|;
comment|/* copy files generated into position */
comment|/* XXX */
if|if
condition|(
operator|!
name|keepcurrentdir
condition|)
if|if
condition|(
name|chdir
argument_list|(
name|src_path
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"can't chdir to %s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfile
condition|)
block|{
name|make_copy
argument_list|(
name|ctmpname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ctmpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hfile
condition|)
block|{
name|make_copy
argument_list|(
name|htmpname
argument_list|,
name|hname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|htmpname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ctmpname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|htmpname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * add_ext   *  * inputs	- pointer to prefix  *		- pointer to suffix  * output	- pointer to name as prefix.suffix  * side effects	- caller is responsible for freeing memory  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|add_ext
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|tmpstr
argument_list|,
literal|"%s.%s"
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmpstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * make_strdup  *  * inputs	- pointer to string to duplicate  * output	- pointer duplicated string  * side effects	- exits if unable to malloc  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_strdup
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * print_headers  *  * inputs	- FILE pointer to cfile  *		- FILE pointer to hfile  *		- FILE pointer to source file  *		- given program name  * output	- none  * side effects	- headers are printed to given temp files  */
end_comment

begin_function
specifier|static
name|void
name|print_headers
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|char
modifier|*
name|prog_name
parameter_list|)
block|{
if|if
condition|(
name|cfile
condition|)
block|{
comment|/* Produce the header of the C file */
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"/*\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" * This file is produced automatically.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" * Do not modify anything in here by hand.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" * Created from source file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" *   %s\n"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" * with\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" *   %s\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" * See the source file for legal information\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|" */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"#include<sys/param.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"#include<sys/kernel.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"#include<sys/kobj.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"#include<sys/queue.h>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hfile
condition|)
block|{
comment|/* Produce the header of the H file */
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"/*\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" * This file is produced automatically.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" * Do not modify anything in here by hand.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" * Created from source file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" *   %s\n"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" * with\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" *   %s\n"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" * See the source file for legal information\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|" */\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process_body  *  * inputs	- filename of src  *		- FILE pointer of src  *		- FILE pointer of cfile output  *		- FILE pointer of hfile output  * output	- NONE  * side effects	- exits on error  */
end_comment

begin_function
specifier|static
name|void
name|process_body
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|int
name|line_count
parameter_list|)
block|{
name|char
name|input_buffer
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|src_noext
decl_stmt|;
name|int
name|myheader
decl_stmt|;
name|myheader
operator|=
literal|0
expr_stmt|;
name|src_noext
operator|=
name|strip_ext
argument_list|(
name|src
argument_list|,
literal|".m"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|input_buffer
argument_list|,
name|MAXLINE
operator|-
literal|1
argument_list|,
name|src_fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* strip newlines */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|input_buffer
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now, why does someone have carriage returns in here? */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|input_buffer
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* not fancy, but include include files for now */
if|if
condition|(
name|strncmp
argument_list|(
name|input_buffer
argument_list|,
literal|"#include"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cfile
condition|)
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"%s\n"
argument_list|,
name|input_buffer
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore comments */
if|if
condition|(
name|input_buffer
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* Ignore blank lines */
if|if
condition|(
name|input_buffer
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|input_buffer
argument_list|,
literal|"CODE"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cfile
operator|&&
operator|!
name|myheader
condition|)
block|{
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"#include \"%s.h\"\n\n"
argument_list|,
name|src_noext
argument_list|)
expr_stmt|;
name|myheader
operator|=
literal|1
expr_stmt|;
block|}
name|emit_code_section
argument_list|(
name|src
argument_list|,
name|src_fp
argument_list|,
name|cfile_fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_buffer
argument_list|,
literal|"METHOD"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cfile
operator|&&
operator|!
name|myheader
condition|)
block|{
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"#include \"%s.h\"\n\n"
argument_list|,
name|src_noext
argument_list|)
expr_stmt|;
name|myheader
operator|=
literal|1
expr_stmt|;
block|}
name|line_count
operator|=
name|parse_method
argument_list|(
name|src_noext
argument_list|,
name|src_fp
argument_list|,
name|cfile_fp
argument_list|,
name|hfile_fp
argument_list|,
name|input_buffer
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|src_noext
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * parse_method  *  * inputs	- pointer to source file name  *		- pointer to temp cfile name output  *		- pointer to temp hfile name output  *		- pointer to scratch input  *		- line_count  *		- given program name  * output	- new line_count  * side effects	- METHOD is parsed, correct code is emitted as necessary  */
end_comment

begin_function
specifier|static
name|int
name|parse_method
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|char
modifier|*
name|input_buffer
parameter_list|,
name|int
name|line_count
parameter_list|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
comment|/* currently being parsed token */
name|char
modifier|*
name|mtype
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|char
modifier|*
name|tmp_type
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
comment|/* method name */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|trim_src
decl_stmt|;
name|int
name|cur_list
decl_stmt|;
comment|/* counter into type/names list */
name|int
name|deref
decl_stmt|;
name|deref
operator|=
name|cur_list
operator|=
literal|0
expr_stmt|;
name|token
operator|=
name|first_token
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
comment|/* METHOD */
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* type or struct */
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"struct"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* type */
name|mtype
operator|=
name|make_malloc
argument_list|(
name|strlen
argument_list|(
literal|"struct "
argument_list|)
operator|+
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mtype
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
comment|/* Copy it into place, knowing where end of "struct " is */
name|strcpy
argument_list|(
name|mtype
operator|+
literal|7
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtype
operator|=
name|make_strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* name */
name|deref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|token
operator|==
literal|'*'
condition|)
block|{
name|deref
operator|=
literal|1
expr_stmt|;
name|mname
operator|=
name|make_strdup
argument_list|(
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|deref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"Null"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mname
operator|=
name|make_strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"deref %d mtype [%s] mname [%s]\n"
argument_list|,
name|deref
argument_list|,
name|mtype
argument_list|,
name|mname
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|input_buffer
argument_list|,
name|MAXLINE
operator|-
literal|1
argument_list|,
name|src_fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|++
name|line_count
expr_stmt|;
if|if
condition|(
name|input_buffer
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
continue|continue;
block|}
name|trim_src
operator|=
name|trim_name
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|input_buffer
argument_list|,
literal|'}'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|token
operator|=
name|first_token
argument_list|(
name|input_buffer
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"DEFAULT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dname
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|dname
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|cfile
condition|)
name|emit_c_body
argument_list|(
name|trim_src
argument_list|,
name|src_fp
argument_list|,
name|cfile_fp
argument_list|,
name|mname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfile
condition|)
name|emit_h_body
argument_list|(
name|trim_src
argument_list|,
name|hfile_fp
argument_list|,
name|mtype
argument_list|,
name|mname
argument_list|,
name|cur_list
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|trim_src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|input_buffer
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|input_buffer
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|=
name|first_token
argument_list|(
name|input_buffer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"parse error line number %d"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"struct"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|token
operator|=
name|next_token
argument_list|(
name|input_buffer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"parse error line number %d"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
block|}
name|tmp_type
operator|=
name|make_malloc
argument_list|(
name|strlen
argument_list|(
literal|"struct "
argument_list|)
operator|+
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy it into place, knowing where end of "struct " is */
name|strcpy
argument_list|(
name|tmp_type
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp_type
operator|+
literal|7
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp_type
operator|=
name|make_strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|type_name_list
index|[
name|cur_list
index|]
operator|.
name|mtype
operator|=
name|tmp_type
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"parse error line number %d"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|token
operator|==
literal|'*'
condition|)
block|{
name|type_name_list
index|[
name|cur_list
index|]
operator|.
name|deref
operator|=
literal|1
expr_stmt|;
name|type_name_list
index|[
name|cur_list
index|]
operator|.
name|mname
operator|=
name|make_strdup
argument_list|(
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type_name_list
index|[
name|cur_list
index|]
operator|.
name|deref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|=
name|next_token
argument_list|(
name|token
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"parse error line number %d"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
block|}
block|}
name|type_name_list
index|[
name|cur_list
index|]
operator|.
name|mname
operator|=
name|make_strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|cur_list
operator|++
expr_stmt|;
if|if
condition|(
name|cur_list
operator|>=
name|MAXLIST
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"parse error MAXLIST exceed line number %d"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mname
argument_list|)
expr_stmt|;
return|return
operator|(
name|line_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * emit_code_section  *  * inputs	- filename of src  *		- FILE pointer of src  *		- FILE pointer of cfile output  * output	- NONE  * side effects	- exits on error  */
end_comment

begin_function
specifier|static
name|void
name|emit_code_section
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|)
block|{
name|char
name|input_buffer
index|[
name|MAXLINE
index|]
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|input_buffer
argument_list|,
name|MAXLINE
operator|-
literal|1
argument_list|,
name|src_fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX can do better then a simple strncmp  * can strchr both '}' and ';' if needed.   * could also count brace depth. i.e. - if } seen if reaches 0, done.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_buffer
argument_list|,
literal|"};"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|cfile
condition|)
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"%s"
argument_list|,
name|input_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * upper_case  *  * inputs	- pointer to name to upper case  * output	- pointer to given string as upper case  * side effects	- caller is responsible for freeing memory  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|upper_case
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|upper
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|upper
operator|=
name|make_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|upper
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|upper
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * emit_c_body  *  * inputs	- filename of src  *		- FILE pointer of src  *		- FILE pointer of cfile output  *		- method name  * output	- NONE  * side effects	- exits on error  */
end_comment

begin_function
specifier|static
name|void
name|emit_c_body
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|src_fp
parameter_list|,
name|FILE
modifier|*
name|cfile_fp
parameter_list|,
name|char
modifier|*
name|mname
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|)
block|{
if|if
condition|(
name|cfile
condition|)
block|{
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"struct kobjop_desc %s_%s_desc = {\n"
argument_list|,
name|src
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"\t0, (kobjop_t) %s\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cfile_fp
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * emit_h_body  *  * inputs	- filename of src  *		- FILE pointer of src  *		- FILE pointer of hfile output  *		- method name  * output	- NONE  * side effects	- exits on error  */
end_comment

begin_function
specifier|static
name|void
name|emit_h_body
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|FILE
modifier|*
name|hfile_fp
parameter_list|,
name|char
modifier|*
name|mtype
parameter_list|,
name|char
modifier|*
name|mname
parameter_list|,
name|int
name|max_list
parameter_list|)
block|{
name|char
modifier|*
name|upper_case_src
decl_stmt|;
name|char
modifier|*
name|upper_case_mname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|upper_case_src
operator|=
name|upper_case
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|upper_case_mname
operator|=
name|upper_case
argument_list|(
name|mname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"extern struct kobjop_desc %s_%s_desc;\n"
argument_list|,
name|src
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"typedef %s %s_%s_t("
argument_list|,
name|mtype
argument_list|,
name|src
argument_list|,
name|mname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_list
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|!=
name|max_list
condition|)
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"%s %s%s, "
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mtype
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|deref
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"%s %s%s);\n"
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mtype
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|deref
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mname
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"static __inline %s %s_%s("
argument_list|,
name|mtype
argument_list|,
name|upper_case_src
argument_list|,
name|upper_case_mname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_list
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|!=
name|max_list
condition|)
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"%s %s%s, "
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mtype
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|deref
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"%s %s%s)\n"
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mtype
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|deref
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mname
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"\tkobjop_t _m;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"\tKOBJOPLOOKUP(((kobj_t)%s)->ops,%s_%s);\n"
argument_list|,
name|type_name_list
index|[
literal|0
index|]
operator|.
name|mname
argument_list|,
name|src
argument_list|,
name|mname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mtype
argument_list|,
literal|"void"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"\treturn ((%s_%s_t *) _m)("
argument_list|,
name|src
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_list
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|!=
name|max_list
condition|)
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"%s, "
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"%s);\n"
argument_list|,
name|type_name_list
index|[
name|i
index|]
operator|.
name|mname
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfile_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|upper_case_src
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|upper_case_mname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * make_copy  *  * inputs	- file to copy from  *		- file to copy to  * output	- NONE  * side effects	- exits on error  */
end_comment

begin_function
specifier|static
name|void
name|make_copy
parameter_list|(
name|char
modifier|*
name|fin
parameter_list|,
name|char
modifier|*
name|fout
parameter_list|)
block|{
name|int
name|fd_in
decl_stmt|;
name|int
name|fd_out
decl_stmt|;
name|char
name|buffer
index|[
name|MAXLINE
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
if|if
condition|(
operator|(
name|fd_in
operator|=
name|open
argument_list|(
name|fin
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Cannot open %s for read"
argument_list|,
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd_out
operator|=
name|open
argument_list|(
name|fout
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Cannot open %s for write"
argument_list|,
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fd_in
argument_list|,
name|buffer
argument_list|,
name|MAXLINE
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fd_out
argument_list|,
name|buffer
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd_in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * strip_ext  *  * inputs	- pointer to string  * output	- pointer to string without extension  * side effects	- NONE  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strip_ext
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|t
operator|=
name|make_strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|t
argument_list|,
name|ext
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* The observant will note this leaves 2 extra bytes allocated 		 * unnecessarily. *tough* memory is cheap. 		 */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * first_token  *  * inputs	- pointer to string  * output	- pointer to next token  * side effects	- NONE  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|first_token
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * next_token  *  * inputs	- pointer to string  * output	- pointer to next token  * side effects	- NONE  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_token
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * trim_name  *  * inputs	- pointer to name to trim  * output	- pointer to static trimmed to first '_'  *		  i.e 'foo_h' trimmed to 'foo'  * side effects	- NONE  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|trim_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|trimmed
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|trimmed
operator|=
name|make_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|trimmed
argument_list|,
literal|'_'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|trimmed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * make_malloc  *  * inputs	- number of byte to allocate  * output	- pointer to allocated memory  * side effects	- exits if unable to malloc  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_malloc
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

end_unit

