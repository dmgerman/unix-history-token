begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)output.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|int
name|update_seqno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* walk the tree of routes with this for output  */
end_comment

begin_struct
struct|struct
block|{
name|struct
name|sockaddr_in
name|to
decl_stmt|;
name|naddr
name|to_mask
decl_stmt|;
name|naddr
name|to_net
decl_stmt|;
name|naddr
name|to_std_mask
decl_stmt|;
name|naddr
name|to_std_net
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
comment|/* usually output interface */
struct|struct
name|ws_buf
block|{
comment|/* info for each buffer */
name|struct
name|rip
modifier|*
name|buf
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|n
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|base
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lim
decl_stmt|;
name|enum
name|output_type
name|type
decl_stmt|;
block|}
name|v12
struct|,
name|v2
struct|;
name|char
name|metric
decl_stmt|;
comment|/* adjust metrics by interface */
name|int
name|npackets
decl_stmt|;
name|u_int
name|state
decl_stmt|;
define|#
directive|define
name|WS_ST_FLASH
value|0x001
comment|/* send only changed routes */
define|#
directive|define
name|WS_ST_RIP2_SAFE
value|0x002
comment|/* send RIPv2 safe for RIPv1 */
define|#
directive|define
name|WS_ST_RIP2_ALL
value|0x004
comment|/* send full featured RIPv2 */
define|#
directive|define
name|WS_ST_AG
value|0x008
comment|/* ok to aggregate subnets */
define|#
directive|define
name|WS_ST_SUPER_AG
value|0x010
comment|/* ok to aggregate networks */
define|#
directive|define
name|WS_ST_SUB_AG
value|0x020
comment|/* aggregate subnets in odd case */
define|#
directive|define
name|WS_ST_QUERY
value|0x040
comment|/* responding to a query */
define|#
directive|define
name|WS_ST_TO_ON_NET
value|0x080
comment|/* sending onto one of our nets */
define|#
directive|define
name|WS_ST_DEFAULT
value|0x100
comment|/* faking a default */
define|#
directive|define
name|WS_ST_PM_RDISC
value|0x200
comment|/* poor-man's router discovery */
block|}
name|ws
struct|;
end_struct

begin_comment
comment|/* A buffer for what can be heard by both RIPv1 and RIPv2 listeners */
end_comment

begin_decl_stmt
name|union
name|pkt_buf
name|ripv12_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Another for only RIPv2 listeners */
end_comment

begin_decl_stmt
name|union
name|pkt_buf
name|rip_v2_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send the contents of the global buffer via the non-multicast socket  */
end_comment

begin_function
name|int
comment|/*<0 on failure */
name|output
parameter_list|(
name|enum
name|output_type
name|type
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|dst
parameter_list|,
comment|/* send to here */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|struct
name|rip
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
comment|/* this many bytes */
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|res
decl_stmt|;
name|naddr
name|tgt_mcast
decl_stmt|;
name|int
name|soc
decl_stmt|;
name|int
name|serrno
decl_stmt|;
name|sin
operator|=
operator|*
name|dst
expr_stmt|;
if|if
condition|(
name|sin
operator|.
name|sin_port
operator|==
literal|0
condition|)
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
if|if
condition|(
name|sin
operator|.
name|sin_len
operator|==
literal|0
condition|)
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|soc
operator|=
name|rip_sock
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OUT_QUERY
case|:
name|msg
operator|=
literal|"Answer Query"
expr_stmt|;
if|if
condition|(
name|soc
operator|<
literal|0
condition|)
name|soc
operator|=
name|ifp
operator|->
name|int_rip_sock
expr_stmt|;
break|break;
case|case
name|OUT_UNICAST
case|:
name|msg
operator|=
literal|"Send"
expr_stmt|;
if|if
condition|(
name|soc
operator|<
literal|0
condition|)
name|soc
operator|=
name|ifp
operator|->
name|int_rip_sock
expr_stmt|;
name|flags
operator|=
name|MSG_DONTROUTE
expr_stmt|;
break|break;
case|case
name|OUT_BROADCAST
case|:
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|msg
operator|=
literal|"Send"
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
literal|"Send bcast"
expr_stmt|;
block|}
name|flags
operator|=
name|MSG_DONTROUTE
expr_stmt|;
break|break;
case|case
name|OUT_MULTICAST
case|:
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|msg
operator|=
literal|"Send pt-to-pt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_DUP
condition|)
block|{
name|trace_act
argument_list|(
literal|"abort multicast output via %s"
literal|" with duplicate address\n"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|msg
operator|=
literal|"Send mcast"
expr_stmt|;
if|if
condition|(
name|rip_sock_mcast
operator|!=
name|ifp
condition|)
block|{
ifdef|#
directive|ifdef
name|MCAST_PPP_BUG
comment|/* Do not specifiy the primary interface 				 * explicitly if we have the multicast 				 * point-to-point kernel bug, since the 				 * kernel will do the wrong thing if the 				 * local address of a point-to-point link 				 * is the same as the address of an ordinary 				 * interface. 				 */
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|myaddr
condition|)
block|{
name|tgt_mcast
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tgt_mcast
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|setsockopt
argument_list|(
name|rip_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|&
name|tgt_mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|tgt_mcast
argument_list|)
argument_list|)
condition|)
block|{
name|serrno
operator|=
name|errno
expr_stmt|;
name|LOGERR
argument_list|(
literal|"setsockopt(rip_sock,"
literal|"IP_MULTICAST_IF)"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
name|ifp
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rip_sock_mcast
operator|=
name|ifp
expr_stmt|;
block|}
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_RIP_GROUP
argument_list|)
expr_stmt|;
block|}
block|}
name|trace_rip
argument_list|(
name|msg
argument_list|,
literal|"to"
argument_list|,
operator|&
name|sin
argument_list|,
name|ifp
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|res
operator|=
name|sendto
argument_list|(
name|soc
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
operator|(
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|)
condition|)
block|{
name|serrno
operator|=
name|errno
expr_stmt|;
name|msglog
argument_list|(
literal|"%s sendto(%s%s%s.%d): %s"
argument_list|,
name|msg
argument_list|,
name|ifp
operator|!=
literal|0
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|""
argument_list|,
name|ifp
operator|!=
literal|0
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* install authentication if appropriate  */
end_comment

begin_function
specifier|static
name|void
name|set_auth
parameter_list|(
name|struct
name|ws_buf
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
name|ws
operator|.
name|ifp
operator|!=
literal|0
operator|&&
name|ws
operator|.
name|ifp
operator|->
name|int_passwd
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_SAFE
operator|)
condition|)
block|{
name|w
operator|->
name|n
operator|->
name|n_family
operator|=
name|RIP_AF_AUTH
expr_stmt|;
operator|(
operator|(
expr|struct
name|netauth
operator|*
operator|)
name|w
operator|->
name|n
operator|)
operator|->
name|a_type
operator|=
name|RIP_AUTH_PW
expr_stmt|;
name|bcopy
argument_list|(
name|ws
operator|.
name|ifp
operator|->
name|int_passwd
argument_list|,
operator|(
operator|(
expr|struct
name|netauth
operator|*
operator|)
name|w
operator|->
name|n
operator|)
operator|->
name|au
operator|.
name|au_pw
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|netauth
operator|*
operator|)
name|w
operator|->
name|n
operator|)
operator|->
name|au
operator|.
name|au_pw
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|n
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Send the buffer  */
end_comment

begin_function
specifier|static
name|void
name|supply_write
parameter_list|(
name|struct
name|ws_buf
modifier|*
name|wb
parameter_list|)
block|{
comment|/* Output multicast only if legal. 	 * If we would multcast and it would be illegal, then discard the 	 * packet. 	 */
switch|switch
condition|(
name|wb
operator|->
name|type
condition|)
block|{
case|case
name|NO_OUT_MULTICAST
case|:
name|trace_pkt
argument_list|(
literal|"skip multicast to %s because impossible\n"
argument_list|,
name|naddr_ntoa
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_OUT_RIPV2
case|:
break|break;
default|default:
if|if
condition|(
name|output
argument_list|(
name|wb
operator|->
name|type
argument_list|,
operator|&
name|ws
operator|.
name|to
argument_list|,
name|ws
operator|.
name|ifp
argument_list|,
name|wb
operator|->
name|buf
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|n
operator|-
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|buf
operator|)
argument_list|)
operator|<
literal|0
operator|&&
name|ws
operator|.
name|ifp
operator|!=
literal|0
condition|)
name|if_sick
argument_list|(
name|ws
operator|.
name|ifp
argument_list|)
expr_stmt|;
name|ws
operator|.
name|npackets
operator|++
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|wb
operator|->
name|n
operator|=
name|wb
operator|->
name|base
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wb
operator|->
name|n
argument_list|)
operator|*
name|NETS_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb
operator|->
name|buf
operator|->
name|rip_vers
operator|==
name|RIPv2
condition|)
name|set_auth
argument_list|(
name|wb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put an entry into the packet  */
end_comment

begin_function
specifier|static
name|void
name|supply_out
parameter_list|(
name|struct
name|ag_info
modifier|*
name|ag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|naddr
name|mask
decl_stmt|,
name|v1_mask
decl_stmt|,
name|s_mask
decl_stmt|,
name|dst_h
decl_stmt|,
name|ddst_h
decl_stmt|;
name|struct
name|ws_buf
modifier|*
name|wb
decl_stmt|;
comment|/* Skip this route if doing a flash update and it and the routes 	 * it aggregates have not changed recently. 	 */
if|if
condition|(
name|ag
operator|->
name|ag_seqno
operator|<
name|update_seqno
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_FLASH
operator|)
condition|)
return|return;
comment|/* Skip this route if required by split-horizon 	 */
if|if
condition|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_SPLIT_HZ
condition|)
return|return;
name|dst_h
operator|=
name|ag
operator|->
name|ag_dst_h
expr_stmt|;
name|mask
operator|=
name|ag
operator|->
name|ag_mask
expr_stmt|;
name|v1_mask
operator|=
name|ripv1_mask_host
argument_list|(
name|htonl
argument_list|(
name|dst_h
argument_list|)
argument_list|,
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_TO_ON_NET
operator|)
condition|?
name|ws
operator|.
name|ifp
else|:
literal|0
argument_list|)
expr_stmt|;
name|s_mask
operator|=
name|std_mask
argument_list|(
name|htonl
argument_list|(
name|dst_h
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If we are sending RIPv2 packets that cannot (or must not) be 	 * heard by RIPv1 listeners, do not worry about sub- or supernets. 	 * Subnets (from other networks) can only be sent via multicast. 	 * A pair of subnet routes might have been promoted so that they 	 * are legal to send by RIPv1. 	 * If RIPv1 is off, use the multicast buffer, unless this is the 	 * fake default route and it is acting as a poor-man's router- 	 * discovery mechanism. 	 */
if|if
condition|(
operator|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|&&
operator|(
name|dst_h
operator|!=
name|RIP_DEFAULT
operator|||
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_PM_RDISC
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_RIPV2
operator|)
operator|&&
name|v1_mask
operator|!=
name|mask
operator|)
condition|)
block|{
comment|/* use the RIPv2-only buffer */
name|wb
operator|=
operator|&
name|ws
operator|.
name|v2
expr_stmt|;
block|}
else|else
block|{
comment|/* use the RIPv1-or-RIPv2 buffer */
name|wb
operator|=
operator|&
name|ws
operator|.
name|v12
expr_stmt|;
comment|/* Convert supernet route into corresponding set of network 		 * routes for RIPv1, but leave non-contiguous netmasks 		 * to ag_check(). 		 */
if|if
condition|(
name|v1_mask
operator|>
name|mask
operator|&&
name|mask
operator|+
operator|(
name|mask
operator|&
operator|-
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|ddst_h
operator|=
name|v1_mask
operator|&
operator|-
name|v1_mask
expr_stmt|;
name|i
operator|=
operator|(
name|v1_mask
operator|&
operator|~
name|mask
operator|)
operator|/
name|ddst_h
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|1024
condition|)
block|{
comment|/* Punt if we would have to generate an 				 * unreasonable number of routes. 				 */
ifdef|#
directive|ifdef
name|DEBUG
name|msglog
argument_list|(
literal|"sending %s to %s as-is instead"
literal|" of as %d routes"
argument_list|,
name|addrname
argument_list|(
name|htonl
argument_list|(
name|dst_h
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|v1_mask
expr_stmt|;
block|}
block|}
block|}
do|do
block|{
name|wb
operator|->
name|n
operator|->
name|n_family
operator|=
name|RIP_AF_INET
expr_stmt|;
name|wb
operator|->
name|n
operator|->
name|n_dst
operator|=
name|htonl
argument_list|(
name|dst_h
argument_list|)
expr_stmt|;
comment|/* If the route is from router-discovery or we are 		 * shutting down, admit only a bad metric. 		 */
name|wb
operator|->
name|n
operator|->
name|n_metric
operator|=
operator|(
operator|(
name|stopint
operator|||
name|ag
operator|->
name|ag_metric
operator|<
literal|1
operator|)
condition|?
name|HOPCNT_INFINITY
else|:
name|ag
operator|->
name|ag_metric
operator|)
expr_stmt|;
name|HTONL
argument_list|(
name|wb
operator|->
name|n
operator|->
name|n_metric
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb
operator|->
name|buf
operator|->
name|rip_vers
operator|==
name|RIPv2
condition|)
block|{
if|if
condition|(
name|ag
operator|->
name|ag_nhop
operator|!=
literal|0
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_SAFE
operator|)
operator|&&
operator|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|||
operator|(
name|ag
operator|->
name|ag_nhop
operator|!=
name|ws
operator|.
name|ifp
operator|->
name|int_addr
operator|&&
name|on_net
argument_list|(
name|ag
operator|->
name|ag_nhop
argument_list|,
name|ws
operator|.
name|ifp
operator|->
name|int_net
argument_list|,
name|ws
operator|.
name|ifp
operator|->
name|int_mask
argument_list|)
operator|)
operator|)
condition|)
name|wb
operator|->
name|n
operator|->
name|n_nhop
operator|=
name|ag
operator|->
name|ag_nhop
expr_stmt|;
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|||
name|mask
operator|!=
name|s_mask
condition|)
name|wb
operator|->
name|n
operator|->
name|n_mask
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|wb
operator|->
name|n
operator|->
name|n_tag
operator|=
name|ag
operator|->
name|ag_tag
expr_stmt|;
block|}
name|dst_h
operator|+=
name|ddst_h
expr_stmt|;
if|if
condition|(
operator|++
name|wb
operator|->
name|n
operator|>=
name|wb
operator|->
name|lim
condition|)
name|supply_write
argument_list|(
name|wb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* supply one route from the table  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|walk_supply
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|,
name|struct
name|walkarg
modifier|*
name|w
parameter_list|)
block|{
define|#
directive|define
name|RT
value|((struct rt_entry *)rn)
name|u_short
name|ags
init|=
literal|0
decl_stmt|;
name|char
name|metric
decl_stmt|,
name|pref
decl_stmt|;
name|naddr
name|dst
decl_stmt|,
name|nhop
decl_stmt|;
comment|/* Do not advertise the loopback interface 	 * or external remote interfaces 	 */
if|if
condition|(
name|RT
operator|->
name|rt_ifp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|RT
operator|->
name|rt_ifp
operator|->
name|int_if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
operator|(
name|RT
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_EXTERNAL
operator|)
operator|)
operator|&&
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_MHOME
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If being quiet about our ability to forward, then 	 * do not say anything unless responding to a query. 	 */
if|if
condition|(
operator|!
name|supplier
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
condition|)
return|return
literal|0
return|;
name|dst
operator|=
name|RT
operator|->
name|rt_dst
expr_stmt|;
comment|/* do not collide with the fake default route */
if|if
condition|(
name|dst
operator|==
name|RIP_DEFAULT
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_DEFAULT
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
condition|)
block|{
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_NET_INT
condition|)
block|{
comment|/* Do not send manual synthetic network routes 			 * into the subnet. 			 */
if|if
condition|(
name|on_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Do not send automatic synthetic network routes 			 * if they are not needed becaus no RIPv1 listeners 			 * can hear them. 			 */
if|if
condition|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
condition|)
return|return
literal|0
return|;
comment|/* Do not send automatic synthetic network routes to 			 * the real subnet. 			 */
if|if
condition|(
name|on_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|nhop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Advertise the next hop if this is not a route for one 		 * of our interfaces and the next hop is on the same 		 * network as the target. 		 */
if|if
condition|(
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_IF
operator|)
operator|&&
name|RT
operator|->
name|rt_gate
operator|!=
name|myaddr
operator|&&
name|RT
operator|->
name|rt_gate
operator|!=
name|loopaddr
condition|)
name|nhop
operator|=
name|RT
operator|->
name|rt_gate
expr_stmt|;
else|else
name|nhop
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Adjust the outgoing metric by the cost of the link. 	 */
name|pref
operator|=
name|metric
operator|=
name|RT
operator|->
name|rt_metric
operator|+
name|ws
operator|.
name|metric
expr_stmt|;
if|if
condition|(
name|pref
operator|<
name|HOPCNT_INFINITY
condition|)
block|{
comment|/* Keep track of the best metric with which the 		 * route has been advertised recently. 		 */
if|if
condition|(
name|RT
operator|->
name|rt_poison_metric
operator|>=
name|metric
operator|||
name|RT
operator|->
name|rt_poison_time
operator|<=
name|now_garbage
condition|)
block|{
name|RT
operator|->
name|rt_poison_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|RT
operator|->
name|rt_poison_metric
operator|=
name|RT
operator|->
name|rt_metric
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Do not advertise stable routes that will be ignored, 		 * unless they are being held down and poisoned.  If the 		 * route recently was advertised with a metric that would 		 * have been less than infinity through this interface, we 		 * need to continue to advertise it in order to poison it. 		 */
name|pref
operator|=
name|RT
operator|->
name|rt_poison_metric
operator|+
name|ws
operator|.
name|metric
expr_stmt|;
if|if
condition|(
name|pref
operator|>=
name|HOPCNT_INFINITY
condition|)
return|return
literal|0
return|;
name|metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
block|}
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_MHOME
condition|)
block|{
comment|/* retain host route of multi-homed servers */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|RT_ISHOST
argument_list|(
name|RT
argument_list|)
condition|)
block|{
comment|/* We should always aggregate the host routes 		 * for the local end of our point-to-point links. 		 * If we are suppressing host routes in general, then do so. 		 * Avoid advertising host routes onto their own network, 		 * where they should be handled by proxy-ARP. 		 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_LOCAL
operator|)
operator|||
name|ridhosts
operator|||
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_SUPER_AG
operator|)
operator|||
name|on_net
argument_list|(
name|dst
argument_list|,
name|ws
operator|.
name|to_net
argument_list|,
name|ws
operator|.
name|to_mask
argument_list|)
condition|)
name|ags
operator||=
name|AGS_SUPPRESS
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_SUPER_AG
condition|)
name|ags
operator||=
name|AGS_PROMOTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_AG
condition|)
block|{
comment|/* Aggregate network routes, if we are allowed. 		 */
name|ags
operator||=
name|AGS_SUPPRESS
expr_stmt|;
comment|/* Generate supernets if allowed. 		 * If we can be heard by RIPv1 systems, we will 		 * later convert back to ordinary nets. 		 * This unifies dealing with received supernets. 		 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_SUBNET
operator|)
operator|||
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_SUPER_AG
operator|)
condition|)
name|ags
operator||=
name|AGS_PROMOTE
expr_stmt|;
block|}
comment|/* Do not send RIPv1 advertisements of subnets to other 	 * networks. If possible, multicast them by RIPv2. 	 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_SUBNET
operator|)
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|&&
operator|!
name|on_net
argument_list|(
name|dst
argument_list|,
name|ws
operator|.
name|to_std_net
argument_list|,
name|ws
operator|.
name|to_std_mask
argument_list|)
condition|)
block|{
name|ags
operator||=
name|AGS_RIPV2
operator||
name|AGS_PROMOTE
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_SUB_AG
condition|)
name|ags
operator||=
name|AGS_SUPPRESS
expr_stmt|;
block|}
comment|/* Do not send a route back to where it came from, except in 	 * response to a query.  This is "split-horizon".  That means not 	 * advertising back to the same network	and so via the same interface. 	 * 	 * We want to suppress routes that might have been fragmented 	 * from this route by a RIPv1 router and sent back to us, and so we 	 * cannot forget this route here.  Let the split-horizon route 	 * aggregate (suppress) the fragmented routes and then itself be 	 * forgotten. 	 * 	 * Include the routes for both ends of point-to-point interfaces 	 * since the other side presumably knows them as well as we do. 	 */
if|if
condition|(
name|RT
operator|->
name|rt_ifp
operator|==
name|ws
operator|.
name|ifp
operator|&&
name|ws
operator|.
name|ifp
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_TO_ON_NET
operator|)
operator|&&
operator|(
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_IF
operator|)
operator|||
name|ws
operator|.
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
name|ags
operator||=
name|AGS_SPLIT_HZ
expr_stmt|;
name|ags
operator|&=
operator|~
operator|(
name|AGS_PROMOTE
operator||
name|AGS_SUPPRESS
operator|)
expr_stmt|;
block|}
name|ag_check
argument_list|(
name|dst
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|,
literal|0
argument_list|,
name|nhop
argument_list|,
name|metric
argument_list|,
name|pref
argument_list|,
name|RT
operator|->
name|rt_seqno
argument_list|,
name|RT
operator|->
name|rt_tag
argument_list|,
name|ags
argument_list|,
name|supply_out
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|RT
block|}
end_function

begin_comment
comment|/* Supply dst with the contents of the routing tables.  * If this won't fit in one packet, chop it up into several.  */
end_comment

begin_function
name|void
name|supply
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|dst
parameter_list|,
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
comment|/* output interface */
name|enum
name|output_type
name|type
parameter_list|,
name|int
name|flash
parameter_list|,
comment|/* 1=flash update */
name|int
name|vers
parameter_list|)
comment|/* RIP version */
block|{
specifier|static
name|int
name|init
init|=
literal|1
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|ws
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|ws
operator|.
name|to
operator|=
operator|*
name|dst
expr_stmt|;
name|ws
operator|.
name|to_std_mask
operator|=
name|std_mask
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ws
operator|.
name|to_std_net
operator|=
name|ntohl
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
name|ws
operator|.
name|to_std_mask
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
name|ws
operator|.
name|to_mask
operator|=
name|ifp
operator|->
name|int_mask
expr_stmt|;
name|ws
operator|.
name|to_net
operator|=
name|ifp
operator|->
name|int_net
expr_stmt|;
if|if
condition|(
name|on_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ws
operator|.
name|to_net
argument_list|,
name|ws
operator|.
name|to_mask
argument_list|)
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_TO_ON_NET
expr_stmt|;
block|}
else|else
block|{
name|ws
operator|.
name|to_mask
operator|=
name|ripv1_mask_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ws
operator|.
name|to_net
operator|=
name|ntohl
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
name|ws
operator|.
name|to_mask
expr_stmt|;
name|rt
operator|=
name|rtfind
argument_list|(
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
condition|)
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
block|}
name|ws
operator|.
name|npackets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flash
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_FLASH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OUT_QUERY
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_QUERY
expr_stmt|;
if|if
condition|(
operator|(
name|ws
operator|.
name|ifp
operator|=
name|ifp
operator|)
operator|==
literal|0
condition|)
block|{
name|ws
operator|.
name|metric
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the advertised metric by the outgoing interface 		 * metric. 		 */
name|ws
operator|.
name|metric
operator|=
name|ifp
operator|->
name|int_metric
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
block|{
name|init
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ripv12_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ripv12_buf
argument_list|)
argument_list|)
expr_stmt|;
name|ripv12_buf
operator|.
name|rip
operator|.
name|rip_cmd
operator|=
name|RIPCMD_RESPONSE
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|buf
operator|=
operator|&
name|ripv12_buf
operator|.
name|rip
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|base
operator|=
operator|&
name|ws
operator|.
name|v12
operator|.
name|buf
operator|->
name|rip_nets
index|[
literal|0
index|]
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|lim
operator|=
name|ws
operator|.
name|v12
operator|.
name|base
operator|+
name|NETS_LEN
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rip_v2_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|rip_v2_buf
argument_list|)
argument_list|)
expr_stmt|;
name|rip_v2_buf
operator|.
name|rip
operator|.
name|rip_cmd
operator|=
name|RIPCMD_RESPONSE
expr_stmt|;
name|rip_v2_buf
operator|.
name|rip
operator|.
name|rip_vers
operator|=
name|RIPv2
expr_stmt|;
name|ws
operator|.
name|v2
operator|.
name|buf
operator|=
operator|&
name|rip_v2_buf
operator|.
name|rip
expr_stmt|;
name|ws
operator|.
name|v2
operator|.
name|base
operator|=
operator|&
name|ws
operator|.
name|v2
operator|.
name|buf
operator|->
name|rip_nets
index|[
literal|0
index|]
expr_stmt|;
name|ws
operator|.
name|v2
operator|.
name|lim
operator|=
name|ws
operator|.
name|v2
operator|.
name|base
operator|+
name|NETS_LEN
expr_stmt|;
block|}
name|ripv12_buf
operator|.
name|rip
operator|.
name|rip_vers
operator|=
name|vers
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|n
operator|=
name|ws
operator|.
name|v12
operator|.
name|base
expr_stmt|;
name|set_auth
argument_list|(
operator|&
name|ws
operator|.
name|v12
argument_list|)
expr_stmt|;
name|ws
operator|.
name|v2
operator|.
name|n
operator|=
name|ws
operator|.
name|v2
operator|.
name|base
expr_stmt|;
name|set_auth
argument_list|(
operator|&
name|ws
operator|.
name|v2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OUT_BROADCAST
case|:
name|ws
operator|.
name|v2
operator|.
name|type
operator|=
operator|(
operator|(
name|ws
operator|.
name|ifp
operator|!=
literal|0
operator|&&
operator|(
name|ws
operator|.
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|)
condition|?
name|OUT_MULTICAST
else|:
name|NO_OUT_MULTICAST
operator|)
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
break|break;
case|case
name|OUT_MULTICAST
case|:
name|ws
operator|.
name|v2
operator|.
name|type
operator|=
operator|(
operator|(
name|ws
operator|.
name|ifp
operator|!=
literal|0
operator|&&
operator|(
name|ws
operator|.
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|)
condition|?
name|OUT_MULTICAST
else|:
name|NO_OUT_MULTICAST
operator|)
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
break|break;
case|case
name|OUT_UNICAST
case|:
case|case
name|OUT_QUERY
case|:
name|ws
operator|.
name|v2
operator|.
name|type
operator|=
operator|(
name|vers
operator|==
name|RIPv2
operator|)
condition|?
name|type
else|:
name|NO_OUT_RIPV2
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|type
operator|=
name|type
expr_stmt|;
break|break;
default|default:
name|ws
operator|.
name|v2
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|ws
operator|.
name|v12
operator|.
name|type
operator|=
name|type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vers
operator|==
name|RIPv2
condition|)
block|{
comment|/* if asked to send RIPv2, send at least that which can 		 * be safely heard by RIPv1 listeners. 		 */
name|ws
operator|.
name|state
operator||=
name|WS_ST_RIP2_SAFE
expr_stmt|;
comment|/* full RIPv2 only if cannot be heard by RIPv1 listeners */
if|if
condition|(
name|type
operator|!=
name|OUT_BROADCAST
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_RIP2_ALL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_TO_ON_NET
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
operator|(
name|WS_ST_AG
operator||
name|WS_ST_SUPER_AG
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ws
operator|.
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ws
operator|.
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_AG
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
name|WS_ST_AG
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OUT_BROADCAST
operator|&&
operator|(
name|ws
operator|.
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ws
operator|.
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_SUPER_AG
operator|)
operator|)
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_SUPER_AG
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ws
operator|.
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ws
operator|.
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_AG
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
name|WS_ST_SUB_AG
expr_stmt|;
block|}
if|if
condition|(
name|supplier
condition|)
block|{
comment|/*  Fake a default route if asked, and if there is not 		 * a better, real default route. 		 */
if|if
condition|(
name|ifp
operator|->
name|int_d_metric
operator|!=
literal|0
operator|&&
operator|(
literal|0
operator|==
operator|(
name|rt
operator|=
name|rtget
argument_list|(
name|RIP_DEFAULT
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|rt
operator|->
name|rt_metric
operator|+
name|ws
operator|.
name|metric
operator|>=
name|ifp
operator|->
name|int_d_metric
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
name|WS_ST_DEFAULT
expr_stmt|;
name|ag_check
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ifp
operator|->
name|int_d_metric
argument_list|,
name|ifp
operator|->
name|int_d_metric
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|supply_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_PM_RDISC
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
name|WS_ST_PM_RDISC
expr_stmt|;
name|ripv12_buf
operator|.
name|rip
operator|.
name|rip_vers
operator|=
name|RIPv1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_supply
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ag_flush
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|supply_out
argument_list|)
expr_stmt|;
comment|/* Flush the packet buffers, provided they are not empty and 	 * do not contain only the password. 	 */
if|if
condition|(
name|ws
operator|.
name|v12
operator|.
name|n
operator|!=
name|ws
operator|.
name|v12
operator|.
name|base
operator|&&
operator|(
name|ws
operator|.
name|v12
operator|.
name|n
operator|>
name|ws
operator|.
name|v12
operator|.
name|base
operator|+
literal|1
operator|||
name|ws
operator|.
name|v12
operator|.
name|n
operator|->
name|n_family
operator|!=
name|RIP_AF_AUTH
operator|)
condition|)
name|supply_write
argument_list|(
operator|&
name|ws
operator|.
name|v12
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|v2
operator|.
name|n
operator|!=
name|ws
operator|.
name|v2
operator|.
name|base
operator|&&
operator|(
name|ws
operator|.
name|v2
operator|.
name|n
operator|>
name|ws
operator|.
name|v2
operator|.
name|base
operator|+
literal|1
operator|||
name|ws
operator|.
name|v2
operator|.
name|n
operator|->
name|n_family
operator|!=
name|RIP_AF_AUTH
operator|)
condition|)
name|supply_write
argument_list|(
operator|&
name|ws
operator|.
name|v2
argument_list|)
expr_stmt|;
comment|/* If we sent nothing and this is an answer to a query, send 	 * an empty buffer. 	 */
if|if
condition|(
name|ws
operator|.
name|npackets
operator|==
literal|0
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
condition|)
name|supply_write
argument_list|(
operator|&
name|ws
operator|.
name|v12
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send all of the routing table or just do a flash update  */
end_comment

begin_function
name|void
name|rip_bcast
parameter_list|(
name|int
name|flash
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
endif|#
directive|endif
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|enum
name|output_type
name|type
decl_stmt|;
name|int
name|vers
decl_stmt|;
name|struct
name|timeval
name|rtime
decl_stmt|;
name|need_flash
operator|=
literal|0
expr_stmt|;
name|intvl_random
argument_list|(
operator|&
name|rtime
argument_list|,
name|MIN_WAITTIME
argument_list|,
name|MAX_WAITTIME
argument_list|)
expr_stmt|;
name|no_flash
operator|=
name|rtime
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|no_flash
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|rip_sock
operator|<
literal|0
condition|)
return|return;
name|trace_act
argument_list|(
literal|"send %s and inhibit dynamic updates for %.3f sec\n"
argument_list|,
name|flash
condition|?
literal|"dynamic update"
else|:
literal|"all routes"
argument_list|,
name|rtime
operator|.
name|tv_sec
operator|+
operator|(
operator|(
name|float
operator|)
name|rtime
operator|.
name|tv_usec
operator|)
operator|/
literal|1000000.0
argument_list|)
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* skip interfaces not doing RIP, those already queried, 		 * and aliases.  Do try broken interfaces to see 		 * if they have healed. 		 */
if|if
condition|(
literal|0
operator|!=
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_PASSIVE
operator||
name|IS_ALIAS
operator|)
operator|)
condition|)
continue|continue;
comment|/* skip turned off interfaces */
if|if
condition|(
operator|!
name|iff_alive
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
continue|continue;
comment|/* default to RIPv1 output */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
condition|)
block|{
comment|/* Say nothing if this interface is turned off */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV2_OUT
condition|)
continue|continue;
name|vers
operator|=
name|RIPv2
expr_stmt|;
block|}
else|else
block|{
name|vers
operator|=
name|RIPv1
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
comment|/* ordinary, hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_brdaddr
expr_stmt|;
comment|/* if RIPv1 is not turned off, then broadcast so 			 * that RIPv1 listeners can hear. 			 */
if|if
condition|(
name|vers
operator|==
name|RIPv2
operator|&&
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
condition|)
block|{
name|type
operator|=
name|OUT_MULTICAST
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
comment|/* point-to-point hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_dstaddr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
else|else
block|{
comment|/* remote interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
name|supply
argument_list|(
operator|&
name|dst
argument_list|,
name|ifp
argument_list|,
name|type
argument_list|,
name|flash
argument_list|,
name|vers
argument_list|)
expr_stmt|;
block|}
name|update_seqno
operator|++
expr_stmt|;
comment|/* all routes are up to date */
block|}
end_function

begin_comment
comment|/* Ask for routes  * Do it only once to an interface, and not even after the interface  * was broken and recovered.  */
end_comment

begin_function
name|void
name|rip_query
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
endif|#
directive|endif
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|rip
name|buf
decl_stmt|;
name|enum
name|output_type
name|type
decl_stmt|;
if|if
condition|(
name|rip_sock
operator|<
literal|0
condition|)
return|return;
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* skip interfaces not doing RIP, those already queried, 		 * and aliases.  Do try broken interfaces to see 		 * if they have healed. 		 */
if|if
condition|(
literal|0
operator|!=
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_RIP_QUERIED
operator||
name|IS_PASSIVE
operator||
name|IS_ALIAS
operator|)
operator|)
condition|)
continue|continue;
comment|/* skip turned off interfaces */
if|if
condition|(
operator|!
name|iff_alive
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
continue|continue;
comment|/* default to RIPv1 output */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV2_OUT
condition|)
block|{
comment|/* Say nothing if this interface is turned off */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
condition|)
continue|continue;
name|buf
operator|.
name|rip_vers
operator|=
name|RIPv1
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|rip_vers
operator|=
name|RIPv2
expr_stmt|;
block|}
name|buf
operator|.
name|rip_cmd
operator|=
name|RIPCMD_REQUEST
expr_stmt|;
name|buf
operator|.
name|rip_nets
index|[
literal|0
index|]
operator|.
name|n_family
operator|=
name|RIP_AF_UNSPEC
expr_stmt|;
name|buf
operator|.
name|rip_nets
index|[
literal|0
index|]
operator|.
name|n_metric
operator|=
name|htonl
argument_list|(
name|HOPCNT_INFINITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
comment|/* ordinary, hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_brdaddr
expr_stmt|;
comment|/* if RIPv1 is not turned off, then broadcast so 			 * that RIPv1 listeners can hear. 			 */
if|if
condition|(
name|buf
operator|.
name|rip_vers
operator|==
name|RIPv2
operator|&&
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
condition|)
block|{
name|type
operator|=
name|OUT_MULTICAST
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
comment|/* point-to-point hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_dstaddr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
else|else
block|{
comment|/* remote interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
name|ifp
operator|->
name|int_state
operator||=
name|IS_RIP_QUERIED
expr_stmt|;
if|if
condition|(
name|output
argument_list|(
name|type
argument_list|,
operator|&
name|dst
argument_list|,
name|ifp
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|if_sick
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

