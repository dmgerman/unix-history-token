begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)if.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#ident "$Revision: 1.1.3.3 $"
end_empty

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
name|struct
name|interface
modifier|*
name|ifnet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* all interfaces */
end_comment

begin_decl_stmt
name|int
name|tot_interfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of remote and local interfaces */
end_comment

begin_decl_stmt
name|int
name|rip_interfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of interfaces doing RIP */
end_comment

begin_decl_stmt
name|int
name|foundloopback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid flag for loopaddr */
end_comment

begin_decl_stmt
name|naddr
name|loopaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our address on loopback */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|ifinit_timer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|have_ripv1_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* have a RIPv1 interface */
end_comment

begin_decl_stmt
name|int
name|have_ripv1_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the interface with an address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|ifwithaddr
parameter_list|(
name|naddr
name|addr
parameter_list|,
name|int
name|bcast
parameter_list|,
comment|/* notice IFF_BROADCAST address */
name|int
name|remote
parameter_list|)
comment|/* include IS_REMOTE interfaces */
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|possible
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|addr
operator|||
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|&&
name|ifp
operator|->
name|int_brdaddr
operator|==
name|addr
operator|&&
name|bcast
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
operator|&&
operator|!
name|remote
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_PASSIVE
operator|)
condition|)
return|return
name|ifp
return|;
name|possible
operator|=
name|ifp
expr_stmt|;
block|}
block|}
return|return
name|possible
return|;
block|}
end_function

begin_comment
comment|/* find the interface with a name  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|ifwithname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* "ec0" or whatever */
name|naddr
name|addr
parameter_list|)
comment|/* 0 or network address */
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|name
argument_list|)
operator|&&
operator|(
name|ifp
operator|->
name|int_addr
operator|==
name|addr
operator|||
operator|(
name|addr
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
operator|)
operator|)
condition|)
return|return
name|ifp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|interface
modifier|*
name|ifwithindex
parameter_list|(
name|u_short
name|index
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_index
operator|==
name|index
condition|)
return|return
name|ifp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find an interface from which the specified address  * should have come from.  Used for figuring out which  * interface a packet came in on -- for tracing.  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|iflookup
parameter_list|(
name|naddr
name|addr
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|maybe
decl_stmt|;
name|maybe
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_dstaddr
operator|==
name|addr
condition|)
comment|/* finished with a match */
return|return
name|ifp
return|;
block|}
else|else
block|{
comment|/* finished with an exact match */
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|addr
condition|)
return|return
name|ifp
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|&&
name|ifp
operator|->
name|int_brdaddr
operator|==
name|addr
condition|)
return|return
name|ifp
return|;
comment|/* Look for the longest approximate match. 			 */
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
operator|&&
operator|(
name|maybe
operator|==
literal|0
operator|||
name|ifp
operator|->
name|int_mask
operator|>
name|maybe
operator|->
name|int_mask
operator|)
condition|)
name|maybe
operator|=
name|ifp
expr_stmt|;
block|}
block|}
return|return
name|maybe
return|;
block|}
end_function

begin_comment
comment|/* Return the classical netmask for an IP address.  */
end_comment

begin_function
name|naddr
name|std_mask
parameter_list|(
name|naddr
name|addr
parameter_list|)
comment|/* in network order */
block|{
name|NTOHL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* was a host, not a network */
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
comment|/* default route has mask 0 */
return|return
literal|0
return|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSA_NET
return|;
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSB_NET
return|;
return|return
name|IN_CLASSC_NET
return|;
block|}
end_function

begin_comment
comment|/* Find the netmask that would be inferred by RIPv1 listeners  *	on the given interface for a given network.  *	If no interface is specified, look for the best fitting	interface.  */
end_comment

begin_function
name|naddr
name|ripv1_mask_net
parameter_list|(
name|naddr
name|addr
parameter_list|,
comment|/* in network byte order */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
comment|/* as seen on this interface */
block|{
name|naddr
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
comment|/* default always has 0 mask */
return|return
name|mask
return|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
comment|/* If the target network is that of the associated interface 		 * on which it arrived, then use the netmask of the interface. 		 */
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
condition|)
name|mask
operator|=
name|ifp
operator|->
name|int_ripv1_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* Examine all interfaces, and if it the target seems 		 * to have the same network number of an interface, use the 		 * netmask of that interface.  If there is more than one 		 * such interface, prefer the interface with the longest 		 * match. 		 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|int_std_net
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
operator|&&
name|ifp
operator|->
name|int_ripv1_mask
operator|>
name|mask
condition|)
name|mask
operator|=
name|ifp
operator|->
name|int_ripv1_mask
expr_stmt|;
block|}
block|}
comment|/* Otherwise, make the classic A/B/C guess. 	 */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|mask
operator|=
name|std_mask
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_function
name|naddr
name|ripv1_mask_host
parameter_list|(
name|naddr
name|addr
parameter_list|,
comment|/* in network byte order */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
comment|/* as seen on this interface */
block|{
name|naddr
name|mask
init|=
name|ripv1_mask_net
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
decl_stmt|;
comment|/* If the computed netmask does not mask the address, 	 * then assume it is a host address 	 */
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|addr
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
condition|)
name|mask
operator|=
name|HOST_MASK
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* See if a IP address looks reasonable as a destination  */
end_comment

begin_function
name|int
comment|/* 0=bad */
name|check_dst
parameter_list|(
name|naddr
name|addr
parameter_list|)
block|{
name|NTOHL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* default */
name|addr
operator|>>=
name|IN_CLASSA_NSHIFT
expr_stmt|;
return|return
operator|(
name|addr
operator|!=
literal|0
operator|&&
name|addr
operator|!=
name|IN_LOOPBACKNET
operator|)
return|;
block|}
return|return
operator|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
operator|||
name|IN_CLASSC
argument_list|(
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete an interface.  */
end_comment

begin_function
specifier|static
name|void
name|ifdel
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ip_mreq
name|m
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
name|trace_if
argument_list|(
literal|"Del"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator||=
name|IS_BROKE
expr_stmt|;
comment|/* unlink the interface 	 */
if|if
condition|(
name|rip_sock_mcast
operator|==
name|ifp
condition|)
name|rip_sock_mcast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_next
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|int_next
operator|->
name|int_prev
operator|=
name|ifp
operator|->
name|int_prev
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_prev
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|int_prev
operator|->
name|int_next
operator|=
name|ifp
operator|->
name|int_next
expr_stmt|;
else|else
name|ifnet
operator|=
name|ifp
operator|->
name|int_next
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
comment|/* delete aliases 		 */
for|for
control|(
name|ifp1
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp1
condition|;
name|ifp1
operator|=
name|ifp1
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp1
operator|!=
name|ifp
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
name|ifdel
argument_list|(
name|ifp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
ifdef|#
directive|ifdef
name|MCAST_PPP_BUG
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
endif|#
directive|endif
operator|&&
name|rip_sock
operator|>=
literal|0
condition|)
block|{
name|m
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_RIP_GROUP
argument_list|)
expr_stmt|;
name|m
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
name|ifp
operator|->
name|int_dstaddr
else|:
name|ifp
operator|->
name|int_addr
operator|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rip_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EADDRNOTAVAIL
operator|&&
operator|!
name|TRACEACTIONS
condition|)
name|LOGERR
argument_list|(
literal|"setsockopt(IP_DROP_MEMBERSHIP RIP)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_rip_sock
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ifp
operator|->
name|int_rip_sock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_rip_sock
operator|=
operator|-
literal|1
expr_stmt|;
name|fix_select
argument_list|()
expr_stmt|;
block|}
name|tot_interfaces
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|IS_RIP_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
condition|)
name|rip_interfaces
operator|--
expr_stmt|;
comment|/* Zap all routes associated with this interface. 		 * Assume routes just using gateways beyond this interface will 		 * timeout naturally, and have probably already died. 		 */
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_bad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_rdisc_mg
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_bad_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark an interface ill.  */
end_comment

begin_function
name|void
name|if_sick
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_SICK
operator||
name|IS_BROKE
operator|)
operator|)
condition|)
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_SICK
expr_stmt|;
name|trace_if
argument_list|(
literal|"Chg"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark an interface dead.  */
end_comment

begin_function
name|void
name|if_bad
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
return|return;
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator||=
operator|(
name|IS_BROKE
operator||
name|IS_SICK
operator|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
operator|(
name|IS_RIP_QUERIED
operator||
name|IS_ACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|=
literal|0
expr_stmt|;
name|trace_if
argument_list|(
literal|"Chg"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
for|for
control|(
name|ifp1
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp1
condition|;
name|ifp1
operator|=
name|ifp1
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp1
operator|!=
name|ifp
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
name|if_bad
argument_list|(
name|ifp1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_bad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_bad_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark an interface alive  */
end_comment

begin_function
name|int
comment|/* 1=it was dead */
name|if_ok
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SICK
condition|)
block|{
name|trace_act
argument_list|(
literal|"%sinterface %s to %s working better\n"
argument_list|,
name|type
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
name|IS_SICK
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|msglog
argument_list|(
literal|"%sinterface %s to %s restored"
argument_list|,
name|type
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
operator|(
name|IS_BROKE
operator||
name|IS_SICK
operator|)
expr_stmt|;
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
for|for
control|(
name|ifp1
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp1
condition|;
name|ifp1
operator|=
name|ifp1
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp1
operator|!=
name|ifp
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
name|if_ok
argument_list|(
name|ifp1
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|if_ok_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* disassemble routing message  */
end_comment

begin_function
name|void
name|rt_xaddrs
parameter_list|(
name|struct
name|rt_addrinfo
modifier|*
name|info
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|lim
parameter_list|,
name|int
name|addrs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
specifier|static
name|struct
name|sockaddr
name|sa_zero
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sgi
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(__uint64_t) - 1))) \ 		    : sizeof(__uint64_t))
else|#
directive|else
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) \ 		    : sizeof(long))
endif|#
directive|endif
name|bzero
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|rti_addrs
operator|=
name|addrs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTAX_MAX
operator|&&
name|sa
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addrs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
name|info
operator|->
name|rti_info
index|[
name|i
index|]
operator|=
operator|(
name|sa
operator|->
name|sa_len
operator|!=
literal|0
operator|)
condition|?
name|sa
else|:
operator|&
name|sa_zero
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|sa
operator|)
operator|+
name|ROUNDUP
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|info
operator|->
name|rti_info
index|[
name|i
index|]
operator|=
name|sa
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|sa
operator|)
operator|+
name|ROUNDUP
argument_list|(
name|_FAKE_SA_LEN_DST
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Find the network interfaces which have configured themselves.  *	This must be done regularly, if only for extra addresses  *	that come and go on interfaces.  */
end_comment

begin_function
name|void
name|ifinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|sysctl_buf
decl_stmt|;
specifier|static
name|size_t
name|sysctl_buf_size
init|=
literal|0
decl_stmt|;
name|uint
name|complaints
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|prev_complaints
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|COMP_NOT_INET
value|0x001
define|#
directive|define
name|COMP_WIERD
value|0x002
define|#
directive|define
name|COMP_NOADDR
value|0x004
define|#
directive|define
name|COMP_NODST
value|0x008
define|#
directive|define
name|COMP_NOBADR
value|0x010
define|#
directive|define
name|COMP_NOMASK
value|0x020
define|#
directive|define
name|COMP_DUP
value|0x040
define|#
directive|define
name|COMP_BAD_METRIC
value|0x080
define|#
directive|define
name|COMP_NETMASK
value|0x100
name|struct
name|interface
name|ifs
decl_stmt|,
name|ifs0
decl_stmt|,
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|ifp1
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|,
modifier|*
name|ifam_lim
decl_stmt|,
modifier|*
name|ifam2
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|int
name|in
decl_stmt|,
name|ierr
decl_stmt|,
name|out
decl_stmt|,
name|oerr
decl_stmt|;
name|struct
name|intnet
modifier|*
name|intnetp
decl_stmt|;
name|struct
name|rt_addrinfo
name|info
decl_stmt|;
ifdef|#
directive|ifdef
name|SIOCGIFMETRIC
name|struct
name|ifreq
name|ifr
decl_stmt|;
endif|#
directive|endif
name|ifinit_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
operator|(
name|supplier
condition|?
name|CHECK_ACT_INTERVAL
else|:
name|CHECK_QUIET_INTERVAL
operator|)
expr_stmt|;
comment|/* mark all interfaces so we can get rid of thost that disappear */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
name|ifp
operator|->
name|int_state
operator|&=
operator|~
operator|(
name|IS_CHECKED
operator||
name|IS_DUP
operator|)
expr_stmt|;
comment|/* Fetch the interface list, without too many system calls 	 * since we do it repeatedly. 	 */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET
expr_stmt|;
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_IFLIST
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|needed
operator|=
name|sysctl_buf_size
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|sysctl_buf
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|ENOMEM
operator|&&
name|errno
operator|!=
name|EFAULT
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"ifinit: get interface table"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sysctl_buf
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"ifinit: route-sysctl-estimate"
argument_list|)
expr_stmt|;
name|sysctl_buf
operator|=
name|rtmalloc
argument_list|(
name|sysctl_buf_size
operator|=
name|needed
argument_list|,
literal|"ifinit"
argument_list|)
expr_stmt|;
block|}
name|ifam_lim
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
operator|(
name|sysctl_buf
operator|+
name|needed
operator|)
expr_stmt|;
for|for
control|(
name|ifam
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|sysctl_buf
init|;
name|ifam
operator|<
name|ifam_lim
condition|;
name|ifam
operator|=
name|ifam2
control|)
block|{
name|ifam2
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifam
operator|+
name|ifam
operator|->
name|ifam_msglen
operator|)
expr_stmt|;
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|==
name|RTM_IFINFO
condition|)
block|{
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|ifam
expr_stmt|;
comment|/* make prototype structure for the IP aliases 			 */
name|bzero
argument_list|(
operator|&
name|ifs0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifs0
argument_list|)
argument_list|)
expr_stmt|;
name|ifs0
operator|.
name|int_rip_sock
operator|=
operator|-
literal|1
expr_stmt|;
name|ifs0
operator|.
name|int_index
operator|=
name|ifm
operator|->
name|ifm_index
expr_stmt|;
name|ifs0
operator|.
name|int_if_flags
operator|=
name|ifm
operator|->
name|ifm_flags
expr_stmt|;
name|ifs0
operator|.
name|int_state
operator|=
name|IS_CHECKED
expr_stmt|;
name|ifs0
operator|.
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|ts
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|ipackets
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_ipackets
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|ierrors
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_ierrors
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|opackets
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_opackets
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|oerrors
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_oerrors
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
name|ifs0
operator|.
name|int_data
operator|.
name|odrops
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_odrops
expr_stmt|;
endif|#
directive|endif
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|ifm
operator|+
literal|1
operator|)
expr_stmt|;
name|sdl
operator|->
name|sdl_data
index|[
name|sdl
operator|->
name|sdl_nlen
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|!=
name|RTM_NEWADDR
condition|)
block|{
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"ifinit: out of sync"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rt_xaddrs
argument_list|(
operator|&
name|info
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ifam2
argument_list|,
name|ifam
operator|->
name|ifam_addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_IFA
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOADDR
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has a bad address"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOADDR
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|INFO_IFA
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOT_INET
operator|)
condition|)
name|trace_act
argument_list|(
literal|"%s: not AF_INET\n"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOT_INET
expr_stmt|;
block|}
continue|continue;
block|}
name|bcopy
argument_list|(
operator|&
name|ifs0
argument_list|,
operator|&
name|ifs
argument_list|,
sizeof|sizeof
argument_list|(
name|ifs0
argument_list|)
argument_list|)
expr_stmt|;
name|ifs0
operator|.
name|int_state
operator||=
name|IS_ALIAS
expr_stmt|;
comment|/* next will be an alias */
name|ifs
operator|.
name|int_addr
operator|=
name|S_ADDR
argument_list|(
name|INFO_IFA
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
if|if
condition|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOMASK
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has no netmask"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOMASK
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_dstaddr
operator|=
name|ifs
operator|.
name|int_addr
expr_stmt|;
name|ifs
operator|.
name|int_mask
operator|=
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_ripv1_mask
operator|=
name|ifs
operator|.
name|int_mask
expr_stmt|;
name|ifs
operator|.
name|int_net
operator|=
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|)
operator|&
name|ifs
operator|.
name|int_mask
expr_stmt|;
name|ifs
operator|.
name|int_std_mask
operator|=
name|std_mask
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|.
name|int_mask
operator|!=
name|ifs
operator|.
name|int_std_mask
condition|)
name|ifs
operator|.
name|int_state
operator||=
name|IS_SUBNET
expr_stmt|;
if|if
condition|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOBADR
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has no"
literal|" broadcast address"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOBADR
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_brdaddr
operator|=
name|S_ADDR
argument_list|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
if|if
condition|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
operator|||
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NODST
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has a bad"
literal|" destination address"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NODST
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_dstaddr
operator|=
name|S_ADDR
argument_list|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_mask
operator|=
name|HOST_MASK
expr_stmt|;
name|ifs
operator|.
name|int_ripv1_mask
operator|=
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_net
operator|=
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_std_mask
operator|=
name|std_mask
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|ifs
operator|.
name|int_state
operator||=
name|IS_PASSIVE
operator||
name|IS_NO_RIP
expr_stmt|;
name|ifs
operator|.
name|int_dstaddr
operator|=
name|ifs
operator|.
name|int_addr
expr_stmt|;
name|ifs
operator|.
name|int_mask
operator|=
name|HOST_MASK
expr_stmt|;
name|ifs
operator|.
name|int_ripv1_mask
operator|=
name|HOST_MASK
expr_stmt|;
name|ifs
operator|.
name|int_net
operator|=
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_std_mask
operator|=
name|std_mask
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundloopback
condition|)
block|{
name|foundloopback
operator|=
literal|1
expr_stmt|;
name|loopaddr
operator|=
name|ifs
operator|.
name|int_addr
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_WIERD
operator|)
condition|)
name|trace_act
argument_list|(
literal|"%s is neither broadcast"
literal|" nor point-to-point nor loopback"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_WIERD
expr_stmt|;
continue|continue;
block|}
name|ifs
operator|.
name|int_std_net
operator|=
name|ifs
operator|.
name|int_net
operator|&
name|ifs
operator|.
name|int_std_mask
expr_stmt|;
name|ifs
operator|.
name|int_std_addr
operator|=
name|htonl
argument_list|(
name|ifs
operator|.
name|int_std_net
argument_list|)
expr_stmt|;
comment|/* Use a minimum metric of one.  Treat the interface metric 		 * (default 0) as an increment to the hop count of one. 		 * 		 * The metric obtained from the routing socket dump of 		 * interface addresses is wrong.  It is not set by the 		 * SIOCSIFMETRIC ioctl. 		 */
ifdef|#
directive|ifdef
name|SIOCGIFMETRIC
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rt_sock
argument_list|,
name|SIOCGIFMETRIC
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DBGERR
argument_list|(
literal|1
argument_list|,
literal|"ioctl(SIOCGIFMETRIC)"
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_metric
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ifs
operator|.
name|int_metric
operator|=
name|ifr
operator|.
name|ifr_metric
expr_stmt|;
block|}
else|#
directive|else
name|ifs
operator|.
name|int_metric
operator|=
name|ifam
operator|->
name|ifam_metric
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifs
operator|.
name|int_metric
operator|>
name|HOPCNT_INFINITY
condition|)
block|{
name|ifs
operator|.
name|int_metric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_BAD_METRIC
operator|)
operator|&&
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
name|complaints
operator||=
name|COMP_BAD_METRIC
expr_stmt|;
name|msglog
argument_list|(
literal|"%s has a metric of %d"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|ifs
operator|.
name|int_metric
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if this is a familiar interface. 		 * If so, stop worrying about it if it is the same. 		 * Start it over if it now is to somewhere else, as happens 		 * frequently with PPP and SLIP. 		 */
name|ifp
operator|=
name|ifwithname
argument_list|(
name|sdl
operator|->
name|sdl_data
argument_list|,
operator|(
operator|(
name|ifs
operator|.
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|?
name|ifs
operator|.
name|int_addr
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_CHECKED
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|^
name|ifs
operator|.
name|int_if_flags
operator|)
operator|&
operator|(
name|IFF_BROADCAST
operator||
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
operator|)
operator|||
literal|0
operator|!=
operator|(
operator|(
name|ifp
operator|->
name|int_state
operator|^
name|ifs
operator|.
name|int_state
operator|)
operator|&
name|IS_ALIAS
operator|)
operator|||
name|ifp
operator|->
name|int_addr
operator|!=
name|ifs
operator|.
name|int_addr
operator|||
name|ifp
operator|->
name|int_brdaddr
operator|!=
name|ifs
operator|.
name|int_brdaddr
operator|||
name|ifp
operator|->
name|int_dstaddr
operator|!=
name|ifs
operator|.
name|int_dstaddr
operator|||
name|ifp
operator|->
name|int_mask
operator|!=
name|ifs
operator|.
name|int_mask
operator|||
name|ifp
operator|->
name|int_metric
operator|!=
name|ifs
operator|.
name|int_metric
condition|)
block|{
comment|/* Forget old information about 				 * a changed interface. 				 */
name|trace_act
argument_list|(
literal|"interface %s has changed\n"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|ifdel
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
comment|/* The primary representative of an alias worries 			 * about how things are working. 			 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
condition|)
continue|continue;
comment|/* note interfaces that have been turned off 			 */
if|if
condition|(
operator|!
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|iff_alive
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"interface %s to %s turned off"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|)
expr_stmt|;
name|if_bad
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_if_flags
operator|&=
operator|~
name|IFF_UP_RUNNING
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* or that were off and are now ok */
if|if
condition|(
operator|!
name|iff_alive
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|int_if_flags
operator||=
name|IFF_UP_RUNNING
expr_stmt|;
operator|(
name|void
operator|)
name|if_ok
argument_list|(
name|ifp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* If it has been long enough, 			 * see if the interface is broken. 			 */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|<
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|+
name|CHECK_BAD_INTERVAL
condition|)
continue|continue;
name|in
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|ipackets
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|ipackets
expr_stmt|;
name|ierr
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|ierrors
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|ierrors
expr_stmt|;
name|out
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|opackets
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|opackets
expr_stmt|;
name|oerr
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|oerrors
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|oerrors
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
comment|/* Through at least IRIX 6.2, PPP and SLIP 			 * count packets dropped by  the filters. 			 * But FDDI rings stuck non-operational count 			 * dropped packets as they wait for improvement. 			 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
name|oerr
operator|+=
operator|(
name|ifs
operator|.
name|int_data
operator|.
name|odrops
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|odrops
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the interface just awoke, restart the counters. 			 */
if|if
condition|(
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|int_data
operator|=
name|ifs
operator|.
name|int_data
expr_stmt|;
continue|continue;
block|}
name|ifp
operator|->
name|int_data
operator|=
name|ifs
operator|.
name|int_data
expr_stmt|;
comment|/* Withhold judgement when the short error 			 * counters wrap or the interface is reset. 			 */
if|if
condition|(
name|ierr
operator|<
literal|0
operator|||
name|in
operator|<
literal|0
operator|||
name|oerr
operator|<
literal|0
operator|||
name|out
operator|<
literal|0
condition|)
block|{
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Withhold judgement when there is no traffic 			 */
if|if
condition|(
name|in
operator|==
literal|0
operator|&&
name|out
operator|==
literal|0
operator|&&
name|ierr
operator|==
literal|0
operator|&&
name|oerr
operator|==
literal|0
condition|)
continue|continue;
comment|/* It is bad if input or output is not working. 			 * Require presistent problems before marking it dead. 			 */
if|if
condition|(
operator|(
name|in
operator|<=
name|ierr
operator|&&
name|ierr
operator|>
literal|0
operator|)
operator|||
operator|(
name|out
operator|<=
name|oerr
operator|&&
name|oerr
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"interface %s to %s"
literal|" sick: in=%d ierr=%d"
literal|" out=%d oerr=%d\n"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|,
name|in
argument_list|,
name|ierr
argument_list|,
name|out
argument_list|,
name|oerr
argument_list|)
expr_stmt|;
name|if_sick
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
block|{
name|msglog
argument_list|(
literal|"interface %s to %s bad:"
literal|" in=%d ierr=%d out=%d oerr=%d"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|,
name|in
argument_list|,
name|ierr
argument_list|,
name|out
argument_list|,
name|oerr
argument_list|)
expr_stmt|;
name|if_bad
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* otherwise, it is active and healthy 			 */
name|ifp
operator|->
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
operator|(
name|void
operator|)
name|if_ok
argument_list|(
name|ifp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* This is a new interface. 		 * If it is dead, forget it. 		 */
if|if
condition|(
operator|!
name|iff_alive
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
continue|continue;
comment|/* See if it duplicates an existing interface. 		 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_mask
operator|!=
name|ifs
operator|.
name|int_mask
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|int_addr
operator|!=
name|ifs
operator|.
name|int_addr
operator|&&
name|ifs
operator|.
name|int_mask
operator|!=
name|HOST_MASK
operator|)
operator|||
operator|(
name|ifp
operator|->
name|int_dstaddr
operator|!=
name|ifs
operator|.
name|int_dstaddr
operator|&&
name|ifs
operator|.
name|int_mask
operator|==
name|HOST_MASK
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iff_alive
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
continue|continue;
comment|/* Let one of our real interfaces be marked 			 * passive. 			 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_PASSIVE
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_EXTERNAL
operator|)
condition|)
continue|continue;
comment|/* It does duplicate an existing interface, 			 * so complain about it, mark the other one 			 * duplicated, and for get this one. 			 */
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_DUP
operator|)
condition|)
block|{
name|complaints
operator||=
name|COMP_DUP
expr_stmt|;
name|msglog
argument_list|(
literal|"%s is duplicated by %s at %s"
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|int_state
operator||=
name|IS_DUP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
continue|continue;
comment|/* It is new and ok.  So make it real 		 */
name|strncpy
argument_list|(
name|ifs
operator|.
name|int_name
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|ifs
operator|.
name|int_name
argument_list|)
operator|-
literal|1
argument_list|,
name|sdl
operator|->
name|sdl_nlen
argument_list|)
argument_list|)
expr_stmt|;
name|get_parms
argument_list|(
operator|&
name|ifs
argument_list|)
expr_stmt|;
comment|/* Add it to the list of interfaces 		 */
name|ifp
operator|=
operator|(
expr|struct
name|interface
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|,
literal|"ifinit"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ifs
argument_list|,
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifnet
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|int_next
operator|=
name|ifnet
expr_stmt|;
name|ifnet
operator|->
name|int_prev
operator|=
name|ifp
expr_stmt|;
block|}
name|ifnet
operator|=
name|ifp
expr_stmt|;
name|trace_if
argument_list|(
literal|"Add"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* Notice likely bad netmask. 		 */
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NETMASK
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
for|for
control|(
name|ifp1
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp1
condition|;
name|ifp1
operator|=
name|ifp1
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp1
operator|->
name|int_mask
operator|==
name|ifp
operator|->
name|int_mask
condition|)
continue|continue;
if|if
condition|(
name|ifp1
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
continue|continue;
if|if
condition|(
name|on_net
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|ifp1
operator|->
name|int_net
argument_list|,
name|ifp1
operator|->
name|int_mask
argument_list|)
operator|||
name|on_net
argument_list|(
name|ifp1
operator|->
name|int_addr
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"possible netmask problem"
literal|" betwen %s:%s and %s:%s"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|addrname
argument_list|(
name|htonl
argument_list|(
name|ifp
operator|->
name|int_net
argument_list|)
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|,
name|addrname
argument_list|(
name|htonl
argument_list|(
name|ifp1
operator|->
name|int_net
argument_list|)
argument_list|,
name|ifp1
operator|->
name|int_mask
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NETMASK
expr_stmt|;
block|}
block|}
block|}
comment|/* Count the # of directly connected networks. 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
name|tot_interfaces
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IS_RIP_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
condition|)
name|rip_interfaces
operator|++
expr_stmt|;
block|}
name|if_ok_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|rip_on
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* If we are multi-homed and have at least one interface 	 * listening to RIP, then output by default. 	 */
if|if
condition|(
operator|!
name|supplier_set
operator|&&
name|rip_interfaces
operator|>
literal|1
condition|)
name|set_supplier
argument_list|()
expr_stmt|;
comment|/* If we are multi-homed, optionally advertise a route to 	 * our main address. 	 */
if|if
condition|(
name|advertise_mhome
operator|||
operator|(
name|tot_interfaces
operator|>
literal|1
operator|&&
name|mhome
operator|&&
operator|(
name|ifp
operator|=
name|ifwithaddr
argument_list|(
name|myaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|foundloopback
operator|)
condition|)
block|{
name|advertise_mhome
operator|=
literal|1
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|myaddr
argument_list|,
name|HOST_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
operator|||
name|rt
operator|->
name|rt_router
operator|!=
name|loopaddr
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator||
name|RS_MHOME
argument_list|,
name|loopaddr
argument_list|,
name|loopaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|,
name|rt
operator|->
name|rt_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
name|rtadd
argument_list|(
name|myaddr
argument_list|,
name|HOST_MASK
argument_list|,
name|loopaddr
argument_list|,
name|loopaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RS_MHOME
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp1
control|)
block|{
name|ifp1
operator|=
name|ifp
operator|->
name|int_next
expr_stmt|;
comment|/* because we may delete it */
comment|/* Forget any interfaces that have disappeared. 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_CHECKED
operator||
name|IS_REMOTE
operator|)
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"interface %s has disappeared\n"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|ifdel
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_PASSIVE
operator|)
condition|)
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
comment|/* If we ever have a RIPv1 interface, assume we always will. 		 * It might come back if it ever goes away. 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
condition|)
name|have_ripv1_out
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_IN
operator|)
condition|)
name|have_ripv1_in
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* Ensure there is always a network route for interfaces, 		 * after any dead interfaces have been deleted, which 		 * might affect routes for point-to-point links. 		 */
name|addrouteforif
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Add routes to the local end of point-to-point interfaces 		 * using loopback. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
operator|&&
name|foundloopback
condition|)
block|{
comment|/* Delete any routes to the network address through 			 * foreign routers. Remove even static routes. 			 */
name|del_static
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|HOST_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|HOST_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|rt
operator|->
name|rt_router
operator|!=
name|loopaddr
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_LOCAL
operator|)
operator|||
name|rt
operator|->
name|rt_metric
operator|>
name|ifp
operator|->
name|int_metric
condition|)
block|{
name|ifp1
operator|=
name|ifp
expr_stmt|;
block|}
else|else
block|{
name|ifp1
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
block|}
name|rtchange
argument_list|(
name|rt
argument_list|,
operator|(
operator|(
name|rt
operator|->
name|rt_state
operator|&
operator|~
name|RS_NET_SYN
operator|)
operator||
operator|(
name|RS_IF
operator||
name|RS_LOCAL
operator|)
operator|)
argument_list|,
name|loopaddr
argument_list|,
name|loopaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ifp1
argument_list|,
name|rt
operator|->
name|rt_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtadd
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|HOST_MASK
argument_list|,
name|loopaddr
argument_list|,
name|loopaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|RS_IF
operator||
name|RS_LOCAL
operator|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* add the authority routes */
for|for
control|(
name|intnetp
operator|=
name|intnets
init|;
name|intnetp
operator|!=
literal|0
condition|;
name|intnetp
operator|=
name|intnetp
operator|->
name|intnet_next
control|)
block|{
name|rt
operator|=
name|rtget
argument_list|(
name|intnetp
operator|->
name|intnet_addr
argument_list|,
name|intnetp
operator|->
name|intnet_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NO_NET_SYN
operator|)
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_INT
operator|)
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
name|rtadd
argument_list|(
name|intnetp
operator|->
name|intnet_addr
argument_list|,
name|intnetp
operator|->
name|intnet_mask
argument_list|,
name|loopaddr
argument_list|,
name|loopaddr
argument_list|,
name|intnetp
operator|->
name|intnet_metric
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|RS_NET_SYN
operator||
name|RS_NET_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|prev_complaints
operator|=
name|complaints
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_net_syn
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
comment|/* Turn on the need to automatically synthesize a network route 	 * for this interface only if we are running RIPv1 on some other 	 * interface that is on a different class-A,B,or C network. 	 */
if|if
condition|(
name|have_ripv1_out
operator|||
name|have_ripv1_in
condition|)
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_NEED_NET_SYN
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|ifp
operator|->
name|int_std_addr
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
literal|0
operator|==
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NO_NET_SYN
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
operator|)
operator|||
name|rt
operator|->
name|rt_metric
operator|>
name|ifp
operator|->
name|int_metric
operator|)
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
name|rtadd
argument_list|(
name|ifp
operator|->
name|int_std_addr
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|,
name|ifp
operator|->
name|int_addr
argument_list|,
name|ifp
operator|->
name|int_addr
argument_list|,
name|ifp
operator|->
name|int_metric
argument_list|,
literal|0
argument_list|,
name|RS_NET_SYN
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|int_state
operator|&=
operator|~
name|IS_NEED_NET_SYN
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|ifp
operator|->
name|int_std_addr
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
operator|)
operator|&&
name|rt
operator|->
name|rt_ifp
operator|==
name|ifp
condition|)
name|rtbad_sub
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add route for interface if not currently installed.  * Create route to other end if a point-to-point link,  * otherwise a route to this (sub)network.  */
end_comment

begin_function
name|void
name|addrouteforif
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|naddr
name|dst
decl_stmt|,
name|gate
decl_stmt|;
comment|/* skip sick interfaces 	 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
return|return;
comment|/* If the interface on a subnet, then install a RIPv1 route to 	 * the network as well (unless it is sick). 	 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SUBNET
condition|)
name|check_net_syn
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
block|{
name|dst
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|gate
operator|=
name|ifp
operator|->
name|int_dstaddr
expr_stmt|;
comment|/* If we are going to send packets to the gateway, 		 * it must be reachable using our physical interfaces 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&&
name|IS_EXTERNAL
operator|)
operator|&&
operator|!
name|rtfind
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
operator|&&
name|ifp
operator|->
name|int_transitions
operator|==
literal|0
condition|)
block|{
name|msglog
argument_list|(
literal|"unreachable gateway %s in "
name|_PATH_GATEWAYS
literal|" entry %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|gate
argument_list|)
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|dst
operator|=
operator|(
literal|0
operator|!=
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_LOOPBACK
operator|)
operator|)
condition|?
name|ifp
operator|->
name|int_dstaddr
else|:
name|htonl
argument_list|(
name|ifp
operator|->
name|int_net
argument_list|)
operator|)
expr_stmt|;
name|gate
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
block|}
comment|/* We are finished if the correct main interface route exists. 	 * The right route must be for the right interface, not synthesized 	 * from a subnet, be a "gateway" or not as appropriate, and so forth. 	 */
name|del_static
argument_list|(
name|dst
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|dst
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
operator|||
name|rt
operator|->
name|rt_router
operator|!=
name|ifp
operator|->
name|int_addr
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_DUP
operator|)
operator|||
name|rt
operator|->
name|rt_ifp
operator|==
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|)
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rtchange
argument_list|(
name|rt
argument_list|,
operator|(
operator|(
name|rt
operator|->
name|rt_state
operator||
name|RS_IF
operator|)
operator|&
operator|~
operator|(
name|RS_NET_SYN
operator||
name|RS_LOCAL
operator|)
operator|)
argument_list|,
name|ifp
operator|->
name|int_addr
argument_list|,
name|ifp
operator|->
name|int_addr
argument_list|,
name|ifp
operator|->
name|int_metric
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_transitions
operator|++
operator|>
literal|0
condition|)
name|trace_act
argument_list|(
literal|"re-install interface %s\n"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|rtadd
argument_list|(
name|dst
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
name|gate
argument_list|,
name|gate
argument_list|,
name|ifp
operator|->
name|int_metric
argument_list|,
literal|0
argument_list|,
name|RS_IF
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

