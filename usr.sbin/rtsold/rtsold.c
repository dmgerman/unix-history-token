begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: rtsold.c,v 1.67 2003/05/17 18:16:15 itojun Exp $	*/
end_comment

begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|"rtsold.h"
end_include

begin_define
define|#
directive|define
name|RTSOL_DUMPFILE
value|"/var/run/rtsold.dump";
end_define

begin_define
define|#
directive|define
name|RTSOL_PIDFILE
value|"/var/run/rtsold.pid";
end_define

begin_decl_stmt
name|struct
name|timespec
name|tm_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_upto
init|=
literal|999
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force setting sysctl parameters */
end_comment

begin_decl_stmt
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|otherconf_script
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|resolvconf_script
init|=
literal|"/sbin/resolvconf"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protocol constants */
end_comment

begin_define
define|#
directive|define
name|MAX_RTR_SOLICITATION_DELAY
value|1
end_define

begin_comment
comment|/* second */
end_comment

begin_define
define|#
directive|define
name|RTR_SOLICITATION_INTERVAL
value|4
end_define

begin_comment
comment|/* seconds */
end_comment

begin_define
define|#
directive|define
name|MAX_RTR_SOLICITATIONS
value|3
end_define

begin_comment
comment|/* times */
end_comment

begin_comment
comment|/*  * implementation dependent constants in seconds  * XXX: should be configurable  */
end_comment

begin_define
define|#
directive|define
name|PROBE_INTERVAL
value|60
end_define

begin_comment
comment|/* static variables and functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mobile_node
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pidfilename
init|=
name|RTSOL_PIDFILE
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|do_dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dumpfilename
init|=
name|RTSOL_DUMPFILE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int ifreconfig(char *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|make_packet
parameter_list|(
name|struct
name|ifinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|timespec
modifier|*
name|rtsol_check_timer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_function_decl
specifier|static
name|void
name|rtsold_set_dump_file
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|ch
decl_stmt|,
name|once
init|=
literal|0
decl_stmt|;
name|struct
name|timespec
modifier|*
name|timeout
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|;
name|struct
name|pollfd
name|set
index|[
literal|2
index|]
decl_stmt|;
name|int
name|rtsock
decl_stmt|;
name|char
modifier|*
name|argv0
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
comment|/* rtsold */
name|opts
operator|=
literal|"adDfFm1O:p:R:u"
expr_stmt|;
else|#
directive|else
comment|/* rtsol */
name|opts
operator|=
literal|"adDFO:R:u"
expr_stmt|;
name|fflag
operator|=
literal|1
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|argv0
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dflag
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dflag
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|Fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mobile_node
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|once
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|otherconf_script
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pidfilename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|resolvconf_script
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|aflag
operator|&&
name|argc
operator|==
literal|0
operator|)
operator|||
operator|(
name|aflag
operator|&&
name|argc
operator|!=
literal|0
operator|)
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Generate maximum time in timespec. */
name|tm_max
operator|.
name|tv_sec
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|time_t
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|tm_max
operator|.
name|tv_sec
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|tm_max
operator|.
name|tv_nsec
operator|=
operator|(
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|tm_max
operator|.
name|tv_nsec
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* set log level */
if|if
condition|(
name|dflag
operator|>
literal|1
condition|)
name|log_upto
operator|=
name|LOG_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
name|dflag
operator|>
literal|0
condition|)
name|log_upto
operator|=
name|LOG_INFO
expr_stmt|;
else|else
name|log_upto
operator|=
name|LOG_NOTICE
expr_stmt|;
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
name|char
modifier|*
name|ident
decl_stmt|;
name|ident
operator|=
name|strrchr
argument_list|(
name|argv0
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ident
condition|)
name|ident
operator|=
name|argv0
expr_stmt|;
else|else
name|ident
operator|++
expr_stmt|;
name|openlog
argument_list|(
name|ident
argument_list|,
name|LOG_NDELAY
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_upto
operator|>=
literal|0
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|log_upto
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|otherconf_script
operator|&&
operator|*
name|otherconf_script
operator|!=
literal|'/'
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"configuration script (%s) must be an absolute path"
argument_list|,
name|otherconf_script
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resolvconf_script
operator|&&
operator|*
name|resolvconf_script
operator|!=
literal|'/'
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"configuration script (%s) must be an absolute path"
argument_list|,
name|resolvconf_script
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pidfilename
operator|&&
operator|*
name|pidfilename
operator|!=
literal|'/'
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pid filename (%s) must be an absolute path"
argument_list|,
name|pidfilename
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|900000
operator|)
if|if
condition|(
name|Fflag
condition|)
block|{
name|setinet6sysctl
argument_list|(
name|IPV6CTL_FORWARDING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* warn if forwarding is up */
if|if
condition|(
name|getinet6sysctl
argument_list|(
name|IPV6CTL_FORWARDING
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"kernel is configured as a router, not a host"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SMALL
comment|/* initialization to dump internal status to a file */
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|rtsold_set_dump_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fflag
condition|)
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* act as a daemon */
comment|/* 	 * Open a socket for sending RS and receiving RA. 	 * This should be done before calling ifinit(), since the function 	 * uses the socket. 	 */
if|if
condition|(
operator|(
name|s
operator|=
name|sockopen
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to open a socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|set
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|s
expr_stmt|;
name|set
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|set
index|[
literal|1
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rtsock
operator|=
name|rtsock_open
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to open a socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|set
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|rtsock
expr_stmt|;
name|set
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
comment|/* configuration per interface */
if|if
condition|(
name|ifinit
argument_list|()
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to initialize interfaces"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aflag
condition|)
name|argv
operator|=
name|autoifprobe
argument_list|()
expr_stmt|;
while|while
condition|(
name|argv
operator|&&
operator|*
name|argv
condition|)
block|{
if|if
condition|(
name|ifconfig
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to initialize %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
comment|/* setup for probing default routers */
if|if
condition|(
name|probe_init
argument_list|()
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to setup for probing routers"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* dump the current pid */
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|pidfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to open a pid log file(%s): %s"
argument_list|,
name|pidfilename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* main loop */
name|int
name|e
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|do_dump
condition|)
block|{
comment|/* SIGUSR1 */
name|do_dump
operator|=
literal|0
expr_stmt|;
name|rtsold_dump_file
argument_list|(
name|dumpfilename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|timeout
operator|=
name|rtsol_check_timer
argument_list|()
expr_stmt|;
if|if
condition|(
name|once
condition|)
block|{
name|struct
name|ifinfo
modifier|*
name|ifi
decl_stmt|;
comment|/* if we have no timeout, we are done (or failed) */
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
break|break;
comment|/* if all interfaces have got RA packet, we are done */
name|TAILQ_FOREACH
argument_list|(
argument|ifi
argument_list|,
argument|&ifinfo_head
argument_list|,
argument|ifi_next
argument_list|)
block|{
if|if
condition|(
name|ifi
operator|->
name|state
operator|!=
name|IFS_DOWN
operator|&&
name|ifi
operator|->
name|racnt
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ifi
operator|==
name|NULL
condition|)
break|break;
block|}
name|e
operator|=
name|poll
argument_list|(
name|set
argument_list|,
literal|2
argument_list|,
name|timeout
condition|?
operator|(
name|timeout
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
name|timeout
operator|->
name|tv_nsec
operator|/
literal|1000
operator|/
literal|1000
operator|)
else|:
name|INFTIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|e
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"select: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* packet reception */
if|if
condition|(
name|set
index|[
literal|1
index|]
operator|.
name|revents
operator|&
name|POLLIN
condition|)
name|rtsock_input
argument_list|(
name|rtsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLIN
condition|)
name|rtsol_input
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ifconfig
parameter_list|(
name|char
modifier|*
name|ifname
parameter_list|)
block|{
name|struct
name|ifinfo
modifier|*
name|ifi
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|sdl
operator|=
name|if_nametosdl
argument_list|(
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"failed to get link layer information for %s"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|find_ifinfo
argument_list|(
name|sdl
operator|->
name|sdl_index
argument_list|)
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"interface %s was already configured"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|Fflag
condition|)
block|{
name|struct
name|in6_ndireq
name|nd
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"socket() failed."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nd
operator|.
name|ifname
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFINFO_IN6
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"cannot get accept_rtadv flag"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nd
operator|.
name|ndi
operator|.
name|flags
operator||=
name|ND6_IFF_ACCEPT_RTADV
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFINFO_IN6
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"cannot set accept_rtadv flag"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ifi
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|ifi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifi
argument_list|)
argument_list|)
expr_stmt|;
name|ifi
operator|->
name|sdl
operator|=
name|sdl
expr_stmt|;
name|ifi
operator|->
name|ifi_rdnss
operator|=
name|IFI_DNSOPT_STATE_NOINFO
expr_stmt|;
name|ifi
operator|->
name|ifi_dnssl
operator|=
name|IFI_DNSOPT_STATE_NOINFO
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ifi
operator|->
name|ifi_rainfo
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ifi
operator|->
name|ifname
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifi
operator|->
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* construct a router solicitation message */
if|if
condition|(
name|make_packet
argument_list|(
name|ifi
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* set link ID of this interface. */
ifdef|#
directive|ifdef
name|HAVE_SCOPELIB
if|if
condition|(
name|inet_zoneid
argument_list|(
name|AF_INET6
argument_list|,
literal|2
argument_list|,
name|ifname
argument_list|,
operator|&
name|ifi
operator|->
name|linkid
argument_list|)
condition|)
goto|goto
name|bad
goto|;
else|#
directive|else
comment|/* XXX: assume interface IDs as link IDs */
name|ifi
operator|->
name|linkid
operator|=
name|ifi
operator|->
name|sdl
operator|->
name|sdl_index
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * check if the interface is available. 	 * also check if SIOCGIFMEDIA ioctl is OK on the interface. 	 */
name|ifi
operator|->
name|mediareqok
operator|=
literal|1
expr_stmt|;
name|ifi
operator|->
name|active
operator|=
name|interface_status
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifi
operator|->
name|mediareqok
condition|)
block|{
comment|/* 		 * probe routers periodically even if the link status 		 * does not change. 		 */
name|ifi
operator|->
name|probeinterval
operator|=
name|PROBE_INTERVAL
expr_stmt|;
block|}
comment|/* activate interface: interface_up returns 0 on success */
name|flags
operator|=
name|interface_up
argument_list|(
name|ifi
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
name|ifi
operator|->
name|state
operator|=
name|IFS_DELAY
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|==
name|IFS_TENTATIVE
condition|)
name|ifi
operator|->
name|state
operator|=
name|IFS_TENTATIVE
expr_stmt|;
else|else
name|ifi
operator|->
name|state
operator|=
name|IFS_DOWN
expr_stmt|;
name|rtsol_timer_update
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ifinfo_head
argument_list|,
name|ifi
argument_list|,
name|ifi_next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|ifi
operator|->
name|sdl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflist_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ifinfo
modifier|*
name|ifi
decl_stmt|;
while|while
condition|(
operator|(
name|ifi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifinfo_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ifinfo_head
argument_list|,
name|ifi
argument_list|,
name|ifi_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifi
operator|->
name|sdl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ifi
operator|->
name|sdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifi
operator|->
name|rs_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ifi
operator|->
name|rs_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int ifreconfig(char *ifname) { 	struct ifinfo *ifi, *prev; 	int rv;  	prev = NULL; 	TAILQ_FOREACH(ifi,&ifinfo_head, ifi_next) { 		if (strncmp(ifi->ifname, ifname, sizeof(ifi->ifname)) == 0) 			break; 		prev = ifi; 	} 	prev->next = ifi->next;  	rv = ifconfig(ifname);
comment|/* reclaim it after ifconfig() in case ifname is pointer inside ifi */
end_comment

begin_endif
unit|if (ifi->rs_data) 		free(ifi->rs_data); 	free(ifi->sdl); 	free(ifi);  	return (rv); }
endif|#
directive|endif
end_endif

begin_function
name|struct
name|rainfo
modifier|*
name|find_rainfo
parameter_list|(
name|struct
name|ifinfo
modifier|*
name|ifi
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|sin6
parameter_list|)
block|{
name|struct
name|rainfo
modifier|*
name|rai
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rai
argument_list|,
argument|&ifi->ifi_rainfo
argument_list|,
argument|rai_next
argument_list|)
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|rai
operator|->
name|rai_saddr
operator|.
name|sin6_addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|rai
operator|->
name|rai_saddr
operator|.
name|sin6_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rai
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ifinfo
modifier|*
name|find_ifinfo
parameter_list|(
name|int
name|ifindex
parameter_list|)
block|{
name|struct
name|ifinfo
modifier|*
name|ifi
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifi
argument_list|,
argument|&ifinfo_head
argument_list|,
argument|ifi_next
argument_list|)
block|{
if|if
condition|(
name|ifi
operator|->
name|sdl
operator|->
name|sdl_index
operator|==
name|ifindex
condition|)
return|return
operator|(
name|ifi
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_packet
parameter_list|(
name|struct
name|ifinfo
modifier|*
name|ifi
parameter_list|)
block|{
name|size_t
name|packlen
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|nd_router_solicit
argument_list|)
decl_stmt|,
name|lladdroptlen
init|=
literal|0
decl_stmt|;
name|struct
name|nd_router_solicit
modifier|*
name|rs
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|lladdroptlen
operator|=
name|lladdropt_length
argument_list|(
name|ifi
operator|->
name|sdl
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_INFO
argument_list|,
name|__func__
argument_list|,
literal|"link-layer address option has null length"
literal|" on %s. Treat as not included."
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|)
expr_stmt|;
block|}
name|packlen
operator|+=
name|lladdroptlen
expr_stmt|;
name|ifi
operator|->
name|rs_datalen
operator|=
name|packlen
expr_stmt|;
comment|/* allocate buffer */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|packlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"memory allocation failed for %s"
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifi
operator|->
name|rs_data
operator|=
name|buf
expr_stmt|;
comment|/* fill in the message */
name|rs
operator|=
operator|(
expr|struct
name|nd_router_solicit
operator|*
operator|)
name|buf
expr_stmt|;
name|rs
operator|->
name|nd_rs_type
operator|=
name|ND_ROUTER_SOLICIT
expr_stmt|;
name|rs
operator|->
name|nd_rs_code
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|nd_rs_cksum
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|nd_rs_reserved
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
expr_stmt|;
comment|/* fill in source link-layer address option */
if|if
condition|(
name|lladdroptlen
condition|)
name|lladdropt_fill
argument_list|(
name|ifi
operator|->
name|sdl
argument_list|,
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|timespec
modifier|*
name|rtsol_check_timer
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|timespec
name|returnval
decl_stmt|;
name|struct
name|timespec
name|now
decl_stmt|,
name|rtsol_timer
decl_stmt|;
name|struct
name|ifinfo
modifier|*
name|ifi
decl_stmt|;
name|struct
name|rainfo
modifier|*
name|rai
decl_stmt|;
name|struct
name|ra_opt
modifier|*
name|rao
decl_stmt|,
modifier|*
name|raotmp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC_FAST
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|rtsol_timer
operator|=
name|tm_max
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifi
argument_list|,
argument|&ifinfo_head
argument_list|,
argument|ifi_next
argument_list|)
block|{
if|if
condition|(
name|TS_CMP
argument_list|(
operator|&
name|ifi
operator|->
name|expire
argument_list|,
operator|&
name|now
argument_list|,
operator|<=
argument_list|)
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"timer expiration on %s, "
literal|"state = %d"
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|,
name|ifi
operator|->
name|state
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rai
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifi
operator|->
name|ifi_rainfo
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove all RA options. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ifi
operator|->
name|ifi_rainfo
argument_list|,
name|rai
argument_list|,
name|rai_next
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rao
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rai
operator|->
name|rai_ra_opt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rai
operator|->
name|rai_ra_opt
argument_list|,
name|rao
argument_list|,
name|rao_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|rao
operator|->
name|rao_msg
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rao
operator|->
name|rao_msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rao
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rai
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ifi
operator|->
name|state
condition|)
block|{
case|case
name|IFS_DOWN
case|:
case|case
name|IFS_TENTATIVE
case|:
comment|/* interface_up returns 0 on success */
name|flags
operator|=
name|interface_up
argument_list|(
name|ifi
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
name|ifi
operator|->
name|state
operator|=
name|IFS_DELAY
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|==
name|IFS_TENTATIVE
condition|)
name|ifi
operator|->
name|state
operator|=
name|IFS_TENTATIVE
expr_stmt|;
else|else
name|ifi
operator|->
name|state
operator|=
name|IFS_DOWN
expr_stmt|;
break|break;
case|case
name|IFS_IDLE
case|:
block|{
name|int
name|oldstatus
init|=
name|ifi
operator|->
name|active
decl_stmt|;
name|int
name|probe
init|=
literal|0
decl_stmt|;
name|ifi
operator|->
name|active
operator|=
name|interface_status
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstatus
operator|!=
name|ifi
operator|->
name|active
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"%s status is changed"
literal|" from %d to %d"
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|,
name|oldstatus
argument_list|,
name|ifi
operator|->
name|active
argument_list|)
expr_stmt|;
name|probe
operator|=
literal|1
expr_stmt|;
name|ifi
operator|->
name|state
operator|=
name|IFS_DELAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifi
operator|->
name|probeinterval
operator|&&
operator|(
name|ifi
operator|->
name|probetimer
operator|-=
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* probe timer expired */
name|ifi
operator|->
name|probetimer
operator|=
name|ifi
operator|->
name|probeinterval
expr_stmt|;
name|probe
operator|=
literal|1
expr_stmt|;
name|ifi
operator|->
name|state
operator|=
name|IFS_PROBE
expr_stmt|;
block|}
comment|/* 				 * If we need a probe, clear the previous 				 * status wrt the "other" configuration. 				 */
if|if
condition|(
name|probe
condition|)
name|ifi
operator|->
name|otherconfig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|probe
operator|&&
name|mobile_node
condition|)
name|defrouter_probe
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IFS_DELAY
case|:
name|ifi
operator|->
name|state
operator|=
name|IFS_PROBE
expr_stmt|;
name|sendpacket
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFS_PROBE
case|:
if|if
condition|(
name|ifi
operator|->
name|probes
operator|<
name|MAX_RTR_SOLICITATIONS
condition|)
name|sendpacket
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
else|else
block|{
name|warnmsg
argument_list|(
name|LOG_INFO
argument_list|,
name|__func__
argument_list|,
literal|"No answer after sending %d RSs"
argument_list|,
name|ifi
operator|->
name|probes
argument_list|)
expr_stmt|;
name|ifi
operator|->
name|probes
operator|=
literal|0
expr_stmt|;
name|ifi
operator|->
name|state
operator|=
name|IFS_IDLE
expr_stmt|;
block|}
break|break;
block|}
name|rtsol_timer_update
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Expiration check for RA options. */
name|int
name|expire
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rai
argument_list|,
argument|&ifi->ifi_rainfo
argument_list|,
argument|rai_next
argument_list|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rao
argument_list|,
argument|&rai->rai_ra_opt
argument_list|,
argument|rao_next
argument_list|,
argument|raotmp
argument_list|)
block|{
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"RA expiration timer: "
literal|"type=%d, msg=%s, expire=%s"
argument_list|,
name|rao
operator|->
name|rao_type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rao
operator|->
name|rao_msg
argument_list|,
name|sec2str
argument_list|(
operator|&
name|rao
operator|->
name|rao_expire
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TS_CMP
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|rao
operator|->
name|rao_expire
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"RA expiration timer: "
literal|"expired."
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rai
operator|->
name|rai_ra_opt
argument_list|,
name|rao
argument_list|,
name|rao_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|rao
operator|->
name|rao_msg
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rao
operator|->
name|rao_msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rao
argument_list|)
expr_stmt|;
name|expire
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|expire
condition|)
name|ra_opt_handler
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TS_CMP
argument_list|(
operator|&
name|ifi
operator|->
name|expire
argument_list|,
operator|&
name|rtsol_timer
argument_list|,
operator|<
argument_list|)
condition|)
name|rtsol_timer
operator|=
name|ifi
operator|->
name|expire
expr_stmt|;
block|}
if|if
condition|(
name|TS_CMP
argument_list|(
operator|&
name|rtsol_timer
argument_list|,
operator|&
name|tm_max
argument_list|,
operator|==
argument_list|)
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"there is no timer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|TS_CMP
argument_list|(
operator|&
name|rtsol_timer
argument_list|,
operator|&
name|now
argument_list|,
operator|<
argument_list|)
condition|)
comment|/* this may occur when the interval is too small */
name|returnval
operator|.
name|tv_sec
operator|=
name|returnval
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
else|else
name|TS_SUB
argument_list|(
operator|&
name|rtsol_timer
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|returnval
argument_list|)
expr_stmt|;
name|now
operator|.
name|tv_sec
operator|+=
name|returnval
operator|.
name|tv_sec
expr_stmt|;
name|now
operator|.
name|tv_nsec
operator|+=
name|returnval
operator|.
name|tv_nsec
expr_stmt|;
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"New timer is %s"
argument_list|,
name|sec2str
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|returnval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rtsol_timer_update
parameter_list|(
name|struct
name|ifinfo
modifier|*
name|ifi
parameter_list|)
block|{
define|#
directive|define
name|MILLION
value|1000000
define|#
directive|define
name|DADRETRY
value|10
comment|/* XXX: adhoc */
name|long
name|interval
decl_stmt|;
name|struct
name|timespec
name|now
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ifi
operator|->
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
name|ifi
operator|->
name|timer
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifi
operator|->
name|state
condition|)
block|{
case|case
name|IFS_DOWN
case|:
case|case
name|IFS_TENTATIVE
case|:
if|if
condition|(
operator|++
name|ifi
operator|->
name|dadcount
operator|>
name|DADRETRY
condition|)
block|{
name|ifi
operator|->
name|dadcount
operator|=
literal|0
expr_stmt|;
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|=
name|PROBE_INTERVAL
expr_stmt|;
block|}
else|else
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IFS_IDLE
case|:
if|if
condition|(
name|mobile_node
condition|)
block|{
comment|/* XXX should be configurable */
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|ifi
operator|->
name|timer
operator|=
name|tm_max
expr_stmt|;
comment|/* stop timer(valid?) */
break|break;
case|case
name|IFS_DELAY
case|:
name|interval
operator|=
name|arc4random_uniform
argument_list|(
name|MAX_RTR_SOLICITATION_DELAY
operator|*
name|MILLION
argument_list|)
expr_stmt|;
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|=
name|interval
operator|/
name|MILLION
expr_stmt|;
name|ifi
operator|->
name|timer
operator|.
name|tv_nsec
operator|=
operator|(
name|interval
operator|%
name|MILLION
operator|)
operator|*
literal|1000
expr_stmt|;
break|break;
case|case
name|IFS_PROBE
case|:
if|if
condition|(
name|ifi
operator|->
name|probes
operator|<
name|MAX_RTR_SOLICITATIONS
condition|)
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|=
name|RTR_SOLICITATION_INTERVAL
expr_stmt|;
else|else
block|{
comment|/* 			 * After sending MAX_RTR_SOLICITATIONS solicitations, 			 * we're just waiting for possible replies; there 			 * will be no more solicitation.  Thus, we change 			 * the timer value to MAX_RTR_SOLICITATION_DELAY based 			 * on RFC 2461, Section 6.3.7. 			 */
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
operator|=
name|MAX_RTR_SOLICITATION_DELAY
expr_stmt|;
block|}
break|break;
default|default:
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"illegal interface state(%d) on %s"
argument_list|,
name|ifi
operator|->
name|state
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* reset the timer */
if|if
condition|(
name|TS_CMP
argument_list|(
operator|&
name|ifi
operator|->
name|timer
argument_list|,
operator|&
name|tm_max
argument_list|,
operator|==
argument_list|)
condition|)
block|{
name|ifi
operator|->
name|expire
operator|=
name|tm_max
expr_stmt|;
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"stop timer for %s"
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC_FAST
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|TS_ADD
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|ifi
operator|->
name|timer
argument_list|,
operator|&
name|ifi
operator|->
name|expire
argument_list|)
expr_stmt|;
name|now
operator|.
name|tv_sec
operator|+=
name|ifi
operator|->
name|timer
operator|.
name|tv_sec
expr_stmt|;
name|now
operator|.
name|tv_nsec
operator|+=
name|ifi
operator|->
name|timer
operator|.
name|tv_nsec
expr_stmt|;
name|warnmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
name|__func__
argument_list|,
literal|"set timer for %s to %s"
argument_list|,
name|ifi
operator|->
name|ifname
argument_list|,
name|sec2str
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|MILLION
block|}
end_function

begin_comment
comment|/* timer related utility functions */
end_comment

begin_define
define|#
directive|define
name|MILLION
value|1000000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_function
specifier|static
name|void
name|rtsold_set_dump_file
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|)
block|{
name|do_dump
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SMALL
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rtsold [-dDfFm1] [-O script-name] "
literal|"[-p pidfile] [-R script-name] interface ...\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rtsold [-dDfFm1] [-O script-name] "
literal|"[-p pidfile] [-R script-name] -a\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rtsol [-dDF] [-O script-name] "
literal|"[-p pidfile] [-R script-name] interface ...\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rtsol [-dDF] [-O script-name] "
literal|"[-p pidfile] [-R script-name] -a\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|warnmsg
parameter_list|(
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
name|priority
operator|<=
name|log_upto
condition|)
block|{
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"<%s> %s"
argument_list|,
name|func
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
name|vsyslog
argument_list|(
name|priority
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return a list of interfaces which is suitable to sending an RS.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|autoifprobe
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
modifier|*
name|argv
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|found
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|ifap
decl_stmt|,
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in6_ndireq
name|nd
decl_stmt|;
comment|/* initialize */
while|while
condition|(
name|n
operator|--
condition|)
name|free
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
condition|)
block|{
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|NULL
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|Fflag
operator|&&
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* find an ethernet */
for|for
control|(
name|ifa
operator|=
name|ifap
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|ifa
operator|->
name|ifa_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
comment|/* 		 * Skip the interfaces which IPv6 and/or accepting RA 		 * is disabled. 		 */
if|if
condition|(
operator|!
name|Fflag
condition|)
block|{
name|memset
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nd
operator|.
name|ifname
argument_list|,
name|ifa
operator|->
name|ifa_name
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFINFO_IN6
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"ioctl(SIOCGIFINFO_IN6)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nd
operator|.
name|ndi
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|nd
operator|.
name|ndi
operator|.
name|flags
operator|&
name|ND6_IFF_ACCEPT_RTADV
operator|)
condition|)
continue|continue;
block|}
comment|/* if we find multiple candidates, just warn. */
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
name|dflag
operator|>
literal|1
condition|)
name|warnmsg
argument_list|(
name|LOG_WARNING
argument_list|,
name|__func__
argument_list|,
literal|"multiple interfaces found"
argument_list|)
expr_stmt|;
name|a
operator|=
name|realloc
argument_list|(
name|argv
argument_list|,
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|=
name|a
expr_stmt|;
name|argv
index|[
name|n
index|]
operator|=
name|strdup
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argv
index|[
name|n
index|]
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|a
operator|=
name|realloc
argument_list|(
name|argv
argument_list|,
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|warnmsg
argument_list|(
name|LOG_ERR
argument_list|,
name|__func__
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|=
name|a
expr_stmt|;
name|argv
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dflag
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|warnmsg
argument_list|(
name|LOG_WARNING
argument_list|,
name|__func__
argument_list|,
literal|"probing %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Fflag
condition|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|freeifaddrs
argument_list|(
name|ifap
argument_list|)
expr_stmt|;
return|return
operator|(
name|argv
operator|)
return|;
block|}
end_function

end_unit

