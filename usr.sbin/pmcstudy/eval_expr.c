begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Netflix Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"eval_expr.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|expression
modifier|*
name|alloc_and_hook_expr
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|exp_p
parameter_list|,
name|struct
name|expression
modifier|*
modifier|*
name|last_p
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|ex
decl_stmt|,
modifier|*
name|at
decl_stmt|;
name|ex
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Out of memory in exp allocation\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|ex
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|exp_p
operator|==
name|NULL
condition|)
block|{
operator|*
name|exp_p
operator|=
name|ex
expr_stmt|;
block|}
name|at
operator|=
operator|*
name|last_p
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
comment|/* First one, its last */
operator|*
name|last_p
operator|=
name|ex
expr_stmt|;
block|}
else|else
block|{
comment|/* Chain it to the end and update last */
name|at
operator|->
name|next
operator|=
name|ex
expr_stmt|;
name|ex
operator|->
name|prev
operator|=
name|at
expr_stmt|;
operator|*
name|last_p
operator|=
name|ex
expr_stmt|;
block|}
return|return
operator|(
name|ex
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_expr
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
name|val1_is_set
parameter_list|,
name|int
name|op_is_set
parameter_list|,
name|int
name|val2_is_set
parameter_list|,
name|int
modifier|*
name|op_cnt
parameter_list|)
block|{
name|int
name|val1
decl_stmt|,
name|op
decl_stmt|,
name|val2
decl_stmt|;
name|int
name|open_cnt
decl_stmt|;
name|val1
operator|=
name|op
operator|=
name|val2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val1_is_set
condition|)
block|{
name|val1
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|op_is_set
condition|)
block|{
name|op
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val2_is_set
condition|)
block|{
name|val2
operator|=
literal|1
expr_stmt|;
block|}
name|open_cnt
operator|=
operator|*
name|op_cnt
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
block|{
comment|/* End of the road */
if|if
condition|(
name|val1
operator|&&
name|op
operator|&&
name|val2
operator|&&
operator|(
name|open_cnt
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|exp
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_OP_PLUS
case|:
case|case
name|TYPE_OP_MINUS
case|:
case|case
name|TYPE_OP_MULT
case|:
case|case
name|TYPE_OP_DIVIDE
case|:
if|if
condition|(
name|val1
operator|&&
name|op
operator|&&
name|val2
condition|)
block|{
comment|/* We are at x + y +  			 * collapse back to val/op 			 */
name|val1
operator|=
literal|1
expr_stmt|;
name|op
operator|=
literal|1
expr_stmt|;
name|val2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val1
operator|)
condition|)
block|{
name|op
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Op but no val1 set\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|TYPE_PARN_OPEN
case|:
if|if
condition|(
name|exp
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"NULL after open paren\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|exp
operator|->
name|next
operator|->
name|type
operator|==
name|TYPE_OP_PLUS
operator|)
operator|||
operator|(
name|exp
operator|->
name|next
operator|->
name|type
operator|==
name|TYPE_OP_MINUS
operator|)
operator|||
operator|(
name|exp
operator|->
name|next
operator|->
name|type
operator|==
name|TYPE_OP_DIVIDE
operator|)
operator|||
operator|(
name|exp
operator|->
name|next
operator|->
name|type
operator|==
name|TYPE_OP_MULT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"'( OP' -- not allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|val1
operator|&&
operator|(
name|op
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"'Val (' -- not allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|val1
operator|&&
name|op
operator|&&
name|val2
condition|)
block|{
name|printf
argument_list|(
literal|"'Val OP Val (' -- not allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|open_cnt
operator|++
expr_stmt|;
operator|*
name|op_cnt
operator|=
name|open_cnt
expr_stmt|;
if|if
condition|(
name|val1
condition|)
block|{
if|if
condition|(
name|validate_expr
argument_list|(
name|exp
operator|->
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|op_cnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val2
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|validate_expr
argument_list|(
name|exp
operator|->
name|next
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|op_cnt
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|TYPE_PARN_CLOSE
case|:
name|open_cnt
operator|--
expr_stmt|;
operator|*
name|op_cnt
operator|=
name|open_cnt
expr_stmt|;
if|if
condition|(
name|val1
operator|&&
name|op
operator|&&
name|val2
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Found close paren and not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|TYPE_VALUE_CON
case|:
case|case
name|TYPE_VALUE_PMC
case|:
if|if
condition|(
name|val1
operator|==
literal|0
condition|)
block|{
name|val1
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|&&
name|op
condition|)
block|{
name|val2
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"val1 set, val2 about to be set op empty\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown type %d\n"
argument_list|,
name|exp
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|validate_expr
argument_list|(
name|exp
operator|->
name|next
argument_list|,
name|val1
argument_list|,
name|op
argument_list|,
name|val2
argument_list|,
name|op_cnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_exp
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|)
block|{
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|exp
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_OP_PLUS
case|:
name|printf
argument_list|(
literal|" + "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_OP_MINUS
case|:
name|printf
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_OP_MULT
case|:
name|printf
argument_list|(
literal|" * "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_OP_DIVIDE
case|:
name|printf
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_PARN_OPEN
case|:
name|printf
argument_list|(
literal|" ( "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_PARN_CLOSE
case|:
name|printf
argument_list|(
literal|" ) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_VALUE_CON
case|:
name|printf
argument_list|(
literal|"%f"
argument_list|,
name|exp
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_VALUE_PMC
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown op %d\n"
argument_list|,
name|exp
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|print_exp
argument_list|(
name|exp
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|walk_back_and_insert_paren
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|beg
parameter_list|,
name|struct
name|expression
modifier|*
name|frm
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|at
decl_stmt|,
modifier|*
name|ex
decl_stmt|;
comment|/* Setup our new open paren */
name|ex
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Out of memory in exp allocation\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|ex
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|->
name|type
operator|=
name|TYPE_PARN_OPEN
expr_stmt|;
comment|/* Now lets place it */
name|at
operator|=
name|frm
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|at
operator|==
operator|*
name|beg
condition|)
block|{
comment|/* We are inserting at the head of the list */
name|in_beg
label|:
name|ex
operator|->
name|next
operator|=
name|at
expr_stmt|;
name|at
operator|->
name|prev
operator|=
name|ex
expr_stmt|;
operator|*
name|beg
operator|=
name|ex
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_CON
operator|)
operator|||
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_PMC
operator|)
condition|)
block|{
comment|/* Simple case we have a value in the previous position */
name|in_mid
label|:
name|ex
operator|->
name|prev
operator|=
name|at
operator|->
name|prev
expr_stmt|;
name|ex
operator|->
name|prev
operator|->
name|next
operator|=
name|ex
expr_stmt|;
name|ex
operator|->
name|next
operator|=
name|at
expr_stmt|;
name|at
operator|->
name|prev
operator|=
name|ex
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_CLOSE
condition|)
block|{
comment|/* Skip through until we reach beg or all ( closes */
name|int
name|par_cnt
init|=
literal|1
decl_stmt|;
name|at
operator|=
name|at
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|par_cnt
condition|)
block|{
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_CLOSE
condition|)
block|{
name|par_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|par_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|par_cnt
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|at
operator|=
name|at
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|at
operator|==
operator|*
name|beg
condition|)
block|{
comment|/* At beginning we insert */
goto|goto
name|in_beg
goto|;
block|}
else|else
block|{
goto|goto
name|in_mid
goto|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s:Unexpected type:%d?\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|at
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_fwd_and_insert_paren
parameter_list|(
name|struct
name|expression
modifier|*
name|frm
parameter_list|,
name|struct
name|expression
modifier|*
modifier|*
name|added
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|at
decl_stmt|,
modifier|*
name|ex
decl_stmt|;
comment|/* Setup our new close paren */
name|ex
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Out of memory in exp allocation\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|ex
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|->
name|type
operator|=
name|TYPE_PARN_CLOSE
expr_stmt|;
operator|*
name|added
operator|=
name|ex
expr_stmt|;
comment|/* Now lets place it */
name|at
operator|=
name|frm
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_CON
operator|)
operator|||
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_PMC
operator|)
condition|)
block|{
comment|/* Simple case we have a value in the previous position */
name|insertit
label|:
name|ex
operator|->
name|next
operator|=
name|at
operator|->
name|next
expr_stmt|;
name|ex
operator|->
name|prev
operator|=
name|at
expr_stmt|;
name|at
operator|->
name|next
operator|=
name|ex
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|int
name|par_cnt
init|=
literal|1
decl_stmt|;
name|at
operator|=
name|at
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|par_cnt
condition|)
block|{
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|par_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_CLOSE
condition|)
block|{
name|par_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|par_cnt
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|at
operator|=
name|at
operator|->
name|next
expr_stmt|;
block|}
goto|goto
name|insertit
goto|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s:Unexpected type:%d?\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|at
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_precendence
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|beg
parameter_list|,
name|struct
name|expression
modifier|*
name|start
parameter_list|,
name|struct
name|expression
modifier|*
name|end
parameter_list|)
block|{
comment|/*  	 * Between start and end add () around any * or /. This 	 * is quite tricky since if there is a () set inside the 	 * list we need to skip over everything in the ()'s considering 	 * that just a value. 	 */
name|struct
name|expression
modifier|*
name|at
decl_stmt|,
modifier|*
name|newone
decl_stmt|;
name|int
name|open_cnt
decl_stmt|;
name|at
operator|=
name|start
expr_stmt|;
name|open_cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|at
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|open_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_CLOSE
condition|)
block|{
name|open_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|open_cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_OP_MULT
operator|)
operator|||
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_OP_DIVIDE
operator|)
condition|)
block|{
name|walk_back_and_insert_paren
argument_list|(
name|beg
argument_list|,
name|at
argument_list|)
expr_stmt|;
name|walk_fwd_and_insert_paren
argument_list|(
name|at
argument_list|,
operator|&
name|newone
argument_list|)
expr_stmt|;
name|at
operator|=
name|newone
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
block|}
name|at
operator|=
name|at
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_math_precidence
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|beg
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|expression
modifier|*
modifier|*
name|stopped
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|at
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|cnt_lower
decl_stmt|,
name|cnt_upper
decl_stmt|;
comment|/*  	 * Walk through and set any math precedence to  	 * get proper precedence we insert () around * / over + - 	 */
name|end
operator|=
name|NULL
expr_stmt|;
name|start
operator|=
name|at
operator|=
name|exp
expr_stmt|;
name|cnt_lower
operator|=
name|cnt_upper
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|at
condition|)
block|{
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_CLOSE
condition|)
block|{
comment|/* Done with that paren */
if|if
condition|(
name|stopped
condition|)
block|{
operator|*
name|stopped
operator|=
name|at
expr_stmt|;
block|}
if|if
condition|(
name|cnt_lower
operator|&&
name|cnt_upper
condition|)
block|{
comment|/* We have a mixed set ... add precedence between start/end */
name|add_precendence
argument_list|(
name|beg
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|set_math_precidence
argument_list|(
name|beg
argument_list|,
name|at
operator|->
name|next
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|at
operator|=
name|end
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_OP_PLUS
operator|)
operator|||
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_OP_MINUS
operator|)
condition|)
block|{
name|cnt_lower
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_OP_DIVIDE
operator|)
operator|||
operator|(
name|at
operator|->
name|type
operator|==
name|TYPE_OP_MULT
operator|)
condition|)
block|{
name|cnt_upper
operator|++
expr_stmt|;
block|}
name|at
operator|=
name|at
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cnt_lower
operator|&&
name|cnt_upper
condition|)
block|{
name|add_precendence
argument_list|(
name|beg
argument_list|,
name|start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|valid_pmcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|valid_pmc_cnt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pmc_name_set
parameter_list|(
name|struct
name|expression
modifier|*
name|at
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|fnd
decl_stmt|;
if|if
condition|(
name|at
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
comment|/* Special number after $ gives index */
name|idx
operator|=
name|strtol
argument_list|(
operator|&
name|at
operator|->
name|name
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|valid_pmc_cnt
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown PMC %s -- largest we have is $%d -- can't run your expression\n"
argument_list|,
name|at
operator|->
name|name
argument_list|,
name|valid_pmc_cnt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|at
operator|->
name|name
argument_list|,
name|valid_pmcs
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fnd
operator|=
literal|0
init|;
name|i
operator|<
name|valid_pmc_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|valid_pmcs
index|[
name|i
index|]
argument_list|,
name|at
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|printf
argument_list|(
literal|"PMC %s does not exist on this machine -- can't run your expression\n"
argument_list|,
name|at
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|expression
modifier|*
name|parse_expression
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|exp
init|=
name|NULL
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|,
modifier|*
name|at
decl_stmt|;
name|int
name|open_par
decl_stmt|,
name|close_par
decl_stmt|;
name|int
name|op_cnt
init|=
literal|0
decl_stmt|;
name|size_t
name|siz
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
comment|/*  	 * Walk through a string expression and convert 	 * it to a linked list of actions. We do this by: 	 * a) Counting the open/close paren's, there must 	 *    be a matching number. 	 * b) If we have balanced paren's then create a linked list 	 *    of the operators, then we validate that expression further. 	 * c) Validating that we have: 	 *      val OP val<or> 	 *      val OP (<and> 	 *    inside every paran you have a: 	 *      val OP val<or> 	 *      val OP (<recursively> 	 * d) A final optional step (not implemented yet) would be 	 *    to insert the mathimatical precedence paran's. For 	 *    the start we will just do the left to right evaluation and 	 *    then later we can add this guy to add paran's to make it 	 *    mathimatically correct... i.e instead of 1 + 2 * 3 we 	 *    would translate it into 1 + ( 2 * 3). 	 */
name|open_par
operator|=
name|close_par
operator|=
literal|0
expr_stmt|;
name|siz
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* No trailing newline please */
if|if
condition|(
name|str
index|[
operator|(
name|siz
operator|-
literal|1
operator|)
index|]
operator|==
literal|'\n'
condition|)
block|{
name|str
index|[
operator|(
name|siz
operator|-
literal|1
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|siz
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|open_par
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|')'
condition|)
block|{
name|close_par
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|open_par
operator|!=
name|close_par
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid expression '%s' %d open paren's and %d close?\n"
argument_list|,
name|str
argument_list|,
name|open_par
argument_list|,
name|close_par
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|at
operator|->
name|type
operator|=
name|TYPE_PARN_OPEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|')'
condition|)
block|{
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|at
operator|->
name|type
operator|=
name|TYPE_PARN_CLOSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Extra blank */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* Extra tab */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'+'
condition|)
block|{
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|at
operator|->
name|type
operator|=
name|TYPE_OP_PLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|at
operator|->
name|type
operator|=
name|TYPE_OP_MINUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|at
operator|->
name|type
operator|=
name|TYPE_OP_DIVIDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|at
operator|->
name|type
operator|=
name|TYPE_OP_MULT
expr_stmt|;
block|}
else|else
block|{
comment|/* Its a value or PMC constant */
name|at
operator|=
name|alloc_and_hook_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|str
index|[
name|i
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|at
operator|->
name|type
operator|=
name|TYPE_VALUE_CON
expr_stmt|;
block|}
else|else
block|{
name|at
operator|->
name|type
operator|=
name|TYPE_VALUE_PMC
expr_stmt|;
block|}
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|str
index|[
name|i
index|]
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|str
index|[
name|i
index|]
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
name|str
index|[
name|i
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|str
index|[
name|i
index|]
operator|!=
literal|')'
operator|)
operator|&&
operator|(
name|str
index|[
name|i
index|]
operator|!=
literal|'('
operator|)
condition|)
block|{
comment|/* We collect the constant until a space or tab */
name|at
operator|->
name|name
index|[
name|x
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|at
operator|->
name|name
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Value/Constant too long %d max:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|at
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|str
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Need to back up and see the last char since 				 * the for will increment the loop. 				 */
name|i
operator|--
expr_stmt|;
block|}
comment|/* Now we have pulled the string, set it up */
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_CON
condition|)
block|{
name|at
operator|->
name|state
operator|=
name|STATE_FILLED
expr_stmt|;
name|at
operator|->
name|value
operator|=
name|strtod
argument_list|(
name|at
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmc_name_set
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now lets validate its a workable expression */
if|if
condition|(
name|validate_expr
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|op_cnt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid expression\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
name|set_math_precidence
argument_list|(
operator|&
name|exp
argument_list|,
name|exp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|expression
modifier|*
name|gather_exp_to_paren_close
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|double
modifier|*
name|val_fill
parameter_list|)
block|{
comment|/* 	 * I have been given ( ??? 	 * so I could see either 	 * ( 	 * or 	 * Val Op 	 * 	 */
name|struct
name|expression
modifier|*
name|lastproc
decl_stmt|;
name|double
name|val
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|lastproc
operator|=
name|gather_exp_to_paren_close
argument_list|(
name|exp
operator|->
name|next
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
operator|*
name|val_fill
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
operator|*
name|val_fill
operator|=
name|run_expr
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
operator|&
name|lastproc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lastproc
operator|)
return|;
block|}
end_function

begin_function
name|double
name|run_expr
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
name|initial_call
parameter_list|,
name|struct
name|expression
modifier|*
modifier|*
name|lastone
parameter_list|)
block|{
comment|/*  	 * We expect to find either 	 * a) A Open Paren 	 * or 	 * b) Val-> Op -> Val 	 * or 	 * c) Val-> Op -> Open Paren 	 */
name|double
name|val1
decl_stmt|,
name|val2
decl_stmt|,
name|res
decl_stmt|;
name|struct
name|expression
modifier|*
name|op
decl_stmt|,
modifier|*
name|other_half
decl_stmt|,
modifier|*
name|rest
decl_stmt|;
if|if
condition|(
name|exp
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|op
operator|=
name|gather_exp_to_paren_close
argument_list|(
name|exp
operator|->
name|next
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|type
operator|==
name|TYPE_VALUE_CON
condition|)
block|{
name|val1
operator|=
name|exp
operator|->
name|value
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|type
operator|==
name|TYPE_VALUE_PMC
condition|)
block|{
name|val1
operator|=
name|exp
operator|->
name|value
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Illegal value in %s huh?\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|val1
operator|)
return|;
block|}
name|more_to_do
label|:
name|other_half
operator|=
name|op
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|other_half
operator|->
name|type
operator|==
name|TYPE_PARN_OPEN
condition|)
block|{
name|rest
operator|=
name|gather_exp_to_paren_close
argument_list|(
name|other_half
operator|->
name|next
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|other_half
operator|->
name|type
operator|==
name|TYPE_VALUE_CON
condition|)
block|{
name|val2
operator|=
name|other_half
operator|->
name|value
expr_stmt|;
name|rest
operator|=
name|other_half
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|other_half
operator|->
name|type
operator|==
name|TYPE_VALUE_PMC
condition|)
block|{
name|val2
operator|=
name|other_half
operator|->
name|value
expr_stmt|;
name|rest
operator|=
name|other_half
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Illegal2 value in %s huh?\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_OP_PLUS
case|:
name|res
operator|=
name|val1
operator|+
name|val2
expr_stmt|;
break|break;
case|case
name|TYPE_OP_MINUS
case|:
name|res
operator|=
name|val1
operator|-
name|val2
expr_stmt|;
break|break;
case|case
name|TYPE_OP_MULT
case|:
name|res
operator|=
name|val1
operator|*
name|val2
expr_stmt|;
break|break;
case|case
name|TYPE_OP_DIVIDE
case|:
if|if
condition|(
name|val2
operator|!=
literal|0.0
condition|)
name|res
operator|=
name|val1
operator|/
name|val2
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Division by zero averted\n"
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1.0
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Op is not an operator -- its %d\n"
argument_list|,
name|op
operator|->
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rest
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lastone
condition|)
block|{
operator|*
name|lastone
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rest
operator|->
name|type
operator|==
name|TYPE_PARN_CLOSE
operator|)
operator|&&
operator|(
name|initial_call
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|lastone
condition|)
block|{
operator|*
name|lastone
operator|=
name|rest
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
comment|/* There is more, as in 	 * a + b + c 	 * where we just did a + b 	 * so now it becomes val1 is set to res and 	 * we need to proceed with the rest of it. 	 */
name|val1
operator|=
name|res
expr_stmt|;
name|op
operator|=
name|rest
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|->
name|type
operator|!=
name|TYPE_OP_PLUS
operator|)
operator|&&
operator|(
name|op
operator|->
name|type
operator|!=
name|TYPE_OP_MULT
operator|)
operator|&&
operator|(
name|op
operator|->
name|type
operator|!=
name|TYPE_OP_MINUS
operator|)
operator|&&
operator|(
name|op
operator|->
name|type
operator|!=
name|TYPE_OP_DIVIDE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s ending on type:%d not an op??\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|op
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
if|if
condition|(
name|op
condition|)
goto|goto
name|more_to_do
goto|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STAND_ALONE_TESTING
end_ifdef

begin_function
specifier|static
name|double
name|calc_expr
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|at
decl_stmt|;
name|double
name|xx
decl_stmt|;
comment|/* First clear PMC's setting */
for|for
control|(
name|at
operator|=
name|exp
init|;
name|at
operator|!=
name|NULL
condition|;
name|at
operator|=
name|at
operator|->
name|next
control|)
block|{
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_PMC
condition|)
block|{
name|at
operator|->
name|state
operator|=
name|STATE_UNSET
expr_stmt|;
block|}
block|}
comment|/* Now for all pmc's make up values .. here is where I would pull them */
for|for
control|(
name|at
operator|=
name|exp
init|;
name|at
operator|!=
name|NULL
condition|;
name|at
operator|=
name|at
operator|->
name|next
control|)
block|{
if|if
condition|(
name|at
operator|->
name|type
operator|==
name|TYPE_VALUE_PMC
condition|)
block|{
name|at
operator|->
name|value
operator|=
operator|(
name|random
argument_list|()
operator|*
literal|1.0
operator|)
expr_stmt|;
name|at
operator|->
name|state
operator|=
name|STATE_FILLED
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|value
operator|==
literal|0.0
condition|)
block|{
comment|/* So we don't have div by 0 */
name|at
operator|->
name|value
operator|=
literal|1.0
expr_stmt|;
block|}
block|}
block|}
comment|/* Now lets calculate the expression */
name|print_exp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|xx
operator|=
name|run_expr
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Answer is %f\n"
argument_list|,
name|xx
argument_list|)
expr_stmt|;
return|return
operator|(
name|xx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Use %s expression\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|exp
operator|=
name|parse_expression
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Now the calc\n"
argument_list|)
expr_stmt|;
name|calc_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

