begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1996 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *  * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"pciconf.h"
end_include

begin_struct
struct|struct
name|pci_device_info
block|{
name|TAILQ_ENTRY
argument_list|(
argument|pci_device_info
argument_list|)
name|link
expr_stmt|;
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_vendor_info
block|{
name|TAILQ_ENTRY
argument_list|(
argument|pci_vendor_info
argument_list|)
name|link
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pci_device_info
argument_list|)
name|devs
expr_stmt|;
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pci_vendor_info
argument_list|)
end_macro

begin_expr_stmt
name|pci_vendors
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|list_devs
parameter_list|(
name|int
name|verbose
parameter_list|,
name|int
name|caps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|list_verbose
parameter_list|(
name|struct
name|pci_conf
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|guess_class
parameter_list|(
name|struct
name|pci_conf
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|guess_subclass
parameter_list|(
name|struct
name|pci_conf
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_vendors
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readit
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeit
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkattached
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|exitstatus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n"
argument_list|,
literal|"usage: pciconf -l [-cv]"
argument_list|,
literal|"       pciconf -a selector"
argument_list|,
literal|"       pciconf -r [-b | -h] selector addr[:addr2]"
argument_list|,
literal|"       pciconf -w [-b | -h] selector addr value"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|listmode
decl_stmt|,
name|readmode
decl_stmt|,
name|writemode
decl_stmt|,
name|attachedmode
decl_stmt|,
name|caps
decl_stmt|,
name|verbose
decl_stmt|;
name|int
name|byte
decl_stmt|,
name|isshort
decl_stmt|;
name|listmode
operator|=
name|readmode
operator|=
name|writemode
operator|=
name|attachedmode
operator|=
name|caps
operator|=
name|verbose
operator|=
name|byte
operator|=
name|isshort
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aclrwbhv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|attachedmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|caps
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|listmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|readmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|writemode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|byte
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|isshort
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|listmode
operator|&&
name|optind
operator|!=
name|argc
operator|)
operator|||
operator|(
name|writemode
operator|&&
name|optind
operator|+
literal|3
operator|!=
name|argc
operator|)
operator|||
operator|(
name|readmode
operator|&&
name|optind
operator|+
literal|2
operator|!=
name|argc
operator|)
operator|||
operator|(
name|attachedmode
operator|&&
name|optind
operator|+
literal|1
operator|!=
name|argc
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|listmode
condition|)
block|{
name|list_devs
argument_list|(
name|verbose
argument_list|,
name|caps
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attachedmode
condition|)
block|{
name|chkattached
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|byte
condition|?
literal|1
else|:
name|isshort
condition|?
literal|2
else|:
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readmode
condition|)
block|{
name|readit
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|byte
condition|?
literal|1
else|:
name|isshort
condition|?
literal|2
else|:
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writemode
condition|)
block|{
name|writeit
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|2
index|]
argument_list|,
name|byte
condition|?
literal|1
else|:
name|isshort
condition|?
literal|2
else|:
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
return|return
name|exitstatus
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_devs
parameter_list|(
name|int
name|verbose
parameter_list|,
name|int
name|caps
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|pci_conf_io
name|pc
decl_stmt|;
name|struct
name|pci_conf
name|conf
index|[
literal|255
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|none_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|load_vendors
argument_list|()
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVPCI
argument_list|,
name|caps
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_DEVPCI
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_conf_io
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|.
name|match_buf_len
operator|=
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pc
operator|.
name|matches
operator|=
name|conf
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PCIOCGETCONF
argument_list|,
operator|&
name|pc
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(PCIOCGETCONF)"
argument_list|)
expr_stmt|;
comment|/* 		 * 255 entries should be more than enough for most people, 		 * but if someone has more devices, and then changes things 		 * around between ioctls, we'll do the cheezy thing and 		 * just bail.  The alternative would be to go back to the 		 * beginning of the list, and print things twice, which may 		 * not be desireable. 		 */
if|if
condition|(
name|pc
operator|.
name|status
operator|==
name|PCI_GETCONF_LIST_CHANGED
condition|)
block|{
name|warnx
argument_list|(
literal|"PCI device list changed, please try again"
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|1
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|pc
operator|.
name|status
operator|==
name|PCI_GETCONF_ERROR
condition|)
block|{
name|warnx
argument_list|(
literal|"error returned from PCIOCGETCONF ioctl"
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|1
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|p
operator|=
name|conf
init|;
name|p
operator|<
operator|&
name|conf
index|[
name|pc
operator|.
name|num_matches
index|]
condition|;
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s%d@pci%d:%d:%d:\tclass=0x%06x card=0x%08x "
literal|"chip=0x%08x rev=0x%02x hdr=0x%02x\n"
argument_list|,
operator|(
name|p
operator|->
name|pd_name
operator|&&
operator|*
name|p
operator|->
name|pd_name
operator|)
condition|?
name|p
operator|->
name|pd_name
else|:
literal|"none"
argument_list|,
operator|(
name|p
operator|->
name|pd_name
operator|&&
operator|*
name|p
operator|->
name|pd_name
operator|)
condition|?
operator|(
name|int
operator|)
name|p
operator|->
name|pd_unit
else|:
name|none_count
operator|++
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_bus
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_dev
argument_list|,
name|p
operator|->
name|pc_sel
operator|.
name|pc_func
argument_list|,
operator|(
name|p
operator|->
name|pc_class
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|->
name|pc_subclass
operator|<<
literal|8
operator|)
operator||
name|p
operator|->
name|pc_progif
argument_list|,
operator|(
name|p
operator|->
name|pc_subdevice
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_subvendor
argument_list|,
operator|(
name|p
operator|->
name|pc_device
operator|<<
literal|16
operator|)
operator||
name|p
operator|->
name|pc_vendor
argument_list|,
name|p
operator|->
name|pc_revid
argument_list|,
name|p
operator|->
name|pc_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|list_verbose
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
condition|)
name|list_caps
argument_list|(
name|fd
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pc
operator|.
name|status
operator|==
name|PCI_GETCONF_MORE_DEVS
condition|)
do|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_verbose
parameter_list|(
name|struct
name|pci_conf
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pci_vendor_info
modifier|*
name|vi
decl_stmt|;
name|struct
name|pci_device_info
modifier|*
name|di
decl_stmt|;
specifier|const
name|char
modifier|*
name|dp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vi
argument_list|,
argument|&pci_vendors
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|p
operator|->
name|pc_vendor
condition|)
block|{
name|printf
argument_list|(
literal|"    vendor     = '%s'\n"
argument_list|,
name|vi
operator|->
name|desc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|vi
operator|==
name|NULL
condition|)
block|{
name|di
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|di
argument_list|,
argument|&vi->devs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|di
operator|->
name|id
operator|==
name|p
operator|->
name|pc_device
condition|)
block|{
name|printf
argument_list|(
literal|"    device     = '%s'\n"
argument_list|,
name|di
operator|->
name|desc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|guess_class
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"    class      = %s\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|guess_subclass
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"    subclass   = %s\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a direct cut-and-paste from the table in sys/dev/pci/pci.c.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|class
decl_stmt|;
name|int
name|subclass
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_nomatch_tab
index|[]
init|=
block|{
block|{
name|PCIC_OLD
block|,
operator|-
literal|1
block|,
literal|"old"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_NONVGA
block|,
literal|"non-VGA display device"
block|}
block|,
block|{
name|PCIC_OLD
block|,
name|PCIS_OLD_VGA
block|,
literal|"VGA-compatible display device"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
operator|-
literal|1
block|,
literal|"mass storage"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_SCSI
block|,
literal|"SCSI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IDE
block|,
literal|"ATA"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_FLOPPY
block|,
literal|"floppy disk"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_IPI
block|,
literal|"IPI"
block|}
block|,
block|{
name|PCIC_STORAGE
block|,
name|PCIS_STORAGE_RAID
block|,
literal|"RAID"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
operator|-
literal|1
block|,
literal|"network"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ETHERNET
block|,
literal|"ethernet"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_TOKENRING
block|,
literal|"token ring"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_FDDI
block|,
literal|"fddi"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ATM
block|,
literal|"ATM"
block|}
block|,
block|{
name|PCIC_NETWORK
block|,
name|PCIS_NETWORK_ISDN
block|,
literal|"ISDN"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
operator|-
literal|1
block|,
literal|"display"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_VGA
block|,
literal|"VGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_XGA
block|,
literal|"XGA"
block|}
block|,
block|{
name|PCIC_DISPLAY
block|,
name|PCIS_DISPLAY_3D
block|,
literal|"3D"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
operator|-
literal|1
block|,
literal|"multimedia"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_VIDEO
block|,
literal|"video"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_AUDIO
block|,
literal|"audio"
block|}
block|,
block|{
name|PCIC_MULTIMEDIA
block|,
name|PCIS_MULTIMEDIA_TELE
block|,
literal|"telephony"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
operator|-
literal|1
block|,
literal|"memory"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_RAM
block|,
literal|"RAM"
block|}
block|,
block|{
name|PCIC_MEMORY
block|,
name|PCIS_MEMORY_FLASH
block|,
literal|"flash"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
operator|-
literal|1
block|,
literal|"bridge"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_HOST
block|,
literal|"HOST-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_ISA
block|,
literal|"PCI-ISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_EISA
block|,
literal|"PCI-EISA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_MCA
block|,
literal|"PCI-MCA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCI
block|,
literal|"PCI-PCI"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_PCMCIA
block|,
literal|"PCI-PCMCIA"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_NUBUS
block|,
literal|"PCI-NuBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_CARDBUS
block|,
literal|"PCI-CardBus"
block|}
block|,
block|{
name|PCIC_BRIDGE
block|,
name|PCIS_BRIDGE_RACEWAY
block|,
literal|"PCI-RACEway"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
operator|-
literal|1
block|,
literal|"simple comms"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_UART
block|,
literal|"UART"
block|}
block|,
comment|/* could detect 16550 */
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_PAR
block|,
literal|"parallel port"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MULSER
block|,
literal|"multiport serial"
block|}
block|,
block|{
name|PCIC_SIMPLECOMM
block|,
name|PCIS_SIMPLECOMM_MODEM
block|,
literal|"generic modem"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
operator|-
literal|1
block|,
literal|"base peripheral"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PIC
block|,
literal|"interrupt controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_DMA
block|,
literal|"DMA controller"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_TIMER
block|,
literal|"timer"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_RTC
block|,
literal|"realtime clock"
block|}
block|,
block|{
name|PCIC_BASEPERIPH
block|,
name|PCIS_BASEPERIPH_PCIHOT
block|,
literal|"PCI hot-plug controller"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
operator|-
literal|1
block|,
literal|"input device"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_KEYBOARD
block|,
literal|"keyboard"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_DIGITIZER
block|,
literal|"digitizer"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_MOUSE
block|,
literal|"mouse"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_SCANNER
block|,
literal|"scanner"
block|}
block|,
block|{
name|PCIC_INPUTDEV
block|,
name|PCIS_INPUTDEV_GAMEPORT
block|,
literal|"gameport"
block|}
block|,
block|{
name|PCIC_DOCKING
block|,
operator|-
literal|1
block|,
literal|"docking station"
block|}
block|,
block|{
name|PCIC_PROCESSOR
block|,
operator|-
literal|1
block|,
literal|"processor"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
operator|-
literal|1
block|,
literal|"serial bus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FW
block|,
literal|"FireWire"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_ACCESS
block|,
literal|"AccessBus"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SSA
block|,
literal|"SSA"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_USB
block|,
literal|"USB"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_FC
block|,
literal|"Fibre Channel"
block|}
block|,
block|{
name|PCIC_SERIALBUS
block|,
name|PCIS_SERIALBUS_SMBUS
block|,
literal|"SMBus"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
operator|-
literal|1
block|,
literal|"wireless controller"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IRDA
block|,
literal|"iRDA"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_IR
block|,
literal|"IR"
block|}
block|,
block|{
name|PCIC_WIRELESS
block|,
name|PCIS_WIRELESS_RF
block|,
literal|"RF"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
operator|-
literal|1
block|,
literal|"intelligent I/O controller"
block|}
block|,
block|{
name|PCIC_INTELLIIO
block|,
name|PCIS_INTELLIIO_I2O
block|,
literal|"I2O"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
operator|-
literal|1
block|,
literal|"satellite communication"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_TV
block|,
literal|"sat TV"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_AUDIO
block|,
literal|"sat audio"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_VOICE
block|,
literal|"sat voice"
block|}
block|,
block|{
name|PCIC_SATCOM
block|,
name|PCIS_SATCOM_DATA
block|,
literal|"sat data"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
operator|-
literal|1
block|,
literal|"encrypt/decrypt"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_NETCOMP
block|,
literal|"network/computer crypto"
block|}
block|,
block|{
name|PCIC_CRYPTO
block|,
name|PCIS_CRYPTO_NETCOMP
block|,
literal|"entertainment crypto"
block|}
block|,
block|{
name|PCIC_DASP
block|,
operator|-
literal|1
block|,
literal|"dasp"
block|}
block|,
block|{
name|PCIC_DASP
block|,
name|PCIS_DASP_DPIO
block|,
literal|"DPIO module"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|guess_class
parameter_list|(
name|struct
name|pci_conf
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|class
operator|==
name|p
operator|->
name|pc_class
condition|)
return|return
operator|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|guess_subclass
parameter_list|(
name|struct
name|pci_conf
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|class
operator|==
name|p
operator|->
name|pc_class
operator|)
operator|&&
operator|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|subclass
operator|==
name|p
operator|->
name|pc_subclass
operator|)
condition|)
return|return
operator|(
name|pci_nomatch_tab
index|[
name|i
index|]
operator|.
name|desc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_vendors
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dbf
decl_stmt|;
name|FILE
modifier|*
name|db
decl_stmt|;
name|struct
name|pci_vendor_info
modifier|*
name|cv
decl_stmt|;
name|struct
name|pci_device_info
modifier|*
name|cd
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|str
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|ch
decl_stmt|;
name|int
name|id
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Locate the database and initialise. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|pci_vendors
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbf
operator|=
name|getenv
argument_list|(
literal|"PCICONF_VENDOR_DATABASE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dbf
operator|=
name|_PATH_PCIVDB
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|fopen
argument_list|(
name|dbf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cv
operator|=
name|NULL
expr_stmt|;
name|cd
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Scan input lines from the database 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|db
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|ch
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|ch
operator|=
literal|'\0'
expr_stmt|;
name|ch
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ch
operator|>
name|buf
operator|&&
name|isspace
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
operator|*
name|ch
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ch
operator|<=
name|buf
condition|)
continue|continue;
comment|/* Can't handle subvendor / subdevice entries yet */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'\t'
condition|)
continue|continue;
comment|/* Check for vendor entry */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%04x %[^\n]"
argument_list|,
operator|&
name|id
argument_list|,
name|str
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|id
operator|==
literal|0
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|<
literal|1
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_vendor_info
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"allocating vendor entry"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|cv
operator|->
name|desc
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"allocating vendor description"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|cv
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cv
operator|->
name|devs
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pci_vendors
argument_list|,
name|cv
argument_list|,
name|link
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check for device entry */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|&&
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%04x %[^\n]"
argument_list|,
operator|&
name|id
argument_list|,
name|str
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|id
operator|==
literal|0
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|<
literal|1
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cv
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"device entry with no vendor!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|cd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_device_info
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"allocating device entry"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|cd
operator|->
name|desc
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"allocating device description"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|cd
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cv
operator|->
name|devs
argument_list|,
name|cd
argument_list|,
name|link
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* It's a comment or junk, ignore it */
block|}
if|if
condition|(
name|ferror
argument_list|(
name|db
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
name|fclose
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|read_config
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|pcisel
modifier|*
name|sel
parameter_list|,
name|long
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|pci_io
name|pi
decl_stmt|;
name|pi
operator|.
name|pi_sel
operator|=
operator|*
name|sel
expr_stmt|;
name|pi
operator|.
name|pi_reg
operator|=
name|reg
expr_stmt|;
name|pi
operator|.
name|pi_width
operator|=
name|width
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PCIOCREAD
argument_list|,
operator|&
name|pi
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(PCIOCREAD)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pi
operator|.
name|pi_data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcisel
name|getsel
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ep
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|epbase
decl_stmt|;
name|struct
name|pcisel
name|sel
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
name|str
expr_stmt|;
else|else
name|ep
operator|++
expr_stmt|;
name|epbase
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ep
argument_list|,
literal|"pci"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ep
operator|+=
literal|3
expr_stmt|;
name|sel
operator|.
name|pc_bus
operator|=
name|strtoul
argument_list|(
name|ep
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|*
name|ep
operator|++
operator|!=
literal|':'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot parse selector %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sel
operator|.
name|pc_dev
operator|=
name|strtoul
argument_list|(
name|ep
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|||
operator|*
name|ep
operator|!=
literal|':'
condition|)
block|{
name|sel
operator|.
name|pc_func
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|++
expr_stmt|;
name|sel
operator|.
name|pc_func
operator|=
name|strtoul
argument_list|(
name|ep
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ep
operator|==
literal|':'
condition|)
name|ep
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\x0'
operator|||
name|ep
operator|==
name|epbase
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot parse selector %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|sel
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|readone
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|pcisel
modifier|*
name|sel
parameter_list|,
name|long
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%0*x"
argument_list|,
name|width
operator|*
literal|2
argument_list|,
name|read_config
argument_list|(
name|fd
argument_list|,
name|sel
argument_list|,
name|reg
argument_list|,
name|width
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readit
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|long
name|rstart
decl_stmt|;
name|long
name|rend
decl_stmt|;
name|long
name|r
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|pcisel
name|sel
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVPCI
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_DEVPCI
argument_list|)
expr_stmt|;
name|rend
operator|=
name|rstart
operator|=
name|strtol
argument_list|(
name|reg
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|&&
operator|*
name|end
operator|==
literal|':'
condition|)
block|{
name|end
operator|++
expr_stmt|;
name|rend
operator|=
name|strtol
argument_list|(
name|end
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sel
operator|=
name|getsel
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|r
operator|=
name|rstart
init|;
name|r
operator|<=
name|rend
condition|;
name|i
operator|++
operator|,
name|r
operator|+=
name|width
control|)
block|{
name|readone
argument_list|(
name|fd
argument_list|,
operator|&
name|sel
argument_list|,
name|r
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|(
name|i
operator|%
literal|8
operator|)
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|i
operator|%
operator|(
literal|16
operator|/
name|width
operator|)
condition|?
literal|' '
else|:
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
operator|(
literal|16
operator|/
name|width
operator|)
operator|!=
literal|1
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|writeit
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|pci_io
name|pi
decl_stmt|;
name|pi
operator|.
name|pi_sel
operator|=
name|getsel
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pi
operator|.
name|pi_reg
operator|=
name|strtoul
argument_list|(
name|reg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX error check */
name|pi
operator|.
name|pi_width
operator|=
name|width
expr_stmt|;
name|pi
operator|.
name|pi_data
operator|=
name|strtoul
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX error check */
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVPCI
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_DEVPCI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PCIOCWRITE
argument_list|,
operator|&
name|pi
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(PCIOCWRITE)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chkattached
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|pci_io
name|pi
decl_stmt|;
name|pi
operator|.
name|pi_sel
operator|=
name|getsel
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pi
operator|.
name|pi_reg
operator|=
literal|0
expr_stmt|;
name|pi
operator|.
name|pi_width
operator|=
name|width
expr_stmt|;
name|pi
operator|.
name|pi_data
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVPCI
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_DEVPCI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PCIOCATTACHED
argument_list|,
operator|&
name|pi
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(PCIOCATTACHED)"
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
name|pi
operator|.
name|pi_data
condition|?
literal|0
else|:
literal|2
expr_stmt|;
comment|/* exit(2), if NOT attached */
name|printf
argument_list|(
literal|"%s: %s%s\n"
argument_list|,
name|name
argument_list|,
name|pi
operator|.
name|pi_data
operator|==
literal|0
condition|?
literal|"not "
else|:
literal|""
argument_list|,
literal|"attached"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

