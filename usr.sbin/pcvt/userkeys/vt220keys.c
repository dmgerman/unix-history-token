begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      Trivial program to load VT220 Function keys with strings,  *      note that the values only get sent when the key is shifted  *      (shoulda been an option to flip the shift set like the Z19!)  *  *      Typing no args gives help, basically pairs of keyname/value  *      strings.  *  *      Author, Author: Barry Shein, Boston University  *  * HISTORY   {1}   30-Oct-85  Kenneth J. Lester (ken) at ektools          Added the necessary code to read an initialization file.  This         should make it easier to used this program.  Also added code         that will set-up the terminal in vt200 (this saves the user the         trouble of checking if the set-up is in vt200).          Restructed  the  main  function  to  use   getopt,  for  argument         processing.          Alterated usage function  to include  new "i"  option (init file)    	-hm	minor modifications for pcvt 2.0 release  $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  *      The default toupper() macro is stupid, will toupper anything  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|toupper
end_ifdef

begin_undef
undef|#
directive|undef
name|toupper
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|(islower(c) ? ((c)-' ') : c)
end_define

begin_define
define|#
directive|define
name|VT200_7BIT
value|1
end_define

begin_define
define|#
directive|define
name|ESC
value|033
end_define

begin_define
define|#
directive|define
name|INITFILE
value|".vt220rc"
end_define

begin_struct
struct|struct
name|keynames
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
name|keys
index|[]
init|=
block|{
literal|"F6"
block|,
literal|"17"
block|,
literal|"F7"
block|,
literal|"18"
block|,
literal|"F8"
block|,
literal|"19"
block|,
literal|"F9"
block|,
literal|"20"
block|,
literal|"F10"
block|,
literal|"21"
block|,
literal|"F11"
block|,
literal|"23"
block|,
literal|"ESC"
block|,
literal|"23"
block|,
literal|"F12"
block|,
literal|"24"
block|,
literal|"BS"
block|,
literal|"24"
block|,
literal|"F13"
block|,
literal|"25"
block|,
literal|"LF"
block|,
literal|"25"
block|,
literal|"F14"
block|,
literal|"26"
block|,
literal|"HELP"
block|,
literal|"28"
block|,
literal|"DO"
block|,
literal|"29"
block|,
literal|"F17"
block|,
literal|"31"
block|,
literal|"F18"
block|,
literal|"32"
block|,
literal|"F19"
block|,
literal|"33"
block|,
literal|"F20"
block|,
literal|"34"
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|prog
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* these are defined in the getopt routine                       */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* argument give to an option            */
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/* argv index after option processing    */
name|int
name|option
decl_stmt|;
comment|/* option character returned by getopt   */
name|int
name|initf
init|=
literal|0
decl_stmt|;
comment|/* read initialization file              */
name|int
name|lockf
init|=
literal|0
decl_stmt|;
comment|/* lock keys after loading strings       */
name|int
name|clearf
init|=
literal|0
decl_stmt|;
comment|/* clear all keys before loading strings */
name|strlcpy
argument_list|(
name|prog
argument_list|,
operator|*
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|prog
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store program name       */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* program requires options              */
comment|/* get options */
while|while
condition|(
operator|(
name|option
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cli"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'c'
case|:
name|clearf
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lockf
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|initf
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|VT200_7BIT
condition|)
name|printf
argument_list|(
literal|"\033[62;1\"p"
argument_list|)
expr_stmt|;
comment|/* vt200 7 bits */
else|else
name|printf
argument_list|(
literal|"\033[62;2\"p"
argument_list|)
expr_stmt|;
comment|/* vt200 8 bits */
if|if
condition|(
name|clearf
condition|)
name|clearkeys
argument_list|()
expr_stmt|;
if|if
condition|(
name|initf
condition|)
name|getinit
argument_list|()
expr_stmt|;
comment|/* process {key, key string} pairs.  Note optind is index to argv            for first pair.  By adding 1 to optind insures that a pair exists            i.e. the last key has a key string.                             */
while|while
condition|(
name|optind
operator|+
literal|1
operator|<
name|argc
condition|)
block|{
name|dokey
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|optind
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|lockf
condition|)
name|lockkeys
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*  *      Load the VT220 SHIFT-FNKEY value, the basic pattern is  *              "\EP1;1|"+KEYNAME+"/"+VAL_AS_HEX+"\E\\"  *      that is, literally what is in quotes (w/o quotes) then the  *      name of the key from the keytable above (a numeric string)  *      then a slash, then the string value as hex pairs then ESC-BACKSLASH  *  *      Note: you can gang together key defns with semicolons but that  *      would complicate things, especially error handling, so do it all  *      for each pair, who cares, really.  */
end_comment

begin_macro
name|dokey
argument_list|(
argument|nm
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nm
decl_stmt|,
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|scr
decl_stmt|;
specifier|register
name|struct
name|keynames
modifier|*
name|kp
decl_stmt|;
for|for
control|(
name|scr
operator|=
name|nm
init|;
operator|*
name|scr
operator|=
name|toupper
argument_list|(
operator|*
name|scr
argument_list|)
condition|;
name|scr
operator|++
control|)
empty_stmt|;
for|for
control|(
name|kp
operator|=
name|keys
init|;
name|kp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|kp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|kp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%cP1;1|%s/"
argument_list|,
name|ESC
argument_list|,
name|kp
operator|->
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|val
condition|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|val
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c\\"
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad key name: %s\n"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* bad key name, give up */
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|clearkeys
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%cP0;1|%c\\"
argument_list|,
name|ESC
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|lockkeys
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%cP1;0|%c\\"
argument_list|,
name|ESC
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-cil] [keyname string keyname string...]\n\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The following options are available\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-c\tclears keys first\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-l\t[sets then] locks further setting\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-i\tfirst read initialization file $HOME/%s\n"
argument_list|,
name|INITFILE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(note that the only way to unlock is via Set-Up)\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keyname is one of:\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keys
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|keys
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nKeyname is SHIFTED function key that sends the string\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Strings may need quoting to protect from shell\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You must specify an option or key,string pairs\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* This routine process the INITFILE.  This file expects lines in the format<ws> keyname ws string     Where ws is white space (spaces or tabs) and<ws> is optional white space.    The string may include spaces or tabs and need not be quoted.  If the    string has the sequence of "\n" then a newline character is included in    the string.     examples:          F6      ls -lg\n         F7      uulog -s  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_macro
name|getinit
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|home
decl_stmt|;
comment|/* user's home directory                */
name|char
name|path
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* full path name of init file          */
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* buffer to hold 1 line from init file */
name|char
name|key
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* buffer, to hold specified fcn key    */
name|char
name|keystr
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* string associated with fcn key       */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* pointer to transverse buf            */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* array indices                        */
name|int
name|statflag
decl_stmt|;
comment|/* whether init file is regular& readable */
name|struct
name|stat
name|statbuf
decl_stmt|;
comment|/* stat of the init file                */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* file pointer to init file            */
comment|/* construct full path name for init file */
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|home
argument_list|,
name|INITFILE
argument_list|)
expr_stmt|;
comment|/* check status if init file    */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|statflag
operator|=
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|&&
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IREAD
expr_stmt|;
if|if
condition|(
operator|!
name|statflag
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"couldn't open initalization file: %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* process lines from init file */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* variable initializations */
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|keystr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
operator|||
operator|*
name|ptr
operator|==
literal|'\t'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/*skip whitespace*/
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
break|break;
comment|/* we hit an emtpy line          */
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
comment|/* get keyname   */
name|key
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|key
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* place EOS in buffer */
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
operator|||
operator|*
name|ptr
operator|==
literal|'\t'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/*skip whitespace*/
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\n'
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
comment|/* get string    */
block|{
comment|/* check if string is to include newline i.e. \n        */
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'n'
condition|)
block|{
name|keystr
index|[
name|j
index|]
operator|=
literal|'\012'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
else|else
name|keystr
index|[
name|j
index|]
operator|=
operator|*
name|ptr
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|keystr
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* place EOS in buffer  */
name|dokey
argument_list|(
name|key
argument_list|,
name|keystr
argument_list|)
expr_stmt|;
comment|/* load key with string */
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"init file %s not found\n\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
end_block

end_unit

