begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Send a compressed CTM delta to a recipient mailing list by encoding it  * in safe ASCII characters, in mailer-friendly chunks, and passing it  * to sendmail.  The encoding is almost the same as MIME BASE64, and is  * protected by a simple checksum.  *  * Author: Stephen McKay  *  * NOTICE: This is free software.  I hope you get some use from this program.  * In return you should think about all the nice people who give away software.  * Maybe you should write some free software too.  *  * $Id: ctm_smail.c,v 1.6 1996/07/01 20:54:11 gpalmer Exp $  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_define
define|#
directive|define
name|DEF_MAX_MSG
value|64000
end_define

begin_comment
comment|/* Default maximum mail msg minus headers. */
end_comment

begin_define
define|#
directive|define
name|LINE_LENGTH
value|76
end_define

begin_comment
comment|/* Chars per encode line. Divisible by 4. */
end_comment

begin_function_decl
name|void
name|chop_and_send
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_msg_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chop_and_queue
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_msg_size
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|encode_body
parameter_list|(
name|FILE
modifier|*
name|sm_fp
parameter_list|,
name|FILE
modifier|*
name|delta_fp
parameter_list|,
name|long
name|msg_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_header
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|int
name|pce
parameter_list|,
name|int
name|npieces
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_trailer
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|unsigned
name|sum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|apologise
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_ctm_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|open_sendmail
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|close_sendmail
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lock_queuedir
parameter_list|(
name|char
modifier|*
name|queue_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_lock
parameter_list|(
name|int
name|lockf
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_to_queue
parameter_list|(
name|char
modifier|*
name|queue_dir
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|int
name|npieces
parameter_list|,
name|char
modifier|*
modifier|*
name|tempnames
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|delta_file
decl_stmt|;
name|char
modifier|*
name|mail_alias
decl_stmt|;
name|long
name|max_msg_size
init|=
name|DEF_MAX_MSG
decl_stmt|;
name|long
name|max_ctm_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|log_file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|queue_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|err_prog_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OPTIONS
argument_list|(
literal|"[-l log] [-m maxmsgsize] [-c maxctmsize] [-q queuedir] ctm-delta mail-alias"
argument_list|)
name|NUMBER
argument_list|(
literal|'m'
argument_list|,
argument|max_msg_size
argument_list|)
name|NUMBER
argument_list|(
literal|'c'
argument_list|,
argument|max_ctm_size
argument_list|)
name|STRING
argument_list|(
literal|'l'
argument_list|,
argument|log_file
argument_list|)
name|STRING
argument_list|(
literal|'q'
argument_list|,
argument|queue_dir
argument_list|)
name|ENDOPTS
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|log_file
operator|!=
name|NULL
condition|)
name|err_set_log
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
name|delta_file
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|mail_alias
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|delta_file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"%s: %s"
argument_list|,
name|delta_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_ctm_size
operator|!=
literal|0
operator|&&
name|sb
operator|.
name|st_size
operator|>
name|max_ctm_size
condition|)
name|apologise
argument_list|(
name|delta_file
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|max_ctm_size
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|queue_dir
operator|==
name|NULL
condition|)
name|chop_and_send
argument_list|(
name|delta_file
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|max_msg_size
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
else|else
name|chop_and_queue
argument_list|(
name|delta_file
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|max_msg_size
argument_list|,
name|queue_dir
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Carve our CTM delta into pieces, encode them, and send them.  */
end_comment

begin_function
name|void
name|chop_and_send
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_msg_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
block|{
name|int
name|npieces
decl_stmt|;
name|long
name|msg_size
decl_stmt|;
name|long
name|exp_size
decl_stmt|;
name|int
name|pce
decl_stmt|;
name|FILE
modifier|*
name|sfp
decl_stmt|;
name|FILE
modifier|*
name|dfp
decl_stmt|;
name|unsigned
name|sum
decl_stmt|;
ifdef|#
directive|ifdef
name|howmany
undef|#
directive|undef
name|howmany
endif|#
directive|endif
define|#
directive|define
name|howmany
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + ((y) - 1)) / (y))
comment|/*      * Work out how many pieces we need, bearing in mind that each piece      * grows by 4/3 when encoded.  We count the newlines too, but ignore      * all mail headers and piece headers.  They are a "small" (almost      * constant) per message overhead that we make the user worry about. :-)      */
name|exp_size
operator|=
name|ctm_size
operator|*
literal|4
operator|/
literal|3
expr_stmt|;
name|exp_size
operator|+=
name|howmany
argument_list|(
name|exp_size
argument_list|,
name|LINE_LENGTH
argument_list|)
expr_stmt|;
name|npieces
operator|=
name|howmany
argument_list|(
name|exp_size
argument_list|,
name|max_msg_size
argument_list|)
expr_stmt|;
name|msg_size
operator|=
name|howmany
argument_list|(
name|ctm_size
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|howmany
if|if
condition|(
operator|(
name|dfp
operator|=
name|fopen
argument_list|(
name|delta
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"cannot open '%s' for reading."
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pce
operator|=
literal|1
init|;
name|pce
operator|<=
name|npieces
condition|;
name|pce
operator|++
control|)
block|{
name|sfp
operator|=
name|open_sendmail
argument_list|()
expr_stmt|;
if|if
condition|(
name|sfp
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_header
argument_list|(
name|sfp
argument_list|,
name|mail_alias
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
name|sum
operator|=
name|encode_body
argument_list|(
name|sfp
argument_list|,
name|dfp
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
name|write_trailer
argument_list|(
name|sfp
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|close_sendmail
argument_list|(
name|sfp
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"%s %d/%d sent to %s"
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Carve our CTM delta into pieces, encode them, and drop them in the  * queue dir.  *  * Basic algorythm:  *  * - for (each piece)  * -   gen. temp. file name (one which the de-queuer will ignore)  * -   record in array  * -   open temp. file  * -   encode delta (including headers) into the temp file  * -   close temp. file  * - end  * - lock queue directory  * - foreach (temp. file)  * -   rename to the proper filename  * - end  * - unlock queue directory  *  * This is probably overkill, but it means that incomplete deltas  * don't get mailed, and also reduces the window for lock races  * between ctm_smail and the de-queueing process.  */
end_comment

begin_function
name|void
name|chop_and_queue
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_msg_size
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
block|{
name|int
name|npieces
decl_stmt|,
name|pce
decl_stmt|,
name|len
decl_stmt|;
name|long
name|msg_size
decl_stmt|,
name|exp_size
decl_stmt|;
name|FILE
modifier|*
name|sfp
decl_stmt|,
modifier|*
name|dfp
decl_stmt|;
name|unsigned
name|sum
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempnames
decl_stmt|,
modifier|*
name|tempnam
decl_stmt|,
modifier|*
name|sn
decl_stmt|;
define|#
directive|define
name|howmany
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + ((y) - 1)) / (y))
comment|/*      * Work out how many pieces we need, bearing in mind that each piece      * grows by 4/3 when encoded.  We count the newlines too, but ignore      * all mail headers and piece headers.  They are a "small" (almost      * constant) per message overhead that we make the user worry about. :-)      */
name|exp_size
operator|=
name|ctm_size
operator|*
literal|4
operator|/
literal|3
expr_stmt|;
name|exp_size
operator|+=
name|howmany
argument_list|(
name|exp_size
argument_list|,
name|LINE_LENGTH
argument_list|)
expr_stmt|;
name|npieces
operator|=
name|howmany
argument_list|(
name|exp_size
argument_list|,
name|max_msg_size
argument_list|)
expr_stmt|;
name|msg_size
operator|=
name|howmany
argument_list|(
name|ctm_size
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|howmany
comment|/*      * allocate space for the array of filenames. Try to be portable      * by not assuming anything to do with sizeof(char *)      */
name|tempnames
operator|=
name|malloc
argument_list|(
name|npieces
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempnames
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"malloc for tempnames failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|queue_dir
argument_list|)
operator|+
literal|16
expr_stmt|;
name|tempnam
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempnam
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"malloc for tempnames failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dfp
operator|=
name|fopen
argument_list|(
name|delta
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"cannot open '%s' for reading."
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sn
operator|=
name|strrchr
argument_list|(
name|delta
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sn
operator|=
name|delta
expr_stmt|;
else|else
name|sn
operator|++
expr_stmt|;
for|for
control|(
name|pce
operator|=
literal|1
init|;
name|pce
operator|<=
name|npieces
condition|;
name|pce
operator|++
control|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|tempnam
argument_list|,
name|len
argument_list|,
literal|"%s/.%08d-%03d"
argument_list|,
name|queue_dir
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|pce
argument_list|)
operator|>=
name|len
condition|)
name|err
argument_list|(
literal|"Whoops! tempnam isn't long enough"
argument_list|)
expr_stmt|;
name|tempnames
index|[
name|pce
operator|-
literal|1
index|]
operator|=
name|strdup
argument_list|(
name|tempnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempnames
index|[
name|pce
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"strdup failed for temp. filename"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sfp
operator|=
name|fopen
argument_list|(
name|tempnam
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfp
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_header
argument_list|(
name|sfp
argument_list|,
name|mail_alias
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
name|sum
operator|=
name|encode_body
argument_list|(
name|sfp
argument_list|,
name|dfp
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
name|write_trailer
argument_list|(
name|sfp
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|sfp
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"%s %d/%d created succesfully"
argument_list|,
name|sn
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
block|}
name|add_to_queue
argument_list|(
name|queue_dir
argument_list|,
name|mail_alias
argument_list|,
name|delta
argument_list|,
name|npieces
argument_list|,
name|tempnames
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MIME BASE64 encode table.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|to_b64
index|[
literal|0x40
index|]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This cheap plastic checksum effectively rotates our checksum-so-far  * left one, then adds the character.  We only want 16 bits of it, and  * don't care what happens to the rest.  It ain't much, but it's small.  */
end_comment

begin_define
define|#
directive|define
name|add_ck
parameter_list|(
name|sum
parameter_list|,
name|x
parameter_list|)
define|\
value|((sum) += ((x)&0xff) + (sum) + (((sum)&0x8000) ? 1 : 0))
end_define

begin_comment
comment|/*  * Encode the body.  Use an encoding almost the same as MIME BASE64.  *  * Characters are read from delta_fp and encoded characters are written  * to sm_fp.  At most 'msg_size' characters should be read from delta_fp.  *  * The body consists of lines of up to LINE_LENGTH characters.  Each group  * of 4 characters encodes 3 input characters.  Each output character encodes  * 6 bits.  Thus 64 different characters are needed in this representation.  */
end_comment

begin_function
name|unsigned
name|encode_body
parameter_list|(
name|FILE
modifier|*
name|sm_fp
parameter_list|,
name|FILE
modifier|*
name|delta_fp
parameter_list|,
name|long
name|msg_size
parameter_list|)
block|{
name|unsigned
name|short
name|cksum
init|=
literal|0xffff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|int
name|want
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
name|inbuf
index|[
name|LINE_LENGTH
operator|*
literal|3
operator|/
literal|4
index|]
decl_stmt|;
name|char
name|outbuf
index|[
name|LINE_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
comment|/*      * Round up to the nearest line boundary, for the tiniest of gains,      * and lots of neatness. :-)      */
name|msg_size
operator|+=
operator|(
name|LINE_LENGTH
operator|*
literal|3
operator|/
literal|4
operator|)
operator|-
literal|1
expr_stmt|;
name|msg_size
operator|-=
name|msg_size
operator|%
operator|(
name|LINE_LENGTH
operator|*
literal|3
operator|/
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|msg_size
operator|>
literal|0
condition|)
block|{
name|want
operator|=
operator|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
operator|)
condition|?
name|msg_size
else|:
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|want
argument_list|,
name|delta_fp
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|msg_size
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|add_ck
argument_list|(
name|cksum
argument_list|,
name|inbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Produce a line of encoded data.  Every line length will be a 	 * multiple of 4, except for, perhaps, the last line. 	 */
name|ip
operator|=
name|inbuf
expr_stmt|;
name|op
operator|=
name|outbuf
expr_stmt|;
while|while
condition|(
name|n
operator|>=
literal|3
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|0
index|]
operator|>>
literal|2
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
operator|(
name|ip
index|[
literal|0
index|]
operator|<<
literal|4
operator|&
literal|0x3f
operator|)
operator||
name|ip
index|[
literal|1
index|]
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
operator|(
name|ip
index|[
literal|1
index|]
operator|<<
literal|2
operator|&
literal|0x3f
operator|)
operator||
name|ip
index|[
literal|2
index|]
operator|>>
literal|6
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|2
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|0
index|]
operator|>>
literal|2
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
operator|(
name|ip
index|[
literal|0
index|]
operator|<<
literal|4
operator|&
literal|0x3f
operator|)
operator||
name|ip
index|[
literal|1
index|]
operator|>>
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|2
condition|)
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|1
index|]
operator|<<
literal|2
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|fwrite
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|op
operator|-
name|outbuf
argument_list|,
name|sm_fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|delta_fp
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"error reading input file."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|sm_fp
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"error writing encoded file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|cksum
return|;
block|}
end_function

begin_comment
comment|/*  * Write the mail header and data header.  */
end_comment

begin_function
name|void
name|write_header
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|int
name|pce
parameter_list|,
name|int
name|npieces
parameter_list|)
block|{
name|char
modifier|*
name|sn
decl_stmt|;
if|if
condition|(
operator|(
name|sn
operator|=
name|strrchr
argument_list|(
name|delta
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sn
operator|=
name|delta
expr_stmt|;
else|else
name|sn
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"From: owner-%s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"Subject: ctm-mail %s %d/%d\n\n"
argument_list|,
name|sn
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"CTM_MAIL BEGIN %s %d %d\n"
argument_list|,
name|sn
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the data trailer.  */
end_comment

begin_function
name|void
name|write_trailer
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|unsigned
name|sum
parameter_list|)
block|{
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"CTM_MAIL END %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We're terribly sorry, but the delta is too big to send.  */
end_comment

begin_function
name|void
name|apologise
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_ctm_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
block|{
name|FILE
modifier|*
name|sfp
decl_stmt|;
name|char
modifier|*
name|sn
decl_stmt|;
name|sfp
operator|=
name|open_sendmail
argument_list|()
expr_stmt|;
if|if
condition|(
name|sfp
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sn
operator|=
name|strrchr
argument_list|(
name|delta
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sn
operator|=
name|delta
expr_stmt|;
else|else
name|sn
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"From: %s-owner\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"Subject: ctm-notice %s\n\n"
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"%s is %ld bytes.  The limit is %ld bytes.\n\n"
argument_list|,
name|sn
argument_list|,
operator|(
name|long
operator|)
name|ctm_size
argument_list|,
name|max_ctm_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"You can retrieve this delta via ftpmail, or your good mate at the university.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|close_sendmail
argument_list|(
name|sfp
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a pipe to sendmail.  Sendmail will decode the destination  * from the message contents.  */
end_comment

begin_function
name|FILE
modifier|*
name|open_sendmail
parameter_list|()
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s -odq -t"
argument_list|,
name|_PATH_SENDMAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"cannot start sendmail"
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Close a pipe to sendmail.  Sendmail will then do its bit.  * Return 1 on success, 0 on failure.  */
end_comment

begin_function
name|int
name|close_sendmail
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"error writing to sendmail"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|pclose
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|"sendmail failed with status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the queuedir so we're the only guy messing about in there.  */
end_comment

begin_function
name|int
name|lock_queuedir
parameter_list|(
name|char
modifier|*
name|queue_dir
parameter_list|)
block|{
name|int
name|fp
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|queue_dir
argument_list|)
operator|+
literal|8
expr_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"malloc failed in lock_queuedir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|"%s/.lock"
argument_list|,
name|queue_dir
argument_list|)
operator|>=
name|len
condition|)
name|err
argument_list|(
literal|"Whoops. lock buffer too small in lock_queuedir"
argument_list|)
expr_stmt|;
comment|/*      * We do our own lockfile scanning to avoid unlink races. 60      * seconds should be enough to ensure that we won't get more races      * happening between the stat and the open/flock.      */
while|while
condition|(
name|stat
argument_list|(
name|buffer
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|buffer
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXLOCK
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"can't open `%s' in lock_queuedir"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|"%8ld"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fp
argument_list|,
name|buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the queuedir so we're the only guy messing about in there.  */
end_comment

begin_function
name|void
name|free_lock
parameter_list|(
name|int
name|lockf
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/*      * Most important: free the lock before we do anything else!      */
name|close
argument_list|(
name|lockf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|queue_dir
argument_list|)
operator|+
literal|7
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"malloc failed in free_lock"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snprintf
argument_list|(
name|path
argument_list|,
name|len
argument_list|,
literal|"%s/.lock"
argument_list|,
name|queue_dir
argument_list|)
operator|>=
name|len
condition|)
name|err
argument_list|(
literal|"lock path buffer too small in free_lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"can't unlink lockfile `%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move everything into the queue directory. */
end_comment

begin_function
name|void
name|add_to_queue
parameter_list|(
name|char
modifier|*
name|queue_dir
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|int
name|npieces
parameter_list|,
name|char
modifier|*
modifier|*
name|tempnames
parameter_list|)
block|{
name|char
modifier|*
name|queuefile
decl_stmt|,
modifier|*
name|sn
decl_stmt|;
name|int
name|pce
decl_stmt|,
name|len
decl_stmt|,
name|lockf
decl_stmt|;
if|if
condition|(
operator|(
name|sn
operator|=
name|strrchr
argument_list|(
name|delta
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sn
operator|=
name|delta
expr_stmt|;
else|else
name|sn
operator|++
expr_stmt|;
comment|/* try to malloc all we need BEFORE entering the lock loop */
name|len
operator|=
name|strlen
argument_list|(
name|queue_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|sn
argument_list|)
operator|+
literal|7
expr_stmt|;
name|queuefile
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|queuefile
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"can't malloc for queuefile"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * We should be the only process mucking around in the queue      * directory while we add the new queue files ... it could be      * awkward if the de-queue process starts it's job while we're      * adding files ...      */
name|lockf
operator|=
name|lock_queuedir
argument_list|(
name|queue_dir
argument_list|)
expr_stmt|;
for|for
control|(
name|pce
operator|=
literal|0
init|;
name|pce
operator|<
name|npieces
condition|;
name|pce
operator|++
control|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|queuefile
argument_list|,
name|len
argument_list|,
literal|"%s/%s+%03d"
argument_list|,
name|queue_dir
argument_list|,
name|sn
argument_list|,
name|pce
operator|+
literal|1
argument_list|)
operator|>=
name|len
condition|)
name|err
argument_list|(
literal|"whoops, queuefile buffer is too small"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|queuefile
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"WOAH! Queue file `%s' already exists! Bailing out."
argument_list|,
name|queuefile
argument_list|)
expr_stmt|;
name|free_lock
argument_list|(
name|lockf
argument_list|,
name|queue_dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rename
argument_list|(
name|tempnames
index|[
name|pce
index|]
argument_list|,
name|queuefile
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"Queue file %s now exists"
argument_list|,
name|queuefile
argument_list|)
expr_stmt|;
block|}
name|free_lock
argument_list|(
name|lockf
argument_list|,
name|queue_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queuefile
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

