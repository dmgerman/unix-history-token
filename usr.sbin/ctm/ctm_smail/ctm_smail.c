begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Send a compressed CTM delta to a recipient mailing list by encoding it  * in safe ASCII characters, in mailer-friendly chunks, and passing them  * to sendmail.  Optionally, the chunks can be queued to be sent later by  * ctm_dequeue in controlled bursts.  The encoding is almost the same as  * MIME BASE64, and is protected by a simple checksum.  *  * Author: Stephen McKay  *  * NOTICE: This is free software.  I hope you get some use from this program.  * In return you should think about all the nice people who give away software.  * Maybe you should write some free software too.  *  * $Id$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_define
define|#
directive|define
name|DEF_MAX_MSG
value|64000
end_define

begin_comment
comment|/* Default maximum mail msg minus headers. */
end_comment

begin_define
define|#
directive|define
name|LINE_LENGTH
value|76
end_define

begin_comment
comment|/* Chars per encoded line. Divisible by 4. */
end_comment

begin_function_decl
name|int
name|chop_and_send_or_queue
parameter_list|(
name|FILE
modifier|*
name|dfp
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_msg_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chop_and_send
parameter_list|(
name|FILE
modifier|*
name|dfp
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|long
name|msg_size
parameter_list|,
name|int
name|npieces
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chop_and_queue
parameter_list|(
name|FILE
modifier|*
name|dfp
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|long
name|msg_size
parameter_list|,
name|int
name|npieces
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clean_up_queue
parameter_list|(
name|char
modifier|*
name|queue_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|encode_body
parameter_list|(
name|FILE
modifier|*
name|sm_fp
parameter_list|,
name|FILE
modifier|*
name|delta_fp
parameter_list|,
name|long
name|msg_size
parameter_list|,
name|unsigned
modifier|*
name|sum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_header
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|int
name|pce
parameter_list|,
name|int
name|npieces
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_trailer
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|unsigned
name|sum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|apologise
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_ctm_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|open_sendmail
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|close_sendmail
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|delta_file
decl_stmt|;
name|char
modifier|*
name|mail_alias
decl_stmt|;
name|long
name|max_msg_size
init|=
name|DEF_MAX_MSG
decl_stmt|;
name|long
name|max_ctm_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|log_file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|queue_dir
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|delta
decl_stmt|;
name|FILE
modifier|*
name|dfp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|err_prog_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OPTIONS
argument_list|(
literal|"[-l log] [-m maxmsgsize] [-c maxctmsize] [-q queuedir] ctm-delta mail-alias"
argument_list|)
name|NUMBER
argument_list|(
literal|'m'
argument_list|,
argument|max_msg_size
argument_list|)
name|NUMBER
argument_list|(
literal|'c'
argument_list|,
argument|max_ctm_size
argument_list|)
name|STRING
argument_list|(
literal|'l'
argument_list|,
argument|log_file
argument_list|)
name|STRING
argument_list|(
literal|'q'
argument_list|,
argument|queue_dir
argument_list|)
name|ENDOPTS
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|log_file
operator|!=
name|NULL
condition|)
name|err_set_log
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
name|delta_file
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|mail_alias
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|=
name|strrchr
argument_list|(
name|delta_file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|delta
operator|=
name|delta_file
expr_stmt|;
else|else
name|delta
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dfp
operator|=
name|fopen
argument_list|(
name|delta_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|dfp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"*%s"
argument_list|,
name|delta_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_ctm_size
operator|!=
literal|0
operator|&&
name|sb
operator|.
name|st_size
operator|>
name|max_ctm_size
condition|)
name|status
operator|=
name|apologise
argument_list|(
name|delta
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|max_ctm_size
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|chop_and_send_or_queue
argument_list|(
name|dfp
argument_list|,
name|delta
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|max_msg_size
argument_list|,
name|mail_alias
argument_list|,
name|queue_dir
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Carve our CTM delta into pieces, encode them, and send or queue them.  * Returns 0 on success, and 1 on failure.  */
end_comment

begin_function
name|int
name|chop_and_send_or_queue
parameter_list|(
name|FILE
modifier|*
name|dfp
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_msg_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|)
block|{
name|int
name|npieces
decl_stmt|;
name|long
name|msg_size
decl_stmt|;
name|long
name|exp_size
decl_stmt|;
name|int
name|status
decl_stmt|;
undef|#
directive|undef
name|howmany
define|#
directive|define
name|howmany
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)+((y)-1)) / (y))
comment|/*      * Work out how many pieces we need, bearing in mind that each piece      * grows by 4/3 when encoded.  We count the newlines too, but ignore      * all mail headers and piece headers.  They are a "small" (almost      * constant) per message overhead that we make the user worry about. :-)      */
name|exp_size
operator|=
name|ctm_size
operator|*
literal|4
operator|/
literal|3
expr_stmt|;
name|exp_size
operator|+=
name|howmany
argument_list|(
name|exp_size
argument_list|,
name|LINE_LENGTH
argument_list|)
expr_stmt|;
name|npieces
operator|=
name|howmany
argument_list|(
name|exp_size
argument_list|,
name|max_msg_size
argument_list|)
expr_stmt|;
name|msg_size
operator|=
name|howmany
argument_list|(
name|ctm_size
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|howmany
if|if
condition|(
name|queue_dir
operator|==
name|NULL
condition|)
name|status
operator|=
name|chop_and_send
argument_list|(
name|dfp
argument_list|,
name|delta
argument_list|,
name|msg_size
argument_list|,
name|npieces
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|chop_and_queue
argument_list|(
name|dfp
argument_list|,
name|delta
argument_list|,
name|msg_size
argument_list|,
name|npieces
argument_list|,
name|mail_alias
argument_list|,
name|queue_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|clean_up_queue
argument_list|(
name|queue_dir
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Carve our CTM delta into pieces, encode them, and send them.  * Returns 0 on success, and 1 on failure.  */
end_comment

begin_function
name|int
name|chop_and_send
parameter_list|(
name|FILE
modifier|*
name|dfp
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|long
name|msg_size
parameter_list|,
name|int
name|npieces
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
block|{
name|int
name|pce
decl_stmt|;
name|FILE
modifier|*
name|sfp
decl_stmt|;
name|unsigned
name|sum
decl_stmt|;
comment|/*      * Send each chunk directly to sendmail as it is generated.      * No temporary files necessary.  If things turn ugly, we just      * have to live with the fact the we have sent only part of      * the delta.      */
for|for
control|(
name|pce
operator|=
literal|1
init|;
name|pce
operator|<=
name|npieces
condition|;
name|pce
operator|++
control|)
block|{
name|int
name|read_error
decl_stmt|;
if|if
condition|(
operator|(
name|sfp
operator|=
name|open_sendmail
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|write_header
argument_list|(
name|sfp
argument_list|,
name|mail_alias
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
name|read_error
operator|=
name|encode_body
argument_list|(
name|sfp
argument_list|,
name|dfp
argument_list|,
name|msg_size
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_error
condition|)
name|write_trailer
argument_list|(
name|sfp
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|close_sendmail
argument_list|(
name|sfp
argument_list|)
operator|||
name|read_error
condition|)
return|return
literal|1
return|;
name|err
argument_list|(
literal|"%s %d/%d sent to %s"
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Construct the tmp queue file name of a delta piece.  */
end_comment

begin_define
define|#
directive|define
name|mk_tmp_name
parameter_list|(
name|fn
parameter_list|,
name|qd
parameter_list|,
name|p
parameter_list|)
define|\
value|sprintf((fn), "%s/.%08ld.%03d", (qd), (long)getpid(), (p))
end_define

begin_comment
comment|/*  * Construct the final queue file name of a delta piece.  */
end_comment

begin_define
define|#
directive|define
name|mk_queue_name
parameter_list|(
name|fn
parameter_list|,
name|qd
parameter_list|,
name|d
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
define|\
value|sprintf((fn), "%s/%s+%03d-%03d", (qd), (d), (p), (n))
end_define

begin_comment
comment|/*  * Carve our CTM delta into pieces, encode them, and queue them.  * Returns 0 on success, and 1 on failure.  */
end_comment

begin_function
name|int
name|chop_and_queue
parameter_list|(
name|FILE
modifier|*
name|dfp
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|long
name|msg_size
parameter_list|,
name|int
name|npieces
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|queue_dir
parameter_list|)
block|{
name|int
name|pce
decl_stmt|;
name|FILE
modifier|*
name|qfp
decl_stmt|;
name|unsigned
name|sum
decl_stmt|;
name|char
name|tname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|qname
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/*      * Store each piece in the queue directory, but under temporary names,      * so that they can be deleted without unpleasant consequences if      * anything goes wrong.  We could easily fill up a disk, for example.      */
for|for
control|(
name|pce
operator|=
literal|1
init|;
name|pce
operator|<=
name|npieces
condition|;
name|pce
operator|++
control|)
block|{
name|int
name|write_error
decl_stmt|;
name|mk_tmp_name
argument_list|(
name|tname
argument_list|,
name|queue_dir
argument_list|,
name|pce
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qfp
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"cannot open '%s' for writing"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|write_header
argument_list|(
name|qfp
argument_list|,
name|mail_alias
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
if|if
condition|(
name|encode_body
argument_list|(
name|qfp
argument_list|,
name|dfp
argument_list|,
name|msg_size
argument_list|,
operator|&
name|sum
argument_list|)
condition|)
return|return
literal|1
return|;
name|write_trailer
argument_list|(
name|qfp
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|write_error
operator|=
name|ferror
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_error
condition|)
block|{
name|err
argument_list|(
literal|"error writing '%s'"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Give the warm success message now, instead of all in a rush 	 * during the rename phase. 	 */
name|err
argument_list|(
literal|"%s %d/%d queued for %s"
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
block|}
comment|/*      * Rename the pieces into place.  If an error occurs now, we are      * stuffed, but there is no neat way to back out.  rename() should      * only fail now under extreme circumstances.      */
for|for
control|(
name|pce
operator|=
literal|1
init|;
name|pce
operator|<=
name|npieces
condition|;
name|pce
operator|++
control|)
block|{
name|mk_tmp_name
argument_list|(
name|tname
argument_list|,
name|queue_dir
argument_list|,
name|pce
argument_list|)
expr_stmt|;
name|mk_queue_name
argument_list|(
name|qname
argument_list|,
name|queue_dir
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tname
argument_list|,
name|qname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"*rename: '%s' to '%s'"
argument_list|,
name|tname
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * There may be temporary files cluttering up the queue directory.  */
end_comment

begin_function
name|void
name|clean_up_queue
parameter_list|(
name|char
modifier|*
name|queue_dir
parameter_list|)
block|{
name|int
name|pce
decl_stmt|;
name|char
name|tname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|err
argument_list|(
literal|"discarding queued delta pieces"
argument_list|)
expr_stmt|;
for|for
control|(
name|pce
operator|=
literal|1
init|;
condition|;
name|pce
operator|++
control|)
block|{
name|mk_tmp_name
argument_list|(
name|tname
argument_list|,
name|queue_dir
argument_list|,
name|pce
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|tname
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * MIME BASE64 encode table.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|to_b64
index|[
literal|0x40
index|]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This cheap plastic checksum effectively rotates our checksum-so-far  * left one, then adds the character.  We only want 16 bits of it, and  * don't care what happens to the rest.  It ain't much, but it's small.  */
end_comment

begin_define
define|#
directive|define
name|add_ck
parameter_list|(
name|sum
parameter_list|,
name|x
parameter_list|)
define|\
value|((sum) += ((x)&0xff) + (sum) + (((sum)&0x8000) ? 1 : 0))
end_define

begin_comment
comment|/*  * Encode the body.  Use an encoding almost the same as MIME BASE64.  *  * Characters are read from delta_fp and encoded characters are written  * to sm_fp.  At most 'msg_size' characters should be read from delta_fp.  *  * The body consists of lines of up to LINE_LENGTH characters.  Each group  * of 4 characters encodes 3 input characters.  Each output character encodes  * 6 bits.  Thus 64 different characters are needed in this representation.  */
end_comment

begin_function
name|int
name|encode_body
parameter_list|(
name|FILE
modifier|*
name|sm_fp
parameter_list|,
name|FILE
modifier|*
name|delta_fp
parameter_list|,
name|long
name|msg_size
parameter_list|,
name|unsigned
modifier|*
name|sum
parameter_list|)
block|{
name|unsigned
name|short
name|cksum
init|=
literal|0xffff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|int
name|want
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
name|inbuf
index|[
name|LINE_LENGTH
operator|*
literal|3
operator|/
literal|4
index|]
decl_stmt|;
name|char
name|outbuf
index|[
name|LINE_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
comment|/*      * Round up to the nearest line boundary, for the tiniest of gains,      * and lots of neatness. :-)      */
name|msg_size
operator|+=
operator|(
name|LINE_LENGTH
operator|*
literal|3
operator|/
literal|4
operator|)
operator|-
literal|1
expr_stmt|;
name|msg_size
operator|-=
name|msg_size
operator|%
operator|(
name|LINE_LENGTH
operator|*
literal|3
operator|/
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|msg_size
operator|>
literal|0
condition|)
block|{
name|want
operator|=
operator|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
operator|)
condition|?
name|msg_size
else|:
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|want
argument_list|,
name|delta_fp
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|msg_size
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|add_ck
argument_list|(
name|cksum
argument_list|,
name|inbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Produce a line of encoded data.  Every line length will be a 	 * multiple of 4, except for, perhaps, the last line. 	 */
name|ip
operator|=
name|inbuf
expr_stmt|;
name|op
operator|=
name|outbuf
expr_stmt|;
while|while
condition|(
name|n
operator|>=
literal|3
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|0
index|]
operator|>>
literal|2
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
operator|(
name|ip
index|[
literal|0
index|]
operator|<<
literal|4
operator|&
literal|0x3f
operator|)
operator||
name|ip
index|[
literal|1
index|]
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
operator|(
name|ip
index|[
literal|1
index|]
operator|<<
literal|2
operator|&
literal|0x3f
operator|)
operator||
name|ip
index|[
literal|2
index|]
operator|>>
literal|6
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|2
index|]
operator|&
literal|0x3f
index|]
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
name|n
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|0
index|]
operator|>>
literal|2
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
operator|(
name|ip
index|[
literal|0
index|]
operator|<<
literal|4
operator|&
literal|0x3f
operator|)
operator||
name|ip
index|[
literal|1
index|]
operator|>>
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|2
condition|)
operator|*
name|op
operator|++
operator|=
name|to_b64
index|[
name|ip
index|[
literal|1
index|]
operator|<<
literal|2
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|fwrite
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|op
operator|-
name|outbuf
argument_list|,
name|sm_fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|delta_fp
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"error reading input file."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|sum
operator|=
name|cksum
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write the mail header and data header.  */
end_comment

begin_function
name|void
name|write_header
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|,
name|char
modifier|*
name|delta
parameter_list|,
name|int
name|pce
parameter_list|,
name|int
name|npieces
parameter_list|)
block|{
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"From: owner-%s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"Subject: ctm-mail %s %d/%d\n\n"
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"CTM_MAIL BEGIN %s %d %d\n"
argument_list|,
name|delta
argument_list|,
name|pce
argument_list|,
name|npieces
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the data trailer.  */
end_comment

begin_function
name|void
name|write_trailer
parameter_list|(
name|FILE
modifier|*
name|sfp
parameter_list|,
name|unsigned
name|sum
parameter_list|)
block|{
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"CTM_MAIL END %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We're terribly sorry, but the delta is too big to send.  * Returns 0 on success, 1 on failure.  */
end_comment

begin_function
name|int
name|apologise
parameter_list|(
name|char
modifier|*
name|delta
parameter_list|,
name|off_t
name|ctm_size
parameter_list|,
name|long
name|max_ctm_size
parameter_list|,
name|char
modifier|*
name|mail_alias
parameter_list|)
block|{
name|FILE
modifier|*
name|sfp
decl_stmt|;
name|sfp
operator|=
name|open_sendmail
argument_list|()
expr_stmt|;
if|if
condition|(
name|sfp
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"From: owner-%s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|mail_alias
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"Subject: ctm-notice %s\n\n"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"%s is %ld bytes.  The limit is %ld bytes.\n\n"
argument_list|,
name|delta
argument_list|,
operator|(
name|long
operator|)
name|ctm_size
argument_list|,
name|max_ctm_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"You can retrieve this delta via ftpmail, "
literal|"or your good mate at the university.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|close_sendmail
argument_list|(
name|sfp
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start a pipe to sendmail.  Sendmail will decode the destination  * from the message contents.  */
end_comment

begin_function
name|FILE
modifier|*
name|open_sendmail
parameter_list|()
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s -odq -t"
argument_list|,
name|_PATH_SENDMAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"cannot start sendmail"
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Close a pipe to sendmail.  Sendmail will then do its bit.  * Return 1 on success, 0 on failure.  */
end_comment

begin_function
name|int
name|close_sendmail
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"error writing to sendmail"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|pclose
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|"sendmail failed with status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
literal|0
operator|)
return|;
block|}
end_function

end_unit

