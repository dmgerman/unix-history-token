begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $Id: ctm.c,v 1.16 1997/02/22 16:05:21 peter Exp $  *  * This is the client program of 'CTM'.  It will apply a CTM-patch to a  * collection of files.  *  * Options we'd like to see:  *  * -a 			Attempt best effort.  * -d<int>		Debug TBD.  * -m<mail-addr>	Email me instead.  * -r<name>		Reconstruct file.  * -R<file>		Read list of files to reconstruct.  *  * Options we have:  * -b<dir>		Base-dir  * -B<file>		Backup to tar-file.  * -t 			Tar command (default as in TARCMD).  * -c			Check it out, don't do anything.  * -F      		Force  * -q 			Tell us less.  * -T<tmpdir>.		Temporary files.  * -u			Set all file modification times to the timestamp  * -v 			Tell us more.  * -V<level>		Tell us more level = number of -v  * -k			Keep files and directories that would have been removed.  * -l			List actions.  *  * Options we don't actually use:  * -p			Less paranoid.  * -P			Paranoid.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/* */
end_comment

begin_include
include|#
directive|include
file|"ctm.h"
end_include

begin_define
define|#
directive|define
name|CTM_STATUS
value|".ctm_status"
end_define

begin_function_decl
specifier|extern
name|int
name|Proc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|applied
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|stat
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|unsigned
name|applied
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|statfile
decl_stmt|;
name|struct
name|CTM_Filter
modifier|*
name|nfilter
init|=
name|NULL
decl_stmt|;
comment|/* new filter */
name|u_char
modifier|*
name|basedir
decl_stmt|;
name|basedir
operator|=
name|NULL
expr_stmt|;
name|Verbose
operator|=
literal|1
expr_stmt|;
name|Paranoid
operator|=
literal|1
expr_stmt|;
name|SetTime
operator|=
literal|0
expr_stmt|;
name|KeepIt
operator|=
literal|0
expr_stmt|;
name|ListIt
operator|=
literal|0
expr_stmt|;
name|BackupFile
operator|=
name|NULL
expr_stmt|;
name|TarCmd
operator|=
name|TARCMD
expr_stmt|;
name|LastFilter
operator|=
name|FilterList
operator|=
name|NULL
expr_stmt|;
name|setbuf
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ab:B:cd:e:Fklm:pPqr:R:t:T:uV:vx:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|basedir
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* Base Directory */
case|case
literal|'B'
case|:
name|BackupFile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|CheckIt
operator|++
expr_stmt|;
break|break;
comment|/* Only check it */
case|case
literal|'F'
case|:
name|Force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|KeepIt
operator|++
expr_stmt|;
break|break;
comment|/* Don't do removes */
case|case
literal|'l'
case|:
name|ListIt
operator|++
expr_stmt|;
break|break;
comment|/* Only list actions and files */
case|case
literal|'p'
case|:
name|Paranoid
operator|--
expr_stmt|;
break|break;
comment|/* Less Paranoid */
case|case
literal|'P'
case|:
name|Paranoid
operator|++
expr_stmt|;
break|break;
comment|/* More Paranoid */
case|case
literal|'q'
case|:
name|Verbose
operator|--
expr_stmt|;
break|break;
comment|/* Quiet */
case|case
literal|'t'
case|:
name|TarCmd
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* archiver command */
case|case
literal|'T'
case|:
name|TmpDir
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* set temporary directory */
case|case
literal|'u'
case|:
name|SetTime
operator|++
expr_stmt|;
break|break;
comment|/* Set timestamp on files */
case|case
literal|'v'
case|:
name|Verbose
operator|++
expr_stmt|;
break|break;
comment|/* Verbose */
case|case
literal|'V'
case|:
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
comment|/* Verbose */
name|Verbose
operator|+=
name|c
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* filter expressions */
case|case
literal|'x'
case|:
if|if
condition|(
name|NULL
operator|==
operator|(
name|nfilter
operator|=
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|CTM_Filter
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"out of memory for expressions: \"%s\""
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|stat
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|nfilter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|CTM_Filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|err
operator|=
name|regcomp
argument_list|(
operator|&
name|nfilter
operator|->
name|CompiledRegex
argument_list|,
name|optarg
argument_list|,
name|REG_NOSUB
argument_list|)
operator|)
condition|)
block|{
name|char
name|errmsg
index|[
literal|128
index|]
decl_stmt|;
name|regerror
argument_list|(
name|err
argument_list|,
operator|&
name|nfilter
operator|->
name|CompiledRegex
argument_list|,
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"regular expression: \"%s\""
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|stat
operator|++
expr_stmt|;
break|break;
block|}
comment|/* note whether the filter enables or disables on match */
name|nfilter
operator|->
name|Action
operator|=
operator|(
operator|(
literal|'e'
operator|==
name|c
operator|)
condition|?
name|CTM_FILTER_ENABLE
else|:
name|CTM_FILTER_DISABLE
operator|)
expr_stmt|;
comment|/* link in the expression into the list */
name|nfilter
operator|->
name|Next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|FilterList
condition|)
block|{
name|LastFilter
operator|=
name|FilterList
operator|=
name|nfilter
expr_stmt|;
comment|/* init head and tail */
block|}
else|else
block|{
comment|/* place at tail */
name|LastFilter
operator|->
name|Next
operator|=
name|nfilter
expr_stmt|;
name|LastFilter
operator|=
name|nfilter
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
name|warnx
argument_list|(
literal|"option '%c' requires an argument"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|stat
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|warnx
argument_list|(
literal|"option '%c' not supported"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|stat
operator|++
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"option '%c' not yet implemented"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stat
condition|)
block|{
name|warnx
argument_list|(
literal|"%d errors during option processing"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
name|Exit_Pilot
return|;
block|}
name|stat
operator|=
name|Exit_Done
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|basedir
operator|==
name|NULL
condition|)
block|{
name|Buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Malloc
argument_list|(
name|BUFSIZ
operator|+
name|strlen
argument_list|(
name|SUBSUFF
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CatPtr
operator|=
name|Buffer
expr_stmt|;
operator|*
name|Buffer
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|Buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|basedir
argument_list|)
operator|+
name|BUFSIZ
operator|+
name|strlen
argument_list|(
name|SUBSUFF
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Buffer
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
name|CatPtr
operator|=
name|Buffer
operator|+
name|strlen
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|CatPtr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|CatPtr
operator|++
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|Buffer
argument_list|,
name|CTM_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ListIt
condition|)
name|applied
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statfile
operator|=
name|fopen
argument_list|(
name|Buffer
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"warning: %s not found"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fscanf
argument_list|(
name|statfile
argument_list|,
literal|"%*s %u"
argument_list|,
operator|&
name|applied
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|statfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argc
condition|)
name|stat
operator||=
name|Proc
argument_list|(
literal|"-"
argument_list|,
name|applied
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|--
operator|&&
name|stat
operator|==
name|Exit_Done
condition|)
block|{
name|stat
operator||=
name|Proc
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|applied
argument_list|)
expr_stmt|;
name|stat
operator|&=
operator|~
operator|(
name|Exit_Version
operator||
name|Exit_NoMatch
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|==
name|Exit_Done
condition|)
name|stat
operator|=
name|Exit_OK
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"exit(%d)"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|FilterList
condition|)
for|for
control|(
name|nfilter
operator|=
name|FilterList
init|;
name|nfilter
condition|;
control|)
block|{
name|struct
name|CTM_Filter
modifier|*
name|tmp
init|=
name|nfilter
operator|->
name|Next
decl_stmt|;
name|Free
argument_list|(
name|nfilter
argument_list|)
expr_stmt|;
name|nfilter
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|stat
return|;
block|}
end_function

begin_function
name|int
name|Proc
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|applied
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".gz"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".Z"
argument_list|)
operator|)
condition|)
block|{
name|p
operator|=
name|alloca
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"gunzip< "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
block|}
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Working on<%s>\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|FileName
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|String
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* If we cannot seek, we're doomed, so copy to a tmp-file in that case */
if|if
condition|(
operator|!
name|p
operator|&&
operator|-
literal|1
operator|==
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fn
init|=
name|tempnam
argument_list|(
name|TmpDir
argument_list|,
literal|"CTMclient"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f2
init|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w+"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|f2
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
name|unlink
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing tmp-file \"%s\"\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|i
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
condition|)
if|if
condition|(
name|EOF
operator|==
name|putc
argument_list|(
name|i
argument_list|,
name|f2
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|f2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Pass1
argument_list|(
name|f
argument_list|,
name|applied
argument_list|)
operator|)
condition|)
goto|goto
name|exit_and_close
goto|;
if|if
condition|(
name|ListIt
condition|)
block|{
name|i
operator|=
name|Exit_Done
expr_stmt|;
goto|goto
name|exit_and_close
goto|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
block|}
name|i
operator|=
name|Pass2
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
block|}
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|Force
operator|)
operator|||
operator|(
name|i
operator|&
operator|~
name|Exit_Forcible
operator|)
condition|)
goto|goto
name|exit_and_close
goto|;
block|}
if|if
condition|(
name|CheckIt
condition|)
block|{
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"All checks out ok.\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|Exit_Done
expr_stmt|;
goto|goto
name|exit_and_close
goto|;
block|}
comment|/* backup files if requested */
if|if
condition|(
name|BackupFile
condition|)
block|{
name|i
operator|=
name|PassB
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
block|}
block|}
name|i
operator|=
name|Pass3
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|exit_and_close
label|:
if|if
condition|(
operator|!
name|p
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"All done ok\n"
argument_list|)
expr_stmt|;
return|return
name|Exit_Done
return|;
block|}
end_function

end_unit

