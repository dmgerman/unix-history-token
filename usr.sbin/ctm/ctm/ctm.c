begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $Id: ctm.c,v 1.12 1996/02/05 16:06:46 phk Exp $  *  * This is the client program of 'CTM'.  It will apply a CTM-patch to a  * collection of files.  *  * Options we'd like to see:  *  * -a 			Attempt best effort.  * -B<file>		Backup to tar-file.  * -d<int>		Debug TBD.  * -m<mail-addr>	Email me instead.  * -r<name>		Reconstruct file.  * -R<file>		Read list of files to reconstruct.  *  * Options we have:  * -b<dir>		Base-dir  * -c			Check it out, don't do anything.  * -F      		Force  * -p			Less paranoid.  * -P			Paranoid.  * -q 			Tell us less.  * -T<tmpdir>.		Temporary files.  * -u			Set all file modification times to the timestamp  * -v 			Tell us more.  * -V<level>		Tell us more level = number of -v  *  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/* */
end_comment

begin_include
include|#
directive|include
file|"ctm.h"
end_include

begin_define
define|#
directive|define
name|CTM_STATUS
value|".ctm_status"
end_define

begin_function_decl
specifier|extern
name|int
name|Proc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|applied
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|stat
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|int
name|optopt
decl_stmt|,
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|unsigned
name|applied
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|statfile
decl_stmt|;
name|u_char
modifier|*
name|basedir
decl_stmt|;
name|basedir
operator|=
name|NULL
expr_stmt|;
name|Verbose
operator|=
literal|1
expr_stmt|;
name|Paranoid
operator|=
literal|1
expr_stmt|;
name|SetTime
operator|=
literal|0
expr_stmt|;
name|setbuf
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ab:B:cd:Fm:pPqr:R:T:uV:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|basedir
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* Base Directory */
case|case
literal|'c'
case|:
name|CheckIt
operator|++
expr_stmt|;
break|break;
comment|/* Only check it */
case|case
literal|'p'
case|:
name|Paranoid
operator|--
expr_stmt|;
break|break;
comment|/* Less Paranoid */
case|case
literal|'P'
case|:
name|Paranoid
operator|++
expr_stmt|;
break|break;
comment|/* More Paranoid */
case|case
literal|'q'
case|:
name|Verbose
operator|--
expr_stmt|;
break|break;
comment|/* Quiet */
case|case
literal|'v'
case|:
name|Verbose
operator|++
expr_stmt|;
break|break;
comment|/* Verbose */
case|case
literal|'T'
case|:
name|TmpDir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|Force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|SetTime
operator|++
expr_stmt|;
break|break;
comment|/* Set timestamp on files */
case|case
literal|'V'
case|:
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
comment|/* Verbose */
name|Verbose
operator|+=
name|c
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Option '%c' requires an argument.\n"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|stat
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Option '%c' not supported.\n"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|stat
operator|++
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Option '%c' not yet implemented.\n"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stat
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d errors during option processing\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
name|Exit_Pilot
return|;
block|}
name|stat
operator|=
name|Exit_Done
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|basedir
operator|==
name|NULL
condition|)
block|{
name|Buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Malloc
argument_list|(
name|BUFSIZ
operator|+
name|strlen
argument_list|(
name|SUBSUFF
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CatPtr
operator|=
name|Buffer
expr_stmt|;
operator|*
name|Buffer
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|Buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|basedir
argument_list|)
operator|+
name|BUFSIZ
operator|+
name|strlen
argument_list|(
name|SUBSUFF
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Buffer
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
name|CatPtr
operator|=
name|Buffer
operator|+
name|strlen
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|CatPtr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|CatPtr
operator|++
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|Buffer
argument_list|,
name|CTM_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|statfile
operator|=
name|fopen
argument_list|(
name|Buffer
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: %s not found.\n"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
else|else
block|{
name|fscanf
argument_list|(
name|statfile
argument_list|,
literal|"%*s %u"
argument_list|,
operator|&
name|applied
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|statfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argc
condition|)
name|stat
operator||=
name|Proc
argument_list|(
literal|"-"
argument_list|,
name|applied
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|--
operator|&&
name|stat
operator|==
name|Exit_Done
condition|)
block|{
name|stat
operator||=
name|Proc
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|applied
argument_list|)
expr_stmt|;
name|stat
operator|&=
operator|~
name|Exit_Version
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|==
name|Exit_Done
condition|)
name|stat
operator|=
name|Exit_OK
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exit(%d)\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
end_function

begin_function
name|int
name|Proc
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|applied
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".gz"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".Z"
argument_list|)
operator|)
condition|)
block|{
name|p
operator|=
name|alloca
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"gunzip< "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
block|}
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Working on<%s>\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|FileName
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|String
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* If we cannot seek, we're doomed, so copy to a tmp-file in that case */
if|if
condition|(
operator|!
name|p
operator|&&
operator|-
literal|1
operator|==
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fn
init|=
name|tempnam
argument_list|(
name|TmpDir
argument_list|,
literal|"CTMclient"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|f2
init|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w+"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|f2
condition|)
block|{
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
name|unlink
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing tmp-file \"%s\"\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|i
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
condition|)
if|if
condition|(
name|EOF
operator|==
name|putc
argument_list|(
name|i
argument_list|,
name|f2
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|f2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Pass1
argument_list|(
name|f
argument_list|,
name|applied
argument_list|)
operator|)
condition|)
goto|goto
name|exit_and_close
goto|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
block|}
name|i
operator|=
name|Pass2
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Broke
return|;
block|}
block|}
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|Force
operator|)
operator|||
operator|(
name|i
operator|&
operator|~
name|Exit_Forcible
operator|)
condition|)
goto|goto
name|exit_and_close
goto|;
block|}
if|if
condition|(
name|CheckIt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"All checks out ok.\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|Exit_Done
expr_stmt|;
goto|goto
name|exit_and_close
goto|;
block|}
name|i
operator|=
name|Pass3
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|exit_and_close
label|:
if|if
condition|(
operator|!
name|p
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"All done ok\n"
argument_list|)
expr_stmt|;
return|return
name|Exit_Done
return|;
block|}
end_function

end_unit

