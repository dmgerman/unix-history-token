begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"ctm.h"
end_include

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|Fatal_
parameter_list|(
name|int
name|ln
parameter_list|,
name|char
modifier|*
name|fn
parameter_list|,
name|char
modifier|*
name|kind
parameter_list|)
block|{
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal error. (%s:%d)\n"
argument_list|,
name|fn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s Fatal error: %s\n"
argument_list|,
name|FileName
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|Fatal
parameter_list|(
name|foo
parameter_list|)
value|Fatal_(__LINE__,__FILE__,foo)
end_define

begin_define
define|#
directive|define
name|Assert
parameter_list|()
value|Fatal_(__LINE__,__FILE__,"Assert failed.")
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* get next field, check that the terminating whitespace is what we expect */
end_comment

begin_function
name|u_char
modifier|*
name|Ffield
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|u_char
name|term
parameter_list|)
block|{
specifier|static
name|u_char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|Fatal
argument_list|(
literal|"Truncated patch."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buf
index|[
name|l
operator|++
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|l
operator|>=
sizeof|sizeof
name|buf
condition|)
block|{
name|Fatal
argument_list|(
literal|"Corrupt patch."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Token is too long.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|buf
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|MD5Update
argument_list|(
name|ctx
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|l
operator|-
literal|1
index|]
operator|!=
name|term
condition|)
block|{
name|Fatal
argument_list|(
literal|"Corrupt patch."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected \"%s\" but didn't find it {%02x}.\n"
argument_list|,
name|term
operator|==
literal|'\n'
condition|?
literal|"\\n"
else|:
literal|" "
argument_list|,
name|buf
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|4
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{%s}\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buf
index|[
operator|--
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|4
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s>\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|Fbytecnt
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|u_char
name|term
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|u_chars
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|Ffield
argument_list|(
name|fd
argument_list|,
name|ctx
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Bytecount contains non-digit."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|u_chars
operator|*=
literal|10
expr_stmt|;
name|u_chars
operator|+=
operator|(
operator|*
name|q
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|u_chars
operator|>
name|MAXSIZE
condition|)
block|{
name|Fatal
argument_list|(
literal|"Bytecount too large."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|u_chars
return|;
block|}
end_function

begin_function
name|u_char
modifier|*
name|Fdata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|u_chars
parameter_list|,
name|MD5_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
name|Malloc
argument_list|(
name|u_chars
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|u_chars
operator|+
literal|1
operator|!=
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|u_chars
operator|+
literal|1
argument_list|,
name|fd
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Truncated patch."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MD5Update
argument_list|(
name|ctx
argument_list|,
name|p
argument_list|,
name|u_chars
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|u_chars
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|Verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"FileData wasn't followed by a newline.\n"
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
literal|"Corrupt patch."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
index|[
name|u_chars
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* get the filename in the next field, prepend BaseDir and give back the result    strings. The sustitute filename is return (the one with the suffix SUBSUFF)     if it exists and the qualifier contains CTM_Q_Name_Subst    NOTA: Buffer is already initialize with BaseDir, CatPtr is the insertion    point on this buffer + the length test in Ffield() is enough for Fname() */
end_comment

begin_function
name|u_char
modifier|*
name|Fname
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|u_char
name|term
parameter_list|,
name|int
name|qual
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|Ffield
argument_list|(
name|fd
argument_list|,
name|ctx
argument_list|,
name|term
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strcpy
argument_list|(
name|CatPtr
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qual
operator|&
name|CTM_Q_Name_Subst
operator|)
condition|)
return|return
operator|(
name|Buffer
operator|)
return|;
name|p
operator|=
name|Buffer
operator|+
name|strlen
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Buffer
argument_list|,
name|SUBSUFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|stat
argument_list|(
name|Buffer
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using %s as substitute file\n"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Buffer
operator|)
return|;
block|}
end_function

end_unit

