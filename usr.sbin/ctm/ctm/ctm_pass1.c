begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"ctm.h"
end_include

begin_define
define|#
directive|define
name|BADREAD
value|1
end_define

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Pass1 -- Validate the incoming CTM-file.  */
end_comment

begin_function
name|int
name|Pass1
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|unsigned
name|applied
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|MD5_CTX
name|ctx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sep
decl_stmt|,
name|cnt
decl_stmt|;
name|u_char
modifier|*
name|md5
init|=
literal|0
decl_stmt|,
modifier|*
name|name
init|=
literal|0
decl_stmt|,
modifier|*
name|trash
init|=
literal|0
decl_stmt|;
name|struct
name|CTM_Syntax
modifier|*
name|sp
decl_stmt|;
name|int
name|slashwarn
init|=
literal|0
decl_stmt|,
name|match
init|=
literal|0
decl_stmt|,
name|total_matches
init|=
literal|0
decl_stmt|;
name|unsigned
name|current
decl_stmt|;
name|char
name|md5_1
index|[
literal|33
index|]
decl_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"Pass1 -- Checking integrity of incoming CTM-patch\n"
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|GETFIELD
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* CTM_BEGIN */
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"CTM_BEGIN"
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Probably not a CTM-patch at all."
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected \"CTM_BEGIN\" got \"%s\".\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|GETFIELDCOPY
argument_list|(
name|Version
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/*<Version> */
if|if
condition|(
name|strcmp
argument_list|(
name|Version
argument_list|,
name|VERSION
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"CTM-patch is wrong version."
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected \"%s\" got \"%s\".\n"
argument_list|,
name|VERSION
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|GETFIELDCOPY
argument_list|(
name|Name
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/*<Name> */
name|GETFIELDCOPY
argument_list|(
name|Nbr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/*<Nbr> */
name|GETFIELDCOPY
argument_list|(
name|TimeStamp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/*<TimeStamp> */
name|GETFIELDCOPY
argument_list|(
name|Prefix
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/*<Prefix> */
name|sscanf
argument_list|(
name|Nbr
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|FilterList
operator|||
name|ListIt
condition|)
name|current
operator|=
literal|0
expr_stmt|;
comment|/* ignore if -l or if filters are present */
if|if
condition|(
name|current
operator|&&
name|current
operator|<=
name|applied
condition|)
block|{
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Delta number %u is already applied; ignoring.\n"
argument_list|,
name|current
argument_list|)
expr_stmt|;
return|return
name|Exit_Version
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|Delete
argument_list|(
name|md5
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|trash
argument_list|)
expr_stmt|;
name|cnt
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* if a filter list is defined we assume that all pathnames require 	   an action opposite to that requested by the first filter in the 	   list. 	   If no filter is defined, all pathnames are assumed to match. */
name|match
operator|=
operator|(
name|FilterList
condition|?
operator|!
operator|(
name|FilterList
operator|->
name|Action
operator|)
else|:
name|CTM_FILTER_ENABLE
operator|)
expr_stmt|;
name|GETFIELD
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* CTM_something */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'C'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'T'
operator|||
name|p
index|[
literal|2
index|]
operator|!=
literal|'M'
condition|)
block|{
name|Fatal
argument_list|(
literal|"Expected CTM keyword."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got [%s]\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
literal|"_END"
argument_list|)
condition|)
break|break;
for|for
control|(
name|sp
operator|=
name|Syntax
init|;
name|sp
operator|->
name|Key
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|sp
operator|->
name|Key
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|Fatal
argument_list|(
literal|"Expected CTM keyword."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got [%s]\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|found
label|:
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|sp
operator|->
name|Key
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|sp
operator|->
name|List
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|List
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|(
name|sp
operator|->
name|List
index|[
name|i
operator|+
literal|1
index|]
operator|&
name|CTM_F_MASK
operator|)
operator|!=
name|CTM_F_Bytes
condition|)
name|sep
operator|=
literal|' '
expr_stmt|;
else|else
name|sep
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %x(%d)"
argument_list|,
name|sp
operator|->
name|List
index|[
name|i
index|]
argument_list|,
name|sep
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|j
operator|&
name|CTM_F_MASK
condition|)
block|{
case|case
name|CTM_F_Name
case|:
comment|/* XXX check for garbage and .. */
name|GETFIELDCOPY
argument_list|(
name|name
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|slashwarn
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: contains trailing slash\n"
argument_list|)
expr_stmt|;
name|slashwarn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|Fatal
argument_list|(
literal|"Absolute paths are illegal."
argument_list|)
expr_stmt|;
return|return
name|Exit_Mess
return|;
block|}
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
if|if
condition|(
name|q
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|q
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|Fatal
argument_list|(
literal|"Paths containing '..' are illegal."
argument_list|)
expr_stmt|;
return|return
name|Exit_Mess
return|;
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|q
operator|++
expr_stmt|;
block|}
comment|/* if we have been asked to `keep' files then skip 		       removes; i.e. we don't match these entries at 		       all. */
if|if
condition|(
name|KeepIt
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|sp
operator|->
name|Key
argument_list|,
literal|"DR"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|sp
operator|->
name|Key
argument_list|,
literal|"FR"
argument_list|)
operator|)
condition|)
block|{
name|match
operator|=
name|CTM_FILTER_DISABLE
expr_stmt|;
break|break;
block|}
comment|/* If filter expression have been defined, match the 		       path name against the expression list.  */
if|if
condition|(
name|FilterList
condition|)
block|{
name|struct
name|CTM_Filter
modifier|*
name|filter
decl_stmt|;
for|for
control|(
name|filter
operator|=
name|FilterList
init|;
name|filter
condition|;
name|filter
operator|=
name|filter
operator|->
name|Next
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|regexec
argument_list|(
operator|&
name|filter
operator|->
name|CompiledRegex
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* if the name matches, adopt the  					   action */
name|match
operator|=
name|filter
operator|->
name|Action
expr_stmt|;
block|}
block|}
comment|/* Add up the total number of matches */
name|total_matches
operator|+=
name|match
expr_stmt|;
break|break;
case|case
name|CTM_F_Uid
case|:
name|GETFIELD
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Non-digit in uid."
argument_list|)
expr_stmt|;
return|return
literal|32
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CTM_F_Gid
case|:
name|GETFIELD
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Non-digit in gid."
argument_list|)
expr_stmt|;
return|return
literal|32
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CTM_F_Mode
case|:
name|GETFIELD
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Non-digit in mode."
argument_list|)
expr_stmt|;
return|return
literal|32
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CTM_F_MD5
case|:
if|if
condition|(
name|j
operator|&
name|CTM_Q_MD5_Chunk
condition|)
block|{
name|GETFIELDCOPY
argument_list|(
name|md5
argument_list|,
name|sep
argument_list|)
expr_stmt|;
comment|/* XXX check for garbage */
block|}
elseif|else
if|if
condition|(
name|j
operator|&
name|CTM_Q_MD5_Before
condition|)
block|{
name|GETFIELD
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
comment|/* XXX check for garbage */
block|}
elseif|else
if|if
condition|(
name|j
operator|&
name|CTM_Q_MD5_After
condition|)
block|{
name|GETFIELD
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
comment|/* XXX check for garbage */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"List = 0x%x\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
literal|"Unqualified MD5."
argument_list|)
expr_stmt|;
return|return
literal|32
return|;
block|}
break|break;
case|case
name|CTM_F_Count
case|:
name|GETBYTECNT
argument_list|(
name|cnt
argument_list|,
name|sep
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTM_F_Bytes
case|:
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
name|WRONG
name|GETDATA
argument_list|(
name|trash
argument_list|,
name|cnt
argument_list|)
decl_stmt|;
name|p
operator|=
name|MD5Data
argument_list|(
name|trash
argument_list|,
name|cnt
argument_list|,
name|md5_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|md5
operator|&&
name|strcmp
argument_list|(
name|md5
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Internal MD5 failed."
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"List = 0x%x\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
literal|"List had garbage."
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
block|}
block|}
block|}
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ListIt
operator|&&
name|match
condition|)
name|printf
argument_list|(
literal|"> %s %s\n"
argument_list|,
name|sp
operator|->
name|Key
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|Delete
argument_list|(
name|md5
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|trash
argument_list|)
expr_stmt|;
name|q
operator|=
name|MD5End
argument_list|(
operator|&
name|ctx
argument_list|,
name|md5_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Expecting Global MD5<%s>\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|GETFIELD
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/*<MD5> */
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Reference Global MD5<%s>\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"MD5 sum doesn't match."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tI have:<%s>\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tShould have been:<%s>\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|Exit_Garbage
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|!=
name|getc
argument_list|(
name|fd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Force
condition|)
block|{
name|Fatal
argument_list|(
literal|"Trailing junk in CTM-file.  Can Force with -F."
argument_list|)
expr_stmt|;
return|return
literal|16
return|;
block|}
block|}
if|if
condition|(
operator|(
name|Verbose
operator|>
literal|1
operator|)
operator|&&
operator|(
literal|0
operator|==
name|total_matches
operator|)
condition|)
name|printf
argument_list|(
literal|"No matches in \"%s\"\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
return|return
operator|(
name|total_matches
condition|?
name|Exit_OK
else|:
name|Exit_NoMatch
operator|)
return|;
block|}
end_function

end_unit

