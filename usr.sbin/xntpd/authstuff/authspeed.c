begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * authspeed - figure out how long it takes to do an NTP encryption  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_AUX3
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_AUX2
argument_list|)
operator|||
name|defined
argument_list|(
name|SOLARIS
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_PTX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_UNIXWARE1
argument_list|)
end_if

begin_define
define|#
directive|define
name|FAKE_RUSAGE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FAKE_RUSAGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_define
define|#
directive|define
name|DEFLOOPS
value|-1
end_define

begin_define
define|#
directive|define
name|DEFDELAYLOOPS
value|20000
end_define

begin_define
define|#
directive|define
name|DEFCOSTLOOPS
value|2000
end_define

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|tstart
decl_stmt|,
name|tend
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FAKE_RUSAGE
end_ifdef

begin_decl_stmt
name|struct
name|tms
name|rstart
decl_stmt|,
name|rend
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|getrusage
parameter_list|(
name|foo
parameter_list|,
name|t
parameter_list|)
value|times(t)
end_define

begin_define
define|#
directive|define
name|RUSAGE_SELF
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|rusage
name|rstart
decl_stmt|,
name|rend
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|l_fp
name|dummy1
decl_stmt|,
name|dummy2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|dummy3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|pkt
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|totalcost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|rtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|vtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|domd5
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dodelay
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|docheap
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|docost
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|subtime
name|P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|,
name|double
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|loops
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|loops
operator|=
name|DEFLOOPS
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cdmn:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|totalcost
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|domd5
operator|=
literal|16
expr_stmt|;
comment|/* offset into list of keys */
break|break;
case|case
literal|'n'
case|:
name|loops
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is unlikely to be a useful number of loops\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|==
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-d] [-n loops] [ -c ] auth.samplekeys\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Compute timing for "
argument_list|)
expr_stmt|;
if|if
condition|(
name|domd5
condition|)
name|printf
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"DES"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" based authentication.\n"
argument_list|)
expr_stmt|;
name|init_auth
argument_list|()
expr_stmt|;
name|authreadkeys
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|auth_havekey
argument_list|(
name|i
operator|+
name|domd5
argument_list|)
condition|)
block|{
name|errflg
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: key %d missing\n"
argument_list|,
name|progname
argument_list|,
name|i
operator|+
name|domd5
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errflg
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: check syslog for errors, or use file with complete set of keys\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loops
operator|==
name|DEFLOOPS
condition|)
block|{
if|if
condition|(
name|totalcost
condition|)
name|loops
operator|=
name|DEFCOSTLOOPS
expr_stmt|;
else|else
name|loops
operator|=
name|DEFDELAYLOOPS
expr_stmt|;
block|}
name|dummy1
operator|.
name|l_ui
operator|=
literal|0x80808080
expr_stmt|;
name|dummy1
operator|.
name|l_uf
operator|=
literal|0xffffff00
expr_stmt|;
name|dummy3
operator|=
literal|0x0aaaaaaa
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|pkt
index|[
name|i
index|]
operator|=
name|i
operator|*
literal|0x22222
expr_stmt|;
if|if
condition|(
name|totalcost
condition|)
block|{
if|if
condition|(
name|totalcost
operator|>
literal|1
condition|)
name|docheap
argument_list|(
name|loops
argument_list|)
expr_stmt|;
else|else
name|docost
argument_list|(
name|loops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dodelay
argument_list|(
name|loops
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"total real time: %.3f\n"
argument_list|,
name|rtime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total CPU time: %.3f\n"
argument_list|,
name|vtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalcost
condition|)
block|{
name|printf
argument_list|(
literal|"real cost (in seconds): %.6f\n"
argument_list|,
name|rtime
operator|/
operator|(
name|double
operator|)
name|loops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CPU cost (in seconds): %.6f\n"
argument_list|,
name|vtime
operator|/
operator|(
name|double
operator|)
name|loops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nThis includes the cost of a decryption plus the\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the cost of an encryption, i.e. the cost to process\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a single authenticated packet.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"authdelay in the configuration file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"real authentication delay: %.6f\n"
argument_list|,
name|rtime
operator|/
operator|(
name|double
operator|)
name|loops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"authentication delay in CPU time: %.6f\n"
argument_list|,
name|vtime
operator|/
operator|(
name|double
operator|)
name|loops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nThe CPU delay is probably the best bet for\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"authdelay in the configuration file\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dodelay - do the delay measurement  */
end_comment

begin_function
specifier|static
name|void
name|dodelay
parameter_list|(
name|loops
parameter_list|)
name|int
name|loops
decl_stmt|;
block|{
name|double
name|vtime1
decl_stmt|,
name|rtime1
decl_stmt|,
name|vtime2
decl_stmt|,
name|rtime2
decl_stmt|;
specifier|register
name|int
name|loopcount
decl_stmt|;
comment|/* 	 *  If we're attempting to compute the cost of an auth2crypt() 	 *  for first compute the total cost, then compute the 	 *  cost of only doing the first step, auth1crypt().  What  	 *  remains is the cost of auth2crypt. 	 */
name|loopcount
operator|=
name|loops
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tstart
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rstart
argument_list|)
expr_stmt|;
while|while
condition|(
name|loopcount
operator|--
operator|>
literal|0
condition|)
block|{
name|auth1crypt
argument_list|(
operator|(
name|loops
operator|&
literal|0xf
operator|)
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|dummy1
argument_list|,
name|dummy3
argument_list|)
expr_stmt|;
name|auth2crypt
argument_list|(
operator|(
name|loops
operator|&
literal|0xf
operator|)
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rend
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tend
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|subtime
argument_list|(
operator|&
name|tstart
argument_list|,
operator|&
name|tend
argument_list|,
operator|&
name|rtime1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAKE_RUSAGE
name|vtime1
operator|=
operator|(
name|rend
operator|.
name|tms_utime
operator|-
name|rstart
operator|.
name|tms_utime
operator|)
operator|*
literal|1.0
operator|/
name|HZ
expr_stmt|;
else|#
directive|else
name|subtime
argument_list|(
operator|&
name|rstart
operator|.
name|ru_utime
argument_list|,
operator|&
name|rend
operator|.
name|ru_utime
argument_list|,
operator|&
name|vtime1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Time for full encryptions is %f rusage %f real\n"
argument_list|,
name|vtime1
argument_list|,
name|rtime1
argument_list|)
expr_stmt|;
name|loopcount
operator|=
name|loops
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tstart
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rstart
argument_list|)
expr_stmt|;
while|while
condition|(
name|loopcount
operator|--
operator|>
literal|0
condition|)
block|{
name|auth1crypt
argument_list|(
operator|(
name|loops
operator|&
literal|0xf
operator|)
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rend
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tend
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|subtime
argument_list|(
operator|&
name|tstart
argument_list|,
operator|&
name|tend
argument_list|,
operator|&
name|rtime2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAKE_RUSAGE
name|vtime2
operator|=
operator|(
name|rend
operator|.
name|tms_utime
operator|-
name|rstart
operator|.
name|tms_utime
operator|)
operator|*
literal|1.0
operator|/
name|HZ
expr_stmt|;
else|#
directive|else
name|subtime
argument_list|(
operator|&
name|rstart
operator|.
name|ru_utime
argument_list|,
operator|&
name|rend
operator|.
name|ru_utime
argument_list|,
operator|&
name|vtime2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Time for auth1crypt is %f rusage %f real\n"
argument_list|,
name|vtime2
argument_list|,
name|rtime2
argument_list|)
expr_stmt|;
name|vtime
operator|=
name|vtime1
operator|-
name|vtime2
expr_stmt|;
name|rtime
operator|=
name|rtime1
operator|-
name|rtime2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * docheap - do the cost measurement the cheap way  */
end_comment

begin_function
specifier|static
name|void
name|docheap
parameter_list|(
name|loops
parameter_list|)
specifier|register
name|int
name|loops
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|authhavekey
argument_list|(
literal|3
operator|+
name|domd5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tstart
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rstart
argument_list|)
expr_stmt|;
while|while
condition|(
name|loops
operator|--
operator|>
literal|0
condition|)
block|{
name|auth1crypt
argument_list|(
literal|3
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|dummy1
argument_list|,
name|dummy3
argument_list|)
expr_stmt|;
name|auth2crypt
argument_list|(
literal|3
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|authdecrypt
argument_list|(
literal|3
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rend
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tend
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|subtime
argument_list|(
operator|&
name|tstart
argument_list|,
operator|&
name|tend
argument_list|,
operator|&
name|rtime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAKE_RUSAGE
name|vtime
operator|=
operator|(
name|rend
operator|.
name|tms_utime
operator|-
name|rstart
operator|.
name|tms_utime
operator|)
operator|*
literal|1.0
operator|/
name|HZ
expr_stmt|;
else|#
directive|else
name|subtime
argument_list|(
operator|&
name|rstart
operator|.
name|ru_utime
argument_list|,
operator|&
name|rend
operator|.
name|ru_utime
argument_list|,
operator|&
name|vtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * docost - do the cost measurement  */
end_comment

begin_function
specifier|static
name|void
name|docost
parameter_list|(
name|loops
parameter_list|)
specifier|register
name|int
name|loops
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tstart
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rstart
argument_list|)
expr_stmt|;
while|while
condition|(
name|loops
operator|--
operator|>
literal|0
condition|)
block|{
name|auth1crypt
argument_list|(
operator|(
name|loops
operator|&
literal|0xf
operator|)
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|dummy1
argument_list|,
name|dummy3
argument_list|)
expr_stmt|;
name|auth2crypt
argument_list|(
operator|(
name|loops
operator|&
literal|0xf
operator|)
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|authdecrypt
argument_list|(
operator|(
operator|(
name|loops
operator|+
literal|1
operator|)
operator|&
literal|0xf
operator|)
operator|+
name|domd5
argument_list|,
name|pkt
argument_list|,
literal|48
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|rend
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tend
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|subtime
argument_list|(
operator|&
name|tstart
argument_list|,
operator|&
name|tend
argument_list|,
operator|&
name|rtime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAKE_RUSAGE
name|vtime
operator|=
operator|(
name|rend
operator|.
name|tms_utime
operator|-
name|rstart
operator|.
name|tms_utime
operator|)
operator|*
literal|1.0
operator|/
name|HZ
expr_stmt|;
else|#
directive|else
name|subtime
argument_list|(
operator|&
name|rstart
operator|.
name|ru_utime
argument_list|,
operator|&
name|rend
operator|.
name|ru_utime
argument_list|,
operator|&
name|vtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * subtime - subtract two struct timevals, return double result  */
end_comment

begin_function
specifier|static
name|void
name|subtime
parameter_list|(
name|tvs
parameter_list|,
name|tve
parameter_list|,
name|res
parameter_list|)
name|struct
name|timeval
modifier|*
name|tvs
decl_stmt|,
decl|*
name|tve
decl_stmt|;
end_function

begin_decl_stmt
name|double
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|sec
decl_stmt|;
name|long
name|usec
decl_stmt|;
name|sec
operator|=
name|tve
operator|->
name|tv_sec
operator|-
name|tvs
operator|->
name|tv_sec
expr_stmt|;
name|usec
operator|=
name|tve
operator|->
name|tv_usec
operator|-
name|tvs
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|usec
operator|<
literal|0
condition|)
block|{
name|usec
operator|+=
literal|1000000
expr_stmt|;
name|sec
operator|--
expr_stmt|;
block|}
operator|*
name|res
operator|=
operator|(
name|double
operator|)
name|sec
operator|+
operator|(
name|double
operator|)
name|usec
operator|/
literal|1000000.
expr_stmt|;
return|return;
block|}
end_block

end_unit

