begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntpq.c,v 3.1 1993/07/06 01:09:29 jbj Exp  * ntpq - query an NTP server using mode 6 commands  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntpq.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Because we potentially understand a lot of commands we will run  * interactive if connected to a terminal.  */
end_comment

begin_decl_stmt
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should prompt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|"ntpq> "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompt to ask him about */
end_comment

begin_comment
comment|/*  * Keyid used for authenticated requests.  Obtained on the fly.  */
end_comment

begin_decl_stmt
name|U_LONG
name|info_auth_keyid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type of key md5 or des  */
end_comment

begin_define
define|#
directive|define
name|KEY_TYPE_DES
value|3
end_define

begin_define
define|#
directive|define
name|KEY_TYPE_MD5
value|4
end_define

begin_decl_stmt
name|int
name|info_auth_keytype
init|=
name|KEY_TYPE_DES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DES */
end_comment

begin_comment
comment|/*  * Flag which indicates we should always send authenticated requests  */
end_comment

begin_decl_stmt
name|int
name|always_auth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag which indicates raw mode output.  */
end_comment

begin_decl_stmt
name|int
name|rawmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Packet version number we use  */
end_comment

begin_decl_stmt
name|u_char
name|pktversion
init|=
name|NTP_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Don't jump if no set jmp.  */
end_comment

begin_decl_stmt
name|int
name|jump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Format values  */
end_comment

begin_define
define|#
directive|define
name|PADDING
value|0
end_define

begin_define
define|#
directive|define
name|TS
value|1
end_define

begin_comment
comment|/* time stamp */
end_comment

begin_define
define|#
directive|define
name|FL
value|2
end_define

begin_comment
comment|/* l_fp type value */
end_comment

begin_define
define|#
directive|define
name|FU
value|3
end_define

begin_comment
comment|/* u_fp type value */
end_comment

begin_define
define|#
directive|define
name|FS
value|4
end_define

begin_comment
comment|/* s_fp type value */
end_comment

begin_define
define|#
directive|define
name|UI
value|5
end_define

begin_comment
comment|/* unsigned integer value */
end_comment

begin_define
define|#
directive|define
name|IN
value|6
end_define

begin_comment
comment|/* signed integer value */
end_comment

begin_define
define|#
directive|define
name|HA
value|7
end_define

begin_comment
comment|/* host address */
end_comment

begin_define
define|#
directive|define
name|NA
value|8
end_define

begin_comment
comment|/* network address */
end_comment

begin_define
define|#
directive|define
name|ST
value|9
end_define

begin_comment
comment|/* string value */
end_comment

begin_define
define|#
directive|define
name|RF
value|10
end_define

begin_comment
comment|/* refid (sometimes string, sometimes not) */
end_comment

begin_define
define|#
directive|define
name|LP
value|11
end_define

begin_comment
comment|/* leap (print in binary) */
end_comment

begin_define
define|#
directive|define
name|OC
value|12
end_define

begin_comment
comment|/* integer, print in octal */
end_comment

begin_define
define|#
directive|define
name|MD
value|13
end_define

begin_comment
comment|/* mode */
end_comment

begin_define
define|#
directive|define
name|AR
value|14
end_define

begin_comment
comment|/* array of times */
end_comment

begin_define
define|#
directive|define
name|TST
value|15
end_define

begin_comment
comment|/* test flags */
end_comment

begin_define
define|#
directive|define
name|EOV
value|255
end_define

begin_comment
comment|/* end of table */
end_comment

begin_comment
comment|/*  * System variable values.  The array can be indexed by  * the variable index to find the textual name.  */
end_comment

begin_decl_stmt
name|struct
name|ctl_var
name|sys_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CS_LEAP
block|,
name|LP
block|,
literal|"leap"
block|}
block|,
comment|/* 1 */
block|{
name|CS_STRATUM
block|,
name|UI
block|,
literal|"stratum"
block|}
block|,
comment|/* 2 */
block|{
name|CS_PRECISION
block|,
name|IN
block|,
literal|"precision"
block|}
block|,
comment|/* 3 */
block|{
name|CS_ROOTDELAY
block|,
name|FU
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 4 */
block|{
name|CS_ROOTDISPERSION
block|,
name|FU
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 5 */
block|{
name|CS_REFID
block|,
name|RF
block|,
literal|"refid"
block|}
block|,
comment|/* 6 */
block|{
name|CS_REFTIME
block|,
name|TS
block|,
literal|"reftime"
block|}
block|,
comment|/* 7 */
block|{
name|CS_POLL
block|,
name|UI
block|,
literal|"poll"
block|}
block|,
comment|/* 8 */
block|{
name|CS_PEERID
block|,
name|UI
block|,
literal|"peer"
block|}
block|,
comment|/* 9 */
block|{
name|CS_OFFSET
block|,
name|FL
block|,
literal|"phase"
block|}
block|,
comment|/* 10 */
block|{
name|CS_DRIFT
block|,
name|FS
block|,
literal|"freq"
block|}
block|,
comment|/* 11 */
block|{
name|CS_COMPLIANCE
block|,
name|UI
block|,
literal|"compliance"
block|}
block|,
comment|/* 12 */
block|{
name|CS_CLOCK
block|,
name|TS
block|,
literal|"clock"
block|}
block|,
comment|/* 13 */
block|{
name|CS_LEAPIND
block|,
name|LP
block|,
literal|"leapindicator"
block|}
block|,
comment|/* 14 */
block|{
name|CS_LEAPWARNING
block|,
name|LP
block|,
literal|"leapwarning"
block|}
block|,
comment|/* 15 */
block|{
name|CS_PROCESSOR
block|,
name|ST
block|,
literal|"processor"
block|}
block|,
comment|/* 16 */
block|{
name|CS_SYSTEM
block|,
name|ST
block|,
literal|"system"
block|}
block|,
comment|/* 17 */
block|{
name|CS_KEYID
block|,
name|UI
block|,
literal|"keyid"
block|}
block|,
comment|/* 18 */
block|{
name|CS_REFSKEW
block|,
name|FL
block|,
literal|"refskew"
block|}
block|,
comment|/* 19 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variable list  */
end_comment

begin_decl_stmt
name|struct
name|ctl_var
name|peer_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CP_CONFIG
block|,
name|UI
block|,
literal|"config"
block|}
block|,
comment|/* 1 */
block|{
name|CP_AUTHENABLE
block|,
name|UI
block|,
literal|"authenable"
block|}
block|,
comment|/* 2 */
block|{
name|CP_AUTHENTIC
block|,
name|UI
block|,
literal|"authentic"
block|}
block|,
comment|/* 3 */
block|{
name|CP_SRCADR
block|,
name|HA
block|,
literal|"srcadr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|UI
block|,
literal|"srcport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_DSTADR
block|,
name|NA
block|,
literal|"dstadr"
block|}
block|,
comment|/* 6 */
block|{
name|CP_DSTPORT
block|,
name|UI
block|,
literal|"dstport"
block|}
block|,
comment|/* 7 */
block|{
name|CP_LEAP
block|,
name|LP
block|,
literal|"leap"
block|}
block|,
comment|/* 8 */
block|{
name|CP_HMODE
block|,
name|MD
block|,
literal|"hmode"
block|}
block|,
comment|/* 9 */
block|{
name|CP_STRATUM
block|,
name|UI
block|,
literal|"stratum"
block|}
block|,
comment|/* 10 */
block|{
name|CP_PPOLL
block|,
name|UI
block|,
literal|"ppoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|UI
block|,
literal|"hpoll"
block|}
block|,
comment|/* 12 */
block|{
name|CP_PRECISION
block|,
name|IN
block|,
literal|"precision"
block|}
block|,
comment|/* 13 */
block|{
name|CP_ROOTDELAY
block|,
name|FS
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 14 */
block|{
name|CP_ROOTDISPERSION
block|,
name|FU
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 15 */
block|{
name|CP_REFID
block|,
name|RF
block|,
literal|"refid"
block|}
block|,
comment|/* 16 */
block|{
name|CP_REFTIME
block|,
name|TS
block|,
literal|"reftime"
block|}
block|,
comment|/* 17 */
block|{
name|CP_ORG
block|,
name|TS
block|,
literal|"org"
block|}
block|,
comment|/* 18 */
block|{
name|CP_REC
block|,
name|TS
block|,
literal|"rec"
block|}
block|,
comment|/* 19 */
block|{
name|CP_XMT
block|,
name|TS
block|,
literal|"xmt"
block|}
block|,
comment|/* 20 */
block|{
name|CP_REACH
block|,
name|OC
block|,
literal|"reach"
block|}
block|,
comment|/* 21 */
block|{
name|CP_VALID
block|,
name|UI
block|,
literal|"valid"
block|}
block|,
comment|/* 22 */
block|{
name|CP_TIMER
block|,
name|UI
block|,
literal|"timer"
block|}
block|,
comment|/* 23 */
block|{
name|CP_DELAY
block|,
name|AR
block|,
literal|"delay"
block|}
block|,
comment|/* 24 */
block|{
name|CP_OFFSET
block|,
name|AR
block|,
literal|"offset"
block|}
block|,
comment|/* 25 */
block|{
name|CP_DISPERSION
block|,
name|FU
block|,
literal|"dispersion"
block|}
block|,
comment|/* 26 */
block|{
name|CP_KEYID
block|,
name|UI
block|,
literal|"keyid"
block|}
block|,
comment|/* 27 */
block|{
name|CP_FILTDELAY
block|,
name|AR
block|,
literal|"filtdelay"
block|}
block|,
comment|/* 28 */
block|{
name|CP_FILTOFFSET
block|,
name|AR
block|,
literal|"filtoffset"
block|}
block|,
comment|/* 29 */
block|{
name|CP_PMODE
block|,
name|ST
block|,
literal|"pmode"
block|}
block|,
comment|/* 30 */
block|{
name|CP_RECEIVED
block|,
name|UI
block|,
literal|"received"
block|}
block|,
comment|/* 31 */
block|{
name|CP_SENT
block|,
name|UI
block|,
literal|"sent"
block|}
block|,
comment|/* 32 */
block|{
name|CP_FILTERROR
block|,
name|AR
block|,
literal|"filterror"
block|}
block|,
comment|/* 33 */
block|{
name|CP_FLASH
block|,
name|TST
block|,
literal|"flash"
block|}
block|,
comment|/* 34 */
block|{
name|CP_DISP
block|,
name|AR
block|,
literal|"disp"
block|}
block|,
comment|/* 35 */
comment|/* 	 * These are duplicate entires so that we can 	 * process deviant version of the xntp protocal. 	 */
block|{
name|CP_SRCADR
block|,
name|HA
block|,
literal|"peeraddr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|UI
block|,
literal|"peerport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_PPOLL
block|,
name|UI
block|,
literal|"peerpoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|UI
block|,
literal|"hostpoll"
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock variable list  */
end_comment

begin_decl_stmt
name|struct
name|ctl_var
name|clock_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CC_TYPE
block|,
name|UI
block|,
literal|"type"
block|}
block|,
comment|/* 1 */
block|{
name|CC_TIMECODE
block|,
name|ST
block|,
literal|"timecode"
block|}
block|,
comment|/* 2 */
block|{
name|CC_POLL
block|,
name|UI
block|,
literal|"poll"
block|}
block|,
comment|/* 3 */
block|{
name|CC_NOREPLY
block|,
name|UI
block|,
literal|"noreply"
block|}
block|,
comment|/* 4 */
block|{
name|CC_BADFORMAT
block|,
name|UI
block|,
literal|"badformat"
block|}
block|,
comment|/* 5 */
block|{
name|CC_BADDATA
block|,
name|UI
block|,
literal|"baddata"
block|}
block|,
comment|/* 6 */
block|{
name|CC_FUDGETIME1
block|,
name|FL
block|,
literal|"fudgetime1"
block|}
block|,
comment|/* 7 */
block|{
name|CC_FUDGETIME2
block|,
name|FL
block|,
literal|"fudgetime2"
block|}
block|,
comment|/* 8 */
block|{
name|CC_FUDGEVAL1
block|,
name|IN
block|,
literal|"fudgeval1"
block|}
block|,
comment|/* 9 */
block|{
name|CC_FUDGEVAL2
block|,
name|IN
block|,
literal|"fudgeval2"
block|}
block|,
comment|/* 10 */
block|{
name|CC_FLAGS
block|,
name|UI
block|,
literal|"flags"
block|}
block|,
comment|/* 11 */
block|{
name|CC_DEVICE
block|,
name|ST
block|,
literal|"device"
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure for turning various constants into a readable string.  */
end_comment

begin_struct
struct|struct
name|codestring
block|{
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * flasher bits  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tstflagnames
index|[]
init|=
block|{
literal|"DUPLICATE PKT"
block|,
literal|"BOGUS PKT"
block|,
literal|"PROTO UNSYNC"
block|,
literal|"PEER BOUNDS"
block|,
literal|"BAD AUTH"
block|,
literal|"PEER CLOCK UNSYNC"
block|,
literal|"BAD STRATUM"
block|,
literal|"ROOT BOUNDS"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Leap values  */
end_comment

begin_decl_stmt
name|struct
name|codestring
name|leap_codes
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"leap_none"
block|}
block|,
block|{
literal|1
block|,
literal|"leap_add_sec"
block|}
block|,
block|{
literal|2
block|,
literal|"leap_del_sec"
block|}
block|,
block|{
literal|3
block|,
literal|"sync_alarm"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|"leap"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock source  */
end_comment

begin_decl_stmt
name|struct
name|codestring
name|sync_codes
index|[]
init|=
block|{
block|{
name|CTL_SST_TS_UNSPEC
block|,
literal|"sync_unspec"
block|}
block|,
block|{
name|CTL_SST_TS_ATOM
block|,
literal|"sync_atomic"
block|}
block|,
block|{
name|CTL_SST_TS_LF
block|,
literal|"sync_lf_clock"
block|}
block|,
block|{
name|CTL_SST_TS_HF
block|,
literal|"sync_hf_clock"
block|}
block|,
block|{
name|CTL_SST_TS_UHF
block|,
literal|"sync_uhf_clock"
block|}
block|,
block|{
name|CTL_SST_TS_LOCAL
block|,
literal|"sync_local_proto"
block|}
block|,
block|{
name|CTL_SST_TS_NTP
block|,
literal|"sync_ntp"
block|}
block|,
block|{
name|CTL_SST_TS_UDPTIME
block|,
literal|"sync_udp/time"
block|}
block|,
block|{
name|CTL_SST_TS_WRSTWTCH
block|,
literal|"sync_wristwatch"
block|}
block|,
block|{
name|CTL_SST_TS_TELEPHONE
block|,
literal|"sync_telephone"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|"sync"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer selection  */
end_comment

begin_decl_stmt
name|struct
name|codestring
name|select_codes
index|[]
init|=
block|{
block|{
name|CTL_PST_SEL_REJECT
block|,
literal|"sel_reject"
block|}
block|,
block|{
name|CTL_PST_SEL_SANE
block|,
literal|"sel_sane"
block|}
block|,
block|{
name|CTL_PST_SEL_CORRECT
block|,
literal|"sel_correct"
block|}
block|,
block|{
name|CTL_PST_SEL_SELCAND
block|,
literal|"sel_candidate"
block|}
block|,
block|{
name|CTL_PST_SEL_SYNCCAND
block|,
literal|"sel_sync"
block|}
block|,
block|{
name|CTL_PST_SEL_DISTSYSPEER
block|,
literal|"sel_sys.peer, hi_dist"
block|}
block|,
block|{
name|CTL_PST_SEL_SYSPEER
block|,
literal|"sel_sys.peer"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|"sel"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock status  */
end_comment

begin_decl_stmt
name|struct
name|codestring
name|clock_codes
index|[]
init|=
block|{
block|{
name|CTL_CLK_OKAY
block|,
literal|"clk_okay"
block|}
block|,
block|{
name|CTL_CLK_NOREPLY
block|,
literal|"clk_noreply"
block|}
block|,
block|{
name|CTL_CLK_BADFORMAT
block|,
literal|"clk_badformat"
block|}
block|,
block|{
name|CTL_CLK_FAULT
block|,
literal|"clk_fault"
block|}
block|,
block|{
name|CTL_CLK_PROPAGATION
block|,
literal|"clk_propagation"
block|}
block|,
block|{
name|CTL_CLK_BADDATE
block|,
literal|"clk_baddate"
block|}
block|,
block|{
name|CTL_CLK_BADTIME
block|,
literal|"clk_badtime"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|"clk"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System Events  */
end_comment

begin_decl_stmt
name|struct
name|codestring
name|sys_codes
index|[]
init|=
block|{
block|{
name|EVNT_UNSPEC
block|,
literal|"event_unspec"
block|}
block|,
block|{
name|EVNT_SYSRESTART
block|,
literal|"event_restart"
block|}
block|,
block|{
name|EVNT_SYSFAULT
block|,
literal|"event_fault"
block|}
block|,
block|{
name|EVNT_SYNCCHG
block|,
literal|"event_sync_chg"
block|}
block|,
block|{
name|EVNT_PEERSTCHG
block|,
literal|"event_peer/strat_chg"
block|}
block|,
block|{
name|EVNT_CLOCKRESET
block|,
literal|"event_clock_reset"
block|}
block|,
block|{
name|EVNT_BADDATETIM
block|,
literal|"event_bad_date"
block|}
block|,
block|{
name|EVNT_CLOCKEXCPT
block|,
literal|"event_clock_excptn"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|"event"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer Events  */
end_comment

begin_decl_stmt
name|struct
name|codestring
name|peer_codes
index|[]
init|=
block|{
block|{
name|EVNT_UNSPEC
block|,
literal|"event_unspec"
block|}
block|,
block|{
name|EVNT_PEERIPERR
operator|&
operator|~
name|PEER_EVENT
block|,
literal|"event_ip_err"
block|}
block|,
block|{
name|EVNT_PEERAUTH
operator|&
operator|~
name|PEER_EVENT
block|,
literal|"event_authen"
block|}
block|,
block|{
name|EVNT_UNREACH
operator|&
operator|~
name|PEER_EVENT
block|,
literal|"event_unreach"
block|}
block|,
block|{
name|EVNT_REACH
operator|&
operator|~
name|PEER_EVENT
block|,
literal|"event_reach"
block|}
block|,
if|#
directive|if
literal|0
block|{ EVNT_PEERSTRAT& ~PEER_EVENT,	"event_stratum_chg" },
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
literal|"event"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Built in command handler declarations  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|openhost
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendpkt
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getresponse
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|u_short
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendrequest
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getcmds
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|abortcmd
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|docmd
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tokenize
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findcmd
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|xcmd
operator|*
operator|,
expr|struct
name|xcmd
operator|*
operator|,
expr|struct
name|xcmd
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getarg
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|arg_v
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtdatetolfp
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|decodereach
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|U_LONG
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_decl_stmt
specifier|static
name|int
name|decodearr
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getcode
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|codestring
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|helpsort
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|helpsort
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi */
end_comment

begin_decl_stmt
specifier|static
name|void
name|printusage
name|P
argument_list|(
operator|(
expr|struct
name|xcmd
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|timeout
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delay
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|host
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ntp_poll
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|keyid
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|keytype
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|passwd
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hostnames
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setdebug
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|quit
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|version
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|raw
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cooked
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|authenticate
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ntpversion
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warning
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_LONG
name|getkeyid
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atoascii
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|makeascii
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getevents
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|statustoa
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rawprint
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|startoutput
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|endoutput
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|outputarr
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cookedprint
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|assoccmp
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|assoccmp
name|P
argument_list|(
operator|(
expr|struct
name|association
operator|*
operator|,
expr|struct
name|association
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgi || bsdi */
end_comment

begin_comment
comment|/*  * Built-in commands we understand  */
end_comment

begin_decl_stmt
name|struct
name|xcmd
name|builtins
index|[]
init|=
block|{
block|{
literal|"?"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"help"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"timeout"
block|,
name|timeout
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the primary receive time out"
block|}
block|,
block|{
literal|"delay"
block|,
name|delay
block|,
block|{
name|OPT
operator||
name|INT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the delay added to encryption time stamps"
block|}
block|,
block|{
literal|"host"
block|,
name|host
block|,
block|{
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"hostname"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify the host whose NTP server we talk to"
block|}
block|,
block|{
literal|"poll"
block|,
name|ntp_poll
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"n"
block|,
literal|"verbose"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"poll an NTP server in client mode `n' times"
block|}
block|,
block|{
literal|"passwd"
block|,
name|passwd
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify a password to use for authenticated requests"
block|}
block|,
block|{
literal|"hostnames"
block|,
name|hostnames
block|,
block|{
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify whether hostnames or net numbers are printed"
block|}
block|,
block|{
literal|"debug"
block|,
name|setdebug
block|,
block|{
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"no|more|less"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/change debugging level"
block|}
block|,
block|{
literal|"quit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpq"
block|}
block|,
block|{
literal|"keyid"
block|,
name|keyid
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key#"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set keyid to use for authenticated requests"
block|}
block|,
block|{
literal|"version"
block|,
name|version
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print version number"
block|}
block|,
block|{
literal|"raw"
block|,
name|raw
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"do raw mode variable output"
block|}
block|,
block|{
literal|"cooked"
block|,
name|cooked
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"do cooked mode variable output"
block|}
block|,
block|{
literal|"authenticate"
block|,
name|authenticate
block|,
block|{
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"always authenticate requests to this server"
block|}
block|,
block|{
literal|"ntpversion"
block|,
name|ntpversion
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"version number"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the NTP version number to use for requests"
block|}
block|,
block|{
literal|"keytype"
block|,
name|keytype
block|,
block|{
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key type (md5|des)"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set key type to use for authenticated requests (des|md5)"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default values we use.  */
end_comment

begin_define
define|#
directive|define
name|DEFTIMEOUT
value|(5)
end_define

begin_comment
comment|/* 5 second time out */
end_comment

begin_define
define|#
directive|define
name|DEFSTIMEOUT
value|(2)
end_define

begin_comment
comment|/* 2 second time out after first */
end_comment

begin_define
define|#
directive|define
name|DEFDELAY
value|0x51EB852
end_define

begin_comment
comment|/* 20 milliseconds, l_fp fraction */
end_comment

begin_define
define|#
directive|define
name|DEFHOST
value|"localhost"
end_define

begin_comment
comment|/* default host name */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters LONG */
end_comment

begin_define
define|#
directive|define
name|MAXCMDS
value|100
end_define

begin_comment
comment|/* maximum commands on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|100
end_define

begin_comment
comment|/* maximum hosts on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum line length */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|(1+MAXARGS+2)
end_define

begin_comment
comment|/* maximum number of usable tokens */
end_comment

begin_define
define|#
directive|define
name|MAXVARLEN
value|256
end_define

begin_comment
comment|/* maximum length of a variable name */
end_comment

begin_define
define|#
directive|define
name|MAXVALLEN
value|256
end_define

begin_comment
comment|/* maximum length of a variable value */
end_comment

begin_define
define|#
directive|define
name|MAXOUTLINE
value|72
end_define

begin_comment
comment|/* maximum length of an output line */
end_comment

begin_comment
comment|/*  * Some variables used and manipulated locally  */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|tvout
init|=
block|{
name|DEFTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time out for reads */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|tvsout
init|=
block|{
name|DEFSTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secondary time out */
end_comment

begin_decl_stmt
name|l_fp
name|delay_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay time */
end_comment

begin_decl_stmt
name|char
name|currenthost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current host name */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|hostaddr
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host address */
end_comment

begin_decl_stmt
name|int
name|showhostnames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show host names by default */
end_comment

begin_decl_stmt
name|int
name|sockfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd socket is openned on */
end_comment

begin_decl_stmt
name|int
name|havehost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when host open */
end_comment

begin_decl_stmt
name|struct
name|servent
modifier|*
name|server_entry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server entry for ntp */
end_comment

begin_comment
comment|/*  * Sequence number used for requests.  It is incremented before  * it is used.  */
end_comment

begin_decl_stmt
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Holds data returned from queries.  Declare buffer LONG to be sure of  * alignment.  */
end_comment

begin_define
define|#
directive|define
name|MAXFRAGS
value|24
end_define

begin_comment
comment|/* maximum number of fragments */
end_comment

begin_define
define|#
directive|define
name|DATASIZE
value|(MAXFRAGS*480)
end_define

begin_comment
comment|/* maximum amount of data */
end_comment

begin_decl_stmt
name|LONG
name|pktdata
index|[
name|DATASIZE
operator|/
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Holds association data for use with the&n operator.  */
end_comment

begin_decl_stmt
name|struct
name|association
name|assoc_cache
index|[
name|MAXASSOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numassoc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached associations */
end_comment

begin_comment
comment|/*  * For commands typed on the command line (with the -c option)  */
end_comment

begin_decl_stmt
name|int
name|numcmds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ccmds
index|[
name|MAXCMDS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDCMD
parameter_list|(
name|cp
parameter_list|)
value|if (numcmds< MAXCMDS) ccmds[numcmds++] = (cp)
end_define

begin_comment
comment|/*  * When multiple hosts are specified.  */
end_comment

begin_decl_stmt
name|int
name|numhosts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chosts
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDHOST
parameter_list|(
name|cp
parameter_list|)
value|if (numhosts< MAXHOSTS) chosts[numhosts++] = (cp)
end_define

begin_comment
comment|/*  * Error codes for internal use  */
end_comment

begin_define
define|#
directive|define
name|ERR_UNSPEC
value|256
end_define

begin_define
define|#
directive|define
name|ERR_INCOMPLETE
value|257
end_define

begin_define
define|#
directive|define
name|ERR_TIMEOUT
value|258
end_define

begin_define
define|#
directive|define
name|ERR_TOOMUCH
value|259
end_define

begin_comment
comment|/*  * Macro definitions we use  */
end_comment

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Jump buffer for longjumping back to the command level  */
end_comment

begin_decl_stmt
name|jmp_buf
name|interrupt_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Points at file being currently printed into  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|current_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command table imported from ntpdc_ops.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|xcmd
name|opcmds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
name|delay_time
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|DEFDELAY
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:dinp"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|ADDCMD
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|showhostnames
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ADDCMD
argument_list|(
literal|"peers"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflg
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-dinp] [-c cmd] host ...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntp_optind
operator|==
name|argc
condition|)
block|{
name|ADDHOST
argument_list|(
name|DEFHOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|ntp_optind
operator|<
name|argc
condition|;
name|ntp_optind
operator|++
control|)
name|ADDHOST
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numcmds
operator|==
literal|0
operator|&&
name|interactive
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|interactive
condition|)
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGINT
argument_list|,
name|abortcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|numcmds
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|openhost
argument_list|(
name|chosts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getcmds
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|ihost
decl_stmt|;
name|int
name|icmd
decl_stmt|;
for|for
control|(
name|ihost
operator|=
literal|0
init|;
name|ihost
operator|<
name|numhosts
condition|;
name|ihost
operator|++
control|)
block|{
if|if
condition|(
name|openhost
argument_list|(
name|chosts
index|[
name|ihost
index|]
argument_list|)
condition|)
for|for
control|(
name|icmd
operator|=
literal|0
init|;
name|icmd
operator|<
name|numcmds
condition|;
name|icmd
operator|++
control|)
name|docmd
argument_list|(
name|ccmds
index|[
name|icmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * openhost - open a socket to a host  */
end_comment

begin_function
specifier|static
name|int
name|openhost
parameter_list|(
name|hname
parameter_list|)
name|char
modifier|*
name|hname
decl_stmt|;
block|{
name|U_LONG
name|netnum
decl_stmt|;
name|char
name|temphost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
if|if
condition|(
name|server_entry
operator|==
name|NULL
condition|)
block|{
name|server_entry
operator|=
name|getservbyname
argument_list|(
literal|"ntp"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_entry
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ntp/udp: unknown service\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Got ntp/udp service entry\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|hname
argument_list|,
operator|&
name|netnum
argument_list|,
name|temphost
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Opening host %s\n"
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
if|if
condition|(
name|havehost
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Closing old host %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|currenthost
argument_list|,
name|temphost
argument_list|)
expr_stmt|;
name|hostaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|hostaddr
operator|.
name|sin_port
operator|=
name|server_entry
operator|->
name|s_port
expr_stmt|;
name|hostaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|netnum
expr_stmt|;
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"socket"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
operator|&&
operator|(
name|SYS_HPUX
operator|<
literal|8
operator|)
ifdef|#
directive|ifdef
name|SO_RCVBUF
block|{
name|int
name|rbufsize
init|=
name|DATASIZE
operator|+
literal|2048
decl_stmt|;
comment|/* 2K for slop */
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"setsockopt"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hostaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|hostaddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"connect"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the remote host  */
end_comment

begin_function
specifier|static
name|int
name|sendpkt
parameter_list|(
name|xdata
parameter_list|,
name|xdatalen
parameter_list|)
name|char
modifier|*
name|xdata
decl_stmt|;
name|int
name|xdatalen
decl_stmt|;
block|{
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Sending %d octets\n"
argument_list|,
name|xdatalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sockfd
argument_list|,
name|xdata
argument_list|,
name|xdatalen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"write to %s failed"
argument_list|,
name|currenthost
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|int
name|first
init|=
literal|8
decl_stmt|;
name|printf
argument_list|(
literal|"Packet data:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|xdatalen
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|first
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|7
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|xdata
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * getresponse - get a (series of) response packet(s) and return the data  */
end_comment

begin_function
specifier|static
name|int
name|getresponse
parameter_list|(
name|opcode
parameter_list|,
name|associd
parameter_list|,
name|rstatus
parameter_list|,
name|rsize
parameter_list|,
name|rdata
parameter_list|,
name|timeo
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|int
name|associd
decl_stmt|;
name|u_short
modifier|*
name|rstatus
decl_stmt|;
name|int
modifier|*
name|rsize
decl_stmt|;
name|char
modifier|*
modifier|*
name|rdata
decl_stmt|;
name|int
name|timeo
decl_stmt|;
block|{
name|struct
name|ntp_control
name|rpkt
decl_stmt|;
name|struct
name|timeval
name|tvo
decl_stmt|;
name|u_short
name|offsets
index|[
name|MAXFRAGS
operator|+
literal|1
index|]
decl_stmt|;
name|u_short
name|counts
index|[
name|MAXFRAGS
operator|+
literal|1
index|]
decl_stmt|;
name|u_short
name|offset
decl_stmt|;
name|u_short
name|count
decl_stmt|;
name|int
name|numfrags
decl_stmt|;
name|int
name|seenlastfrag
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * This is pretty tricky.  We may get between 1 and MAXFRAG packets 	 * back in response to the request.  We peel the data out of 	 * each packet and collect it in one LONG block.  When the last 	 * packet in the sequence is received we'll know how much data we 	 * should have had.  Note we use one LONG time out, should reconsider. 	 */
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rstatus
condition|)
operator|*
name|rstatus
operator|=
literal|0
expr_stmt|;
operator|*
name|rdata
operator|=
operator|(
name|char
operator|*
operator|)
name|pktdata
expr_stmt|;
name|numfrags
operator|=
literal|0
expr_stmt|;
name|seenlastfrag
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|numfrags
operator|==
literal|0
condition|)
name|tvo
operator|=
name|tvout
expr_stmt|;
else|else
name|tvo
operator|=
name|tvsout
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|1
condition|)
name|printf
argument_list|(
literal|"select() returns %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"select fails"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Timed out.  Return what we have 		 */
if|if
condition|(
name|numfrags
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeo
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out, nothing received\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
name|ERR_TIMEOUT
return|;
block|}
else|else
block|{
if|if
condition|(
name|timeo
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out with incomplete data\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Received fragments:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|numfrags
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|"%4d %d\n"
argument_list|,
name|offsets
index|[
name|n
index|]
argument_list|,
name|counts
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|seenlastfrag
condition|)
name|printf
argument_list|(
literal|"last fragment received\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"last fragment not received\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ERR_INCOMPLETE
return|;
block|}
block|}
name|n
operator|=
name|read
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"read"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|int
name|len
init|=
name|n
decl_stmt|,
name|first
init|=
literal|8
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
decl_stmt|;
name|printf
argument_list|(
literal|"Packet data:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|first
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|7
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|data
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for format errors.  Bug proofing. 	 */
if|if
condition|(
name|n
operator|<
name|CTL_HEADER_LEN
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Short (%d byte) packet received\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|<=
name|NTP_OLDVERSION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with version %d\n"
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with mode %d\n"
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|!
name|CTL_ISRESPONSE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received request packet, wanted response\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check opcode and sequence number for a match. 	 * Could be old data getting to us. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|sequence
argument_list|)
operator|!=
name|sequence
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received sequnce number %d, wanted %d\n"
argument_list|,
name|ntohs
argument_list|(
name|rpkt
operator|.
name|sequence
argument_list|)
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|CTL_OP
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
operator|!=
name|opcode
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received opcode %d, wanted %d (sequence number okay)\n"
argument_list|,
name|CTL_OP
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check the error code.  If non-zero, return it. 	 */
if|if
condition|(
name|CTL_ISERROR
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|int
name|errcode
decl_stmt|;
name|errcode
operator|=
operator|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|status
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error code %d received on not-final packet\n"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|==
name|CERR_UNSPEC
condition|)
return|return
name|ERR_UNSPEC
return|;
return|return
name|errcode
return|;
block|}
comment|/* 	 * Check the association ID to make sure it matches what 	 * we sent. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|associd
argument_list|)
operator|!=
name|associd
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Association ID %d doesn't match expected %d\n"
argument_list|,
name|ntohs
argument_list|(
name|rpkt
operator|.
name|associd
argument_list|)
argument_list|,
name|associd
argument_list|)
expr_stmt|;
comment|/* 	 * Hack for silly fuzzballs which, at the time of writing, 	 * return an assID of sys.peer when queried for system variables. 	 */
ifdef|#
directive|ifdef
name|notdef
goto|goto
name|again
goto|;
endif|#
directive|endif
block|}
comment|/* 	 * Collect offset and count.  Make sure they make sense. 	 */
name|offset
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|count
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
name|int
name|shouldbesize
decl_stmt|;
name|U_LONG
name|key
decl_stmt|;
name|U_LONG
modifier|*
name|lpkt
decl_stmt|;
name|int
name|maclen
decl_stmt|;
comment|/* 		 * Usually we ignore authentication, but for debugging purposes 		 * we watch it here. 		 */
name|shouldbesize
operator|=
name|CTL_HEADER_LEN
operator|+
name|count
expr_stmt|;
comment|/* round to 8 octet boundary */
name|shouldbesize
operator|=
operator|(
name|shouldbesize
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|n
operator|&
literal|0x3
condition|)
block|{
name|printf
argument_list|(
literal|"Packet not padded, size = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|maclen
operator|=
name|n
operator|-
name|shouldbesize
operator|)
operator|>=
name|MIN_MAC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"Packet shows signs of authentication (total %d, data %d, mac %d)\n"
argument_list|,
name|n
argument_list|,
name|shouldbesize
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
name|lpkt
operator|=
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|rpkt
expr_stmt|;
name|printf
argument_list|(
literal|"%08lx %08lx %08lx %08lx %08lx %08lx\n"
argument_list|,
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|-
literal|3
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|-
literal|2
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Authenticated with keyid %lu\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
literal|0
operator|&&
name|key
operator|!=
name|info_auth_keyid
condition|)
block|{
name|printf
argument_list|(
literal|"We don't know that key\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|authdecrypt
argument_list|(
name|key
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
operator|(
name|n
operator|-
name|maclen
operator|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Auth okay!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Auth failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Got packet, size = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
call|(
name|u_short
call|)
argument_list|(
name|n
operator|-
name|CTL_HEADER_LEN
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received count of %d octets, data in packet is %d\n"
argument_list|,
name|count
argument_list|,
name|n
operator|-
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received count of 0 in non-final fragment\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|offset
operator|+
name|count
operator|>
sizeof|sizeof
argument_list|(
name|pktdata
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Offset %d, count %d, too big for buffer\n"
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|ERR_TOOMUCH
return|;
block|}
if|if
condition|(
name|seenlastfrag
operator|&&
operator|!
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received second last fragment packet\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * So far, so good.  Record this fragment, making sure it doesn't 	 * overlap anything. 	 */
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Packet okay\n"
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|numfrags
operator|==
name|MAXFRAGS
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Number of fragments exceeds maximum\n"
argument_list|)
expr_stmt|;
return|return
name|ERR_TOOMUCH
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|numfrags
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|offsets
index|[
name|n
index|]
condition|)
goto|goto
name|again
goto|;
comment|/* duplicate */
if|if
condition|(
name|offset
operator|<
name|offsets
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
call|(
name|u_short
call|)
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|offsets
index|[
name|n
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|>
name|offset
condition|)
goto|goto
name|overlap
goto|;
if|if
condition|(
name|n
operator|<
name|numfrags
operator|&&
call|(
name|u_short
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|offsets
index|[
name|n
index|]
condition|)
goto|goto
name|overlap
goto|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|numfrags
init|;
name|i
operator|>
name|n
condition|;
name|i
operator|--
control|)
block|{
name|offsets
index|[
name|i
index|]
operator|=
name|offsets
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|counts
index|[
name|i
index|]
operator|=
name|counts
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
name|offsets
index|[
name|n
index|]
operator|=
name|offset
expr_stmt|;
name|counts
index|[
name|n
index|]
operator|=
name|count
expr_stmt|;
name|numfrags
operator|++
expr_stmt|;
comment|/* 	 * Got that stuffed in right.  Figure out if this was the last. 	 * Record status info out of the last packet. 	 */
if|if
condition|(
operator|!
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|seenlastfrag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rstatus
operator|!=
literal|0
condition|)
operator|*
name|rstatus
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy the data into the data buffer. 	 */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pktdata
operator|+
name|offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rpkt
operator|.
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * If we've seen the last fragment, look for holes in the sequence. 	 * If there aren't any, we're done. 	 */
if|if
condition|(
name|seenlastfrag
operator|&&
name|offsets
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|numfrags
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|offsets
index|[
name|n
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|n
operator|-
literal|1
index|]
operator|!=
name|offsets
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|numfrags
condition|)
block|{
operator|*
name|rsize
operator|=
name|offsets
index|[
name|numfrags
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|numfrags
operator|-
literal|1
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
goto|goto
name|again
goto|;
name|overlap
label|:
comment|/* 	 * Print debugging message about overlapping fragments 	 */
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Overlapping fragments returned in response\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * sendrequest - format and send a request packet  */
end_comment

begin_function
specifier|static
name|int
name|sendrequest
parameter_list|(
name|opcode
parameter_list|,
name|associd
parameter_list|,
name|auth
parameter_list|,
name|qsize
parameter_list|,
name|qdata
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|int
name|associd
decl_stmt|;
name|int
name|auth
decl_stmt|;
name|int
name|qsize
decl_stmt|;
name|char
modifier|*
name|qdata
decl_stmt|;
block|{
name|struct
name|ntp_control
name|qpkt
decl_stmt|;
name|int
name|pktsize
decl_stmt|;
comment|/* 	 * Check to make sure the data will fit in one packet 	 */
if|if
condition|(
name|qsize
operator|>
name|CTL_MAX_DATA_LEN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Internal error!  qsize (%d) too large\n"
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Fill in the packet 	 */
name|qpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
literal|0
argument_list|,
name|pktversion
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|r_m_e_op
operator|=
operator|(
name|u_char
operator|)
name|opcode
operator|&
name|CTL_OP_MASK
expr_stmt|;
name|qpkt
operator|.
name|sequence
operator|=
name|htons
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|qpkt
operator|.
name|associd
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|associd
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|qpkt
operator|.
name|count
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|qsize
argument_list|)
expr_stmt|;
comment|/* 	 * If we have data, copy it in and pad it out to a 64 	 * bit boundary. 	 */
if|if
condition|(
name|qsize
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qpkt
operator|.
name|data
argument_list|,
name|qdata
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
name|pktsize
operator|=
name|qsize
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
while|while
condition|(
name|pktsize
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|qpkt
operator|.
name|data
index|[
name|qsize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pktsize
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|pktsize
operator|=
name|CTL_HEADER_LEN
expr_stmt|;
block|}
comment|/* 	 * If it isn't authenticated we can just send it.  Otherwise 	 * we're going to have to think about it a little. 	 */
if|if
condition|(
operator|!
name|auth
operator|&&
operator|!
name|always_auth
condition|)
block|{
return|return
name|sendpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|pass
decl_stmt|;
comment|/* 		 * Pad out packet to a multiple of 8 octets to be sure 		 * receiver can handle it. 		 */
while|while
condition|(
name|pktsize
operator|&
literal|7
condition|)
block|{
name|qpkt
operator|.
name|data
index|[
name|qsize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pktsize
operator|++
expr_stmt|;
block|}
comment|/* 		 * Get the keyid and the password if we don't have one. 		 */
if|if
condition|(
name|info_auth_keyid
operator|==
operator|-
literal|1
condition|)
block|{
name|info_auth_keyid
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Keyid must be defined, request not sent\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|auth_havekey
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
name|pass
operator|=
name|getpass
argument_list|(
literal|"Password: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pass
operator|!=
literal|'\0'
condition|)
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_havekey
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
name|int
name|maclen
decl_stmt|;
comment|/* 			 * Stick the keyid in the packet where 			 * cp currently points.  Cp should be aligned 			 * properly.  Then do the encryptions. 			 */
operator|*
operator|(
name|U_LONG
operator|*
operator|)
operator|(
operator|&
name|qpkt
operator|.
name|data
index|[
name|qsize
index|]
operator|)
operator|=
name|htonl
argument_list|(
name|info_auth_keyid
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|info_auth_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
argument_list|)
expr_stmt|;
return|return
name|sendpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
operator|+
name|maclen
argument_list|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No password, request not sent\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * doquery - send a request and process the response  */
end_comment

begin_function
name|int
name|doquery
parameter_list|(
name|opcode
parameter_list|,
name|associd
parameter_list|,
name|auth
parameter_list|,
name|qsize
parameter_list|,
name|qdata
parameter_list|,
name|rstatus
parameter_list|,
name|rsize
parameter_list|,
name|rdata
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|int
name|associd
decl_stmt|;
name|int
name|auth
decl_stmt|;
name|int
name|qsize
decl_stmt|;
name|char
modifier|*
name|qdata
decl_stmt|;
name|u_short
modifier|*
name|rstatus
decl_stmt|;
name|int
modifier|*
name|rsize
decl_stmt|;
name|char
modifier|*
modifier|*
name|rdata
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* 	 * Check to make sure host is open 	 */
if|if
condition|(
operator|!
name|havehost
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No host open, use `host' command\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|done
operator|=
literal|0
expr_stmt|;
name|sequence
operator|++
expr_stmt|;
name|again
label|:
comment|/* 	 * send a request 	 */
name|res
operator|=
name|sendrequest
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
comment|/* 	 * Get the response.  If we got a standard error, print a message 	 */
name|res
operator|=
name|getresponse
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|rstatus
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|res
operator|==
name|ERR_TIMEOUT
operator|||
name|res
operator|==
name|ERR_INCOMPLETE
operator|)
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|ERR_INCOMPLETE
condition|)
block|{
comment|/* 				 * better bump the sequence so we don't 				 * get confused about differing fragments. 				 */
name|sequence
operator|++
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|CERR_BADFMT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a bad format request packet\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_PERMISSION
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server disallowed request (authentication?)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADOP
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a bad opcode in request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADASSOC
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association ID %d unknown to server\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_UNKNOWNVAR
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***A request variable was unknown to the server\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADVALUE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server indicates a request variable was bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_UNSPEC
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returned an unspecified error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TIMEOUT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Request timed out\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_INCOMPLETE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Response from server was incomplete\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TOOMUCH
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Buffer size exceeded for returned data\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returns unknown error code %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * getcmds - read commands from the standard input and execute them  */
end_comment

begin_function
specifier|static
name|void
name|getcmds
parameter_list|()
block|{
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|interactive
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|docmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * abortcmd - catch interrupts and abort the current command  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|abortcmd
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|current_output
operator|==
name|stdout
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|longjmp
argument_list|(
name|interrupt_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * docmd - decode the command line and execute a command  */
end_comment

begin_function
specifier|static
name|void
name|docmd
parameter_list|(
name|cmdline
parameter_list|)
name|char
modifier|*
name|cmdline
decl_stmt|;
block|{
name|char
modifier|*
name|tokens
index|[
literal|1
operator|+
name|MAXARGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|parse
name|pcmd
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|static
name|int
name|i
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcmd
decl_stmt|;
comment|/* 	 * Tokenize the command line.  If nothing on it, return. 	 */
name|tokenize
argument_list|(
name|cmdline
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Find the appropriate command description. 	 */
name|i
operator|=
name|findcmd
argument_list|(
name|tokens
index|[
literal|0
index|]
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' unknown\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' ambiguous\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Save the keyword, then walk through the arguments, interpreting 	 * as we go. 	 */
name|pcmd
operator|.
name|keyword
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pcmd
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|>=
name|ntok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
condition|)
block|{
name|printusage
argument_list|(
name|xcmd
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
operator|&&
operator|(
operator|*
name|tokens
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|getarg
argument_list|(
name|tokens
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
operator|&
name|pcmd
operator|.
name|argval
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
name|pcmd
operator|.
name|nargs
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ntok
operator|&&
operator|*
name|tokens
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|tokens
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|ntok
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No file for redirect\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_output
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_output
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Error opening %s: "
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
comment|/* flag we need a close */
block|}
else|else
block|{
name|current_output
operator|=
name|stdout
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* flag no close */
block|}
if|if
condition|(
name|interactive
operator|&&
name|setjmp
argument_list|(
name|interrupt_buf
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|jump
operator|++
expr_stmt|;
call|(
name|xcmd
operator|->
name|handler
call|)
argument_list|(
operator|&
name|pcmd
argument_list|,
name|current_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|current_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * tokenize - turn a command line into tokens  */
end_comment

begin_function
specifier|static
name|void
name|tokenize
parameter_list|(
name|line
parameter_list|,
name|tokens
parameter_list|,
name|ntok
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
name|int
modifier|*
name|ntok
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
name|char
name|tspace
index|[
name|MAXLINE
index|]
decl_stmt|;
name|sp
operator|=
name|tspace
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
for|for
control|(
operator|*
name|ntok
operator|=
literal|0
init|;
operator|*
name|ntok
operator|<
name|MAXTOKENS
condition|;
operator|(
operator|*
name|ntok
operator|)
operator|++
control|)
block|{
name|tokens
index|[
operator|*
name|ntok
index|]
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * findcmd - find a command in a command description table  */
end_comment

begin_function
specifier|static
name|int
name|findcmd
parameter_list|(
name|str
parameter_list|,
name|clist1
parameter_list|,
name|clist2
parameter_list|,
name|cmd
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist1
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist2
decl_stmt|;
name|struct
name|xcmd
modifier|*
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|struct
name|xcmd
modifier|*
name|cl
decl_stmt|;
specifier|register
name|int
name|clen
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|nearmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clist1
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist1
expr_stmt|;
elseif|else
if|if
condition|(
name|clist2
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist2
expr_stmt|;
else|else
return|return
literal|0
return|;
name|again
label|:
for|for
control|(
name|cl
operator|=
name|clist
init|;
name|cl
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|cl
operator|++
control|)
block|{
comment|/* do a first character check, for efficiency */
if|if
condition|(
operator|*
name|str
operator|!=
operator|*
operator|(
name|cl
operator|->
name|keyword
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|cl
operator|->
name|keyword
argument_list|,
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Could be extact match, could be approximate. 			 * Is exact if the length of the keyword is the 			 * same as the str. 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|cl
operator|->
name|keyword
operator|)
operator|+
name|clen
operator|)
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cmd
operator|=
name|cl
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|nearmatch
operator|=
name|cl
expr_stmt|;
block|}
block|}
comment|/* 	 * See if there is more to do.  If so, go again.  Sorry about the 	 * goto, too much looking at BSD sources... 	 */
if|if
condition|(
name|clist
operator|==
name|clist1
operator|&&
name|clist2
operator|!=
literal|0
condition|)
block|{
name|clist
operator|=
name|clist2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If we got extactly 1 near match, use it, else return number 	 * of matches. 	 */
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
operator|*
name|cmd
operator|=
name|nearmatch
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|nmatch
return|;
block|}
end_function

begin_comment
comment|/*  * getarg - interpret an argument token  */
end_comment

begin_function
specifier|static
name|int
name|getarg
parameter_list|(
name|str
parameter_list|,
name|code
parameter_list|,
name|argp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|code
decl_stmt|;
name|arg_v
modifier|*
name|argp
decl_stmt|;
block|{
name|int
name|isneg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|static
name|char
modifier|*
name|digits
init|=
literal|"0123456789"
decl_stmt|;
switch|switch
condition|(
name|code
operator|&
operator|~
name|OPT
condition|)
block|{
case|case
name|STR
case|:
name|argp
operator|->
name|string
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|ADD
case|:
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|str
argument_list|,
operator|&
operator|(
name|argp
operator|->
name|netnum
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
break|break;
case|case
name|INT
case|:
case|case
name|UINT
case|:
name|isneg
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'&'
condition|)
block|{
name|np
operator|++
expr_stmt|;
name|isneg
operator|=
name|atoi
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association value `%s' invalid/undecodable\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isneg
operator|>
name|numassoc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association for `%s' unknown (max&%d)\n"
argument_list|,
name|str
argument_list|,
name|numassoc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|uval
operator|=
name|assoc_cache
index|[
name|isneg
operator|-
literal|1
index|]
operator|.
name|assid
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|np
operator|==
literal|'-'
condition|)
block|{
name|np
operator|++
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
name|argp
operator|->
name|uval
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|digits
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Illegal integer value %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|uval
operator|*=
literal|10
expr_stmt|;
name|argp
operator|->
name|uval
operator|+=
operator|(
name|cp
operator|-
name|digits
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
operator|++
name|np
operator|)
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|isneg
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
operator|~
name|OPT
operator|)
operator|==
name|UINT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Value %s should be unsigned\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argp
operator|->
name|ival
operator|=
operator|-
name|argp
operator|->
name|ival
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * getnetnum - given a host name, return its net number  *	       and (optional) full name  */
end_comment

begin_function
name|int
name|getnetnum
parameter_list|(
name|host
parameter_list|,
name|num
parameter_list|,
name|fullhost
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|U_LONG
modifier|*
name|num
decl_stmt|;
name|char
modifier|*
name|fullhost
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|decodenetnum
argument_list|(
name|host
argument_list|,
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|fullhost
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fullhost
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
operator|(
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
name|htonl
argument_list|(
operator|*
name|num
argument_list|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullhost
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fullhost
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Can't find host %s\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * nntohost - convert network number to host name.  This routine enforces  *	       the showhostnames setting.  */
end_comment

begin_function
name|char
modifier|*
name|nntohost
parameter_list|(
name|netnum
parameter_list|)
name|U_LONG
name|netnum
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|showhostnames
condition|)
return|return
name|numtoa
argument_list|(
name|netnum
argument_list|)
return|;
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|netnum
argument_list|)
operator|&
name|REFCLOCK_MASK
operator|)
operator|==
name|REFCLOCK_ADDR
condition|)
return|return
name|refnumtoa
argument_list|(
name|netnum
argument_list|)
return|;
return|return
name|numtohost
argument_list|(
name|netnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * rtdatetolfp - decode an RT-11 date into an l_fp  */
end_comment

begin_function
specifier|static
name|int
name|rtdatetolfp
parameter_list|(
name|str
parameter_list|,
name|lfp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|l_fp
modifier|*
name|lfp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|calendar
name|cal
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|months
index|[
literal|12
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
name|cal
operator|.
name|yearday
operator|=
literal|0
expr_stmt|;
comment|/* 	 * An RT-11 date looks like: 	 * 	 * d[d]-Mth-y[y] hh:mm:ss 	 */
name|cp
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * Catch special case 			 */
name|lfp
operator|->
name|l_ui
operator|=
name|lfp
operator|->
name|l_uf
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
name|cal
operator|.
name|monthday
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
comment|/* ascii dependent */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|monthday
operator|=
operator|(
name|cal
operator|.
name|monthday
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|monthday
operator|<<
literal|1
operator|)
expr_stmt|;
name|cal
operator|.
name|monthday
operator|+=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|buf
argument_list|,
name|months
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|12
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|month
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|year
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
expr_stmt|;
name|cal
operator|.
name|year
operator|+=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
comment|/* 	 * Catch special case.  If cal.year == 0 this is a zero timestamp. 	 */
if|if
condition|(
name|cal
operator|.
name|year
operator|==
literal|0
condition|)
block|{
name|lfp
operator|->
name|l_ui
operator|=
name|lfp
operator|->
name|l_uf
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|' '
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|hour
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|hour
operator|=
operator|(
name|cal
operator|.
name|hour
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|hour
operator|<<
literal|1
operator|)
expr_stmt|;
name|cal
operator|.
name|hour
operator|+=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|minute
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|minute
operator|=
operator|(
name|cal
operator|.
name|minute
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|minute
operator|<<
literal|1
operator|)
expr_stmt|;
name|cal
operator|.
name|minute
operator|+=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|second
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|second
operator|=
operator|(
name|cal
operator|.
name|second
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|second
operator|<<
literal|1
operator|)
expr_stmt|;
name|cal
operator|.
name|second
operator|+=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
name|cal
operator|.
name|year
operator|+=
literal|1900
expr_stmt|;
name|lfp
operator|->
name|l_ui
operator|=
name|caltontp
argument_list|(
operator|&
name|cal
argument_list|)
expr_stmt|;
name|lfp
operator|->
name|l_uf
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * decodets - decode a timestamp into an l_fp format number, with  *	      consideration of fuzzball formats.  */
end_comment

begin_function
name|int
name|decodets
parameter_list|(
name|str
parameter_list|,
name|lfp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|l_fp
modifier|*
name|lfp
decl_stmt|;
block|{
comment|/* 	 * If it starts with a 0x, decode as hex. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
return|return
name|hextolfp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|lfp
argument_list|)
return|;
comment|/* 	 * If it starts with a '"', try it as an RT-11 date. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'"'
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|str
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'"'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|bp
operator|<
operator|&
name|buf
index|[
literal|29
index|]
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rtdatetolfp
argument_list|(
name|buf
argument_list|,
name|lfp
argument_list|)
return|;
block|}
comment|/* 	 * Might still be hex.  Check out the first character.  Talk 	 * about heuristics! 	 */
if|if
condition|(
operator|(
operator|*
name|str
operator|>=
literal|'A'
operator|&&
operator|*
name|str
operator|<=
literal|'F'
operator|)
operator|||
operator|(
operator|*
name|str
operator|>=
literal|'a'
operator|&&
operator|*
name|str
operator|<=
literal|'f'
operator|)
condition|)
return|return
name|hextolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
comment|/* 	 * Try it as a decimal.  If this fails, try as an unquoted 	 * RT-11 date.  This code should go away eventually. 	 */
if|if
condition|(
name|atolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|rtdatetolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodetime - decode a time value.  It should be in milliseconds  */
end_comment

begin_function
name|int
name|decodetime
parameter_list|(
name|str
parameter_list|,
name|lfp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|l_fp
modifier|*
name|lfp
decl_stmt|;
block|{
return|return
name|mstolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_comment
comment|/*  * decodereach - decode a (possibly octal or hex, damn fuzzballs) reachability  */
end_comment

begin_function
specifier|static
name|int
name|decodereach
parameter_list|(
name|str
parameter_list|,
name|uval
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|U_LONG
modifier|*
name|uval
decl_stmt|;
block|{
name|U_LONG
name|u
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
comment|/* 		 * Could be octal or hex 		 */
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|uval
argument_list|)
return|;
return|return
name|octtoint
argument_list|(
name|str
argument_list|,
name|uval
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|str
argument_list|,
operator|&
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|u
operator|>
literal|255
condition|)
return|return
name|octtoint
argument_list|(
name|str
argument_list|,
name|uval
argument_list|)
return|;
operator|*
name|uval
operator|=
name|u
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/*  * decodeint - decode an integer  */
end_comment

begin_function
name|int
name|decodeint
parameter_list|(
name|str
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|LONG
modifier|*
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|val
argument_list|)
return|;
return|return
name|octtoint
argument_list|(
name|str
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|val
argument_list|)
return|;
block|}
return|return
name|atoint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodeuint - decode an unsigned integer  */
end_comment

begin_function
name|int
name|decodeuint
parameter_list|(
name|str
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|U_LONG
modifier|*
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|val
argument_list|)
return|;
return|return
name|octtoint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
return|;
block|}
return|return
name|atouint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodearr - decode an array of time values  */
end_comment

begin_function
specifier|static
name|int
name|decodearr
parameter_list|(
name|str
parameter_list|,
name|narr
parameter_list|,
name|lfparr
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|narr
decl_stmt|;
name|l_fp
modifier|*
name|lfparr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|l_fp
modifier|*
name|lfp
decl_stmt|;
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|lfp
operator|=
name|lfparr
expr_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
operator|*
name|narr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|narr
operator|<
literal|8
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|decodetime
argument_list|(
name|buf
argument_list|,
name|lfp
argument_list|)
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|narr
operator|)
operator|++
expr_stmt|;
name|lfp
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * getcode - return string corresponding to code  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getcode
parameter_list|(
name|code
parameter_list|,
name|codetab
parameter_list|)
name|int
name|code
decl_stmt|;
name|struct
name|codestring
modifier|*
name|codetab
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
while|while
condition|(
name|codetab
operator|->
name|code
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|codetab
operator|->
name|code
operator|==
name|code
condition|)
return|return
name|codetab
operator|->
name|string
return|;
name|codetab
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s_%d"
argument_list|,
name|codetab
operator|->
name|string
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Finally, the built in command handlers  */
end_comment

begin_comment
comment|/*  * help - tell about commands, or details of a particular command  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|cmdsort
index|[
literal|100
index|]
decl_stmt|;
name|int
name|length
index|[
literal|100
index|]
decl_stmt|;
name|int
name|maxlength
decl_stmt|;
name|int
name|numperline
decl_stmt|;
specifier|static
name|char
modifier|*
name|spaces
init|=
literal|"                    "
decl_stmt|;
comment|/* 20 spaces */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|xcp
operator|=
name|builtins
init|;
name|xcp
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|xcp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|xcp
operator|->
name|keyword
operator|)
operator|!=
literal|'?'
condition|)
name|cmdsort
index|[
name|n
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
block|}
for|for
control|(
name|xcp
operator|=
name|opcmds
init|;
name|xcp
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|xcp
operator|++
control|)
name|cmdsort
index|[
name|n
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cmdsort
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
else|#
directive|else
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdsort
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi || bsdi */
name|maxlength
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|length
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|cmdsort
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
index|[
name|i
index|]
operator|>
name|maxlength
condition|)
name|maxlength
operator|=
name|length
index|[
name|i
index|]
expr_stmt|;
block|}
name|maxlength
operator|++
expr_stmt|;
name|numperline
operator|=
literal|76
operator|/
name|maxlength
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Commands available:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
name|numperline
operator|)
operator|==
operator|(
name|numperline
operator|-
literal|1
operator|)
operator|||
name|i
operator|==
operator|(
name|n
operator|-
literal|1
operator|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|cmdsort
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
name|cmdsort
index|[
name|i
index|]
argument_list|,
name|spaces
operator|+
literal|20
operator|-
name|maxlength
operator|+
name|length
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|n
operator|=
name|findcmd
argument_list|(
name|cmd
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is unknown\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is ambiguous\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"function: %s\n"
argument_list|,
name|xcp
operator|->
name|comment
argument_list|)
expr_stmt|;
name|printusage
argument_list|(
name|xcp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * helpsort - do hostname qsort comparisons  */
end_comment

begin_function
specifier|static
name|int
if|#
directive|if
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|helpsort
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|const
name|void
modifier|*
name|t1
decl_stmt|;
specifier|const
name|void
modifier|*
name|t2
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
modifier|*
name|name1
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|t1
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|name2
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|t2
decl_stmt|;
else|#
directive|else
name|helpsort
argument_list|(
argument|name1
argument_list|,
argument|name2
argument_list|)
name|char
modifier|*
modifier|*
name|name1
decl_stmt|;
name|char
modifier|*
modifier|*
name|name2
decl_stmt|;
block|{
endif|#
directive|endif
comment|/* sgi || bsdi */
return|return
name|strcmp
argument_list|(
operator|*
name|name1
argument_list|,
operator|*
name|name2
argument_list|)
return|;
block|}
comment|/*  * printusage - print usage information for a command  */
specifier|static
name|void
name|printusage
parameter_list|(
name|xcp
parameter_list|,
name|fp
parameter_list|)
name|struct
name|xcmd
modifier|*
name|xcp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage: %s"
argument_list|,
name|xcp
operator|->
name|keyword
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" [ %s ]"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * timeout - set time out time  */
specifier|static
name|void
name|timeout
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tvout
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"primary timeout %d ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tvout
operator|.
name|tv_sec
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|/
literal|1000
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|-
operator|(
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
block|}
comment|/*  * delay - set delay for auth requests  */
specifier|static
name|void
name|delay
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|isneg
decl_stmt|;
name|U_LONG
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|delay_time
operator|.
name|l_ui
operator|*
literal|1000
operator|+
name|delay_time
operator|.
name|l_uf
operator|/
literal|4294967
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %d ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
call|(
name|U_LONG
call|)
argument_list|(
operator|-
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|U_LONG
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
expr_stmt|;
block|}
name|delay_time
operator|.
name|l_ui
operator|=
name|val
operator|/
literal|1000
expr_stmt|;
name|val
operator|%=
literal|1000
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|val
operator|*
literal|4294967
expr_stmt|;
comment|/* 2**32/1000 */
if|if
condition|(
name|isneg
condition|)
name|L_NEG
argument_list|(
operator|&
name|delay_time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * host - set the host we are dealing with.  */
specifier|static
name|void
name|host
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host is %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no current host\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openhost
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host set to %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|numassoc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * poll - do one (or more) polls of the host via NTP  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|ntp_poll
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"poll not implemented yet\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * keyid - get a keyid to use for authenticating requests  */
specifier|static
name|void
name|keyid
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info_auth_keyid
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no keyid defined\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keyid is %u\n"
argument_list|,
name|info_auth_keyid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_auth_keyid
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
comment|/*  * keytype - get type of key to use for authenticating requests  */
specifier|static
name|void
name|keytype
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype is %s"
argument_list|,
operator|(
name|info_auth_keytype
operator|==
name|KEY_TYPE_MD5
operator|)
condition|?
literal|"md5"
else|:
literal|"des"
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
operator|)
condition|)
block|{
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|info_auth_keytype
operator|=
name|KEY_TYPE_MD5
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|info_auth_keytype
operator|=
name|KEY_TYPE_DES
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype must be 'md5' or 'des'\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * passwd - get an authentication key  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|passwd
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|pass
decl_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
operator|-
literal|1
condition|)
block|{
name|info_auth_keyid
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keyid must be defined\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|pass
operator|=
name|getpass
argument_list|(
literal|"Password: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pass
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Password unchanged\n"
argument_list|)
expr_stmt|;
else|else
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
comment|/*  * hostnames - set the showhostnames flag  */
specifier|static
name|void
name|hostnames
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|showhostnames
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames being shown\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames not being shown\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * setdebug - set/change debugging level  */
specifier|static
name|void
name|setdebug
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level is %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"more"
argument_list|)
condition|)
block|{
name|debug
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"less"
argument_list|)
condition|)
block|{
name|debug
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level set to %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
comment|/*  * quit - stop this nonsense  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|quit
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
comment|/* cleanliness next to godliness */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * version - print the current version number  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|version
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|Version
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
block|}
comment|/*  * raw - set raw mode output  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|raw
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|rawmode
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Output set to raw\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * cooked - set cooked mode output  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|cooked
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|rawmode
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Output set to cooked\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * authenticate - always authenticate requests to this host  */
specifier|static
name|void
name|authenticate
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|always_auth
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"authenticated requests being sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"unauthenticated requests being sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
block|{
name|always_auth
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|always_auth
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * ntpversion - choose the NTP version to use  */
specifier|static
name|void
name|ntpversion
parameter_list|(
name|pcmd
parameter_list|,
name|fp
parameter_list|)
name|struct
name|parse
modifier|*
name|pcmd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NTP version being claimed is %d\n"
argument_list|,
name|pktversion
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|<=
name|NTP_OLDVERSION
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|>
name|NTP_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"versions %d to %d, please\n"
argument_list|,
name|NTP_OLDVERSION
operator|+
literal|1
argument_list|,
name|NTP_VERSION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pktversion
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
block|}
comment|/*  * warning - print a warning message  */
specifier|static
name|void
name|warning
parameter_list|(
name|fmt
parameter_list|,
name|st1
parameter_list|,
name|st2
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|st1
decl_stmt|;
name|char
modifier|*
name|st2
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|st1
argument_list|,
name|st2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/*  * error - print a message and exit  */
specifier|static
name|void
name|error
parameter_list|(
name|fmt
parameter_list|,
name|st1
parameter_list|,
name|st2
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|st1
decl_stmt|;
name|char
modifier|*
name|st2
decl_stmt|;
block|{
name|warning
argument_list|(
name|fmt
argument_list|,
name|st1
argument_list|,
name|st2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * getkeyid - prompt the user for a keyid to use  */
specifier|static
name|U_LONG
name|getkeyid
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|FILE
modifier|*
name|fi
decl_stmt|;
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fi
operator|=
name|stdin
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|fi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pbuf
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
operator|&
name|pbuf
index|[
literal|18
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pbuf
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|U_LONG
operator|)
name|atoi
argument_list|(
name|pbuf
argument_list|)
return|;
block|}
comment|/*  * atoascii - printable-ize possibly ascii data using the character  *	      transformations cat -v uses.  */
specifier|static
name|void
name|atoascii
parameter_list|(
name|length
parameter_list|,
name|data
parameter_list|,
name|outdata
parameter_list|)
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|outdata
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ocp
decl_stmt|;
specifier|register
name|u_char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
operator|*
name|outdata
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|ocp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|outdata
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
init|;
name|cp
operator|<
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|length
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|>
literal|0177
condition|)
block|{
operator|*
name|ocp
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|ocp
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|&=
literal|0177
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
operator|*
name|ocp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|ocp
operator|++
operator|=
name|c
operator|+
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
block|{
operator|*
name|ocp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|ocp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ocp
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ocp
operator|>=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|outdata
operator|+
name|length
operator|-
literal|4
operator|)
condition|)
break|break;
block|}
operator|*
name|ocp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*  * makeascii - print possibly ascii data using the character  *	       transformations that cat -v uses.  */
specifier|static
name|void
name|makeascii
parameter_list|(
name|length
parameter_list|,
name|data
parameter_list|,
name|fp
parameter_list|)
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
init|;
name|cp
operator|<
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|length
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|int
operator|)
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0177
condition|)
block|{
name|putc
argument_list|(
literal|'M'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0177
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
operator|+
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'?'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * asciize - same thing as makeascii except add a newline  */
name|void
name|asciize
parameter_list|(
name|length
parameter_list|,
name|data
parameter_list|,
name|fp
parameter_list|)
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|makeascii
argument_list|(
name|length
argument_list|,
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*  * Some circular buffer space  */
define|#
directive|define
name|CBLEN
value|80
define|#
directive|define
name|NUMCB
value|6
name|char
name|circ_buf
index|[
name|NUMCB
index|]
index|[
name|CBLEN
index|]
decl_stmt|;
name|int
name|nextcb
init|=
literal|0
decl_stmt|;
comment|/*  * getevents - return a descriptive string for the event count  */
specifier|static
name|char
modifier|*
name|getevents
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
literal|"no events"
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d event%s"
argument_list|,
name|cnt
argument_list|,
operator|(
name|cnt
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/*  * statustoa - return a descriptive string for a peer status  */
specifier|static
name|char
modifier|*
name|statustoa
parameter_list|(
name|type
parameter_list|,
name|st
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|st
decl_stmt|;
block|{
name|char
modifier|*
name|cb
decl_stmt|;
name|u_char
name|pst
decl_stmt|;
name|cb
operator|=
operator|&
name|circ_buf
index|[
name|nextcb
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|nextcb
operator|>=
name|NUMCB
condition|)
name|nextcb
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_SYS
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
name|CTL_SYS_LI
argument_list|(
name|st
argument_list|)
argument_list|,
name|leap_codes
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
name|CTL_SYS_SOURCE
argument_list|(
name|st
argument_list|)
argument_list|,
name|sync_codes
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getevents
argument_list|(
name|CTL_SYS_NEVNT
argument_list|(
name|st
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
name|CTL_SYS_EVENT
argument_list|(
name|st
argument_list|)
argument_list|,
name|sys_codes
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_PEER
case|:
comment|/* 		 * Handcraft the bits 		 */
name|pst
operator|=
name|CTL_PEER_STATVAL
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pst
operator|&
name|CTL_PST_REACH
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cb
argument_list|,
literal|"unreach"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cb
argument_list|,
literal|"reach"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!(pst& CTL_PST_DISP)) { 				(void)strcat(cb, ", hi_disp"); 			} else { 				if (pst& CTL_PST_SANE) { 					if ((pst& 0x3) == CTL_PST_SEL_REJECT) 						(void)strcat(cb, ", sane"); 				} else { 					(void)strcat(cb, ", insane"); 				} 			}
endif|#
directive|endif
block|}
if|if
condition|(
name|pst
operator|&
name|CTL_PST_CONFIG
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", conf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|&
name|CTL_PST_AUTHENABLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pst
operator|&
name|CTL_PST_REACH
operator|)
operator|||
operator|(
name|pst
operator|&
name|CTL_PST_AUTHENTIC
operator|)
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", auth"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", unauth"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now the codes 		 */
if|if
condition|(
operator|(
name|pst
operator|&
literal|0x7
operator|)
operator|!=
name|CTL_PST_SEL_REJECT
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
name|pst
operator|&
literal|0x7
argument_list|,
name|select_codes
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getevents
argument_list|(
name|CTL_PEER_NEVNT
argument_list|(
name|st
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTL_PEER_EVENT
argument_list|(
name|st
argument_list|)
operator|!=
name|EVNT_UNSPEC
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
name|CTL_PEER_EVENT
argument_list|(
name|st
argument_list|)
argument_list|,
name|peer_codes
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CLOCK
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
operator|(
operator|(
name|st
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|clock_codes
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
literal|", last_"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cb
argument_list|,
name|getcode
argument_list|(
operator|(
name|st
operator|)
operator|&
literal|0xff
argument_list|,
name|clock_codes
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|cb
return|;
block|}
comment|/*  * nextvar - find the next variable in the buffer  */
name|int
name|nextvar
parameter_list|(
name|datalen
parameter_list|,
name|datap
parameter_list|,
name|vname
parameter_list|,
name|vvalue
parameter_list|)
name|int
modifier|*
name|datalen
decl_stmt|;
name|char
modifier|*
modifier|*
name|datap
decl_stmt|;
name|char
modifier|*
modifier|*
name|vname
decl_stmt|;
name|char
modifier|*
modifier|*
name|vvalue
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpend
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|name
index|[
name|MAXVARLEN
index|]
decl_stmt|;
specifier|static
name|char
name|value
index|[
name|MAXVALLEN
index|]
decl_stmt|;
name|cp
operator|=
operator|*
name|datap
expr_stmt|;
name|cpend
operator|=
name|cp
operator|+
operator|*
name|datalen
expr_stmt|;
comment|/* 	 * Space past commas and white space 	 */
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|cpend
condition|)
return|return
literal|0
return|;
comment|/* 	 * Copy name until we hit a ',', an '=', a '\r' or a '\n'.  Backspace 	 * over any white space and terminate it. 	 */
name|np
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|*
name|cp
operator|!=
literal|','
operator|&&
operator|*
name|cp
operator|!=
literal|'='
operator|&&
operator|*
name|cp
operator|!=
literal|'\r'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|np
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|np
operator|--
expr_stmt|;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|vname
operator|=
name|name
expr_stmt|;
comment|/* 	 * Check if we hit the end of the buffer or a ','.  If so we are done. 	 */
if|if
condition|(
name|cp
operator|==
name|cpend
operator|||
operator|*
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|'\r'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|cpend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|datap
operator|=
name|cp
expr_stmt|;
operator|*
name|datalen
operator|=
name|cpend
operator|-
name|cp
expr_stmt|;
operator|*
name|vvalue
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * So far, so good.  Copy out the value 	 */
name|cp
operator|++
expr_stmt|;
comment|/* past '=' */
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\r'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
name|np
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
operator|(
operator|*
name|cp
operator|!=
literal|','
operator|)
operator|||
name|quoted
operator|)
condition|)
block|{
name|quoted
operator|^=
operator|(
operator|(
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|'"'
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|np
operator|>
name|value
operator|&&
name|isspace
argument_list|(
operator|*
operator|(
name|np
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|np
operator|--
expr_stmt|;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Return this.  All done. 	 */
if|if
condition|(
name|cp
operator|!=
name|cpend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|datap
operator|=
name|cp
expr_stmt|;
operator|*
name|datalen
operator|=
name|cpend
operator|-
name|cp
expr_stmt|;
operator|*
name|vvalue
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * findvar - see if this variable is known to us  */
name|int
name|findvar
parameter_list|(
name|varname
parameter_list|,
name|varlist
parameter_list|)
name|char
modifier|*
name|varname
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|varlist
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|vl
decl_stmt|;
name|vl
operator|=
name|varlist
expr_stmt|;
name|np
operator|=
name|varname
expr_stmt|;
while|while
condition|(
name|vl
operator|->
name|fmt
operator|!=
name|EOV
condition|)
block|{
if|if
condition|(
name|vl
operator|->
name|fmt
operator|!=
name|PADDING
operator|&&
name|STREQ
argument_list|(
name|np
argument_list|,
name|vl
operator|->
name|text
argument_list|)
condition|)
return|return
name|vl
operator|->
name|code
return|;
name|vl
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * printvars - print variables returned in response packet  */
name|void
name|printvars
parameter_list|(
name|length
parameter_list|,
name|data
parameter_list|,
name|status
parameter_list|,
name|sttype
parameter_list|,
name|fp
parameter_list|)
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|sttype
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|rawmode
condition|)
name|rawprint
argument_list|(
name|sttype
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|status
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|cookedprint
argument_list|(
name|sttype
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|status
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*  * rawprint - do a printout of the data in raw mode  */
specifier|static
name|void
name|rawprint
parameter_list|(
name|datatype
parameter_list|,
name|length
parameter_list|,
name|data
parameter_list|,
name|status
parameter_list|,
name|fp
parameter_list|)
name|int
name|datatype
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpend
decl_stmt|;
comment|/* 	 * Essentially print the data as is.  We reformat unprintables, though. 	 */
name|cp
operator|=
name|data
expr_stmt|;
name|cpend
operator|=
name|data
operator|+
name|length
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"status=%04x %s\n"
argument_list|,
name|status
argument_list|,
name|statustoa
argument_list|(
name|datatype
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
comment|/* 			 * If this is a \r and the next character is a 			 * \n, supress this, else pretty print it.  Otherwise 			 * just output the character. 			 */
if|if
condition|(
name|cp
operator|==
operator|(
name|cpend
operator|-
literal|1
operator|)
operator|||
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
name|makeascii
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|makeascii
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/*  * Global data used by the cooked output routines  */
name|int
name|out_chars
decl_stmt|;
comment|/* number of characters output */
name|int
name|out_linecount
decl_stmt|;
comment|/* number of characters output on this line */
comment|/*  * startoutput - get ready to do cooked output  */
specifier|static
name|void
name|startoutput
parameter_list|()
block|{
name|out_chars
operator|=
literal|0
expr_stmt|;
name|out_linecount
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * output - output a variable=value combination  */
specifier|static
name|void
name|output
parameter_list|(
name|fp
parameter_list|,
name|name
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|lenname
decl_stmt|;
name|int
name|lenvalue
decl_stmt|;
name|lenname
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|lenvalue
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_chars
operator|!=
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_chars
operator|++
expr_stmt|;
name|out_linecount
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|out_linecount
operator|+
name|lenname
operator|+
name|lenvalue
operator|+
literal|3
operator|)
operator|>
name|MAXOUTLINE
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_chars
operator|++
expr_stmt|;
name|out_linecount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_chars
operator|++
expr_stmt|;
name|out_linecount
operator|++
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'='
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|value
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_chars
operator|+=
name|lenname
operator|+
literal|1
operator|+
name|lenvalue
expr_stmt|;
name|out_linecount
operator|+=
name|lenname
operator|+
literal|1
operator|+
name|lenvalue
expr_stmt|;
block|}
comment|/*  * endoutput - terminate a block of cooked output  */
specifier|static
name|void
name|endoutput
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|out_chars
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*  * outputarr - output an array of values  */
specifier|static
name|void
name|outputarr
parameter_list|(
name|fp
parameter_list|,
name|name
parameter_list|,
name|narr
parameter_list|,
name|lfp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|narr
decl_stmt|;
name|l_fp
modifier|*
name|lfp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Hack to align delay and offset values 	 */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
literal|10
condition|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
name|narr
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|narr
condition|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cp
operator|=
name|lfptoms
argument_list|(
name|lfp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|7
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|lfp
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
specifier|static
name|char
modifier|*
name|tstflags
parameter_list|(
name|val
parameter_list|)
name|U_LONG
name|val
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cb
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|sep
decl_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|cb
operator|=
operator|&
name|circ_buf
index|[
name|nextcb
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|nextcb
operator|>=
name|NUMCB
condition|)
name|nextcb
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|cb
argument_list|,
literal|"0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|cb
operator|+=
name|strlen
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|strcat
argument_list|(
name|cb
argument_list|,
literal|"<OK>"
argument_list|)
expr_stmt|;
name|cb
operator|+=
name|strlen
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cb
operator|++
operator|=
literal|'<'
expr_stmt|;
while|while
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|val
operator|&
literal|0x1
condition|)
block|{
name|sprintf
argument_list|(
name|cb
argument_list|,
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|tstflagnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|";"
expr_stmt|;
name|cb
operator|+=
name|strlen
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|cb
operator|++
operator|=
literal|'>'
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|cb
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
operator|*
name|cb
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/*  * cookedprint - output variables in cooked mode  */
specifier|static
name|void
name|cookedprint
parameter_list|(
name|datatype
parameter_list|,
name|length
parameter_list|,
name|data
parameter_list|,
name|status
parameter_list|,
name|fp
parameter_list|)
name|int
name|datatype
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|varid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|output_raw
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|varlist
decl_stmt|;
name|l_fp
name|lfp
decl_stmt|;
name|LONG
name|ival
decl_stmt|;
name|U_LONG
name|uval
decl_stmt|;
name|l_fp
name|lfparr
index|[
literal|8
index|]
decl_stmt|;
name|int
name|narr
decl_stmt|;
switch|switch
condition|(
name|datatype
condition|)
block|{
case|case
name|TYPE_PEER
case|:
name|varlist
operator|=
name|peer_var
expr_stmt|;
break|break;
case|case
name|TYPE_SYS
case|:
name|varlist
operator|=
name|sys_var
expr_stmt|;
break|break;
case|case
name|TYPE_CLOCK
case|:
name|varlist
operator|=
name|clock_var
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown datatype(0x%x) in cookedprint\n"
argument_list|,
name|datatype
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"status=%04x %s\n"
argument_list|,
name|status
argument_list|,
name|statustoa
argument_list|(
name|datatype
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|startoutput
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|length
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|varid
operator|=
name|findvar
argument_list|(
name|name
argument_list|,
name|varlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|varid
operator|==
literal|0
condition|)
block|{
name|output_raw
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
block|{
name|output_raw
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|fmt
operator|=
name|varlist
index|[
name|varid
index|]
operator|.
name|fmt
operator|)
condition|)
block|{
case|case
name|TS
case|:
if|if
condition|(
operator|!
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|lfp
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|prettydate
argument_list|(
operator|&
name|lfp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FL
case|:
case|case
name|FU
case|:
case|case
name|FS
case|:
if|if
condition|(
operator|!
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|lfp
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|FL
case|:
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|lfp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FU
case|:
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|ulfptoms
argument_list|(
operator|&
name|lfp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FS
case|:
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|lfp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|UI
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|uinttoa
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN
case|:
if|if
condition|(
operator|!
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|ival
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|inttoa
argument_list|(
name|ival
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HA
case|:
case|case
name|NA
case|:
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
operator|==
name|HA
condition|)
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|nntohost
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|numtoa
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST
case|:
name|output_raw
operator|=
literal|'*'
expr_stmt|;
break|break;
case|case
name|RF
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|nntohost
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|value
argument_list|)
operator|<=
literal|4
condition|)
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|output_raw
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
name|LP
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
operator|||
name|uval
operator|>
literal|3
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
name|char
name|b
index|[
literal|3
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|uval
operator|&
literal|0x2
condition|)
name|b
index|[
literal|0
index|]
operator|=
literal|'1'
expr_stmt|;
if|if
condition|(
name|uval
operator|&
literal|0x1
condition|)
name|b
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OC
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
name|char
name|b
index|[
literal|10
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"%03o"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MD
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|uinttoa
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AR
case|:
if|if
condition|(
operator|!
name|decodearr
argument_list|(
name|value
argument_list|,
operator|&
name|narr
argument_list|,
name|lfparr
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|outputarr
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|narr
argument_list|,
name|lfparr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TST
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|tstflags
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error in cookedprint, %s=%s, fmt %d\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|output_raw
operator|!=
literal|0
condition|)
block|{
name|char
name|bn
index|[
literal|401
index|]
decl_stmt|;
name|char
name|bv
index|[
literal|401
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|atoascii
argument_list|(
literal|400
argument_list|,
name|name
argument_list|,
name|bn
argument_list|)
expr_stmt|;
name|atoascii
argument_list|(
literal|400
argument_list|,
name|value
argument_list|,
name|bv
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_raw
operator|!=
literal|'*'
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|bv
argument_list|)
expr_stmt|;
name|bv
index|[
name|len
index|]
operator|=
name|output_raw
expr_stmt|;
name|bv
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|output
argument_list|(
name|fp
argument_list|,
name|bn
argument_list|,
name|bv
argument_list|)
expr_stmt|;
block|}
block|}
name|endoutput
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*  * sortassoc - sort associations in the cache into ascending order  */
name|void
name|sortassoc
parameter_list|()
block|{
if|if
condition|(
name|numassoc
operator|>
literal|1
condition|)
if|#
directive|if
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|assoc_cache
argument_list|,
name|numassoc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|association
argument_list|)
argument_list|,
name|assoccmp
argument_list|)
expr_stmt|;
else|#
directive|else
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assoc_cache
argument_list|,
name|numassoc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|association
argument_list|)
argument_list|,
name|assoccmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sgi || bsdi */
block|}
comment|/*  * assoccmp - compare two associations  */
specifier|static
name|int
if|#
directive|if
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|assoccmp
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|const
name|void
modifier|*
name|t1
decl_stmt|;
specifier|const
name|void
modifier|*
name|t2
decl_stmt|;
block|{
specifier|const
name|struct
name|association
modifier|*
name|ass1
init|=
operator|(
specifier|const
expr|struct
name|association
operator|*
operator|)
name|t1
decl_stmt|;
specifier|const
name|struct
name|association
modifier|*
name|ass2
init|=
operator|(
specifier|const
expr|struct
name|association
operator|*
operator|)
name|t2
decl_stmt|;
else|#
directive|else
name|assoccmp
argument_list|(
argument|ass1
argument_list|,
argument|ass2
argument_list|)
name|struct
name|association
modifier|*
name|ass1
decl_stmt|;
name|struct
name|association
modifier|*
name|ass2
decl_stmt|;
block|{
endif|#
directive|endif
comment|/* sgi || bsdi */
if|if
condition|(
name|ass1
operator|->
name|assid
operator|<
name|ass2
operator|->
name|assid
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ass1
operator|->
name|assid
operator|>
name|ass2
operator|->
name|assid
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

