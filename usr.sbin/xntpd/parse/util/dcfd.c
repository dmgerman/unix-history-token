begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/parse/util/dcfd.c,v 3.18 1994/05/12 12:49:23 kardel Exp  *  * dcfd.c,v 3.18 1994/05/12 12:49:23 kardel Exp  *  * Ported to FreeBSD 2.0 1995/03/20 by Vincenzo Capuano  *  * DCF77 100/200ms pulse synchronisation daemon program (via 50Baud serial line)  *  * Features:  *  DCF77 decoding  *  NTP loopfilter logic for local clock  *  interactive display for debugging  *  * Lacks:  *  Leap second handling (at that level you should switch to xntp3 - really!)  *  * Copyright (c) 1993,1994  * Frank Kardel, Friedrich-Alexander Universitaet Erlangen-Nuernberg  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * This program may not be sold or used for profit without prior  * written consent of the author.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_comment
comment|/*  * NTP compilation environment  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_LINUX
end_ifdef

begin_include
include|#
directive|include
file|"ntp_timex.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * select which terminal handling to use (currently only SysV variants)  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_define
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcgetattr((_FD_), (_ARG_))
end_define

begin_define
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcsetattr((_FD_), TCSANOW, (_ARG_))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_define
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCGETA, (_ARG_))
end_define

begin_define
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCSETAW, (_ARG_))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TTY_GETATTR
end_ifndef

begin_expr_stmt
name|MUST
name|DEFINE
name|ONE
name|OF
literal|"HAVE_TERMIOS"
name|or
literal|"HAVE_TERMIO"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|dysize
define|#
directive|define
name|dysize
parameter_list|(
name|_x_
parameter_list|)
value|(((_x_) % 4) ? 365 : (((_x_) % 100) ? 366 : ((_x_) % 400 ? 365 : 366 )))
endif|#
directive|endif
define|#
directive|define
name|timernormalize
parameter_list|(
name|_a_
parameter_list|)
define|\
value|if ((_a_)->tv_usec>= 1000000) \ 			{ \ 				(_a_)->tv_sec  += (_a_)->tv_usec / 1000000; \ 				(_a_)->tv_usec  = (_a_)->tv_usec % 1000000; \ 			} \ 		if ((_a_)->tv_usec< 0) \ 			{ \ 				(_a_)->tv_sec  -= 1 + -(_a_)->tv_usec / 1000000; \ 				(_a_)->tv_usec = 1000000 - (-(_a_)->tv_usec % 1000000); \ 			}
define|#
directive|define
name|timeradd
parameter_list|(
name|_a_
parameter_list|,
name|_b_
parameter_list|)
define|\
value|(_a_)->tv_sec  += (_b_)->tv_sec; \ 		(_a_)->tv_usec += (_b_)->tv_usec; \ 		timernormalize((_a_))
define|#
directive|define
name|timersub
parameter_list|(
name|_a_
parameter_list|,
name|_b_
parameter_list|)
define|\
value|(_a_)->tv_sec  -= (_b_)->tv_sec; \ 		(_a_)->tv_usec -= (_b_)->tv_usec; \ 		timernormalize((_a_))
comment|/*  * debug macros  */
define|#
directive|define
name|PRINTF
value|if (interactive) printf
define|#
directive|define
name|LPRINTF
value|if (interactive&& loop_filter_debug) printf
ifdef|#
directive|ifdef
name|DEBUG
define|#
directive|define
name|dprintf
parameter_list|(
name|_x_
parameter_list|)
value|PRINTF _x_
else|#
directive|else
define|#
directive|define
name|dprintf
parameter_list|(
name|_x_
parameter_list|)
endif|#
directive|endif
specifier|extern
name|int
name|errno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * display received data (avoids also detaching from tty)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * display loopfilter (clock control) variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_filter_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * do not set/adjust system time  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * time that passes between start of DCF impulse and time stamping (fine  * adjustment) in microseconds (receiver/OS dependent)  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DELAY
value|230000
end_define

begin_comment
comment|/* rough estimate */
end_comment

begin_comment
comment|/*  * The two states we can be in - eithe we receive nothing  * usable or we have the correct time  */
end_comment

begin_define
define|#
directive|define
name|NO_SYNC
value|0x01
end_define

begin_define
define|#
directive|define
name|SYNC
value|0x02
end_define

begin_decl_stmt
specifier|static
name|int
name|sync_state
init|=
name|NO_SYNC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ticks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pat
index|[]
init|=
literal|"-\\|/"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINES
value|(24-2)
end_define

begin_comment
comment|/* error lines after which the two headlines are repeated */
end_comment

begin_define
define|#
directive|define
name|MAX_UNSYNC
value|(10*60)
end_define

begin_comment
comment|/* allow synchronisation loss for 10 minutes */
end_comment

begin_define
define|#
directive|define
name|NOTICE_INTERVAL
value|(20*60)
end_define

begin_comment
comment|/* mention missing synchronisation every 20 minutes */
end_comment

begin_comment
comment|/*  * clock adjustment PLL - see NTP protocol spec (RFC1305) for details  */
end_comment

begin_define
define|#
directive|define
name|USECSCALE
value|10
end_define

begin_define
define|#
directive|define
name|TIMECONSTANT
value|2
end_define

begin_define
define|#
directive|define
name|ADJINTERVAL
value|0
end_define

begin_define
define|#
directive|define
name|FREQ_WEIGHT
value|18
end_define

begin_define
define|#
directive|define
name|PHASE_WEIGHT
value|7
end_define

begin_define
define|#
directive|define
name|MAX_DRIFT
value|0x3FFFFFFF
end_define

begin_define
define|#
directive|define
name|R_SHIFT
parameter_list|(
name|_X_
parameter_list|,
name|_Y_
parameter_list|)
value|(((_X_)< 0) ? -(-(_X_)>> (_Y_)) : ((_X_)>> (_Y_)))
end_define

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|max_adj_offset
init|=
block|{
literal|0
block|,
literal|128000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|clock_adjust
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current adjustment value (usec * 2^USECSCALE) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|drift_comp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated drift value  (usec / ADJINTERVAL) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|adjustments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|skip_adjust
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard first adjustment (bad samples) */
end_comment

begin_comment
comment|/*  * DCF77 state flags  */
end_comment

begin_define
define|#
directive|define
name|DCFB_ANNOUNCE
value|0x0001
end_define

begin_comment
comment|/* switch time zone warning (DST switch) */
end_comment

begin_define
define|#
directive|define
name|DCFB_DST
value|0x0002
end_define

begin_comment
comment|/* DST in effect */
end_comment

begin_define
define|#
directive|define
name|DCFB_LEAP
value|0x0004
end_define

begin_comment
comment|/* LEAP warning (1 hour prior to occurence) */
end_comment

begin_define
define|#
directive|define
name|DCFB_ALTERNATE
value|0x0008
end_define

begin_comment
comment|/* alternate antenna used */
end_comment

begin_struct
struct|struct
name|clocktime
comment|/* clock time broken up from time code */
block|{
name|long
name|wday
decl_stmt|;
comment|/* Day of week: 1: Monday - 7: Sunday */
name|long
name|day
decl_stmt|;
name|long
name|month
decl_stmt|;
name|long
name|year
decl_stmt|;
name|long
name|hour
decl_stmt|;
name|long
name|minute
decl_stmt|;
name|long
name|second
decl_stmt|;
name|long
name|usecond
decl_stmt|;
name|long
name|utcoffset
decl_stmt|;
comment|/* in minutes */
name|long
name|flags
decl_stmt|;
comment|/* current clock status  (DCF77 state flags) */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|clocktime
name|clocktime_t
typedef|;
end_typedef

begin_comment
comment|/*  * (usually) quick constant multiplications  */
end_comment

begin_define
define|#
directive|define
name|TIMES10
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)<< 3) + ((_X_)<< 1))
end_define

begin_comment
comment|/* *8 + *2 */
end_comment

begin_define
define|#
directive|define
name|TIMES24
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)<< 4) + ((_X_)<< 3))
end_define

begin_comment
comment|/* *16 + *8 */
end_comment

begin_define
define|#
directive|define
name|TIMES60
parameter_list|(
name|_X_
parameter_list|)
value|((((_X_)<< 4)  - (_X_))<< 2)
end_define

begin_comment
comment|/* *(16 - 1) *4 */
end_comment

begin_comment
comment|/*  * generic abs() function  */
end_comment

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|_x_
parameter_list|)
value|(((_x_)< 0) ? -(_x_) : (_x_))
end_define

begin_comment
comment|/*  * conversion related return/error codes  */
end_comment

begin_define
define|#
directive|define
name|CVT_MASK
value|0x0000000F
end_define

begin_comment
comment|/* conversion exit code */
end_comment

begin_define
define|#
directive|define
name|CVT_NONE
value|0x00000001
end_define

begin_comment
comment|/* format not applicable */
end_comment

begin_define
define|#
directive|define
name|CVT_FAIL
value|0x00000002
end_define

begin_comment
comment|/* conversion failed - error code returned */
end_comment

begin_define
define|#
directive|define
name|CVT_OK
value|0x00000004
end_define

begin_comment
comment|/* conversion succeeded */
end_comment

begin_define
define|#
directive|define
name|CVT_BADFMT
value|0x00000010
end_define

begin_comment
comment|/* general format error - (unparsable) */
end_comment

begin_define
define|#
directive|define
name|CVT_BADDATE
value|0x00000020
end_define

begin_comment
comment|/* invalid date */
end_comment

begin_define
define|#
directive|define
name|CVT_BADTIME
value|0x00000040
end_define

begin_comment
comment|/* invalid time */
end_comment

begin_comment
comment|/*  * DCF77 raw time code  *  * From "Zur Zeit", Physikalisch-Technische Bundesanstalt (PTB), Braunschweig  * und Berlin, Maerz 1989  *  * Timecode transmission:  * AM:  *	time marks are send every second except for the second before the  *	next minute mark  *	time marks consist of a reduction of transmitter power to 25%  *	of the nominal level  *	the falling edge is the time indication (on time)  *	time marks of a 100ms duration constitute a logical 0  *	time marks of a 200ms duration constitute a logical 1  * FM:  *	see the spec. (basically a (non-)inverted psuedo random phase shift)  *  * Encoding:  * Second	Contents  * 0  - 10	AM: free, FM: 0  * 11 - 14	free  * 15		R     - alternate antenna  * 16		A1    - expect zone change (1 hour before)  * 17 - 18	Z1,Z2 - time zone  *		 0  0 illegal  *		 0  1 MEZ  (MET)  *		 1  0 MESZ (MED, MET DST)  *		 1  1 illegal  * 19		A2    - expect leap insertion/deletion (1 hour before)  * 20		S     - start of time code (1)  * 21 - 24	M1    - BCD (lsb first) Minutes  * 25 - 27	M10   - BCD (lsb first) 10 Minutes  * 28		P1    - Minute Parity (even)  * 29 - 32	H1    - BCD (lsb first) Hours  * 33 - 34      H10   - BCD (lsb first) 10 Hours  * 35		P2    - Hour Parity (even)  * 36 - 39	D1    - BCD (lsb first) Days  * 40 - 41	D10   - BCD (lsb first) 10 Days  * 42 - 44	DW    - BCD (lsb first) day of week (1: Monday -> 7: Sunday)  * 45 - 49	MO    - BCD (lsb first) Month  * 50           MO0   - 10 Months  * 51 - 53	Y1    - BCD (lsb first) Years  * 54 - 57	Y10   - BCD (lsb first) 10 Years  * 58 		P3    - Date Parity (even)  * 59		      - usually missing (minute indication), except for leap insertion  */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------  * conversion table to map DCF77 bit stream into data fields.  * Encoding:  *   Each field of the DCF77 code is described with two adjacent entries in  *   this table. The first entry specifies the offset into the DCF77 data stream  *   while the length is given as the difference between the start index and  *   the start index of the following field.  */
end_comment

begin_struct
specifier|static
struct|struct
name|rawdcfcode
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit */
block|}
name|rawdcfcode
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|25
block|}
block|,
block|{
literal|28
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|33
block|}
block|,
block|{
literal|35
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|40
block|}
block|,
block|{
literal|42
block|}
block|,
block|{
literal|45
block|}
block|,
block|{
literal|49
block|}
block|,
block|{
literal|50
block|}
block|,
block|{
literal|54
block|}
block|,
block|{
literal|58
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------------------------------------------------------------  * symbolic names for the fields of DCF77 describes in "rawdcfcode".  * see comment above for the structure of the DCF77 data  */
end_comment

begin_define
define|#
directive|define
name|DCF_M
value|0
end_define

begin_define
define|#
directive|define
name|DCF_R
value|1
end_define

begin_define
define|#
directive|define
name|DCF_A1
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z
value|3
end_define

begin_define
define|#
directive|define
name|DCF_A2
value|4
end_define

begin_define
define|#
directive|define
name|DCF_S
value|5
end_define

begin_define
define|#
directive|define
name|DCF_M1
value|6
end_define

begin_define
define|#
directive|define
name|DCF_M10
value|7
end_define

begin_define
define|#
directive|define
name|DCF_P1
value|8
end_define

begin_define
define|#
directive|define
name|DCF_H1
value|9
end_define

begin_define
define|#
directive|define
name|DCF_H10
value|10
end_define

begin_define
define|#
directive|define
name|DCF_P2
value|11
end_define

begin_define
define|#
directive|define
name|DCF_D1
value|12
end_define

begin_define
define|#
directive|define
name|DCF_D10
value|13
end_define

begin_define
define|#
directive|define
name|DCF_DW
value|14
end_define

begin_define
define|#
directive|define
name|DCF_MO
value|15
end_define

begin_define
define|#
directive|define
name|DCF_MO0
value|16
end_define

begin_define
define|#
directive|define
name|DCF_Y1
value|17
end_define

begin_define
define|#
directive|define
name|DCF_Y10
value|18
end_define

begin_define
define|#
directive|define
name|DCF_P3
value|19
end_define

begin_comment
comment|/*-----------------------------------------------------------------------  * parity field table (same encoding as rawdcfcode)  * This table describes the sections of the DCF77 code that are  * parity protected  */
end_comment

begin_struct
specifier|static
struct|struct
name|partab
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit of parity field */
block|}
name|partab
index|[]
init|=
block|{
block|{
literal|21
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------------------------------------------------------------  * offsets for parity field descriptions  */
end_comment

begin_define
define|#
directive|define
name|DCF_P_P1
value|0
end_define

begin_define
define|#
directive|define
name|DCF_P_P2
value|1
end_define

begin_define
define|#
directive|define
name|DCF_P_P3
value|2
end_define

begin_comment
comment|/*-----------------------------------------------------------------------  * legal values for time zone information  */
end_comment

begin_define
define|#
directive|define
name|DCF_Z_MET
value|0x2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MED
value|0x1
end_define

begin_comment
comment|/*-----------------------------------------------------------------------  * symbolic representation if the DCF77 data stream  */
end_comment

begin_struct
specifier|static
struct|struct
name|dcfparam
block|{
name|unsigned
name|char
name|onebits
index|[
literal|60
index|]
decl_stmt|;
name|unsigned
name|char
name|zerobits
index|[
literal|60
index|]
decl_stmt|;
block|}
name|dcfparam
init|=
block|{
literal|"###############RADMLS1248124P124812P1248121241248112481248P"
block|,
comment|/* 'ONE' representation */
literal|"--------------------s-------p------p----------------------p"
comment|/* 'ZERO' representation */
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------------------------------------------------------------  * extract a bitfield from DCF77 datastream  * All numeric field are LSB first.  * buf holds a pointer to a DCF77 data buffer in symbolic  *     representation  * idx holds the index to the field description in rawdcfcode  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ext_bf
parameter_list|(
name|buf
parameter_list|,
name|idx
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|rawdcfcode
index|[
name|idx
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rawdcfcode
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
init|;
name|i
operator|>=
name|first
condition|;
name|i
operator|--
control|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator||=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|dcfparam
operator|.
name|zerobits
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * check even parity integrity for a bitfield  *  * buf holds a pointer to a DCF77 data buffer in symbolic  *     representation  * idx holds the index to the field description in partab  */
end_comment

begin_function
specifier|static
name|unsigned
name|pcheck
parameter_list|(
name|buf
parameter_list|,
name|idx
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
specifier|register
name|unsigned
name|psum
init|=
literal|1
decl_stmt|;
name|last
operator|=
name|partab
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partab
index|[
name|idx
index|]
operator|.
name|offset
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|psum
operator|^=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|dcfparam
operator|.
name|zerobits
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
name|psum
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * convert a DCF77 data buffer into wall clock time + flags  *  * buffer holds a pointer to a DCF77 data buffer in symbolic  *        representation  * size   describes the length of DCF77 information in bits (represented  *        as chars in symbolic notation  * clock  points to a wall clock time description of the DCF77 data (result)  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|convert_rawdcf
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|clock
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|<
literal|57
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** INCOMPLETE"
argument_list|)
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
comment|/*    * check Start and Parity bits    */
if|if
condition|(
operator|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_S
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P1
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P2
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P3
argument_list|)
condition|)
block|{
comment|/*        * buffer OK - extract all fields and build wall clock time from them        */
name|clock
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|clock
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
name|clock
operator|->
name|second
operator|=
literal|0
expr_stmt|;
name|clock
operator|->
name|minute
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M10
argument_list|)
expr_stmt|;
name|clock
operator|->
name|minute
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|minute
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M1
argument_list|)
expr_stmt|;
name|clock
operator|->
name|hour
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H10
argument_list|)
expr_stmt|;
name|clock
operator|->
name|hour
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|hour
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H1
argument_list|)
expr_stmt|;
name|clock
operator|->
name|day
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D10
argument_list|)
expr_stmt|;
name|clock
operator|->
name|day
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|day
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D1
argument_list|)
expr_stmt|;
name|clock
operator|->
name|month
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO0
argument_list|)
expr_stmt|;
name|clock
operator|->
name|month
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|month
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO
argument_list|)
expr_stmt|;
name|clock
operator|->
name|year
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y10
argument_list|)
expr_stmt|;
name|clock
operator|->
name|year
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|year
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y1
argument_list|)
expr_stmt|;
name|clock
operator|->
name|wday
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_DW
argument_list|)
expr_stmt|;
comment|/*        * determine offset to UTC by examining the time zone        */
switch|switch
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Z
argument_list|)
condition|)
block|{
case|case
name|DCF_Z_MET
case|:
name|clock
operator|->
name|utcoffset
operator|=
operator|-
literal|60
expr_stmt|;
break|break;
case|case
name|DCF_Z_MED
case|:
name|clock
operator|->
name|flags
operator||=
name|DCFB_DST
expr_stmt|;
name|clock
operator|->
name|utcoffset
operator|=
operator|-
literal|120
expr_stmt|;
break|break;
default|default:
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** BAD TIME ZONE"
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
comment|/*        * extract various warnings from DCF77        */
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A1
argument_list|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|DCFB_ANNOUNCE
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A2
argument_list|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|DCFB_LEAP
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_R
argument_list|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|DCFB_ALTERNATE
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
else|else
block|{
comment|/*        * bad format - not for us        */
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** BAD FORMAT (invalid/parity)"
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * raw dcf input routine - fix up 50 baud  * characters for 1/0 decision  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|cvt_rawdcf
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|clock
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|e
init|=
name|buffer
operator|+
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfparam
operator|.
name|onebits
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfparam
operator|.
name|zerobits
decl_stmt|;
specifier|register
name|unsigned
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|lowmax
decl_stmt|,
name|highmax
decl_stmt|,
name|cutoff
decl_stmt|,
name|span
decl_stmt|;
define|#
directive|define
name|BITS
value|9
name|unsigned
name|char
name|histbuf
index|[
name|BITS
index|]
decl_stmt|;
comment|/*    * the input buffer contains characters with runs of consecutive    * bits set. These set bits are an indication of the DCF77 pulse    * length. We assume that we receive the pulse at 50 Baud. Thus    * a 100ms pulse would generate a 4 bit train (20ms per bit and    * start bit)    * a 200ms pulse would create all zeroes (and probably a frame error)    *    * The basic idea is that on corret reception we must have two    * maxima in the pulse length distribution histogram. (one for    * the zero representing pulses and one for the one representing    * pulses)    * There will always be ones in the datastream, thus we have to see    * two maxima.    * The best point to cut for a 1/0 decision is the minimum between those    * between the maxima. The following code tries to find this cutoff point.    */
comment|/*    * clear histogram buffer    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|histbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cutoff
operator|=
literal|0
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
comment|/*    * convert sequences of set bits into bits counts updating    * the histogram alongway    */
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
specifier|register
name|unsigned
name|int
name|ch
init|=
operator|*
name|s
operator|^
literal|0xFF
decl_stmt|;
comment|/*        * check integrity and update histogramm        */
if|if
condition|(
operator|!
operator|(
operator|(
name|ch
operator|+
literal|1
operator|)
operator|&
name|ch
operator|)
operator|||
operator|!
operator|*
name|s
condition|)
block|{
comment|/* 	   * character ok 	   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|i
expr_stmt|;
name|histbuf
index|[
name|i
index|]
operator|++
expr_stmt|;
name|cutoff
operator|+=
name|i
expr_stmt|;
name|lowmax
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * invalid character (no consecutive bit sequence) 	   */
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: character check for 0x%x@%d FAILED\n"
operator|,
operator|*
name|s
operator|,
name|s
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|~
literal|0
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADFMT
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
comment|/*    * first cutoff estimate (average bit count - must be between both    * maxima)    */
if|if
condition|(
name|lowmax
condition|)
block|{
name|cutoff
operator|/=
name|lowmax
expr_stmt|;
block|}
else|else
block|{
name|cutoff
operator|=
literal|4
expr_stmt|;
comment|/* doesn't really matter - it'll fail anyway, but gives error output */
block|}
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: average bit count: %d\n"
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
comment|/* weighted sum */
name|highmax
operator|=
literal|0
expr_stmt|;
comment|/* bitcount */
comment|/*    * collect weighted sum of lower bits (left of initial guess)    */
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: histogram:"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cutoff
condition|;
name|i
operator|++
control|)
block|{
name|lowmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"<M>"
operator|)
argument_list|)
expr_stmt|;
comment|/*    * round up    */
name|lowmax
operator|+=
name|highmax
operator|/
literal|2
expr_stmt|;
comment|/*    * calculate lower bit maximum (weighted sum / bit count)    *    * avoid divide by zero    */
if|if
condition|(
name|highmax
condition|)
block|{
name|lowmax
operator|/=
name|highmax
expr_stmt|;
block|}
else|else
block|{
name|lowmax
operator|=
literal|0
expr_stmt|;
block|}
name|highmax
operator|=
literal|0
expr_stmt|;
comment|/* weighted sum of upper bits counts */
name|cutoff
operator|=
literal|0
expr_stmt|;
comment|/* bitcount */
comment|/*    * collect weighted sum of lower bits (right of initial guess)    */
for|for
control|(
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|cutoff
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*    * determine upper maximum (weighted sum / bit count)    */
if|if
condition|(
name|cutoff
condition|)
block|{
name|highmax
operator|/=
name|cutoff
expr_stmt|;
block|}
else|else
block|{
name|highmax
operator|=
name|BITS
operator|-
literal|1
expr_stmt|;
block|}
comment|/*    * following now holds:    * lowmax<= cutoff(initial guess)<= highmax    * best cutoff is the minimum nearest to higher bits    */
comment|/*    * find the minimum between lowmax and highmax (detecting    * possibly a minimum span)    */
name|span
operator|=
name|cutoff
operator|=
name|lowmax
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowmax
init|;
name|i
operator|<=
name|highmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|>
name|histbuf
index|[
name|i
index|]
condition|)
block|{
comment|/* 	   * got a new minimum move beginning of minimum (cutoff) and 	   * end of minimum (span) there 	   */
name|cutoff
operator|=
name|span
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|==
name|histbuf
index|[
name|i
index|]
condition|)
block|{
comment|/* 	     * minimum not better yet - but it spans more than 	     * one bit value - follow it 	     */
name|span
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/*    * cutoff point for 1/0 decision is the middle of the minimum section    * in the histogram    */
name|cutoff
operator|=
operator|(
name|cutoff
operator|+
name|span
operator|)
operator|/
literal|2
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"parse: cvt_rawdcf: lower maximum %d, higher maximum %d, cutoff %d\n"
operator|,
name|lowmax
operator|,
name|highmax
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
comment|/*    * convert the bit counts to symbolic 1/0 information for data conversion    */
name|s
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|<
name|e
operator|)
operator|&&
operator|*
name|c
operator|&&
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
condition|)
block|{
comment|/* 	   * invalid character 	   */
operator|*
name|s
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * symbolic 1/0 representation 	   */
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|>=
name|cutoff
operator|)
condition|?
operator|*
name|b
else|:
operator|*
name|c
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
comment|/*    * if everything went well so far return the result of the symbolic    * conversion routine else just the accumulated errors    */
if|if
condition|(
name|rtc
operator|!=
name|CVT_NONE
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%-30s"
argument_list|,
literal|"*** BAD DATA"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rtc
operator|==
name|CVT_NONE
operator|)
condition|?
name|convert_rawdcf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
name|clock
argument_list|)
else|:
name|rtc
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * convert a wall clock time description of DCF77 to a Unix time (seconds  * since 1.1. 1970 UTC)  */
end_comment

begin_function
name|time_t
name|dcf_to_unixtime
parameter_list|(
name|clock
parameter_list|,
name|cvtrtc
parameter_list|)
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|cvtrtc
decl_stmt|;
block|{
define|#
directive|define
name|SETRTC
parameter_list|(
name|_X_
parameter_list|)
value|{ if (cvtrtc) *cvtrtc = (_X_); }
specifier|static
name|int
name|days_of_month
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|time_t
name|t
decl_stmt|;
comment|/*    * map 2 digit years to 19xx (DCF77 is a 20th century item)    */
if|if
condition|(
name|clock
operator|->
name|year
operator|<
literal|100
condition|)
name|clock
operator|->
name|year
operator|+=
literal|1900
expr_stmt|;
comment|/*    * assume that we convert timecode within the unix/UTC epoch -    * prolonges validity of 2 digit years    */
if|if
condition|(
name|clock
operator|->
name|year
operator|<
literal|1994
condition|)
name|clock
operator|->
name|year
operator|+=
literal|100
expr_stmt|;
comment|/* XXX this will do it till<2094 */
comment|/*    * must have been a really negative year code - drop it    */
if|if
condition|(
name|clock
operator|->
name|year
operator|<
literal|0
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*    * sorry, slow section here - but it's not time critical anyway    */
comment|/*    * calculate days since 1970 (watching leap years)    */
name|t
operator|=
operator|(
name|clock
operator|->
name|year
operator|-
literal|1970
operator|)
operator|*
literal|365
expr_stmt|;
name|t
operator|+=
operator|(
name|clock
operator|->
name|year
operator|>>
literal|2
operator|)
operator|-
operator|(
literal|1970
operator|>>
literal|2
operator|)
expr_stmt|;
name|t
operator|-=
name|clock
operator|->
name|year
operator|/
literal|100
operator|-
literal|1970
operator|/
literal|100
expr_stmt|;
name|t
operator|+=
name|clock
operator|->
name|year
operator|/
literal|400
operator|-
literal|1970
operator|/
literal|400
expr_stmt|;
comment|/* month */
if|if
condition|(
name|clock
operator|->
name|month
operator|<=
literal|0
operator|||
name|clock
operator|->
name|month
operator|>
literal|12
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad month */
block|}
comment|/* adjust current leap year */
if|if
condition|(
name|clock
operator|->
name|month
operator|>=
literal|3
operator|&&
name|dysize
argument_list|(
name|clock
operator|->
name|year
argument_list|)
operator|==
literal|366
condition|)
name|t
operator|++
expr_stmt|;
comment|/*    * collect days from months excluding the current one    */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|clock
operator|->
name|month
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|+=
name|days_of_month
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* day */
if|if
condition|(
name|clock
operator|->
name|day
operator|<
literal|1
operator|||
operator|(
operator|(
name|clock
operator|->
name|month
operator|==
literal|2
operator|&&
name|dysize
argument_list|(
name|clock
operator|->
name|year
argument_list|)
operator|==
literal|366
operator|)
condition|?
name|clock
operator|->
name|day
operator|>
literal|29
else|:
name|clock
operator|->
name|day
operator|>
name|days_of_month
index|[
name|clock
operator|->
name|month
index|]
operator|)
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad day */
block|}
comment|/*    * collect days from date excluding the current one    */
name|t
operator|+=
name|clock
operator|->
name|day
operator|-
literal|1
expr_stmt|;
comment|/* hour */
if|if
condition|(
name|clock
operator|->
name|hour
operator|<
literal|0
operator|||
name|clock
operator|->
name|hour
operator|>=
literal|24
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad hour */
block|}
comment|/*    * calculate hours from 1. 1. 1970    */
name|t
operator|=
name|TIMES24
argument_list|(
name|t
argument_list|)
operator|+
name|clock
operator|->
name|hour
expr_stmt|;
comment|/* min */
if|if
condition|(
name|clock
operator|->
name|minute
operator|<
literal|0
operator|||
name|clock
operator|->
name|minute
operator|>
literal|59
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad min */
block|}
comment|/*    * calculate minutes from 1. 1. 1970    */
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock
operator|->
name|minute
expr_stmt|;
comment|/* sec */
comment|/*    * calculate UTC in minutes    */
name|t
operator|+=
name|clock
operator|->
name|utcoffset
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|second
operator|<
literal|0
operator|||
name|clock
operator|->
name|second
operator|>
literal|60
condition|)
comment|/* allow for LEAPs */
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad sec */
block|}
comment|/*    * calculate UTC in seconds - phew !    */
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock
operator|->
name|second
expr_stmt|;
comment|/* done */
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * cheap half baked 1/0 decision - for interactive operation only  */
end_comment

begin_function
specifier|static
name|char
name|type
parameter_list|(
name|c
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
block|{
name|c
operator|^=
literal|0xFF
expr_stmt|;
return|return
operator|(
name|c
operator|>
literal|0xF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * week day representation  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wday
index|[
literal|8
index|]
init|=
block|{
literal|"??"
block|,
literal|"Mo"
block|,
literal|"Tu"
block|,
literal|"We"
block|,
literal|"Th"
block|,
literal|"Fr"
block|,
literal|"Sa"
block|,
literal|"Su"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-----------------------------------------------------------------------  * generate a string representation for a timeval  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pr_timeval
parameter_list|(
name|val
parameter_list|)
name|struct
name|timeval
modifier|*
name|val
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|tv_sec
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c0.%06ld"
argument_list|,
operator|(
name|val
operator|->
name|tv_usec
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
operator|(
name|long
name|int
operator|)
name|abs
argument_list|(
name|val
operator|->
name|tv_usec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld.%06ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|val
operator|->
name|tv_sec
argument_list|,
operator|(
name|long
name|int
operator|)
name|abs
argument_list|(
name|val
operator|->
name|tv_usec
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * correct the current time by an offset by setting the time rigorously  */
end_comment

begin_function
specifier|static
name|void
name|set_time
parameter_list|(
name|offset
parameter_list|)
name|struct
name|timeval
modifier|*
name|offset
decl_stmt|;
block|{
name|struct
name|timeval
name|the_time
decl_stmt|;
if|if
condition|(
name|no_set
condition|)
return|return;
name|LPRINTF
argument_list|(
literal|"set_time: %s "
argument_list|,
name|pr_timeval
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"setting time (offset %s)"
argument_list|,
name|pr_timeval
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|the_time
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"gettimeofday()"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeradd
argument_list|(
operator|&
name|the_time
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|settimeofday
argument_list|(
operator|&
name|the_time
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"settimeofday()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * slew the time by a given offset  */
end_comment

begin_function
specifier|static
name|void
name|adj_time
parameter_list|(
name|offset
parameter_list|)
specifier|register
name|long
name|offset
decl_stmt|;
block|{
name|struct
name|timeval
name|time_offset
decl_stmt|;
if|if
condition|(
name|no_set
condition|)
return|return;
name|time_offset
operator|.
name|tv_sec
operator|=
name|offset
operator|/
literal|1000000
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
name|offset
operator|%
literal|1000000
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"adj_time: %ld us "
argument_list|,
operator|(
name|long
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|time_offset
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"adjtime()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * read in a possibly previously written drift value  */
end_comment

begin_function
specifier|static
name|void
name|read_drift
parameter_list|(
name|drift_file
parameter_list|)
name|char
modifier|*
name|drift_file
decl_stmt|;
block|{
name|FILE
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|fopen
argument_list|(
name|drift_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
block|{
name|int
name|idrift
decl_stmt|,
name|fdrift
decl_stmt|;
name|fscanf
argument_list|(
name|df
argument_list|,
literal|"%4d.%03d"
argument_list|,
operator|&
name|idrift
argument_list|,
operator|&
name|fdrift
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"read_drift: %d.%03d ppm "
argument_list|,
name|idrift
argument_list|,
name|fdrift
argument_list|)
expr_stmt|;
name|drift_comp
operator|=
name|idrift
operator|<<
name|USECSCALE
expr_stmt|;
name|fdrift
operator|=
operator|(
name|fdrift
operator|<<
name|USECSCALE
operator|)
operator|/
literal|1000
expr_stmt|;
name|drift_comp
operator|+=
name|fdrift
operator|&
operator|(
literal|1
operator|<<
name|USECSCALE
operator|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"read_drift: drift_comp %ld "
argument_list|,
operator|(
name|long
name|int
operator|)
name|drift_comp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * write out the current drift value  */
end_comment

begin_function
specifier|static
name|void
name|update_drift
parameter_list|(
name|drift_file
parameter_list|,
name|offset
parameter_list|,
name|reftime
parameter_list|)
name|char
modifier|*
name|drift_file
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|time_t
name|reftime
decl_stmt|;
block|{
name|FILE
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|fopen
argument_list|(
name|drift_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
block|{
name|int
name|idrift
init|=
name|R_SHIFT
argument_list|(
name|drift_comp
argument_list|,
name|USECSCALE
argument_list|)
decl_stmt|;
name|int
name|fdrift
init|=
name|drift_comp
operator|&
operator|(
operator|(
literal|1
operator|<<
name|USECSCALE
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|LPRINTF
argument_list|(
literal|"update_drift: drift_comp %ld "
argument_list|,
operator|(
name|long
name|int
operator|)
name|drift_comp
argument_list|)
expr_stmt|;
name|fdrift
operator|=
operator|(
name|fdrift
operator|*
literal|1000
operator|)
operator|/
operator|(
literal|1
operator|<<
name|USECSCALE
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%4d.%03d %c%ld.%06ld %.24s\n"
argument_list|,
name|idrift
argument_list|,
name|fdrift
argument_list|,
operator|(
name|offset
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|abs
argument_list|(
name|offset
argument_list|)
operator|/
literal|1000000
argument_list|)
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|abs
argument_list|(
name|offset
argument_list|)
operator|%
literal|1000000
argument_list|)
argument_list|,
name|asctime
argument_list|(
name|localtime
argument_list|(
operator|&
name|reftime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"update_drift: %d.%03d ppm "
argument_list|,
name|idrift
argument_list|,
name|fdrift
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * process adjustments derived from the DCF77 observation  * (controls clock PLL)  */
end_comment

begin_function
specifier|static
name|void
name|adjust_clock
parameter_list|(
name|offset
parameter_list|,
name|drift_file
parameter_list|,
name|reftime
parameter_list|)
name|struct
name|timeval
modifier|*
name|offset
decl_stmt|;
name|char
modifier|*
name|drift_file
decl_stmt|;
name|time_t
name|reftime
decl_stmt|;
block|{
name|struct
name|timeval
name|toffset
decl_stmt|;
specifier|register
name|long
name|usecoffset
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|no_set
condition|)
return|return;
if|if
condition|(
name|skip_adjust
condition|)
block|{
name|skip_adjust
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|toffset
operator|=
operator|*
name|offset
expr_stmt|;
name|toffset
operator|.
name|tv_sec
operator|=
name|abs
argument_list|(
name|toffset
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|toffset
operator|.
name|tv_usec
operator|=
name|abs
argument_list|(
name|toffset
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|toffset
argument_list|,
operator|&
name|max_adj_offset
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/*        * hopeless - set the clock - and clear the timing        */
name|set_time
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|clock_adjust
operator|=
literal|0
expr_stmt|;
name|skip_adjust
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|usecoffset
operator|=
name|offset
operator|->
name|tv_sec
operator|*
literal|1000000
operator|+
name|offset
operator|->
name|tv_usec
expr_stmt|;
name|clock_adjust
operator|=
name|R_SHIFT
argument_list|(
name|usecoffset
argument_list|,
name|TIMECONSTANT
argument_list|)
expr_stmt|;
comment|/* adjustment to make for next period */
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|adjustments
operator|>
operator|(
literal|1
operator|<<
name|tmp
operator|)
condition|)
name|tmp
operator|++
expr_stmt|;
name|adjustments
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|FREQ_WEIGHT
condition|)
name|tmp
operator|=
name|FREQ_WEIGHT
expr_stmt|;
name|drift_comp
operator|+=
name|R_SHIFT
argument_list|(
name|usecoffset
operator|<<
name|USECSCALE
argument_list|,
name|TIMECONSTANT
operator|+
name|TIMECONSTANT
operator|+
name|FREQ_WEIGHT
operator|-
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|>
name|MAX_DRIFT
condition|)
comment|/* clamp into interval */
name|drift_comp
operator|=
name|MAX_DRIFT
expr_stmt|;
elseif|else
if|if
condition|(
name|drift_comp
operator|<
operator|-
name|MAX_DRIFT
condition|)
name|drift_comp
operator|=
operator|-
name|MAX_DRIFT
expr_stmt|;
name|update_drift
argument_list|(
name|drift_file
argument_list|,
name|usecoffset
argument_list|,
name|reftime
argument_list|)
expr_stmt|;
name|LPRINTF
argument_list|(
literal|"clock_adjust: %s, clock_adjust %ld, drift_comp %ld(%ld) "
argument_list|,
name|pr_timeval
argument_list|(
name|offset
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|R_SHIFT
argument_list|(
name|clock_adjust
argument_list|,
name|USECSCALE
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|R_SHIFT
argument_list|(
name|drift_comp
argument_list|,
name|USECSCALE
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|drift_comp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * adjust the clock by a small mount to simulate frequency correction  */
end_comment

begin_function
specifier|static
name|void
name|periodic_adjust
parameter_list|()
block|{
specifier|register
name|long
name|adjustment
decl_stmt|;
name|adjustments
operator|++
expr_stmt|;
name|adjustment
operator|=
name|R_SHIFT
argument_list|(
name|clock_adjust
argument_list|,
name|PHASE_WEIGHT
argument_list|)
expr_stmt|;
name|clock_adjust
operator|-=
name|adjustment
expr_stmt|;
name|adjustment
operator|+=
name|R_SHIFT
argument_list|(
name|drift_comp
argument_list|,
name|USECSCALE
operator|+
name|ADJINTERVAL
argument_list|)
expr_stmt|;
name|adj_time
argument_list|(
name|adjustment
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * control synchronisation status (warnings) and do periodic adjusts  * (frequency control simulation)  */
end_comment

begin_function
specifier|static
name|void
name|tick
parameter_list|()
block|{
specifier|static
name|unsigned
name|long
name|last_notice
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|SV_ONSTACK
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|periodic_adjust
argument_list|()
expr_stmt|;
name|ticks
operator|+=
literal|1
operator|<<
name|ADJINTERVAL
expr_stmt|;
if|if
condition|(
operator|(
name|ticks
operator|-
name|last_sync
operator|)
operator|>
name|MAX_UNSYNC
condition|)
block|{
comment|/*        * not getting time for a while        */
if|if
condition|(
name|sync_state
operator|==
name|SYNC
condition|)
block|{
comment|/* 	   * completely lost information 	   */
name|sync_state
operator|=
name|NO_SYNC
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DCF77 reception lost (timeout)"
argument_list|)
expr_stmt|;
name|last_notice
operator|=
name|ticks
expr_stmt|;
block|}
elseif|else
comment|/* 	 * in NO_SYNC state - look whether its time to speak up again 	 */
if|if
condition|(
operator|(
name|ticks
operator|-
name|last_notice
operator|)
operator|>
name|NOTICE_INTERVAL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"still not synchronized to DCF77 - check receiver/signal"
argument_list|)
expr_stmt|;
name|last_notice
operator|=
name|ticks
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|ITIMER_REAL
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
operator|<<
name|ADJINTERVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * break association from terminal to avoid catching terminal  * or process group related signals (-> daemon operation)  */
end_comment

begin_function
specifier|static
name|void
name|detach
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|3
condition|;
name|s
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NTP_POSIX_SOURCE
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_
argument_list|)
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* _POSIX_ */
ifndef|#
directive|ifndef
name|BSD
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* BSD */
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
endif|#
directive|endif
comment|/* _POSIX_ */
if|#
directive|if
name|defined
argument_list|(
name|hpux
argument_list|)
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hpux */
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * list possible arguments and options  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|program
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-f] [-l] [-t] [-i] [-o] [-d<drift_file>]<device>\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-n              do not change time\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-i              interactive\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-t              trace (print all datagrams)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-f              print all databits (includes PTB private data)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-l              print loop filter debug information\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-o              print offet average for current minute\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-d<drift_file> specify alternate drift file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-D<input delay>specify delay from input edge to processing in micro seconds\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------  * main loop - argument interpreter / setup / main loop  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|a
init|=
name|argv
decl_stmt|;
name|int
name|ac
init|=
name|argc
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|drift_file
init|=
literal|"/etc/dcfd.drift"
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|offset
init|=
literal|15
decl_stmt|;
name|int
name|offsets
init|=
literal|0
decl_stmt|;
name|int
name|delay
init|=
name|DEFAULT_DELAY
decl_stmt|;
comment|/* average delay from input edge to time stamping */
name|int
name|trace
init|=
literal|0
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
comment|/*    * process arguments    */
while|while
condition|(
operator|--
name|ac
condition|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
operator|++
name|a
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|arg
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|offset
operator|=
literal|0
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|loop_filter_debug
operator|=
literal|1
expr_stmt|;
name|offsets
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|no_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|offsets
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
name|delay
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|a
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -D requires integer argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
name|drift_file
operator|=
operator|*
operator|++
name|a
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -d requires file name argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option -%c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
name|arg
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: device specified twice\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errs
condition|)
block|{
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: device not specified\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|errs
operator|=
name|LINES
operator|+
literal|1
expr_stmt|;
comment|/*    * get access to DCF77 tty port    */
if|#
directive|if
name|defined
argument_list|(
name|SYS_FREEBSD
argument_list|)
operator|&&
name|defined
argument_list|(
name|BOEDER
argument_list|)
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|rrc
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
name|tt
decl_stmt|,
name|tlast
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|timeval
name|phase
decl_stmt|;
name|struct
name|timeval
name|time_offset
decl_stmt|;
name|char
name|pbuf
index|[
literal|61
index|]
decl_stmt|;
comment|/* printable version */
name|char
name|buf
index|[
literal|61
index|]
decl_stmt|;
comment|/* raw data */
name|clocktime_t
name|clock
decl_stmt|;
comment|/* wall clock time */
name|time_t
name|utc_time
init|=
literal|0
decl_stmt|;
name|time_t
name|last_utc_time
init|=
literal|0
decl_stmt|;
name|long
name|usecerror
init|=
literal|0
decl_stmt|;
name|long
name|lasterror
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|STREAM
argument_list|)
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
name|struct
name|termio
name|term
decl_stmt|;
endif|#
directive|endif
name|int
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
name|phase
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|phase
operator|.
name|tv_usec
operator|=
name|delay
expr_stmt|;
comment|/*        * setup TTY (50 Baud, Read, 8Bit, No Hangup, 1 character IO)        */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|fd
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|term
operator|.
name|c_cc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|term
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
name|term
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_FREEBSD
argument_list|)
name|term
operator|.
name|c_cflag
operator|=
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|PARENB
expr_stmt|;
name|term
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|term
operator|.
name|c_cflag
operator|=
name|B50
operator||
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|PARENB
expr_stmt|;
name|term
operator|.
name|c_iflag
operator|=
name|IGNPAR
expr_stmt|;
endif|#
directive|endif
name|term
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|term
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_FREEBSD
argument_list|)
if|if
condition|(
name|cfsetspeed
argument_list|(
operator|&
name|term
argument_list|,
name|B50
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"cfsetspeed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|fd
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*        * loose terminal if in daemon operation        */
if|if
condition|(
operator|!
name|interactive
condition|)
name|detach
argument_list|()
expr_stmt|;
comment|/*        * get syslog() initialized        */
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"dcfd"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"dcfd"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*        * setup periodic operations (state control / frequency control)        */
ifdef|#
directive|ifdef
name|SV_ONSTACK
block|{
name|struct
name|sigvec
name|vec
decl_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|tick
expr_stmt|;
name|vec
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
name|vec
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|vec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec(SIGALRM): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ITIMER_REAL
block|{
name|struct
name|itimerval
name|it
decl_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|1
operator|<<
name|ADJINTERVAL
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|1
operator|<<
name|ADJINTERVAL
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
operator|<<
name|ADJINTERVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_FREEBSD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONRAD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"F_SETFL"
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"TIOCMGET"
argument_list|)
expr_stmt|;
name|i
operator||=
name|TIOCM_DTR
expr_stmt|;
name|i
operator|&=
operator|~
name|TIOCM_RTS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMSET
argument_list|,
operator|&
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"TIOCMSET"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_FREEBSD
argument_list|)
operator|&&
name|defined
argument_list|(
name|BOEDER
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"F_SETFL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCCDTR
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"TIOCCDTR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRINTF
argument_list|(
literal|"  DCF77 monitor - Copyright 1993,1994, Frank Kardel\n\n"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Starting on %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|pbuf
index|[
literal|60
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|60
condition|;
name|i
operator|++
control|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|read_drift
argument_list|(
name|drift_file
argument_list|)
expr_stmt|;
comment|/*        * what time is it now (for interval measurement)        */
name|gettimeofday
argument_list|(
operator|&
name|tlast
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/*        * loop until input trouble ...        */
do|do
block|{
comment|/* 	   * get an impulse 	   */
while|while
condition|(
operator|(
name|rrc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|t
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|tt
operator|=
name|t
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tlast
argument_list|)
expr_stmt|;
if|if
condition|(
name|errs
operator|>
name|LINES
condition|)
block|{
name|PRINTF
argument_list|(
literal|"  %s"
argument_list|,
operator|&
literal|"PTB private....RADMLSMin....PHour..PMDay..DayMonthYear....P\n"
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"  %s"
argument_list|,
operator|&
literal|"---------------RADMLS1248124P124812P1248121241248112481248P\n"
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	       * timeout -> possible minute mark -> interpretation 	       */
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|timeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"%c %.*s "
argument_list|,
name|pat
index|[
name|i
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
operator|)
index|]
argument_list|,
literal|59
operator|-
name|offset
argument_list|,
operator|&
name|pbuf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtc
operator|=
name|cvt_rawdcf
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
operator|&
name|clock
argument_list|)
operator|)
operator|!=
name|CVT_OK
condition|)
block|{
comment|/* 		       * this data was bad - well - forget synchronisation for now 		       */
name|PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync_state
operator|==
name|SYNC
condition|)
block|{
name|sync_state
operator|=
name|NO_SYNC
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DCF77 reception lost (bad data)"
argument_list|)
expr_stmt|;
block|}
name|errs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trace
condition|)
block|{
name|PRINTF
argument_list|(
literal|"\r  %.*s "
argument_list|,
literal|59
operator|-
name|offset
argument_list|,
operator|&
name|buf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* 		   * collect first character 		   */
if|if
condition|(
operator|(
operator|(
name|c
operator|^
literal|0xFF
operator|)
operator|+
literal|1
operator|)
operator|&
operator|(
name|c
operator|^
literal|0xFF
operator|)
condition|)
name|pbuf
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
else|else
name|pbuf
index|[
literal|0
index|]
operator|=
name|type
argument_list|(
name|c
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|60
condition|;
name|i
operator|++
control|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		   * collect character 		   */
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* 		   * initial guess (usually correct) 		   */
if|if
condition|(
operator|(
operator|(
name|c
operator|^
literal|0xFF
operator|)
operator|+
literal|1
operator|)
operator|&
operator|(
name|c
operator|^
literal|0xFF
operator|)
condition|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|'?'
expr_stmt|;
else|else
name|pbuf
index|[
name|i
index|]
operator|=
name|type
argument_list|(
name|c
argument_list|)
condition|?
literal|'#'
else|:
literal|'-'
expr_stmt|;
name|PRINTF
argument_list|(
literal|"%c %.*s "
argument_list|,
name|pat
index|[
name|i
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
operator|)
index|]
argument_list|,
literal|59
operator|-
name|offset
argument_list|,
operator|&
name|pbuf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|rtc
operator|==
name|CVT_OK
condition|)
block|{
comment|/* 		   * we got a good time code here - try to convert it to 		   * UTC 		   */
if|if
condition|(
operator|(
name|utc_time
operator|=
name|dcf_to_unixtime
argument_list|(
operator|&
name|clock
argument_list|,
operator|&
name|rtc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PRINTF
argument_list|(
literal|"*** BAD CONVERSION\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utc_time
operator|!=
operator|(
name|last_utc_time
operator|+
literal|60
operator|)
condition|)
block|{
comment|/* 		       * well, two successive sucessful telegrams are not 60 seconds 		       * apart 		       */
name|PRINTF
argument_list|(
literal|"*** NO MINUTE INC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync_state
operator|==
name|SYNC
condition|)
block|{
name|sync_state
operator|=
name|NO_SYNC
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DCF77 reception lost (data mismatch)"
argument_list|)
expr_stmt|;
block|}
name|errs
operator|++
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADTIME
operator||
name|CVT_BADDATE
expr_stmt|;
block|}
else|else
name|usecerror
operator|=
literal|0
expr_stmt|;
name|last_utc_time
operator|=
name|utc_time
expr_stmt|;
block|}
if|if
condition|(
name|rtc
operator|==
name|CVT_OK
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		       * valid time code - determine offset and 		       * note regained reception 		       */
name|last_sync
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|sync_state
operator|==
name|NO_SYNC
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receiving DCF77"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			   * we had at least one minute SYNC - thus 			   * last error is valid 			   */
if|#
directive|if
name|defined
argument_list|(
name|BOEDER
argument_list|)
if|if
condition|(
name|abs
argument_list|(
name|utc_time
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
operator|>
literal|10
condition|)
block|{
name|time_offset
operator|.
name|tv_sec
operator|=
name|utc_time
operator|-
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|time_offset
operator|.
name|tv_sec
operator|=
name|lasterror
operator|/
literal|1000000
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
name|lasterror
operator|%
literal|1000000
expr_stmt|;
block|}
else|#
directive|else
name|time_offset
operator|.
name|tv_sec
operator|=
name|lasterror
operator|/
literal|1000000
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
name|lasterror
operator|%
literal|1000000
expr_stmt|;
endif|#
directive|endif
name|adjust_clock
argument_list|(
operator|&
name|time_offset
argument_list|,
name|drift_file
argument_list|,
name|utc_time
argument_list|)
expr_stmt|;
block|}
name|sync_state
operator|=
name|SYNC
expr_stmt|;
block|}
name|time_offset
operator|.
name|tv_sec
operator|=
name|utc_time
operator|+
name|i
expr_stmt|;
name|time_offset
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeradd
argument_list|(
operator|&
name|time_offset
argument_list|,
operator|&
name|phase
argument_list|)
expr_stmt|;
name|usecerror
operator|+=
operator|(
name|time_offset
operator|.
name|tv_sec
operator|-
name|tt
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|time_offset
operator|.
name|tv_usec
operator|-
name|tt
operator|.
name|tv_usec
expr_stmt|;
comment|/* 		   * output interpreted DCF77 data.  DCF77 gives us a YY year 		   * but dcf_to_unixtime() adds the century, so print YYYY. 		   */
name|PRINTF
argument_list|(
name|offsets
condition|?
literal|"%s, %2d:%02d:%02d, %d.%02d.%4d,<%s%s%s%s> (%c%d.%06ds)"
else|:
literal|"%s, %2d:%02d:%02d, %d.%02d.%02d,<%s%s%s%s>"
argument_list|,
name|wday
index|[
name|clock
operator|.
name|wday
index|]
argument_list|,
name|clock
operator|.
name|hour
argument_list|,
name|clock
operator|.
name|minute
argument_list|,
name|i
argument_list|,
name|clock
operator|.
name|day
argument_list|,
name|clock
operator|.
name|month
argument_list|,
name|clock
operator|.
name|year
argument_list|,
operator|(
name|clock
operator|.
name|flags
operator|&
name|DCFB_ALTERNATE
operator|)
condition|?
literal|"R"
else|:
literal|"_"
argument_list|,
operator|(
name|clock
operator|.
name|flags
operator|&
name|DCFB_ANNOUNCE
operator|)
condition|?
literal|"A"
else|:
literal|"_"
argument_list|,
operator|(
name|clock
operator|.
name|flags
operator|&
name|DCFB_DST
operator|)
condition|?
literal|"D"
else|:
literal|"_"
argument_list|,
operator|(
name|clock
operator|.
name|flags
operator|&
name|DCFB_LEAP
operator|)
condition|?
literal|"L"
else|:
literal|"_"
argument_list|,
operator|(
name|lasterror
operator|<
literal|0
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|abs
argument_list|(
name|lasterror
argument_list|)
operator|/
literal|1000000
argument_list|,
name|abs
argument_list|(
name|lasterror
argument_list|)
operator|%
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
block|{
name|PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
name|lasterror
operator|=
name|usecerror
operator|/
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lasterror
operator|=
literal|0
expr_stmt|;
comment|/* we cannot calculate phase errors on bad reception */
block|}
name|PRINTF
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|60
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
name|tlast
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|rrc
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
comment|/*        * lost IO - sorry guys        */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TERMINATING - cannot read from device %s (%m)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|closelog
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

