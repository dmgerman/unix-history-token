begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/parse/parsesolaris.c,v 3.9 1994/01/25 19:05:26 kardel Exp  *    * parsesolaris.c,v 3.9 1994/01/25 19:05:26 kardel Exp  *  * STREAMS module for reference clocks  * (SunOS5.x - not fully tested - buyer beware ! - OS KILLERS may still be  *  lurking in the code!)  *  * Copyright (c) 1993,1994  * derived work from parsestreams.c ((c) 1991-1993, Frank Kardel) and  * dcf77sync.c((c) Frank Kardel)  * Frank Kardel, Friedrich-Alexander Universitaet Erlangen-Nuernberg  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"parsesolaris.c,v 3.9 1994/01/25 19:05:26 kardel Exp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Well, the man spec says we have to do this junk - the  * header files tell a different story (i like that one more)  */
end_comment

begin_define
define|#
directive|define
name|SAFE_WR
parameter_list|(
name|q
parameter_list|)
value|(((q)->q_flag& QREADR) ? WR((q)) : (q))
end_define

begin_define
define|#
directive|define
name|SAFE_RD
parameter_list|(
name|q
parameter_list|)
value|(((q)->q_flag& QREADR) ? (q) : RD((q)))
end_define

begin_comment
comment|/*  * needed to cope with Solaris 2.3 header file chaos  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/*  * the Solaris 2.2 include list  */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/strtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_define
define|#
directive|define
name|STREAM
end_define

begin_comment
comment|/* that's what we are here for */
end_comment

begin_define
define|#
directive|define
name|HAVE_NO_NICE
end_define

begin_comment
comment|/* for the NTP headerfiles */
end_comment

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|parsebusy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- loadable driver section -----------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|streamtab
name|parseinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fmodsw
name|fmod_templ
init|=
block|{
literal|"parse"
block|,
comment|/* module name */
operator|&
name|parseinfo
block|,
comment|/* module information */
literal|0
block|,
comment|/* not clean yet */
comment|/* lock ptr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mod_ops
name|mod_strmodops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlstrmod
name|modlstrmod
init|=
block|{
operator|&
name|mod_strmodops
block|,
comment|/* a STREAMS module */
literal|"PARSE      - NTP reference"
block|,
comment|/* name this baby - keep room for revision number */
operator|&
name|fmod_templ
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlinkage
init|=
block|{
name|MODREV_1
block|,
operator|&
name|modlstrmod
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * strings support usually not in kernel  */
end_comment

begin_function
specifier|static
name|int
name|Strlen
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
block|{
name|c
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Strncpy
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|&&
name|t
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|Strcmp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * module management routines  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|revision
index|[]
init|=
literal|"3.9"
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|S
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/*    * copy RCS revision into Drv_name    *    * are we forcing RCS here to do things it was not built for ?    */
name|s
operator|=
name|revision
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
comment|/*        * skip "$Revision: "        * if present. - not necessary on a -kv co (cvs export)        */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|modlstrmod
operator|.
name|strmod_linkinfo
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
operator|*
name|t
operator|!=
literal|' '
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|' '
condition|)
name|t
operator|++
expr_stmt|;
name|S
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|S
operator|&&
operator|(
operator|(
operator|(
operator|*
name|S
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|S
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|*
name|S
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|S
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|t
operator|&&
operator|(
name|S
operator|>
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|Strlen
argument_list|(
name|t
argument_list|)
operator|>=
operator|(
name|S
operator|-
name|s
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|S
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mod_install
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
return|return
operator|(
name|mod_info
argument_list|(
operator|&
name|modlinkage
argument_list|,
name|modinfop
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|parsebusy
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"_fini[%s]: STREAMS module has still %d instances active.\n"
argument_list|,
name|modlstrmod
operator|.
name|strmod_linkinfo
argument_list|,
name|parsebusy
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
return|return
operator|(
name|mod_remove
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------- stream module definition ----------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|parseopen
argument_list|()
decl_stmt|,
name|parseclose
argument_list|()
decl_stmt|,
name|parsewput
argument_list|()
decl_stmt|,
name|parserput
argument_list|()
decl_stmt|,
name|parsersvc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|module_info
name|driverinfo
init|=
block|{
literal|0
block|,
comment|/* module ID number */
name|fmod_templ
operator|.
name|f_name
block|,
comment|/* module name - why repeated here ? compat ?*/
literal|0
block|,
comment|/* minimum accepted packet size */
name|INFPSZ
block|,
comment|/* maximum accepted packet size */
literal|1
block|,
comment|/* high water mark - flow control */
literal|0
comment|/* low water mark - flow control */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|rinit
init|=
comment|/* read queue definition */
block|{
name|parserput
block|,
comment|/* put procedure */
name|parsersvc
block|,
comment|/* service procedure */
name|parseopen
block|,
comment|/* open procedure */
name|parseclose
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|winit
init|=
comment|/* write queue definition */
block|{
name|parsewput
block|,
comment|/* put procedure */
name|NULL
block|,
comment|/* service procedure */
name|NULL
block|,
comment|/* open procedure */
name|NULL
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|streamtab
name|parseinfo
init|=
comment|/* stream info element for parse driver */
block|{
operator|&
name|rinit
block|,
comment|/* read queue */
operator|&
name|winit
block|,
comment|/* write queue */
name|NULL
block|,
comment|/* read mux */
name|NULL
comment|/* write mux */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- driver data structures ----------------------------*/
end_comment

begin_comment
comment|/*  * we usually have an inverted signal - but you  * can change this to suit your needs  */
end_comment

begin_decl_stmt
name|int
name|cd_invert
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invert status of CD line - PPS support via CD input */
end_comment

begin_decl_stmt
name|int
name|parsedebug
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|uniqtime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*--------------- module implementation -----------------------------*/
end_comment

begin_define
define|#
directive|define
name|TIMEVAL_USADD
parameter_list|(
name|_X_
parameter_list|,
name|_US_
parameter_list|)
value|do {\ 				    (_X_)->tv_usec += (_US_);\ 			            if ((_X_)->tv_usec>= 1000000)\ 				      {\ 					 (_X_)->tv_sec++;\ 					 (_X_)->tv_usec -= 1000000;\ 				      }\ 				 } while (0)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun4c
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG_CD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sun4c/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sun4c/auxio.h>
end_include

begin_define
define|#
directive|define
name|SET_LED
parameter_list|(
name|_X_
parameter_list|)
value|(((cpu& CPU_ARCH) == SUN4C_ARCH) ? *(u_char *)AUXIO_REG = AUX_MBO|AUX_EJECT|((_X_)?AUX_LED:0) : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_LED
parameter_list|(
name|_X_
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|init_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * keep here MACHINE AND OS AND ENVIRONMENT DEPENDENT  * timing constants  *  * FOR ABSOLUTE PRECISION YOU NEED TO MEASURE THE TIMING  * SKEW BETWEEN THE HW-PPS SIGNAL AND KERNEL uniqtime()  * YOURSELF.  *  * YOU MUST BE QUALIFIED APPROPRIATELY FOR THESE TYPE  * OF HW MANIPULATION !  *  * you need an oscilloscope and the permission for HW work  * in order to figure out these timing constants/variables  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xsdelay
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume an SS2 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|stdelay
init|=
literal|350
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|delays
block|{
name|unsigned
name|char
name|mask
decl_stmt|;
comment|/* what to check for */
name|unsigned
name|char
name|type
decl_stmt|;
comment|/* what to match */
name|unsigned
name|long
name|xsdelay
decl_stmt|;
comment|/* external status direct delay in us */
name|unsigned
name|long
name|stdelay
decl_stmt|;
comment|/* STREAMS message delay (M_[UN]HANGUP) */
block|}
name|isr_delays
index|[]
init|=
block|{
comment|/*    * WARNING: must still be measured - currently taken from Craig Leres ppsdev    */
ifdef|#
directive|ifdef
name|sun4c
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4C_50
block|,
literal|10
block|,
literal|350
block|}
block|,
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4C_65
block|,
literal|15
block|,
literal|700
block|}
block|,
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4C_75
block|,
literal|10
block|,
literal|350
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun4m
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4M_50
block|,
literal|8
block|,
literal|250
block|}
block|,
block|{
name|CPU_ARCH
operator||
name|CPU_MACH
block|,
name|CPU_SUN4M_690
block|,
literal|8
block|,
literal|250
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,}
block|}
struct|;
end_struct

begin_function
name|void
name|setup_delays
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cputype
operator|&
name|OBP_ARCH
condition|)
block|{
name|printf
argument_list|(
literal|"parse: WARNING: PPS kernel fudge factors no yet determinable (no dev tree walk yet) - assuming SS2 (Sun4/75)\n"
argument_list|,
name|cputype
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|isr_delays
index|[
name|i
index|]
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cputype
operator|&
name|isr_delays
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|==
name|isr_delays
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
name|xsdelay
operator|=
name|isr_delays
index|[
name|i
index|]
operator|.
name|xsdelay
expr_stmt|;
name|stdelay
operator|=
name|isr_delays
index|[
name|i
index|]
operator|.
name|stdelay
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"parse: WARNING: PPS kernel fudge factors unknown for this machine (Type 0x%x) - assuming SS2 (Sun4/75)\n"
argument_list|,
name|cputype
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|M_PARSE
value|0x0001
end_define

begin_define
define|#
directive|define
name|M_NOPARSE
value|0x0002
end_define

begin_function
specifier|static
name|int
name|setup_stream
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|register
name|mblk_t
modifier|*
name|mp
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: SETUP_STREAM - setting up stream for q=%x\n"
operator|,
name|q
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|struct
name|stroptions
modifier|*
name|str
init|=
operator|(
expr|struct
name|stroptions
operator|*
operator|)
name|mp
operator|->
name|b_wptr
decl_stmt|;
name|str
operator|->
name|so_flags
operator|=
name|SO_READOPT
operator||
name|SO_HIWAT
operator||
name|SO_LOWAT
expr_stmt|;
name|str
operator|->
name|so_readopt
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|RMSGD
else|:
name|RNORM
expr_stmt|;
name|str
operator|->
name|so_hiwat
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
else|:
literal|256
expr_stmt|;
name|str
operator|->
name|so_lowat
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_SETOPTS
expr_stmt|;
name|mp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
name|panic
argument_list|(
literal|"NULL q - strange"
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|putctl1
argument_list|(
name|SAFE_WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_next
argument_list|,
name|M_CTL
argument_list|,
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|MC_SERVICEIMM
else|:
name|MC_SERVICEDEF
argument_list|)
return|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: setup_stream - FAILED - no MEMORY for allocb\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseopen
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|dev_t
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|sflag
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
specifier|register
name|mblk_t
modifier|*
name|mp
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parse
decl_stmt|;
specifier|static
name|int
name|notice
init|=
literal|0
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - q=%x\n"
operator|,
name|q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|!=
name|MODOPEN
condition|)
block|{
comment|/* open only for modules */
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - not MODOPEN\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|q
operator|->
name|q_ptr
operator|!=
operator|(
name|caddr_t
operator|)
name|NULL
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - FAILED - EXCLUSIVE ONLY\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|parsebusy
operator|++
expr_stmt|;
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - parse area q=%x, q->q_ptr=%x\n"
operator|,
name|q
operator|,
name|q
operator|->
name|q_ptr
operator|)
argument_list|)
expr_stmt|;
name|SAFE_WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
name|q
operator|->
name|q_ptr
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - WQ parse area q=%x, q->q_ptr=%x\n"
operator|,
name|SAFE_WR
argument_list|(
name|q
argument_list|)
operator|,
name|SAFE_WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|)
argument_list|)
expr_stmt|;
name|parse
operator|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parse
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_queue
operator|=
name|q
expr_stmt|;
name|parse
operator|->
name|parse_status
operator|=
name|PARSE_ENABLE
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - initializing io subsystem q=%x\n"
operator|,
name|q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_ioinit
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
condition|)
block|{
comment|/*        * ok guys - beat it        */
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
name|parsebusy
operator|--
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - initializing stream q=%x\n"
operator|,
name|q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup_stream
argument_list|(
name|q
argument_list|,
name|M_PARSE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|init_linemon
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* hook up PPS ISR routines if possible */
name|setup_delays
argument_list|()
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_OPEN
argument_list|,
operator|(
literal|"parse: OPEN - SUCCEEDED\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*        * I know that you know the delete key, but you didn't write this        * code, did you ? - So, keep the message in here.        */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Copyright (c) 1991-1993, Frank Kardel\n"
argument_list|,
name|modlstrmod
operator|.
name|strmod_linkinfo
argument_list|)
expr_stmt|;
name|notice
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
name|parsebusy
operator|--
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseclose
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|unsigned
name|long
name|s
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_CLOSE
argument_list|,
operator|(
literal|"parse: CLOSE\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_dqueue
condition|)
name|close_linemon
argument_list|(
name|parse
operator|->
name|parse_dqueue
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_dqueue
operator|=
operator|(
name|queue_t
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parse_ioend
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|SAFE_WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|parsebusy
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move unrecognized stuff upward  */
end_comment

begin_expr_stmt
specifier|static
name|parsersvc
argument_list|(
argument|queue_t *q
argument_list|)
block|{
name|mblk_t
operator|*
name|mp
block|;
while|while
condition|(
name|mp
operator|=
name|getq
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RSVC
argument_list|,
operator|(
literal|"parse: RSVC - putnext\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|putbq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RSVC
argument_list|,
operator|(
literal|"parse: RSVC - flow control wait\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
end_else

begin_comment
unit|} }
comment|/*  * do ioctls and  * send stuff down - dont care about  * flow control  */
end_comment

begin_function
specifier|static
name|int
name|parsewput
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|mblk_t
modifier|*
name|mp
parameter_list|)
block|{
specifier|register
name|int
name|ok
init|=
literal|1
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|datap
decl_stmt|;
specifier|register
name|struct
name|iocblk
modifier|*
name|iocp
decl_stmt|;
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_IOCTL
case|:
name|iocp
operator|=
operator|(
expr|struct
name|iocblk
operator|*
operator|)
name|mp
operator|->
name|b_rptr
expr_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
default|default:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - forward M_IOCTL\n"
operator|)
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIOGETEV
case|:
comment|/* 	   * taken from Craig Leres ppsclock module (and modified) 	   */
name|datap
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|datap
operator|==
name|NULL
operator|||
name|mp
operator|->
name|b_cont
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
name|iocp
operator|->
name|ioc_error
operator|=
operator|(
name|datap
operator|==
name|NULL
operator|)
condition|?
name|ENOMEM
else|:
name|EINVAL
expr_stmt|;
if|if
condition|(
name|datap
operator|!=
name|NULL
condition|)
name|freeb
argument_list|(
name|datap
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_cont
operator|=
name|datap
expr_stmt|;
operator|*
operator|(
expr|struct
name|ppsclockev
operator|*
operator|)
name|datap
operator|->
name|b_wptr
operator|=
name|parse
operator|->
name|parse_ppsclockev
expr_stmt|;
name|datap
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|datap
operator|->
name|b_wptr
argument_list|)
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
name|iocp
operator|->
name|ioc_count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_ENABLE
case|:
case|case
name|PARSEIOC_DISABLE
case|:
block|{
name|parse
operator|->
name|parse_status
operator|=
operator|(
name|parse
operator|->
name|parse_status
operator|&
operator|~
name|PARSE_ENABLE
operator|)
operator||
operator|(
name|iocp
operator|->
name|ioc_cmd
operator|==
name|PARSEIOC_ENABLE
operator|)
condition|?
name|PARSE_ENABLE
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|setup_stream
argument_list|(
name|SAFE_RD
argument_list|(
name|q
argument_list|)
argument_list|,
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|?
name|M_PARSE
else|:
name|M_NOPARSE
argument_list|)
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
block|}
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PARSEIOC_SETSTAT
case|:
case|case
name|PARSEIOC_GETSTAT
case|:
case|case
name|PARSEIOC_TIMECODE
case|:
case|case
name|PARSEIOC_SETFMT
case|:
case|case
name|PARSEIOC_GETFMT
case|:
case|case
name|PARSEIOC_SETCS
case|:
if|if
condition|(
name|iocp
operator|->
name|ioc_count
operator|==
sizeof|sizeof
argument_list|(
name|parsectl_t
argument_list|)
condition|)
block|{
name|parsectl_t
modifier|*
name|dct
init|=
operator|(
name|parsectl_t
operator|*
operator|)
name|mp
operator|->
name|b_cont
operator|->
name|b_rptr
decl_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
case|case
name|PARSEIOC_GETSTAT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_GETSTAT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_getstat
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETSTAT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETSTAT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setstat
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_TIMECODE
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_TIMECODE\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_timecode
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETFMT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETFMT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_GETFMT
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_GETFMT\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_getfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETCS
case|:
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput - PARSEIOC_SETCS\n"
operator|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setcs
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|ok
condition|?
name|M_IOCACK
else|:
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_WPUT
argument_list|,
operator|(
literal|"parse: parsewput qreply - %s\n"
operator|,
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|==
name|M_IOCNAK
operator|)
condition|?
literal|"M_IOCNAK"
else|:
literal|"M_IOCACK"
operator|)
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * read characters from streams buffers  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rdchar
parameter_list|(
name|mblk_t
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_wptr
operator|-
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
condition|)
block|{
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
operator|++
operator|)
argument_list|)
return|;
block|}
else|else
block|{
specifier|register
name|mblk_t
modifier|*
name|mmp
init|=
operator|*
name|mp
decl_stmt|;
operator|*
name|mp
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_cont
expr_stmt|;
name|freeb
argument_list|(
name|mmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|~
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * convert incoming data  */
end_comment

begin_function
specifier|static
name|int
name|parserput
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|mblk_t
modifier|*
name|imp
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|type
decl_stmt|;
name|mblk_t
modifier|*
name|mp
init|=
name|imp
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
comment|/*        * anything we don't know will be put on queue        * the service routine will move it to the next one        */
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - forward type 0x%x\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BREAK
case|:
case|case
name|M_DATA
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ch
decl_stmt|;
name|timestamp_t
name|ctime
decl_stmt|;
comment|/* 	 * get time on packet delivery 	 */
name|uniqtime
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - parser disabled - forward type 0x%x\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|parseprintf(DD_RPUT,("parse: parserput - M_%s\n", (type == M_DATA) ? "DATA" : "BREAK"));
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|M_DATA
condition|)
block|{
comment|/* 		 * parse packet looking for start an end characters 		 */
while|while
condition|(
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|ch
operator|=
name|rdchar
argument_list|(
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
operator|~
literal|0
operator|&&
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|char
operator|)
name|ch
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
comment|/* 			 * up up and away (hopefully ...) 			 * don't press it if resources are tight or nobody wants it 			 */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
comment|/* 		     * up up and away (hopefully ...) 		     * don't press it if resources are tight or nobody wants it 		     */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/*        * CD PPS support for non direct ISR hack        */
case|case
name|M_HANGUP
case|:
case|case
name|M_UNHANGUP
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|timestamp_t
name|ctime
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|int
name|status
init|=
name|cd_invert
operator|^
operator|(
name|type
operator|==
name|M_HANGUP
operator|)
decl_stmt|;
name|SET_LED
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|uniqtime
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_USADD
argument_list|(
operator|&
name|ctime
operator|.
name|tv
argument_list|,
name|stdelay
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RPUT
argument_list|,
operator|(
literal|"parse: parserput - M_%sHANGUP\n"
operator|,
operator|(
name|type
operator|==
name|M_HANGUP
operator|)
condition|?
literal|""
else|:
literal|"UN"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|,
operator|&
name|ctime
argument_list|)
condition|)
block|{
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canput
argument_list|(
name|parse
operator|->
name|parse_queue
operator|->
name|q_next
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canput
argument_list|(
name|q
operator|->
name|q_next
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|ctime
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|init_zs_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* handle line monitor for "zs" driver */
end_comment

begin_function_decl
specifier|static
name|void
name|close_zs_linemon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zs_xsisr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* zs external status interupt handler */
end_comment

begin_comment
comment|/*-------------------- CD isr status monitor ---------------*/
end_comment

begin_function
specifier|static
name|int
name|init_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|)
block|{
specifier|register
name|queue_t
modifier|*
name|dq
decl_stmt|;
name|dq
operator|=
name|SAFE_WR
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/*    * we ARE doing very bad things down here (basically stealing ISR    * hooks)    *    * so we chase down the STREAMS stack searching for the driver    * and if this is a known driver we insert our ISR routine for    * status changes in to the ExternalStatus handling hook    */
while|while
condition|(
name|dq
operator|->
name|q_next
condition|)
block|{
name|dq
operator|=
name|dq
operator|->
name|q_next
expr_stmt|;
comment|/* skip down to driver */
block|}
comment|/*    * find appropriate driver dependent routine    */
if|if
condition|(
name|dq
operator|->
name|q_qinfo
operator|&&
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: driver is \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
return|return
name|init_zs_linemon
argument_list|(
name|dq
argument_list|,
name|q
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: driver \"%s\" not suitable for CD monitoring\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_linemon: cannot find driver\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
comment|/*    * find appropriate driver dependent routine    */
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
name|close_zs_linemon
argument_list|(
name|q
argument_list|,
name|my_q
argument_list|)
expr_stmt|;
return|return;
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_linemon: cannot find driver close routine for \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_linemon: cannot find driver name\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/zsdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/ser_async.h>
end_include

begin_include
include|#
directive|include
file|<sys/ser_zscc.h>
end_include

begin_comment
comment|/*  * there should be some docs telling how to get to  * sz:zs_usec_delay and zs:initzsops()  */
end_comment

begin_define
define|#
directive|define
name|zs_usec_delay
value|5
end_define

begin_struct
struct|struct
name|savedzsops
block|{
name|struct
name|zsops
name|zsops
decl_stmt|;
name|struct
name|zsops
modifier|*
name|oldzsops
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|zsops
modifier|*
name|emergencyzs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_zs_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
comment|/*    * we expect the zsaline pointer in the q_data pointer    * from there on we insert our on EXTERNAL/STATUS ISR routine    * into the interrupt path, before the standard handler    */
name|zs
operator|=
operator|(
operator|(
expr|struct
name|asyncline
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/*        * well - not found on startup - just say no (shouldn't happen though)        */
return|return
literal|0
return|;
block|}
else|else
block|{
name|unsigned
name|long
name|s
decl_stmt|;
comment|/*        * we do a direct replacement, in case others fiddle also        * if somebody else grabs our hook and we disconnect        * we are in DEEP trouble - panic is likely to be next, sorry        */
name|szs
operator|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|parsestream
operator|->
name|parse_data
operator|=
operator|(
name|void
operator|*
operator|)
name|szs
expr_stmt|;
name|mutex_enter
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|parsestream
operator|->
name|parse_dqueue
operator|=
name|q
expr_stmt|;
comment|/* remember driver */
name|szs
operator|->
name|zsops
operator|=
operator|*
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|szs
operator|->
name|zsops
operator|.
name|zsop_xsint
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|zs_xsisr
expr_stmt|;
comment|/* place our bastard */
name|szs
operator|->
name|oldzsops
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|emergencyzs
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|zs
operator|->
name|zs_ops
operator|=
operator|&
name|szs
operator|->
name|zsops
expr_stmt|;
comment|/* hook it up */
comment|/*        * XXX: this is usually done via zsopinit()         * - have yet to find a way to call that routine        */
name|zs
operator|->
name|zs_xsint
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|zs_xsisr
expr_stmt|;
name|mutex_exit
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"init_zs_linemon: CD monitor installed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * unregister our ISR routine - must call under splhigh()  */
end_comment

begin_function
specifier|static
name|void
name|close_zs_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
name|zs
operator|=
operator|(
operator|(
expr|struct
name|asyncline
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/*        * well - not found on startup - just say no (shouldn't happen though)        */
return|return;
block|}
else|else
block|{
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
init|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|parsestream
operator|->
name|parse_data
decl_stmt|;
name|mutex_enter
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_ops
operator|=
name|szs
operator|->
name|oldzsops
expr_stmt|;
comment|/* reset to previous handler functions */
comment|/*        * XXX: revert xsint (usually done via zsopinit() - have still to find        * a way to call that bugger        */
name|zs
operator|->
name|zs_xsint
operator|=
name|zs
operator|->
name|zs_ops
operator|->
name|zsop_xsint
expr_stmt|;
name|mutex_exit
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|szs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_INSTALL
argument_list|,
operator|(
literal|"close_zs_linemon: CD monitor deleted\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ZSRR0_IGNORE
value|(ZSRR0_CD|ZSRR0_SYNC|ZSRR0_CTS)
end_define

begin_define
define|#
directive|define
name|MAXDEPTH
value|50
end_define

begin_comment
comment|/* maximum allowed stream crawl */
end_comment

begin_comment
comment|/*  * take external status interrupt (only CD interests us)  */
end_comment

begin_function
specifier|static
name|void
name|zs_xsisr
parameter_list|(
name|struct
name|zscom
modifier|*
name|zs
parameter_list|)
block|{
specifier|register
name|struct
name|asyncline
modifier|*
name|za
init|=
operator|(
expr|struct
name|asyncline
operator|*
operator|)
name|zs
operator|->
name|zs_priv
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|char
name|zsstatus
decl_stmt|;
specifier|register
name|int
name|loopcheck
decl_stmt|;
specifier|register
name|unsigned
name|char
name|cdstate
decl_stmt|;
specifier|register
name|char
modifier|*
name|dname
decl_stmt|;
comment|/*    * pick up current state    */
name|zsstatus
operator|=
name|SCC_READ0
argument_list|()
expr_stmt|;
if|if
condition|(
name|za
operator|->
name|za_rr0
operator|^
operator|(
name|cdstate
operator|=
name|zsstatus
operator|&
name|ZSRR0_CD
operator|)
condition|)
block|{
name|timestamp_t
name|cdevent
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
comment|/*        * CONDITIONAL external measurement support        */
name|SET_LED
argument_list|(
name|cdstate
argument_list|)
expr_stmt|;
comment|/* 				 * inconsistent with upper SET_LED, but this 				 * is for oscilloscope business anyway and we 				 * are just interested in edge delays in the 				 * lower us range 				 */
comment|/*        * time stamp        */
name|uniqtime
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_USADD
argument_list|(
operator|&
name|cdevent
operator|.
name|tv
argument_list|,
name|xsdelay
argument_list|)
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
comment|/*        * logical state        */
name|status
operator|=
name|cd_invert
condition|?
name|cdstate
operator|==
literal|0
else|:
name|cdstate
operator|!=
literal|0
expr_stmt|;
comment|/*        * ok - now the hard part - find ourself        */
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
comment|/* 		   * back home - phew (hopping along stream queues might 		   * prove dangerous to your health) 		   */
if|if
condition|(
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|,
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|,
operator|&
name|cdevent
argument_list|)
condition|)
block|{
comment|/* 		       * XXX - currently we do not pass up the message, as 		       * we should. 		       * for a correct behaviour wee need to block out 		       * processing until parse_iodone has been posted via 		       * a softcall-ed routine which does the message pass-up 		       * right now PPS information relies on input being 		       * received 		       */
name|parse_iodone
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|cdevent
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: CD event %s has been posted for \"%s\"\n"
operator|,
name|status
condition|?
literal|"ONE"
else|:
literal|"ZERO"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*        * only pretend that CD and ignored transistion (SYNC,CTS)        * have been handled        */
name|za
operator|->
name|za_rr0
operator|=
operator|(
name|za
operator|->
name|za_rr0
operator|&
operator|~
name|ZSRR0_IGNORE
operator|)
operator||
operator|(
name|zsstatus
operator|&
name|ZSRR0_IGNORE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|~
name|ZSRR0_IGNORE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	   * all done - kill status indication and return 	   */
name|SCC_WRITE0
argument_list|(
name|ZSWR0_RESET_STATUS
argument_list|)
expr_stmt|;
comment|/* might kill other conditions here */
return|return;
block|}
block|}
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: non CD event 0x%x for \"%s\"\n"
operator|,
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|~
name|ZSRR0_CD
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
comment|/*    * we are now gathered here to process some unusual external status    * interrupts.    * any CD events have also been handled and shouldn't be processed    * by the original routine (unless we have a VERY busy port pin)    * some initializations are done here, which could have been done before for    * both code paths but have been avioded for minimum path length to    * the uniq_time routine    */
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
comment|/*    * the real thing for everything else ...    */
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|Strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
specifier|register
name|void
function_decl|(
modifier|*
name|zsisr
function_decl|)
parameter_list|()
function_decl|;
comment|/* 	       * back home - phew (hopping along stream queues might 	       * prove dangerous to your health) 	       */
if|if
condition|(
name|zsisr
operator|=
operator|(
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_data
operator|)
operator|->
name|oldzsops
operator|->
name|zsop_xsint
condition|)
name|zsisr
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: unable to locate original ISR"
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_ISR
argument_list|,
operator|(
literal|"zs_xsisr: non CD event was processed for \"%s\"\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
comment|/* 	       * now back to our program ... 	       */
return|return;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - non CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * last resort - shouldn't even come here as it indicates    * corrupted TTY structures    */
name|printf
argument_list|(
literal|"zs_zsisr: looking for \"%s\" - found \"%s\" - taking EMERGENCY path\n"
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|,
name|dname
condition|?
name|dname
else|:
literal|"-NIL-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|emergencyzs
operator|&&
name|emergencyzs
operator|->
name|zsop_xsint
condition|)
name|emergencyzs
operator|->
name|zsop_xsint
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: no emergency ISR handler"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * History:  *  * parsesolaris.c,v  * Revision 3.9  1994/01/25  19:05:26  kardel  * 94/01/23 reconcilation  *  * Revision 3.8  1994/01/23  17:22:04  kardel  * 1994 reconcilation  *  * Revision 3.7  1993/12/15  18:24:41  kardel  * Now also ignoring state changes on ZSRR0_{SYNC,CTS} to avoid zs driver bugs (Solaris 2.3)  *  * Revision 3.6  1993/12/15  12:48:53  kardel  * fixed message loss on M_*HANHUP messages  *  * Revision 3.5  1993/12/14  21:05:12  kardel  * PPS working now for SunOS 5.x zs external status hook  *  * Revision 3.4  1993/11/13  11:13:17  kardel  * Solaris 2.3 additional includes  *  * Revision 3.3  1993/11/11  11:20:33  kardel  * declaration fixes  *  * Revision 3.2  1993/11/05  15:40:25  kardel  * shut up nice feature detection  *  * Revision 3.1  1993/11/01  20:00:29  kardel  * parse Solaris support (initial version)  *  */
end_comment

end_unit

