begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|PARSE
argument_list|)
operator|||
name|defined
argument_list|(
name|PARSEPPS
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CLOCK_TRIMTSIP
argument_list|)
end_if

begin_comment
comment|/*  * $FreeBSD$  *  * Trimble TSIP support - CURRENTLY VERY MUCH UNDER CONSTRUCTION  */
end_comment

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_comment
comment|/*  * Trimble TSIP parser  *  * The receiver uses a serial message protocol called Trimble Standard  * Interface Protocol (it can support others but this driver only supports  * TSIP). Messages in this protocol have the following form:  *  *<DLE><id> ...<data> ...<DLE><ETX>  *  * Any bytes within the<data> portion of value 10 hex (<DLE>) are doubled  * on transmission and compressed back to one on reception. Otherwise  * the values of data bytes can be anything. The serial interface is RS-422  * asynchronous using 9600 baud, 8 data bits with odd party (**note** 9 bits  * in total!), and 1 stop bit. The protocol supports byte, integer, single,  * and double datatypes. Integers are two bytes, sent most significant first.  * Singles are IEEE754 single precision floating point numbers (4 byte) sent  * sign& exponent first. Doubles are IEEE754 double precision floating point  * numbers (8 byte) sent sign& exponent first.  * The receiver supports a large set of messages, only a small subset of  * which are used here. From driver to receiver the following are used:  *  *  ID    Description  *  *  21    Request current time  *  22    Mode Select  *  2C    Set/Request operating parameters  *  2F    Request UTC info  *  35    Set/Request I/O options  *  * From receiver to driver the following are recognised:  *  *  ID    Description  *  *  41    GPS Time  *  44    Satellite selection, PDOP, mode  *  46    Receiver health  *  4B    Machine code/status  *  4C    Report operating parameters (debug only)  *  4F    UTC correction data (used to get leap second warnings)  *  55    I/O options (debug only)  *  * All others are accepted but ignored.  *  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|trimble
block|{
name|u_char
name|t_in_pkt
decl_stmt|;
comment|/* first DLE received */
name|u_char
name|t_dle
decl_stmt|;
comment|/* subsequent DLE received */
name|u_char
name|t_status
decl_stmt|;
comment|/* last status */
name|u_char
name|t_error
decl_stmt|;
comment|/* last error */
name|u_short
name|t_week
decl_stmt|;
comment|/* GPS week */
name|u_short
name|t_weekleap
decl_stmt|;
comment|/* GPS week of next/last week */
name|u_short
name|t_dayleap
decl_stmt|;
comment|/* day in week */
name|u_short
name|t_gpsutc
decl_stmt|;
comment|/* GPS - UTC offset */
name|u_short
name|t_gpsutcleap
decl_stmt|;
comment|/* offset at next/last leap */
name|u_char
name|t_operable
decl_stmt|;
comment|/* receiver feels OK */
name|u_char
name|t_leap
decl_stmt|;
comment|/* possible leap warning */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|inp_tsip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|cvt_trimtsip
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|clockformat
name|clock_trimtsip
init|=
block|{
name|inp_tsip
block|,
comment|/* Trimble TSIP input handler */
name|cvt_trimtsip
block|,
comment|/* Trimble TSIP conversion */
name|syn_simple
block|,
comment|/* easy time stamps for RS232 (fallback) */
name|pps_simple
block|,
comment|/* easy PPS monitoring */
operator|(
name|unsigned
name|LONG
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
comment|/* no time code synthesizer monitoring */
operator|(
name|void
operator|*
operator|)
literal|0
block|,
comment|/* no configuration data */
literal|"Trimble SV6/TSIP"
block|,
literal|128
block|,
comment|/* input buffer */
name|CVT_FIXEDONLY
block|,
comment|/* we do our own input handling */
sizeof|sizeof
argument_list|(
expr|struct
name|trimble
argument_list|)
block|,
comment|/* no private data */
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDSECOND
value|0x01
end_define

begin_define
define|#
directive|define
name|DELSECOND
value|0x02
end_define

begin_define
define|#
directive|define
name|DLE
value|0x10
end_define

begin_define
define|#
directive|define
name|ETX
value|0x03
end_define

begin_function
specifier|static
name|unsigned
name|LONG
name|inp_tsip
parameter_list|(
name|parseio
parameter_list|,
name|ch
parameter_list|,
name|ctime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|unsigned
name|char
name|ch
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ctime
decl_stmt|;
block|{
specifier|register
name|struct
name|trimble
modifier|*
name|t
init|=
operator|(
expr|struct
name|trimble
operator|*
operator|)
name|parseio
operator|->
name|parse_pdata
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
comment|/* local data not allocated - sigh! */
if|if
condition|(
operator|!
name|t
operator|->
name|t_in_pkt
operator|&&
name|ch
operator|!=
name|DLE
condition|)
block|{
comment|/* wait for start of packet */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"sv6+ discarding %2.2x\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|DLE
case|:
if|if
condition|(
operator|!
name|t
operator|->
name|t_in_pkt
condition|)
block|{
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_in_pkt
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ctime
expr_stmt|;
comment|/* pick up time stamp at packet start */
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|t_dle
condition|)
block|{
comment|/* Double DLE -> insert a DLE */
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
block|}
else|else
name|t
operator|->
name|t_dle
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ETX
case|:
if|if
condition|(
name|t
operator|->
name|t_dle
condition|)
block|{
comment|/* DLE,ETX -> end of packet */
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|DLE
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_ldsize
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_in_pkt
operator|=
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fall into ... */
default|default:
name|t
operator|->
name|t_dle
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
return|return
operator|(
name|parseio
operator|->
name|parse_index
operator|==
name|parseio
operator|->
name|parse_dsize
operator|-
literal|1
operator|)
return|;
comment|/* buffer full - attempt to parse (likely to fail) */
block|}
end_function

begin_define
define|#
directive|define
name|GPSORIGIN
value|2524953600
end_define

begin_comment
comment|/* NTP origin - GPS origin in seconds */
end_comment

begin_define
define|#
directive|define
name|SECSPERWEEK
value|604800
end_define

begin_comment
comment|/* seconds per week - GPS tells us about weeks */
end_comment

begin_define
define|#
directive|define
name|L_UF_SCALE
value|4294967296.0
end_define

begin_comment
comment|/* scale a float fraction to l_uf units */
end_comment

begin_comment
comment|/*  * mapping union for ints, floats, doubles for both input& output to the  * receiver  *  * CAVEAT: must disappear - non portable  */
end_comment

begin_union
union|union
block|{
name|u_char
name|bd
index|[
literal|8
index|]
decl_stmt|;
name|int
name|iv
decl_stmt|;
name|float
name|fv
decl_stmt|;
name|double
name|dv
decl_stmt|;
block|}
name|uval
union|;
end_union

begin_decl_stmt
specifier|static
name|float
name|getflt
name|P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|getdbl
name|P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getint
name|P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cvt_trimtsip  *  * convert TSIP type format  */
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|cvt_trimtsip
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|format
parameter_list|,
name|clock
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|struct
name|format
modifier|*
name|format
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
specifier|register
name|struct
name|trimble
modifier|*
name|t
decl_stmt|;
block|{
define|#
directive|define
name|mb
parameter_list|(
name|_X_
parameter_list|)
value|(buffer[2+(_X_)])
comment|/* shortcut for buffer access */
specifier|register
name|u_char
name|cmd
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sv6+ BAD call (t=0)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_NONE
return|;
comment|/* local data not allocated - sigh! */
block|}
if|if
condition|(
operator|(
name|size
operator|<
literal|4
operator|)
operator|||
operator|(
name|buffer
index|[
literal|0
index|]
operator|!=
name|DLE
operator|)
operator|||
operator|(
name|buffer
index|[
name|size
operator|-
literal|1
index|]
operator|!=
name|ETX
operator|)
operator|||
operator|(
name|buffer
index|[
name|size
operator|-
literal|2
index|]
operator|!=
name|DLE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"sv6+ BAD packet, size %d:\n	"
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2.2x, "
argument_list|,
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
condition|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|CVT_NONE
return|;
block|}
else|else
block|{
name|cmd
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|0x41
case|:
name|printf
argument_list|(
literal|"sv6+ gps time: %f, %d, %f\n"
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x44
case|:
name|printf
argument_list|(
literal|"sv6+ sats: %2x, %2d %2d %2d %2d, %.2f\n"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x45
case|:
name|printf
argument_list|(
literal|"sv6+ software: %d.%d (19%d/%d/%d)\n"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|4
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x46
case|:
name|printf
argument_list|(
literal|"sv6+ health: %2x %2x\n"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x48
case|:
name|printf
argument_list|(
literal|"sv6+ gps message: '%.22s'\n"
argument_list|,
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4b
case|:
name|printf
argument_list|(
literal|"sv6+ status: %2d %2x\n"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4c
case|:
name|printf
argument_list|(
literal|"sv6+ op params: %2x %.1f %.1f %.1f %.1f\n"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|9
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|13
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4f
case|:
name|printf
argument_list|(
literal|"sv6+ utc data: %.3e %.3e %d %d %d %d %d\n"
argument_list|,
name|getdbl
argument_list|(
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|18
argument_list|)
argument_list|)
argument_list|,
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
argument_list|,
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|22
argument_list|)
argument_list|)
argument_list|,
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|24
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x54
case|:
comment|/*printf("sv6+ bias and rate: %.1fm %.2fm/s at %.1fs\n", 		 getflt(&mb(0)), getflt(&mb(4)), getflt(&mb(8))); ignore it*/
break|break;
case|case
literal|0x55
case|:
name|printf
argument_list|(
literal|"sv6+ io opts: %2x %2x %2x %2x\n"
argument_list|,
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|2
argument_list|)
argument_list|,
name|mb
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8f
case|:
block|{
define|#
directive|define
name|RTOD
value|(180.0 / 3.1415926535898)
name|double
name|lat
init|=
name|getdbl
argument_list|(
operator|&
name|mb
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|lng
init|=
name|getdbl
argument_list|(
operator|&
name|mb
argument_list|(
literal|10
argument_list|)
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"sv6+ last fix: %2.2x %d lat %f %c, long %f %c, alt %.2fm\n"
argument_list|,
name|mb
argument_list|(
literal|1
argument_list|)
operator|&
literal|0xff
argument_list|,
name|mb
argument_list|(
literal|40
argument_list|)
operator|&
literal|0xff
argument_list|,
operator|(
operator|(
name|lat
operator|<
literal|0
operator|)
condition|?
operator|(
operator|-
name|lat
operator|)
else|:
operator|(
name|lat
operator|)
operator|)
operator|*
name|RTOD
argument_list|,
operator|(
name|lat
operator|<
literal|0
condition|?
literal|'S'
else|:
literal|'N'
operator|)
argument_list|,
operator|(
operator|(
name|lng
operator|<
literal|0
operator|)
condition|?
operator|(
operator|-
name|lng
operator|)
else|:
operator|(
name|lng
operator|)
operator|)
operator|*
name|RTOD
argument_list|,
operator|(
name|lng
operator|<
literal|0
condition|?
literal|'W'
else|:
literal|'E'
operator|)
argument_list|,
name|getdbl
argument_list|(
operator|&
name|mb
argument_list|(
literal|18
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x40
case|:
case|case
literal|0x5b
case|:
case|case
literal|0x6d
case|:
comment|/* Ignore */
break|break;
default|default:
name|printf
argument_list|(
literal|"sv6+ cmd ignored: %2x, length: %d\n"
argument_list|,
name|cmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* DEBUG */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|0x41
case|:
block|{
comment|/* GPS time */
name|float
name|secs
init|=
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|week
init|=
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|secint
decl_stmt|;
name|float
name|secfrac
decl_stmt|;
name|l_fp
name|gpstime
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|secs
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sv6+ seconds<= 0 (%e), setting POWERUP\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clock
operator|->
name|flags
operator|=
name|PARSEB_POWERUP
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
comment|/* time OK */
name|secint
operator|=
name|secs
expr_stmt|;
comment|/* integer part, hopefully */
name|secfrac
operator|=
name|secs
operator|-
name|secint
expr_stmt|;
comment|/* 0.0<= secfrac< 1.0 */
name|secint
operator|-=
name|getflt
argument_list|(
operator|&
name|mb
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* UTC offset */
name|gpstime
operator|.
name|l_ui
operator|=
name|week
operator|*
name|SECSPERWEEK
operator|+
name|secint
operator|+
name|GPSORIGIN
expr_stmt|;
comment|/* convert to NTP time */
name|gpstime
operator|.
name|l_uf
operator|=
name|secfrac
operator|*
name|L_UF_SCALE
expr_stmt|;
name|clock
operator|->
name|utctime
operator|=
name|gpstime
operator|.
name|l_ui
operator|-
name|JAN_1970
expr_stmt|;
name|TSFTOTVU
argument_list|(
name|gpstime
operator|.
name|l_uf
argument_list|,
name|clock
operator|->
name|usecond
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_leap
operator|==
name|ADDSECOND
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_LEAPADD
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_leap
operator|==
name|DELSECOND
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_LEAPDEL
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_operable
condition|)
name|clock
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PARSEB_NOSYNC
operator||
name|PARSEB_POWERUP
operator|)
expr_stmt|;
else|else
name|clock
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
comment|/* case 0x41 */
break|break;
case|case
literal|0x46
case|:
block|{
comment|/* sv6+ health */
name|u_char
name|status
init|=
name|t
operator|->
name|t_status
operator|=
name|mb
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|u_char
name|error
init|=
name|t
operator|->
name|t_error
operator|=
name|mb
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|9
operator|||
name|status
operator|==
literal|10
operator|||
name|status
operator|==
literal|11
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|t_operable
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Trimble clock synced"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_operable
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|->
name|t_operable
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Trimble clock unsynced"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_operable
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x4f
case|:
block|{
comment|/* UTC correction data - derive a leap warning */
name|int
name|tls
init|=
name|t
operator|->
name|t_gpsutc
operator|=
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|12
argument_list|)
argument_list|)
decl_stmt|;
comment|/* current leap correction (GPS-UTC) */
name|int
name|wnlsf
init|=
name|t
operator|->
name|t_weekleap
operator|=
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|20
argument_list|)
argument_list|)
decl_stmt|;
comment|/* week no of leap correction */
name|int
name|dn
init|=
name|t
operator|->
name|t_dayleap
operator|=
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|22
argument_list|)
argument_list|)
decl_stmt|;
comment|/* day in week of leap correction */
name|int
name|tlsf
init|=
name|t
operator|->
name|t_gpsutcleap
operator|=
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|24
argument_list|)
argument_list|)
decl_stmt|;
comment|/* new leap correction */
name|U_LONG
name|now
decl_stmt|,
name|leaptime
decl_stmt|;
name|t
operator|->
name|t_week
operator|=
name|getint
argument_list|(
operator|&
name|mb
argument_list|(
literal|18
argument_list|)
argument_list|)
expr_stmt|;
comment|/* current week no */
comment|/* this stuff hasn't been tested yet... */
name|now
operator|=
name|clock
operator|->
name|utctime
operator|+
name|JAN_1970
expr_stmt|;
comment|/* now in GPS seconds */
name|leaptime
operator|=
operator|(
name|wnlsf
operator|*
literal|7
operator|+
name|dn
operator|)
operator|*
literal|86400
expr_stmt|;
comment|/* time of leap in GPS seconds */
if|if
condition|(
operator|(
name|leaptime
operator|>
name|now
operator|)
operator|&&
operator|(
operator|(
name|leaptime
operator|-
name|now
operator|)
operator|<
literal|86400
operator|*
literal|28
operator|)
condition|)
block|{
comment|/* generate a leap warning */
if|if
condition|(
name|tlsf
operator|>
name|tls
condition|)
name|t
operator|->
name|t_leap
operator|=
name|ADDSECOND
expr_stmt|;
else|else
name|t
operator|->
name|t_leap
operator|=
name|DELSECOND
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|t_leap
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* it's validly formed, but we don't care about it! */
break|break;
block|}
block|}
return|return
name|CVT_SKIP
return|;
block|}
end_function

begin_comment
comment|/*  * getflt, getdbl, getint convert fields in the incoming data into the  * appropriate type of item  *  * CAVEAT: these routines are currently definitely byte order dependent  * and assume Representation(float) == IEEE754  * These functions MUST be converted to portable versions (especially  * converting the float representation into ntp_fp formats in order  * to avoid floating point operations at all!  */
end_comment

begin_function
specifier|static
name|float
name|getflt
parameter_list|(
name|bp
parameter_list|)
name|u_char
modifier|*
name|bp
decl_stmt|;
block|{
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
expr_stmt|;
return|return
name|uval
operator|.
name|fv
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|getdbl
parameter_list|(
name|bp
parameter_list|)
name|u_char
modifier|*
name|bp
decl_stmt|;
block|{
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|4
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|5
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|6
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|7
index|]
operator|=
operator|*
name|bp
expr_stmt|;
return|return
name|uval
operator|.
name|dv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getint
parameter_list|(
name|bp
parameter_list|)
name|u_char
modifier|*
name|bp
decl_stmt|;
block|{
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|uval
operator|.
name|bd
index|[
literal|3
index|]
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|uval
operator|.
name|bd
index|[
literal|2
index|]
operator|&
literal|0x80
condition|)
comment|/* sign-extend */
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
else|else
name|uval
operator|.
name|bd
index|[
literal|0
index|]
operator|=
name|uval
operator|.
name|bd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|uval
operator|.
name|iv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(PARSE)&& defined(CLOCK_TRIMTSIP) */
end_comment

begin_comment
comment|/*  * History:  *  * $Log: clk_trimtsip.c,v $  * Revision 1.2  1995/05/30  03:54:13  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/29  23:01:31  wollman  * xntp 3.4e from Dave Mills @ UDel  *  */
end_comment

end_unit

