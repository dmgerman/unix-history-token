begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|PARSE
argument_list|)
operator|||
name|defined
argument_list|(
name|PARSEPPS
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CLOCK_RAWDCF
argument_list|)
end_if

begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/parse/clk_rawdcf.c,v 3.9 1994/01/25 19:05:12 kardel Exp  *    * clk_rawdcf.c,v 3.9 1994/01/25 19:05:12 kardel Exp  *  * Raw DCF77 pulse clock support  *  * Copyright (c) 1992,1993,1994  * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PARSESTREAM
end_ifdef

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PARSEKERNEL
end_ifndef

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DCF77 raw time code  *  * From "Zur Zeit", Physikalisch-Technische Bundesanstalt (PTB), Braunschweig  * und Berlin, Maerz 1989  *  * Timecode transmission:  * AM:  *	time marks are send every second except for the second before the  *	next minute mark  *	time marks consist of a reduction of transmitter power to 25%  *	of the nominal level  *	the falling edge is the time indication (on time)  *	time marks of a 100ms duration constitute a logical 0  *	time marks of a 200ms duration constitute a logical 1  * FM:  *	see the spec. (basically a (non-)inverted psuedo random phase shift)  *  * Encoding:  * Second	Contents  * 0  - 10	AM: free, FM: 0  * 11 - 14	free  * 15		R     - alternate antenna  * 16		A1    - expect zone change (1 hour before)  * 17 - 18	Z1,Z2 - time zone  *		 0  0 illegal  *		 0  1 MEZ  (MET)  *		 1  0 MESZ (MED, MET DST)  *		 1  1 illegal  * 19		A2    - expect leap insertion/deletion (1 hour before)  * 20		S     - start of time code (1)  * 21 - 24	M1    - BCD (lsb first) Minutes  * 25 - 27	M10   - BCD (lsb first) 10 Minutes  * 28		P1    - Minute Parity (even)  * 29 - 32	H1    - BCD (lsb first) Hours  * 33 - 34      H10   - BCD (lsb first) 10 Hours  * 35		P2    - Hour Parity (even)  * 36 - 39	D1    - BCD (lsb first) Days  * 40 - 41	D10   - BCD (lsb first) 10 Days  * 42 - 44	DW    - BCD (lsb first) day of week (1: Monday -> 7: Sunday)  * 45 - 49	MO    - BCD (lsb first) Month  * 50           MO0   - 10 Months  * 51 - 53	Y1    - BCD (lsb first) Years  * 54 - 57	Y10   - BCD (lsb first) 10 Years  * 58 		P3    - Date Parity (even)  * 59		      - usually missing (minute indication), except for leap insertion  */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|cvt_rawdcf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|pps_rawdcf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|snt_rawdcf
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|clockformat_t
name|clock_rawdcf
init|=
block|{
name|cvt_rawdcf
block|,
comment|/* raw dcf input conversion */
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
comment|/* no character bound synchronisation */
name|pps_rawdcf
block|,
comment|/* examining PPS information */
name|snt_rawdcf
block|,
comment|/* synthesize time code from input */
operator|(
name|void
operator|*
operator|)
literal|0
block|,
comment|/* buffer bit representation */
literal|"RAW DCF77 Timecode"
block|,
comment|/* direct decoding / time synthesis */
literal|61
block|,
comment|/* bit buffer */
name|SYNC_ONE
operator||
name|SYNC_ZERO
operator||
name|SYNC_TIMEOUT
operator||
name|SYNC_SYNTHESIZE
operator||
name|CVT_FIXEDONLY
block|,
comment|/* catch all transitions, buffer restart on timeout, fixed configuration only */
block|{
literal|1
block|,
literal|500000
block|}
block|,
comment|/* restart after 1.5 seconds */
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|dcfparam
block|{
name|unsigned
name|char
name|onebits
index|[
literal|60
index|]
decl_stmt|;
name|unsigned
name|char
name|zerobits
index|[
literal|60
index|]
decl_stmt|;
block|}
name|dcfparam
init|=
block|{
literal|"###############RADMLS1248124P124812P1248121241248112481248P"
block|,
comment|/* 'ONE' representation */
literal|"--------------------s-------p------p----------------------p"
comment|/* 'ZERO' representation */
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|rawdcfcode
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit */
block|}
name|rawdcfcode
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|21
block|}
block|,
block|{
literal|25
block|}
block|,
block|{
literal|28
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|33
block|}
block|,
block|{
literal|35
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|40
block|}
block|,
block|{
literal|42
block|}
block|,
block|{
literal|45
block|}
block|,
block|{
literal|49
block|}
block|,
block|{
literal|50
block|}
block|,
block|{
literal|54
block|}
block|,
block|{
literal|58
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DCF_M
value|0
end_define

begin_define
define|#
directive|define
name|DCF_R
value|1
end_define

begin_define
define|#
directive|define
name|DCF_A1
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z
value|3
end_define

begin_define
define|#
directive|define
name|DCF_A2
value|4
end_define

begin_define
define|#
directive|define
name|DCF_S
value|5
end_define

begin_define
define|#
directive|define
name|DCF_M1
value|6
end_define

begin_define
define|#
directive|define
name|DCF_M10
value|7
end_define

begin_define
define|#
directive|define
name|DCF_P1
value|8
end_define

begin_define
define|#
directive|define
name|DCF_H1
value|9
end_define

begin_define
define|#
directive|define
name|DCF_H10
value|10
end_define

begin_define
define|#
directive|define
name|DCF_P2
value|11
end_define

begin_define
define|#
directive|define
name|DCF_D1
value|12
end_define

begin_define
define|#
directive|define
name|DCF_D10
value|13
end_define

begin_define
define|#
directive|define
name|DCF_DW
value|14
end_define

begin_define
define|#
directive|define
name|DCF_MO
value|15
end_define

begin_define
define|#
directive|define
name|DCF_MO0
value|16
end_define

begin_define
define|#
directive|define
name|DCF_Y1
value|17
end_define

begin_define
define|#
directive|define
name|DCF_Y10
value|18
end_define

begin_define
define|#
directive|define
name|DCF_P3
value|19
end_define

begin_struct
specifier|static
struct|struct
name|partab
block|{
name|char
name|offset
decl_stmt|;
comment|/* start bit of parity field */
block|}
name|partab
index|[]
init|=
block|{
block|{
literal|21
block|}
block|,
block|{
literal|29
block|}
block|,
block|{
literal|36
block|}
block|,
block|{
literal|59
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DCF_P_P1
value|0
end_define

begin_define
define|#
directive|define
name|DCF_P_P2
value|1
end_define

begin_define
define|#
directive|define
name|DCF_P_P3
value|2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MET
value|0x2
end_define

begin_define
define|#
directive|define
name|DCF_Z_MED
value|0x1
end_define

begin_function
specifier|static
name|unsigned
name|LONG
name|ext_bf
parameter_list|(
name|buf
parameter_list|,
name|idx
parameter_list|,
name|zero
parameter_list|)
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
specifier|register
name|char
modifier|*
name|zero
decl_stmt|;
block|{
specifier|register
name|unsigned
name|LONG
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
name|rawdcfcode
index|[
name|idx
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rawdcfcode
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
init|;
name|i
operator|>=
name|first
condition|;
name|i
operator|--
control|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator||=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|zero
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|pcheck
parameter_list|(
name|buf
parameter_list|,
name|idx
parameter_list|,
name|zero
parameter_list|)
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
specifier|register
name|char
modifier|*
name|zero
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
specifier|register
name|unsigned
name|psum
init|=
literal|1
decl_stmt|;
name|last
operator|=
name|partab
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|partab
index|[
name|idx
index|]
operator|.
name|offset
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|psum
operator|^=
operator|(
name|buf
index|[
name|i
index|]
operator|!=
name|zero
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
name|psum
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|LONG
name|convert_rawdcf
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|dcfparam
parameter_list|,
name|clock
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|struct
name|dcfparam
modifier|*
name|dcfparam
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfparam
operator|->
name|onebits
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfparam
operator|->
name|zerobits
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: \"%s\"\n"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|57
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: convert_rawdcf: INCOMPLETE DATA - time code only has %d bits\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: INCOMPLETE DATA - time code only has %d bits\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_NONE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|58
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|!=
operator|*
name|b
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
operator|*
name|c
operator|)
condition|)
block|{
comment|/* 	   * we only have two types of bytes (ones and zeros) 	   */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: convert_rawdcf: BAD DATA - no conversion for \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: BAD DATA - no conversion for \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_NONE
return|;
block|}
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
comment|/*    * check Start and Parity bits    */
if|if
condition|(
operator|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_S
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P1
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P2
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
operator|&&
name|pcheck
argument_list|(
name|buffer
argument_list|,
name|DCF_P_P3
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
condition|)
block|{
comment|/*        * buffer OK        */
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: parity check passed\n"
operator|)
argument_list|)
expr_stmt|;
name|clock
operator|->
name|flags
operator|=
name|PARSEB_S_ANTENNA
operator||
name|PARSEB_S_LEAP
expr_stmt|;
name|clock
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
name|clock
operator|->
name|second
operator|=
literal|0
expr_stmt|;
name|clock
operator|->
name|minute
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M10
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|minute
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|minute
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_M1
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|hour
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H10
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|hour
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|hour
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_H1
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|day
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D10
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|day
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|day
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_D1
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|month
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO0
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|month
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|month
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_MO
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|year
operator|=
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y10
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
name|clock
operator|->
name|year
operator|=
name|TIMES10
argument_list|(
name|clock
operator|->
name|year
argument_list|)
operator|+
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Y1
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_Z
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
condition|)
block|{
case|case
name|DCF_Z_MET
case|:
name|clock
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
case|case
name|DCF_Z_MED
case|:
name|clock
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
name|clock
operator|->
name|utcoffset
operator|=
operator|-
literal|2
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
break|break;
default|default:
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: BAD TIME ZONE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A1
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_A2
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_LEAP
expr_stmt|;
if|if
condition|(
name|ext_bf
argument_list|(
name|buffer
argument_list|,
name|DCF_R
argument_list|,
name|dcfparam
operator|->
name|zerobits
argument_list|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_ALTERNATE
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: convert_rawdcf: TIME CODE OK: %d:%d, %d.%d.%d, flags 0x%x\n"
operator|,
name|clock
operator|->
name|hour
operator|,
name|clock
operator|->
name|minute
operator|,
name|clock
operator|->
name|day
operator|,
name|clock
operator|->
name|month
operator|,
name|clock
operator|->
name|year
operator|,
name|clock
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
else|else
block|{
comment|/*        * bad format - not for us        */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: convert_rawdcf: parity check FAILED for \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: convert_rawdcf: parity check FAILED for \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * raw dcf input routine - needs to fix up 50 baud  * characters for 1/0 decision  */
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|cvt_rawdcf
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|param
parameter_list|,
name|clock
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|void
modifier|*
name|param
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
name|buffer
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|e
init|=
name|buffer
operator|+
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
init|=
name|dcfparam
operator|.
name|onebits
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|c
init|=
name|dcfparam
operator|.
name|zerobits
decl_stmt|;
specifier|register
name|unsigned
name|rtc
init|=
name|CVT_NONE
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|lowmax
decl_stmt|,
name|highmax
decl_stmt|,
name|cutoff
decl_stmt|,
name|span
decl_stmt|;
define|#
directive|define
name|BITS
value|9
name|unsigned
name|char
name|histbuf
index|[
name|BITS
index|]
decl_stmt|;
comment|/*    * the input buffer contains characters with runs of consecutive    * bits set. These set bits are an indication of the DCF77 pulse    * length. We assume that we receive the pulse at 50 Baud. Thus    * a 100ms pulse would generate a 4 bit train (20ms per bit and    * start bit)    * a 200ms pulse would create all zeroes (and probably a frame error)    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|histbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cutoff
operator|=
literal|0
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
specifier|register
name|unsigned
name|int
name|ch
init|=
operator|*
name|s
operator|^
literal|0xFF
decl_stmt|;
comment|/*        * these lines are left as an excercise to the reader 8-)        */
if|if
condition|(
operator|!
operator|(
operator|(
name|ch
operator|+
literal|1
operator|)
operator|&
name|ch
operator|)
operator|||
operator|!
operator|*
name|s
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|i
expr_stmt|;
name|histbuf
index|[
name|i
index|]
operator|++
expr_stmt|;
name|cutoff
operator|+=
name|i
expr_stmt|;
name|lowmax
operator|++
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: character check for 0x%x@%d FAILED\n"
operator|,
operator|*
name|s
operator|,
name|s
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|~
literal|0
expr_stmt|;
name|rtc
operator|=
name|CVT_FAIL
operator||
name|CVT_BADFMT
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lowmax
condition|)
block|{
name|cutoff
operator|/=
name|lowmax
expr_stmt|;
block|}
else|else
block|{
name|cutoff
operator|=
literal|4
expr_stmt|;
comment|/* doesn't really matter - it'll fail anyway, but gives error output */
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: average bit count: %d\n"
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|=
literal|0
expr_stmt|;
name|highmax
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: histogram:"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cutoff
condition|;
name|i
operator|++
control|)
block|{
name|lowmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"<M>"
operator|)
argument_list|)
expr_stmt|;
name|lowmax
operator|+=
name|highmax
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|highmax
condition|)
block|{
name|lowmax
operator|/=
name|highmax
expr_stmt|;
block|}
else|else
block|{
name|lowmax
operator|=
literal|0
expr_stmt|;
block|}
name|highmax
operator|=
literal|0
expr_stmt|;
name|cutoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|BITS
condition|;
name|i
operator|++
control|)
block|{
name|highmax
operator|+=
name|histbuf
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|cutoff
operator|+=
name|histbuf
index|[
name|i
index|]
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|" %d"
operator|,
name|histbuf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutoff
condition|)
block|{
name|highmax
operator|/=
name|cutoff
expr_stmt|;
block|}
else|else
block|{
name|highmax
operator|=
name|BITS
operator|-
literal|1
expr_stmt|;
block|}
name|span
operator|=
name|cutoff
operator|=
name|lowmax
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowmax
init|;
name|i
operator|<=
name|highmax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|>
name|histbuf
index|[
name|i
index|]
condition|)
block|{
name|cutoff
operator|=
name|i
expr_stmt|;
name|span
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|histbuf
index|[
name|cutoff
index|]
operator|==
name|histbuf
index|[
name|i
index|]
condition|)
block|{
name|span
operator|=
name|i
expr_stmt|;
block|}
block|}
name|cutoff
operator|=
operator|(
name|cutoff
operator|+
name|span
operator|)
operator|/
literal|2
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: cvt_rawdcf: lower maximum %d, higher maximum %d, cutoff %d\n"
operator|,
name|lowmax
operator|,
name|highmax
operator|,
name|cutoff
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|<
name|e
operator|)
operator|&&
operator|*
name|c
operator|&&
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
condition|)
block|{
operator|*
name|s
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|>=
name|cutoff
operator|)
condition|?
operator|*
name|b
else|:
operator|*
name|c
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rtc
operator|==
name|CVT_NONE
operator|)
condition|?
name|convert_rawdcf
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|dcfparam
argument_list|,
name|clock
argument_list|)
else|:
name|rtc
return|;
block|}
end_function

begin_comment
comment|/*  * pps_rawdcf  *  * currently a very stupid version - should be extended to decode  * also ones and zeros (which is easy)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|pps_rawdcf
parameter_list|(
name|parseio
parameter_list|,
name|status
parameter_list|,
name|ptime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ptime
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_ptime
operator|=
operator|*
name|ptime
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
block|}
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|snt_rawdcf
parameter_list|(
name|parseio
parameter_list|,
name|ptime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ptime
decl_stmt|;
block|{
name|clocktime_t
name|clock
decl_stmt|;
name|unsigned
name|LONG
name|cvtrtc
decl_stmt|;
name|time_t
name|t
decl_stmt|;
comment|/*    * start at last sample and add second index - gross, may have to be much more careful    */
if|if
condition|(
name|convert_rawdcf
argument_list|(
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_ldsize
operator|-
literal|1
argument_list|,
operator|&
name|dcfparam
argument_list|,
operator|&
name|clock
argument_list|)
operator|==
name|CVT_OK
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|parse_to_unixtime
argument_list|(
operator|&
name|clock
argument_list|,
operator|&
name|cvtrtc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: snt_rawdcf: time conversion FAILED\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_FAIL
operator||
name|cvtrtc
return|;
block|}
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: snt_rawdcf: data conversion FAILED\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ptime
expr_stmt|;
name|t
operator|+=
name|parseio
operator|->
name|parse_index
operator|-
literal|1
expr_stmt|;
comment|/*    * time stamp    */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
operator|=
name|t
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_usec
operator|=
name|clock
operator|.
name|usecond
expr_stmt|;
else|#
directive|else
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|=
name|t
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|clock
operator|.
name|usecond
argument_list|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_uf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parseprintf
argument_list|(
name|DD_RAWDCF
argument_list|,
operator|(
literal|"parse: snt_rawdcf: time stamp synthesized offset %d seconds\n"
operator|,
name|parseio
operator|->
name|parse_index
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|updatetimeinfo
argument_list|(
name|parseio
argument_list|,
name|t
argument_list|,
name|clock
operator|.
name|usecond
argument_list|,
name|clock
operator|.
name|flags
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(PARSE)&& defined(CLOCK_RAWDCF) */
end_comment

begin_comment
comment|/*  * History:  *  * clk_rawdcf.c,v  * Revision 3.9  1994/01/25  19:05:12  kardel  * 94/01/23 reconcilation  *  * Revision 3.8  1994/01/22  11:24:11  kardel  * fixed PPS handling  *  * Revision 3.7  1993/10/30  09:44:41  kardel  * conditional compilation flag cleanup  *  * Revision 3.6  1993/10/03  19:10:45  kardel  * restructured I/O handling  *  * Revision 3.5  1993/09/27  21:08:07  kardel  * utcoffset now in seconds  *  * Revision 3.4  1993/09/26  23:40:25  kardel  * new parse driver logic  *  * Revision 3.3  1993/09/01  21:44:54  kardel  * conditional cleanup  *  * Revision 3.2  1993/07/09  11:37:18  kardel  * Initial restructured version + GPS support  *  * Revision 3.1  1993/07/06  10:00:19  kardel  * DCF77 driver goes generic...  *  */
end_comment

end_unit

