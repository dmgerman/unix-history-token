begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|PARSE
argument_list|)
operator|||
name|defined
argument_list|(
name|PARSEPPS
argument_list|)
operator|)
end_if

begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/parse/parse.c,v 3.19 1994/01/25 19:05:20 kardel Exp  *    * parse.c,v 3.19 1994/01/25 19:05:20 kardel Exp  *  * Parser module for reference clock  *  * PARSEKERNEL define switches between two personalities of the module  * if PARSEKERNEL is defined this module can be used with dcf77sync.c as  * a PARSEKERNEL kernel module. In this case the time stamps will be  * a struct timeval.  * when PARSEKERNEL is not defined NTP time stamps will be used.  *  * Copyright (c) 1992,1993,1994  * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|lint
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"parse.c,v 3.19 1994/01/25 19:05:20 kardel Exp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PARSESTREAM
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SYS_SUNOS4
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_SOLARIS
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_comment
comment|/*  * Sorry, but in SunOS 4.x AND Solaris 2.x kernels there are no  * mem* operations. I don't want them - bcopy, bzero  * are fine in the kernel  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NTP_NEED_BOPS
end_ifndef

begin_define
define|#
directive|define
name|NTP_NEED_BOPS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|NTP_NEED_BOPS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|bzero
end_ifndef

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|_X_
parameter_list|,
name|_Y_
parameter_list|)
value|memset(_X_, 0, _Y_)
end_define

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|_X_
parameter_list|,
name|_Y_
parameter_list|,
name|_Z_
parameter_list|)
value|memmove(_Y_, _X_, _Z_)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PARSESTREAM
end_ifdef

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|clockformat_t
modifier|*
name|clockformats
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|short
name|nformats
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|timepacket
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * strings support usually not in kernel - duplicated, but what the heck  */
end_comment

begin_function
specifier|static
name|int
name|Strlen
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
block|{
name|c
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Strcmp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timedout
parameter_list|(
name|parseio
parameter_list|,
name|ctime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ctime
decl_stmt|;
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|delta
operator|.
name|tv_sec
operator|=
name|ctime
operator|->
name|tv
operator|.
name|tv_sec
operator|-
name|parseio
operator|->
name|parse_lastchar
operator|.
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|ctime
operator|->
name|tv
operator|.
name|tv_usec
operator|-
name|parseio
operator|->
name|parse_lastchar
operator|.
name|tv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
else|#
directive|else
specifier|extern
name|LONG
name|tstouslo
index|[]
decl_stmt|;
specifier|extern
name|LONG
name|tstousmid
index|[]
decl_stmt|;
specifier|extern
name|LONG
name|tstoushi
index|[]
decl_stmt|;
name|l_fp
name|delt
decl_stmt|;
name|delt
operator|=
name|ctime
operator|->
name|fp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|delt
argument_list|,
operator|&
name|parseio
operator|->
name|parse_lastchar
operator|.
name|fp
argument_list|)
expr_stmt|;
name|TSTOTV
argument_list|(
operator|&
name|delt
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|parseio
operator|->
name|parse_timeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: timedout: TRUE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: timedout: FALSE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * setup_bitmaps  */
end_comment

begin_function
specifier|static
name|int
name|setup_bitmaps
parameter_list|(
name|parseio
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|unsigned
name|short
name|low
decl_stmt|;
specifier|register
name|unsigned
name|short
name|high
decl_stmt|;
block|{
specifier|register
name|unsigned
name|short
name|i
decl_stmt|;
specifier|register
name|int
name|f
init|=
literal|0
decl_stmt|;
specifier|register
name|clockformat_t
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|unsigned
name|index
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|low
operator|>=
name|high
operator|)
operator|||
operator|(
name|high
operator|>
name|nformats
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"setup_bitmaps: failed: bounds error (low=%d, high=%d, nformats=%d)\n"
operator|,
name|low
operator|,
name|high
operator|,
name|nformats
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|parseio
operator|->
name|parse_startsym
argument_list|,
sizeof|sizeof
argument_list|(
name|parseio
operator|->
name|parse_startsym
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parseio
operator|->
name|parse_endsym
argument_list|,
sizeof|sizeof
argument_list|(
name|parseio
operator|->
name|parse_endsym
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parseio
operator|->
name|parse_syncsym
argument_list|,
sizeof|sizeof
argument_list|(
name|parseio
operator|->
name|parse_syncsym
argument_list|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_syncflags
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/*    * gather bitmaps of possible start and end values    */
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
name|fmt
operator|=
name|clockformats
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|flags
operator|&
name|F_START
condition|)
block|{
name|index
operator|=
name|fmt
operator|->
name|startsym
operator|/
literal|8
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|fmt
operator|->
name|startsym
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_endsym
index|[
name|index
index|]
operator|&
name|mask
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: setup_bitmaps: failed: START symbol collides with END symbol (format %d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: setup_bitmaps: failed: START symbol collides with END symbol (format %d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|else
block|{
name|parseio
operator|->
name|parse_startsym
index|[
name|index
index|]
operator||=
name|mask
expr_stmt|;
name|f
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fmt
operator|->
name|flags
operator|&
name|F_END
condition|)
block|{
name|index
operator|=
name|fmt
operator|->
name|endsym
operator|/
literal|8
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|fmt
operator|->
name|endsym
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_startsym
index|[
name|index
index|]
operator|&
name|mask
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: setup_bitmaps: failed: END symbol collides with START symbol (format %d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: setup_bitmaps: failed: END symbol collides with START symbol (format %d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|else
block|{
name|parseio
operator|->
name|parse_endsym
index|[
name|index
index|]
operator||=
name|mask
expr_stmt|;
name|f
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fmt
operator|->
name|flags
operator|&
name|SYNC_CHAR
condition|)
block|{
name|parseio
operator|->
name|parse_syncsym
index|[
name|fmt
operator|->
name|syncsym
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|fmt
operator|->
name|syncsym
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|parseio
operator|->
name|parse_syncflags
operator||=
name|fmt
operator|->
name|flags
operator|&
operator|(
name|SYNC_START
operator||
name|SYNC_END
operator||
name|SYNC_CHAR
operator||
name|SYNC_ONE
operator||
name|SYNC_ZERO
operator||
name|SYNC_TIMEOUT
operator||
name|SYNC_SYNTHESIZE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|->
name|flags
operator|&
name|SYNC_TIMEOUT
operator|)
operator|&&
operator|(
operator|(
name|parseio
operator|->
name|parse_timeout
operator|.
name|tv_sec
operator|||
name|parseio
operator|->
name|parse_timeout
operator|.
name|tv_usec
operator|)
condition|?
name|timercmp
argument_list|(
operator|&
name|parseio
operator|->
name|parse_timeout
argument_list|,
operator|&
name|fmt
operator|->
name|timeout
argument_list|,
operator|>
argument_list|)
else|:
literal|1
operator|)
condition|)
block|{
name|parseio
operator|->
name|parse_timeout
operator|=
name|fmt
operator|->
name|timeout
expr_stmt|;
block|}
if|if
condition|(
name|parseio
operator|->
name|parse_dsize
operator|<
name|fmt
operator|->
name|length
condition|)
name|parseio
operator|->
name|parse_dsize
operator|=
name|fmt
operator|->
name|length
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
operator|&&
operator|(
call|(
name|int
call|)
argument_list|(
name|high
operator|-
name|low
argument_list|)
operator|>
literal|1
operator|)
condition|)
block|{
comment|/*        * need at least one start or end symbol        */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: setup_bitmaps: failed: neither START nor END symbol defined\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: setup_bitmaps: failed: neither START nor END symbol defined\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_ioinit
parameter_list|(
name|parseio
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iostart\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setup_bitmaps
argument_list|(
name|parseio
argument_list|,
literal|0
argument_list|,
name|nformats
argument_list|)
condition|)
return|return
literal|0
return|;
name|parseio
operator|->
name|parse_data
operator|=
name|MALLOC
argument_list|(
name|parseio
operator|->
name|parse_dsize
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseio
operator|->
name|parse_data
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"init failed: malloc for data area failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * leave room for '\0'    */
name|parseio
operator|->
name|parse_ldata
operator|=
name|parseio
operator|->
name|parse_data
operator|+
name|parseio
operator|->
name|parse_dsize
operator|+
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_lformat
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_badformat
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_ioflags
operator|=
name|PARSE_IO_CS7
expr_stmt|;
comment|/* usual unix default */
name|parseio
operator|->
name|parse_flags
operator|=
literal|0
expr_stmt|;
comment|/* true samples */
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|parse_ioend
parameter_list|(
name|parseio
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioend\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_data
condition|)
name|FREE
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_dsize
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_ioread
parameter_list|(
name|parseio
parameter_list|,
name|ch
parameter_list|,
name|ctime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|unsigned
name|char
name|ch
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ctime
decl_stmt|;
block|{
specifier|register
name|unsigned
name|updated
init|=
name|CVT_NONE
decl_stmt|;
specifier|register
name|unsigned
name|short
name|low
decl_stmt|,
name|high
decl_stmt|;
specifier|register
name|unsigned
name|index
decl_stmt|,
name|mask
decl_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread(0x%x, char=0x%x, ..., ...)\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|parseio
operator|,
name|ch
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_flags
operator|&
name|PARSE_FIXED_FMT
condition|)
block|{
if|if
condition|(
operator|!
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|convert
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: input dropped.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
name|low
operator|=
name|parseio
operator|->
name|parse_lformat
expr_stmt|;
name|high
operator|=
name|low
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|nformats
expr_stmt|;
block|}
comment|/*    * within STREAMS CSx (x< 8) chars still have the upper bits set    * so we normalize the characters by masking unecessary bits off.    */
switch|switch
condition|(
name|parseio
operator|->
name|parse_ioflags
operator|&
name|PARSE_IO_CSIZE
condition|)
block|{
case|case
name|PARSE_IO_CS5
case|:
name|ch
operator|&=
literal|0x1F
expr_stmt|;
break|break;
case|case
name|PARSE_IO_CS6
case|:
name|ch
operator|&=
literal|0x3F
expr_stmt|;
break|break;
case|case
name|PARSE_IO_CS7
case|:
name|ch
operator|&=
literal|0x7F
expr_stmt|;
break|break;
case|case
name|PARSE_IO_CS8
case|:
break|break;
block|}
name|index
operator|=
name|ch
operator|/
literal|8
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|ch
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_CHAR
operator|)
operator|&&
operator|(
name|parseio
operator|->
name|parse_syncsym
index|[
name|index
index|]
operator|&
name|mask
operator|)
condition|)
block|{
specifier|register
name|clockformat_t
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|unsigned
name|short
name|i
decl_stmt|;
comment|/*        * got a sync event - call sync routine        */
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
name|fmt
operator|=
name|clockformats
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|->
name|flags
operator|&
name|SYNC_CHAR
operator|)
operator|&&
operator|(
name|fmt
operator|->
name|syncsym
operator|==
name|ch
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: SYNC_CHAR event\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|syncevt
condition|)
name|fmt
operator|->
name|syncevt
argument_list|(
name|parseio
argument_list|,
name|ctime
argument_list|,
name|fmt
operator|->
name|data
argument_list|,
name|SYNC_CHAR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_START
operator|)
operator|&&
operator|(
name|parseio
operator|->
name|parse_startsym
index|[
name|index
index|]
operator|&
name|mask
operator|)
operator|)
operator|||
operator|(
name|parseio
operator|->
name|parse_index
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_TIMEOUT
operator|)
operator|&&
name|timedout
argument_list|(
name|parseio
argument_list|,
name|ctime
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|unsigned
name|short
name|i
decl_stmt|;
comment|/*        * packet start - re-fill buffer        */
if|if
condition|(
name|parseio
operator|->
name|parse_index
condition|)
block|{
comment|/* 	   * filled buffer - thus not end character found 	   * do processing now 	   */
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|updated
operator|=
name|timepacket
argument_list|(
name|parseio
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_TIMEOUT
condition|)
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ctime
expr_stmt|;
block|}
comment|/*        * could be a sync event - call sync routine if needed        */
if|if
condition|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_START
condition|)
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|clockformat_t
modifier|*
name|fmt
init|=
name|clockformats
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|parseio
operator|->
name|parse_index
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|fmt
operator|->
name|flags
operator|&
name|SYNC_START
operator|)
operator|&&
operator|(
name|fmt
operator|->
name|startsym
operator|==
name|ch
operator|)
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: SYNC_START event\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|syncevt
condition|)
name|fmt
operator|->
name|syncevt
argument_list|(
name|parseio
argument_list|,
name|ctime
argument_list|,
name|fmt
operator|->
name|data
argument_list|,
name|SYNC_START
argument_list|)
expr_stmt|;
block|}
block|}
name|parseio
operator|->
name|parse_index
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: parse_ioread: buffer start\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|unsigned
name|short
name|i
decl_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_index
operator|<
name|parseio
operator|->
name|parse_dsize
condition|)
block|{
comment|/* 	   * collect into buffer 	   */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: parse_ioread: buffer[%d] = 0x%x\n"
operator|,
name|parseio
operator|->
name|parse_index
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parseio
operator|->
name|parse_endsym
index|[
name|index
index|]
operator|&
name|mask
operator|)
operator|||
operator|(
name|parseio
operator|->
name|parse_index
operator|>=
name|parseio
operator|->
name|parse_dsize
operator|)
condition|)
block|{
comment|/* 	   * packet end - process buffer 	   */
if|if
condition|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_END
condition|)
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|clockformat_t
modifier|*
name|fmt
init|=
name|clockformats
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|->
name|flags
operator|&
name|SYNC_END
operator|)
operator|&&
operator|(
name|fmt
operator|->
name|endsym
operator|==
name|ch
operator|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: SYNC_END event\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|syncevt
condition|)
name|fmt
operator|->
name|syncevt
argument_list|(
name|parseio
argument_list|,
name|ctime
argument_list|,
name|fmt
operator|->
name|data
argument_list|,
name|SYNC_END
argument_list|)
expr_stmt|;
block|}
block|}
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|updated
operator|=
name|timepacket
argument_list|(
name|parseio
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
operator|+
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: parse_ioread: buffer end\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|updated
operator|==
name|CVT_NONE
operator|)
operator|&&
operator|(
name|parseio
operator|->
name|parse_flags
operator|&
name|PARSE_FIXED_FMT
operator|)
operator|&&
operator|(
name|parseio
operator|->
name|parse_syncflags
operator|&
name|SYNC_SYNTHESIZE
operator|)
operator|&&
operator|(
operator|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_OK
operator|)
operator|&&
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|synth
condition|)
block|{
name|updated
operator|=
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|synth
argument_list|(
name|parseio
argument_list|,
name|ctime
argument_list|)
expr_stmt|;
block|}
comment|/*    * remember last character time    */
name|parseio
operator|->
name|parse_lastchar
operator|=
operator|*
name|ctime
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|updated
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
condition|)
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: time sample accumulated (status=0x%x)\n"
operator|,
name|updated
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_status
operator|=
name|updated
expr_stmt|;
return|return
operator|(
name|updated
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * parse_iopps  *  * take status line indication and derive synchronisation information  * from it.  * It can also be used to decode a serial serial data format (such as the  * ONE, ZERO, MINUTE sync data stream from DCF77)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_iopps
parameter_list|(
name|parseio
parameter_list|,
name|status
parameter_list|,
name|ptime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ptime
decl_stmt|;
block|{
specifier|register
name|unsigned
name|updated
init|=
name|CVT_NONE
decl_stmt|;
comment|/*    * PPS pulse information will only be delivered to ONE clock format    * this is either the last successful conversion module with a ppssync    * routine, or a fixed format with a ppssync routine    */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iopps: STATUS %s\n"
operator|,
operator|(
name|status
operator|==
name|SYNC_ONE
operator|)
condition|?
literal|"ONE"
else|:
literal|"ZERO"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|parseio
operator|->
name|parse_flags
operator|&
name|PARSE_FIXED_FMT
operator|)
operator|||
operator|(
operator|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_OK
operator|)
operator|)
operator|&&
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|syncpps
operator|&&
operator|(
name|status
operator|&
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|flags
operator|)
condition|)
block|{
name|updated
operator|=
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|syncpps
argument_list|(
name|parseio
argument_list|,
name|status
operator|==
name|SYNC_ONE
argument_list|,
name|ptime
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iopps: updated = 0x%x\n"
operator|,
name|updated
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iopps: STATUS dropped\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|updated
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * parse_iodone  *  * clean up internal status for new round  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|parse_iodone
parameter_list|(
name|parseio
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
block|{
comment|/*    * we need to clean up certain flags for the next round    */
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator|=
literal|0
expr_stmt|;
comment|/* no problems with ISRs */
block|}
end_function

begin_comment
comment|/*---------- conversion implementation --------------------*/
end_comment

begin_comment
comment|/*  * convert a struct clock to UTC since Jan, 1st 1970 0:00 (the UNIX EPOCH)  */
end_comment

begin_define
define|#
directive|define
name|dysize
parameter_list|(
name|x
parameter_list|)
value|((x) % 4 ? 365 : ((x % 400) ? 365 :366))
end_define

begin_function
name|time_t
name|parse_to_unixtime
parameter_list|(
name|clock
parameter_list|,
name|cvtrtc
parameter_list|)
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
specifier|register
name|unsigned
name|LONG
modifier|*
name|cvtrtc
decl_stmt|;
block|{
define|#
directive|define
name|SETRTC
parameter_list|(
name|_X_
parameter_list|)
value|{ if (cvtrtc) *cvtrtc = (_X_); }
specifier|static
name|int
name|days_of_month
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|clock
operator|->
name|year
operator|<
literal|100
condition|)
name|clock
operator|->
name|year
operator|+=
literal|1900
expr_stmt|;
if|if
condition|(
name|clock
operator|->
name|year
operator|<
literal|1970
condition|)
name|clock
operator|->
name|year
operator|+=
literal|100
expr_stmt|;
comment|/* XXX this will do it till<2070 */
if|if
condition|(
name|clock
operator|->
name|year
operator|<
literal|0
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*    * sorry, slow section here - but it's not time critical anyway    */
name|t
operator|=
operator|(
name|clock
operator|->
name|year
operator|-
literal|1970
operator|)
operator|*
literal|365
expr_stmt|;
name|t
operator|+=
operator|(
name|clock
operator|->
name|year
operator|>>
literal|2
operator|)
operator|-
operator|(
literal|1970
operator|>>
literal|2
operator|)
expr_stmt|;
name|t
operator|-=
name|clock
operator|->
name|year
operator|/
literal|400
operator|-
literal|1970
operator|/
literal|400
expr_stmt|;
comment|/* month */
if|if
condition|(
name|clock
operator|->
name|month
operator|<=
literal|0
operator|||
name|clock
operator|->
name|month
operator|>
literal|12
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad month */
block|}
comment|/* adjust leap year */
if|if
condition|(
name|clock
operator|->
name|month
operator|>=
literal|3
operator|&&
name|dysize
argument_list|(
name|clock
operator|->
name|year
argument_list|)
operator|==
literal|366
condition|)
name|t
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|clock
operator|->
name|month
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|+=
name|days_of_month
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* day */
if|if
condition|(
name|clock
operator|->
name|day
operator|<
literal|1
operator|||
operator|(
operator|(
name|clock
operator|->
name|month
operator|==
literal|2
operator|&&
name|dysize
argument_list|(
name|clock
operator|->
name|year
argument_list|)
operator|==
literal|366
operator|)
condition|?
name|clock
operator|->
name|day
operator|>
literal|29
else|:
name|clock
operator|->
name|day
operator|>
name|days_of_month
index|[
name|clock
operator|->
name|month
index|]
operator|)
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad day */
block|}
name|t
operator|+=
name|clock
operator|->
name|day
operator|-
literal|1
expr_stmt|;
comment|/* hour */
if|if
condition|(
name|clock
operator|->
name|hour
operator|<
literal|0
operator|||
name|clock
operator|->
name|hour
operator|>=
literal|24
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad hour */
block|}
name|t
operator|=
name|TIMES24
argument_list|(
name|t
argument_list|)
operator|+
name|clock
operator|->
name|hour
expr_stmt|;
comment|/* min */
if|if
condition|(
name|clock
operator|->
name|minute
operator|<
literal|0
operator|||
name|clock
operator|->
name|minute
operator|>
literal|59
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad min */
block|}
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock
operator|->
name|minute
expr_stmt|;
comment|/* sec */
if|if
condition|(
name|clock
operator|->
name|second
operator|<
literal|0
operator|||
name|clock
operator|->
name|second
operator|>
literal|60
condition|)
comment|/* allow for LEAPs */
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad sec */
block|}
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock
operator|->
name|second
expr_stmt|;
name|t
operator|+=
name|clock
operator|->
name|utcoffset
expr_stmt|;
comment|/* warp to UTC */
comment|/* done */
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*--------------- format conversion -----------------------------------*/
end_comment

begin_function
name|int
name|Stoi
parameter_list|(
name|s
parameter_list|,
name|zp
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|LONG
modifier|*
name|zp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|char
modifier|*
name|b
init|=
name|s
decl_stmt|;
name|int
name|f
decl_stmt|,
name|z
decl_stmt|,
name|v
decl_stmt|;
name|char
name|c
decl_stmt|;
name|f
operator|=
name|z
operator|=
name|v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|v
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|||
operator|(
name|cnt
operator|&&
operator|(
operator|(
name|s
operator|-
name|b
operator|)
operator|>
name|cnt
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|v
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
operator|*
name|zp
operator|=
name|z
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|z
operator|=
operator|(
name|z
operator|<<
literal|3
operator|)
operator|+
operator|(
name|z
operator|<<
literal|1
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|f
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|Strok
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|m
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|m
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|==
literal|' '
operator|)
condition|?
literal|1
else|:
operator|(
operator|*
name|s
operator|==
operator|*
name|m
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
operator|!
operator|*
name|m
return|;
block|}
end_function

begin_function
name|unsigned
name|LONG
name|updatetimeinfo
parameter_list|(
name|parseio
parameter_list|,
name|t
parameter_list|,
name|usec
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|time_t
name|t
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|usec
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|flags
decl_stmt|;
block|{
specifier|register
name|LONG
name|usecoff
decl_stmt|;
specifier|register
name|LONG
name|mean
decl_stmt|;
name|LONG
name|delta
index|[
name|PARSE_DELTA
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|usecoff
operator|=
operator|(
name|t
operator|-
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|.
name|tv
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|-
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|.
name|tv
operator|.
name|tv_usec
operator|+
name|usec
expr_stmt|;
else|#
directive|else
specifier|extern
name|LONG
name|tstouslo
index|[]
decl_stmt|;
specifier|extern
name|LONG
name|tstousmid
index|[]
decl_stmt|;
specifier|extern
name|LONG
name|tstoushi
index|[]
decl_stmt|;
name|TSFTOTVU
argument_list|(
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|.
name|fp
operator|.
name|l_uf
argument_list|,
name|usecoff
argument_list|)
expr_stmt|;
name|usecoff
operator|=
operator|-
name|usecoff
expr_stmt|;
name|usecoff
operator|+=
operator|(
name|t
operator|-
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|.
name|fp
operator|.
name|l_ui
operator|+
name|JAN_1970
operator|)
operator|*
literal|1000000
operator|+
name|usec
expr_stmt|;
endif|#
directive|endif
comment|/*    * filtering (median) if requested    */
if|if
condition|(
name|parseio
operator|->
name|parse_flags
operator|&
name|PARSE_STAT_FILTER
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|,
name|k
decl_stmt|;
name|parseio
operator|->
name|parse_delta
index|[
name|parseio
operator|->
name|parse_dindex
index|]
operator|=
name|usecoff
expr_stmt|;
name|parseio
operator|->
name|parse_dindex
operator|=
operator|(
name|parseio
operator|->
name|parse_dindex
operator|+
literal|1
operator|)
operator|%
name|PARSE_DELTA
expr_stmt|;
comment|/*        * sort always - thus every sample gets its data        */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|parseio
operator|->
name|parse_delta
argument_list|,
operator|(
name|caddr_t
operator|)
name|delta
argument_list|,
sizeof|sizeof
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|PARSE_DELTA
condition|;
name|s
operator|++
control|)
for|for
control|(
name|k
operator|=
name|s
operator|+
literal|1
init|;
name|k
operator|<
name|PARSE_DELTA
condition|;
name|k
operator|++
control|)
block|{
comment|/* Yes - it's slow sort */
if|if
condition|(
name|delta
index|[
name|s
index|]
operator|>
name|delta
index|[
name|k
index|]
condition|)
block|{
specifier|register
name|LONG
name|tmp
decl_stmt|;
name|tmp
operator|=
name|delta
index|[
name|k
index|]
expr_stmt|;
name|delta
index|[
name|k
index|]
operator|=
name|delta
index|[
name|s
index|]
expr_stmt|;
name|delta
index|[
name|s
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|PARSE_DELTA
expr_stmt|;
comment|/*        * you know this median loop if you have read the other code        */
while|while
condition|(
operator|(
name|n
operator|-
name|i
operator|)
operator|>
literal|8
condition|)
block|{
specifier|register
name|LONG
name|top
init|=
name|delta
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
specifier|register
name|LONG
name|mid
init|=
name|delta
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|>>
literal|1
index|]
decl_stmt|;
specifier|register
name|LONG
name|low
init|=
name|delta
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|top
operator|-
name|mid
operator|)
operator|>
operator|(
name|mid
operator|-
name|low
operator|)
condition|)
block|{
comment|/* 	       * cut off high end 	       */
name|n
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 	       * cut off low end 	       */
name|i
operator|++
expr_stmt|;
block|}
block|}
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_usecdisp
operator|=
name|delta
index|[
name|n
operator|-
literal|1
index|]
operator|-
name|delta
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_flags
operator|&
name|PARSE_STAT_AVG
condition|)
block|{
comment|/* 	   * take the average of the median samples as this clock 	   * is a little bumpy 	   */
name|mean
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|mean
operator|+=
name|delta
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
name|mean
operator|>>=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|mean
operator|=
name|delta
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|>>
literal|1
index|]
expr_stmt|;
block|}
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_usecerror
operator|=
name|mean
expr_stmt|;
block|}
else|else
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_usecerror
operator|=
name|usecoff
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_usecdisp
operator|=
literal|0
expr_stmt|;
block|}
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: updatetimeinfo: T=%x+%d usec, useccoff=%d, usecerror=%d, usecdisp=%d\n"
operator|,
name|t
operator|,
name|usec
operator|,
name|usecoff
operator|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_usecerror
operator|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_usecdisp
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|parseio
operator|->
name|parse_lstate
operator|=
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||
name|flags
operator||
name|PARSEB_TIMECODE
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator|=
name|parseio
operator|->
name|parse_lstate
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|CVT_OK
return|;
comment|/* everything fine and dandy... */
block|}
end_function

begin_comment
comment|/*  * syn_simple  *  * handle a sync time stamp  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|syn_simple
parameter_list|(
name|parseio
parameter_list|,
name|ts
parameter_list|,
name|format
parameter_list|,
name|why
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ts
decl_stmt|;
specifier|register
name|struct
name|format
modifier|*
name|format
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|why
decl_stmt|;
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ts
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pps_simple  *  * handle a pps time stamp  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|unsigned
name|LONG
name|pps_simple
parameter_list|(
name|parseio
parameter_list|,
name|status
parameter_list|,
name|ptime
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|timestamp_t
modifier|*
name|ptime
decl_stmt|;
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_ptime
operator|=
operator|*
name|ptime
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * timepacket  *  * process a data packet  */
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|timepacket
parameter_list|(
name|parseio
parameter_list|)
specifier|register
name|parse_t
modifier|*
name|parseio
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|unsigned
name|short
name|format
decl_stmt|;
specifier|register
name|time_t
name|t
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|cvtsum
init|=
literal|0
decl_stmt|;
comment|/* accumulated CVT_FAIL errors */
name|unsigned
name|LONG
name|cvtrtc
decl_stmt|;
comment|/* current conversion result */
name|clocktime_t
name|clock
decl_stmt|;
name|format
operator|=
name|parseio
operator|->
name|parse_lformat
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_flags
operator|&
name|PARSE_FIXED_FMT
condition|)
block|{
switch|switch
condition|(
operator|(
name|cvtrtc
operator|=
name|clockformats
index|[
name|format
index|]
operator|->
name|convert
condition|?
name|clockformats
index|[
name|format
index|]
operator|->
name|convert
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_index
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|data
argument_list|,
operator|&
name|clock
argument_list|)
else|:
name|CVT_NONE
operator|)
operator|&
name|CVT_MASK
condition|)
block|{
case|case
name|CVT_FAIL
case|:
name|parseio
operator|->
name|parse_badformat
operator|++
expr_stmt|;
name|cvtsum
operator|=
name|cvtrtc
operator|&
operator|~
name|CVT_MASK
expr_stmt|;
comment|/* 	   * may be too often ... but is nice to know when it happens 	   */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: \"%s\" failed to convert\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: \"%s\" failed to convert\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CVT_NONE
case|:
comment|/* 	   * too bad - pretend bad format 	   */
name|parseio
operator|->
name|parse_badformat
operator|++
expr_stmt|;
name|cvtsum
operator|=
name|CVT_BADFMT
expr_stmt|;
break|break;
case|case
name|CVT_OK
case|:
name|k
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* shouldn't happen */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: INTERNAL error: bad return code of convert routine \"%s\"\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: INTERNAL error: bad return code of convert routine \"%s\"\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|cvtrtc
return|;
block|}
block|}
else|else
block|{
comment|/*        * find correct conversion routine        * and convert time packet        * RR search starting at last successful conversion routine        */
if|if
condition|(
name|nformats
condition|)
comment|/* very careful ... */
block|{
do|do
block|{
switch|switch
condition|(
operator|(
name|cvtrtc
operator|=
operator|(
name|clockformats
index|[
name|format
index|]
operator|->
name|convert
operator|&&
operator|!
operator|(
name|clockformats
index|[
name|format
index|]
operator|->
name|flags
operator|&
name|CVT_FIXEDONLY
operator|)
operator|)
condition|?
name|clockformats
index|[
name|format
index|]
operator|->
name|convert
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
name|parseio
operator|->
name|parse_index
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|data
argument_list|,
operator|&
name|clock
argument_list|)
else|:
name|CVT_NONE
operator|)
operator|&
name|CVT_MASK
condition|)
block|{
case|case
name|CVT_FAIL
case|:
name|parseio
operator|->
name|parse_badformat
operator|++
expr_stmt|;
name|cvtsum
operator||=
name|cvtrtc
operator|&
operator|~
name|CVT_MASK
expr_stmt|;
comment|/* 		   * may be too often ... but is nice to know when it happens 		   */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: \"%s\" failed to convert\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: \"%s\" failed to convert\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*FALLTHROUGH*/
case|case
name|CVT_NONE
case|:
name|format
operator|++
expr_stmt|;
break|break;
case|case
name|CVT_OK
case|:
name|k
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* shouldn't happen */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: INTERNAL error: bad return code of convert routine \"%s\"\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: INTERNAL error: bad return code of convert routine \"%s\"\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_BADFMT
return|;
block|}
if|if
condition|(
name|format
operator|>=
name|nformats
condition|)
name|format
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|k
operator|&&
operator|(
name|format
operator|!=
name|parseio
operator|->
name|parse_lformat
operator|)
condition|)
do|;
block|}
block|}
if|if
condition|(
operator|!
name|k
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: time format \"%s\" not convertable\n"
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: time format \"%s\" not convertable\n"
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|cvtsum
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|=
name|parse_to_unixtime
argument_list|(
operator|&
name|clock
argument_list|,
operator|&
name|cvtrtc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|printf
argument_list|(
literal|"parse: bad time format \"%s\"\n"
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: bad time format \"%s\"\n"
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|cvtrtc
return|;
block|}
name|parseio
operator|->
name|parse_lformat
operator|=
name|format
expr_stmt|;
comment|/*    * time stamp    */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
operator|=
name|t
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_usec
operator|=
name|clock
operator|.
name|usecond
expr_stmt|;
else|#
directive|else
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|=
name|t
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|clock
operator|.
name|usecond
argument_list|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_uf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_format
operator|=
name|format
expr_stmt|;
return|return
name|updatetimeinfo
argument_list|(
name|parseio
argument_list|,
name|t
argument_list|,
name|clock
operator|.
name|usecond
argument_list|,
name|clock
operator|.
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * control operations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_getstat
parameter_list|(
name|dct
parameter_list|,
name|parse
parameter_list|)
name|parsectl_t
modifier|*
name|dct
decl_stmt|;
name|parse_t
modifier|*
name|parse
decl_stmt|;
block|{
name|dct
operator|->
name|parsestatus
operator|.
name|flags
operator|=
name|parse
operator|->
name|parse_flags
operator|&
name|PARSE_STAT_FLAGS
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_setstat
parameter_list|(
name|dct
parameter_list|,
name|parse
parameter_list|)
name|parsectl_t
modifier|*
name|dct
decl_stmt|;
name|parse_t
modifier|*
name|parse
decl_stmt|;
block|{
name|parse
operator|->
name|parse_flags
operator|=
operator|(
name|parse
operator|->
name|parse_flags
operator|&
operator|~
name|PARSE_STAT_FLAGS
operator|)
operator||
name|dct
operator|->
name|parsestatus
operator|.
name|flags
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_timecode
parameter_list|(
name|dct
parameter_list|,
name|parse
parameter_list|)
name|parsectl_t
modifier|*
name|dct
decl_stmt|;
name|parse_t
modifier|*
name|parse
decl_stmt|;
block|{
name|dct
operator|->
name|parsegettc
operator|.
name|parse_state
operator|=
name|parse
operator|->
name|parse_lstate
expr_stmt|;
name|dct
operator|->
name|parsegettc
operator|.
name|parse_format
operator|=
name|parse
operator|->
name|parse_lformat
expr_stmt|;
comment|/*    * move out current bad packet count    * user program is expected to sum these up    * this is not a problem, as "parse" module are    * exclusive open only    */
name|dct
operator|->
name|parsegettc
operator|.
name|parse_badformat
operator|=
name|parse
operator|->
name|parse_badformat
expr_stmt|;
name|parse
operator|->
name|parse_badformat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_ldsize
operator|<=
name|PARSE_TCMAX
condition|)
block|{
name|dct
operator|->
name|parsegettc
operator|.
name|parse_count
operator|=
name|parse
operator|->
name|parse_ldsize
expr_stmt|;
name|bcopy
argument_list|(
name|parse
operator|->
name|parse_ldata
argument_list|,
name|dct
operator|->
name|parsegettc
operator|.
name|parse_buffer
argument_list|,
name|dct
operator|->
name|parsegettc
operator|.
name|parse_count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_setfmt
parameter_list|(
name|dct
parameter_list|,
name|parse
parameter_list|)
name|parsectl_t
modifier|*
name|dct
decl_stmt|;
name|parse_t
modifier|*
name|parse
decl_stmt|;
block|{
if|if
condition|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
operator|<=
name|PARSE_TCMAX
condition|)
block|{
if|if
condition|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
condition|)
block|{
specifier|register
name|unsigned
name|short
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nformats
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Strcmp
argument_list|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|clockformats
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
block|{
name|parse
operator|->
name|parse_lformat
operator|=
name|i
expr_stmt|;
name|parse
operator|->
name|parse_flags
operator||=
name|PARSE_FIXED_FMT
expr_stmt|;
comment|/* set fixed format indication */
return|return
name|setup_bitmaps
argument_list|(
name|parse
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
name|parse
operator|->
name|parse_flags
operator|&=
operator|~
name|PARSE_FIXED_FMT
expr_stmt|;
comment|/* clear fixed format indication */
return|return
name|setup_bitmaps
argument_list|(
name|parse
argument_list|,
literal|0
argument_list|,
name|nformats
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_getfmt
parameter_list|(
name|dct
parameter_list|,
name|parse
parameter_list|)
name|parsectl_t
modifier|*
name|dct
decl_stmt|;
name|parse_t
modifier|*
name|parse
decl_stmt|;
block|{
if|if
condition|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
operator|<
name|nformats
operator|&&
name|Strlen
argument_list|(
name|clockformats
index|[
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
index|]
operator|->
name|name
argument_list|)
operator|<=
name|PARSE_TCMAX
condition|)
block|{
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
operator|=
name|Strlen
argument_list|(
name|clockformats
index|[
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
index|]
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|clockformats
index|[
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
index|]
operator|->
name|name
argument_list|,
name|dct
operator|->
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_setcs
parameter_list|(
name|dct
parameter_list|,
name|parse
parameter_list|)
name|parsectl_t
modifier|*
name|dct
decl_stmt|;
name|parse_t
modifier|*
name|parse
decl_stmt|;
block|{
name|parse
operator|->
name|parse_ioflags
operator|&=
operator|~
name|PARSE_IO_CSIZE
expr_stmt|;
name|parse
operator|->
name|parse_ioflags
operator||=
name|dct
operator|->
name|parsesetcs
operator|.
name|parse_cs
operator|&
name|PARSE_IO_CSIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(REFCLOCK)&& defined(PARSE) */
end_comment

begin_comment
comment|/*  * History:  *  * parse.c,v  * Revision 3.19  1994/01/25  19:05:20  kardel  * 94/01/23 reconcilation  *  * Revision 3.18  1994/01/23  17:21:59  kardel  * 1994 reconcilation  *  * Revision 3.17  1993/11/11  11:20:29  kardel  * declaration fixes  *  * Revision 3.16  1993/11/06  22:26:07  duwe  * Linux cleanup after config change  *  * Revision 3.15  1993/11/04  11:14:18  kardel  * ansi/K&R traps  *  * Revision 3.14  1993/11/04  10:03:28  kardel  * disarmed ansiism  *  * Revision 3.13  1993/11/01  20:14:13  kardel  * useless comparision removed  *  * Revision 3.12  1993/11/01  20:00:22  kardel  * parse Solaris support (initial version)  *  * Revision 3.11  1993/10/30  09:41:25  kardel  * minor optimizations  *  * Revision 3.10  1993/10/22  14:27:51  kardel  * Oct. 22nd 1993 reconcilation  *  * Revision 3.9  1993/10/05  23:15:09  kardel  * more STREAM protection  *  * Revision 3.8  1993/09/27  21:08:00  kardel  * utcoffset now in seconds  *  * Revision 3.7  1993/09/26  23:40:16  kardel  * new parse driver logic  *  * Revision 3.6  1993/09/07  10:12:46  kardel  * September 7th reconcilation - 3.2 (alpha)  *  * Revision 3.5  1993/09/01  21:44:48  kardel  * conditional cleanup  *  * Revision 3.4  1993/08/27  00:29:39  kardel  * compilation cleanup  *  * Revision 3.3  1993/08/24  22:27:13  kardel  * cleaned up AUTOCONF DCF77 mess 8-) - wasn't too bad  *  * Revision 3.2  1993/07/09  11:37:11  kardel  * Initial restructured version + GPS support  *  * Revision 3.1  1993/07/06  10:00:08  kardel  * DCF77 driver goes generic...  *  */
end_comment

end_unit

