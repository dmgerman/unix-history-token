begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66.  *  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  * 4. The name of the University may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|PPS
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|MX4200
argument_list|)
operator|||
name|defined
argument_list|(
name|MX4200CLK
argument_list|)
operator|||
name|defined
argument_list|(
name|MX4200PPS
argument_list|)
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) /src/master/xntp-930612/xntpd/refclock_mx4200.c,v 1.5 1993/06/18 21:19:54 jbj Exp (LBL) "
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MX4200CLK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/clkdefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MX4200CLK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_include
include|#
directive|include
file|"mx4200.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * This driver supports the Magnavox Model MX4200 GPS Receiver.  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|2
end_define

begin_comment
comment|/* max number of mx4200 units */
end_comment

begin_define
define|#
directive|define
name|MX4200232
value|"/dev/gps%d"
end_define

begin_define
define|#
directive|define
name|SPEED232
value|B4800
end_define

begin_comment
comment|/* baud */
end_comment

begin_comment
comment|/*  * The number of raw samples which we acquire to derive a single estimate.  */
end_comment

begin_define
define|#
directive|define
name|NSTAMPS
value|64
end_define

begin_comment
comment|/*  * Radio interface parameters  */
end_comment

begin_define
define|#
directive|define
name|MX4200PRECISION
value|(-18)
end_define

begin_comment
comment|/* precision assumed (about 4 us) */
end_comment

begin_define
define|#
directive|define
name|MX4200REFID
value|"GPS"
end_define

begin_comment
comment|/* reference id */
end_comment

begin_define
define|#
directive|define
name|MX4200DESCRIPTION
value|"Magnavox MX4200 GPS Receiver"
end_define

begin_comment
comment|/* who we are */
end_comment

begin_define
define|#
directive|define
name|DEFFUDGETIME
value|0
end_define

begin_comment
comment|/* default fudge time (ms) */
end_comment

begin_comment
comment|/* Leap stuff */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|leap_hoursfromleap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|U_LONG
name|leap_happened
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leap_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * mx4200_reset - reset the count back to zero  */
end_comment

begin_define
define|#
directive|define
name|mx4200_reset
parameter_list|(
name|mx4200
parameter_list|)
define|\
value|do { \ 		(mx4200)->nsamples = 0; \ 	} while (0)
end_define

begin_comment
comment|/*  * mx4200_event - record and report an event  */
end_comment

begin_define
define|#
directive|define
name|mx4200_event
parameter_list|(
name|mx4200
parameter_list|,
name|evcode
parameter_list|)
define|\
value|do { \ 		if ((mx4200)->status != (u_char)(evcode)) \ 			mx4200_report_event((mx4200), (evcode)); \ 	} while (0)
end_define

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_loopfilter module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * MX4200 unit control structure.  */
end_comment

begin_struct
struct|struct
name|mx4200unit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* associated peer structure */
name|struct
name|refclockio
name|io
decl_stmt|;
comment|/* given to the I/O handler */
name|U_LONG
name|gpssamples
index|[
name|NSTAMPS
index|]
decl_stmt|;
comment|/* the GPS time samples */
name|l_fp
name|unixsamples
index|[
name|NSTAMPS
index|]
decl_stmt|;
comment|/* the UNIX time samples */
name|l_fp
name|lastsampletime
decl_stmt|;
comment|/* time of last estimate */
name|u_int
name|lastserial
decl_stmt|;
comment|/* last pps serial number */
ifdef|#
directive|ifdef
name|notdef
name|l_fp
name|lastrec
decl_stmt|;
comment|/* last receive time */
name|l_fp
name|lastref
decl_stmt|;
comment|/* last timecode time */
endif|#
directive|endif
name|char
name|lastcode
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
comment|/* last timecode received */
name|U_LONG
name|lasttime
decl_stmt|;
comment|/* last time clock heard from */
name|u_char
name|nsamples
decl_stmt|;
comment|/* number of samples we've collected */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number for this guy */
name|u_char
name|status
decl_stmt|;
comment|/* clock status */
name|u_char
name|lastevent
decl_stmt|;
comment|/* last clock event */
name|u_char
name|reason
decl_stmt|;
comment|/* reason for last abort */
name|u_char
name|lencode
decl_stmt|;
comment|/* length of last timecode */
name|u_char
name|year
decl_stmt|;
comment|/* year of eternity */
name|u_short
name|monthday
decl_stmt|;
comment|/* day of month */
name|u_char
name|hour
decl_stmt|;
comment|/* hour of day */
name|u_char
name|minute
decl_stmt|;
comment|/* minute of hour */
name|u_char
name|second
decl_stmt|;
comment|/* seconds of minute */
name|u_char
name|leap
decl_stmt|;
comment|/* leap indicators */
comment|/* 	 * Status tallies 	 */
ifdef|#
directive|ifdef
name|notdef
name|U_LONG
name|polls
decl_stmt|;
comment|/* polls sent */
name|U_LONG
name|noresponse
decl_stmt|;
comment|/* number of nonresponses */
endif|#
directive|endif
name|U_LONG
name|badformat
decl_stmt|;
comment|/* bad format */
name|U_LONG
name|baddata
decl_stmt|;
comment|/* bad data */
name|U_LONG
name|timestarted
decl_stmt|;
comment|/* time we started this */
block|}
struct|;
end_struct

begin_comment
comment|/*  * We demand that consecutive PPS samples are more than 0.995 seconds  * and less than 1.005 seconds apart.  */
end_comment

begin_define
define|#
directive|define
name|PPSLODIFF_UI
value|0
end_define

begin_comment
comment|/* 0.900 as an l_fp */
end_comment

begin_define
define|#
directive|define
name|PPSLODIFF_UF
value|0xe6666610
end_define

begin_define
define|#
directive|define
name|PPSHIDIFF_UI
value|1
end_define

begin_comment
comment|/* 1.100 as an l_fp */
end_comment

begin_define
define|#
directive|define
name|PPSHIDIFF_UF
value|0x19999990
end_define

begin_comment
comment|/*  * reason codes  */
end_comment

begin_define
define|#
directive|define
name|PPSREASON
value|20
end_define

begin_define
define|#
directive|define
name|CODEREASON
value|40
end_define

begin_define
define|#
directive|define
name|PROCREASON
value|60
end_define

begin_comment
comment|/*  * Data space for the unit structures.  Note that we allocate these on  * the fly, but never give them back.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mx4200unit
modifier|*
name|mx4200units
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|unitinuse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keep the fudge factors separately so they can be set even  * when no clock is configured.  */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|fudgefactor
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|stratumtouse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|sloppyclockflag
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_LONG
name|refid
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pmvxg
index|[]
init|=
literal|"PMVXG"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mx4200_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mx4200_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_process
name|P
argument_list|(
operator|(
expr|struct
name|mx4200unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_report_event
name|P
argument_list|(
operator|(
expr|struct
name|mx4200unit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_control
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_buginfo
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockbug
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mx4200_parse
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|calendar
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mx4200_needconf
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_config
name|P
argument_list|(
operator|(
expr|struct
name|mx4200unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mx4200_send
name|P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mx4200_cmpl_fp
name|P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|cksum
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|opendfile
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|checkdfile
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_mx4200
init|=
block|{
name|mx4200_start
block|,
name|mx4200_shutdown
block|,
name|mx4200_poll
block|,
name|mx4200_control
block|,
name|mx4200_init
block|,
name|mx4200_buginfo
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * mx4200_init - initialize internal mx4200 driver data  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_init
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Just zero the data arrays 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mx4200units
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mx4200units
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unitinuse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|unitinuse
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize fudge factors to default. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
name|fudgefactor
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|fudgefactor
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFFUDGETIME
expr_stmt|;
name|stratumtouse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sloppyclockflag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|refid
index|[
name|i
index|]
argument_list|,
name|MX4200REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|dfile
index|[]
init|=
literal|"/var/tmp/MX4200.debug"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|df
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|opendfile
parameter_list|(
name|create
parameter_list|)
name|int
name|create
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|create
operator|&&
name|access
argument_list|(
name|dfile
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200: open %s: %m"
argument_list|,
name|dfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|df
operator|=
name|fopen
argument_list|(
name|dfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|==
name|NULL
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200: open %s: %m"
argument_list|,
name|dfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|setvbuf
argument_list|(
name|df
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200: setvbuf %s: %m"
argument_list|,
name|dfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checkdfile
parameter_list|()
block|{
if|if
condition|(
name|df
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|access
argument_list|(
name|dfile
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|opendfile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * mx4200_start - open the MX4200 devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|mx4200_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fd232
decl_stmt|;
name|char
name|mx4200dev
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Check configuration info 	 */
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: unit %d in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Open serial port 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mx4200dev
argument_list|,
name|MX4200232
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd232
operator|=
name|open
argument_list|(
name|mx4200dev
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: open of %s: %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
comment|/* 	 * System V serial line parameters (termio interface) 	 * 	 */
block|{
name|struct
name|termio
name|ttyb
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, TCGETA): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyb
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyb
operator|.
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyb
operator|.
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyb
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyb
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, TCSETA): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* 	 * POSIX serial line parameters (termios interface) 	 * 	 * The MX4200CLK option provides timestamping at the driver level. 	 * It requires the tty_clk streams module. 	 * 	 * The MX4200PPS option provides timestamping at the driver level. 	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the ppsclock streams module and SunOS 4.1.1 or 	 * later. 	 */
block|{
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd232
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: tcgetattr(%s): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd232
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: tcsetattr(%s): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd232
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: tcflush(%s): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|STREAM
if|#
directive|if
name|defined
argument_list|(
name|MX4200CLK
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"clk"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, I_PUSH, clk): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|CLK_SETSTR
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, CLK_SETSTR): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MX4200CLK */
if|#
directive|if
name|defined
argument_list|(
name|MX4200PPS
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"ppsclock"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, I_PUSH, ppsclock): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
else|else
name|fdpps
operator|=
name|fd232
expr_stmt|;
endif|#
directive|endif
comment|/* MX4200PPS */
endif|#
directive|endif
comment|/* STREAM */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 * 	 * The MX4200CLK option provides timestamping at the driver level. 	 * It requires the tty_clk line discipline and 4.3bsd or later. 	 */
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MX4200CLK
argument_list|)
name|int
name|ldisc
init|=
name|CLKLDISC
decl_stmt|;
endif|#
directive|endif
comment|/* MX4200CLK */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, TIOCGETP): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|SPEED232
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MX4200CLK
argument_list|)
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
else|#
directive|else
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\0'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
endif|#
directive|endif
comment|/* MX4200CLK */
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, TIOCSETP): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|MX4200CLK
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_start: ioctl(%s, TIOCSETD): %m"
argument_list|,
name|mx4200dev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
endif|#
directive|endif
comment|/* MX4200CLK */
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
comment|/* 	 * Allocate unit structure 	 */
if|if
condition|(
name|mx4200units
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
block|{
name|mx4200
operator|=
name|mx4200units
index|[
name|unit
index|]
expr_stmt|;
comment|/* The one we want is okay */
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|unitinuse
index|[
name|i
index|]
operator|&&
name|mx4200units
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|MAXUNITS
condition|)
block|{
comment|/* 			 * Reclaim this one 			 */
name|mx4200
operator|=
name|mx4200units
index|[
name|i
index|]
expr_stmt|;
name|mx4200units
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mx4200
operator|=
operator|(
expr|struct
name|mx4200unit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mx4200unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mx4200
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mx4200unit
argument_list|)
argument_list|)
expr_stmt|;
name|mx4200units
index|[
name|unit
index|]
operator|=
name|mx4200
expr_stmt|;
comment|/* 	 * Set up the structures 	 */
name|mx4200
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|mx4200
operator|->
name|unit
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|mx4200
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|mx4200
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|mx4200_receive
expr_stmt|;
name|mx4200
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|mx4200
expr_stmt|;
name|mx4200
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|mx4200
operator|->
name|io
operator|.
name|fd
operator|=
name|fd232
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|mx4200
operator|->
name|io
argument_list|)
condition|)
goto|goto
name|screwed
goto|;
comment|/* 	 * All done.  Initialize a few random peer variables, then 	 * return success. 	 */
name|peer
operator|->
name|precision
operator|=
name|MX4200PRECISION
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|refid
index|[
name|unit
index|]
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Insure the receiver is properly configured */
name|mx4200_config
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|opendfile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Something broke; abandon ship 	 */
name|screwed
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd232
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mx4200_shutdown - shut down a MX4200 clock  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_shutdown
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_shutdown: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_shutdown: unit %d not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tell the I/O module to turn us off.  We're history. 	 */
name|mx4200
operator|=
name|mx4200units
index|[
name|unit
index|]
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|mx4200
operator|->
name|io
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mx4200_config
parameter_list|(
name|mx4200
parameter_list|)
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
block|{
specifier|register
name|int
name|fd
init|=
name|mx4200
operator|->
name|io
operator|.
name|fd
decl_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"mx4200_config"
argument_list|)
expr_stmt|;
comment|/* Zero the output list (do it twice to flush possible junk) */
name|mx4200_send
argument_list|(
name|fd
argument_list|,
literal|"%s,%03d,,%d,,,,,,"
argument_list|,
name|pmvxg
argument_list|,
name|PMVXG_S_PORTCONF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mx4200_send
argument_list|(
name|fd
argument_list|,
literal|"%s,%03d,,%d,,,,,,"
argument_list|,
name|pmvxg
argument_list|,
name|PMVXG_S_PORTCONF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Switch to 2d mode */
name|mx4200_send
argument_list|(
name|fd
argument_list|,
literal|"%s,%03d,%d,,%.1f,%.1f,,%d,%d,%c,%d"
argument_list|,
name|pmvxg
argument_list|,
name|PMVXG_S_INITMODEB
argument_list|,
literal|2
argument_list|,
comment|/* 2d mode */
literal|0.1
argument_list|,
comment|/* hor accel fact as per Steve */
literal|0.1
argument_list|,
comment|/* ver accel fact as per Steve */
literal|10
argument_list|,
comment|/* hdop limit as per Steve */
literal|5
argument_list|,
comment|/* elevation limit as per Steve */
literal|'U'
argument_list|,
comment|/* time output mode */
literal|0
argument_list|)
expr_stmt|;
comment|/* local time offset from gmt */
comment|/* Configure time recovery */
name|mx4200_send
argument_list|(
name|fd
argument_list|,
literal|"%s,%03d,%c,%c,%c,%d,%d,%d,"
argument_list|,
name|pmvxg
argument_list|,
name|PMVXG_S_TRECOVCONF
argument_list|,
ifdef|#
directive|ifdef
name|notdef
literal|'K'
argument_list|,
comment|/* known position */
literal|'D'
argument_list|,
comment|/* dynamic position */
else|#
directive|else
literal|'S'
argument_list|,
comment|/* static position */
endif|#
directive|endif
literal|'U'
argument_list|,
comment|/* steer clock to gps time */
literal|'A'
argument_list|,
comment|/* always output time pulse */
literal|500
argument_list|,
comment|/* max time error in ns */
literal|0
argument_list|,
comment|/* user bias in ns */
literal|1
argument_list|)
expr_stmt|;
comment|/* output to control port */
block|}
end_function

begin_comment
comment|/*  * mx4200_report_event - note the occurrence of an event  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_report_event
parameter_list|(
name|mx4200
parameter_list|,
name|code
parameter_list|)
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|peer
operator|=
name|mx4200
operator|->
name|peer
expr_stmt|;
if|if
condition|(
name|mx4200
operator|->
name|status
operator|!=
operator|(
name|u_char
operator|)
name|code
condition|)
block|{
name|mx4200
operator|->
name|status
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|CEVNT_NOMINAL
condition|)
name|mx4200
operator|->
name|lastevent
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"mx4200 clock %s event %x"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mx4200_poll - mx4200 watchdog routine  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_poll: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_poll: unit %d not used"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|mx4200
operator|=
name|mx4200units
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|current_time
operator|-
name|mx4200
operator|->
name|lasttime
operator|)
operator|>
literal|150
condition|)
block|{
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
comment|/* Request a status message which should trigger a reconfig */
name|mx4200_send
argument_list|(
name|mx4200
operator|->
name|io
operator|.
name|fd
argument_list|,
literal|"%s,%03d"
argument_list|,
literal|"CDGPQ"
argument_list|,
name|PMVXG_D_STATUS
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"mx4200_poll: request status"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|char2hex
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * mx4200_receive - receive gps data  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
specifier|register
name|char
modifier|*
name|dpt
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_ui
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_uf
decl_stmt|;
specifier|register
name|U_LONG
name|gpstime
decl_stmt|;
name|struct
name|ppsclockev
name|ev
decl_stmt|;
specifier|register
name|struct
name|calendar
modifier|*
name|jt
decl_stmt|;
name|struct
name|calendar
name|sjt
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|valid
decl_stmt|,
name|leapsec
decl_stmt|;
specifier|register
name|u_char
name|ck
decl_stmt|;
name|mx4200
operator|=
operator|(
expr|struct
name|mx4200unit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: nsamples = %d\n"
argument_list|,
name|mx4200
operator|->
name|nsamples
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record the time of this event */
name|mx4200
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
comment|/* Get the pps value */
if|if
condition|(
name|ioctl
argument_list|(
name|mx4200
operator|->
name|io
operator|.
name|fd
argument_list|,
name|CIOGETEV
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ev
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* XXX Actually, if this fails, we're pretty much screwed */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mx4200_receive: "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"CIOGETEV"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|1
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp_ui
operator|=
name|ev
operator|.
name|tv
operator|.
name|tv_sec
operator|+
operator|(
name|U_LONG
operator|)
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|ev
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
comment|/* Get buffer and length; sock away last timecode */
name|n
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|dpt
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return;
name|mx4200
operator|->
name|lencode
operator|=
name|n
expr_stmt|;
name|memmove
argument_list|(
name|mx4200
operator|->
name|lastcode
argument_list|,
name|dpt
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * We expect to see something like: 	 * 	 *    $PMVXG,830,T,1992,07,09,04:18:34,U,S,-02154,00019,000000,00*1D\n 	 * 	 * Reject if any important landmarks are missing. 	 */
name|cp
operator|=
name|dpt
operator|+
name|n
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|dpt
operator|||
operator|*
name|dpt
operator|!=
literal|'$'
operator|||
name|cp
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|cp
index|[
literal|3
index|]
operator|!=
literal|'\n'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: bad format\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mx4200
operator|->
name|badformat
operator|++
expr_stmt|;
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|2
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check checksum */
name|ck
operator|=
name|cksum
argument_list|(
operator|&
name|dpt
index|[
literal|1
index|]
argument_list|,
name|n
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|char2hex
index|[
name|ck
operator|>>
literal|4
index|]
operator|!=
name|cp
index|[
literal|1
index|]
operator|||
name|char2hex
index|[
name|ck
operator|&
literal|0xf
index|]
operator|!=
name|cp
index|[
literal|2
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: bad checksum\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mx4200
operator|->
name|badformat
operator|++
expr_stmt|;
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|3
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Truncate checksum (and the buffer for that matter) */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Leap second debugging stuff */
if|if
condition|(
operator|(
name|leap_hoursfromleap
operator|&&
operator|!
name|leap_happened
operator|)
operator|||
name|leap_debug
operator|>
literal|0
condition|)
block|{
comment|/* generate reports for awhile after leap */
if|if
condition|(
name|leap_hoursfromleap
operator|&&
operator|!
name|leap_happened
condition|)
name|leap_debug
operator|=
literal|3600
expr_stmt|;
else|else
operator|--
name|leap_debug
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"mx4200 leap: %s \"%s\""
argument_list|,
name|umfptoa
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
literal|6
argument_list|)
argument_list|,
name|dpt
argument_list|)
expr_stmt|;
block|}
comment|/* Parse time recovery message */
name|jt
operator|=
operator|&
name|sjt
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|mx4200_parse
argument_list|(
name|dpt
argument_list|,
name|jt
argument_list|,
operator|&
name|valid
argument_list|,
operator|&
name|leapsec
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Configure the receiver if necessary */
if|if
condition|(
name|mx4200_needconf
argument_list|(
name|dpt
argument_list|)
condition|)
name|mx4200_config
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: mx4200_parse: %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mx4200
operator|->
name|badformat
operator|++
expr_stmt|;
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|5
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup leap second indicator */
if|if
condition|(
name|leapsec
operator|==
literal|0
condition|)
name|mx4200
operator|->
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
elseif|else
if|if
condition|(
name|leapsec
operator|==
literal|1
condition|)
name|mx4200
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
elseif|else
if|if
condition|(
name|leapsec
operator|==
operator|-
literal|1
condition|)
name|mx4200
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
else|else
name|mx4200
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
comment|/* shouldn't happen */
comment|/* Check parsed time (allow for possible leap seconds) */
if|if
condition|(
name|jt
operator|->
name|second
operator|>=
literal|61
operator|||
name|jt
operator|->
name|minute
operator|>=
literal|60
operator|||
name|jt
operator|->
name|hour
operator|>=
literal|24
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"mx4200_receive: bad time %d:%02d:%02d"
argument_list|,
name|jt
operator|->
name|hour
argument_list|,
name|jt
operator|->
name|minute
argument_list|,
name|jt
operator|->
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|leapsec
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" (leap %+d)"
argument_list|,
name|leapsec
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mx4200
operator|->
name|baddata
operator|++
expr_stmt|;
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|6
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
comment|/* Eat the next pulse which the clock claims will be bad */
name|mx4200
operator|->
name|nsamples
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Check parsed date */
if|if
condition|(
name|jt
operator|->
name|monthday
operator|>
literal|31
operator|||
name|jt
operator|->
name|month
operator|>
literal|12
operator|||
name|jt
operator|->
name|year
operator|<
literal|1900
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: bad date (%d/%d/%d)\n"
argument_list|,
name|jt
operator|->
name|monthday
argument_list|,
name|jt
operator|->
name|month
argument_list|,
name|jt
operator|->
name|year
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mx4200
operator|->
name|baddata
operator|++
expr_stmt|;
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|7
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert to ntp time */
name|gpstime
operator|=
name|caltontp
argument_list|(
name|jt
argument_list|)
expr_stmt|;
comment|/* The gps message describes the *next* pulse; pretend it's this one */
operator|--
name|gpstime
expr_stmt|;
comment|/* Debugging */
ifdef|#
directive|ifdef
name|DEBUG
name|checkdfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
block|{
name|l_fp
name|t
decl_stmt|;
name|t
operator|.
name|l_ui
operator|=
name|gpstime
expr_stmt|;
name|t
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|M_SUB
argument_list|(
name|t
operator|.
name|l_ui
argument_list|,
name|t
operator|.
name|l_uf
argument_list|,
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"%s\t%s"
argument_list|,
name|umfptoa
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
literal|6
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|t
operator|.
name|l_ui
argument_list|,
name|t
operator|.
name|l_uf
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\t(gps: %lu)"
argument_list|,
operator|(
name|u_long
operator|)
name|gpstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|leapsec
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\t(leap sec %+d)"
argument_list|,
name|leapsec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
name|fprintf
argument_list|(
name|df
argument_list|,
literal|"\t(pulse not valid)"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|df
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check pps serial number against last one */
if|if
condition|(
name|mx4200
operator|->
name|lastserial
operator|+
literal|1
operator|!=
name|ev
operator|.
name|serial
operator|&&
name|mx4200
operator|->
name|lastserial
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|ev
operator|.
name|serial
operator|==
name|mx4200
operator|->
name|lastserial
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: no new pps event\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"mx4200_receive: missed %d pps events\n"
argument_list|,
name|ev
operator|.
name|serial
operator|-
name|mx4200
operator|->
name|lastserial
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|8
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
comment|/* fall through and this one collect as first sample */
block|}
name|mx4200
operator|->
name|lastserial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
comment|/*  * XXX  * Since this message is for the next pulse, it's really the next pulse  * that the clock might be telling us will be invalid.  */
comment|/* Toss if not designated "valid" by the gps */
if|if
condition|(
operator|!
name|valid
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mx4200_receive: pps not valid\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mx4200
operator|->
name|reason
operator|=
name|PPSREASON
operator|+
literal|9
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy time into mx4200unit struct */
comment|/* XXX (why?) */
name|mx4200
operator|->
name|year
operator|=
name|jt
operator|->
name|year
expr_stmt|;
name|mx4200
operator|->
name|monthday
operator|=
name|jt
operator|->
name|monthday
expr_stmt|;
name|mx4200
operator|->
name|hour
operator|=
name|jt
operator|->
name|hour
expr_stmt|;
name|mx4200
operator|->
name|minute
operator|=
name|jt
operator|->
name|minute
expr_stmt|;
name|mx4200
operator|->
name|second
operator|=
name|jt
operator|->
name|second
expr_stmt|;
comment|/* Sock away the GPS and UNIX timesamples */
name|n
operator|=
name|mx4200
operator|->
name|nsamples
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return;
comment|/* oops, this pulse is bad */
name|mx4200
operator|->
name|gpssamples
index|[
name|n
index|]
operator|=
name|gpstime
expr_stmt|;
name|mx4200
operator|->
name|unixsamples
index|[
name|n
index|]
operator|.
name|l_ui
operator|=
name|mx4200
operator|->
name|lastsampletime
operator|.
name|l_ui
operator|=
name|tmp_ui
expr_stmt|;
name|mx4200
operator|->
name|unixsamples
index|[
name|n
index|]
operator|.
name|l_uf
operator|=
name|mx4200
operator|->
name|lastsampletime
operator|.
name|l_uf
operator|=
name|tmp_uf
expr_stmt|;
if|if
condition|(
name|mx4200
operator|->
name|nsamples
operator|>=
name|NSTAMPS
condition|)
block|{
comment|/* 		 * Here we've managed to complete an entire NSTAMPS 		 * second cycle without major mishap. Process what has 		 * been received. 		 */
name|mx4200_process
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
name|mx4200_reset
argument_list|(
name|mx4200
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two l_fp's, used with qsort() */
end_comment

begin_function
specifier|static
name|int
name|mx4200_cmpl_fp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|register
name|void
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|L_ISGEQ
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|l_fp
operator|*
operator|)
name|p2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|l_fp
operator|*
operator|)
name|p2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mx4200_process - process a pile of samples from the clock  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_process
parameter_list|(
name|mx4200
parameter_list|)
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|l_fp
modifier|*
name|fp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
specifier|register
name|U_LONG
modifier|*
name|lp
decl_stmt|;
name|l_fp
name|off
index|[
name|NSTAMPS
index|]
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_ui
decl_stmt|,
name|tmp_uf
decl_stmt|;
specifier|register
name|U_LONG
name|date_ui
decl_stmt|,
name|date_uf
decl_stmt|;
name|u_fp
name|dispersion
decl_stmt|;
comment|/* Compute offsets from the raw data. */
name|fp
operator|=
name|mx4200
operator|->
name|unixsamples
expr_stmt|;
name|op
operator|=
name|off
expr_stmt|;
name|lp
operator|=
name|mx4200
operator|->
name|gpssamples
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSTAMPS
condition|;
operator|++
name|i
operator|,
operator|++
name|lp
operator|,
operator|++
name|op
operator|,
operator|++
name|fp
control|)
block|{
name|op
operator|->
name|l_ui
operator|=
operator|*
name|lp
expr_stmt|;
name|op
operator|->
name|l_uf
operator|=
literal|0
expr_stmt|;
name|L_SUB
argument_list|(
name|op
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Sort offsets into ascending order. */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|off
argument_list|,
name|NSTAMPS
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|,
name|mx4200_cmpl_fp
argument_list|)
expr_stmt|;
comment|/* 	 * Reject the furthest from the median until 8 samples left 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|NSTAMPS
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|-
name|i
operator|)
operator|>
literal|8
condition|)
block|{
name|tmp_ui
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_uf
expr_stmt|;
name|date_ui
operator|=
name|off
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
index|]
operator|.
name|l_ui
expr_stmt|;
name|date_uf
operator|=
name|off
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
index|]
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|date_ui
argument_list|,
name|date_uf
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|date_ui
argument_list|,
name|date_uf
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISHIS
argument_list|(
name|date_ui
argument_list|,
name|date_uf
argument_list|,
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
condition|)
block|{
comment|/* 			 * reject low end 			 */
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * reject high end 			 */
name|n
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Compute the dispersion based on the difference between the 	 * extremes of the remaining offsets. 	 */
name|tmp_ui
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|l_uf
expr_stmt|;
name|M_SUB
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|dispersion
operator|=
name|MFPTOFP
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
comment|/* 	 * Now compute the offset estimate.  If the sloppy clock 	 * flag is set, average the remainder, otherwise pick the 	 * median. 	 */
if|if
condition|(
name|sloppyclockflag
index|[
name|mx4200
operator|->
name|unit
index|]
condition|)
block|{
name|tmp_ui
operator|=
name|tmp_uf
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|M_ADD
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|M_RSHIFT
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|.
name|l_ui
operator|=
name|tmp_ui
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|.
name|l_uf
operator|=
name|tmp_uf
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
expr_stmt|;
block|}
comment|/* 	 * Add the default MX4200 QT delay into this. 	 */
ifdef|#
directive|ifdef
name|notdef
name|L_ADDUF
argument_list|(
operator|&
name|off
index|[
name|i
index|]
argument_list|,
name|MX4200QTFUDGE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Done.  Use lastref as the reference time and lastrec 	 * as the receive time. ** note this can result in tossing 	 * out the peer in the protocol module if lastref> lastrec, 	 * so last rec is used for both values - dlm *** 	 */
name|refclock_receive
argument_list|(
name|mx4200
operator|->
name|peer
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|,
operator|(
name|s_fp
operator|)
literal|0
argument_list|,
comment|/* delay */
name|dispersion
argument_list|,
operator|&
name|mx4200
operator|->
name|unixsamples
index|[
name|NSTAMPS
operator|-
literal|1
index|]
argument_list|,
comment|/* reftime */
operator|&
name|mx4200
operator|->
name|unixsamples
index|[
name|NSTAMPS
operator|-
literal|1
index|]
argument_list|,
comment|/* rectime */
name|mx4200
operator|->
name|leap
argument_list|)
expr_stmt|;
name|mx4200_event
argument_list|(
name|mx4200
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mx4200_control - set fudge factors, return statistics  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_control
parameter_list|(
name|unit
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|in
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_control: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|fudgefactor
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
name|stratumtouse
index|[
name|unit
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|->
name|fudgeval1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
condition|)
name|refid
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgeval2
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG1
condition|)
name|sloppyclockflag
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG1
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|peer
operator|=
name|mx4200units
index|[
name|unit
index|]
operator|->
name|peer
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|refid
index|[
name|unit
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refclockstat
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|REFCLK_GPS_MX4200
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
operator||
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
operator||
name|CLK_HAVEFLAG1
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|MX4200DESCRIPTION
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|fudgefactor
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
operator|(
name|LONG
operator|)
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
name|refid
index|[
name|unit
index|]
expr_stmt|;
empty_stmt|;
name|out
operator|->
name|flags
operator|=
name|sloppyclockflag
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|mx4200
operator|=
name|mx4200units
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
name|mx4200
operator|->
name|lencode
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
name|mx4200
operator|->
name|lastcode
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|mx4200
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|mx4200
operator|->
name|status
expr_stmt|;
name|out
operator|->
name|polls
operator|=
literal|0
expr_stmt|;
comment|/* mx4200->polls; */
name|out
operator|->
name|noresponse
operator|=
literal|0
expr_stmt|;
comment|/* mx4200->noresponse; */
name|out
operator|->
name|badformat
operator|=
name|mx4200
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|mx4200
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|mx4200
operator|->
name|timestarted
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * mx4200_buginfo - return clock dependent debugging info  */
end_comment

begin_function
specifier|static
name|void
name|mx4200_buginfo
parameter_list|(
name|unit
parameter_list|,
name|bug
parameter_list|)
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|refclockbug
modifier|*
name|bug
decl_stmt|;
block|{
specifier|register
name|struct
name|mx4200unit
modifier|*
name|mx4200
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_buginfo: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
return|return;
name|mx4200
operator|=
name|mx4200units
index|[
name|unit
index|]
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bug
argument_list|)
argument_list|)
expr_stmt|;
name|bug
operator|->
name|nvalues
operator|=
literal|10
expr_stmt|;
name|bug
operator|->
name|ntimes
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mx4200
operator|->
name|lasttime
operator|!=
literal|0
condition|)
name|bug
operator|->
name|values
index|[
literal|0
index|]
operator|=
name|current_time
operator|-
name|mx4200
operator|->
name|lasttime
expr_stmt|;
else|else
name|bug
operator|->
name|values
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|1
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|mx4200
operator|->
name|reason
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|2
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|mx4200
operator|->
name|year
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|3
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|mx4200
operator|->
name|monthday
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|4
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|mx4200
operator|->
name|hour
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|5
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|mx4200
operator|->
name|minute
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|6
index|]
operator|=
operator|(
name|U_LONG
operator|)
name|mx4200
operator|->
name|second
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|bug
operator|->
name|values
index|[
literal|7
index|]
operator|=
name|mx4200
operator|->
name|msec
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|8
index|]
operator|=
name|mx4200
operator|->
name|noreply
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|9
index|]
operator|=
name|mx4200
operator|->
name|yearstart
expr_stmt|;
endif|#
directive|endif
name|bug
operator|->
name|stimes
operator|=
literal|0x1c
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|bug
operator|->
name|times
index|[
literal|0
index|]
operator|=
name|mx4200
operator|->
name|lastref
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|1
index|]
operator|=
name|mx4200
operator|->
name|lastrec
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns true if the this is a status message. We use this as  * an indication that the receiver needs to be initialized.  */
end_comment

begin_function
specifier|static
name|int
name|mx4200_needconf
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|LONG
name|v
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Record type */
name|v
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|PMVXG_D_STATUS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX 	 * Since we configure the receiver to not give us status 	 * messages and since the receiver outputs status messages by 	 * default after being reset to factory defaults when sent the 	 * "$PMVXG,018,C\r\n" message, any status message we get 	 * indicates the reciever needs to be initialized; thus, it is 	 * not necessary to decode the status message. 	 */
ifdef|#
directive|ifdef
name|notdef
operator|++
name|cp
expr_stmt|;
comment|/* Receiver status */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Number of satellites which should be visible */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Number of satellites being tracked */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Time since last NAV */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Initialization status */
name|v
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a mx4200 time recovery message. Returns a string if error */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mx4200_parse
parameter_list|(
name|buf
parameter_list|,
name|jt
parameter_list|,
name|validp
parameter_list|,
name|leapsecp
parameter_list|)
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|struct
name|calendar
modifier|*
name|jt
decl_stmt|;
specifier|register
name|int
modifier|*
name|validp
decl_stmt|,
decl|*
name|leapsecp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|LONG
name|v
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|jt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|jt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"no rec-type"
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Record type */
name|v
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|PMVXG_D_TRECOVOUT
condition|)
return|return
operator|(
literal|"wrong rec-type"
operator|)
return|;
comment|/* Pulse valid indicator */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
return|return
operator|(
literal|"no pulse-valid"
operator|)
return|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'T'
condition|)
operator|*
name|validp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'F'
condition|)
operator|*
name|validp
operator|=
literal|0
expr_stmt|;
else|else
return|return
operator|(
literal|"bad pulse-valid"
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Year */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
return|return
operator|(
literal|"no year"
operator|)
return|;
name|jt
operator|->
name|year
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Month of year */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
return|return
operator|(
literal|"no month"
operator|)
return|;
name|jt
operator|->
name|month
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Day of month */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
return|return
operator|(
literal|"no month day"
operator|)
return|;
name|jt
operator|->
name|monthday
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Hour */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
condition|)
return|return
operator|(
literal|"no hour"
operator|)
return|;
name|jt
operator|->
name|hour
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Minute */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
condition|)
return|return
operator|(
literal|"no minute"
operator|)
return|;
name|jt
operator|->
name|minute
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Second */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
condition|)
return|return
operator|(
literal|"no second"
operator|)
return|;
name|jt
operator|->
name|second
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Time indicator */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
operator|||
operator|*
name|cp
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|"no time indicator"
operator|)
return|;
comment|/* Time recovery mode */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|','
operator|||
operator|*
name|cp
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|"no time mode"
operator|)
return|;
comment|/* Oscillator offset */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"no osc off"
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Time mark error */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"no time mark err"
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* User time bias */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"no user bias"
operator|)
return|;
operator|++
name|cp
expr_stmt|;
comment|/* Leap second flag */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"no leap"
operator|)
return|;
operator|++
name|cp
expr_stmt|;
operator|*
name|leapsecp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Calculate the checksum */
end_comment

begin_function
specifier|static
name|u_char
name|cksum
parameter_list|(
name|cp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_int
name|n
decl_stmt|;
block|{
specifier|register
name|u_char
name|ck
decl_stmt|;
for|for
control|(
name|ck
operator|=
literal|0
init|;
name|n
operator|--
operator|>
literal|0
condition|;
operator|++
name|cp
control|)
name|ck
operator|^=
operator|*
name|cp
expr_stmt|;
return|return
operator|(
name|ck
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
if|#
directive|if
name|__STDC__
name|mx4200_send
parameter_list|(
specifier|register
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|mx4200_send
parameter_list|(
name|fd
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|u_char
name|ck
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|buf
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'$'
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* BSD is rational */
name|n
operator|=
name|vsnprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SunOS sucks */
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|cp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ck
operator|=
name|cksum
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
operator|++
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* BSD is rational */
name|n
operator|+=
name|snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
operator|-
literal|5
argument_list|,
literal|"*%02X\r\n"
argument_list|,
name|ck
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SunOS sucks */
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"*%02X\r\n"
argument_list|,
name|ck
argument_list|)
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_send: write: %m (%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|!=
name|n
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mx4200_send: write: %d != %d (%s)"
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

