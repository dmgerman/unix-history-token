begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_trak - clock driver for the TRAK 8820 GPS Station Clock  *  * Thanks to Tomoaki TSURUOKA<tsuruoka@nc.fukuoka-u.ac.jp> for the  * previous version from which this one was developed.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * This driver supports the TRAK 8820 GPS Station Clock. The claimed  * accuracy at the 1-pps output is 200-300 ns relative to the broadcast  * signal; however, in most cases the actual accuracy is limited by the  * precision of the timecode and the latencies of the serial interface  * and operating system.  *  * For best accuracy, this radio requires the LDISC_ACTS line  * discipline, which captures a timestamp at the '*' on-time character  * of the timecode. Using this discipline the jitter is in the order of  * 1 ms and systematic error about 0.5 ms. If unavailable, the buffer  * timestamp is used, which is captured at the \r ending the timecode  * message. This introduces a systematic error of 23 character times, or  * about 24 ms at 9600 bps, together with a jitter well over 8 ms on Sun  * IPC-class machines.  *  * Using the memus, the radio should be set for 9600 bps, one stop bit  * and no parity. It should be set to operate in computer (no echo)  * mode. The timecode format includes neither the year nor leap-second  * warning. No provisions are included in this preliminary version of  * the driver to read and record detailed internal radio status.  *  * In operation, this driver sends a RQTS\r request to the radio at  * initialization in order to put it in continuous time output mode. The  * radio then sends the following message once each second:  *  *	*RQTS U,ddd:hh:mm:ss.0,q<cr><lf>  *  *	on-time = '*'
comment|*	ddd = day of year  *	hh:mm:ss = hours, minutes, seconds  *	q = quality indicator (phase error), 0-6:  * 		0> 20 us  *		6> 10 us  *		5> 1 us  *		4> 100 ns  *		3> 10 ns  *		2< 10 ns  *  * The alarm condition is indicated by '0' at Q, which means the radio  * has a phase error than 20 usec relative to the broadcast time. The  * absence of year, DST and leap-second warning in this format is also  * alarming.  *  * The continuous time mode is disabled using the RQTX<cr> request,  * following which the radio sends a RQTX DONE<cr><lf> response. In the  * normal mode, other control and status requests are effective,  * including the leap-second status request RQLS<cr>. The radio responds  * wtih RQLS yy,mm,dd<cr><lf>, where yy,mm,dd are the year, month and  * day. Presumably, this gives the epoch of the next leap second,  * RQLS 00,00,00 if none is specified in the GPS message. Specified in  * this form, the information is generally useless and is ignored by  * the driver.  *  * Fudge Factors  *  * There are no special fudge factors other than the generic.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/trak%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B9600
end_define

begin_comment
comment|/* uart speed (9600 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"TRAK"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"TRACK 8810/8820 Station Clock"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|NSAMPLES
value|3
end_define

begin_comment
comment|/* stages of median filter */
end_comment

begin_define
define|#
directive|define
name|LENTRAK
value|24
end_define

begin_comment
comment|/* timecode length */
end_comment

begin_define
define|#
directive|define
name|C_CTO
value|"RQTS\r"
end_define

begin_comment
comment|/* start continuous time output */
end_comment

begin_comment
comment|/*  * Imported from ntp_timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time (s) */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|wwvbunit
block|{
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
name|u_char
name|tcswitch
decl_stmt|;
comment|/* timecode switch */
name|char
name|qualchar
decl_stmt|;
comment|/* quality indicator */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trak_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trak_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trak_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trak_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_trak
init|=
block|{
name|trak_start
block|,
comment|/* start up driver */
name|trak_shutdown
block|,
comment|/* shut down driver */
name|trak_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old trak_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old trak_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * trak_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|trak_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|wwvbunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port. The LDISC_ACTS line discipline inserts a 	 * timestamp following the "*" on-time character of the 	 * timecode. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_ACTS
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|wwvbunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wwvbunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wwvbunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|trak_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Start continuous time output. If something breaks, fold the 	 * tent and go home. 	 */
if|if
condition|(
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|C_CTO
argument_list|,
sizeof|sizeof
argument_list|(
name|C_CTO
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|C_CTO
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * trak_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|trak_shutdown
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|wwvbunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvbunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * trak_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|trak_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|wwvbunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|;
name|char
modifier|*
name|dpt
decl_stmt|,
modifier|*
name|dpend
decl_stmt|;
name|char
name|qchar
decl_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp. We 	 * then chuck out everything, including runts, except one 	 * message each poll interval. 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvbunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|tcswitch
operator|||
name|pp
operator|->
name|lencode
operator|<
literal|9
condition|)
return|return;
name|up
operator|->
name|tcswitch
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We get a buffer and timestamp following the '*' on-time 	 * character. If a valid timestamp, we use that in place of the 	 * buffer timestamp and edit out the timestamp for prettyprint 	 * billboards. 	 */
name|dpt
operator|=
name|pp
operator|->
name|lastcode
expr_stmt|;
name|dpend
operator|=
name|dpt
operator|+
name|pp
operator|->
name|lencode
expr_stmt|;
if|if
condition|(
operator|*
name|dpt
operator|==
literal|'*'
operator|&&
name|buftvtots
argument_list|(
name|dpt
operator|+
literal|1
argument_list|,
operator|&
name|trtmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|trtmp
operator|.
name|l_i
operator|==
name|pp
operator|->
name|lastrec
operator|.
name|l_i
operator|||
name|trtmp
operator|.
name|l_i
operator|==
name|pp
operator|->
name|lastrec
operator|.
name|l_i
operator|+
literal|1
condition|)
block|{
name|pp
operator|->
name|lastrec
operator|=
name|trtmp
expr_stmt|;
name|dpt
operator|+=
literal|9
expr_stmt|;
while|while
condition|(
name|dpt
operator|<
name|dpend
condition|)
operator|*
operator|(
name|dpt
operator|-
literal|8
operator|)
operator|=
operator|*
name|dpt
operator|++
expr_stmt|;
block|}
block|}
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"trak: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. If the timecode has invalid length or is not in 	 * proper format, we declare bad format and exit. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|<
name|LENTRAK
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode format: "*RQTS U,ddd:hh:mm:ss.0,q"  	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|lastcode
argument_list|,
literal|"*RQTS U,%3d:%2d:%2d:%2d.0,%c"
argument_list|,
operator|&
name|pp
operator|->
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|qchar
argument_list|)
operator|!=
literal|5
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Decode quality and leap characters. If unsynchronized, set 	 * the leap bits accordingly and exit. 	 */
if|if
condition|(
name|qchar
operator|==
literal|'0'
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
else|else
block|{
name|pp
operator|->
name|leap
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
block|}
comment|/* 	 * Process the new sample in the median filter and determine the 	 * reference clock offset and dispersion. We use lastrec as both 	 * the reference time and receive time in order to avoid being 	 * cute, like setting the reference time later than the receive 	 * time, which may cause a paranoid protocol module to chuck out 	 * the data.  	 */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|,
name|NSAMPLES
argument_list|,
name|NSAMPLES
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|,
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|dispersion
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
name|pp
operator|->
name|leap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * trak_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|trak_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|wwvbunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * We don't really do anything here, except arm the receiving 	 * side to capture a sample and check for timeouts. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|wwvbunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|up
operator|->
name|tcswitch
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

