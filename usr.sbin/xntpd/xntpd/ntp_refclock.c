begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_refclock - processing support for reference clocks  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PPS
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS */
end_comment

begin_comment
comment|/*  * Reference clock support is provided here by maintaining the fiction  * that the clock is actually a peer. As no packets are exchanged with a  * reference clock, however, we replace the transmit, receive and packet  * procedures with separate code to simulate them. Routines  * refclock_transmit() and refclock_receive() maintain the peer  * variables in a state analogous to an actual peer and pass reference  * clock data on through the filters. Routines refclock_peer() and  * refclock_unpeer() are called to initialize and terminate reference  * clock associations. A set of utility routines is included to open  * serial devices, process sample data, edit input lines to extract  * embedded timestamps and to peform various debugging functions.  *  * The main interface used by these routines is the refclockproc  * structure, which contains for most drivers the decimal equivalants of  * the year, day, month, hour, second and millisecond/microsecond  * decoded from the ASCII timecode. Additional information includes the  * receive timestamp, exception report, statistics tallies, etc. In  * addition, there may be a driver-specific unit structure used for  * local control of the device.  *  * The support routines are passed a pointer to the peer structure,  * which is used for all peer-specific processing and contains a pointer  * to the refclockproc structure, which in turn containes a pointer to  * the unit structure, if used. In addition, some routines expect an  * address in the dotted quad form 127.127.t.u, where t is the clock  * type and u the unit. A table typeunit[type][unit] contains the peer  * structure pointer for each configured clock type and unit.  *  * Most drivers support the 1-pps signal provided by some radios and  * connected via a level converted described in the gadget directory.  * The signal is captured using a separate, dedicated serial port and  * the tty_clk line discipline/streams modules described in the kernel  * directory. For the highest precision, the signal is captured using  * the carrier-detect line of the same serial port using the ppsclock  * streams module described in the ppsclock directory.  */
end_comment

begin_define
define|#
directive|define
name|REFCLOCKMAXDISPERSE
value|(FP_SECOND/4)
end_define

begin_comment
comment|/* max sample dispersion */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|4
end_define

begin_comment
comment|/* max units */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CLKLDISC
end_ifndef

begin_define
define|#
directive|define
name|CLKLDISC
value|10
end_define

begin_comment
comment|/* XXX temp tty_clk line discipline */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHULDISC
end_ifndef

begin_define
define|#
directive|define
name|CHULDISC
value|10
end_define

begin_comment
comment|/* XXX temp tty_chu line discipline */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The refclock configuration table. Imported from refclock_conf  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|refclock
modifier|*
name|refclock_conf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|num_refclock_conf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the I/O module  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_loopfilter module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the main and peer modules. We use the same algorithm  * for spacing out timers at configuration time that the peer module  * does.  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|init_peer_starttime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initializing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type/unit peer index. Used to find the peer structure for control and  * debugging. When all clock drivers have been converted to new style,  * this dissapears.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|peer
modifier|*
name|typeunit
index|[
name|REFCLK_MAX
operator|+
literal|1
index|]
index|[
name|MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * refclock_report - note the occurance of an event  *  * This routine presently just remembers the report and logs it, but  * does nothing heroic for the trap handler. It tries to be a good  * citizen and bothers the system log only if things change.  */
end_comment

begin_function
name|void
name|refclock_report
parameter_list|(
name|peer
parameter_list|,
name|code
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_char
name|code
decl_stmt|;
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|=
name|peer
operator|->
name|procptr
operator|)
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|CEVNT_BADREPLY
condition|)
name|pp
operator|->
name|badformat
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_BADTIME
condition|)
name|pp
operator|->
name|baddata
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_TIMEOUT
condition|)
name|pp
operator|->
name|noreply
operator|++
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|currentstatus
operator|!=
name|code
condition|)
block|{
name|pp
operator|->
name|currentstatus
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_NOMINAL
condition|)
return|return;
name|pp
operator|->
name|lastevent
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CEVNT_FAULT
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock %s fault %x"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"clock %s event %x"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * init_refclock - initialize the reference clock drivers  *  * This routine calls each of the drivers in turn to initialize internal  * variables, if necessary. Most drivers have nothing to say at this  * point.  */
end_comment

begin_function
name|void
name|init_refclock
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_refclock_conf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|refclock_conf
index|[
name|i
index|]
operator|->
name|clock_init
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|i
index|]
operator|->
name|clock_init
operator|)
operator|(
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXUNIT
condition|;
name|j
operator|++
control|)
name|typeunit
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * refclock_newpeer - initialize and start a reference clock  *  * This routine allocates and initializes the interface structure which  * supports a reference clock in the form of an ordinary NTP peer. A  * driver-specific support routine completes the initialization, if  * used. Default peer variables which identify the clock and establish  * its reference ID and stratum are set here. It returns one if success  * and zero if the clock address is invalid or already running,  * insufficient resources are available or the driver declares a bum  * rap.  */
end_comment

begin_function
name|int
name|refclock_newpeer
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Check for valid clock address. If already running, shut it 	 	 * down first. 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_newpeer: clock address %s invalid"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|clktype
operator|=
name|REFCLOCKTYPE
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|unit
operator|>
name|MAXUNIT
operator|||
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_start
operator|==
name|noentry
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_newpeer: clock type %d invalid\n"
argument_list|,
name|clktype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|refclock_unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize interface structure 	 */
if|if
condition|(
operator|!
operator|(
name|pp
operator|=
operator|(
expr|struct
name|refclockproc
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|refclockproc
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refclockproc
argument_list|)
argument_list|)
expr_stmt|;
name|typeunit
index|[
name|clktype
index|]
index|[
name|unit
index|]
operator|=
name|peer
expr_stmt|;
name|peer
operator|->
name|procptr
operator|=
name|pp
expr_stmt|;
comment|/* 	 * Initialize structures 	 */
name|peer
operator|->
name|refclktype
operator|=
name|clktype
expr_stmt|;
name|peer
operator|->
name|refclkunit
operator|=
name|unit
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|event_timer
operator|.
name|peer
operator|=
name|peer
expr_stmt|;
name|peer
operator|->
name|event_timer
operator|.
name|event_handler
operator|=
name|refclock_transmit
expr_stmt|;
name|pp
operator|->
name|type
operator|=
name|clktype
expr_stmt|;
name|pp
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
comment|/* 	 * Do driver dependent initialization 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_start
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Set up the timeout for polling and reachability determination 	 */
if|if
condition|(
name|initializing
condition|)
block|{
name|init_peer_starttime
operator|+=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
if|if
condition|(
name|init_peer_starttime
operator|>=
operator|(
literal|1
operator|<<
name|peer
operator|->
name|minpoll
operator|)
condition|)
name|init_peer_starttime
operator|=
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|peer
operator|->
name|event_timer
operator|.
name|event_time
operator|=
name|init_peer_starttime
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|->
name|event_timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
operator|(
literal|1
operator|<<
name|peer
operator|->
name|hpoll
operator|)
expr_stmt|;
block|}
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|peer
operator|->
name|event_timer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_unpeer - shut down a clock  */
end_comment

begin_function
name|void
name|refclock_unpeer
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
block|{
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Wiggle the driver to release its resources, then give back 	 * the interface structure. 	 */
if|if
condition|(
operator|!
name|peer
operator|->
name|procptr
condition|)
return|return;
name|clktype
operator|=
name|peer
operator|->
name|refclktype
expr_stmt|;
name|unit
operator|=
name|peer
operator|->
name|refclkunit
expr_stmt|;
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_shutdown
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_shutdown
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
expr_stmt|;
name|free
argument_list|(
name|peer
operator|->
name|procptr
argument_list|)
expr_stmt|;
name|peer
operator|->
name|procptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_transmit - simulate the transmit procedure  *  * This routine implements the NTP transmit procedure for a reference  * clock. This provides a mechanism to call the driver at the NTP poll  * interval, as well as provides a reachability mechanism to detect a  * broken radio or other madness.  */
end_comment

begin_function
name|void
name|refclock_transmit
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
block|{
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|u_char
name|opeer_reach
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|clktype
operator|=
name|peer
operator|->
name|refclktype
expr_stmt|;
name|unit
operator|=
name|peer
operator|->
name|refclkunit
expr_stmt|;
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
comment|/* 	 * The transmit procedure is supposed to freeze a timestamp. 	 * Get one just for fun, and to tell when we last were here. 	 */
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
comment|/* 	 * Fiddle reachability. 	 */
name|opeer_reach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Clear this one out. No need to redo selection since 		 * this fellow will definitely be suffering from 		 * dispersion madness. 		 */
if|if
condition|(
name|opeer_reach
operator|!=
literal|0
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update reachability and poll variables 	 */
block|}
elseif|else
if|if
condition|(
operator|(
name|opeer_reach
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
name|l_fp
name|off
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|valid
operator|>
literal|0
condition|)
name|peer
operator|->
name|valid
operator|--
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|off
argument_list|)
expr_stmt|;
name|clock_filter
argument_list|(
name|peer
argument_list|,
operator|&
name|off
argument_list|,
literal|0
argument_list|,
name|NTP_MAXDISPERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
condition|)
name|clock_select
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|valid
operator|<
name|NTP_SHIFT
condition|)
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
comment|/* 	 * If he wants to be polled, do it. New style drivers do not use 	 * the unit argument, since the fudge stuff is in the 	 * refclockproc structure. 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_poll
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_poll
operator|)
operator|(
name|unit
operator|,
name|peer
operator|)
expr_stmt|;
comment|/* 	 * Finally, reset the timer 	 */
name|peer
operator|->
name|event_timer
operator|.
name|event_time
operator|+=
operator|(
literal|1
operator|<<
name|peer
operator|->
name|hpoll
operator|)
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|peer
operator|->
name|event_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare two l_fp's - used with qsort()  */
end_comment

begin_function
specifier|static
name|int
name|refclock_cmpl_fp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|register
name|void
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_comment
comment|/* l_fp to compare */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|L_ISGEQ
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|l_fp
operator|*
operator|)
name|p2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|l_fp
operator|*
operator|)
name|p2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * refclock_process - process a pile of samples from the clock  *  * This routine converts the timecode in the form days, hours, miinutes,  * seconds, milliseconds/microseconds to internal timestamp format. It  * then calculates the difference from the receive timestamp and  * assembles the samples in a shift register. It implements a recursive  * median filter to suppress spikes in the data, as well as determine a  * rough dispersion estimate. A configuration constant time adjustment  * fudgetime1 can be added to the final offset to compensate for various  * systematic errors. The routine returns one if success and zero if  * failure due to invalid timecode data or very noisy offsets.  */
end_comment

begin_function
name|int
name|refclock_process
parameter_list|(
name|pp
parameter_list|,
name|nstart
parameter_list|,
name|nskeep
parameter_list|)
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* peer structure pointer */
name|int
name|nstart
decl_stmt|;
comment|/* stages of median filter */
name|int
name|nskeep
decl_stmt|;
comment|/* stages after outlyer trim */
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|l_fp
name|offset
decl_stmt|,
name|median
decl_stmt|,
name|lftmp
decl_stmt|;
name|l_fp
name|off
index|[
name|MAXSTAGE
index|]
decl_stmt|;
name|u_fp
name|disp
decl_stmt|;
comment|/* 	 * Compute the timecode timestamp from the days, hours, minutes, 	 * seconds and milliseconds/microseconds of the timecode. Use 	 * clocktime() for the aggregate seconds and the msec/usec for 	 * the fraction, when present. Note that this code relies on the 	 * filesystem time for the years and does not use the years of 	 * the timecode. 	 */
name|pp
operator|->
name|nstages
operator|=
name|nstart
expr_stmt|;
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|pp
operator|->
name|day
argument_list|,
name|pp
operator|->
name|hour
argument_list|,
name|pp
operator|->
name|minute
argument_list|,
name|pp
operator|->
name|second
argument_list|,
name|GMT
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|&
name|pp
operator|->
name|lastref
operator|.
name|l_ui
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pp
operator|->
name|usec
condition|)
block|{
name|TVUTOTSF
argument_list|(
name|pp
operator|->
name|usec
argument_list|,
name|pp
operator|->
name|lastref
operator|.
name|l_uf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MSUTOTSF
argument_list|(
name|pp
operator|->
name|msec
argument_list|,
name|pp
operator|->
name|lastref
operator|.
name|l_uf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Subtract the receive timestamp from the timecode timestamp 	 * to form the raw offset. Insert in the median filter shift 	 * register. 	 */
name|i
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|coderecv
argument_list|)
operator|)
operator|%
name|pp
operator|->
name|nstages
expr_stmt|;
name|offset
operator|=
name|pp
operator|->
name|lastref
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pp
operator|->
name|nstages
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|filter
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|->
name|coderecv
operator|++
expr_stmt|;
comment|/* 	 * Copy the raw offsets and sort into ascending order 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pp
operator|->
name|nstages
condition|;
name|i
operator|++
control|)
name|off
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|filter
index|[
name|i
index|]
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|off
argument_list|,
name|pp
operator|->
name|nstages
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|,
name|refclock_cmpl_fp
argument_list|)
expr_stmt|;
comment|/* 	 * Reject the furthest from the median of nstages samples until 	 * nskeep samples remain. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|pp
operator|->
name|nstages
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|-
name|i
operator|)
operator|>
name|nskeep
condition|)
block|{
name|lftmp
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|median
operator|=
name|off
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|lftmp
argument_list|,
operator|&
name|median
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|median
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|median
argument_list|,
operator|&
name|lftmp
argument_list|)
condition|)
block|{
comment|/* reject low end */
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* reject high end */
name|n
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Compute the dispersion based on the difference between the 	 * extremes of the remaining offsets. Add to this the time since 	 * the last clock update, which represents the dispersion 	 * increase with time. We know that NTP_MAXSKEW is 16. If the 	 * sum is greater than the allowed sample dispersion, bail out. 	 * If the loop is unlocked, return the most recent offset; 	 * otherwise, return the median offset. In either case include 	 * the configured fudgetime1 adjustment. 	 */
name|lftmp
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|lftmp
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|disp
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|lftmp
argument_list|)
operator|+
name|current_time
operator|-
name|pp
operator|->
name|lasttime
expr_stmt|;
if|if
condition|(
name|disp
operator|>
name|REFCLOCKMAXDISPERSE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
operator|&
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|dispersion
operator|=
name|disp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_receive - simulate the receive and packet procedures  *  * This routine simulates the NTP receive and packet procedures for a  * reference clock. This provides a mechanism in which the ordinary NTP  * filter, selection and combining algorithms can be used to suppress  * misbehaving radios and to mitigate between them when more than one is  * available for backup.  */
end_comment

begin_function
name|void
name|refclock_receive
parameter_list|(
name|peer
parameter_list|,
name|offset
parameter_list|,
name|delay
parameter_list|,
name|dispersion
parameter_list|,
name|reftime
parameter_list|,
name|rectime
parameter_list|,
name|leap
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
name|l_fp
modifier|*
name|offset
decl_stmt|;
comment|/* computed offset (s) */
name|s_fp
name|delay
decl_stmt|;
comment|/* computed delay to peer */
name|u_fp
name|dispersion
decl_stmt|;
comment|/* computed dispersion to peer */
name|l_fp
modifier|*
name|reftime
decl_stmt|;
comment|/* time at last clock update */
name|l_fp
modifier|*
name|rectime
decl_stmt|;
comment|/* time at last peer update */
name|int
name|leap
decl_stmt|;
comment|/* synchronization/leap code */
block|{
name|int
specifier|restrict
expr_stmt|;
name|int
name|trustable
decl_stmt|;
name|u_fp
name|precision
decl_stmt|;
name|peer
operator|->
name|received
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_receive: %s %s %s %s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The authentication and access-control machinery works, but 	 * its utility may be questionable. 	 */
specifier|restrict
operator|=
name|restrictions
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
specifier|restrict
operator|&
operator|(
name|RES_IGNORE
operator||
name|RES_DONTSERVE
operator|)
condition|)
return|return;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
if|if
condition|(
specifier|restrict
operator|&
name|RES_DONTTRUST
condition|)
name|trustable
operator|=
literal|0
expr_stmt|;
else|else
name|trustable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
if|if
condition|(
name|trustable
condition|)
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
else|else
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
name|peer
operator|->
name|leap
operator|=
name|leap
expr_stmt|;
comment|/* 	 * Set the timestamps. rec and org are in local time, while ref 	 * is in timecode time. 	 */
name|peer
operator|->
name|rec
operator|=
name|peer
operator|->
name|org
operator|=
operator|*
name|rectime
expr_stmt|;
name|peer
operator|->
name|reftime
operator|=
operator|*
name|reftime
expr_stmt|;
comment|/* 	 * If the interface has been set to any_interface, set it to the 	 * loopback address if we have one. This is so that peers which 	 * are unreachable are easy to see in the peer display. 	 */
if|if
condition|(
name|peer
operator|->
name|dstadr
operator|==
name|any_interface
operator|&&
name|loopback_interface
operator|!=
literal|0
condition|)
name|peer
operator|->
name|dstadr
operator|=
name|loopback_interface
expr_stmt|;
comment|/* 	 * Set peer.pmode based on the hmode. For appearances only. 	 */
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
name|peer
operator|->
name|pmode
operator|=
name|MODE_PASSIVE
expr_stmt|;
break|break;
default|default:
name|peer
operator|->
name|pmode
operator|=
name|MODE_SERVER
expr_stmt|;
break|break;
block|}
comment|/* 	 * Abandon ship if the radio came bum. We only got this far 	 * in order to make pretty billboards, even if bum. 	 */
if|if
condition|(
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return;
comment|/* 	 * If this guy was previously unreachable, report him 	 * reachable. 	 */
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
comment|/* 	 * Give the data to the clock filter and update the clock. Note 	 * the clock reading precision initialized by the driver is 	 * added at this point. 	 */
name|precision
operator|=
name|FP_SECOND
operator|>>
operator|-
operator|(
name|int
operator|)
name|peer
operator|->
name|precision
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|offset
argument_list|,
name|delay
argument_list|,
name|dispersion
operator|+
name|precision
argument_list|)
expr_stmt|;
name|clock_update
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * refclock_gtlin - groom next input line and extract timestamp  *  * This routine processes the timecode received from the clock and  * removes the parity bit and control characters. If a timestamp is  * present in the timecode, as produced by the tty_clk line  * discipline/streams module, it returns that as the timestamp;  * otherwise, it returns the buffer timestamp. The routine return code  * is the number of characters in the line.  */
end_comment

begin_function
name|int
name|refclock_gtlin
parameter_list|(
name|rbufp
parameter_list|,
name|lineptr
parameter_list|,
name|bmax
parameter_list|,
name|tsptr
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
comment|/* receive buffer pointer */
name|char
modifier|*
name|lineptr
decl_stmt|;
comment|/* current line pointer */
name|int
name|bmax
decl_stmt|;
comment|/* remaining characters in line */
name|l_fp
modifier|*
name|tsptr
decl_stmt|;
comment|/* pointer to timestamp returned */
block|{
name|char
modifier|*
name|dpt
decl_stmt|,
modifier|*
name|dpend
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|,
name|tstmp
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * Check for the presence of a timestamp left by the tty_clock 	 * line discipline/streams module and, if present, use that 	 * instead of the buffer timestamp captured by the I/O routines. 	 * We recognize a timestamp by noting its value is earlier than 	 * the buffer timestamp, but not more than one second earlier. 	 */
name|dpt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|dpend
operator|=
name|dpt
operator|+
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|trtmp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
if|if
condition|(
name|dpend
operator|>=
name|dpt
operator|+
literal|8
condition|)
block|{
if|if
condition|(
name|buftvtots
argument_list|(
name|dpend
operator|-
literal|8
argument_list|,
operator|&
name|tstmp
argument_list|)
condition|)
block|{
name|L_SUB
argument_list|(
operator|&
name|trtmp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|trtmp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"refclock_gtlin: fd %d ldisc %s"
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|gettstamp
argument_list|(
operator|&
name|trtmp
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|trtmp
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sigio %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dpend
operator|-=
literal|8
expr_stmt|;
name|trtmp
operator|=
name|tstmp
expr_stmt|;
block|}
else|else
name|trtmp
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
block|}
block|}
comment|/* 	 * Edit timecode to remove control chars. Don't monkey with the 	 * line buffer if the input buffer contains no ASCII printing 	 * characters. 	 */
if|if
condition|(
name|dpend
operator|-
name|dpt
operator|>
name|bmax
operator|-
literal|1
condition|)
name|dpend
operator|=
name|dpt
operator|+
name|bmax
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|lineptr
init|;
name|dpt
operator|<
name|dpend
condition|;
name|dpt
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|dpt
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
condition|)
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|i
operator|=
name|dp
operator|-
name|lineptr
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_gtlin: fd %d time %s timecode %d %s\n"
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|,
name|ulfptoa
argument_list|(
operator|&
name|trtmp
argument_list|,
literal|6
argument_list|)
argument_list|,
name|i
argument_list|,
name|lineptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|tsptr
operator|=
name|trtmp
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_open - open serial port for reference clock  *  * This routine opens a serial port for I/O and sets default options. It  * returns the file descriptor if success and zero if failure.  */
end_comment

begin_function
name|int
name|refclock_open
parameter_list|(
name|dev
parameter_list|,
name|speed
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|dev
decl_stmt|;
comment|/* device name pointer */
name|int
name|speed
decl_stmt|;
comment|/* serial port speed (code) */
name|int
name|flags
decl_stmt|;
comment|/* line discipline flags */
block|{
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
name|struct
name|sgttyb
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
ifdef|#
directive|ifdef
name|HAVE_MODEM_CONTROL
name|u_long
name|ltemp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_MODEM_CONTROL */
comment|/* 	 * Open serial port and set default options 	 */
name|fd
operator|=
name|open
argument_list|(
name|dev
argument_list|,
name|O_RDWR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: %s: %m"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The following sections initialize the serial line port in 	 * canonical (line-oriented) mode and set the specified line 	 * speed, 8 bits and no parity. The modem control, break, erase 	 * and kill functions are normally disabled. There is a 	 * different section for each terminal interface, as selected at 	 * compile time. 	 */
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
comment|/* 	 * POSIX serial line parameters (termios interface) 	 */
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d tcgetattr %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set canonical mode and local connection; set specified speed, 	 * 8 bits and no parity; map CR to NL; ignore break. 	 */
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
operator|(
name|void
operator|)
name|cfsetispeed
argument_list|(
operator|&
name|ttyb
argument_list|,
name|speed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfsetospeed
argument_list|(
operator|&
name|ttyb
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MODEM_CONTROL
comment|/* 	 * If we have modem control, check to see if modem leads are 	 * active; if so, set remote connection. This is necessary for 	 * the kernel pps mods to work. 	 */
name|ltemp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ltemp
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TIOCMGET %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_open: fd %d modem status %lx\n"
argument_list|,
name|fd
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ltemp
operator|&
name|TIOCM_DSR
condition|)
name|ttyp
operator|->
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MODEM_CONTROL */
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d tcsetattr %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d tcflush %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
comment|/* 	 * System V serial line parameters (termio interface) 	 * 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCGETA
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TCGETA %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set canonical mode and local connection; set specified speed, 	 * 8 bits and no parity; map CR to NL; ignore break. 	 */
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|speed
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MODEM_CONTROL
comment|/* 	 * If we have modem control, check to see if modem leads are 	 * active; if so, set remote connection. This is necessary for 	 * the kernel pps mods to work. 	 */
name|ltemp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ltemp
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TIOCMGET %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_open: fd %d modem status %lx\n"
argument_list|,
name|fd
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ltemp
operator|&
name|TIOCM_DSR
condition|)
name|ttyp
operator|->
name|c_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MODEM_CONTROL */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TCSETA
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TCSETA %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d TIOCGETP %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ttyp
operator|->
name|sg_ispeed
operator|=
name|ttyp
operator|->
name|sg_ospeed
operator|=
name|speed
expr_stmt|;
name|ttyp
operator|->
name|sg_flags
operator|=
name|EVENP
operator||
name|ODDP
operator||
name|CRMOD
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: TIOCSETP %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
if|if
condition|(
operator|!
name|refclock_ioctl
argument_list|(
name|fd
argument_list|,
name|flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_open: fd %d ioctl fails"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_ioctl - set serial port control functions  *  * This routine attempts to hide the internal, system-specific details  * of serial ports. It can handle POSIX (termios), SYSV (termio) and BSD  * (sgtty) interfaces with varying degrees of success. The routine sets  * up the tty_clk, chu_clk and ppsclock streams module/line discipline,  * if compiled in the daemon and requested in the call. The routine  * returns one if success and zero if failure.  */
end_comment

begin_function
name|int
name|refclock_ioctl
parameter_list|(
name|fd
parameter_list|,
name|flags
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|flags
decl_stmt|;
comment|/* line discipline flags */
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
name|struct
name|sgttyb
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"refclock_ioctl: fd %d flags %x\n"
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The following sections select optional features, such as 	 * modem control, line discipline and so forth. Some require 	 * specific operating system support in the form of streams 	 * modules, which can be loaded and unloaded at run time without 	 * rebooting the kernel, or line discipline modules, which must 	 * be compiled in the kernel. The streams modules require System 	 * V STREAMS support, while the line discipline modules require 	 * 4.3bsd or later. The checking frenzy is attenuated here, 	 * since the device is already open. 	 * 	 * Note that both the clk and ppsclock modules are optional; the 	 * dang thing still works, but the accuracy improvement using 	 * them will not be available. The ppsclock module is associated 	 * with a specific, declared line and should be used only once. 	 * If requested, the chu module is mandatory, since the driver 	 * will not work without it. 	 * 	 * Use the LDISC_PPS option ONLY with Sun baseboard ttya or 	 * ttyb. Using it with the SPIF multipexor crashes the kernel. 	 */
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
operator|)
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_CLK
operator||
name|LDISC_CHU
operator||
name|LDISC_PPS
operator||
name|LDISC_ACTS
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: unsupported terminal interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_TERMIOS HAVE_BSD_TTYS */
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAM
ifdef|#
directive|ifdef
name|CLK
comment|/* 	 * The CLK option provides timestamping at the driver level. 	 * It requires the tty_clk streams module and System V STREAMS 	 * support. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_CLK
operator||
name|LDISC_CLKPPS
operator||
name|LDISC_ACTS
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"clk"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional clk streams module unavailable"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|LDISC_PPS
condition|)
name|str
operator|=
literal|"\377"
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LDISC_ACTS
condition|)
name|str
operator|=
literal|"*"
expr_stmt|;
else|else
name|str
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CLK_SETSTR
argument_list|,
name|str
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: CLK_SETSTR %m"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The ACTS line discipline requires additional line-ending 	 * character '*'. 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_ACTS
condition|)
block|{
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VEOL
index|]
operator|=
literal|'*'
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|LDISC_CLK
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional clk streams module unsupported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLK */
ifdef|#
directive|ifdef
name|CHU
comment|/* 	 * The CHU option provides timestamping and decoding for the CHU 	 * timecode. It requires the tty_chu streams module and System V 	 * STREAMS support. 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_CHU
condition|)
block|{
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcflush
argument_list|(
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"chu"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: required chu streams module unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|LDISC_CHU
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: required chu streams module unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* CHU */
ifdef|#
directive|ifdef
name|PPS
comment|/* 	 * The PPS option provides timestamping at the driver level. 	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the ppsclock streams module and System V STREAMS 	 * support. 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_PPS
condition|)
block|{
if|if
condition|(
name|fdpps
operator|!=
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: ppsclock already configured"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"ppsclock"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional ppsclock streams module unavailable"
argument_list|)
expr_stmt|;
else|else
name|fdpps
operator|=
name|fd
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|LDISC_PPS
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional ppsclock streams module unsupported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS */
else|#
directive|else
comment|/* STREAM */
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
ifdef|#
directive|ifdef
name|CLK
comment|/* 	 * The CLK option provides timestamping at the driver level. It 	 * requires the tty_clk line discipline and 4.3bsd or later. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_CLK
operator||
name|LDISC_CLKPPS
operator||
name|LDISC_ACTS
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LDISC_CLKPPS
condition|)
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\377'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LDISC_ACTS
condition|)
block|{
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'*'
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'#'
expr_stmt|;
block|}
else|else
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\n'
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_line
operator|=
name|CLKLDISC
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcflush
argument_list|(
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|LDISC_CLK
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional clk line discipline unsupported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLK */
ifdef|#
directive|ifdef
name|CHU
comment|/* 	 * The CHU option provides timestamping and decoding for the CHU 	 * timecode. It requires the tty_chu line disciplne and 4.3bsd 	 * or later. 	 */
if|if
condition|(
name|flags
operator|&
name|LDISC_CHU
condition|)
block|{
operator|(
name|void
operator|)
name|tcgetattr
argument_list|(
name|fd
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\r'
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_line
operator|=
name|CHULDISC
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
block|)
empty_stmt|;
operator|(
name|void
operator|)
name|tcflush
argument_list|(
name|fd
argument_list|,
name|TCIOFLUSH
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|flags
operator|&
name|LDISC_CHU
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: required chu line discipline unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIOS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|CLK
end_ifdef

begin_comment
comment|/* 	 * The CLK option provides timestamping at the driver level. It 	 * requires the tty_clk line discipline and 4.3bsd or later. 	 */
end_comment

begin_if
if|if
condition|(
name|flags
operator|&
operator|(
name|LDISC_CLK
operator||
name|LDISC_CLKPPS
operator||
name|LDISC_ACTS
operator|)
condition|)
block|{
name|int
name|ldisc
init|=
name|CLKLDISC
decl_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LDISC_CLKPPS
condition|)
name|ttyp
operator|->
name|sg_erase
operator|=
name|ttyp
operator|->
name|sg_kill
operator|=
literal|'\377'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LDISC_ACTS
condition|)
block|{
name|ttyp
operator|->
name|sg_erase
operator|=
literal|'*'
expr_stmt|;
name|ttyp
operator|->
name|sg_kill
operator|=
literal|'#'
expr_stmt|;
block|}
else|else
name|ttyp
operator|->
name|sg_erase
operator|=
name|ttyp
operator|->
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyp
operator|->
name|sg_flags
operator|=
name|RAW
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
name|ttyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional clk line discipline unavailable"
argument_list|)
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|flags
operator|&
name|LDISC_CLK
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"refclock_ioctl: optional clk line discipline unsupported"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CHU
end_ifdef

begin_comment
comment|/* 	 * The CHU option provides timestamping and decoding for the CHU 	 * timecode. It requires the tty_chu line disciplne and 4.3bsd 	 * or later. 	 */
end_comment

begin_if
if|if
condition|(
name|flags
operator|&
name|LDISC_CHU
condition|)
block|{
name|int
name|ldisc
init|=
name|CHULDISC
decl_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
expr_stmt|;
name|ttyp
operator|->
name|sg_erase
operator|=
name|ttyp
operator|->
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyp
operator|->
name|sg_flags
operator|=
name|RAW
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ttyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: required chu line discipline unavailable"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|flags
operator|&
name|LDISC_CHU
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refclock_ioctl: required chu line discipline unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * refclock_control - set and/or return clock values  *  * This routine is used mainly for debugging. It returns designated  * values from the interface structure that can be displayed using  * xntpdc and the clockstat command. It can also be used to initialize  * configuration variables, such as fudgetimes, fudgevalues, reference  * ID and stratum.  */
end_comment

begin_macro
unit|void
name|refclock_control
argument_list|(
argument|srcadr
argument_list|,
argument|in
argument_list|,
argument|out
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|refclockstat
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|refclockstat
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Check for valid address and running peer 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
return|return;
name|clktype
operator|=
name|REFCLOCKTYPE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|unit
operator|>
name|MAXUNIT
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|peer
operator|=
name|typeunit
index|[
name|clktype
index|]
index|[
name|unit
index|]
operator|)
condition|)
return|return;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Initialize requested data 	 */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|pp
operator|->
name|fudgetime1
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
name|pp
operator|->
name|fudgetime2
operator|=
name|in
operator|->
name|fudgetime2
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
name|peer
operator|->
name|stratum
operator|=
name|in
operator|->
name|fudgeval1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
condition|)
name|pp
operator|->
name|refid
operator|=
name|in
operator|->
name|fudgeval2
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|peer
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG1
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG1
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG2
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG2
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG2
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG3
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG3
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG3
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG4
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG4
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator||=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG4
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG3
condition|)
operator|(
name|void
operator|)
name|refclock_ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|LDISC_PPS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Readback requested data 	 */
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
operator||
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
operator||
name|CLK_HAVEFLAG4
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|pp
operator|->
name|fudgetime1
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|=
name|pp
operator|->
name|fudgetime2
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|pp
operator|->
name|sloppyclockflag
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|pp
operator|->
name|timestarted
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|pp
operator|->
name|polls
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
name|pp
operator|->
name|noreply
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|pp
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|pp
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|pp
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|pp
operator|->
name|currentstatus
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|pp
operator|->
name|type
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|pp
operator|->
name|clockdesc
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
name|pp
operator|->
name|lencode
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
name|pp
operator|->
name|lastcode
expr_stmt|;
block|}
comment|/* 	 * Give the stuff to the clock 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_control
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_control
operator|)
operator|(
name|unit
operator|,
name|in
operator|,
name|out
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * refclock_buginfo - return debugging info  *  * This routine is used mainly for debugging. It returns designated  * values from the interface structure that can be displayed using  * xntpdc and the clkbug command.  */
end_comment

begin_function
name|void
name|refclock_buginfo
parameter_list|(
name|srcadr
parameter_list|,
name|bug
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
comment|/* clock address */
name|struct
name|refclockbug
modifier|*
name|bug
decl_stmt|;
comment|/* output structure */
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|u_char
name|clktype
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Check for valid address and peer structure 	 */
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
name|srcadr
argument_list|)
condition|)
return|return;
name|clktype
operator|=
name|REFCLOCKTYPE
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
name|unit
operator|=
name|REFCLOCKUNIT
argument_list|(
name|srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
name|clktype
operator|>=
name|num_refclock_conf
operator|||
name|unit
operator|>
name|MAXUNIT
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|peer
operator|=
name|typeunit
index|[
name|clktype
index|]
index|[
name|unit
index|]
operator|)
condition|)
return|return;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
comment|/* 	 * Copy structure values 	 */
name|bug
operator|->
name|nvalues
operator|=
literal|8
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|year
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|1
index|]
operator|=
name|pp
operator|->
name|day
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|2
index|]
operator|=
name|pp
operator|->
name|hour
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|3
index|]
operator|=
name|pp
operator|->
name|minute
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|4
index|]
operator|=
name|pp
operator|->
name|second
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|5
index|]
operator|=
name|pp
operator|->
name|msec
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|6
index|]
operator|=
name|pp
operator|->
name|yearstart
expr_stmt|;
name|bug
operator|->
name|values
index|[
literal|7
index|]
operator|=
name|pp
operator|->
name|coderecv
expr_stmt|;
name|bug
operator|->
name|ntimes
operator|=
name|pp
operator|->
name|nstages
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|bug
operator|->
name|ntimes
operator|>
name|NCLKBUGTIMES
condition|)
name|bug
operator|->
name|ntimes
operator|=
name|NCLKBUGTIMES
expr_stmt|;
name|bug
operator|->
name|stimes
operator|=
literal|0xfffffffc
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|lastref
expr_stmt|;
name|bug
operator|->
name|times
index|[
literal|1
index|]
operator|=
name|pp
operator|->
name|lastrec
expr_stmt|;
name|UFPTOLFP
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
operator|&
name|bug
operator|->
name|times
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bug
operator|->
name|ntimes
condition|;
name|i
operator|++
control|)
name|bug
operator|->
name|times
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|pp
operator|->
name|filter
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Give the stuff to the clock 	 */
if|if
condition|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_buginfo
operator|!=
name|noentry
condition|)
operator|(
name|refclock_conf
index|[
name|clktype
index|]
operator|->
name|clock_buginfo
operator|)
operator|(
name|unit
operator|,
name|bug
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

