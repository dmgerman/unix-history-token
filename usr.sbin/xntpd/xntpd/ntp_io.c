begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_io.c,v 3.1 1993/07/06 01:11:17 jbj Exp  * xntp_io.c - input/output routines for xntpd.  The socket-opening code  *	       was shamelessly stolen from ntpd.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MCAST
end_ifdef

begin_include
include|#
directive|include
file|"ntp_in.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MCAST */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_SINIXM
argument_list|)
end_if

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199006
end_if

begin_define
define|#
directive|define
name|HAVE_VARIABLE_IFR_LENGTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VARIABLE_IFR_LENGTH
argument_list|)
operator|&&
name|defined
argument_list|(
name|AF_LINK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|_SOCKADR_LEN
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|SYS_DECOSF1
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|HAVE_VARIABLE_IFR_LENGTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_TTY_SIGPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_UDP_SIGPOLL
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_AIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|_IO
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|_IO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.  In the signal  * handler we poll to see which sockets are ready and read the  * packets from them into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We watch the number of recvbufs available to the signal handler  * and allocate more when this number drops below the low water  * mark.  If the signal handler should run out of buffers in the  * interim it will drop incoming frames, the idea being that it is  * better to drop a packet than to be inaccurate.  */
end_comment

begin_comment
comment|/*  * Block the interrupt, for critical sections.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
end_if

begin_define
define|#
directive|define
name|BLOCKIO
parameter_list|()
value|((void) block_sigio())
end_define

begin_define
define|#
directive|define
name|UNBLOCKIO
parameter_list|()
value|((void) unblock_sigio())
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BLOCKIO
parameter_list|()
end_define

begin_define
define|#
directive|define
name|UNBLOCKIO
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * recvbuf memory management  */
end_comment

begin_define
define|#
directive|define
name|RECV_INIT
value|10
end_define

begin_comment
comment|/* 10 buffers initially */
end_comment

begin_define
define|#
directive|define
name|RECV_LOWAT
value|3
end_define

begin_comment
comment|/* when we're down to three buffers get more */
end_comment

begin_define
define|#
directive|define
name|RECV_INC
value|5
end_define

begin_comment
comment|/* get 5 more at a time */
end_comment

begin_define
define|#
directive|define
name|RECV_TOOMANY
value|30
end_define

begin_comment
comment|/* this is way too many buffers */
end_comment

begin_comment
comment|/*  * Memory allocation  */
end_comment

begin_decl_stmt
name|U_LONG
name|full_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of recvbufs on fulllist */
end_comment

begin_decl_stmt
name|U_LONG
name|free_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of recvbufs on freelist */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|recvbuf
modifier|*
name|freelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free buffers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|recvbuf
modifier|*
name|fulllist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lifo buffers with data */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|recvbuf
modifier|*
name|beginlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fifo buffers with data */
end_comment

begin_decl_stmt
name|U_LONG
name|total_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total recvbufs currently in use */
end_comment

begin_decl_stmt
name|U_LONG
name|lowater_additions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times we have added memory */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|recvbuf
name|initial_bufs
index|[
name|RECV_INIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial allocation */
end_comment

begin_comment
comment|/*  * Other statistics of possible interest  */
end_comment

begin_decl_stmt
name|U_LONG
name|packets_dropped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets dropped on reception */
end_comment

begin_decl_stmt
name|U_LONG
name|packets_ignored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets received on wild card interface */
end_comment

begin_decl_stmt
name|U_LONG
name|packets_received
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets received */
end_comment

begin_decl_stmt
name|U_LONG
name|packets_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets sent */
end_comment

begin_decl_stmt
name|U_LONG
name|packets_notsent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of packets which couldn't be sent */
end_comment

begin_decl_stmt
name|U_LONG
name|handler_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls to interrupt handler */
end_comment

begin_decl_stmt
name|U_LONG
name|handler_pkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pkts received by handler */
end_comment

begin_decl_stmt
name|U_LONG
name|io_timereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time counters were reset */
end_comment

begin_comment
comment|/*  * Interface stuff  */
end_comment

begin_define
define|#
directive|define
name|MAXINTERFACES
value|192
end_define

begin_comment
comment|/* much better for big gateways with IP/X.25 and more ... */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to default interface */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point to loopback interface */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|interface
name|inter_list
index|[
name|MAXINTERFACES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ninterfaces
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Refclock stuff.  We keep a chain of structures with data concerning  * the guys we are doing I/O for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|refclockio
modifier|*
name|refio
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * File descriptor masks etc. for call to select  */
end_comment

begin_decl_stmt
name|fd_set
name|activefds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxactivefd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_timer.c  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|create_sockets
name|P
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_socket
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_socket
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|init_clock_sig
name|P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_socket_sig
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_signal
name|P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|sigio_handler
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|block_sigio
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unblock_sigio
name|P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STREAMS_TLI
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|inet_ntoa
name|P
argument_list|(
operator|(
expr|struct
name|in_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAMS_TLI */
end_comment

begin_comment
comment|/*  * init_io - initialize I/O data structures and call socket creation routine  */
end_comment

begin_function
name|void
name|init_io
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Init buffer free list and stat counters 	 */
name|freelist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECV_INIT
condition|;
name|i
operator|++
control|)
block|{
name|initial_bufs
index|[
name|i
index|]
operator|.
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
operator|&
name|initial_bufs
index|[
name|i
index|]
expr_stmt|;
block|}
name|fulllist
operator|=
literal|0
expr_stmt|;
name|free_recvbufs
operator|=
name|total_recvbufs
operator|=
name|RECV_INIT
expr_stmt|;
name|full_recvbufs
operator|=
name|lowater_additions
operator|=
literal|0
expr_stmt|;
name|packets_dropped
operator|=
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
literal|0
expr_stmt|;
name|loopback_interface
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
name|refio
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
operator|(
name|void
operator|)
name|set_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Create the sockets 	 */
name|BLOCKIO
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|create_sockets
argument_list|(
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"init_io: maxactivefd %d\n"
argument_list|,
name|maxactivefd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * create_sockets - create a socket for each interface plus a default  *		    socket for when we don't know where to send  */
end_comment

begin_function
specifier|static
name|int
name|create_sockets
parameter_list|(
name|port
parameter_list|)
name|unsigned
name|int
name|port
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|struct
name|strioctl
name|ioc
decl_stmt|;
endif|#
directive|endif
comment|/* STREAMS_TLI */
name|char
name|buf
index|[
name|MAXINTERFACES
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|,
modifier|*
name|ifr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|vs
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|sockaddr_in
name|resmask
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"create_sockets(%d)\n"
argument_list|,
name|ntohs
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * create pseudo-interface with wildcard address 	 */
name|inter_list
index|[
literal|0
index|]
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"wildcard"
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|received
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|sent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|notsent
operator|=
literal|0
expr_stmt|;
name|inter_list
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|INT_BROADCAST
expr_stmt|;
ifdef|#
directive|ifdef
name|MCAST
name|inter_list
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|INT_MULTICAST
expr_stmt|;
endif|#
directive|endif
comment|/* MCAST */
ifdef|#
directive|ifdef
name|USE_STREAMS_DEVICE_FOR_IF_CONFIG
if|if
condition|(
operator|(
name|vs
operator|=
name|open
argument_list|(
literal|"/dev/ip"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
comment|/* ! USE_STREAMS_DEVICE_FOR_IF_CONFIG */
if|if
condition|(
operator|(
name|vs
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* USE_STREAMS_DEVICE_FOR_IF_CONFIG */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vs=socket(AF_INET, SOCK_DGRAM) %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFCONF
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
operator|<
literal|0
operator|||
name|ioc
operator|.
name|ic_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface configuration: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIZE_RETURNED_IN_BUFFER
name|ifc
operator|.
name|ifc_len
operator|=
name|ioc
operator|.
name|ic_len
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! SIZE_RETURNED_IN_BUFFER */
name|ifc
operator|.
name|ifc_len
operator|=
name|ioc
operator|.
name|ic_len
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
comment|/* SIZE_RETURNED_IN_BUFFER */
else|#
directive|else
comment|/* ! STREAMS_TLI */
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface configuration: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STREAMS_TLI */
for|for
control|(
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|,
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
init|;
name|n
operator|>
literal|0
condition|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifr
operator|+
name|size
operator|)
control|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_VARIABLE_IFR_LENGTH
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_addr
argument_list|)
condition|)
name|size
operator|+=
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|ifreq
operator|=
operator|*
name|ifr
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFFLAGS
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
else|#
directive|else
comment|/* ! STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* STREAMS_TLI */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface flags: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
condition|)
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_BROADCAST
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SUN_3_3_STINKS
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
operator|&&
operator|(
name|SYS_HPUX
operator|<
literal|8
operator|)
if|if
condition|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_LOCAL_LOOPBACK
condition|)
else|#
directive|else
if|if
condition|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_LOOPBACK
condition|)
endif|#
directive|endif
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_LOOPBACK
expr_stmt|;
if|if
condition|(
name|loopback_interface
operator|==
literal|0
condition|)
name|loopback_interface
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFADDR
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
else|#
directive|else
comment|/* ! STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* STREAMS_TLI */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface addr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SUN_3_3_STINKS
argument_list|)
comment|/* 		 * Oh, barf!  I'm too disgusted to even explain this 		 */
if|if
condition|(
name|SRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|==
literal|0x7f000001
condition|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_LOOPBACK
expr_stmt|;
if|if
condition|(
name|loopback_interface
operator|==
literal|0
condition|)
name|loopback_interface
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
condition|)
block|{
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFBRDADDR
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
else|#
directive|else
comment|/* ! STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFBRDADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* STREAMS_TLI */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFBRDADDR fails"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ifr_broadaddr
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
expr_stmt|;
else|#
directive|else
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_broadaddr
expr_stmt|;
endif|#
directive|endif
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STREAMS_TLI
name|ioc
operator|.
name|ic_cmd
operator|=
name|SIOCGIFNETMASK
expr_stmt|;
name|ioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|ioc
operator|.
name|ic_dp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifreq
expr_stmt|;
name|ioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|I_STR
argument_list|,
operator|&
name|ioc
argument_list|)
condition|)
block|{
else|#
directive|else
comment|/* ! STREAMS_TLI */
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* STREAMS_TLI */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFNETMASK fails"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
expr_stmt|;
comment|/*  		 * look for an already existing source interface address.  If 		 * the machine has multiple point to point interfaces, then  		 * the local address may appear more than once. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|inter_list
index|[
name|j
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|i
condition|)
name|i
operator|++
expr_stmt|;
block|}
name|close
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|ninterfaces
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|activefds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Blacklist all bound interface addresses 	 */
name|resmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|~
literal|0L
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
specifier|restrict
operator|(
name|RESTRICT_FLAGS
operator|,
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|,
operator|&
name|resmask
operator|,
name|RESM_NTPONLY
operator||
name|RESM_INTERFACE
operator|,
name|RES_IGNORE
operator|)
expr_stmt|;
name|any_interface
operator|=
operator|&
name|inter_list
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"create_sockets: ninterfaces=%d\n"
argument_list|,
name|ninterfaces
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"interface %d:  fd=%d,  bfd=%d,  name=%.8s,  flags=0x%x\n"
argument_list|,
name|i
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* Leave these as three printf calls. */
name|printf
argument_list|(
literal|"              sin=%s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
condition|)
name|printf
argument_list|(
literal|"  bcast=%s,"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mask=%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
operator|.
name|sin_addr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|ninterfaces
return|;
block|}
comment|/*  * io_setbclient - open the broadcast client sockets  */
name|void
name|io_setbclient
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SOLARIS
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYS_DOMAINOS
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
operator|=
name|open_socket
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|INT_BCASTOPEN
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|MCAST
comment|/*  * io_multicast_add() - add multicast group address  */
name|void
name|io_multicast_add
parameter_list|(
name|addr
parameter_list|)
name|U_LONG
name|addr
decl_stmt|;
block|{
name|int
name|fd
init|=
name|inter_list
index|[
literal|0
index|]
operator|.
name|fd
decl_stmt|;
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|addr
argument_list|)
condition|)
return|return;
comment|/* 	 * enable reception of multicast packets 	 */
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_ADD_MEMBERSHIP fails: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MCAST */
comment|/*  * io_unsetbclient - close the broadcast client sockets  */
name|void
name|io_unsetbclient
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
continue|continue;
name|close_socket
argument_list|(
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
argument_list|)
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|INT_BCASTOPEN
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MCAST
comment|/*  * io_multicast_del() - delete multicast group address  */
name|void
name|io_multicast_del
parameter_list|(
name|addr
parameter_list|)
name|U_LONG
name|addr
decl_stmt|;
block|{
name|int
name|fd
init|=
name|inter_list
index|[
literal|0
index|]
operator|.
name|fd
decl_stmt|;
name|struct
name|ip_mreq
name|mreq
decl_stmt|;
if|if
condition|(
operator|!
name|IN_CLASSD
argument_list|(
name|addr
argument_list|)
condition|)
return|return;
comment|/* 	 * disable reception of multicast packets 	 */
name|mreq
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|mreq
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|,
sizeof|sizeof
argument_list|(
name|mreq
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_DROP_MEMBERSHIP fails: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MCAST */
comment|/*  * open_socket - open a socket, returning the file descriptor  */
specifier|static
name|int
name|open_socket
parameter_list|(
name|addr
parameter_list|,
name|bcast
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|int
name|bcast
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|off
init|=
literal|0
decl_stmt|;
comment|/* create a datagram (UDP) socket */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(AF_INET, SOCK_DGRAM, 0) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
comment|/* set SO_REUSEADDR since we will be binding the same port 	   number on each interface */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR on fails: %m"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * bind the local address. 	 */
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|buff
index|[
literal|160
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"bind() fd %d, family %d, port %d, addr %08x, bcast=%d fails: %%m"
argument_list|,
name|fd
argument_list|,
name|addr
operator|->
name|sin_family
argument_list|,
name|addr
operator|->
name|sin_port
argument_list|,
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|bcast
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_SIGNALED_IO */
comment|/* 	 * set non-blocking, 	 */
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* O_NONBLOCK */
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* FNDELAY */
name|Need
name|non
name|blocking
name|I
operator|/
name|O
endif|#
directive|endif
comment|/* FNDELAY */
endif|#
directive|endif
comment|/* O_NONBLOCK */
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
comment|/* 	 *  Turn off the SO_REUSEADDR socket option.  It apparently 	 *  causes heartburn on systems with multicast IP installed. 	 *  On normal systems it only gets looked at when the address 	 *  is being bound anyway.. 	 */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt SO_REUSEADDR off fails: %m"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MCAST
comment|/* for the moment we use the bcast option to set multicast ttl */
if|if
condition|(
name|bcast
condition|)
block|{
name|unsigned
name|char
name|mttl
init|=
literal|127
decl_stmt|;
comment|/* set the multicast ttl for outgoing packets */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|&
name|mttl
argument_list|,
sizeof|sizeof
argument_list|(
name|mttl
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt IP_MULTICAST_TTL fails: %m"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MCAST */
ifdef|#
directive|ifdef
name|SO_BROADCAST
comment|/* if this interface can support broadcast, set SO_BROADCAST */
if|if
condition|(
name|bcast
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(SO_BROADCAST): %m"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SO_BROADCAST */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"flags for fd %d: 0%o\n"
argument_list|,
name|fd
argument_list|,
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fd
return|;
block|}
comment|/*  * closesocket - close a socket and remove from the activefd list  */
specifier|static
name|void
name|close_socket
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|newmax
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|maxactivefd
condition|)
block|{
name|newmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxactivefd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|activefds
argument_list|)
condition|)
name|newmax
operator|=
name|i
expr_stmt|;
name|maxactivefd
operator|=
name|newmax
expr_stmt|;
block|}
block|}
comment|/*  * findbcastinter - find broadcast interface corresponding to address  */
name|struct
name|interface
modifier|*
name|findbcastinter
parameter_list|(
name|addr
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SIOCGIFCONF
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|U_LONG
name|netnum
decl_stmt|;
name|netnum
operator|=
name|NSRCADR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BROADCAST
operator|)
condition|)
continue|continue;
if|if
condition|(
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|bcast
argument_list|)
operator|==
name|netnum
condition|)
return|return
operator|&
name|inter_list
index|[
name|i
index|]
return|;
if|if
condition|(
operator|(
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
argument_list|)
operator|&
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
operator|)
operator|==
operator|(
name|netnum
operator|&
name|NSRCADR
argument_list|(
operator|&
name|inter_list
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
operator|)
condition|)
return|return
operator|&
name|inter_list
index|[
name|i
index|]
return|;
block|}
endif|#
directive|endif
comment|/* SIOCGIFCONF */
return|return
name|any_interface
return|;
block|}
comment|/* XXX ELIMINATE getrecvbufs (almost) identical to ntpdate.c, ntptrace.c, ntp_io.c */
comment|/*  * getrecvbufs - get receive buffers which have data in them  *  * ***N.B. must be called with SIGIO blocked***  */
name|struct
name|recvbuf
modifier|*
name|getrecvbufs
parameter_list|()
block|{
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"getrecvbufs: %d handler interrupts, %d frames\n"
argument_list|,
name|handler_calls
argument_list|,
name|handler_pkts
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|full_recvbufs
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"getrecvbufs called, no action here\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
return|;
comment|/* nothing has arrived */
block|}
comment|/* 	 * Get the fulllist chain and mark it empty 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"getrecvbufs returning %d buffers\n"
argument_list|,
name|full_recvbufs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rb
operator|=
name|beginlist
expr_stmt|;
name|fulllist
operator|=
literal|0
expr_stmt|;
name|full_recvbufs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check to see if we're below the low water mark. 	 */
if|if
condition|(
name|free_recvbufs
operator|<=
name|RECV_LOWAT
condition|)
block|{
specifier|register
name|struct
name|recvbuf
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|total_recvbufs
operator|>=
name|RECV_TOOMANY
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"too many recvbufs allocated (%d)"
argument_list|,
name|total_recvbufs
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
name|emalloc
argument_list|(
name|RECV_INC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|recvbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECV_INC
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|buf
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
name|free_recvbufs
operator|+=
name|RECV_INC
expr_stmt|;
name|total_recvbufs
operator|+=
name|RECV_INC
expr_stmt|;
name|lowater_additions
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Return the chain 	 */
return|return
name|rb
return|;
block|}
comment|/* XXX ELIMINATE freerecvbuf (almost) identical to ntpdate.c, ntptrace.c, ntp_io.c */
comment|/*  * freerecvbuf - make a single recvbuf available for reuse  */
name|void
name|freerecvbuf
parameter_list|(
name|rb
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
name|rb
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
block|}
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
comment|/*  * sendpkt - send a packet to the specified destination. Maintain a  * send error cache so that only the first consecutive error for a  * destination is logged.  */
name|void
name|sendpkt
parameter_list|(
name|dest
parameter_list|,
name|inter
parameter_list|,
name|pkt
parameter_list|,
name|len
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|dest
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|slot
decl_stmt|;
comment|/* 	 * Send error cache. Empty slots have port == 0 	 * Set ERRORCACHESIZE to 0 to disable 	 */
struct|struct
name|cache
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
block|}
struct|;
ifndef|#
directive|ifndef
name|ERRORCACHESIZE
define|#
directive|define
name|ERRORCACHESIZE
value|8
endif|#
directive|endif
if|#
directive|if
name|ERRORCACHESIZE
operator|>
literal|0
specifier|static
name|struct
name|cache
name|badaddrs
index|[
name|ERRORCACHESIZE
index|]
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|badaddrs
value|((struct cache *)0)
comment|/* Only used in empty loops! */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sendpkt(fd=%d %s, %s, %d)\n"
argument_list|,
name|inter
operator|->
name|fd
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|inter
operator|->
name|sin
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
name|dest
operator|->
name|sin_port
operator|&&
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|.
name|s_addr
operator|==
name|dest
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
name|cc
operator|=
name|sendto
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|inter
operator|->
name|notsent
operator|++
expr_stmt|;
name|packets_notsent
operator|++
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
operator|&&
name|slot
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Remember this, if there's an empty slot 			 */
for|for
control|(
name|slot
operator|=
name|ERRORCACHESIZE
init|;
operator|--
name|slot
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|==
literal|0
condition|)
block|{
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
name|dest
operator|->
name|sin_port
expr_stmt|;
name|badaddrs
index|[
name|slot
index|]
operator|.
name|addr
operator|=
name|dest
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s): %m"
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inter
operator|->
name|sent
operator|++
expr_stmt|;
name|packets_sent
operator|++
expr_stmt|;
comment|/* 		 * He's not bad any more 		 */
if|if
condition|(
name|slot
operator|>=
literal|0
condition|)
name|badaddrs
index|[
name|slot
index|]
operator|.
name|port
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  * input_handler - receive packets asynchronously  */
name|void
name|input_handler
parameter_list|(
name|cts
parameter_list|)
name|l_fp
modifier|*
name|cts
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
specifier|register
name|int
name|doing
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|handler_calls
operator|++
expr_stmt|;
name|ts
operator|=
operator|*
name|cts
expr_stmt|;
comment|/* 	 * Do a poll to see who has data 	 */
name|again
label|:
name|fds
operator|=
name|activefds
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|maxactivefd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
comment|/* 	 * If nothing to do, just return.  If an error occurred, complain 	 * and return.  If we've got some, freeze a timestamp. 	 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() error: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|handler_pkts
operator|+=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 	 * Check out the reference clocks first, if any 	 */
if|if
condition|(
name|refio
operator|!=
literal|0
condition|)
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
name|fd
operator|=
name|rp
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|free_recvbufs
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|packets_dropped
operator|++
expr_stmt|;
continue|continue;
block|}
name|rb
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
operator|->
name|next
expr_stmt|;
name|free_recvbufs
operator|--
expr_stmt|;
name|i
operator|=
operator|(
name|rp
operator|->
name|datalen
operator|==
literal|0
operator|||
name|rp
operator|->
name|datalen
operator|>
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
else|:
name|rp
operator|->
name|datalen
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock read: %m"
argument_list|)
expr_stmt|;
name|rb
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * Got one.  Mark how and when it got here, 				 * put it on the full list and do bookkeeping. 				 */
name|rb
operator|->
name|recv_srcclock
operator|=
name|rp
operator|->
name|srcclock
expr_stmt|;
name|rb
operator|->
name|dstadr
operator|=
literal|0
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|rp
operator|->
name|clock_recv
expr_stmt|;
if|if
condition|(
name|fulllist
operator|==
literal|0
condition|)
block|{
name|beginlist
operator|=
name|rb
expr_stmt|;
name|rb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rb
operator|->
name|next
operator|=
name|fulllist
operator|->
name|next
expr_stmt|;
name|fulllist
operator|->
name|next
operator|=
name|rb
expr_stmt|;
block|}
name|fulllist
operator|=
name|rb
expr_stmt|;
name|full_recvbufs
operator|++
expr_stmt|;
name|rp
operator|->
name|recvcount
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Loop through the interfaces looking for data to read. 	 */
for|for
control|(
name|i
operator|=
name|ninterfaces
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|doing
operator|=
literal|0
init|;
name|doing
operator|<
literal|2
operator|&&
name|n
operator|>
literal|0
condition|;
name|doing
operator|++
control|)
block|{
if|if
condition|(
name|doing
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|inter_list
index|[
name|i
index|]
operator|.
name|fd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_BCASTOPEN
operator|)
condition|)
break|break;
name|fd
operator|=
name|inter_list
index|[
name|i
index|]
operator|.
name|bfd
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
comment|/* 				 * Get a buffer and read the frame.  If we 				 * haven't got a buffer, or this is received 				 * on the wild card socket, just dump the packet. 				 */
if|if
condition|(
operator|!
operator|(
name|free_recvbufs
operator|&&
name|i
operator|==
literal|0
operator|&&
name|inter_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INT_MULTICAST
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|UDP_WILDCARD_DELIVERY
comment|/*  * these guys manage to put properly addressed packets into the wildcard queue  */
if|if
condition|(
name|free_recvbufs
operator|==
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|free_recvbufs
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|char
name|buf
index|[
name|RX_BUFF_SIZE
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|UDP_WILDCARD_DELIVERY
operator|(
name|void
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fromlen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|packets_ignored
operator|++
expr_stmt|;
else|else
name|packets_dropped
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|rb
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
operator|->
name|next
expr_stmt|;
name|free_recvbufs
operator|--
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_space
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_space
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"recvfrom: %m"
argument_list|)
expr_stmt|;
name|rb
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"input_handler: fd=%d dropped (bad recvfrom)\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"input_handler: fd=%d length %d\n"
argument_list|,
name|fd
argument_list|,
name|rb
operator|->
name|recv_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Got one.  Mark how and when it got here, 				 * put it on the full list and do bookkeeping. 				 */
name|rb
operator|->
name|dstadr
operator|=
operator|&
name|inter_list
index|[
name|i
index|]
expr_stmt|;
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
if|if
condition|(
name|fulllist
operator|==
literal|0
condition|)
block|{
name|beginlist
operator|=
name|rb
expr_stmt|;
name|rb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rb
operator|->
name|next
operator|=
name|fulllist
operator|->
name|next
expr_stmt|;
name|fulllist
operator|->
name|next
operator|=
name|rb
expr_stmt|;
block|}
name|fulllist
operator|=
name|rb
expr_stmt|;
name|full_recvbufs
operator|++
expr_stmt|;
name|inter_list
index|[
name|i
index|]
operator|.
name|received
operator|++
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Done everything from that select.  Poll again. 	 */
goto|goto
name|again
goto|;
block|}
comment|/*  * findinterface - utility used by other modules to find an interface  *		   given an address.  */
name|struct
name|interface
modifier|*
name|findinterface
parameter_list|(
name|addr
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|U_LONG
name|saddr
decl_stmt|;
comment|/* 	 * Just match the address portion. 	 */
name|saddr
operator|=
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninterfaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inter_list
index|[
name|i
index|]
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|saddr
condition|)
return|return
operator|&
name|inter_list
index|[
name|i
index|]
return|;
block|}
return|return
operator|(
expr|struct
name|interface
operator|*
operator|)
literal|0
return|;
block|}
comment|/*  * io_clr_stats - clear I/O module statistics  */
name|void
name|io_clr_stats
parameter_list|()
block|{
name|packets_dropped
operator|=
literal|0
expr_stmt|;
name|packets_ignored
operator|=
literal|0
expr_stmt|;
name|packets_received
operator|=
literal|0
expr_stmt|;
name|packets_sent
operator|=
literal|0
expr_stmt|;
name|packets_notsent
operator|=
literal|0
expr_stmt|;
name|handler_calls
operator|=
literal|0
expr_stmt|;
name|handler_pkts
operator|=
literal|0
expr_stmt|;
name|io_timereset
operator|=
name|current_time
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/*   * This is a hack so that I don't have to fool with these ioctls in the  * pps driver ... we are already non-blocking and turn on SIGIO thru  * another mechanisim  */
name|int
name|io_addclock_simple
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* 	 * Stuff the I/O structure in the list and mark the descriptor 	 * in use.  There is a harmless (I hope) race condition here. 	 */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
name|refio
operator|=
name|rio
expr_stmt|;
if|if
condition|(
name|rio
operator|->
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * io_addclock - add a reference clock to the list and arrange that we  *               get SIGIO interrupts from it.  */
name|int
name|io_addclock
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/*          * Stuff the I/O structure in the list and mark the descriptor          * in use.  There is a harmless (I hope) race condition here.          */
name|rio
operator|->
name|next
operator|=
name|refio
expr_stmt|;
name|refio
operator|=
name|rio
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
if|if
condition|(
name|init_clock_sig
argument_list|(
name|rio
argument_list|)
condition|)
block|{
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rio
operator|->
name|fd
operator|>
name|maxactivefd
condition|)
name|maxactivefd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
operator|&
name|activefds
argument_list|)
expr_stmt|;
name|UNBLOCKIO
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * io_closeclock - close the clock in the I/O structure given  */
name|void
name|io_closeclock
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
comment|/* 	 * Remove structure from the list 	 */
if|if
condition|(
name|refio
operator|==
name|rio
condition|)
block|{
name|refio
operator|=
name|rio
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|refclockio
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|refio
init|;
name|rp
operator|!=
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|rp
operator|->
name|next
operator|==
name|rio
condition|)
block|{
name|rp
operator|->
name|next
operator|=
name|rio
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Internal error.  Report it. 			 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error: refclockio structure not found"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Close the descriptor.  close_socket does the right thing despite 	 * the misnomer. 	 */
name|close_socket
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REFCLOCK */
comment|/*  * SIGPOLL and SIGIO ROUTINES.  */
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
comment|/*  * Some systems (MOST) define SIGPOLL==SIGIO others SIGIO==SIGPOLL a few  * have seperate SIGIO and SIGPOLL signals.  This code checks for the  * SIGIO==SIGPOLL case at compile time.  * Do not defined USE_SIGPOLL or USE_SIGIO.  * these are interal only to ntp_io.c!  */
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
undef|#
directive|undef
name|USE_SIGPOLL
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
undef|#
directive|undef
name|USE_SIGIO
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_TTY_SIGPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_UDP_SIGPOLL
argument_list|)
define|#
directive|define
name|USE_SIGPOLL
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_TTY_SIGPOLL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|USE_UDP_SIGPOLL
argument_list|)
define|#
directive|define
name|USE_SIGIO
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
if|#
directive|if
name|SIGIO
operator|==
name|SIGPOLL
define|#
directive|define
name|USE_SIGIO
undef|#
directive|undef
name|USE_SIGPOLL
endif|#
directive|endif
comment|/* SIGIO==SIGPOLL */
endif|#
directive|endif
comment|/* USE_SIGIO&& USE_SIGIO */
comment|/*  * TTY instialzation routeins.  */
ifndef|#
directive|ifndef
name|USE_TTY_SIGPOLL
comment|/*  * Spical cases first!  */
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
define|#
directive|define
name|CLOCK_DONE
specifier|static
name|int
name|init_clock_sig
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
name|int
name|pgrp
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSSAIOOWN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSSAIOOWN) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/*          * set non-blocking, async I/O on the descriptor          */
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSSAIOSTAT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSSAIOSTAT) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* SYS_HPUX */
if|#
directive|if
name|defined
argument_list|(
name|SYS_AIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BSD
argument_list|)
comment|/*  * SYSV compatibility mode under AIX.  */
define|#
directive|define
name|CLOCK_DONE
specifier|static
name|int
name|init_clock_sig
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
name|int
name|pgrp
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOASYNC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOASYNC) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|pgrp
operator|=
operator|-
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|FIOSETOWN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSETOWN) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* AIX&& !BSD */
ifndef|#
directive|ifndef
name|CLOCK_DONE
specifier|static
name|int
name|init_clock_sig
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETOWN) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* CLOCK_DONE */
else|#
directive|else
comment|/* !USE_TTY_SIGPOLL */
name|int
specifier|static
name|init_clock_sig
parameter_list|(
name|rio
parameter_list|)
name|struct
name|refclockio
modifier|*
name|rio
decl_stmt|;
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|rio
operator|->
name|fd
argument_list|,
name|I_SETSIG
argument_list|,
name|S_INPUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_SETSIG, S_INPUT) fails for clock I/O: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* !USE_TTY_SIGPOLL  */
ifndef|#
directive|ifndef
name|USE_UDP_SIGPOLL
comment|/*  * Socket SIGPOLL initialization routines.  * Special cases first!  */
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_LINUX
argument_list|)
define|#
directive|define
name|SOCKET_DONE
specifier|static
name|void
name|init_socket_sig
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|pgrp
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
comment|/*          * Big difference here for HP-UX ... why can't life be easy ?          */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOASYNC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|#
directive|if
operator|(
name|SYS_HPUX
operator|>
literal|7
operator|)
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
else|#
directive|else
name|pgrp
operator|=
operator|-
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCSPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(SIOCSPGRP) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
endif|#
directive|endif
comment|/* SYS_HPUX */
if|#
directive|if
name|defined
argument_list|(
name|SYS_AIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BSD
argument_list|)
comment|/*  * SYSV compatibility mod under AIX  */
define|#
directive|define
name|SOCKET_DONE
specifier|static
name|void
name|init_socket_sig
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|pgrp
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOASYNC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|pgrp
operator|=
operator|-
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSETOWN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSETOWN) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
endif|#
directive|endif
comment|/* AIX&& !BSD */
if|#
directive|if
name|defined
argument_list|(
name|UDP_BACKWARDS_SETOWN
argument_list|)
comment|/*  * SunOS 3.5 and Ultirx 2.0   */
define|#
directive|define
name|SOCKET_DONE
specifier|static
name|void
name|init_socket_sig
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
comment|/*          * The way Sun did it as recently as SunOS 3.5.  Only          * in the case of sockets, of course, just to confuse          * the issue.  Don't they even bother to test the stuff          * they send out?  Ibid for Ultrix 2.0          */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETOWN
argument_list|,
operator|-
name|getpid
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETOWN) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*          * set non-blocking, async I/O on the descriptor          */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
endif|#
directive|endif
comment|/* UDP_BACKWARDS_SETOWN */
ifndef|#
directive|ifndef
name|SOCKET_DONE
specifier|static
name|void
name|init_socket_sig
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETOWN) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*          * set non-blocking, async I/O on the descriptor          */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
endif|#
directive|endif
comment|/* SOCKET_DONE */
else|#
directive|else
comment|/* !USE_UDP_SIGPOLL */
specifier|static
name|void
name|init_socket_sig
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_SETSIG
argument_list|,
name|S_INPUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(I_SETSIG, S_INPUT) fails for socket I/O: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_UDP_SIGPOLL */
specifier|static
name|RETSIGTYPE
name|sigio_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|l_fp
name|ts
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_SVR4
comment|/* This should not be necessary for a signal previously set with          * sigset().          */
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGIO
argument_list|,
name|sigio_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGPOLL
argument_list|,
name|sigio_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SYS_SVR4 */
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|input_handler
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/*  * Signal support routines.  */
ifdef|#
directive|ifdef
name|NTP_POSIX_SOURCE
specifier|static
name|void
name|set_signal
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
name|struct
name|sigaction
name|vec
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|vec
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SIGIO
name|sigaddset
argument_list|(
operator|&
name|vec
operator|.
name|sa_mask
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SIGPOLL
name|sigaddset
argument_list|(
operator|&
name|vec
operator|.
name|sa_mask
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vec
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|vec
operator|.
name|sa_handler
operator|=
name|sigio_handler
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
name|sigaction
argument_list|(
name|SIGIO
argument_list|,
operator|&
name|vec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"sigaction"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|vec
operator|.
name|sa_handler
operator|=
name|sigio_handler
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
name|sigaction
argument_list|(
name|SIGPOLL
argument_list|,
operator|&
name|vec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"sigaction"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|void
name|block_io_and_alarm
parameter_list|()
block|{
name|sigset_t
name|set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|block_sigio
parameter_list|()
block|{
name|sigset_t
name|set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|void
name|unblock_io_and_alarm
parameter_list|()
block|{
name|sigset_t
name|unset
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|unset
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|unset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|unblock_sigio
parameter_list|()
block|{
name|sigset_t
name|unset
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|unset
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|sigaddset
argument_list|(
operator|&
name|unset
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|unset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|void
name|wait_for_signal
parameter_list|()
block|{
name|sigset_t
name|old
decl_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
name|NULL
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGIO
argument_list|)
name|sigdelset
argument_list|(
operator|&
name|old
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_SIGPOLL
argument_list|)
name|sigdelset
argument_list|(
operator|&
name|old
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigdelset
argument_list|(
operator|&
name|old
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigsuspend
argument_list|(
operator|&
name|old
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/*  * Must be an old bsd system.  * We assume there is no SIGPOLL.  */
name|void
name|block_io_and_alarm
parameter_list|()
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
name|void
name|block_sigio
parameter_list|()
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|set_signal
parameter_list|()
block|{
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGIO
argument_list|,
name|sigio_handler
argument_list|)
expr_stmt|;
block|}
name|void
name|unblock_io_and_alarm
parameter_list|()
block|{
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|omask
operator|&=
operator|~
name|mask
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
name|void
name|unblock_sigio
parameter_list|()
block|{
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|omask
operator|&=
operator|~
name|mask
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
name|void
name|wait_for_signal
parameter_list|()
block|{
name|int
name|mask
decl_stmt|,
name|omask
decl_stmt|;
name|mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|omask
operator|&=
operator|~
name|mask
expr_stmt|;
name|sigpause
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NTP_POSIX_SOURCE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SIGNALED_IO */
end_comment

end_unit

