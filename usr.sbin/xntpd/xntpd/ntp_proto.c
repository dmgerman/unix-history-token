begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_proto.c - NTP version 3 protocol machinery  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_comment
comment|/*  * System variables are declared here.  See Section 3.2 of the  * specification.  */
end_comment

begin_decl_stmt
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap indicator */
end_comment

begin_decl_stmt
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stratum of system */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision */
end_comment

begin_decl_stmt
name|s_fp
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance to current sync source */
end_comment

begin_decl_stmt
name|u_fp
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion of system clock */
end_comment

begin_decl_stmt
name|u_long
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference source for local clock */
end_comment

begin_decl_stmt
name|l_fp
name|sys_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* combined offset from clock_select */
end_comment

begin_decl_stmt
name|u_fp
name|sys_maxd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dispersion of selected peer */
end_comment

begin_decl_stmt
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last updated */
end_comment

begin_decl_stmt
name|l_fp
name|sys_refskew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated skew since last update */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current peer */
end_comment

begin_decl_stmt
name|u_char
name|sys_poll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2 of system poll interval */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|sys_clock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* second part of current time */
end_comment

begin_decl_stmt
name|long
name|sys_lastselect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sys_clock at last synch update */
end_comment

begin_comment
comment|/*  * Nonspecified system state variables.  */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we set our time to broadcasts */
end_comment

begin_decl_stmt
name|s_fp
name|sys_bdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broadcast client default delay */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authenticate time used for syncing */
end_comment

begin_decl_stmt
name|u_char
name|consensus_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mitigated leap bits */
end_comment

begin_decl_stmt
name|u_long
name|sys_authdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* encryption time (l_fp fraction) */
end_comment

begin_decl_stmt
name|u_char
name|leap_consensus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* consensus of survivor leap bits */
end_comment

begin_comment
comment|/*  * Statistics counters  */
end_comment

begin_decl_stmt
name|u_long
name|sys_stattime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time when we started recording */
end_comment

begin_decl_stmt
name|u_long
name|sys_badstratum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with invalid stratum */
end_comment

begin_decl_stmt
name|u_long
name|sys_oldversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old version packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_newversionpkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new version packets received */
end_comment

begin_decl_stmt
name|u_long
name|sys_unknownversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't know version packets */
end_comment

begin_decl_stmt
name|u_long
name|sys_badlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets with bad length */
end_comment

begin_decl_stmt
name|u_long
name|sys_processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets processed */
end_comment

begin_decl_stmt
name|u_long
name|sys_badauth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packets dropped because of auth */
end_comment

begin_decl_stmt
name|u_long
name|sys_limitrejected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pkts rejected due toclient count per net */
end_comment

begin_comment
comment|/*  * Imported from ntp_timer.c  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_io.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_loopfilter.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|pll_enable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pps_update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_util.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stats_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The peer hash table. Imported from ntp_peer.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|peer_hash
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|peer_hash_count
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * debug flag  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_all
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * transmit - Transmit Procedure. See Section 3.4.1 of the  *	specification.  */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
comment|/* packet to send */
name|u_long
name|peer_timer
decl_stmt|;
name|u_fp
name|precision
decl_stmt|;
name|int
name|bool
decl_stmt|;
comment|/* 	 * We need to be very careful about honking uncivilized time. If 	 * not operating in broadcast mode, honk in all except broadcast 	 * client mode. If operating in broadcast mode and synchronized 	 * to a real source, honk except when the peer is the local- 	 * clock driver and the prefer flag is not set. In other words, 	 * in broadcast mode we never honk unless known to be 	 * synchronized to real time. 	 */
name|bool
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BCLIENT
condition|)
name|bool
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_peer
operator|!=
literal|0
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sys_peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|&&
operator|!
operator|(
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
operator|)
condition|)
name|bool
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bool
condition|)
block|{
name|u_long
name|xkeyid
decl_stmt|;
name|int
name|find_rtt
init|=
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
decl_stmt|;
comment|/* 		 * Figure out which keyid to include in the packet 		 */
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
operator|&&
operator|(
name|peer
operator|->
name|flags
operator|&
operator|(
name|FLAG_CONFIG
operator||
name|FLAG_AUTHENTIC
operator|)
operator|)
operator|&&
name|authhavekey
argument_list|(
name|peer
operator|->
name|keyid
argument_list|)
condition|)
block|{
name|xkeyid
operator|=
name|peer
operator|->
name|keyid
expr_stmt|;
block|}
else|else
block|{
name|xkeyid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Make up a packet to send. 		 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|peer
operator|->
name|version
argument_list|,
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdelay
argument_list|)
expr_stmt|;
name|precision
operator|=
name|FP_SECOND
operator|>>
operator|-
operator|(
name|int
operator|)
name|sys_precision
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdispersion
operator|+
name|precision
operator|+
name|LFPTOFP
argument_list|(
operator|&
name|sys_refskew
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 		 * Decide whether to authenticate or not. If so, call 		 * encrypt() to fill in the rest of the frame. If not, 		 * just add in the xmt timestamp and send it quick. 		 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
name|int
name|sendlen
decl_stmt|;
name|xpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|xkeyid
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendlen
operator|=
name|auth2crypt
argument_list|(
name|xkeyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|find_rtt
condition|?
name|any_interface
else|:
name|peer
operator|->
name|dstadr
argument_list|,
operator|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
operator|!
name|find_rtt
operator|)
condition|?
name|peer
operator|->
name|ttl
else|:
operator|-
literal|7
argument_list|,
operator|&
name|xpkt
argument_list|,
name|sendlen
operator|+
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit auth to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Get xmt timestamp, then send it without mac 			 * field 			 */
name|int
name|find_rtt
init|=
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
name|peer
operator|->
name|dstadr
operator|!=
name|any_interface
decl_stmt|;
name|get_systime
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|xmt
operator|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|find_rtt
condition|?
name|any_interface
else|:
name|peer
operator|->
name|dstadr
argument_list|,
operator|(
operator|(
name|peer
operator|->
name|cast_flags
operator|&
name|MDF_MCAST
operator|)
operator|&&
operator|!
name|find_rtt
operator|)
condition|?
name|peer
operator|->
name|ttl
else|:
operator|-
literal|8
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|peer
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|peer
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|u_char
name|opeer_reach
decl_stmt|;
comment|/* 		 * Determine reachability and diddle things if we 		 * haven't heard from the host for a while. If we are 		 * about to become unreachable and are a 		 * broadcast/multicast client, the server has refused to 		 * boogie in client/server mode, so we switch to 		 * MODE_BCLIENT anyway and wait for subsequent 		 * broadcasts. 		 */
name|opeer_reach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
if|if
condition|(
name|opeer_reach
operator|&
literal|0x80
operator|&&
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
condition|)
block|{
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opeer_reach
operator|!=
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_UNREACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* 			 * Clear this guy out.  No need to redo clock 			 * selection since by now this guy won't be a 			 * player 			 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
block|{
if|if
condition|(
name|opeer_reach
operator|!=
literal|0
condition|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
block|}
block|}
comment|/* 			 * While we have a chance, if our system peer is 			 * zero or his stratum is greater than the last 			 * known stratum of this guy, make sure hpoll is 			 * clamped to the minimum before resetting the 			 * timer. If the peer has been unreachable for a 			 * while and we have a system peer who is at 			 * least his equal, we may want to ramp his 			 * polling interval up to avoid the useless 			 * traffic. 			 */
if|if
condition|(
name|sys_peer
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_peer
operator|->
name|stratum
operator|>
name|peer
operator|->
name|stratum
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|unreach
operator|<
literal|16
condition|)
block|{
name|peer
operator|->
name|unreach
operator|++
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|<
name|peer
operator|->
name|maxpoll
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|++
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
block|}
block|}
comment|/* 		 * Update reachability and poll variables 		 */
block|}
elseif|else
if|if
condition|(
operator|(
name|opeer_reach
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
name|l_fp
name|off
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|valid
operator|>
literal|0
condition|)
name|peer
operator|->
name|valid
operator|--
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|>
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|--
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|off
argument_list|)
expr_stmt|;
name|clock_filter
argument_list|(
name|peer
argument_list|,
operator|&
name|off
argument_list|,
operator|(
name|s_fp
operator|)
literal|0
argument_list|,
operator|(
name|u_fp
operator|)
name|NTP_MAXDISPERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
condition|)
name|clock_select
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|valid
operator|<
name|NTP_SHIFT
condition|)
block|{
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|<
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Finally, adjust the hpoll variable for special conditions. If 	 * we are a broadcast/multicast client, we use the server poll 	 * interval if listening for broadcasts and one-eighth this 	 * interval if in client/server mode. The following clamp 	 * prevents madness. If this is the system poll, sys_poll 	 * controls hpoll. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|ppoll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|ppoll
operator|-
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hpoll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
comment|/* 	 * Arrange for our next timeout. hpoll will be less than maxpoll 	 * for sure. 	 */
if|if
condition|(
name|peer
operator|->
name|event_timer
operator|.
name|next
operator|!=
literal|0
condition|)
comment|/* 		 * Oops, someone did already. 		 */
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|peer
operator|->
name|event_timer
argument_list|)
expr_stmt|;
name|peer_timer
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|max
argument_list|(
operator|(
name|u_char
operator|)
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
name|peer
operator|->
name|event_timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|peer_timer
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|peer
operator|->
name|event_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - Receive Procedure.  See section 3.4.2 in the specification.  */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_char
name|hismode
decl_stmt|;
name|int
specifier|restrict
expr_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|trustable
decl_stmt|;
name|int
name|is_authentic
decl_stmt|;
name|u_long
name|hiskeyid
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive from %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Let the monitoring software take a look at this first. 	 */
name|monitor
argument_list|(
name|rbufp
argument_list|)
expr_stmt|;
comment|/* 	 * Get the restrictions on this guy.  If we're to ignore him, 	 * go no further. 	 */
specifier|restrict
operator|=
name|restrictions
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
if|if
condition|(
specifier|restrict
operator|&
name|RES_IGNORE
condition|)
return|return;
comment|/* 	 * Get a pointer to the packet. 	 */
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
comment|/* 	 * Catch packets whose version number we can't deal with 	 */
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_VERSION
condition|)
block|{
name|sys_newversionpkt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|>=
name|NTP_OLDVERSION
condition|)
block|{
name|sys_oldversionpkt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_unknownversion
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Catch private mode packets. Dump it if queries not allowed. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_PRIVATE
condition|)
block|{
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOQUERY
condition|)
return|return;
name|process_private
argument_list|(
name|rbufp
argument_list|,
operator|(
operator|(
specifier|restrict
operator|&
name|RES_NOMODIFY
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Same with control mode packets. 	 */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOQUERY
condition|)
return|return;
name|process_control
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if we're allowed to serve this guy time.  If not, ignore 	 * him. 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_DONTSERVE
condition|)
return|return;
comment|/* 	 * See if we only accept limited number of clients from the net 	 * this guy is from. Note: the flag is determined dynamically 	 * within restrictions() 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_LIMITED
condition|)
block|{
specifier|extern
name|u_long
name|client_limit
decl_stmt|;
name|sys_limitrejected
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"rejected mode %d request from %s - per net client limit (%d) exceeded"
argument_list|,
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|client_limit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Dump anything with a putrid stratum.  These will most likely 	 * come from someone trying to poll us with ntpdc. 	 */
if|if
condition|(
name|pkt
operator|->
name|stratum
operator|>
name|NTP_MAXSTRATUM
condition|)
block|{
name|sys_badstratum
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find the peer.  This will return a null if this guy isn't in 	 * the database. 	 */
name|peer
operator|=
name|findpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|rbufp
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Check the length for validity, drop the packet if it is 	 * not as expected. If this is a client mode poll, go no 	 * further. Send back his time and drop it. 	 * 	 * The scheme we use for authentication is this.  If we are 	 * running in non-authenticated mode, we accept both frames 	 * which are authenticated and frames which aren't, but don't 	 * authenticate. We do record whether the frame had a mac field 	 * or not so we know what to do on output. 	 * 	 * If we are running in authenticated mode, we only trust frames 	 * which have authentication attached, which are validated and 	 * which are using one of our trusted keys. We respond to all 	 * other pollers without saving any state. If a host we are 	 * passively peering with changes his key from a trusted one to 	 * an untrusted one, we immediately unpeer with him, reselect 	 * the clock and treat him as an unmemorable client (this is 	 * a small denial-of-service hole I'll have to think about). 	 * If a similar event occurs with a configured peer we drop the 	 * frame and hope he'll revert to our key again. If we get a 	 * frame which can't be authenticated with the given key, we 	 * drop it. Either we disagree on the keys or someone is trying 	 * some funny stuff. 	 */
comment|/* 	 * here we assume that any packet with an authenticator is at 	 * least LEN_PKT_MAC bytes long, which means at least 96 bits 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|LEN_PKT_MAC
condition|)
block|{
name|has_mac
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
expr_stmt|;
name|hiskeyid
operator|=
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: pkt is %d octets, mac %d octets long, keyid %ld\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|has_mac
argument_list|,
name|hiskeyid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|LEN_PKT_NOMAC
condition|)
block|{
name|hiskeyid
operator|=
literal|0
expr_stmt|;
name|has_mac
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: bad length %d %ld\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sys_badlength
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Figure out his mode and validate it. 	 */
name|hismode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: his mode %d\n"
argument_list|,
name|hismode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|NTP_OLDVERSION
operator|&&
name|hismode
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Easy.  If it is from the NTP port it is 		 * a sym act, else client. 		 */
if|if
condition|(
name|SRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
operator|==
name|NTP_PORT
condition|)
name|hismode
operator|=
name|MODE_ACTIVE
expr_stmt|;
else|else
name|hismode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hismode
operator|!=
name|MODE_ACTIVE
operator|&&
name|hismode
operator|!=
name|MODE_PASSIVE
operator|&&
name|hismode
operator|!=
name|MODE_SERVER
operator|&&
name|hismode
operator|!=
name|MODE_CLIENT
operator|&&
name|hismode
operator|!=
name|MODE_BROADCAST
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad mode %d received from %s"
argument_list|,
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If he included a mac field, decrypt it to see if it is 	 * authentic. 	 */
name|is_authentic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_mac
condition|)
block|{
if|if
condition|(
name|authhavekey
argument_list|(
name|hiskeyid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|hiskeyid
argument_list|)
condition|)
block|{
name|sys_badauth
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: untrusted keyid\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|authdecrypt
argument_list|(
name|hiskeyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|pkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
condition|)
block|{
name|is_authentic
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: authdecrypt succeeds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|sys_badauth
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: authdecrypt fails\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 	 * If this is someone we don't remember from a previous 	 * association, dispatch him now.  Either we send something back 	 * quick, we ignore him, or we allocate some memory for him and 	 * let him continue. 	 */
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|int
name|mymode
decl_stmt|;
name|mymode
operator|=
name|MODE_PASSIVE
expr_stmt|;
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
comment|/* 			 * See if this guy qualifies as being the least 			 * bit memorable.  If so we keep him around for 			 * later.  If not, send his time quick. 			 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOPEER
condition|)
block|{
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MODE_PASSIVE
case|:
case|case
name|MODE_SERVER
case|:
comment|/* 			 * These are obvious errors.  Ignore. 			 */
return|return;
case|case
name|MODE_CLIENT
case|:
comment|/* 			 * Send it back quick and go home. 			 */
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODE_BROADCAST
case|:
comment|/* 			 * Sort of a repeat of the above... 			 */
if|if
condition|(
operator|(
specifier|restrict
operator|&
name|RES_NOPEER
operator|)
operator|||
operator|!
name|sys_bclient
condition|)
return|return;
name|mymode
operator|=
name|MODE_MCLIENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Okay, we're going to keep him around.  Allocate him 		 * some memory. 		 */
name|peer
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|mymode
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXDPOLL
argument_list|,
literal|0
argument_list|,
name|hiskeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The only way this can happen is if the 			 * source address looks like a reference 			 * clock.  Since this is an illegal address 			 * this is one of those "can't happen" things. 			 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"receive() failed to peer with %s, mode %d"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|mymode
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Mark the time of reception 	 */
name|peer
operator|->
name|timereceived
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * If the peer isn't configured, set his keyid and authenable 	 * status based on the packet. 	 */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
condition|)
block|{
if|if
condition|(
name|has_mac
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|reach
operator|&&
name|peer
operator|->
name|keyid
operator|!=
name|hiskeyid
operator|)
condition|)
block|{
name|peer
operator|->
name|keyid
operator|=
name|hiskeyid
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
block|}
block|}
else|else
block|{
name|peer
operator|->
name|keyid
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENABLE
expr_stmt|;
block|}
block|}
comment|/* 	 * If this message was authenticated properly, note this 	 * in the flags. 	 */
if|if
condition|(
name|is_authentic
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If this guy is authenable, and has been authenticated 		 * in the past, but just failed the authentic test, 		 * report the event. 		 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|&&
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
condition|)
name|report_event
argument_list|(
name|EVNT_PEERAUTH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_AUTHENTIC
expr_stmt|;
block|}
comment|/* 	 * Determine if this guy is basically trustable. 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_DONTTRUST
condition|)
name|trustable
operator|=
literal|0
expr_stmt|;
else|else
name|trustable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sys_authenticate
operator|&&
name|trustable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|||
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|has_mac
operator|&&
name|is_authentic
condition|)
name|trustable
operator|=
literal|1
expr_stmt|;
else|else
name|trustable
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Dispose of the packet based on our respective modes. We 	 * don't drive this with a table, though we probably could. 	 */
switch|switch
condition|(
name|peer
operator|->
name|hmode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_CLIENT
case|:
comment|/* 		 * Active mode associations are configured. If the data 		 * isn't trustable, ignore it and hope this guy 		 * brightens up. Else accept any data we get and process 		 * it. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_PASSIVE
case|:
case|case
name|MODE_SERVER
case|:
case|case
name|MODE_BROADCAST
case|:
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_time
operator|)
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_CLIENT
case|:
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_ACTIVE
condition|)
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MODE_PASSIVE
case|:
comment|/* 		 * Passive mode associations are (in the current 		 * implementation) always dynamic. If we get an invalid 		 * header, break the connection. I hate doing this since 		 * it seems like a waste. Oh, well. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
if|if
condition|(
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
operator|(
name|rbufp
operator|->
name|recv_time
operator|)
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODE_PASSIVE
case|:
case|case
name|MODE_SERVER
case|:
case|case
name|MODE_BROADCAST
case|:
comment|/* 			 * These are errors.  Just ignore the packet. 			 * If he doesn't straighten himself out this 			 * association will eventually be disolved. 			 */
break|break;
case|case
name|MODE_CLIENT
case|:
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MODE_BCLIENT
case|:
comment|/* 		 * Broadcast client pseudo-mode. We accept both server 		 * and broadcast data. Passive mode data is an error. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_ACTIVE
case|:
comment|/* 			 * This guy wants to give us real time when 			 * we've been existing on lousy broadcasts! 			 * Create a passive mode association and do it 			 * that way, but keep the old one in case the 			 * packet turns out to be bad. 			 */
name|peer2
operator|=
name|newpeer
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|MODE_PASSIVE
argument_list|,
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|NTP_MINDPOLL
argument_list|,
name|NTP_MAXPOLL
argument_list|,
literal|0
argument_list|,
name|hiskeyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_packet
argument_list|(
name|peer2
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Strange situation.  We've been 				 * receiving broadcasts from him which 				 * we liked, but we don't like his 				 * active mode stuff. Keep his old peer 				 * structure and send him some time 				 * quickly, we'll figure it out later. 				 */
name|unpeer
argument_list|(
name|peer2
argument_list|)
expr_stmt|;
name|fast_xmit
argument_list|(
name|rbufp
argument_list|,
operator|(
name|int
operator|)
name|hismode
argument_list|,
name|is_authentic
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 				 * Drop the old association 				 */
name|unpeer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_PASSIVE
case|:
break|break;
case|case
name|MODE_SERVER
case|:
case|case
name|MODE_BROADCAST
case|:
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
expr_stmt|;
comment|/* 			 * We don't test for invalid headers. 			 * Let him time out. 			 */
break|break;
block|}
break|break;
case|case
name|MODE_MCLIENT
case|:
comment|/* 		 * This mode is temporary and does not appear outside 		 * this routine. It lasts only from the time the 		 * broadcast/multicast is recognized until the 		 * association is instantiated. Note that we start up in 		 * client/server mode to initially synchronize the 	 	 * clock. 		 */
switch|switch
condition|(
name|hismode
condition|)
block|{
case|case
name|MODE_BROADCAST
case|:
name|peer
operator|->
name|flags
operator||=
name|FLAG_MCAST1
operator||
name|FLAG_MCAST2
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
name|process_packet
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
name|has_mac
argument_list|,
name|trustable
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_SERVER
case|:
case|case
name|MODE_PASSIVE
case|:
case|case
name|MODE_ACTIVE
case|:
case|case
name|MODE_CLIENT
case|:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * process_packet - Packet Procedure, a la Section 3.4.3 of the  *	specification. Or almost, at least. If we're in here we have a  *	reasonable expectation that we will be having a long term  *	relationship with this host.  */
end_comment

begin_function
name|int
name|process_packet
parameter_list|(
name|peer
parameter_list|,
name|pkt
parameter_list|,
name|recv_ts
parameter_list|,
name|has_mac
parameter_list|,
name|trustable
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|l_fp
modifier|*
name|recv_ts
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|trustable
decl_stmt|;
comment|/* used as "valid header" */
block|{
name|l_fp
name|t10
decl_stmt|,
name|t23
decl_stmt|;
name|s_fp
name|di
decl_stmt|,
name|ei
decl_stmt|,
name|p_dist
decl_stmt|,
name|p_disp
decl_stmt|;
name|l_fp
name|ci
decl_stmt|,
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_org
decl_stmt|;
name|int
name|randomize
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|,
name|oreach
decl_stmt|;
name|U_LONG
name|temp
decl_stmt|;
name|u_fp
name|precision
decl_stmt|;
name|sys_processed
operator|++
expr_stmt|;
name|peer
operator|->
name|processed
operator|++
expr_stmt|;
name|p_dist
operator|=
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|p_disp
operator|=
name|NTOHS_FP
argument_list|(
name|pkt
operator|->
name|rootdispersion
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
else|else
name|p_org
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|peer
operator|->
name|rec
operator|=
operator|*
name|recv_ts
expr_stmt|;
name|peer
operator|->
name|flash
operator|=
literal|0
expr_stmt|;
name|randomize
operator|=
name|POLL_RANDOMCHANGE
expr_stmt|;
comment|/* 	 * Test for old or duplicate packets (tests 1 through 3). 	 */
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* count old packets */
name|peer
operator|->
name|oldpkt
operator|++
expr_stmt|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|,
operator|&
name|p_xmt
argument_list|)
condition|)
comment|/* test 1 */
name|peer
operator|->
name|flash
operator||=
name|TEST1
expr_stmt|;
comment|/* duplicate packet */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|peer
operator|->
name|xmt
argument_list|,
operator|&
name|p_org
argument_list|)
condition|)
block|{
comment|/* test 2 */
name|randomize
operator|=
name|POLL_MAKERANDOM
expr_stmt|;
name|peer
operator|->
name|bogusorg
operator|++
expr_stmt|;
name|peer
operator|->
name|flash
operator||=
name|TEST2
expr_stmt|;
comment|/* bogus packet */
block|}
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_rec
argument_list|)
operator|||
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynchronized */
block|}
else|else
block|{
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|p_org
argument_list|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST3
expr_stmt|;
comment|/* unsynchronized */
block|}
name|peer
operator|->
name|org
operator|=
name|p_xmt
expr_stmt|;
comment|/* reuse byte-swapped pkt->xmt */
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
comment|/* 	 * Call poll_update(). This will either start us, if the 	 * association is new, or drop the polling interval if the 	 * association is existing and ppoll has been reduced. 	 */
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|,
name|randomize
argument_list|)
expr_stmt|;
comment|/* 	 * Test for valid header (tests 5 through 8) 	 */
if|if
condition|(
name|trustable
operator|==
literal|0
condition|)
comment|/* test 5 */
name|peer
operator|->
name|flash
operator||=
name|TEST5
expr_stmt|;
comment|/* authentication failed */
name|temp
operator|=
name|ntohl
argument_list|(
name|pkt
operator|->
name|reftime
operator|.
name|l_ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
operator|==
name|LEAP_NOTINSYNC
operator|||
comment|/* test 6 */
name|p_xmt
operator|.
name|l_ui
operator|<
name|temp
operator|||
name|p_xmt
operator|.
name|l_ui
operator|>=
name|temp
operator|+
name|NTP_MAXAGE
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST6
expr_stmt|;
comment|/* peer clock unsynchronized */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|&&
comment|/* test 7 */
operator|(
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|>=
name|NTP_MAXSTRATUM
operator|||
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
operator|>
name|sys_stratum
operator|)
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST7
expr_stmt|;
comment|/* peer stratum out of bounds */
if|if
condition|(
name|p_dist
operator|>=
name|NTP_MAXDISPERSE
comment|/* test 8 */
operator|||
name|p_dist
operator|<=
operator|(
operator|-
name|NTP_MAXDISPERSE
operator|)
operator|||
name|p_disp
operator|>=
name|NTP_MAXDISPERSE
condition|)
name|peer
operator|->
name|flash
operator||=
name|TEST8
expr_stmt|;
comment|/* delay/dispersion too big */
comment|/* 	 * If the packet header is invalid (tests 5 through 8), exit 	 */
if|if
condition|(
name|peer
operator|->
name|flash
operator|&
operator|(
name|TEST5
operator||
name|TEST6
operator||
name|TEST7
operator||
name|TEST8
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"invalid packet header %s %02x\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Valid header; update our state. 	 */
name|peer
operator|->
name|leap
operator|=
name|PKT_LEAP
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|peer
operator|->
name|pmode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mac
condition|)
name|peer
operator|->
name|pkeyid
operator|=
name|ntohl
argument_list|(
name|pkt
operator|->
name|keyid
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|pkeyid
operator|=
literal|0
expr_stmt|;
name|ostratum
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|p_dist
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|p_disp
expr_stmt|;
name|peer
operator|->
name|refid
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|pkt
operator|->
name|reftime
argument_list|,
operator|&
name|peer
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|oreach
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
name|peer
operator|->
name|timereachable
operator|=
name|current_time
expr_stmt|;
comment|/* 		 * If this guy was previously unreachable, set his 		 * polling interval to the minimum and reset the 		 * unreach counter. 		 */
name|peer
operator|->
name|unreach
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
comment|/* 	 * If running in a client/server association, calculate the 	 * clock offset c, roundtrip delay d and dispersion e. We use 	 * the equations (reordered from those in the spec). Note that, 	 * in a broadcast association, org has been set to the time of 	 * last reception. Note the computation of dispersion includes 	 * the system precision plus that due to the frequency error 	 * since the originate time. 	 * 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 * d = (t2 - t3) - (t1 - t0) 	 * e = (org - rec) (seconds only) 	 */
name|t10
operator|=
name|p_xmt
expr_stmt|;
comment|/* compute t1 - t0 */
name|L_SUB
argument_list|(
operator|&
name|t10
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
name|t23
operator|=
name|p_rec
expr_stmt|;
comment|/* compute t2 - t3 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|ci
operator|=
name|t10
expr_stmt|;
name|precision
operator|=
name|FP_SECOND
operator|>>
operator|-
operator|(
name|int
operator|)
name|sys_precision
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
name|ei
operator|=
name|precision
operator|+
name|peer
operator|->
name|rec
operator|.
name|l_ui
operator|-
name|p_org
operator|.
name|l_ui
expr_stmt|;
comment|/* 	 * If running in a broacast association, the clock offset is (t1 	 * - t0) corrected by the one-way delay, but we can't measure 	 * that directly; therefore, we start up in client/server mode, 	 * calculate the clock offset, using the engineered refinement 	 * algorithms, while also receiving broadcasts. When a broadcast 	 * is received in client/server mode, we calculate a correction 	 * factor to use after switching back to broadcast mode. We know 	 * NTP_SKEWFACTOR == 16, which accounts for the simplified ei 	 * calculation. 	 * 	 * If FLAG_MCAST2 is set, we are a broadcast/multicast client. 	 * If FLAG_MCAST1 is set, we haven't calculated the propagation 	 * delay. If hmode is MODE_CLIENT, we haven't set the local 	 * clock in client/server mode. Initially, we come up 	 * MODE_CLIENT. When the clock is first updated and FLAG_MCAST2 	 * is set, we switch from MODE_CLIENT to MODE_BCLIENT. 	 */
if|if
condition|(
name|peer
operator|->
name|pmode
operator|==
name|MODE_BROADCAST
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST1
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
condition|)
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_MCAST1
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|peer
operator|->
name|offset
argument_list|)
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estbdelay
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|FPTOLFP
argument_list|(
name|peer
operator|->
name|estbdelay
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|di
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
block|}
else|else
block|{
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t23
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|di
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|t23
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"offset: %s, delay %s, error %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|ci
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|di
argument_list|,
literal|5
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|ei
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|di
operator|>=
name|NTP_MAXDISPERSE
operator|||
name|di
operator|<=
operator|(
operator|-
name|NTP_MAXDISPERSE
operator|)
operator|||
name|ei
operator|>=
name|NTP_MAXDISPERSE
condition|)
comment|/* test 4 */
name|peer
operator|->
name|flash
operator||=
name|TEST4
expr_stmt|;
comment|/* delay/dispersion too big */
comment|/* 	 * If the packet data is invalid (tests 1 through 4), exit. 	 */
if|if
condition|(
name|peer
operator|->
name|flash
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid packet data %s %02x\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If there was a reachability change report it even 		 * though the packet was bogus. 		 */
if|if
condition|(
name|oreach
operator|==
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * This one is valid.  Mark it so, give it to clock_filter(). 	 */
name|clock_filter
argument_list|(
name|peer
argument_list|,
operator|&
name|ci
argument_list|,
name|di
argument_list|,
operator|(
name|u_fp
operator|)
name|ei
argument_list|)
expr_stmt|;
comment|/* 	 * If this guy was previously unreachable, report him reachable. 	 * Note we do this here so that the peer values we return are 	 * the updated ones. 	 */
if|if
condition|(
name|oreach
operator|==
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_REACH
argument_list|,
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * Now update the clock. If we have found a system peer and this 	 * is a broadcast/multicast client, switch to listen mode. 	 */
name|clock_update
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|&&
name|peer
operator|->
name|flags
operator|&
name|FLAG_MCAST2
condition|)
name|peer
operator|->
name|hmode
operator|=
name|MODE_BCLIENT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * clock_update - Clock-update procedure, see section 3.4.5.  */
end_comment

begin_function
name|void
name|clock_update
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
name|u_char
name|oleap
decl_stmt|;
name|u_char
name|ostratum
decl_stmt|;
name|s_fp
name|d
decl_stmt|;
specifier|extern
name|u_char
name|leap_mask
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_update(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|record_peer_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|,
operator|&
name|peer
operator|->
name|offset
argument_list|,
name|peer
operator|->
name|delay
argument_list|,
name|peer
operator|->
name|dispersion
argument_list|)
expr_stmt|;
comment|/* 	 * Call the clock selection algorithm to see if this update 	 * causes the peer to change. If this is not the system peer, 	 * quit now. 	 */
name|clock_select
argument_list|()
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|sys_peer
condition|)
return|return;
comment|/* 	 * Update the system state. This updates the system stratum, 	 * leap bits, root delay, root dispersion, reference ID and 	 * reference time. We also update select dispersion and max 	 * frequency error. 	 */
name|oleap
operator|=
name|sys_leap
expr_stmt|;
name|ostratum
operator|=
name|sys_stratum
expr_stmt|;
name|sys_stratum
operator|=
name|peer
operator|->
name|stratum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sys_stratum
operator|==
literal|1
condition|)
name|sys_refid
operator|=
name|peer
operator|->
name|refid
expr_stmt|;
else|else
name|sys_refid
operator|=
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|sys_reftime
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|sys_rootdelay
operator|=
name|peer
operator|->
name|rootdelay
operator|+
name|d
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|d
operator|+=
name|peer
operator|->
name|dispersion
operator|+
name|peer
operator|->
name|selectdisp
expr_stmt|;
if|if
condition|(
operator|!
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|&&
name|d
operator|<
name|NTP_MINDISPERSE
condition|)
name|d
operator|=
name|NTP_MINDISPERSE
expr_stmt|;
name|sys_rootdispersion
operator|=
name|peer
operator|->
name|rootdispersion
operator|+
name|d
expr_stmt|;
comment|/* 	 * Reset/adjust the system clock. Watch for timewarps here. 	 */
switch|switch
condition|(
name|local_clock
argument_list|(
operator|&
name|sys_offset
argument_list|,
name|peer
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* 		 * Clock is too screwed up. Just exit for now. 		 */
name|report_event
argument_list|(
name|EVNT_SYSFAULT
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* 		 * Clock was slewed.  Continue on normally. 		 */
name|sys_leap
operator|=
name|leap_consensus
operator|&
name|leap_mask
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_refskew
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 		 * Clock was stepped.  Clear filter registers 		 * of all peers. 		 */
name|clear_all
argument_list|()
expr_stmt|;
name|leap_process
argument_list|()
expr_stmt|;
comment|/* reset the leap interrupt */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_refskew
operator|.
name|l_i
operator|=
name|NTP_MAXSKEW
expr_stmt|;
name|sys_refskew
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_CLOCKRESET
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|sys_maxd
operator|=
name|peer
operator|->
name|dispersion
operator|+
name|peer
operator|->
name|selectdisp
expr_stmt|;
if|if
condition|(
name|oleap
operator|!=
name|sys_leap
condition|)
name|report_event
argument_list|(
name|EVNT_SYNCCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostratum
operator|!=
name|sys_stratum
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * poll_update - update peer poll interval. See Section 3.4.8 of the  *     spec.  */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|peer
parameter_list|,
name|new_hpoll
parameter_list|,
name|randomize
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|unsigned
name|int
name|new_hpoll
decl_stmt|;
name|int
name|randomize
decl_stmt|;
block|{
specifier|register
name|struct
name|event
modifier|*
name|evp
decl_stmt|;
specifier|register
name|u_long
name|new_timer
decl_stmt|;
name|u_char
name|newpoll
decl_stmt|,
name|oldpoll
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"poll_update(%s, %d, %d)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|new_hpoll
argument_list|,
name|randomize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Catch reference clocks here.  The polling interval for a 	 * reference clock is fixed and needn't be maintained by us. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|||
name|peer
operator|->
name|hmode
operator|==
name|MODE_BROADCAST
condition|)
return|return;
comment|/* 	 * This routine * will randomly perturb the new peer.timer if 	 * requested, to try to prevent synchronization with the remote 	 * peer from occuring.  There are three options, based on the 	 * value of randomize: 	 * 	 * POLL_NOTRANDOM - essentially the spec algorithm.  If 	 * peer.timer is greater than the new polling interval, 	 * drop it to the new interval. 	 * 	 * POLL_RANDOMCHANGE - make changes randomly.  If peer.timer 	 * must be changed, based on the comparison about, randomly 	 * perturb the new value of peer.timer. 	 * 	 * POLL_MAKERANDOM - make next interval random.  Calculate 	 * a randomly perturbed poll interval.  If this value is 	 * less that peer.timer, update peer.timer. 	 */
name|oldpoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|hmode
operator|==
name|MODE_BCLIENT
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|ppoll
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_SYSPEER
operator|)
operator|&&
name|new_hpoll
operator|>
name|sys_poll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|max
argument_list|(
name|peer
operator|->
name|minpoll
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|new_hpoll
operator|>
name|peer
operator|->
name|maxpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
elseif|else
if|if
condition|(
name|new_hpoll
operator|<
name|peer
operator|->
name|minpoll
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
name|new_hpoll
expr_stmt|;
block|}
comment|/* hpoll<= maxpoll for sure */
name|newpoll
operator|=
name|max
argument_list|(
operator|(
name|u_char
operator|)
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|peer
operator|->
name|hpoll
argument_list|)
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|randomize
operator|==
name|POLL_MAKERANDOM
operator|||
operator|(
name|randomize
operator|==
name|POLL_RANDOMCHANGE
operator|&&
name|newpoll
operator|!=
name|oldpoll
operator|)
condition|)
name|new_timer
operator|=
operator|(
literal|1
operator|<<
operator|(
name|newpoll
operator|-
literal|1
operator|)
operator|)
operator|+
name|ranp2
argument_list|(
name|newpoll
operator|-
literal|1
argument_list|)
operator|+
name|current_time
expr_stmt|;
else|else
name|new_timer
operator|=
operator|(
literal|1
operator|<<
name|newpoll
operator|)
operator|+
name|current_time
expr_stmt|;
name|evp
operator|=
operator|&
operator|(
name|peer
operator|->
name|event_timer
operator|)
expr_stmt|;
if|if
condition|(
name|evp
operator|->
name|next
operator|==
literal|0
operator|||
name|evp
operator|->
name|event_time
operator|>
name|new_timer
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
name|evp
argument_list|)
expr_stmt|;
name|evp
operator|->
name|event_time
operator|=
name|new_timer
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
name|evp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clear_all - clear all peer filter registers.  This is done after  *	       a step change in the time.  */
end_comment

begin_function
specifier|static
name|void
name|clear_all
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
name|peer_clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear sys_peer. We'll sync to one later. 	 */
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clear - clear peer filter registers.  See Section 3.4.7 of the spec.  */
end_comment

begin_function
name|void
name|peer_clear
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clear(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|CLEAR_TO_ZERO
argument_list|(
name|peer
argument_list|)
argument_list|,
literal|0
argument_list|,
name|LEN_CLEAR_TO_ZERO
argument_list|)
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|peer
operator|->
name|dispersion
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
name|peer
operator|->
name|filter_error
index|[
name|i
index|]
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
name|peer
operator|->
name|minpoll
argument_list|,
name|POLL_RANDOMCHANGE
argument_list|)
expr_stmt|;
name|clock_select
argument_list|()
expr_stmt|;
comment|/* 	 * Clear out the selection counters 	 */
name|peer
operator|->
name|candidate
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|select
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|correct
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|was_sane
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Since we have a chance to correct possible funniness in 	 * our selection of interfaces on a multihomed host, do so 	 * by setting us to no particular interface. 	 */
name|peer
operator|->
name|dstadr
operator|=
name|any_interface
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_filter - add incoming clock sample to filter register and run  *		  the filter procedure to find the best sample.  */
end_comment

begin_function
name|void
name|clock_filter
parameter_list|(
name|peer
parameter_list|,
name|sample_offset
parameter_list|,
name|sample_delay
parameter_list|,
name|sample_error
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
modifier|*
name|sample_offset
decl_stmt|;
name|s_fp
name|sample_delay
decl_stmt|;
name|u_fp
name|sample_error
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ord
decl_stmt|;
name|s_fp
name|distance
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
name|long
name|skew
decl_stmt|,
name|skewmax
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"clock_filter(%s, %s, %s, %s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
name|sample_offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|sample_delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|sample_error
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Update sample errors and calculate distances. Also initialize 	 * sort index vector. We know NTP_SKEWFACTOR == 16 	 */
name|skew
operator|=
name|sys_clock
operator|-
name|peer
operator|->
name|update
expr_stmt|;
name|peer
operator|->
name|update
operator|=
name|sys_clock
expr_stmt|;
name|ord
operator|=
name|peer
operator|->
name|filter_order
expr_stmt|;
name|j
operator|=
name|peer
operator|->
name|filter_nextpt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter_error
index|[
name|j
index|]
operator|+=
operator|(
name|u_fp
operator|)
name|skew
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_error
index|[
name|j
index|]
operator|>
name|NTP_MAXDISPERSE
condition|)
name|peer
operator|->
name|filter_error
index|[
name|j
index|]
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|distance
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter_error
index|[
name|j
index|]
operator|+
operator|(
name|peer
operator|->
name|filter_delay
index|[
name|j
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
name|j
operator|+=
name|NTP_SHIFT
expr_stmt|;
block|}
comment|/* 	 * Insert the new sample at the beginning of the register. 	 */
name|peer
operator|->
name|filter_delay
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_delay
expr_stmt|;
name|peer
operator|->
name|filter_offset
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
operator|*
name|sample_offset
expr_stmt|;
name|peer
operator|->
name|filter_soffset
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|LFPTOFP
argument_list|(
name|sample_offset
argument_list|)
expr_stmt|;
name|peer
operator|->
name|filter_error
index|[
name|peer
operator|->
name|filter_nextpt
index|]
operator|=
name|sample_error
expr_stmt|;
name|distance
index|[
literal|0
index|]
operator|=
name|sample_error
operator|+
operator|(
name|sample_delay
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Sort the samples in the register by distance. The winning 	 * sample will be in ord[0]. Sort the samples only if the 	 * samples are not too old and the delay is meaningful. 	 */
name|skewmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NTP_SHIFT
operator|&&
name|sample_delay
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
operator|&&
name|skewmax
operator|<
name|CLOCK_MAXSEC
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|distance
index|[
name|j
index|]
operator|>
name|distance
index|[
name|n
index|]
condition|)
block|{
name|s_fp
name|ftmp
decl_stmt|;
name|ftmp
operator|=
name|distance
index|[
name|n
index|]
expr_stmt|;
name|k
operator|=
name|ord
index|[
name|n
index|]
expr_stmt|;
name|distance
index|[
name|n
index|]
operator|=
name|distance
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|n
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|distance
index|[
name|j
index|]
operator|=
name|ftmp
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
name|skewmax
operator|+=
operator|(
literal|1
operator|<<
name|peer
operator|->
name|hpoll
operator|)
expr_stmt|;
block|}
name|peer
operator|->
name|filter_nextpt
operator|++
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter_nextpt
operator|>=
name|NTP_SHIFT
condition|)
name|peer
operator|->
name|filter_nextpt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We compute the dispersion as per the spec. Note that, to make 	 * things simple, both the l_fp and s_fp offsets are retained 	 * and that the s_fp could be nonsense if the l_fp is greater 	 * than about 32000 s. However, the sanity checks in 	 * ntp_loopfilter() require the l_fp offset to be less than 1000 	 * s anyway, so not to worry. 	 */
if|if
condition|(
name|peer
operator|->
name|filter_error
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|>=
name|NTP_MAXDISPERSE
condition|)
block|{
name|peer
operator|->
name|dispersion
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
block|}
else|else
block|{
name|s_fp
name|d
decl_stmt|;
name|u_fp
name|y
decl_stmt|;
name|peer
operator|->
name|delay
operator|=
name|peer
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|peer
operator|->
name|offset
operator|=
name|peer
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|peer
operator|->
name|soffset
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|peer
operator|->
name|offset
argument_list|)
expr_stmt|;
name|peer
operator|->
name|dispersion
operator|=
name|peer
operator|->
name|filter_error
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTP_SHIFT
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|filter_error
index|[
name|ord
index|[
name|i
index|]
index|]
operator|>=
name|NTP_MAXDISPERSE
condition|)
name|d
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
else|else
block|{
name|d
operator|=
name|peer
operator|->
name|filter_soffset
index|[
name|ord
index|[
name|i
index|]
index|]
operator|-
name|peer
operator|->
name|filter_soffset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|NTP_MAXDISPERSE
condition|)
name|d
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
block|}
comment|/* 			 * XXX This *knows* NTP_FILTER is 1/2 			 */
name|y
operator|=
operator|(
operator|(
name|u_fp
operator|)
name|d
operator|+
name|y
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
name|peer
operator|->
name|dispersion
operator|+=
name|y
expr_stmt|;
comment|/* 		 * Calculate synchronization distance backdated to 		 * sys_lastselect (clock_select will fix it). We know 		 * NTP_SKEWFACTOR == 16. 		 */
name|d
operator|=
name|peer
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|d
operator|+=
name|peer
operator|->
name|rootdelay
expr_stmt|;
name|peer
operator|->
name|synch
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
name|peer
operator|->
name|rootdispersion
operator|+
name|peer
operator|->
name|dispersion
operator|-
operator|(
name|sys_clock
operator|-
name|sys_lastselect
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clock_select - find the pick-of-the-litter clock  */
end_comment

begin_function
name|void
name|clock_select
parameter_list|()
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nlist
decl_stmt|,
name|nl3
decl_stmt|;
specifier|register
name|s_fp
name|d
decl_stmt|,
name|e
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|allow
decl_stmt|,
name|found
decl_stmt|,
name|k
decl_stmt|;
name|s_fp
name|low
init|=
literal|0x7fffffff
decl_stmt|;
name|s_fp
name|high
init|=
operator|-
literal|0x7ffffff
decl_stmt|;
name|u_fp
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|,
name|error
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|peer
modifier|*
name|osys_peer
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeacts
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typelocal
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typepps
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typeprefer
init|=
literal|0
decl_stmt|;
name|struct
name|peer
modifier|*
name|typesystem
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|list_alloc
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|endpoint
modifier|*
name|endpoint
decl_stmt|;
specifier|static
name|int
modifier|*
name|index
decl_stmt|;
specifier|static
name|struct
name|peer
modifier|*
modifier|*
name|peer_list
decl_stmt|;
specifier|static
name|int
name|endpoint_size
init|=
literal|0
decl_stmt|,
name|index_size
init|=
literal|0
decl_stmt|,
name|peer_list_size
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"clock_select()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initizialize. If a prefer peer does not survive this thing, 	 * the pps_update switch will remain zero. 	 */
name|pps_update
operator|=
literal|0
expr_stmt|;
name|nlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
name|nlist
operator|+=
name|peer_hash_count
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
name|list_alloc
condition|)
block|{
if|if
condition|(
name|list_alloc
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|peer_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list_alloc
operator|<
name|nlist
condition|)
block|{
name|list_alloc
operator|+=
literal|5
expr_stmt|;
name|endpoint_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
expr|*
name|endpoint
expr_stmt|;
name|index_size
operator|+=
literal|5
operator|*
literal|3
operator|*
sizeof|sizeof
expr|*
name|index
expr_stmt|;
name|peer_list_size
operator|+=
literal|5
operator|*
sizeof|sizeof
expr|*
name|peer_list
expr_stmt|;
block|}
name|endpoint
operator|=
operator|(
expr|struct
name|endpoint
operator|*
operator|)
name|emalloc
argument_list|(
name|endpoint_size
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
name|index_size
argument_list|)
expr_stmt|;
name|peer_list
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|peer_list_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This first chunk of code is supposed to go through all 	 * peers we know about to find the NTP_MAXLIST peers which 	 * are most likely to succeed.  We run through the list 	 * doing the sanity checks and trying to insert anyone who 	 * looks okay.  We are at all times aware that we should 	 * only keep samples from the top two strata and we only need 	 * NTP_MAXLIST of them. 	 */
name|nlist
operator|=
name|nl3
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_SIZE
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|peer_hash
index|[
name|n
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
comment|/* 			 * Clear peer selection stats 			 */
name|peer
operator|->
name|was_sane
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|correct
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|candidate
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|select
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|flags
operator|&=
operator|~
name|FLAG_SYSPEER
expr_stmt|;
comment|/* 			 * Update synch distance (NTP_SKEWFACTOR == 16). 			 * Note synch distance check instead of spec 			 * dispersion check. Naughty. 			 */
name|peer
operator|->
name|synch
operator|+=
operator|(
name|sys_clock
operator|-
name|sys_lastselect
operator|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
continue|continue;
comment|/* unreachable */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
operator|&&
name|peer
operator|->
name|refid
operator|==
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
continue|continue;
comment|/* sync loop */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>=
name|NTP_MAXSTRATUM
operator|||
name|peer
operator|->
name|stratum
operator|>
name|sys_stratum
condition|)
continue|continue;
comment|/* bad stratum  */
if|if
condition|(
name|peer
operator|->
name|dispersion
operator|>=
name|NTP_MAXDISTANCE
condition|)
block|{
name|peer
operator|->
name|seldisptoolarge
operator|++
expr_stmt|;
continue|continue;
comment|/* too noisy or broken */
block|}
if|if
condition|(
name|peer
operator|->
name|org
operator|.
name|l_ui
operator|<
name|peer
operator|->
name|reftime
operator|.
name|l_ui
condition|)
block|{
name|peer
operator|->
name|selbroken
operator|++
expr_stmt|;
continue|continue;
comment|/* very broken host */
block|}
comment|/* 			 * Don't allow the local-clock or acts drivers 			 * in the kitchen at this point, unless the 			 * prefer peer. Do that later, but only if 			 * nobody else is around. 			 */
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
condition|)
block|{
name|typelocal
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no local clock */
block|}
if|if
condition|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_NIST_ACTS
condition|)
block|{
name|typeacts
operator|=
name|peer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
operator|)
condition|)
continue|continue;
comment|/* no acts */
block|}
comment|/* 			 * If we get this far, we assume the peer is 			 * acceptable. 			 */
name|peer
operator|->
name|was_sane
operator|=
literal|1
expr_stmt|;
name|peer_list
index|[
name|nlist
operator|++
index|]
operator|=
name|peer
expr_stmt|;
comment|/* 			 * Insert each interval endpoint on the sorted 			 * list. 			 */
name|e
operator|=
name|peer
operator|->
name|soffset
operator|+
name|peer
operator|->
name|synch
expr_stmt|;
comment|/* Upper end */
for|for
control|(
name|i
operator|=
name|nl3
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|-=
name|peer
operator|->
name|synch
expr_stmt|;
comment|/* Center point */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
name|e
operator|-=
name|peer
operator|->
name|synch
expr_stmt|;
comment|/* Lower end */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|e
operator|>=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
condition|)
break|break;
name|index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|nl3
expr_stmt|;
name|endpoint
index|[
name|nl3
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|endpoint
index|[
name|nl3
operator|++
index|]
operator|.
name|val
operator|=
name|e
expr_stmt|;
block|}
block|}
name|sys_lastselect
operator|=
name|sys_clock
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: endpoint %2d %s\n"
argument_list|,
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
argument_list|,
name|fptoa
argument_list|(
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|val
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nl3
operator|-
literal|1
expr_stmt|;
name|allow
operator|=
name|nlist
expr_stmt|;
comment|/* falsetickers assumed */
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|allow
operator|>
literal|0
condition|)
block|{
name|allow
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|index
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|j
operator|--
control|)
block|{
name|n
operator|+=
name|endpoint
index|[
name|index
index|[
name|j
index|]
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|endpoint
index|[
name|index
index|[
name|j
index|]
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|>
name|allow
condition|)
break|break;
name|low
operator|=
name|endpoint
index|[
name|index
index|[
name|i
operator|++
index|]
index|]
operator|.
name|val
expr_stmt|;
name|high
operator|=
name|endpoint
index|[
name|index
index|[
name|j
operator|--
index|]
index|]
operator|.
name|val
expr_stmt|;
block|}
comment|/* 	 * If no survivors remain at this point, check if the acts or 	 * local clock drivers have been found. If so, nominate one of 	 * them as the only survivor. Otherwise, give up and declare us 	 * unsynchronized. 	 */
if|if
condition|(
operator|(
name|allow
operator|<<
literal|1
operator|)
operator|>=
name|nlist
condition|)
block|{
if|if
condition|(
name|typeacts
operator|!=
literal|0
condition|)
block|{
name|typeacts
operator|->
name|was_sane
operator|=
literal|1
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typeacts
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typelocal
operator|!=
literal|0
condition|)
block|{
name|typelocal
operator|->
name|was_sane
operator|=
literal|1
expr_stmt|;
name|peer_list
index|[
literal|0
index|]
operator|=
name|typelocal
expr_stmt|;
name|nlist
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"select: low %s high %s\n"
argument_list|,
name|fptoa
argument_list|(
name|low
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|high
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clustering algorithm. Process intersection list to discard 	 * outlyers. Construct candidate list in cluster order 	 * determined by the sum of peer synchronization distance plus 	 * scaled stratum. We must find at least one peer. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nlist
operator|>
literal|1
operator|&&
operator|(
name|peer
operator|->
name|soffset
operator|<
name|low
operator|||
name|high
operator|<
name|peer
operator|->
name|soffset
operator|)
condition|)
continue|continue;
name|peer
operator|->
name|correct
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|peer
operator|->
name|synch
operator|+
operator|(
operator|(
name|u_long
operator|)
name|peer
operator|->
name|stratum
operator|<<
name|NTP_DISPFACTOR
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NTP_MAXCLOCK
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
continue|continue;
else|else
name|j
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|k
operator|-
literal|1
index|]
condition|)
break|break;
name|synch
index|[
name|k
index|]
operator|=
name|synch
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|peer_list
index|[
name|k
index|]
operator|=
name|peer_list
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer_list
index|[
name|k
index|]
operator|=
name|peer
expr_stmt|;
name|synch
index|[
name|k
index|]
operator|=
name|d
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|nlist
operator|=
name|j
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: candidate %s cdist %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|synch
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now, prune outlyers by root dispersion. Continue as long as 	 * there are more than NTP_MINCLOCK survivors and the minimum 	 * select dispersion is greater than the maximum peer 	 * dispersion. Stop if we are about to discard a preferred peer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
name|peer
operator|->
name|candidate
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|error
index|[
name|i
index|]
operator|=
name|peer_list
index|[
name|i
index|]
operator|->
name|rootdispersion
operator|+
name|peer_list
index|[
name|i
index|]
operator|->
name|dispersion
operator|+
operator|(
name|sys_clock
operator|-
name|peer_list
index|[
name|i
index|]
operator|->
name|update
operator|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|u_fp
name|maxd
init|=
literal|0
decl_stmt|;
name|e
operator|=
name|error
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|u_fp
name|sdisp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
name|nlist
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|d
operator|=
name|peer_list
index|[
name|i
index|]
operator|->
name|soffset
operator|-
name|peer_list
index|[
name|j
index|]
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|sdisp
operator|+=
name|d
expr_stmt|;
name|sdisp
operator|=
operator|(
operator|(
name|sdisp
operator|>>
literal|1
operator|)
operator|+
name|sdisp
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
name|peer_list
index|[
name|i
index|]
operator|->
name|selectdisp
operator|=
name|sdisp
expr_stmt|;
if|if
condition|(
name|sdisp
operator|>
name|maxd
condition|)
block|{
name|maxd
operator|=
name|sdisp
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|error
index|[
name|i
index|]
operator|<
name|e
condition|)
name|e
operator|=
name|error
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nlist
operator|<=
name|NTP_MINCLOCK
operator|||
name|maxd
operator|<=
name|e
operator|||
name|peer_list
index|[
name|k
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|k
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
name|peer_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|peer_list
index|[
name|j
index|]
expr_stmt|;
name|error
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|error
index|[
name|j
index|]
expr_stmt|;
block|}
name|nlist
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"select: survivor %s offset %s, cdist %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|peer_list
index|[
name|i
index|]
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|synch
index|[
name|i
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * What remains is a list of not greater than NTP_MINCLOCK 	 * peers. We want only a peer at the lowest stratum to become 	 * the system peer, although all survivors are eligible for the 	 * combining algorithm. First record their order, diddle the 	 * flags and clamp the poll intervals. Then, consider the peers 	 * at the lowest stratum. Of these, OR the leap bits on the 	 * assumption that, if some of them honk nonzero bits, they must 	 * know what they are doing. Also, check for prefer and pps 	 * peers. If a prefer peer is found within CLOCK_MAX, update the 	 * pps switch. Of the other peers not at the lowest stratum, 	 * check if the system peer is among them and, if found, zap 	 * him. We note that the head of the list is at the lowest 	 * stratum and that unsynchronized peers cannot survive this 	 * far. 	 */
name|leap_consensus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nlist
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|peer_list
index|[
name|i
index|]
operator|->
name|select
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|peer_list
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|FLAG_SYSPEER
expr_stmt|;
name|poll_update
argument_list|(
name|peer_list
index|[
name|i
index|]
argument_list|,
name|peer_list
index|[
name|i
index|]
operator|->
name|hpoll
argument_list|,
name|POLL_RANDOMCHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|stratum
operator|==
name|peer_list
index|[
literal|0
index|]
operator|->
name|stratum
condition|)
block|{
name|leap_consensus
operator||=
name|peer_list
index|[
name|i
index|]
operator|->
name|leap
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|refclktype
operator|==
name|REFCLK_ATOM_PPS
condition|)
name|typepps
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|==
name|sys_peer
condition|)
name|typesystem
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
block|{
name|typeprefer
operator|=
name|peer_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|typeprefer
operator|->
name|soffset
operator|>=
operator|-
name|CLOCK_MAX_FP
operator|&&
name|typeprefer
operator|->
name|soffset
operator|<
name|CLOCK_MAX_FP
condition|)
name|pps_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|peer_list
index|[
name|i
index|]
operator|==
name|sys_peer
condition|)
name|sys_peer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Mitigation rules of the game. There are several types of 	 * peers that make a difference here: (1) prefer local peers 	 * (type REFCLK_LOCALCLOCK with FLAG_PREFER) or prefer acts 	 * peers (type REFCLK_NIST_ATOM with FLAG_PREFER), (2) pps peers 	 * (type REFCLK_ATOM_PPS), (3) remaining prefer peers (flag 	 * FLAG_PREFER), (4) the existing system peer, if any, (5) the 	 * head of the survivor list. Note that only one peer can be 	 * declared prefer. The order of preference is in the order 	 * stated. Note that all of these must be at the lowest stratum, 	 * i.e., the stratum of the head of the survivor list. 	 */
name|osys_peer
operator|=
name|sys_peer
expr_stmt|;
if|if
condition|(
name|typeprefer
operator|&&
operator|(
name|typeprefer
operator|==
name|typelocal
operator|||
name|typeprefer
operator|==
name|typeacts
operator|||
operator|!
name|typepps
operator|)
condition|)
block|{
name|sys_peer
operator|=
name|typeprefer
expr_stmt|;
name|sys_peer
operator|->
name|selectdisp
operator|=
literal|0
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"select: prefer offset %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|sys_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|typepps
condition|)
block|{
name|sys_peer
operator|=
name|typepps
expr_stmt|;
name|sys_peer
operator|->
name|selectdisp
operator|=
literal|0
expr_stmt|;
name|sys_offset
operator|=
name|sys_peer
operator|->
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"select: pps offset %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|sys_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|typesystem
condition|)
name|sys_peer
operator|=
name|peer_list
index|[
literal|0
index|]
expr_stmt|;
name|clock_combine
argument_list|(
name|peer_list
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"select: combine offset %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|sys_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If we got a new system peer from all of this, report the 	 * event and clamp the system poll interval. 	 */
if|if
condition|(
name|osys_peer
operator|!=
name|sys_peer
condition|)
block|{
name|sys_poll
operator|=
name|sys_peer
operator|->
name|minpoll
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERSTCHG
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clock_combine - combine offsets from selected peers  *  * Note: this routine uses only those peers at the lowest stratum.  * Strictly speaking, this is at variance with the spec.  */
end_comment

begin_function
name|void
name|clock_combine
parameter_list|(
name|peers
parameter_list|,
name|npeers
parameter_list|)
name|struct
name|peer
modifier|*
modifier|*
name|peers
decl_stmt|;
name|int
name|npeers
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|u_fp
name|a
decl_stmt|,
name|b
decl_stmt|,
name|d
decl_stmt|;
name|u_fp
name|synch
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|l_fp
name|coffset
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|l_fp
name|diff
decl_stmt|;
comment|/* 	 * Sort the offsets by synch distance. 	 */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npeers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peers
index|[
name|i
index|]
operator|->
name|stratum
operator|>
name|sys_peer
operator|->
name|stratum
condition|)
continue|continue;
name|d
operator|=
name|peers
index|[
name|i
index|]
operator|->
name|synch
expr_stmt|;
for|for
control|(
name|j
operator|=
name|k
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|synch
index|[
name|j
operator|-
literal|1
index|]
operator|<=
name|d
condition|)
break|break;
name|synch
index|[
name|j
index|]
operator|=
name|synch
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|coffset
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|synch
index|[
name|j
index|]
operator|=
name|d
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|peers
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
comment|/* 	 * Succesively combine the two offsets with the highest 	 * distance and enter the result into the sorted list. 	 */
for|for
control|(
name|i
operator|=
name|k
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* 		 * The possible weights for the most distant offset 		 * are 1/2, 1/4, 1/8 and zero. We combine the synch 		 * distances as if they were variances of the offsets; 		 * the given weights allow us to stay within 16/15 of 		 * the optimum combined variance at each step, and 		 * within 8/7 on any series. 		 * 		 * The breakeven points for the weigths are found 		 * where the smaller distance is 3/8, 3/16 and 1/16 		 * of the sum, respectively. 		 */
name|d
operator|=
name|synch
index|[
name|i
index|]
expr_stmt|;
name|a
operator|=
operator|(
name|d
operator|+
name|synch
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* (d1+d2)/4 */
name|b
operator|=
name|a
operator|>>
literal|1
expr_stmt|;
comment|/* (d1+d2)/8 */
if|if
condition|(
name|d
operator|<=
operator|(
name|b
operator|>>
literal|1
operator|)
condition|)
comment|/* d1<= (d1+d2)/16 */
comment|/* 			 * Below 1/16, no combination is done, 			 * we just drop the distant offset. 			 */
continue|continue;
comment|/* 		 * The offsets are combined by shifting their 		 * difference the appropriate number of times and 		 * adding it back in. 		 */
name|diff
operator|=
name|coffset
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|coffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|a
operator|+
name|b
condition|)
block|{
comment|/* d1>= 3(d1+d2)/8 */
comment|/* 			 * Above 3/8, the weight is 1/2, and the 			 * combined distance is (d1+d2)/4 			 */
name|d
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|a
operator|>>=
literal|2
expr_stmt|;
comment|/* (d1+d2)/16 */
name|L_RSHIFT
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|a
operator|+
name|b
condition|)
block|{
comment|/* d1>= 3(d1+d2)/16 */
comment|/* 				 * Between 3/16 and 3/8, the weight 				 * is 1/4, and the combined distance 				 * is (9d1+d2)/16 = d1/2 + (d1+d2)/16 				 */
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
name|a
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Between 1/16 and 3/16, the weight 				 * is 1/8, and the combined distance 				 * is (49d1+d2)/64 = 3d1/4+(d1+d2)/64 				 * (We know d> a, so the shift is safe). 				 */
name|L_RSHIFT
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|d
operator|-=
operator|(
name|d
operator|-
name|a
operator|)
operator|>>
literal|2
expr_stmt|;
block|}
block|}
comment|/* 		 * Now we can make the combined offset and insert it 		 * in the list. 		 */
name|L_ADD
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|coffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|synch
index|[
name|j
operator|-
literal|1
index|]
condition|)
break|break;
name|synch
index|[
name|j
index|]
operator|=
name|synch
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|coffset
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|synch
index|[
name|j
index|]
operator|=
name|d
expr_stmt|;
name|coffset
index|[
name|j
index|]
operator|=
name|diff
expr_stmt|;
block|}
comment|/* 	 * The result is put where clock_update() can find it. 	 */
name|sys_offset
operator|=
name|coffset
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fast_xmit - fast path send for stateless (non-)associations  */
end_comment

begin_function
name|void
name|fast_xmit
parameter_list|(
name|rbufp
parameter_list|,
name|rmode
parameter_list|,
name|authentic
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
name|int
name|rmode
decl_stmt|;
name|int
name|authentic
decl_stmt|;
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
specifier|register
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
name|u_char
name|xmode
decl_stmt|;
name|u_short
name|xkey
init|=
literal|0
decl_stmt|;
name|int
name|docrypt
init|=
literal|0
decl_stmt|;
name|l_fp
name|xmt_ts
decl_stmt|;
name|u_fp
name|precision
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"fast_xmit(%s, %d)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|,
name|rmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make up new packet and send it quick 	 */
name|rpkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
if|if
condition|(
name|rmode
operator|==
name|MODE_ACTIVE
condition|)
name|xmode
operator|=
name|MODE_PASSIVE
expr_stmt|;
else|else
name|xmode
operator|=
name|MODE_SERVER
expr_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|LEN_PKT_MAC
condition|)
block|{
name|docrypt
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
expr_stmt|;
if|if
condition|(
name|authentic
condition|)
name|xkey
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|keyid
argument_list|)
expr_stmt|;
block|}
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|xmode
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|sys_stratum
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|max
argument_list|(
name|NTP_MINPOLL
argument_list|,
name|rpkt
operator|->
name|ppoll
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdelay
argument_list|)
expr_stmt|;
name|precision
operator|=
name|FP_SECOND
operator|>>
operator|-
operator|(
name|int
operator|)
name|sys_precision
expr_stmt|;
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|sys_rootdispersion
operator|+
name|precision
operator|+
name|LFPTOFP
argument_list|(
operator|&
name|sys_refskew
argument_list|)
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|org
operator|=
name|rpkt
operator|->
name|xmt
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|,
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * If we are encrypting, do it.  Else don't.  Easy. 	 */
if|if
condition|(
name|docrypt
condition|)
block|{
name|int
name|maclen
decl_stmt|;
name|xpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|xkey
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|xkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|xmt_ts
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|auth2crypt
argument_list|(
name|xkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
operator|-
literal|9
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Get xmt timestamp, then send it without mac field 		 */
name|get_systime
argument_list|(
operator|&
name|xmt_ts
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_ts
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
operator|-
literal|10
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the precision of this particular machine  */
end_comment

begin_define
define|#
directive|define
name|DUSECS
value|1000000
end_define

begin_comment
comment|/* us in a s */
end_comment

begin_define
define|#
directive|define
name|HUSECS
value|(1<< 20)
end_define

begin_comment
comment|/* approx DUSECS for shifting etc */
end_comment

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* minimum clock increment (ys) */
end_comment

begin_define
define|#
directive|define
name|MAXSTEP
value|20000
end_define

begin_comment
comment|/* maximum clock increment (us) */
end_comment

begin_define
define|#
directive|define
name|MINLOOPS
value|5
end_define

begin_comment
comment|/* minimum number of step samples */
end_comment

begin_comment
comment|/*  * This routine calculates the differences between successive calls to  * gettimeofday(). If a difference is less than zero, the us field  * has rolled over to the next second, so we add a second in us. If  * the difference is greater than zero and less than MINSTEP, the  * clock has been advanced by a small amount to avoid standing still.  * If the clock has advanced by a greater amount, then a timer interrupt  * has occurred and this amount represents the precision of the clock.  * In order to guard against spurious values, which could occur if we  * happen to hit a fat interrupt, we do this for MINLOOPS times and  * keep the minimum value obtained.  */
end_comment

begin_function
name|int
name|default_get_precision
parameter_list|()
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|long
name|usec
decl_stmt|;
name|usec
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|MAXSTEP
expr_stmt|;
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINLOOPS
operator|&&
name|usec
operator|<
name|HUSECS
condition|;
control|)
block|{
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
name|usec
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|val
condition|)
name|val
operator|=
name|diff
expr_stmt|;
block|}
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"precision = %d usec"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>=
name|HUSECS
condition|)
name|val
operator|=
name|MINSTEP
expr_stmt|;
comment|/* val<= MINSTEP; fast machine */
name|diff
operator|=
name|HUSECS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|diff
operator|>
name|val
condition|;
name|i
operator|--
control|)
name|diff
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * init_proto - initialize the protocol module's data  */
end_comment

begin_function
name|void
name|init_proto
parameter_list|()
block|{
name|l_fp
name|dummy
decl_stmt|;
comment|/* 	 * Fill in the sys_* stuff.  Default is don't listen to 	 * broadcasting, don't authenticate. 	 */
name|sys_leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
name|sys_stratum
operator|=
name|STRATUM_UNSPEC
expr_stmt|;
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|default_get_precision
argument_list|()
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|sys_rootdispersion
operator|=
literal|0
expr_stmt|;
name|sys_refid
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
name|sys_refskew
operator|.
name|l_i
operator|=
name|NTP_MAXSKEW
expr_stmt|;
name|sys_refskew
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|sys_peer
operator|=
literal|0
expr_stmt|;
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|sys_lastselect
operator|=
name|sys_clock
expr_stmt|;
name|sys_bclient
operator|=
literal|0
expr_stmt|;
name|sys_bdelay
operator|=
name|DEFBROADDELAY
expr_stmt|;
name|sys_authenticate
operator|=
literal|0
expr_stmt|;
name|sys_authdelay
operator|=
name|DEFAUTHDELAY
expr_stmt|;
name|sys_stattime
operator|=
literal|0
expr_stmt|;
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Default these to enable 	 */
name|pll_enable
operator|=
literal|1
expr_stmt|;
name|stats_control
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * proto_config - configure the protocol module  */
end_comment

begin_function
name|void
name|proto_config
parameter_list|(
name|item
parameter_list|,
name|value
parameter_list|)
name|int
name|item
decl_stmt|;
name|u_long
name|value
decl_stmt|;
block|{
comment|/* 	 * Figure out what he wants to change, then do it 	 */
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|PROTO_PLL
case|:
comment|/* 		 * Turn on/off pll clock correction 		 */
name|pll_enable
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_MONITOR
case|:
comment|/* 		 * Turn on/off monitoring 		 */
if|if
condition|(
name|value
condition|)
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
else|else
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_FILEGEN
case|:
comment|/* 		 * Turn on/off statistics 		 */
name|stats_control
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_BROADCLIENT
case|:
comment|/* 		 * Turn on/off facility to listen to broadcasts 		 */
name|sys_bclient
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|io_setbclient
argument_list|()
expr_stmt|;
else|else
name|io_unsetbclient
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_ADD
case|:
comment|/* 		  * Add muliticast group address 		  */
name|sys_bclient
operator|=
literal|1
expr_stmt|;
name|io_multicast_add
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_MULTICAST_DEL
case|:
comment|/* 		 * Delete multicast group address 		 */
name|sys_bclient
operator|=
literal|1
expr_stmt|;
name|io_multicast_del
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROTO_PRECISION
case|:
comment|/* 		 * Set system precision 		 */
name|sys_precision
operator|=
operator|(
name|s_char
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_BROADDELAY
case|:
comment|/* 		 * Set default broadcast delay (s_fp) 		 */
if|if
condition|(
name|sys_bdelay
operator|<
literal|0
condition|)
name|sys_bdelay
operator|=
operator|-
operator|(
operator|-
name|value
operator|>>
literal|16
operator|)
expr_stmt|;
else|else
name|sys_bdelay
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|PROTO_AUTHENTICATE
case|:
comment|/* 		 * Specify the use of authenticated data 		 */
name|sys_authenticate
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|PROTO_AUTHDELAY
case|:
comment|/* 		 * Set authentication delay (l_fp fraction) 		 */
name|sys_authdelay
operator|=
name|value
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Log this error 		 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"proto_config: illegal item %d, value %ld"
argument_list|,
name|item
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * proto_clr_stats - clear protocol stat counters  */
end_comment

begin_function
name|void
name|proto_clr_stats
parameter_list|()
block|{
name|sys_badstratum
operator|=
literal|0
expr_stmt|;
name|sys_oldversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_newversionpkt
operator|=
literal|0
expr_stmt|;
name|sys_unknownversion
operator|=
literal|0
expr_stmt|;
name|sys_badlength
operator|=
literal|0
expr_stmt|;
name|sys_processed
operator|=
literal|0
expr_stmt|;
name|sys_badauth
operator|=
literal|0
expr_stmt|;
name|sys_stattime
operator|=
name|current_time
expr_stmt|;
name|sys_limitrejected
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

