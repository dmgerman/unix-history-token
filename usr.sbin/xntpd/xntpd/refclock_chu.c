begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_chu - clock driver for the CHU time code  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CHU
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|<sys/chudefs.h>
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * The CHU time signal includes a time code which is modulated at the  * standard Bell 103 frequencies (i.e. mark=2225Hz, space=2025Hz).  * and formatted into 8 bit characters with one start bit and two  * stop bits. The time code is composed of 10 8-bit characters.  * The second 5 bytes of the timecode are a redundancy check, and  * are a copy of the first 5 bytes.  *  * It is assumed that you have built or modified a Bell 103 standard  * modem, attached the input to the output of a radio and cabled the  * output to a serial port on your computer, i.e. what you are receiving  * is essentially the output of your radio.  It is also assumed you have  * installed a special CHU line discipline to condition the output from  * the terminal driver and take accurate time stamps.  *  * There are two types of timecodes. One is sent in the 32nd  * through 39th second of the minute.  *  *     6dddhhmmss6dddhhmmss  *  * where ddd is the day of the year, hh is the hour (in UTC), mm is  * the minute and ss the second.  The 6 is a constant.  Note that  * the code is sent twice.  *  * The second sort of timecode is sent only during the 31st second  * past the minute.  *  *     xdyyyyttabXDYYYYTTAB  *  * In this case, the second part of the code is the one's complement  * of the code. This differentiates it from the other timecode  * format.  *  * d is the absolute value of DUT (in tenths of a second). yyyy  * is the year. tt is the difference between UTC and TAI. a is  * a canadian daylight time flag and b is a serial number.  * x is a bitwise field. The least significant bit of x is  * one if DUT is negative. The 2nd bit is set if a leap second  * will be added at the next opportunity. The 3rd bit is set if  * a leap second will be deleted at the next opportunity.  * The 4th bit is an even parity bit for the other three bits  * in this nibble.  *  * The start bit in each character has a precise relationship to  * the on-time second. Most often UART's synchronize themselves to the  * start bit and will post an interrupt at the center of the first stop  * bit.  Thus each character's interrupt should occur at a fixed offset  * from the on-time second. This means that a timestamp taken at the  * arrival of each character in the code will provide an independent  * estimate of the offset.  Since there are 10 characters in the time  * code and the code is sent 9 times per minute, this means you  * potentially get 90 offset samples per minute. Much of the code in  * here is dedicated to producing a single offset estimate from these  * samples.  *  * A note about the line discipline. It is possible to receive the  * CHU time code in raw mode, but this has disadvantages. In particular,  * this puts a lot of code between the interrupt and the time you freeze  * a time stamp, decreasing precision. It is also expensive in terms of  * context switches, and made even more expensive by the way I do I/O.  * Worse, since you are listening directly to the output of your radio,  * CHU is noisy and will make you spend a lot of time receiving noise.  *  * The line discipline fixes a lot of this. It knows that the CHU time  * code consists of 10 bytes which arrive with an intercharacter  * spacing of about 37 ms, and that the data is BCD, and filters on this  * basis. It delivers block of ten characters plus their associated time  * stamps all at once. The time stamps are hence about as accurate as  * a Unix machine can get them, and much of the noise disappears in the  * kernel with no context switching cost.  *  * The kernel module also will insure that the packets that are  * delivered have the correct redundancy bytes, and will return  * a flag in chutype to differentiate one sort of packet from  * the other.  */
end_comment

begin_comment
comment|/*  * CHU definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/chu%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* uart speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-9)
end_define

begin_comment
comment|/* what the heck */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"CHU\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Scratchbuilt CHU Receiver"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|NCHUCODES
value|8
end_define

begin_comment
comment|/* expect 8 CHU codes per minute */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHULDISC
end_ifndef

begin_define
define|#
directive|define
name|CHULDISC
value|10
end_define

begin_comment
comment|/* XXX temp CHU line discipline */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * To compute a quality for the estimate (a pseudo dispersion) we add a  * fixed 10 ms for each missing code in the minute and add to this  * the sum of the differences between the remaining offsets and the  * estimated sample offset.  */
end_comment

begin_define
define|#
directive|define
name|CHUDELAYPENALTY
value|0x0000028f
end_define

begin_comment
comment|/*  * Default fudge factors  */
end_comment

begin_define
define|#
directive|define
name|DEFPROPDELAY
value|0x00624dd3
end_define

begin_comment
comment|/* 0.0015 seconds, 1.5 ms */
end_comment

begin_define
define|#
directive|define
name|DEFFILTFUDGE
value|0x000d1b71
end_define

begin_comment
comment|/* 0.0002 seconds, 200 us */
end_comment

begin_comment
comment|/*  * Hacks to avoid excercising the multiplier.  I have no pride.  */
end_comment

begin_define
define|#
directive|define
name|MULBY10
parameter_list|(
name|x
parameter_list|)
value|(((x)<<3) + ((x)<<1))
end_define

begin_define
define|#
directive|define
name|MULBY60
parameter_list|(
name|x
parameter_list|)
value|(((x)<<6) - ((x)<<2))
end_define

begin_comment
comment|/* watch overflow */
end_comment

begin_define
define|#
directive|define
name|MULBY24
parameter_list|(
name|x
parameter_list|)
value|(((x)<<4) + ((x)<<3))
end_define

begin_comment
comment|/*  * Constants for use when multiplying by 0.1.  ZEROPTONE is 0.1  * as an l_fp fraction, NZPOBITS is the number of significant bits  * in ZEROPTONE.  */
end_comment

begin_define
define|#
directive|define
name|ZEROPTONE
value|0x1999999a
end_define

begin_define
define|#
directive|define
name|NZPOBITS
value|29
end_define

begin_decl_stmt
specifier|static
name|char
name|hexstring
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unit control structure.  */
end_comment

begin_struct
struct|struct
name|chuunit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* peer structure pointer */
name|struct
name|event
name|chutimer
decl_stmt|;
comment|/* timeout timer structure */
name|l_fp
name|offsets
index|[
name|NCHUCODES
index|]
decl_stmt|;
comment|/* offsets computed from each code */
name|l_fp
name|rectimes
index|[
name|NCHUCODES
index|]
decl_stmt|;
comment|/* times we received this stuff */
name|u_long
name|reftimes
index|[
name|NCHUCODES
index|]
decl_stmt|;
comment|/* time of last code received */
name|u_char
name|lastcode
index|[
name|NCHUCHARS
operator|*
literal|4
index|]
decl_stmt|;
comment|/* last code we received */
name|u_char
name|expect
decl_stmt|;
comment|/* the next offset expected */
name|u_short
name|haveoffset
decl_stmt|;
comment|/* flag word indicating valid offsets */
name|u_short
name|flags
decl_stmt|;
comment|/* operational flags */
name|u_long
name|responses
decl_stmt|;
comment|/* number of responses */
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CHUTIMERSET
value|0x1
end_define

begin_comment
comment|/* timer is set to fire */
end_comment

begin_comment
comment|/*  * The CHU table. This gives the expected time of arrival of each  * character after the on-time second and is computed as follows:  * The CHU time code is sent at 300 bps.  Your average UART will  * synchronize at the edge of the start bit and will consider the  * character complete at the middle of the first stop bit, i.e.  * 0.031667 ms later (some UARTS may complete the character at the  * end of the stop bit instead of the middle, but you can fudge this).  * Thus the expected time of each interrupt is the start bit time plus  * 0.031667 seconds. These times are in chutable[].  */
end_comment

begin_define
define|#
directive|define
name|CHARDELAY
value|0x081b4e82
end_define

begin_decl_stmt
specifier|static
name|u_long
name|chutable
index|[
name|NCHUCHARS
index|]
init|=
block|{
literal|0x22222222
operator|+
name|CHARDELAY
block|,
comment|/* 0.1333333333 */
literal|0x2b851eb8
operator|+
name|CHARDELAY
block|,
comment|/* 0.170 (exactly) */
literal|0x34e81b4e
operator|+
name|CHARDELAY
block|,
comment|/* 0.2066666667 */
literal|0x3f92c5f9
operator|+
name|CHARDELAY
block|,
comment|/* 0.2483333333 */
literal|0x47ae147b
operator|+
name|CHARDELAY
block|,
comment|/* 0.280 (exactly) */
literal|0x51111111
operator|+
name|CHARDELAY
block|,
comment|/* 0.3166666667 */
literal|0x5a740da7
operator|+
name|CHARDELAY
block|,
comment|/* 0.3533333333 */
literal|0x63d70a3d
operator|+
name|CHARDELAY
block|,
comment|/* 0.390 (exactly) */
literal|0x6d3a06d4
operator|+
name|CHARDELAY
block|,
comment|/* 0.4266666667 */
literal|0x769d0370
operator|+
name|CHARDELAY
block|,
comment|/* 0.4633333333 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chu_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_process
name|P
argument_list|(
operator|(
expr|struct
name|chuunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_timeout
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_chu
init|=
block|{
name|chu_start
block|,
comment|/* start up driver */
name|chu_shutdown
block|,
comment|/* shut down driver */
name|chu_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old chu_control) */
name|noentry
block|,
comment|/* initialize driver (not used) */
name|noentry
block|,
comment|/* not used (old chu_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * chu_start - open the CHU device and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|chu_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port and set CHU line discipline 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_CHU
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|chutimer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|up
expr_stmt|;
name|up
operator|->
name|chutimer
operator|.
name|event_handler
operator|=
name|chu_timeout
expr_stmt|;
name|up
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|chu_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|chu_shutdown
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_receive - receive data from a CHU clock, do format checks and compute  *		 an estimate from the sample data  */
end_comment

begin_function
specifier|static
name|void
name|chu_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|date_ui
decl_stmt|;
name|u_long
name|tmp
decl_stmt|;
name|u_char
modifier|*
name|code
decl_stmt|;
name|struct
name|chucode
modifier|*
name|chuc
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|u_long
name|reftime
decl_stmt|;
name|l_fp
name|off
index|[
name|NCHUCHARS
index|]
decl_stmt|;
name|int
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
comment|/* 	 * Do a length check on the data.  Should be what we asked for. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|chucode
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_receive: received %d bytes, expected %d"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chucode
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the clock this applies to and a pointer to the data 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|chuc
operator|=
operator|(
expr|struct
name|chucode
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|up
operator|->
name|responses
operator|++
expr_stmt|;
comment|/* 	 * Just for fun, we can debug the whole frame if 	 * we want. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|->
name|lastcode
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|hexstring
index|[
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
name|pp
operator|->
name|lastcode
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|hexstring
index|[
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
index|]
expr_stmt|;
block|}
name|pp
operator|->
name|lencode
operator|=
literal|2
operator|*
name|i
expr_stmt|;
name|pp
operator|->
name|lastcode
index|[
name|pp
operator|->
name|lencode
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"chu: %s packet\n"
argument_list|,
operator|(
name|chuc
operator|->
name|chutype
operator|==
name|CHU_YEAR
operator|)
condition|?
literal|"year"
else|:
literal|"time"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|c
argument_list|,
literal|"%c%c %s"
argument_list|,
name|hexstring
index|[
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
index|]
argument_list|,
name|hexstring
index|[
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
index|]
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|c
index|[
name|strlen
argument_list|(
name|c
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ctime() adds \n */
name|printf
argument_list|(
literal|"chu: %s .%06d\n"
argument_list|,
name|c
argument_list|,
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * At this point we're assured that both halves of the 	 * data match because of what the kernel has done. 	 * But there's more than one data format. We need to 	 * check chutype to see what to do now. If it's a 	 * year packet, then we fiddle with it specially. 	 */
if|if
condition|(
name|chuc
operator|->
name|chutype
operator|==
name|CHU_YEAR
condition|)
block|{
name|u_char
name|leapbits
decl_stmt|,
name|parity
decl_stmt|;
comment|/* 	 	 * Break out the code into the BCD nibbles. 		 * Put it in the half of lastcode. 		 */
name|code
operator|=
name|up
operator|->
name|lastcode
expr_stmt|;
name|code
operator|+=
literal|2
operator|*
name|NCHUCHARS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|code
operator|++
operator|=
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
name|leapbits
operator|=
name|chuc
operator|->
name|codechars
index|[
literal|0
index|]
operator|&
literal|0xf
expr_stmt|;
comment|/* 		 * Now make sure that the leap nibble 		 * is even parity. 		 */
name|parity
operator|=
operator|(
name|leapbits
operator|^
operator|(
name|leapbits
operator|>>
literal|2
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
name|parity
operator|=
operator|(
name|parity
operator|^
operator|(
name|parity
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|parity
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * This just happens to work. :-) 		 */
name|pp
operator|->
name|leap
operator|=
operator|(
name|leapbits
operator|>>
literal|1
operator|)
operator|&
literal|0x3
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chuc
operator|->
name|chutype
operator|!=
name|CHU_TIME
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Break out the code into the BCD nibbles.  Only need to fiddle 	 * with the first half since both are identical.  Note the first 	 * BCD character is the low order nibble, the second the high order. 	 */
name|code
operator|=
name|up
operator|->
name|lastcode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|code
operator|++
operator|=
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/* 	 * Format check.  Make sure the two halves match. 	 * There's really no need for this, but it can't hurt. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|!=
name|chuc
operator|->
name|codechars
index|[
name|i
operator|+
operator|(
name|NCHUCHARS
operator|/
literal|2
operator|)
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the first nibble isn't a 6, we're up the creek 	 */
name|code
operator|=
name|up
operator|->
name|lastcode
expr_stmt|;
if|if
condition|(
operator|*
name|code
operator|++
operator|!=
literal|6
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Collect the day, the hour, the minute and the second. 	 */
name|day
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|day
operator|=
name|MULBY10
argument_list|(
name|day
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|day
operator|=
name|MULBY10
argument_list|(
name|day
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|hour
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|hour
operator|=
name|MULBY10
argument_list|(
name|hour
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|minute
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|minute
operator|=
name|MULBY10
argument_list|(
name|minute
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|second
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|second
operator|=
name|MULBY10
argument_list|(
name|second
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
comment|/* 	 * Sanity check the day and time.  Note that this 	 * only occurs on the 32st through the 39th second 	 * of the minute. 	 */
if|if
condition|(
name|day
operator|<
literal|1
operator|||
name|day
operator|>
literal|366
operator|||
name|hour
operator|>
literal|23
operator|||
name|minute
operator|>
literal|59
operator|||
name|second
operator|<
literal|32
operator|||
name|second
operator|>
literal|39
condition|)
block|{
name|pp
operator|->
name|baddata
operator|++
expr_stmt|;
if|if
condition|(
name|day
operator|<
literal|1
operator|||
name|day
operator|>
literal|366
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Compute the NTP date from the input data and the 	 * receive timestamp.  If this doesn't work, mark the 	 * date as bad and forget it. 	 */
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
literal|0
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
operator|&
name|pp
operator|->
name|yearstart
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|reftime
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
return|return;
block|}
name|date_ui
operator|=
name|reftime
expr_stmt|;
empty_stmt|;
comment|/* 	 * We've now got the integral seconds part of the time code (we hope). 	 * The fractional part comes from the table.  We next compute 	 * the offsets for each character. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|u_long
name|tmp2
decl_stmt|;
name|off
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
name|date_ui
expr_stmt|;
name|off
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|chutable
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pp
operator|->
name|sloppyclockflag
condition|)
block|{
name|u_short
name|ord
index|[
name|NCHUCHARS
index|]
decl_stmt|;
comment|/* 		 * In here we assume the clock has adequate bits 		 * to take timestamps with reasonable accuracy. 		 * Note that the time stamps may contain errors 		 * for a couple of reasons.  Timing is actually 		 * referenced to the start bit in each character 		 * in the time code.  If this is obscured by static 		 * you can still get a valid character but have the 		 * timestamp offset by +-1.5 ms.  Also, we may suffer 		 * from interrupt delays if the interrupt is being 		 * held off when the character arrives.  Note the 		 * latter error is always in the form of a delay. 		 * 		 * After fiddling I arrived at the following scheme. 		 * We sort the times into order by offset.  We then 		 * drop the most positive 2 offset values (which may 		 * correspond to a character arriving early due to 		 * static) and the most negative 4 (which may correspond 		 * to delayed characters, either from static or from 		 * interrupt latency).  We then take the mean of the 		 * remaining 4 offsets as our estimate. 		 */
comment|/* 		 * Set up the order array. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
name|ord
index|[
name|i
index|]
operator|=
operator|(
name|u_short
operator|)
name|i
expr_stmt|;
comment|/* 		 * Sort them into order.  Reuse variables with abandon. 		 */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
operator|(
name|NCHUCHARS
operator|-
literal|1
operator|)
condition|;
name|tmp
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|tmp
operator|+
literal|1
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|L_ISGEQ
argument_list|(
operator|&
name|off
index|[
name|ord
index|[
name|i
index|]
index|]
argument_list|,
operator|&
name|off
index|[
name|ord
index|[
name|tmp
index|]
index|]
argument_list|)
condition|)
block|{
name|date_ui
operator|=
operator|(
name|u_long
operator|)
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|tmp
index|]
expr_stmt|;
name|ord
index|[
name|tmp
index|]
operator|=
operator|(
name|u_short
operator|)
name|date_ui
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Done the sort.  We drop 0, 1, 2 and 3 at the negative 		 * end, and 8 and 9 at the positive.  Take the sum of 		 * 4, 5, 6 and 7. 		 */
name|date_ui
operator|=
name|off
index|[
name|ord
index|[
literal|4
index|]
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp
operator|=
name|off
index|[
name|ord
index|[
literal|4
index|]
index|]
operator|.
name|l_uf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|off
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/* 		 * Round properly, then right shift two bits for the 		 * divide by four. 		 */
if|if
condition|(
name|tmp
operator|&
literal|0x2
condition|)
name|M_ADDUF
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Here is a *big* problem.  On a machine where the 		 * low order bit in the clock is on the order of half 		 * a millisecond or more we don't really have enough 		 * precision to make intelligent choices about which 		 * samples might be in error and which aren't.  More 		 * than this, in the case of error free data we can 		 * pick up a few bits of precision by taking the mean 		 * of the whole bunch.  This is what we do.  The problem 		 * comes when it comes time to divide the 64 bit sum of 		 * the 10 samples by 10, a procedure which really sucks. 		 * Oh, well, grin and bear it.  Compute the sum first. 		 */
name|date_ui
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
condition|)
name|isneg
operator|=
literal|1
expr_stmt|;
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Here is a multiply-by-0.1 optimization that should apply 		 * just about everywhere.  If the magnitude of the sum 		 * is less than 9 we don't have to worry about overflow 		 * out of a 64 bit product, even after rounding. 		 */
if|if
condition|(
name|date_ui
operator|<
literal|9
operator|||
name|date_ui
operator|>
literal|0xfffffff7
condition|)
block|{
specifier|register
name|u_long
name|prod_ui
decl_stmt|;
specifier|register
name|u_long
name|prod_uf
decl_stmt|;
name|prod_ui
operator|=
name|prod_uf
operator|=
literal|0
expr_stmt|;
comment|/* 			 * This code knows the low order bit in 0.1 is zero 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NZPOBITS
condition|;
name|i
operator|++
control|)
block|{
name|M_LSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZEROPTONE
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|M_ADD
argument_list|(
name|prod_ui
argument_list|,
name|prod_uf
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Done, round it correctly.  Prod_ui contains the 			 * fraction. 			 */
if|if
condition|(
name|prod_uf
operator|&
literal|0x80000000
condition|)
name|prod_ui
operator|++
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|date_ui
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|date_ui
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|prod_ui
expr_stmt|;
comment|/* 			 * date_ui is integral part, tmp is fraction. 			 */
block|}
else|else
block|{
specifier|register
name|u_long
name|prod_ovr
decl_stmt|;
specifier|register
name|u_long
name|prod_ui
decl_stmt|;
specifier|register
name|u_long
name|prod_uf
decl_stmt|;
specifier|register
name|u_long
name|highbits
decl_stmt|;
name|prod_ovr
operator|=
name|prod_ui
operator|=
name|prod_uf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|highbits
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* sign extend */
else|else
name|highbits
operator|=
literal|0
expr_stmt|;
comment|/* 			 * This code knows the low order bit in 0.1 is zero 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NZPOBITS
condition|;
name|i
operator|++
control|)
block|{
name|M_LSHIFT3
argument_list|(
name|highbits
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZEROPTONE
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|M_ADD3
argument_list|(
name|prod_ovr
argument_list|,
name|prod_uf
argument_list|,
name|prod_ui
argument_list|,
name|highbits
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prod_uf
operator|&
literal|0x80000000
condition|)
name|M_ADDUF
argument_list|(
name|prod_ovr
argument_list|,
name|prod_ui
argument_list|,
operator|(
name|u_long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|date_ui
operator|=
name|prod_ovr
expr_stmt|;
name|tmp
operator|=
name|prod_ui
expr_stmt|;
block|}
block|}
comment|/* 	 * At this point we have the mean offset, with the integral 	 * part in date_ui and the fractional part in tmp.  Store 	 * it in the structure. 	 */
name|i
operator|=
name|second
operator|-
literal|32
expr_stmt|;
comment|/* gives a value 0 through 8 */
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|up
operator|->
name|expect
condition|)
block|{
comment|/* 		 * This shouldn't actually happen, but might if a single 		 * bit error occurred in the code which fooled us. 		 * Throw away all previous data. 		 */
name|up
operator|->
name|expect
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|haveoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|flags
operator|&
name|CHUTIMERSET
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|up
operator|->
name|flags
operator|&=
operator|~
name|CHUTIMERSET
expr_stmt|;
block|}
block|}
name|up
operator|->
name|offsets
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
name|date_ui
expr_stmt|;
name|up
operator|->
name|offsets
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|tmp
expr_stmt|;
name|up
operator|->
name|rectimes
index|[
name|i
index|]
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|up
operator|->
name|reftimes
index|[
name|i
index|]
operator|=
name|reftime
expr_stmt|;
name|up
operator|->
name|expect
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|up
operator|->
name|haveoffset
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|expect
operator|>=
name|NCHUCODES
condition|)
block|{
comment|/* 		 * Got a full second's worth.  Dequeue timer and 		 * process this. 		 */
if|if
condition|(
name|up
operator|->
name|flags
operator|&
name|CHUTIMERSET
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|up
operator|->
name|flags
operator|&=
operator|~
name|CHUTIMERSET
expr_stmt|;
block|}
name|chu_process
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|up
operator|->
name|flags
operator|&
name|CHUTIMERSET
operator|)
condition|)
block|{
comment|/* 		 * Try to take an interrupt sometime after the 		 * 42 second mark (leaves an extra 2 seconds for 		 * slop).  Round it up to an even multiple of 		 * 4 seconds. 		 */
name|up
operator|->
name|chutimer
operator|.
name|event_time
operator|=
name|current_time
operator|+
call|(
name|u_long
call|)
argument_list|(
literal|10
operator|-
name|i
argument_list|)
operator|+
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|up
operator|->
name|chutimer
operator|.
name|event_time
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|up
operator|->
name|flags
operator||=
name|CHUTIMERSET
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_timeout - process a timeout event  */
end_comment

begin_function
specifier|static
name|void
name|chu_timeout
parameter_list|(
name|fakepeer
parameter_list|)
name|struct
name|peer
modifier|*
name|fakepeer
decl_stmt|;
block|{
comment|/* 	 * If we got here it means we received some time codes 	 * but didn't get the one which should have arrived on 	 * the 39th second.  Process what we have. 	 */
operator|(
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|fakepeer
operator|)
operator|->
name|flags
operator|&=
operator|~
name|CHUTIMERSET
expr_stmt|;
name|chu_process
argument_list|(
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|fakepeer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_process - process the raw offset estimates we have and pass  *		 the results on to the NTP clock filters.  */
end_comment

begin_function
specifier|static
name|void
name|chu_process
parameter_list|(
name|up
parameter_list|)
specifier|register
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s_fp
name|bestoff
decl_stmt|;
name|s_fp
name|tmpoff
decl_stmt|;
name|u_fp
name|dispersion
decl_stmt|;
name|int
name|imax
decl_stmt|;
comment|/* 	 * The most positive offset. 	 */
name|peer
operator|=
name|up
operator|->
name|peer
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|imax
operator|=
name|NCHUCODES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|up
operator|->
name|haveoffset
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
if|if
condition|(
name|i
operator|<
name|imax
operator|||
name|L_ISGEQ
argument_list|(
operator|&
name|up
operator|->
name|offsets
index|[
name|i
index|]
argument_list|,
operator|&
name|up
operator|->
name|offsets
index|[
name|imax
index|]
argument_list|)
condition|)
name|imax
operator|=
name|i
expr_stmt|;
comment|/* 	 * The most positive estimate is our best bet.  Go through 	 * the list again computing the dispersion. 	 */
name|bestoff
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|up
operator|->
name|offsets
index|[
name|imax
index|]
argument_list|)
expr_stmt|;
name|dispersion
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCODES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|up
operator|->
name|haveoffset
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|tmpoff
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|up
operator|->
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dispersion
operator|+=
operator|(
name|bestoff
operator|-
name|tmpoff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dispersion
operator|+=
name|CHUDELAYPENALTY
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|,
operator|&
name|up
operator|->
name|offsets
index|[
name|imax
index|]
argument_list|,
literal|0
argument_list|,
name|dispersion
argument_list|,
operator|&
name|up
operator|->
name|rectimes
index|[
name|imax
index|]
argument_list|,
operator|&
name|up
operator|->
name|rectimes
index|[
name|imax
index|]
argument_list|,
name|pp
operator|->
name|leap
argument_list|)
expr_stmt|;
comment|/* 	 * Zero out unit for next code series 	 */
name|up
operator|->
name|haveoffset
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|expect
operator|=
literal|0
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|chu_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

