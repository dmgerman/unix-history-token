begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_control.c - respond to control messages and send async traps  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Structure to hold request procedure information  */
end_comment

begin_define
define|#
directive|define
name|NOAUTH
value|0
end_define

begin_define
define|#
directive|define
name|AUTH
value|1
end_define

begin_define
define|#
directive|define
name|NO_REQUEST
value|(-1)
end_define

begin_struct
struct|struct
name|ctl_proc
block|{
name|short
name|control_code
decl_stmt|;
comment|/* defined request code */
name|u_short
name|flags
decl_stmt|;
comment|/* flags word */
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
comment|/* routine to handle request */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Only one flag.  Authentication required or not.  */
end_comment

begin_define
define|#
directive|define
name|NOAUTH
value|0
end_define

begin_define
define|#
directive|define
name|AUTH
value|1
end_define

begin_comment
comment|/*  * Request processing routines  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ctl_error
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|ctlclkstatus
name|P
argument_list|(
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_flushpkt
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putdata
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putstr
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putlfp
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ctl_putulfp
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ctl_putfp
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|s_fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putufp
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putuint
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|U_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_puthex
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|U_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putint
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putts
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putadr
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|U_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putid
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putarray
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|s_fp
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putsys
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ctl_putpeer
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ctl_putclock
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
modifier|*
name|ctl_getitem
name|P
argument_list|(
operator|(
expr|struct
name|ctl_var
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|count_var
name|P
argument_list|(
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|control_unspec
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_status
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_variables
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_variables
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_clock_status
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_clock_status
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_trap
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unset_trap
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_trap
modifier|*
name|ctlfindtrap
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_proc
name|control_codes
index|[]
init|=
block|{
block|{
name|CTL_OP_UNSPEC
block|,
name|NOAUTH
block|,
name|control_unspec
block|}
block|,
block|{
name|CTL_OP_READSTAT
block|,
name|NOAUTH
block|,
name|read_status
block|}
block|,
block|{
name|CTL_OP_READVAR
block|,
name|NOAUTH
block|,
name|read_variables
block|}
block|,
block|{
name|CTL_OP_WRITEVAR
block|,
name|AUTH
block|,
name|write_variables
block|}
block|,
block|{
name|CTL_OP_READCLOCK
block|,
name|NOAUTH
block|,
name|read_clock_status
block|}
block|,
block|{
name|CTL_OP_WRITECLOCK
block|,
name|NOAUTH
block|,
name|write_clock_status
block|}
block|,
block|{
name|CTL_OP_SETTRAP
block|,
name|NOAUTH
block|,
name|set_trap
block|}
block|,
block|{
name|CTL_OP_UNSETTRAP
block|,
name|NOAUTH
block|,
name|unset_trap
block|}
block|,
block|{
name|NO_REQUEST
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System variable values.  The array can be indexed by  * the variable index to find the textual name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
name|sys_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CS_LEAP
block|,
name|RW
block|,
literal|"leap"
block|}
block|,
comment|/* 1 */
block|{
name|CS_STRATUM
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 2 */
block|{
name|CS_PRECISION
block|,
name|RO
block|,
literal|"precision"
block|}
block|,
comment|/* 3 */
block|{
name|CS_ROOTDELAY
block|,
name|RO
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 4 */
block|{
name|CS_ROOTDISPERSION
block|,
name|RO
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 5 */
block|{
name|CS_REFID
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 6 */
block|{
name|CS_REFTIME
block|,
name|RO
block|,
literal|"reftime"
block|}
block|,
comment|/* 7 */
block|{
name|CS_POLL
block|,
name|RO
block|,
literal|"poll"
block|}
block|,
comment|/* 8 */
block|{
name|CS_PEERID
block|,
name|RO
block|,
literal|"peer"
block|}
block|,
comment|/* 9 */
block|{
name|CS_OFFSET
block|,
name|RO
block|,
literal|"phase"
block|}
block|,
comment|/* 10 */
block|{
name|CS_DRIFT
block|,
name|RO
block|,
literal|"freq"
block|}
block|,
comment|/* 11 */
block|{
name|CS_COMPLIANCE
block|,
name|RO
block|,
literal|"compliance"
block|}
block|,
comment|/* 12 */
block|{
name|CS_CLOCK
block|,
name|RO
block|,
literal|"clock"
block|}
block|,
comment|/* 13 */
block|{
name|CS_LEAPIND
block|,
name|RW
block|,
literal|"leapindicator"
block|}
block|,
comment|/* 14 */
block|{
name|CS_LEAPWARNING
block|,
name|RW
block|,
literal|"leapwarning"
block|}
block|,
comment|/* 15 */
block|{
name|CS_PROCESSOR
block|,
name|RO
block|,
literal|"processor"
block|}
block|,
comment|/* 16 */
block|{
name|CS_SYSTEM
block|,
name|RO
block|,
literal|"system"
block|}
block|,
comment|/* 17 */
block|{
name|CS_KEYID
block|,
name|RO
block|,
literal|"keyid"
block|}
block|,
comment|/* 18 */
block|{
name|CS_REFSKEW
block|,
name|RO
block|,
literal|"refskew"
block|}
block|,
comment|/* 19 */
block|{
name|CS_VARLIST
block|,
name|RO
block|,
literal|"sys_var_list"
block|}
block|,
comment|/* 20 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
modifier|*
name|ext_sys_var
init|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System variables we print by default (in fuzzball order, more-or-less)  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|def_sys_var
index|[]
init|=
block|{
name|CS_SYSTEM
block|,
name|CS_LEAP
block|,
name|CS_STRATUM
block|,
name|CS_ROOTDELAY
block|,
name|CS_ROOTDISPERSION
block|,
name|CS_PEERID
block|,
name|CS_REFID
block|,
name|CS_REFTIME
block|,
name|CS_POLL
block|,
name|CS_CLOCK
block|,
name|CS_OFFSET
block|,
name|CS_DRIFT
block|,
name|CS_COMPLIANCE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variable list  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
name|peer_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CP_CONFIG
block|,
name|RO
block|,
literal|"config"
block|}
block|,
comment|/* 1 */
block|{
name|CP_AUTHENABLE
block|,
name|RO
block|,
literal|"authenable"
block|}
block|,
comment|/* 2 */
block|{
name|CP_AUTHENTIC
block|,
name|RO
block|,
literal|"authentic"
block|}
block|,
comment|/* 3 */
block|{
name|CP_SRCADR
block|,
name|RO
block|,
literal|"srcadr"
block|}
block|,
comment|/* 4 */
block|{
name|CP_SRCPORT
block|,
name|RO
block|,
literal|"srcport"
block|}
block|,
comment|/* 5 */
block|{
name|CP_DSTADR
block|,
name|RO
block|,
literal|"dstadr"
block|}
block|,
comment|/* 6 */
block|{
name|CP_DSTPORT
block|,
name|RO
block|,
literal|"dstport"
block|}
block|,
comment|/* 7 */
block|{
name|CP_LEAP
block|,
name|RO
block|,
literal|"leap"
block|}
block|,
comment|/* 8 */
block|{
name|CP_HMODE
block|,
name|RO
block|,
literal|"hmode"
block|}
block|,
comment|/* 9 */
block|{
name|CP_STRATUM
block|,
name|RO
block|,
literal|"stratum"
block|}
block|,
comment|/* 10 */
block|{
name|CP_PPOLL
block|,
name|RO
block|,
literal|"ppoll"
block|}
block|,
comment|/* 11 */
block|{
name|CP_HPOLL
block|,
name|RO
block|,
literal|"hpoll"
block|}
block|,
comment|/* 12 */
block|{
name|CP_PRECISION
block|,
name|RO
block|,
literal|"precision"
block|}
block|,
comment|/* 13 */
block|{
name|CP_ROOTDELAY
block|,
name|RO
block|,
literal|"rootdelay"
block|}
block|,
comment|/* 14 */
block|{
name|CP_ROOTDISPERSION
block|,
name|RO
block|,
literal|"rootdispersion"
block|}
block|,
comment|/* 15 */
block|{
name|CP_REFID
block|,
name|RO
block|,
literal|"refid"
block|}
block|,
comment|/* 16 */
block|{
name|CP_REFTIME
block|,
name|RO
block|,
literal|"reftime"
block|}
block|,
comment|/* 17 */
block|{
name|CP_ORG
block|,
name|RO
block|,
literal|"org"
block|}
block|,
comment|/* 18 */
block|{
name|CP_REC
block|,
name|RO
block|,
literal|"rec"
block|}
block|,
comment|/* 19 */
block|{
name|CP_XMT
block|,
name|RO
block|,
literal|"xmt"
block|}
block|,
comment|/* 20 */
block|{
name|CP_REACH
block|,
name|RO
block|,
literal|"reach"
block|}
block|,
comment|/* 21 */
block|{
name|CP_VALID
block|,
name|RO
block|,
literal|"valid"
block|}
block|,
comment|/* 22 */
block|{
name|CP_TIMER
block|,
name|RO
block|,
literal|"timer"
block|}
block|,
comment|/* 23 */
block|{
name|CP_DELAY
block|,
name|RO
block|,
literal|"delay"
block|}
block|,
comment|/* 24 */
block|{
name|CP_OFFSET
block|,
name|RO
block|,
literal|"offset"
block|}
block|,
comment|/* 25 */
block|{
name|CP_DISPERSION
block|,
name|RO
block|,
literal|"dispersion"
block|}
block|,
comment|/* 26 */
block|{
name|CP_KEYID
block|,
name|RO
block|,
literal|"keyid"
block|}
block|,
comment|/* 27 */
block|{
name|CP_FILTDELAY
block|,
name|RO
block|,
literal|"filtdelay"
block|}
block|,
comment|/* 28 */
block|{
name|CP_FILTOFFSET
block|,
name|RO
block|,
literal|"filtoffset"
block|}
block|,
comment|/* 29 */
block|{
name|CP_PMODE
block|,
name|RO
block|,
literal|"pmode"
block|}
block|,
comment|/* 30 */
block|{
name|CP_RECEIVED
block|,
name|RO
block|,
literal|"received"
block|}
block|,
comment|/* 31 */
block|{
name|CP_SENT
block|,
name|RO
block|,
literal|"sent"
block|}
block|,
comment|/* 32 */
block|{
name|CP_FILTERROR
block|,
name|RO
block|,
literal|"filterror"
block|}
block|,
comment|/* 33 */
block|{
name|CP_FLASH
block|,
name|RO
block|,
literal|"flash"
block|}
block|,
comment|/* 34 */
block|{
name|CP_DISP
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 35 */
block|{
name|CP_VARLIST
block|,
name|RO
block|,
literal|"peer_var_list"
block|}
block|,
comment|/* 36 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Peer variables we print by default  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|def_peer_var
index|[]
init|=
block|{
name|CP_SRCADR
block|,
name|CP_SRCPORT
block|,
name|CP_DSTADR
block|,
name|CP_DSTPORT
block|,
name|CP_KEYID
block|,
name|CP_STRATUM
block|,
name|CP_PRECISION
block|,
name|CP_ROOTDELAY
block|,
name|CP_ROOTDISPERSION
block|,
name|CP_REFID
block|,
name|CP_REFTIME
block|,
name|CP_DELAY
block|,
name|CP_OFFSET
block|,
name|CP_DISPERSION
block|,
name|CP_REACH
block|,
name|CP_VALID
block|,
name|CP_HMODE
block|,
name|CP_PMODE
block|,
name|CP_HPOLL
block|,
name|CP_PPOLL
block|,
name|CP_LEAP
block|,
name|CP_FLASH
block|,
name|CP_ORG
block|,
name|CP_REC
block|,
name|CP_XMT
block|,
name|CP_FILTDELAY
block|,
name|CP_FILTOFFSET
block|,
name|CP_FILTERROR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * Clock variable list  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ctl_var
name|clock_var
index|[]
init|=
block|{
block|{
literal|0
block|,
name|PADDING
block|,
literal|""
block|}
block|,
comment|/* 0 */
block|{
name|CC_TYPE
block|,
name|RO
block|,
literal|"type"
block|}
block|,
comment|/* 1 */
block|{
name|CC_TIMECODE
block|,
name|RO
block|,
literal|"timecode"
block|}
block|,
comment|/* 2 */
block|{
name|CC_POLL
block|,
name|RO
block|,
literal|"poll"
block|}
block|,
comment|/* 3 */
block|{
name|CC_NOREPLY
block|,
name|RO
block|,
literal|"noreply"
block|}
block|,
comment|/* 4 */
block|{
name|CC_BADFORMAT
block|,
name|RO
block|,
literal|"badformat"
block|}
block|,
comment|/* 5 */
block|{
name|CC_BADDATA
block|,
name|RO
block|,
literal|"baddata"
block|}
block|,
comment|/* 6 */
block|{
name|CC_FUDGETIME1
block|,
name|RO
block|,
literal|"fudgetime1"
block|}
block|,
comment|/* 7 */
block|{
name|CC_FUDGETIME2
block|,
name|RO
block|,
literal|"fudgetime2"
block|}
block|,
comment|/* 8 */
block|{
name|CC_FUDGEVAL1
block|,
name|RO
block|,
literal|"fudgeval1"
block|}
block|,
comment|/* 9 */
block|{
name|CC_FUDGEVAL2
block|,
name|RO
block|,
literal|"fudgeval2"
block|}
block|,
comment|/* 10 */
block|{
name|CC_FLAGS
block|,
name|RO
block|,
literal|"flags"
block|}
block|,
comment|/* 11 */
block|{
name|CC_DEVICE
block|,
name|RO
block|,
literal|"device"
block|}
block|,
comment|/* 12 */
block|{
name|CC_VARLIST
block|,
name|RO
block|,
literal|"clock_var_list"
block|}
block|,
comment|/* 13 */
block|{
literal|0
block|,
name|EOV
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clock variables printed by default  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|def_clock_var
index|[]
init|=
block|{
name|CC_DEVICE
block|,
name|CC_TYPE
block|,
comment|/* won't be output if device= known */
name|CC_TIMECODE
block|,
name|CC_POLL
block|,
name|CC_NOREPLY
block|,
name|CC_BADFORMAT
block|,
name|CC_BADDATA
block|,
name|CC_FUDGETIME1
block|,
name|CC_FUDGETIME2
block|,
name|CC_FUDGEVAL1
block|,
name|CC_FUDGEVAL2
block|,
name|CC_FLAGS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * System and processor definitions.  These will change for the gizmo board.  */
end_comment

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|utsname
name|utsname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Trap structures.  We only allow a few of these, and send  * a copy of each async message to each live one.  Traps time  * out after an hour, it is up to the trap receipient to  * keep resetting it to avoid being timed out.  */
end_comment

begin_comment
comment|/* ntp_request.c */
end_comment

begin_decl_stmt
name|struct
name|ctl_trap
name|ctl_trap
index|[
name|CTL_MAXTRAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_ctl_traps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Type bits, for ctlsettrap() call.  */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_CONFIG
value|0
end_define

begin_comment
comment|/* used by configuration code */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_PRIO
value|1
end_define

begin_comment
comment|/* priority trap */
end_comment

begin_define
define|#
directive|define
name|TRAP_TYPE_NONPRIO
value|2
end_define

begin_comment
comment|/* nonpriority trap */
end_comment

begin_comment
comment|/*  * List relating reference clock types to control message time sources.  * Index by the reference clock type.  * This list will only be used iff the reference clock driver doesn't  * set peer->sstclktype to something different than CTL_SST_TS_UNSPEC.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|clocktypes
index|[]
init|=
block|{
name|CTL_SST_TS_NTP
block|,
comment|/* REFCLK_NONE */
name|CTL_SST_TS_UNSPEC
block|,
comment|/* REFCLK_LOCALCLOCK */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_GPS_TRAK */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_WWV_PST */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_WWVB_SPECTRACOM */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GOES_TRUETIME */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GOES_TRAK */
name|CTL_SST_TS_HF
block|,
comment|/* REFCLK_CHU */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLOCK_PARSE - default value - driver supplies actual value in peer->sstclktype */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_WWVB_SPECTRACOM_HP */
name|CTL_SST_TS_UHF
block|,
comment|/* REFCLK_GPS_AS2201 */
name|CTL_SST_TS_LF
block|,
comment|/* REFCLK_OMEGA_TRUETIME */
name|CTL_SST_TS_UNSPEC
block|,
comment|/* Future expansion */
name|CTL_SST_TS_UNSPEC
block|,
comment|/* Future expansion */
name|CTL_SST_TS_UNSPEC
block|,
comment|/* Future expansion */
name|CTL_SST_TS_UNSPEC
comment|/* Future expansion */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keyid used for authenticating write requests.  */
end_comment

begin_decl_stmt
name|U_LONG
name|ctl_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We keep track of the last error reported by the system internally  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|ctl_sys_last_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ctl_sys_num_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistic counters to keep track of requests and responses.  */
end_comment

begin_decl_stmt
name|U_LONG
name|ctltimereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time stats reset */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlreq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of requests we've received */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlbadpkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bad control packets */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlresponses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of resp packets sent with data */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlfrags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fragments sent */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlerrors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of error responses sent */
end_comment

begin_decl_stmt
name|U_LONG
name|numctltooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of too short input packets */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlinputresp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of responses on input */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlinputfrag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fragments on input */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlinputerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with err bit set */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlbadoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with nonzero offset */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlbadversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input pkts with unknown version */
end_comment

begin_decl_stmt
name|U_LONG
name|numctldatatooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data too short for count */
end_comment

begin_decl_stmt
name|U_LONG
name|numctlbadop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bad op code found in packet */
end_comment

begin_decl_stmt
name|U_LONG
name|numasyncmsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of async messages we've sent */
end_comment

begin_comment
comment|/*  * Imported from the I/O module  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the main routines  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|assoc_hash
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pps_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag for 1-pps signal present */
end_comment

begin_comment
comment|/*  * Importations from the protocol module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_fp
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_fp
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|U_LONG
name|sys_refid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|l_fp
name|sys_reftime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|l_fp
name|sys_refskew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|sys_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the loop filter module  */
end_comment

begin_decl_stmt
specifier|extern
name|l_fp
name|last_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_fp
name|drift_comp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|time_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the leap module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|leap_indicator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|leap_warning
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Response packet used by these routines.  Also some state information  * so that we can handle packet formatting within a common set of  * subroutines.  Note we try to enter data in place whenever possible,  * but the need to set the more bit correctly means we occasionally  * use the extra buffer and copy.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ntp_control
name|rpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|res_associd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|res_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|datapt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|dataend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datalinelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datanotbinflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|rmt_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|lcl_inter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_authenticate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|res_authokay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_LONG
name|res_keyid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXDATALINELEN
value|(72)
end_define

begin_decl_stmt
specifier|static
name|u_char
name|res_async
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 if this is async trap response */
end_comment

begin_comment
comment|/*  * Pointers for saving state when decoding request packets  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reqpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reqend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_control - initialize request data  */
end_comment

begin_function
name|void
name|init_control
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
expr_stmt|;
name|ctl_clr_stats
argument_list|()
expr_stmt|;
name|ctl_auth_keyid
operator|=
literal|0
expr_stmt|;
name|ctl_sys_last_event
operator|=
name|EVNT_UNSPEC
expr_stmt|;
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAXTRAPS
condition|;
name|i
operator|++
control|)
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_error - send an error response for the current request  */
end_comment

begin_function
specifier|static
name|void
name|ctl_error
parameter_list|(
name|errcode
parameter_list|)
name|int
name|errcode
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"sending control error %d\n"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * fill in the fields.  We assume rpkt.sequence and rpkt.associd 	 * have already been filled in. 	 */
name|rpkt
operator|.
name|r_m_e_op
operator|=
name|CTL_RESPONSE
operator||
name|CTL_ERROR
operator||
operator|(
name|res_opcode
operator|&
name|CTL_OP_MASK
operator|)
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
operator|(
name|errcode
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * send packet and bump counters 	 */
if|if
condition|(
name|res_authenticate
condition|)
block|{
name|int
name|maclen
decl_stmt|;
operator|*
operator|(
name|U_LONG
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rpkt
operator|+
name|CTL_HEADER_LEN
operator|)
operator|=
name|htonl
argument_list|(
name|res_keyid
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|CTL_HEADER_LEN
argument_list|)
expr_stmt|;
block|}
name|numctlerrors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process_control - process an incoming control message  */
end_comment

begin_decl_stmt
name|void
name|process_control
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ntp_control
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|int
name|req_count
decl_stmt|;
specifier|register
name|int
name|req_data
decl_stmt|;
specifier|register
name|struct
name|ctl_proc
modifier|*
name|cc
decl_stmt|;
name|int
name|properlen
decl_stmt|;
name|int
name|maclen
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"in process_control()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Save the addresses for error responses 	 */
name|numctlreq
operator|++
expr_stmt|;
name|rmt_addr
operator|=
operator|&
name|rbufp
operator|->
name|recv_srcadr
expr_stmt|;
name|lcl_inter
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|ntp_control
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
comment|/* 	 * If the length is less than required for the header, or 	 * it is a response or a fragment, ignore this. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|CTL_HEADER_LEN
operator|||
name|pkt
operator|->
name|r_m_e_op
operator|&
operator|(
name|CTL_RESPONSE
operator||
name|CTL_MORE
operator||
name|CTL_ERROR
operator|)
operator|||
name|pkt
operator|->
name|offset
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"invalid format in control packet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|<
name|CTL_HEADER_LEN
condition|)
name|numctltooshort
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|r_m_e_op
operator|&
name|CTL_RESPONSE
condition|)
name|numctlinputresp
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|r_m_e_op
operator|&
name|CTL_MORE
condition|)
name|numctlinputfrag
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|r_m_e_op
operator|&
name|CTL_ERROR
condition|)
name|numctlinputerr
operator|++
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|offset
operator|!=
literal|0
condition|)
name|numctlbadoffset
operator|++
expr_stmt|;
return|return;
block|}
name|res_version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_version
operator|>
name|NTP_VERSION
operator|||
name|res_version
operator|<
name|NTP_OLDVERSION
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"unknown version %d in control packet\n"
argument_list|,
name|res_version
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|numctlbadversion
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pull enough data from the packet to make intelligent responses 	 */
name|rpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|res_version
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|res_opcode
operator|=
name|pkt
operator|->
name|r_m_e_op
expr_stmt|;
name|rpkt
operator|.
name|sequence
operator|=
name|pkt
operator|->
name|sequence
expr_stmt|;
name|rpkt
operator|.
name|associd
operator|=
name|pkt
operator|->
name|associd
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|res_offset
operator|=
literal|0
expr_stmt|;
name|res_associd
operator|=
name|htons
argument_list|(
name|pkt
operator|->
name|associd
argument_list|)
expr_stmt|;
name|res_async
operator|=
literal|0
expr_stmt|;
name|res_authenticate
operator|=
literal|0
expr_stmt|;
name|res_keyid
operator|=
literal|0
expr_stmt|;
name|res_authokay
operator|=
literal|0
expr_stmt|;
name|req_count
operator|=
operator|(
name|int
operator|)
name|htons
argument_list|(
name|pkt
operator|->
name|count
argument_list|)
expr_stmt|;
name|datanotbinflag
operator|=
literal|0
expr_stmt|;
name|datalinelen
operator|=
literal|0
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|data
expr_stmt|;
name|dataend
operator|=
operator|&
operator|(
name|rpkt
operator|.
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
operator|)
expr_stmt|;
comment|/* 	 * We're set up now.  Make sure we've got at least 	 * enough incoming data space to match the count. 	 */
name|req_data
operator|=
name|rbufp
operator|->
name|recv_length
operator|-
name|CTL_HEADER_LEN
expr_stmt|;
if|if
condition|(
name|req_data
operator|<
name|req_count
operator|||
name|rbufp
operator|->
name|recv_length
operator|&
literal|0x3
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
name|numctldatatooshort
operator|++
expr_stmt|;
return|return;
block|}
name|properlen
operator|=
name|req_count
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
operator|&&
operator|(
name|rbufp
operator|->
name|recv_length
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Packet length %d unrounded\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* round up proper len to a 8 octet boundary */
name|properlen
operator|=
operator|(
name|properlen
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|rbufp
operator|->
name|recv_length
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|maclen
operator|=
operator|(
name|rbufp
operator|->
name|recv_length
operator|-
name|properlen
operator|)
operator|)
operator|>=
name|MIN_MAC_LEN
operator|&&
name|maclen
operator|<=
name|MAX_MAC_LEN
condition|)
block|{
name|res_authenticate
operator|=
literal|1
expr_stmt|;
name|res_keyid
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|U_LONG
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|pkt
operator|+
name|properlen
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"recv_len %d, properlen %d, wants auth with keyid %d, MAC length=%d\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|properlen
argument_list|,
name|res_keyid
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|res_keyid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"keyid %lu unknown\n"
argument_list|,
name|res_keyid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|authdecrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|pkt
argument_list|,
name|rbufp
operator|->
name|recv_length
operator|-
name|maclen
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"authenticated okay\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res_authokay
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"authentication failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res_keyid
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Set up translate pointers 	 */
name|reqpt
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt
operator|->
name|data
expr_stmt|;
name|reqend
operator|=
name|reqpt
operator|+
name|req_count
expr_stmt|;
comment|/* 	 * Look for the opcode processor 	 */
for|for
control|(
name|cc
operator|=
name|control_codes
init|;
name|cc
operator|->
name|control_code
operator|!=
name|NO_REQUEST
condition|;
name|cc
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|->
name|control_code
operator|==
name|res_opcode
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"opcode %d, found command handler\n"
argument_list|,
name|res_opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cc
operator|->
name|flags
operator|==
name|AUTH
operator|&&
operator|(
operator|!
name|res_authokay
operator|||
name|res_keyid
operator|!=
name|ctl_auth_keyid
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
name|cc
operator|->
name|handler
call|)
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Can't find this one, return an error. 	 */
name|numctlbadop
operator|++
expr_stmt|;
name|ctl_error
argument_list|(
name|CERR_BADOP
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * ctlpeerstatus - return a status word for this peer  */
end_comment

begin_function
name|u_short
name|ctlpeerstatus
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|u_short
name|status
decl_stmt|;
name|status
operator|=
name|CTL_PST_SEL_REJECT
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|was_sane
operator|!=
literal|0
condition|)
name|status
operator|=
name|CTL_PST_SEL_SANE
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|correct
operator|!=
literal|0
condition|)
name|status
operator|=
name|CTL_PST_SEL_CORRECT
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|candidate
operator|!=
literal|0
condition|)
name|status
operator|=
name|CTL_PST_SEL_SELCAND
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|select
operator|!=
literal|0
condition|)
name|status
operator|=
name|CTL_PST_SEL_SYNCCAND
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|sys_peer
condition|)
block|{
name|status
operator|=
name|CTL_PST_SEL_DISTSYSPEER
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|synch
operator|<
name|NTP_MAXDISTANCE
condition|)
block|{
name|status
operator|=
name|CTL_PST_SEL_SYSPEER
expr_stmt|;
if|if
condition|(
name|pps_control
condition|)
name|status
operator|=
name|CTL_PST_SEL_PPS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|status
operator||=
name|CTL_PST_CONFIG
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
block|{
name|status
operator||=
name|CTL_PST_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
condition|)
name|status
operator||=
name|CTL_PST_AUTHENTIC
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|reach
operator|!=
literal|0
condition|)
name|status
operator||=
name|CTL_PST_REACH
expr_stmt|;
return|return
operator|(
name|u_short
operator|)
name|CTL_PEER_STATUS
argument_list|(
name|status
argument_list|,
name|peer
operator|->
name|num_events
argument_list|,
name|peer
operator|->
name|last_event
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlclkstatus - return a status word for this clock  */
end_comment

begin_function
specifier|static
name|u_short
name|ctlclkstatus
parameter_list|(
name|clock
parameter_list|)
name|struct
name|refclockstat
modifier|*
name|clock
decl_stmt|;
block|{
return|return
operator|(
call|(
name|u_short
call|)
argument_list|(
name|clock
operator|->
name|currentstatus
argument_list|)
operator|<<
literal|8
operator|)
operator||
call|(
name|u_short
call|)
argument_list|(
name|clock
operator|->
name|lastevent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctlsysstatus - return the system status word  */
end_comment

begin_function
name|u_short
name|ctlsysstatus
parameter_list|()
block|{
specifier|register
name|u_char
name|clock
decl_stmt|;
name|clock
operator|=
name|CTL_SST_TS_UNSPEC
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
if|if
condition|(
name|sys_peer
operator|->
name|sstclktype
operator|!=
name|CTL_SST_TS_UNSPEC
condition|)
name|clock
operator|=
name|sys_peer
operator|->
name|sstclktype
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_peer
operator|->
name|refclktype
operator|<
sizeof|sizeof
argument_list|(
name|clocktypes
argument_list|)
condition|)
name|clock
operator|=
name|clocktypes
index|[
name|sys_peer
operator|->
name|refclktype
index|]
expr_stmt|;
return|return
operator|(
name|u_short
operator|)
name|CTL_SYS_STATUS
argument_list|(
name|sys_leap
argument_list|,
name|clock
argument_list|,
name|ctl_sys_num_events
argument_list|,
name|ctl_sys_last_event
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctl_flushpkt - write out the current packet and prepare  *		  another if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_flushpkt
parameter_list|(
name|more
parameter_list|)
name|int
name|more
decl_stmt|;
block|{
name|int
name|dlen
decl_stmt|;
name|int
name|sendlen
decl_stmt|;
if|if
condition|(
operator|!
name|more
operator|&&
name|datanotbinflag
condition|)
block|{
comment|/* 		 * Big hack, output a trailing \r\n 		 */
operator|*
name|datapt
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|datapt
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
name|dlen
operator|=
name|datapt
operator|-
operator|(
name|u_char
operator|*
operator|)
name|rpkt
operator|.
name|data
expr_stmt|;
name|sendlen
operator|=
name|dlen
operator|+
name|CTL_HEADER_LEN
expr_stmt|;
comment|/* 	 * Pad to a multiple of 32 bits 	 */
while|while
condition|(
name|sendlen
operator|&
literal|0x3
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sendlen
operator|++
expr_stmt|;
block|}
comment|/* 	 * Fill in the packet with the current info 	 */
name|rpkt
operator|.
name|r_m_e_op
operator|=
name|CTL_RESPONSE
operator||
name|more
operator||
operator|(
name|res_opcode
operator|&
name|CTL_OP_MASK
operator|)
expr_stmt|;
name|rpkt
operator|.
name|count
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|dlen
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|offset
operator|=
name|htons
argument_list|(
name|res_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_async
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CTL_MAXTRAPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_flags
operator|&
name|TRAP_INUSE
condition|)
block|{
name|rpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|sys_leap
argument_list|,
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_version
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|sequence
operator|=
name|htons
argument_list|(
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_sequence
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_addr
argument_list|,
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_localaddr
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more
condition|)
name|ctl_trap
index|[
name|i
index|]
operator|.
name|tr_sequence
operator|++
expr_stmt|;
name|numasyncmsgs
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|res_authenticate
condition|)
block|{
name|int
name|maclen
decl_stmt|;
name|int
name|totlen
init|=
name|sendlen
decl_stmt|;
comment|/* 			 *  If we are going to authenticate, then there is 			 *  an additional requirement that the MAC begin on 			 *  a 64 bit boundary. 			 */
while|while
condition|(
name|totlen
operator|&
literal|7
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|totlen
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|U_LONG
operator|*
operator|)
name|datapt
operator|=
name|htonl
argument_list|(
name|res_keyid
argument_list|)
expr_stmt|;
name|maclen
operator|=
name|authencrypt
argument_list|(
name|res_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|totlen
operator|+
name|maclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendpkt
argument_list|(
name|rmt_addr
argument_list|,
name|lcl_inter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|sendlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|more
condition|)
name|numctlfrags
operator|++
expr_stmt|;
else|else
name|numctlresponses
operator|++
expr_stmt|;
block|}
comment|/* 	 * Set us up for another go around. 	 */
name|res_offset
operator|+=
name|dlen
expr_stmt|;
name|datapt
operator|=
operator|(
name|u_char
operator|*
operator|)
name|rpkt
operator|.
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putdata - write data into the packet, fragmenting and  *		 starting another if this one is full.  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putdata
parameter_list|(
name|dp
parameter_list|,
name|dlen
parameter_list|,
name|bin
parameter_list|)
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|int
name|bin
decl_stmt|;
comment|/* set to 1 when data is binary */
block|{
name|int
name|overhead
decl_stmt|;
name|overhead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bin
condition|)
block|{
name|datanotbinflag
operator|=
literal|1
expr_stmt|;
name|overhead
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|datapt
operator|!=
name|rpkt
operator|.
name|data
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|','
expr_stmt|;
name|datalinelen
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dlen
operator|+
name|datalinelen
operator|+
literal|1
operator|)
operator|>=
name|MAXDATALINELEN
condition|)
block|{
operator|*
name|datapt
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|datapt
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|datalinelen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|datapt
operator|++
operator|=
literal|' '
expr_stmt|;
name|datalinelen
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Save room for trailing junk 	 */
if|if
condition|(
name|dlen
operator|+
name|overhead
operator|+
name|datapt
operator|>
name|dataend
condition|)
block|{
comment|/* 		 * Not enough room in this one, flush it out. 		 */
name|ctl_flushpkt
argument_list|(
name|CTL_MORE
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|datapt
argument_list|,
name|dp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|datapt
operator|+=
name|dlen
expr_stmt|;
name|datalinelen
operator|+=
name|dlen
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putstr - write a tagged string into the response packet  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putstr
parameter_list|(
name|tag
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|400
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|-
literal|1
operator|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putlfp - write a tagged, signed l_fp into the response packet  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putlfp
parameter_list|(
name|tag
parameter_list|,
name|ts
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|lfptoms
argument_list|(
name|ts
argument_list|,
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_comment
comment|/*  * ctl_putlfp - write a tagged, unsigned l_fp into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putulfp
parameter_list|(
name|tag
parameter_list|,
name|ts
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|ulfptoms
argument_list|(
name|ts
argument_list|,
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/*  * ctl_putfp - write a tagged s_fp number into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putfp
parameter_list|(
name|tag
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|s_fp
name|fp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|fptoms
argument_list|(
name|fp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putufp - write a tagged u_fp number into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putufp
parameter_list|(
name|tag
parameter_list|,
name|ufp
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|u_fp
name|ufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|ufptoms
argument_list|(
name|ufp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putuint - write a tagged unsigned integer into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putuint
parameter_list|(
name|tag
parameter_list|,
name|uval
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|U_LONG
name|uval
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%u"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_puthex - write a tagged unsigned integer, in hex, into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_puthex
parameter_list|(
name|tag
parameter_list|,
name|uval
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|U_LONG
name|uval
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"0x%lx"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putint - write a tagged signed integer into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putint
parameter_list|(
name|tag
parameter_list|,
name|ival
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|LONG
name|ival
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putts - write a tagged timestamp, in hex, into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putts
parameter_list|(
name|tag
parameter_list|,
name|ts
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"0x%08lx.%08lx"
argument_list|,
name|ts
operator|->
name|l_ui
operator|&
literal|0xffffffffL
argument_list|,
name|ts
operator|->
name|l_uf
operator|&
literal|0xffffffffL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putadr - write a dotted quad IP address into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putadr
parameter_list|(
name|tag
parameter_list|,
name|addr
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|U_LONG
name|addr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|numtoa
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putid - write a tagged clock ID into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putid
parameter_list|(
name|tag
parameter_list|,
name|id
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|cq
operator|=
name|id
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
operator|&&
operator|(
name|cq
operator|-
name|id
operator|)
operator|<
literal|4
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putarray - write a tagged eight element s_fp array into the response  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putarray
parameter_list|(
name|tag
parameter_list|,
name|arr
parameter_list|,
name|start
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|s_fp
modifier|*
name|arr
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ind
decl_stmt|;
name|int
name|len
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
name|cq
operator|=
name|tag
expr_stmt|;
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
comment|/* 	 * Hack.  We know the tag is either filtdelay, filtoffset, 	 * or filterror.  Space over the shorter words one space. 	 */
if|if
condition|(
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|<
literal|11
condition|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
name|ind
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|NTP_SHIFT
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|ind
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|ind
operator|=
literal|1
expr_stmt|;
block|}
name|cq
operator|=
name|fptoms
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cq
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|7
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cq
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cq
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|start
condition|)
do|;
name|ctl_putdata
argument_list|(
name|buffer
argument_list|,
name|cp
operator|-
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_putsys - output a system variable  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putsys
parameter_list|(
name|varid
parameter_list|)
name|int
name|varid
decl_stmt|;
block|{
name|l_fp
name|tmp
decl_stmt|;
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CS_LEAP
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_LEAP
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|sys_leap
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_STRATUM
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_STRATUM
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|sys_stratum
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PRECISION
case|:
name|ctl_putint
argument_list|(
name|sys_var
index|[
name|CS_PRECISION
index|]
operator|.
name|text
argument_list|,
operator|(
name|LONG
operator|)
name|sys_precision
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ROOTDELAY
case|:
name|ctl_putfp
argument_list|(
name|sys_var
index|[
name|CS_ROOTDELAY
index|]
operator|.
name|text
argument_list|,
name|sys_rootdelay
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_ROOTDISPERSION
case|:
name|ctl_putufp
argument_list|(
name|sys_var
index|[
name|CS_ROOTDISPERSION
index|]
operator|.
name|text
argument_list|,
name|sys_rootdispersion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFID
case|:
if|if
condition|(
name|sys_stratum
operator|<=
literal|1
condition|)
name|ctl_putid
argument_list|(
name|sys_var
index|[
name|CS_REFID
index|]
operator|.
name|text
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sys_refid
argument_list|)
expr_stmt|;
else|else
name|ctl_putadr
argument_list|(
name|sys_var
index|[
name|CS_REFID
index|]
operator|.
name|text
argument_list|,
name|sys_refid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFTIME
case|:
name|ctl_putts
argument_list|(
name|sys_var
index|[
name|CS_REFTIME
index|]
operator|.
name|text
argument_list|,
operator|&
name|sys_reftime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_POLL
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_POLL
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|sys_poll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PEERID
case|:
if|if
condition|(
name|sys_peer
operator|==
name|NULL
condition|)
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERID
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_PEERID
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|sys_peer
operator|->
name|associd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_OFFSET
case|:
name|ctl_putlfp
argument_list|(
name|sys_var
index|[
name|CS_OFFSET
index|]
operator|.
name|text
argument_list|,
operator|&
name|last_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_DRIFT
case|:
name|ctl_putfp
argument_list|(
name|sys_var
index|[
name|CS_DRIFT
index|]
operator|.
name|text
argument_list|,
name|drift_comp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_COMPLIANCE
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_COMPLIANCE
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|time_constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_CLOCK
case|:
name|get_systime
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|ctl_putts
argument_list|(
name|sys_var
index|[
name|CS_CLOCK
index|]
operator|.
name|text
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_LEAPIND
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_LEAPIND
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|leap_indicator
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_LEAPWARNING
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_LEAPWARNING
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|leap_warning
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_PROCESSOR
case|:
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_PROCESSOR
index|]
operator|.
name|text
argument_list|,
name|utsname
operator|.
name|machine
argument_list|,
name|strlen
argument_list|(
name|utsname
operator|.
name|machine
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_SYSTEM
case|:
name|ctl_putstr
argument_list|(
name|sys_var
index|[
name|CS_SYSTEM
index|]
operator|.
name|text
argument_list|,
name|utsname
operator|.
name|sysname
argument_list|,
name|strlen
argument_list|(
name|utsname
operator|.
name|sysname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_KEYID
case|:
name|ctl_putuint
argument_list|(
name|sys_var
index|[
name|CS_KEYID
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_REFSKEW
case|:
name|ctl_putlfp
argument_list|(
name|sys_var
index|[
name|CS_REFSKEW
index|]
operator|.
name|text
argument_list|,
operator|&
name|sys_refskew
argument_list|)
expr_stmt|;
break|break;
case|case
name|CS_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|ss
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|sys_var
index|[
name|CS_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|be
condition|)
break|break;
comment|/* really long var name 8-( - Killer */
name|strcpy
argument_list|(
name|s
argument_list|,
name|sys_var
index|[
name|CS_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|sys_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|ext_sys_var
init|;
name|k
operator|&&
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|ss
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
continue|continue;
while|while
condition|(
operator|*
name|ss
operator|&&
operator|*
name|ss
operator|!=
literal|'='
condition|)
name|ss
operator|++
expr_stmt|;
name|i
operator|=
name|ss
operator|-
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
name|s
operator|-
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * ctl_putpeer - output a peer variable  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putpeer
parameter_list|(
name|varid
parameter_list|,
name|peer
parameter_list|)
name|int
name|varid
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CP_CONFIG
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_CONFIG
index|]
operator|.
name|text
argument_list|,
call|(
name|U_LONG
call|)
argument_list|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENABLE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_AUTHENABLE
index|]
operator|.
name|text
argument_list|,
call|(
name|U_LONG
call|)
argument_list|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_AUTHENTIC
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_AUTHENTIC
index|]
operator|.
name|text
argument_list|,
call|(
name|U_LONG
call|)
argument_list|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_AUTHENTIC
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCADR
case|:
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_SRCADR
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SRCPORT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_SRCPORT
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|ntohs
argument_list|(
name|peer
operator|->
name|srcadr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DSTADR
case|:
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_DSTADR
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DSTPORT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_DSTPORT
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|ntohs
argument_list|(
name|peer
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_LEAP
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_LEAP
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|leap
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HMODE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_HMODE
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|hmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_STRATUM
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_STRATUM
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PPOLL
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_PPOLL
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|ppoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_HPOLL
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_HPOLL
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PRECISION
case|:
name|ctl_putint
argument_list|(
name|peer_var
index|[
name|CP_PRECISION
index|]
operator|.
name|text
argument_list|,
operator|(
name|LONG
operator|)
name|peer
operator|->
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ROOTDELAY
case|:
name|ctl_putfp
argument_list|(
name|peer_var
index|[
name|CP_ROOTDELAY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ROOTDISPERSION
case|:
name|ctl_putufp
argument_list|(
name|peer_var
index|[
name|CP_ROOTDISPERSION
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|rootdispersion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REFID
case|:
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
condition|)
name|ctl_putadr
argument_list|(
name|peer_var
index|[
name|CP_REFID
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|refid
argument_list|)
expr_stmt|;
else|else
name|ctl_putid
argument_list|(
name|peer_var
index|[
name|CP_REFID
index|]
operator|.
name|text
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REFTIME
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_REFTIME
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|reftime
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_ORG
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_ORG
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|org
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REC
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_REC
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_XMT
case|:
name|ctl_putts
argument_list|(
name|peer_var
index|[
name|CP_XMT
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_REACH
case|:
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_REACH
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|reach
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FLASH
case|:
name|ctl_puthex
argument_list|(
name|peer_var
index|[
name|CP_FLASH
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|flash
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_VALID
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_VALID
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_TIMER
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_TIMER
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|event_timer
operator|.
name|event_time
operator|-
name|current_time
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DELAY
case|:
name|ctl_putfp
argument_list|(
name|peer_var
index|[
name|CP_DELAY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|delay
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_OFFSET
case|:
name|ctl_putlfp
argument_list|(
name|peer_var
index|[
name|CP_OFFSET
index|]
operator|.
name|text
argument_list|,
operator|&
name|peer
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_DISPERSION
case|:
name|ctl_putufp
argument_list|(
name|peer_var
index|[
name|CP_DISPERSION
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|dispersion
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_KEYID
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_KEYID
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|keyid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTDELAY
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|CP_FILTDELAY
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|filter_delay
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTOFFSET
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|CP_FILTOFFSET
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|filter_soffset
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_FILTERROR
case|:
name|ctl_putarray
argument_list|(
name|peer_var
index|[
name|CP_FILTERROR
index|]
operator|.
name|text
argument_list|,
operator|(
name|s_fp
operator|*
operator|)
name|peer
operator|->
name|filter_error
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_PMODE
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_PMODE
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|peer
operator|->
name|pmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_RECEIVED
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_RECEIVED
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|received
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_SENT
case|:
name|ctl_putuint
argument_list|(
name|peer_var
index|[
name|CP_SENT
index|]
operator|.
name|text
argument_list|,
name|peer
operator|->
name|sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CP_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|peer_var
index|[
name|CP_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|be
condition|)
break|break;
comment|/* really long var name 8-( - Killer */
name|strcpy
argument_list|(
name|s
argument_list|,
name|peer_var
index|[
name|CP_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|peer_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
name|s
operator|-
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_comment
comment|/*  * ctl_putclock - output clock variables  */
end_comment

begin_function
specifier|static
name|void
name|ctl_putclock
parameter_list|(
name|varid
parameter_list|,
name|clock
parameter_list|,
name|mustput
parameter_list|)
name|int
name|varid
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|clock
decl_stmt|;
name|int
name|mustput
decl_stmt|;
block|{
switch|switch
condition|(
name|varid
condition|)
block|{
case|case
name|CC_TYPE
case|:
if|if
condition|(
name|mustput
operator|||
name|clock
operator|->
name|clockdesc
operator|==
name|NULL
operator|||
operator|*
operator|(
name|clock
operator|->
name|clockdesc
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_TYPE
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|clock
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_TIMECODE
case|:
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|CC_TIMECODE
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|lastcode
argument_list|,
operator|(
name|int
operator|)
name|clock
operator|->
name|lencode
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_POLL
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_POLL
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|clock
operator|->
name|polls
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_NOREPLY
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_NOREPLY
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|noresponse
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_BADFORMAT
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_BADFORMAT
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|badformat
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_BADDATA
case|:
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_BADDATA
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|baddata
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGETIME1
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
operator|)
condition|)
name|ctl_putlfp
argument_list|(
name|clock_var
index|[
name|CC_FUDGETIME1
index|]
operator|.
name|text
argument_list|,
operator|&
name|clock
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGETIME2
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
operator|)
condition|)
name|ctl_putlfp
argument_list|(
name|clock_var
index|[
name|CC_FUDGETIME2
index|]
operator|.
name|text
argument_list|,
operator|&
name|clock
operator|->
name|fudgetime2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGEVAL1
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
operator|)
condition|)
name|ctl_putint
argument_list|(
name|clock_var
index|[
name|CC_FUDGEVAL1
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|fudgeval1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FUDGEVAL2
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL2
operator|)
condition|)
name|ctl_putint
argument_list|(
name|clock_var
index|[
name|CC_FUDGEVAL2
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|fudgeval2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_FLAGS
case|:
if|if
condition|(
name|mustput
operator|||
operator|(
name|clock
operator|->
name|haveflags
operator|&
operator|(
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
operator||
name|CLK_HAVEFLAG4
operator|)
operator|)
condition|)
name|ctl_putuint
argument_list|(
name|clock_var
index|[
name|CC_FLAGS
index|]
operator|.
name|text
argument_list|,
operator|(
name|U_LONG
operator|)
name|clock
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_DEVICE
case|:
if|if
condition|(
name|clock
operator|->
name|clockdesc
operator|==
name|NULL
operator|||
operator|*
operator|(
name|clock
operator|->
name|clockdesc
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mustput
condition|)
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|CC_DEVICE
index|]
operator|.
name|text
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_putstr
argument_list|(
name|clock_var
index|[
name|CC_DEVICE
index|]
operator|.
name|text
argument_list|,
name|clock
operator|->
name|clockdesc
argument_list|,
name|strlen
argument_list|(
name|clock
operator|->
name|clockdesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_VARLIST
case|:
block|{
name|char
name|buf
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|ss
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|be
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|be
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|clock_var
index|[
name|CC_VARLIST
index|]
operator|.
name|text
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|be
condition|)
break|break;
comment|/* really long var name 8-( - Killer */
name|strcpy
argument_list|(
name|s
argument_list|,
name|clock_var
index|[
name|CC_VARLIST
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"=\""
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|k
operator|=
name|clock_var
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|i
operator|=
name|strlen
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|clock
operator|->
name|kv_list
init|;
name|k
operator|&&
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|->
name|flags
operator|&
name|PADDING
condition|)
continue|continue;
name|ss
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
continue|continue;
while|while
condition|(
operator|*
name|ss
operator|&&
operator|*
name|ss
operator|!=
literal|'='
condition|)
name|ss
operator|++
expr_stmt|;
name|i
operator|=
name|ss
operator|-
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|i
operator|+
literal|1
operator|>=
name|be
condition|)
break|break;
if|if
condition|(
name|s
operator|!=
name|t
condition|)
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|k
operator|->
name|text
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|+
literal|2
operator|>=
name|be
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ctl_putdata
argument_list|(
name|buf
argument_list|,
name|s
operator|-
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ctl_getitem - get the next data item from the incoming packet  */
end_comment

begin_function
specifier|static
name|struct
name|ctl_var
modifier|*
name|ctl_getitem
parameter_list|(
name|var_list
parameter_list|,
name|data
parameter_list|)
name|struct
name|ctl_var
modifier|*
name|var_list
decl_stmt|;
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
specifier|static
name|struct
name|ctl_var
name|eol
init|=
block|{
literal|0
block|,
name|EOV
block|, }
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* 	 * Delete leading commas and white space 	 */
while|while
condition|(
name|reqpt
operator|<
name|reqend
operator|&&
operator|(
operator|*
name|reqpt
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|*
name|reqpt
argument_list|)
operator|)
condition|)
block|{
name|reqpt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|reqpt
operator|>=
name|reqend
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|var_list
operator|==
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
condition|)
return|return
operator|&
name|eol
return|;
comment|/* 	 * Look for a first character match on the tag.  If we find 	 * one, see if it is a full match. 	 */
name|v
operator|=
name|var_list
expr_stmt|;
name|cp
operator|=
name|reqpt
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|PADDING
operator|)
operator|&&
operator|*
name|cp
operator|==
operator|*
operator|(
name|v
operator|->
name|text
operator|)
condition|)
block|{
name|tp
operator|=
name|v
operator|->
name|text
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|!=
literal|'\0'
operator|&&
operator|*
name|tp
operator|!=
literal|'='
operator|&&
name|cp
operator|<
name|reqend
operator|&&
operator|*
name|cp
operator|==
operator|*
name|tp
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|tp
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|tp
operator|==
literal|'='
operator|)
condition|)
block|{
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|reqend
operator|||
operator|*
name|cp
operator|==
literal|','
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|data
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|reqend
condition|)
name|cp
operator|++
expr_stmt|;
name|reqpt
operator|=
name|cp
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|tp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|reqend
operator|&&
operator|*
name|cp
operator|!=
literal|','
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|reqend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|*
operator|(
operator|--
name|tp
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|reqpt
operator|=
name|cp
expr_stmt|;
operator|*
name|data
operator|=
name|buf
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
name|cp
operator|=
name|reqpt
expr_stmt|;
block|}
name|v
operator|++
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * control_unspec - response to an unspecified op-code  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|control_unspec
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 	 * What is an appropriate response to an unspecified op-code? 	 * I return no errors and no data, unless a specified assocation 	 * doesn't exist. 	 */
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
operator|(
name|int
operator|)
name|res_associd
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read_status - return either a list of associd's, or a particular  *		 peer's status.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_status
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|u_short
name|ass_stat
index|[
name|CTL_MAX_DATA_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"read_status: ID %d\n"
argument_list|,
name|res_associd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Two choices here.  If the specified association ID is 	 * zero we return all known assocation ID's.  Otherwise 	 * we return a bunch of stuff about the particular peer. 	 */
if|if
condition|(
name|res_associd
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|assoc_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|ass_next
control|)
block|{
name|ass_stat
index|[
name|n
operator|++
index|]
operator|=
name|htons
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|ass_stat
index|[
name|n
operator|++
index|]
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|CTL_MAX_DATA_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|ctl_putdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ass_stat
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|ctl_putdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ass_stat
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
operator|(
name|int
operator|)
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
comment|/* 			 * For now, output everything we know about the peer. 			 * May be more selective later. 			 */
for|for
control|(
name|cp
operator|=
name|def_peer_var
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|ctl_putpeer
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * read_variables - return the variables the caller asks for  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_variables
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|u_char
modifier|*
name|wants
decl_stmt|;
name|int
name|gotvar
init|=
operator|(
name|CS_MAXCODE
operator|>
name|CP_MAXCODE
operator|)
condition|?
operator|(
name|CS_MAXCODE
operator|+
literal|1
operator|)
else|:
operator|(
name|CP_MAXCODE
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|res_associd
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Wants system variables.  Figure out which he wants 		 * and give them to him. 		 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|ctl_sys_num_events
operator|=
literal|0
expr_stmt|;
name|gotvar
operator|+=
name|count_var
argument_list|(
name|ext_sys_var
argument_list|)
expr_stmt|;
name|wants
operator|=
operator|(
name|u_char
operator|*
operator|)
name|emalloc
argument_list|(
name|gotvar
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|,
literal|0
argument_list|,
name|gotvar
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|ext_sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|CS_MAXCODE
operator|+
literal|1
operator|+
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
comment|/* shouldn't happen ! */
block|}
block|}
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CS_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putsys
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ext_sys_var
operator|&&
operator|!
operator|(
name|ext_sys_var
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EOV
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
operator|+
name|CS_MAXCODE
operator|+
literal|1
index|]
condition|)
name|ctl_putdata
argument_list|(
name|ext_sys_var
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|strlen
argument_list|(
name|ext_sys_var
index|[
name|i
index|]
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
for|for
control|(
name|cs
operator|=
name|def_sys_var
init|;
operator|*
name|cs
operator|!=
literal|0
condition|;
name|cs
operator|++
control|)
name|ctl_putsys
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cs
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|ext_sys_var
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 		 * Wants info for a particular peer.  See if we know 		 * the guy. 		 */
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
operator|(
name|int
operator|)
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_authokay
condition|)
name|peer
operator|->
name|num_events
operator|=
literal|0
expr_stmt|;
name|wants
operator|=
operator|(
name|u_char
operator|*
operator|)
name|emalloc
argument_list|(
name|gotvar
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|,
literal|0
argument_list|,
name|gotvar
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|peer_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CP_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putpeer
argument_list|(
name|i
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|def_peer_var
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|ctl_putpeer
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * write_variables - write into variables.  We only allow leap bit writing  *		     this way.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|write_variables
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|ext_var
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|LONG
name|val
decl_stmt|;
name|u_char
name|leapind
decl_stmt|,
name|leapwarn
decl_stmt|;
comment|/* 	 * If he's trying to write into a peer tell him no way 	 */
if|if
condition|(
name|res_associd
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set status 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * Set flags to not-in-sync so we can tell when we get something. 	 */
name|leapind
operator|=
operator|(
name|u_char
operator|)
operator|~
literal|0
expr_stmt|;
name|leapwarn
operator|=
operator|(
name|u_char
operator|)
operator|~
literal|0
expr_stmt|;
comment|/* 	 * Look through the variables.  Dump out at the first sign of trouble. 	 */
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ext_var
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|ext_sys_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
return|return;
block|}
name|ext_var
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|CAN_WRITE
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ext_var
operator|&&
operator|(
operator|*
name|valuep
operator|==
literal|'\0'
operator|||
operator|!
name|atoint
argument_list|(
name|valuep
argument_list|,
operator|&
name|val
argument_list|)
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADFMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ext_var
operator|&&
operator|(
name|val
operator|&
operator|~
name|LEAP_NOTINSYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADVALUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ext_var
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|v
operator|->
name|text
argument_list|)
operator|+
name|strlen
argument_list|(
name|valuep
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|tt
init|=
name|s
decl_stmt|;
name|t
operator|=
name|v
operator|->
name|text
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|'='
condition|)
operator|*
name|tt
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|tt
operator|++
operator|=
literal|'='
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|v
operator|->
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This one seems sane.  Save it. 			 */
switch|switch
condition|(
name|v
operator|->
name|code
condition|)
block|{
case|case
name|CS_LEAP
case|:
case|case
name|CS_LEAPIND
case|:
name|leapind
operator|=
operator|(
name|u_char
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|CS_LEAPWARNING
case|:
name|leapwarn
operator|=
operator|(
name|u_char
operator|)
name|val
expr_stmt|;
break|break;
default|default:
name|ctl_error
argument_list|(
name|CERR_UNSPEC
argument_list|)
expr_stmt|;
comment|/* our fault, really */
return|return;
block|}
block|}
block|}
comment|/* 	 * If we got anything, do it. 	 */
if|if
condition|(
name|leapind
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
operator|||
name|leapwarn
operator|!=
operator|(
name|u_char
operator|)
operator|~
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|leap_setleap
argument_list|(
operator|(
name|int
operator|)
name|leapind
argument_list|,
operator|(
name|int
operator|)
name|leapwarn
argument_list|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read_clock_status - return clock radio status  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_clock_status
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|REFCLOCK
comment|/* 	 * If no refclock support, no data to return 	 */
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|struct
name|ctl_var
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
modifier|*
name|valuep
decl_stmt|;
name|u_char
modifier|*
name|wants
decl_stmt|;
name|int
name|gotvar
decl_stmt|;
name|struct
name|refclockstat
name|clock
decl_stmt|;
if|if
condition|(
name|res_associd
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Find a clock for this jerk.  If the system peer 		 * is a clock use it, else search the hash tables 		 * for one. 		 */
if|if
condition|(
name|sys_peer
operator|!=
literal|0
operator|&&
operator|(
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|peer
operator|=
name|sys_peer
expr_stmt|;
block|}
else|else
block|{
name|peer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|peer
operator|==
literal|0
operator|&&
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|peer
operator|=
name|assoc_hash
index|[
name|i
index|]
init|;
name|peer
operator|!=
literal|0
condition|;
name|peer
operator|=
name|peer
operator|->
name|ass_next
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|peer
operator|==
literal|0
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|peer
operator|=
name|findpeerbyassoc
argument_list|(
operator|(
name|int
operator|)
name|res_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|0
operator|||
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
operator|)
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If we got here we have a peer which is a clock.  Get his status. 	 */
name|clock
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
comment|/* 	 * Look for variables in the packet. 	 */
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlclkstatus
argument_list|(
operator|&
name|clock
argument_list|)
argument_list|)
expr_stmt|;
name|gotvar
operator|=
name|CC_MAXCODE
operator|+
literal|1
operator|+
name|count_var
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|)
expr_stmt|;
name|wants
operator|=
operator|(
name|u_char
operator|*
operator|)
name|emalloc
argument_list|(
name|gotvar
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|,
literal|0
argument_list|,
name|gotvar
argument_list|)
expr_stmt|;
name|gotvar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|clock_var
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|ctl_getitem
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|,
operator|&
name|valuep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|EOV
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_UNKNOWNVAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|)
expr_stmt|;
return|return;
block|}
name|wants
index|[
name|CC_MAXCODE
operator|+
literal|1
operator|+
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
comment|/* shouldn't happen ! */
block|}
block|}
name|wants
index|[
name|v
operator|->
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|gotvar
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gotvar
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
index|]
condition|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|clock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|clock
operator|.
name|kv_list
operator|&&
operator|!
operator|(
name|clock
operator|.
name|kv_list
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EOV
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wants
index|[
name|i
operator|+
name|CC_MAXCODE
operator|+
literal|1
index|]
condition|)
name|ctl_putdata
argument_list|(
name|clock
operator|.
name|kv_list
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|strlen
argument_list|(
name|clock
operator|.
name|kv_list
index|[
name|i
index|]
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|u_char
modifier|*
name|cc
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
for|for
control|(
name|cc
operator|=
name|def_clock_var
init|;
operator|*
name|cc
operator|!=
literal|0
condition|;
name|cc
operator|++
control|)
name|ctl_putclock
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cc
argument_list|,
operator|&
name|clock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|clock
operator|.
name|kv_list
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wants
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * write_clock_status - we don't do this  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|write_clock_status
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Trap support from here on down.  We send async trap messages when the  * upper levels report trouble.  Traps can by set either by control  * messages or by configuration.  */
end_comment

begin_comment
comment|/*  * set_trap - set a trap in response to a control message  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_trap
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|traptype
decl_stmt|;
comment|/* 	 * See if this guy is allowed 	 */
if|if
condition|(
specifier|restrict
operator|&
name|RES_NOTRAP
condition|)
block|{
name|ctl_error
argument_list|(
name|CERR_PERMISSION
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Determine his allowed trap type. 	 */
name|traptype
operator|=
name|TRAP_TYPE_PRIO
expr_stmt|;
if|if
condition|(
specifier|restrict
operator|&
name|RES_LPTRAP
condition|)
name|traptype
operator|=
name|TRAP_TYPE_NONPRIO
expr_stmt|;
comment|/* 	 * Call ctlsettrap() to do the work.  Return 	 * an error if it can't assign the trap. 	 */
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|traptype
argument_list|,
operator|(
name|int
operator|)
name|res_version
argument_list|)
condition|)
name|ctl_error
argument_list|(
name|CERR_NORESOURCE
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * unset_trap - unset a trap in response to a control message  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|unset_trap
argument_list|(
name|rbufp
argument_list|,
specifier|restrict
argument_list|)
decl|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|restrict
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|traptype
decl_stmt|;
comment|/* 	 * We don't prevent anyone from removing his own 	 * trap unless the trap is configured.  Note we also 	 * must be aware of the possibility that restriction 	 * flags were changed since this guy last set his trap. 	 * Set the trap type based on this. 	 */
name|traptype
operator|=
name|TRAP_TYPE_PRIO
expr_stmt|;
if|if
condition|(
specifier|restrict
operator|&
name|RES_LPTRAP
condition|)
name|traptype
operator|=
name|TRAP_TYPE_NONPRIO
expr_stmt|;
comment|/* 	 * Call ctlclrtrap() to clear this out. 	 */
if|if
condition|(
operator|!
name|ctlclrtrap
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|,
name|rbufp
operator|->
name|dstadr
argument_list|,
name|traptype
argument_list|)
condition|)
name|ctl_error
argument_list|(
name|CERR_BADASSOC
argument_list|)
expr_stmt|;
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ctlsettrap - called to set a trap  */
end_comment

begin_function
name|int
name|ctlsettrap
parameter_list|(
name|raddr
parameter_list|,
name|linter
parameter_list|,
name|traptype
parameter_list|,
name|version
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|raddr
decl_stmt|;
name|struct
name|interface
modifier|*
name|linter
decl_stmt|;
name|int
name|traptype
decl_stmt|;
name|int
name|version
decl_stmt|;
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tptouse
decl_stmt|;
comment|/* 	 * See if we can find this trap.  If so, we only need update 	 * the flags and the time. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctlfindtrap
argument_list|(
name|raddr
argument_list|,
name|linter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|traptype
condition|)
block|{
case|case
name|TRAP_TYPE_CONFIG
case|:
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
operator||
name|TRAP_CONFIGURED
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_PRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
condition|)
return|return
literal|1
return|;
comment|/* don't change anything */
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_NONPRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
condition|)
return|return
literal|1
return|;
comment|/* don't change anything */
name|tp
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
operator||
name|TRAP_NONPRIO
expr_stmt|;
break|break;
block|}
name|tp
operator|->
name|tr_settime
operator|=
name|current_time
expr_stmt|;
name|tp
operator|->
name|tr_resets
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * First we heard of this guy.  Try to find a trap structure 	 * for him to use, clearing out lesser priority guys if we 	 * have to.  Clear out anyone who's expired while we're at it. 	 */
name|tptouse
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|ctl_trap
init|;
name|tp
operator|<
operator|&
name|ctl_trap
index|[
name|CTL_MAXTRAPS
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|tr_settime
operator|+
name|CTL_TRAPTIME
operator|)
operator|>
name|current_time
operator|)
condition|)
block|{
name|tp
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|)
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|)
condition|)
block|{
switch|switch
condition|(
name|traptype
condition|)
block|{
case|case
name|TRAP_TYPE_CONFIG
case|:
if|if
condition|(
name|tptouse
operator|==
name|NULL
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tptouse
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
operator|&&
operator|!
operator|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|tptouse
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
operator|)
operator|&&
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
condition|)
block|{
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tptouse
operator|->
name|tr_origtime
operator|<
name|tp
operator|->
name|tr_origtime
condition|)
name|tptouse
operator|=
name|tp
expr_stmt|;
break|break;
case|case
name|TRAP_TYPE_PRIO
case|:
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_NONPRIO
condition|)
block|{
if|if
condition|(
name|tptouse
operator|==
name|NULL
operator|||
operator|(
name|tptouse
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|&&
name|tptouse
operator|->
name|tr_origtime
operator|<
name|tp
operator|->
name|tr_origtime
operator|)
condition|)
name|tptouse
operator|=
name|tp
expr_stmt|;
block|}
break|break;
case|case
name|TRAP_TYPE_NONPRIO
case|:
break|break;
block|}
block|}
block|}
comment|/* 	 * If we don't have room for him return an error. 	 */
if|if
condition|(
name|tptouse
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	 * Set up this structure for him. 	 */
name|tptouse
operator|->
name|tr_settime
operator|=
name|tptouse
operator|->
name|tr_origtime
operator|=
name|current_time
expr_stmt|;
name|tptouse
operator|->
name|tr_count
operator|=
name|tptouse
operator|->
name|tr_resets
operator|=
literal|0
expr_stmt|;
name|tptouse
operator|->
name|tr_sequence
operator|=
literal|1
expr_stmt|;
name|tptouse
operator|->
name|tr_addr
operator|=
operator|*
name|raddr
expr_stmt|;
name|tptouse
operator|->
name|tr_localaddr
operator|=
name|linter
expr_stmt|;
name|tptouse
operator|->
name|tr_version
operator|=
name|version
expr_stmt|;
name|tptouse
operator|->
name|tr_flags
operator|=
name|TRAP_INUSE
expr_stmt|;
if|if
condition|(
name|traptype
operator|==
name|TRAP_TYPE_CONFIG
condition|)
name|tptouse
operator|->
name|tr_flags
operator||=
name|TRAP_CONFIGURED
expr_stmt|;
elseif|else
if|if
condition|(
name|traptype
operator|==
name|TRAP_TYPE_NONPRIO
condition|)
name|tptouse
operator|->
name|tr_flags
operator||=
name|TRAP_NONPRIO
expr_stmt|;
name|num_ctl_traps
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ctlclrtrap - called to clr a trap  */
end_comment

begin_function
name|int
name|ctlclrtrap
parameter_list|(
name|raddr
parameter_list|,
name|linter
parameter_list|,
name|traptype
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|raddr
decl_stmt|;
name|struct
name|interface
modifier|*
name|linter
decl_stmt|;
name|int
name|traptype
decl_stmt|;
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctlfindtrap
argument_list|(
name|raddr
argument_list|,
name|linter
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_CONFIGURED
operator|&&
name|traptype
operator|!=
name|TRAP_TYPE_CONFIG
condition|)
return|return
literal|0
return|;
name|tp
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|num_ctl_traps
operator|--
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ctlfindtrap - find a trap given the remote and local addresses  */
end_comment

begin_function
specifier|static
name|struct
name|ctl_trap
modifier|*
name|ctlfindtrap
parameter_list|(
name|raddr
parameter_list|,
name|linter
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|raddr
decl_stmt|;
name|struct
name|interface
modifier|*
name|linter
decl_stmt|;
block|{
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|ctl_trap
init|;
name|tp
operator|<
operator|&
name|ctl_trap
index|[
name|CTL_MAXTRAPS
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
operator|&&
name|NSRCADR
argument_list|(
name|raddr
argument_list|)
operator|==
name|NSRCADR
argument_list|(
operator|&
name|tp
operator|->
name|tr_addr
argument_list|)
operator|&&
name|NSRCPORT
argument_list|(
name|raddr
argument_list|)
operator|==
name|NSRCPORT
argument_list|(
operator|&
name|tp
operator|->
name|tr_addr
argument_list|)
operator|&&
name|linter
operator|==
name|tp
operator|->
name|tr_localaddr
condition|)
return|return
name|tp
return|;
block|}
return|return
operator|(
expr|struct
name|ctl_trap
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * report_event - report an event to the trappers  */
end_comment

begin_function
name|void
name|report_event
parameter_list|(
name|err
parameter_list|,
name|peer
parameter_list|)
name|int
name|err
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Record error code in proper spots, but have mercy on the 	 * log file. 	 */
if|if
condition|(
operator|!
operator|(
name|err
operator|&
name|PEER_EVENT
operator|)
condition|)
block|{
if|if
condition|(
name|ctl_sys_num_events
operator|<
name|CTL_SYS_MAXEVENTS
condition|)
name|ctl_sys_num_events
operator|++
expr_stmt|;
if|if
condition|(
name|ctl_sys_last_event
operator|!=
operator|(
name|u_char
operator|)
name|err
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"system event %x status %x"
argument_list|,
name|err
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
name|ctl_sys_last_event
operator|=
operator|(
name|u_char
operator|)
name|err
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|!=
literal|0
condition|)
block|{
name|peer
operator|->
name|last_event
operator|=
call|(
name|u_char
call|)
argument_list|(
name|err
operator|&
operator|~
name|PEER_EVENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|num_events
operator|<
name|CTL_PEER_MAXEVENTS
condition|)
name|peer
operator|->
name|num_events
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"peer %s event %x status %x"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|err
argument_list|,
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"report_event: err %x, no peer"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no trappers, return. 	 */
if|if
condition|(
name|num_ctl_traps
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Set up the outgoing packet variables 	 */
name|res_opcode
operator|=
name|CTL_OP_ASYNCMSG
expr_stmt|;
name|res_offset
operator|=
literal|0
expr_stmt|;
name|res_async
operator|=
literal|1
expr_stmt|;
name|res_authenticate
operator|=
literal|0
expr_stmt|;
name|datapt
operator|=
name|rpkt
operator|.
name|data
expr_stmt|;
name|dataend
operator|=
operator|&
operator|(
name|rpkt
operator|.
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|err
operator|&
name|PEER_EVENT
operator|)
condition|)
block|{
name|rpkt
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlsysstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 		 * For now, put everything we know about system 		 * variables.  Maybe more selective later 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CS_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putsys
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 		 * for clock exception events: 		 *    add clock variables to reflect info on exception 		 */
if|if
condition|(
name|err
operator|==
name|EVNT_CLOCKEXCPT
condition|)
block|{
name|struct
name|refclockstat
name|clock
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|clock
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
literal|"refclockstatus"
argument_list|,
operator|(
name|U_LONG
operator|)
name|ctlclkstatus
argument_list|(
operator|&
name|clock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|clock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|clock
operator|.
name|kv_list
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*REFCLOCK*/
block|}
else|else
block|{
name|rpkt
operator|.
name|associd
operator|=
name|htons
argument_list|(
name|peer
operator|->
name|associd
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|status
operator|=
name|htons
argument_list|(
name|ctlpeerstatus
argument_list|(
name|peer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Dump it all.  Later, maybe less. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CP_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putpeer
argument_list|(
name|i
argument_list|,
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 			 * for clock exception events: 			 *    add clock variables to reflect info on exception 			 */
if|if
condition|(
name|err
operator|==
name|EVNT_PEERCLOCK
condition|)
block|{
name|struct
name|refclockstat
name|clock
decl_stmt|;
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
name|clock
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|ctl_puthex
argument_list|(
literal|"refclockstatus"
argument_list|,
operator|(
name|U_LONG
operator|)
name|ctlclkstatus
argument_list|(
operator|&
name|clock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|CC_MAXCODE
condition|;
name|i
operator|++
control|)
name|ctl_putclock
argument_list|(
name|i
argument_list|,
operator|&
name|clock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|clock
operator|.
name|kv_list
init|;
name|kv
operator|&&
operator|!
operator|(
name|kv
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|kv
operator|->
name|flags
operator|&
name|DEF
condition|)
name|ctl_putdata
argument_list|(
name|kv
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|kv
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*REFCLOCK*/
block|}
comment|/* 	 * We're done, return. 	 */
name|ctl_flushpkt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ctl_clr_stats - clear stat counters  */
end_comment

begin_function
name|void
name|ctl_clr_stats
parameter_list|()
block|{
name|ctltimereset
operator|=
name|current_time
expr_stmt|;
name|numctlreq
operator|=
literal|0
expr_stmt|;
name|numctlbadpkts
operator|=
literal|0
expr_stmt|;
name|numctlresponses
operator|=
literal|0
expr_stmt|;
name|numctlfrags
operator|=
literal|0
expr_stmt|;
name|numctlerrors
operator|=
literal|0
expr_stmt|;
name|numctlfrags
operator|=
literal|0
expr_stmt|;
name|numctltooshort
operator|=
literal|0
expr_stmt|;
name|numctlinputresp
operator|=
literal|0
expr_stmt|;
name|numctlinputfrag
operator|=
literal|0
expr_stmt|;
name|numctlinputerr
operator|=
literal|0
expr_stmt|;
name|numctlbadoffset
operator|=
literal|0
expr_stmt|;
name|numctlbadversion
operator|=
literal|0
expr_stmt|;
name|numctldatatooshort
operator|=
literal|0
expr_stmt|;
name|numctlbadop
operator|=
literal|0
expr_stmt|;
name|numasyncmsgs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|count_var
parameter_list|(
name|k
parameter_list|)
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|k
operator|&&
operator|!
operator|(
name|k
operator|++
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
name|c
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|add_var
parameter_list|(
name|kv
parameter_list|,
name|size
parameter_list|,
name|def
parameter_list|)
name|struct
name|ctl_var
modifier|*
modifier|*
name|kv
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|c
decl_stmt|;
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
name|c
operator|=
name|count_var
argument_list|(
operator|*
name|kv
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|kv
expr_stmt|;
operator|*
name|kv
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|kv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|k
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctl_var
argument_list|)
operator|*
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|k
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|code
operator|=
name|c
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|flags
operator|=
name|def
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
operator|*
name|kv
operator|)
index|[
name|c
operator|+
literal|1
index|]
operator|.
name|flags
operator|=
name|EOV
expr_stmt|;
return|return
operator|(
operator|*
name|kv
operator|)
index|[
name|c
index|]
operator|.
name|text
return|;
block|}
end_function

begin_function
name|void
name|set_var
parameter_list|(
name|kv
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|,
name|def
parameter_list|)
name|struct
name|ctl_var
modifier|*
modifier|*
name|kv
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
specifier|register
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
operator|!
name|size
condition|)
return|return;
if|if
condition|(
operator|(
name|k
operator|=
operator|*
name|kv
operator|)
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|)
block|{
name|s
operator|=
name|data
expr_stmt|;
name|t
operator|=
name|k
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
while|while
condition|(
operator|*
name|t
operator|!=
literal|'='
operator|&&
operator|*
name|s
operator|-
operator|*
name|t
operator|==
literal|0
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|t
operator|&&
operator|(
operator|(
operator|*
name|t
operator|==
literal|'='
operator|)
operator|||
operator|!
operator|*
name|t
operator|)
condition|)
block|{
name|free
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|k
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|k
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|def
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|k
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|k
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|k
operator|->
name|flags
operator|=
name|def
expr_stmt|;
return|return;
block|}
name|k
operator|++
expr_stmt|;
block|}
block|}
name|t
operator|=
name|add_var
argument_list|(
name|kv
argument_list|,
name|size
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|t
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_sys_var
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|,
name|def
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
name|set_var
argument_list|(
operator|&
name|ext_sys_var
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_varlist
parameter_list|(
name|kv
parameter_list|)
name|struct
name|ctl_var
modifier|*
name|kv
decl_stmt|;
block|{
name|struct
name|ctl_var
modifier|*
name|k
decl_stmt|;
if|if
condition|(
name|kv
condition|)
block|{
for|for
control|(
name|k
operator|=
name|kv
init|;
operator|!
operator|(
name|k
operator|->
name|flags
operator|&
name|EOV
operator|)
condition|;
name|k
operator|++
control|)
name|free
argument_list|(
name|k
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

