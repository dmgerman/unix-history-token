begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_loopfilter.c - implements the NTP loop filter algorithm  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|"sys/timex.h"
end_include

begin_define
define|#
directive|define
name|ntp_gettime
parameter_list|(
name|t
parameter_list|)
value|syscall(SYS_ntp_gettime, (t))
end_define

begin_define
define|#
directive|define
name|ntp_adjtime
parameter_list|(
name|t
parameter_list|)
value|syscall(SYS_ntp_adjtime, (t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_comment
comment|/*  * The loop filter is implemented in slavish adherence to the  * specification (Section 5), except that for consistency we  * mostly carry the quantities in the same units as appendix G.  *  * Note that the long values below are the fractional portion of  * a long fixed-point value.  This limits these values to +-0.5  * seconds.  When adjustments are capped inside this range (see  * CLOCK_MAX_{I,F}) both the clock_adjust and the compliance  * registers should be fine. (When the compliance is above 16, it  * will at most accumulate 2 ** CLOCK_MULT times the maximum offset,  * which means it fits in a s_fp.)  *  * The skew compensation is a special case. In version 2, it was  * kept in ms / 4s (i.e., CLOCK_FREQ was 10). In version 3 (Section 5)  * it seems to be 2 ** -16ms / 4s in a s_fp for a maximum of +-125ppm  * (stated maximum 100ppm). Since this seems about to change to a  * larger range, it will be kept in units of 2 ** -20 (CLOCK_DSCALE)  * in an s_fp (mainly because that's nearly the same as parts per  * million). Note that this is ``seconds per second'', whereas a  * clock adjustment is a 32-bit fraction of a second to be applied  * every 2 ** CLOCK_ADJ seconds; to find it, shift the drift right by  * (CLOCK_DSCALE - 16 - CLOCK_ADJ). When updating the drift, on the  * other hand, the CLOCK_FREQ factor from the spec assumes the value to  * be in ``seconds per 4 seconds''; to get our units, CLOCK_ADJ must be  * added to the shift.  *  * Kernel PLL/PPS state machine  *  * The following state machine is used when the kernel PLL modifications  * described in the README.kernel file are present. The initial  * configuration routine loop_config() sets up the initial frequency  * estimate and tests if the kernel modifications are present. If so and  * the PLL mode bit 1 (STA_PLL) of the mode word in the drift file  * (ntp.drift) is set, pll_control is set true and the kernel pll is  * enabled. If the kernel modifications are present and the PLL mode bit  * 2 (STA_PPSFREQ) is set, the kernel PPS frequency discipline is  * enabled.  *  * Each update to a prefer peer sets pps_update true if it survives the  * intersection algorithm and its time is within range. The PPS time  * discipline is enabled (STA_PPSTIME bit set in the status word) when  * pps_update is true and the PPS frequency discipline is enabled. If  * the PPS time discipline is enabled and the kernel reports a PPS  * signal is present, the pps_control variable is set to the current  * time. If the current time is later than pps_control by PPS_MAXAGE  * (120 s), this variable is set to zero.  *  * The pll_enable switch can be set both at configuration time and at  * run time using xntpdc. If true, the kernel modifications are active  * as described above; if false, the kernel is bypassed entirely (except  * for the PPS frequency update, if enabled) and the daemon PLL used  * instead.   */
end_comment

begin_define
define|#
directive|define
name|RSH_DRIFT_TO_FRAC
value|(CLOCK_DSCALE - 16)
end_define

begin_define
define|#
directive|define
name|RSH_DRIFT_TO_ADJ
value|(RSH_DRIFT_TO_FRAC - CLOCK_ADJ)
end_define

begin_define
define|#
directive|define
name|RSH_FRAC_TO_FREQ
value|(CLOCK_FREQ + CLOCK_ADJ - RSH_DRIFT_TO_FRAC)
end_define

begin_define
define|#
directive|define
name|PPS_MAXAGE
value|120
end_define

begin_comment
comment|/* kernel pps signal timeout (s) */
end_comment

begin_comment
comment|/*  * Program variables  */
end_comment

begin_decl_stmt
name|l_fp
name|last_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last clock offset */
end_comment

begin_decl_stmt
name|u_long
name|last_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of last clock update (s) */
end_comment

begin_decl_stmt
name|u_fp
name|clock_stability
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock stability (ppm) */
end_comment

begin_decl_stmt
name|s_fp
name|clock_frequency
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock frequency error (ppm) */
end_comment

begin_decl_stmt
name|s_fp
name|drift_comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pll frequency (ppm) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|clock_adjust
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock adjust (fraction only) */
end_comment

begin_decl_stmt
specifier|static
name|s_fp
name|max_comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max frequency offset (ppm) */
end_comment

begin_decl_stmt
name|int
name|tc_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll-adjust counter */
end_comment

begin_decl_stmt
name|int
name|pll_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status bits for kernel pll */
end_comment

begin_decl_stmt
name|int
name|pll_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if working kernel pll */
end_comment

begin_decl_stmt
name|int
name|pll_enable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if pll enabled */
end_comment

begin_decl_stmt
name|u_long
name|pps_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last pps sample time */
end_comment

begin_decl_stmt
name|int
name|pps_update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps update valid */
end_comment

begin_decl_stmt
name|int
name|fdpps
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_comment
comment|/*  * Imported from the ntp_proto module  */
end_comment

begin_decl_stmt
specifier|extern
name|s_fp
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root delay */
end_comment

begin_decl_stmt
specifier|extern
name|u_fp
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root dispersion */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system peer pointer */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_poll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2 of system poll interval */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap bits */
end_comment

begin_decl_stmt
specifier|extern
name|l_fp
name|sys_refskew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated skew since last update */
end_comment

begin_decl_stmt
specifier|extern
name|u_fp
name|sys_maxd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max dispersion of survivor list */
end_comment

begin_comment
comment|/*  * Imported from ntp_io.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Imported from timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* like it says, in seconds */
end_comment

begin_comment
comment|/*  * Imported from leap module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|leapbits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sanitized leap bits */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
end_if

begin_define
define|#
directive|define
name|MOD_BITS
value|(MOD_OFFSET | MOD_MAXERROR | MOD_ESTERROR | \     MOD_STATUS | MOD_TIMECONST)
end_define

begin_decl_stmt
specifier|extern
name|int
name|sigvec
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|sigvec
operator|*
operator|,
expr|struct
name|sigvec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|syscall
name|P
argument_list|(
operator|(
name|int
operator|,
name|void
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pll_trap
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sigvec
name|sigsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current sigvec status */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sigvec
name|newsigsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new sigvec status */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_comment
comment|/*  * init_loopfilter - initialize loop filter data  */
end_comment

begin_function
name|void
name|init_loopfilter
parameter_list|()
block|{
specifier|extern
name|u_long
name|tsf_maxslew
decl_stmt|;
name|u_long
name|tsf_limit
decl_stmt|;
comment|/* 	 * Limit for drift_comp, minimum of two values. The first is to 	 * avoid signed overflow, the second to keep within 75% of the 	 * maximum adjustment possible in adj_systime(). 	 */
name|max_comp
operator|=
literal|0x7fff0000
expr_stmt|;
name|tsf_limit
operator|=
operator|(
operator|(
name|tsf_maxslew
operator|>>
literal|1
operator|)
operator|+
operator|(
name|tsf_maxslew
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|max_comp
operator|>>
name|RSH_DRIFT_TO_ADJ
operator|)
operator|>
name|tsf_limit
condition|)
name|max_comp
operator|=
name|tsf_limit
operator|<<
name|RSH_DRIFT_TO_ADJ
expr_stmt|;
comment|/* 	 * Reset clockworks 	 */
name|drift_comp
operator|=
literal|0
expr_stmt|;
name|clock_adjust
operator|=
literal|0
expr_stmt|;
name|tc_counter
operator|=
literal|0
expr_stmt|;
name|sys_poll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|last_offset
argument_list|)
expr_stmt|;
name|last_time
operator|=
literal|0
expr_stmt|;
name|clock_frequency
operator|=
literal|0
expr_stmt|;
name|clock_stability
operator|=
literal|0
expr_stmt|;
name|pps_update
operator|=
name|pps_control
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * local_clock - the NTP logical clock loop filter.  Returns 1 if the  *	clock was stepped, 0 if it was slewed and -1 if it is hopeless.  */
end_comment

begin_function
name|int
name|local_clock
parameter_list|(
name|fp_offset
parameter_list|,
name|peer
parameter_list|)
name|l_fp
modifier|*
name|fp_offset
decl_stmt|;
comment|/* best offset estimate */
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* from peer - for messages */
block|{
name|long
name|offset
decl_stmt|;
name|long
name|tmp
decl_stmt|;
name|int
name|return_code
decl_stmt|;
name|l_fp
name|ftmp
decl_stmt|;
name|s_fp
name|stmp
decl_stmt|;
name|u_fp
name|smax
decl_stmt|;
name|long
name|allan
decl_stmt|;
name|long
name|interval
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
name|struct
name|timex
name|ntv
decl_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
comment|/* 	 * Initialize estimated measurement error and Allan variance 	 * intercept point. The measurement error is assumed the sum of 	 * the peer dispersion plus select dispersion, which seems 	 * reasonable. The Allan variance intercept point is assumed 	 * at MAXSEC for reference clocks and twice that for peer 	 * clocks, which seems cowardly. 	 */
if|if
condition|(
name|peer
operator|->
name|refclktype
condition|)
name|allan
operator|=
name|CLOCK_MAXSEC
expr_stmt|;
else|else
name|allan
operator|=
name|CLOCK_MAXSEC
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|last_time
condition|)
name|last_time
operator|=
name|current_time
expr_stmt|;
name|interval
operator|=
call|(
name|long
call|)
argument_list|(
name|current_time
operator|-
name|last_time
argument_list|)
expr_stmt|;
name|clock_adjust
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|fp_offset
operator|->
name|l_f
expr_stmt|;
name|smax
operator|=
name|peer
operator|->
name|dispersion
operator|+
name|peer
operator|->
name|selectdisp
expr_stmt|;
name|return_code
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"local_clock: offset %s peer %s watch %ld)\n"
argument_list|,
name|lfptoa
argument_list|(
name|fp_offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|interval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the clock is way off, don't tempt fate by correcting it. 	 */
name|ftmp
operator|=
operator|*
name|fp_offset
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|ftmp
argument_list|)
condition|)
name|L_NEG
argument_list|(
operator|&
name|ftmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftmp
operator|.
name|l_ui
operator|>=
name|CLOCK_WAYTOOBIG
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"time error %s is way too large (set clock manually)"
argument_list|,
name|lfptoa
argument_list|(
name|fp_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BIGTIMESTEP
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* BIGTIMESTEP */
comment|/* 	 * If the magnitude of the offset is greater than CLOCK.MAX 	 * (128 ms), reset the time and frequency. We are quite 	 * aggresive here, since the intrinsic clock oscillator 	 * frequency error can be quite large, sometimes over +-300 ppm. 	 * With something this large and a noisy peer, the casual time 	 * updates wander right through the acceptable range, causing 	 * this section to trigger. 	 */
block|}
elseif|else
if|if
condition|(
name|ftmp
operator|.
name|l_ui
operator|>
name|CLOCK_MAX_I
operator|||
operator|(
name|ftmp
operator|.
name|l_ui
operator|==
name|CLOCK_MAX_I
operator|&&
name|ftmp
operator|.
name|l_uf
operator|>=
name|CLOCK_MAX_F
operator|)
condition|)
block|{
name|tc_counter
operator|=
literal|0
expr_stmt|;
name|sys_poll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
comment|/* 		 * Either we are not in synchronization, or we have gone 		 * CLOCK_MINSTEP (900 s) since the last acceptable 		 * update. We step the clock and leave the frequency 		 * alone. Since the clock filter has been reset, the 		 * dispersions will be high upon recovery and the quick- 		 * march code below will trigger to keep the clock in 		 * bounds. 		 */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|interval
operator|>
name|CLOCK_MINSTEP
condition|)
block|{
name|step_systime
argument_list|(
name|fp_offset
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"time reset (%s) %s s"
argument_list|,
ifdef|#
directive|ifdef
name|SLEWALWAYS
literal|"slew"
argument_list|,
else|#
directive|else
literal|"step"
argument_list|,
endif|#
directive|endif
name|lfptoa
argument_list|(
name|fp_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|1
expr_stmt|;
comment|/* 		 * The local clock is out of range, but we haven't 		 * allowed enough time for the peer (usually a radio 		 * clock) to recover after a leap second. Pretend we wuz 		 * never here. 		 */
block|}
else|else
return|return
operator|(
name|return_code
operator|)
return|;
comment|/* 	 * This code segment works when the clock-adjustment code is 	 * implemented in the kernel, which at present is only in the 	 * (modified) SunOS 4.1, Ultrix 4.3 and OSF/1 kernels. In the 	 * case of the DECstation 5000/240 and Alpha AXP, additional 	 * kernel modifications provide a true microsecond clock. We 	 * know the scaling of the frequency variable (s_fp) is the same 	 * as the kernel variable (1<< SHIFT_USEC = 16). 	 */
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
block|}
elseif|else
if|if
condition|(
name|pll_control
operator|&&
name|pll_enable
condition|)
block|{
name|l_fp
name|pps_offset
decl_stmt|;
name|u_fp
name|pps_dispersion
decl_stmt|;
comment|/* 		 * We initialize the structure for the ntp_adjtime() 		 * system call. We have to convert everything to 		 * microseconds first. Afterwards, remember the 		 * frequency offset for the drift file. 		 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ntv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ntv
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|modes
operator|=
name|MOD_BITS
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
name|TSFTOTVU
argument_list|(
name|offset
argument_list|,
name|ntv
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TSFTOTVU
argument_list|(
operator|-
name|offset
argument_list|,
name|ntv
operator|.
name|offset
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|offset
operator|=
operator|-
name|ntv
operator|.
name|offset
expr_stmt|;
block|}
name|TSFTOTVU
argument_list|(
name|sys_rootdispersion
operator|+
name|sys_rootdelay
operator|/
literal|2
argument_list|,
name|ntv
operator|.
name|maxerror
argument_list|)
expr_stmt|;
name|TSFTOTVU
argument_list|(
name|sys_rootdispersion
argument_list|,
name|ntv
operator|.
name|esterror
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|status
operator|=
name|pll_status
operator|&
operator|(
name|STA_PLL
operator||
name|STA_PPSFREQ
operator|)
expr_stmt|;
if|if
condition|(
name|pps_update
operator|&&
name|pll_status
operator|&
name|STA_PPSFREQ
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_PPSTIME
expr_stmt|;
if|if
condition|(
name|sys_leap
operator|&
name|LEAP_ADDSECOND
operator|&&
name|sys_leap
operator|&
name|LEAP_DELSECOND
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_UNSYNC
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|&
name|LEAP_ADDSECOND
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_INS
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|&
name|LEAP_DELSECOND
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_DEL
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|sys_poll
argument_list|)
operator|-
name|NTP_MINPOLL
expr_stmt|;
operator|(
name|void
operator|)
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
name|drift_comp
operator|=
name|ntv
operator|.
name|freq
expr_stmt|;
name|pll_status
operator|=
name|ntv
operator|.
name|status
expr_stmt|;
comment|/* 		 * If the kernel pps discipline is working, monitor its 		 * performance. 		 */
if|if
condition|(
name|pll_status
operator|&
name|STA_PPSTIME
operator|&&
name|pll_status
operator|&
name|STA_PPSSIGNAL
operator|&&
name|ntv
operator|.
name|shift
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|offset
operator|>=
literal|0
condition|)
name|TVUTOTSF
argument_list|(
name|ntv
operator|.
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|TVUTOTSF
argument_list|(
operator|-
name|ntv
operator|.
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|L_CLR
argument_list|(
operator|&
name|pps_offset
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|pps_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|ntv
operator|.
name|jitter
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|pps_dispersion
operator|=
operator|(
name|tmp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
operator|!
name|pps_control
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"kernel pps sync enabled"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
name|current_time
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|loopback_interface
operator|->
name|sin
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|,
name|fp_offset
argument_list|,
literal|0
argument_list|,
name|pps_dispersion
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KERNEL_PLL */
comment|/* 	 * If the dispersion exceeds 128 ms, we need to quick-march it 	 * to nominal zero offset and wait for the next update. This is 	 * necessary when the intrinsic frequency error is large and the 	 * clock has drifted during the interval the clock filter was 	 * stabilizing. Note that, if unsynchronized, the dispersion is 	 * always greater than 128 ms, so we don't need a check for 	 * that. 	 */
block|}
elseif|else
if|if
condition|(
name|smax
operator|>
name|CLOCK_MAX_FP
condition|)
block|{
name|clock_adjust
operator|=
name|offset
expr_stmt|;
comment|/* 	 * If the dispersion has increased substantially over the 	 * previous value, we have a spike which probably should be 	 * suppressed. A factor of eight has been found reasonable by 	 * simulation. 	 */
block|}
elseif|else
if|if
condition|(
name|smax
operator|>
name|sys_maxd
operator|<<
literal|3
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the interval between corrections is less than the Allan 	 * variance intercept point, we use a phase-lock loop to compute 	 * new values of time and frequency. The bandwidth is controlled 	 * by the time constant, which is adjusted in response to the 	 * phase error and dispersion. Note the frequency is not changed 	 * if the local clock driver is in control. 	 */
block|}
elseif|else
if|if
condition|(
name|interval
operator|<
name|allan
condition|)
block|{
name|int
name|time_constant
init|=
name|min
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|sys_poll
argument_list|)
operator|-
name|NTP_MINPOLL
decl_stmt|;
name|int
name|ltmp
init|=
name|interval
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|clock_adjust
operator|=
operator|-
operator|(
operator|-
name|offset
operator|>>
name|time_constant
operator|)
expr_stmt|;
else|else
name|clock_adjust
operator|=
name|offset
operator|>>
name|time_constant
expr_stmt|;
if|if
condition|(
name|interval
operator|&&
operator|!
operator|(
name|peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|)
condition|)
block|{
name|tmp
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
while|while
condition|(
name|ltmp
operator|<
operator|(
literal|1
operator|<<
name|peer
operator|->
name|maxpoll
operator|)
condition|)
block|{
name|tmp
operator|--
expr_stmt|;
name|ltmp
operator|<<=
literal|1
expr_stmt|;
block|}
name|tmp
operator|=
operator|(
name|RSH_FRAC_TO_FREQ
operator|-
name|tmp
operator|)
operator|+
name|time_constant
operator|+
name|time_constant
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|-
operator|(
operator|-
name|offset
operator|>>
name|tmp
operator|)
expr_stmt|;
else|else
name|tmp
operator|=
name|offset
operator|>>
name|tmp
expr_stmt|;
name|drift_comp
operator|+=
name|tmp
expr_stmt|;
block|}
comment|/* 	 * If the interval between corrections is greater than the Allan 	 * variance intercept point, we use a hybrid frequency-lock loop 	 * to compute new values of phase and frequency. The following 	 * code is based on ideas suggested by Judah Levine of NIST and 	 * used in his "lockclock" implementation of ACTS. The magic 	 * factor of 4 in the left shift is to convert from s_fp to ppm. 	 */
block|}
else|else
block|{
name|clock_adjust
operator|=
name|offset
expr_stmt|;
name|stmp
operator|=
operator|(
name|offset
operator|/
name|interval
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|stmp
operator|<
literal|0
condition|)
name|drift_comp
operator|-=
operator|-
name|stmp
operator|>>
name|CLOCK_G
expr_stmt|;
else|else
name|drift_comp
operator|+=
name|stmp
operator|>>
name|CLOCK_G
expr_stmt|;
block|}
comment|/* 	 * As a sanity check, we clamp the frequency not to exceed the 	 * slew rate of the stock Unix adjtime() system call. Finally, 	 * do a little housekeeping. 	 */
if|if
condition|(
name|drift_comp
operator|>
name|max_comp
condition|)
name|drift_comp
operator|=
name|max_comp
expr_stmt|;
elseif|else
if|if
condition|(
name|drift_comp
operator|<
operator|-
name|max_comp
condition|)
name|drift_comp
operator|=
operator|-
name|max_comp
expr_stmt|;
if|if
condition|(
name|interval
operator|>
operator|(
literal|1
operator|<<
operator|(
name|peer
operator|->
name|minpoll
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Determine when to adjust the poll interval. We do 		 * this regardless of what source controls the loop, 		 * since we might flap back and forth between sources. 		 */
name|stmp
operator|=
name|LFPTOFP
argument_list|(
name|fp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmp
operator|<
literal|0
condition|)
name|stmp
operator|=
operator|-
name|stmp
expr_stmt|;
if|if
condition|(
name|stmp
operator|>
name|smax
condition|)
block|{
name|tc_counter
operator|-=
operator|(
name|int
operator|)
name|sys_poll
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|tc_counter
operator|<
operator|-
name|CLOCK_LIMIT
condition|)
block|{
name|tc_counter
operator|=
operator|-
name|CLOCK_LIMIT
expr_stmt|;
if|if
condition|(
name|sys_poll
operator|>
name|peer
operator|->
name|minpoll
condition|)
block|{
name|sys_poll
operator|--
expr_stmt|;
name|tc_counter
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tc_counter
operator|+=
operator|(
name|int
operator|)
name|sys_poll
expr_stmt|;
if|if
condition|(
name|tc_counter
operator|>
name|CLOCK_LIMIT
condition|)
block|{
name|tc_counter
operator|=
name|CLOCK_LIMIT
expr_stmt|;
if|if
condition|(
name|sys_poll
operator|<
name|peer
operator|->
name|maxpoll
condition|)
block|{
name|sys_poll
operator|++
expr_stmt|;
name|tc_counter
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Calculate the frequency offset and frequency 		 * stability. These are useful for performance 		 * monitoring, but do not affect the loop variables. The 		 * results are scaled as a s_fp in ppm, because we know 		 * more than we should. 		 */
name|ftmp
operator|=
operator|*
name|fp_offset
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|ftmp
argument_list|,
operator|&
name|last_offset
argument_list|)
expr_stmt|;
name|clock_frequency
operator|=
operator|(
name|LFPTOFP
argument_list|(
operator|&
name|ftmp
argument_list|)
operator|/
name|interval
operator|)
operator|<<
literal|20
expr_stmt|;
if|if
condition|(
name|clock_frequency
operator|<
operator|-
name|max_comp
condition|)
name|clock_frequency
operator|=
operator|-
name|max_comp
expr_stmt|;
elseif|else
if|if
condition|(
name|clock_frequency
operator|>
name|max_comp
condition|)
name|clock_frequency
operator|=
name|max_comp
expr_stmt|;
name|stmp
operator|=
name|clock_frequency
expr_stmt|;
if|if
condition|(
name|stmp
operator|<
literal|0
condition|)
name|stmp
operator|=
operator|-
name|stmp
expr_stmt|;
name|stmp
operator|-=
name|clock_stability
expr_stmt|;
if|if
condition|(
name|stmp
operator|<
literal|0
condition|)
name|clock_stability
operator|-=
operator|-
name|stmp
operator|>>
name|NTP_MAXD
expr_stmt|;
else|else
name|clock_stability
operator|+=
name|stmp
operator|>>
name|NTP_MAXD
expr_stmt|;
block|}
name|last_offset
operator|=
operator|*
name|fp_offset
expr_stmt|;
name|last_time
operator|=
name|current_time
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"local_clock: phase %s freq %s err %s allan %ld poll %d\n"
argument_list|,
name|mfptoa
argument_list|(
operator|(
name|clock_adjust
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|,
name|clock_adjust
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|drift_comp
argument_list|,
literal|3
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|smax
argument_list|,
literal|6
argument_list|)
argument_list|,
name|allan
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
operator|(
name|void
operator|)
name|record_loop_stats
argument_list|(
name|fp_offset
argument_list|,
name|drift_comp
argument_list|,
name|sys_poll
argument_list|)
expr_stmt|;
comment|/* 	 * Whew.  I've had enough. 	 */
return|return
operator|(
name|return_code
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * adj_host_clock - Called every 1<< CLOCK_ADJ seconds to update host  *	 clock  */
end_comment

begin_function
name|void
name|adj_host_clock
parameter_list|()
block|{
specifier|register
name|long
name|adjustment
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
comment|/* 	 * Update the dispersion since the last update. Don't allow 	 * frequency measurements over periods longer than NTP_MAXAGE 	 * (86400 s = one day). 	 */
if|if
condition|(
name|current_time
operator|-
name|last_time
operator|>
name|NTP_MAXAGE
condition|)
name|last_time
operator|=
literal|0
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|sys_refskew
argument_list|,
name|NTP_SKEWINC
argument_list|)
expr_stmt|;
comment|/* 	 * Declare PPS kernel unsync if the pps signal has been heard 	 * during the last few minutes. 	 */
if|if
condition|(
name|pps_control
operator|&&
name|current_time
operator|-
name|pps_control
operator|>
name|PPS_MAXAGE
condition|)
block|{
if|if
condition|(
name|pps_control
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"kernel pps sync disabled"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the phase-lock loop is not implemented in the kernel, we 	 * do it the hard way using incremental adjustments and the 	 * adjtime() system call. 	 */
if|if
condition|(
name|pll_control
operator|&&
name|pll_enable
condition|)
return|return;
name|adjustment
operator|=
name|clock_adjust
expr_stmt|;
if|if
condition|(
name|adjustment
operator|<
literal|0
condition|)
name|adjustment
operator|=
operator|-
operator|(
operator|-
name|adjustment
operator|>>
name|CLOCK_PHASE
operator|)
expr_stmt|;
else|else
name|adjustment
operator|>>=
name|CLOCK_PHASE
expr_stmt|;
name|clock_adjust
operator|-=
name|adjustment
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|<
literal|0
condition|)
name|adjustment
operator|-=
operator|-
name|drift_comp
operator|>>
name|RSH_DRIFT_TO_ADJ
expr_stmt|;
else|else
name|adjustment
operator|+=
name|drift_comp
operator|>>
name|RSH_DRIFT_TO_ADJ
expr_stmt|;
comment|/* 	 * Intricate wrinkle. If the local clock driver is in use and 	 * selected for synchronization, somebody else may be tinker the 	 * adjtime() syscall. In this case we have to avoid calling 	 * adjtime(), since that may truncate the other guy's requests. 	 * That means the local clock fudge time and frequency 	 * adjustments don't work in that case. Caveat empty. 	 */
if|if
condition|(
name|sys_peer
condition|)
block|{
if|if
condition|(
name|sys_peer
operator|->
name|refclktype
operator|==
name|REFCLK_LOCALCLOCK
operator|&&
name|sys_peer
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
return|return;
block|}
name|L_CLR
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|offset
argument_list|,
name|adjustment
argument_list|)
expr_stmt|;
name|adj_systime
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * adj_frequency - adjust local clock frequency  */
end_comment

begin_function
name|void
name|adj_frequency
parameter_list|(
name|freq
parameter_list|)
name|s_fp
name|freq
decl_stmt|;
comment|/* frequency (ppm) */
block|{
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
name|struct
name|timex
name|ntv
decl_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
comment|/* 	 * This routine adjusts the frequency offset. It is used by the 	 * local clock driver to adjust frequency when no external 	 * discipline source is available and by the acts driver when 	 * the interval between updates is greater than 1<< 	 * NTP_MAXPOLL. Note that the maximum offset is limited by 	 * max_comp when the daemon pll is used, but the maximum may be 	 * different when the kernel pll is used. 	 */
name|drift_comp
operator|+=
name|freq
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|>
name|max_comp
condition|)
name|drift_comp
operator|=
name|max_comp
expr_stmt|;
elseif|else
if|if
condition|(
name|drift_comp
operator|<
operator|-
name|max_comp
condition|)
name|drift_comp
operator|=
operator|-
name|max_comp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
comment|/* 	 * If the phase-lock code is implemented in the kernel, set the 	 * kernel frequency as well, but be sure to set drift_comp to 	 * the actual frequency. 	 */
if|if
condition|(
operator|!
operator|(
name|pll_control
operator|&&
name|pll_enable
operator|)
condition|)
return|return;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ntv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ntv
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|modes
operator|=
name|MOD_FREQUENCY
expr_stmt|;
name|ntv
operator|.
name|freq
operator|=
name|freq
operator|+
name|drift_comp
expr_stmt|;
operator|(
name|void
operator|)
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
name|drift_comp
operator|=
name|ntv
operator|.
name|freq
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
block|}
end_function

begin_comment
comment|/*  * loop_config - configure the loop filter  */
end_comment

begin_function
name|void
name|loop_config
parameter_list|(
name|item
parameter_list|,
name|lfp_value
parameter_list|,
name|int_value
parameter_list|)
name|int
name|item
decl_stmt|;
name|l_fp
modifier|*
name|lfp_value
decl_stmt|;
name|int
name|int_value
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
name|struct
name|timex
name|ntv
decl_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"loop_config %d %s %x\n"
argument_list|,
name|item
argument_list|,
name|lfptoa
argument_list|(
name|lfp_value
argument_list|,
literal|3
argument_list|)
argument_list|,
name|int_value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|LOOP_DRIFTCOMP
case|:
name|drift_comp
operator|=
name|LFPTOFP
argument_list|(
name|lfp_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|>
name|max_comp
condition|)
name|drift_comp
operator|=
name|max_comp
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|<
operator|-
name|max_comp
condition|)
name|drift_comp
operator|=
operator|-
name|max_comp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
comment|/* 		 * If the phase-lock code is implemented in the kernel, 		 * give the time_constant and saved frequency offset to 		 * the kernel. If not, no harm is done. We do this 		 * whether or not the use of the kernel mods is 		 * requested, in order to clear out the trash from 		 * possible prior customers.  		 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ntv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ntv
argument_list|)
expr_stmt|;
name|pll_status
operator|=
name|int_value
operator|&
operator|(
name|STA_PLL
operator||
name|STA_PPSFREQ
operator|)
expr_stmt|;
if|if
condition|(
name|pll_status
operator|&
name|STA_PLL
condition|)
name|pll_control
operator|=
literal|1
expr_stmt|;
else|else
name|pll_control
operator|=
literal|0
expr_stmt|;
name|ntv
operator|.
name|modes
operator|=
name|MOD_BITS
operator||
name|MOD_FREQUENCY
expr_stmt|;
if|if
condition|(
name|pll_status
condition|)
block|{
name|ntv
operator|.
name|freq
operator|=
name|drift_comp
expr_stmt|;
name|ntv
operator|.
name|maxerror
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|ntv
operator|.
name|esterror
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|ntv
operator|.
name|status
operator|=
name|pll_status
operator||
name|STA_UNSYNC
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|sys_poll
operator|-
name|NTP_MINPOLL
expr_stmt|;
block|}
name|newsigsys
operator|.
name|sv_handler
operator|=
name|pll_trap
expr_stmt|;
name|newsigsys
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
name|newsigsys
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sigvec
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|newsigsys
argument_list|,
operator|&
name|sigsys
argument_list|)
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec() fails to save SIGSYS trap: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigvec
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|sigsys
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec() fails to restore SIGSYS trap: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll_control
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"using kernel phase-lock loop %04x"
argument_list|,
name|ntv
operator|.
name|status
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"using xntpd phase-lock loop"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
break|break;
default|default:
comment|/* sigh */
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
end_if

begin_comment
comment|/*  * _trap - trap processor for undefined syscalls  *  * This nugget is called by the kernel when the SYS_ntp_adjtime()  * syscall bombs because the silly thing has not been implemented in  * the kernel. In this case the phase-lock loop is emulated by  * the stock adjtime() syscall and a lot of indelicate abuse.  */
end_comment

begin_function
name|RETSIGTYPE
name|pll_trap
parameter_list|()
block|{
name|pll_control
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

end_unit

