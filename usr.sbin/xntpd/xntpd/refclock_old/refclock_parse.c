begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|PARSE
argument_list|)
operator|||
name|defined
argument_list|(
name|PARSEPPS
argument_list|)
operator|)
end_if

begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/xntpd/refclock_parse.c,v 3.53 1994/03/25 13:07:39 kardel Exp  *  * refclock_parse.c,v 3.53 1994/03/25 13:07:39 kardel Exp  *  * generic reference clock driver for receivers  *  * make use of a STREAMS module for input processing where  * available and configured. Currently the STREAMS module  * is only available for Suns running SunOS 4.x and SunOS5.x (new - careful!)  *  * Copyright (c) 1989,1990,1991,1992,1993,1994  * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_comment
comment|/*  * Defines:  *  REFCLOCK&& (PARSE||PARSEPPS)  *                    - enable this mess  *  STREAM            - allow for STREAMS modules  *                      ("parse", "ppsclocd", "ppsclock")  *  PARSEPPS          - provide PPS information to loopfilter (for  *                      backward compatibilty only)  *  PPS		      - supply loopfilter with PPS samples (if configured)  *  PPSPPS            - notify loopfilter of PPS file descriptor  *  *  FREEBSD_CONRAD    - Make very cheap "Conrad DCF77 RS-232" gadget work  *			with FreeBSD.  * TTY defines:  *  HAVE_BSD_TTYS     - currently unsupported  *  HAVE_SYSV_TTYS    - will use termio.h  *  HAVE_TERMIOS      - will use termios.h  *  STREAM            - will use streams and implies HAVE_TERMIOS  */
end_comment

begin_comment
comment|/*  * This driver currently provides the support for  *   - Meinberg DCF77 receiver DCF77 PZF 535 (TCXO version) (DCF)  *   - Meinberg DCF77 receiver DCF77 PZF 535 (OCXO version) (DCF)  *   - Meinberg DCF77 receiver U/A 31                       (DCF)  *   - ELV DCF7000                                          (DCF)  *   - Schmid clock                                         (DCF)  *   - Conrad DCF77 receiver module                         (DCF)  *   - FAU DCF77 NTP receiver (TimeBrick)                   (DCF)  *   - Meinberg GPS166                                      (GPS)  *   - Trimble SV6                                          (GPS)  *  */
end_comment

begin_comment
comment|/*  * Meinberg receivers are connected via a 9600 baud serial line  *  * Receivers that do NOT support:  *          - leap second indication  * 	DCF U/A 31  *	DCF PZF535 (stock version)  *  * so...  *          - for PZF535 please ask for revision PZFUERL4.6 or higher  *            (support for leap second and alternate antenna)  *  * The Meinberg GPS receiver also has a special NTP time stamp  * format. The firmware release is Uni-Erlangen. Only this  * firmware release is supported by xntp3.  *  * Meinberg generic receiver setup:  *	output time code every second  *	Baud rate 9600 7E2S  */
end_comment

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_CONRAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STREAM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_comment
comment|/* #error NEED TO DEFINE ONE OF "STREAM" or "HAVE_SYSV_TTYS" */
end_comment

begin_expr_stmt
name|NEED
name|TO
name|DEFINE
name|ONE
name|OF
literal|"STREAM"
operator|,
literal|"HAVE_SYSV_TTYS"
name|or
literal|"HAVE_TERMIOS"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STREAM
include|#
directive|include
file|<sys/stream.h>
include|#
directive|include
file|<sys/stropts.h>
ifndef|#
directive|ifndef
name|HAVE_TERMIOS
define|#
directive|define
name|HAVE_TERMIOS
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
include|#
directive|include
file|<termios.h>
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcgetattr((_FD_), (_ARG_))
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|tcsetattr((_FD_), TCSANOW, (_ARG_))
undef|#
directive|undef
name|HAVE_SYSV_TTYS
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
include|#
directive|include
file|<termio.h>
define|#
directive|define
name|TTY_GETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCGETA, (_ARG_))
define|#
directive|define
name|TTY_SETATTR
parameter_list|(
name|_FD_
parameter_list|,
name|_ARG_
parameter_list|)
value|ioctl((_FD_), TCSETAW, (_ARG_))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_BSD_TTYS
comment|/* #error CURRENTLY NO BSD TTY SUPPORT */
name|CURRENTLY
name|NO
name|BSD
name|TTY
name|SUPPORT
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_RDWR
argument_list|)
comment|/* XXX SOLARIS */
include|#
directive|include
file|<fcntl.h>
endif|#
directive|endif
comment|/* !def(O_RDWR) */
ifdef|#
directive|ifdef
name|PPSPPS
include|#
directive|include
file|<sys/ppsclock.h>
endif|#
directive|endif
include|#
directive|include
file|"ntp_select.h"
include|#
directive|include
file|"ntp_stdlib.h"
include|#
directive|include
file|"parse.h"
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_SCCSID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
specifier|static
name|char
name|rcsid
index|[]
operator|=
literal|"refclock_parse.c,v 3.53 1994/03/25 13:07:39 kardel Exp"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**===========================================================================  ** external interface to xntp mechanism  **/
end_comment

begin_decl_stmt
specifier|static
name|void
name|parse_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_start
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_shutdown
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_control
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|parse_buginfo
value|noentry
end_define

begin_decl_stmt
name|struct
name|refclock
name|refclock_parse
init|=
block|{
name|parse_start
block|,
name|parse_shutdown
block|,
name|parse_poll
block|,
name|parse_control
block|,
name|parse_init
block|,
name|parse_buginfo
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the unit field selects for one the prototype to be used (lower 4 bits)  * and for the other the clock type in case of different but similar  * receivers (bits 4-6)  * the most significant bit encodes PPS support  * when the most significant bit is set the pps telegrams will be used  * for controlling the local clock (ntp_loopfilter.c)  * receiver specific configration data is kept in the clockinfo field.  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|4
end_define

begin_comment
comment|/* maximum number of "PARSE" units permitted */
end_comment

begin_define
define|#
directive|define
name|PARSEDEVICE
value|"/dev/refclock-%d"
end_define

begin_comment
comment|/* device to open %d is unit number */
end_comment

begin_comment
comment|/**===========================================================================  ** function vector for dynamically binding io handling mechanism  **/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bind
block|{
name|char
modifier|*
name|bd_description
decl_stmt|;
comment|/* name of type of binding */
name|int
function_decl|(
modifier|*
name|bd_init
function_decl|)
parameter_list|()
function_decl|;
comment|/* initialize */
name|void
function_decl|(
modifier|*
name|bd_end
function_decl|)
parameter_list|()
function_decl|;
comment|/* end */
name|int
function_decl|(
modifier|*
name|bd_setcs
function_decl|)
parameter_list|()
function_decl|;
comment|/* set character size */
name|int
function_decl|(
modifier|*
name|bd_disable
function_decl|)
parameter_list|()
function_decl|;
comment|/* disable */
name|int
function_decl|(
modifier|*
name|bd_enable
function_decl|)
parameter_list|()
function_decl|;
comment|/* enable */
name|int
function_decl|(
modifier|*
name|bd_getfmt
function_decl|)
parameter_list|()
function_decl|;
comment|/* get format */
name|int
function_decl|(
modifier|*
name|bd_setfmt
function_decl|)
parameter_list|()
function_decl|;
comment|/* setfmt */
name|int
function_decl|(
modifier|*
name|bd_getstat
function_decl|)
parameter_list|()
function_decl|;
comment|/* getstat */
name|int
function_decl|(
modifier|*
name|bd_setstat
function_decl|)
parameter_list|()
function_decl|;
comment|/* setstat */
name|int
function_decl|(
modifier|*
name|bd_timecode
function_decl|)
parameter_list|()
function_decl|;
comment|/* get time code */
name|void
function_decl|(
modifier|*
name|bd_receive
function_decl|)
parameter_list|()
function_decl|;
comment|/* receive operation */
name|void
function_decl|(
modifier|*
name|bd_poll
function_decl|)
parameter_list|()
function_decl|;
comment|/* poll operation */
block|}
name|bind_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PARSE_END
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_end)(_X_)
end_define

begin_define
define|#
directive|define
name|PARSE_SETCS
parameter_list|(
name|_X_
parameter_list|,
name|_CS_
parameter_list|)
value|(*(_X_)->binding->bd_setcs)(_X_, _CS_)
end_define

begin_define
define|#
directive|define
name|PARSE_ENABLE
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_enable)(_X_)
end_define

begin_define
define|#
directive|define
name|PARSE_DISABLE
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_disable)(_X_)
end_define

begin_define
define|#
directive|define
name|PARSE_GETFMT
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_getfmt)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_SETFMT
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_setfmt)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_GETSTAT
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_getstat)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_SETSTAT
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_setstat)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_GETTIMECODE
parameter_list|(
name|_X_
parameter_list|,
name|_DCT_
parameter_list|)
value|(*(_X_)->binding->bd_timecode)(_X_, _DCT_)
end_define

begin_define
define|#
directive|define
name|PARSE_POLL
parameter_list|(
name|_X_
parameter_list|)
value|(*(_X_)->binding->bd_poll)(_X_)
end_define

begin_comment
comment|/*  * io modes  */
end_comment

begin_define
define|#
directive|define
name|PARSE_F_NOPOLLONLY
value|0x0001
end_define

begin_comment
comment|/* always do async io (possible PPS support via PARSE) */
end_comment

begin_define
define|#
directive|define
name|PARSE_F_POLLONLY
value|0x0002
end_define

begin_comment
comment|/* never do async io  (no PPS support via PARSE) */
end_comment

begin_define
define|#
directive|define
name|PARSE_F_PPSPPS
value|0x0004
end_define

begin_comment
comment|/* use loopfilter PPS code (CIOGETEV) */
end_comment

begin_define
define|#
directive|define
name|PARSE_F_PPSONSECOND
value|0x0008
end_define

begin_comment
comment|/* PPS pulses are on second */
end_comment

begin_comment
comment|/**===========================================================================  ** refclock instance data  **/
end_comment

begin_struct
struct|struct
name|parseunit
block|{
comment|/*    * XNTP management    */
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* backlink to peer structure - refclock inactive if 0  */
name|int
name|fd
decl_stmt|;
comment|/* device file descriptor */
name|u_char
name|unit
decl_stmt|;
comment|/* encoded unit/type/PPS */
comment|/*    * XNTP io    */
name|struct
name|refclockio
name|io
decl_stmt|;
comment|/* io system structure (used in PPS mode) */
name|bind_t
modifier|*
name|binding
decl_stmt|;
comment|/* io handling binding */
comment|/*    * parse state    */
name|parse_t
name|parseio
decl_stmt|;
comment|/* io handling structure (user level parsing) */
comment|/*    * type specific parameters    */
name|struct
name|clockinfo
modifier|*
name|parse_type
decl_stmt|;
comment|/* link to clock description */
comment|/*    * clock specific configuration    */
name|l_fp
name|basedelay
decl_stmt|;
comment|/* clock local phase offset */
name|l_fp
name|ppsdelay
decl_stmt|;
comment|/* clock local pps phase offset */
comment|/*    * clock state handling/reporting    */
name|u_char
name|flags
decl_stmt|;
comment|/* flags (leap_control) */
name|u_char
name|status
decl_stmt|;
comment|/* current status */
name|u_char
name|lastevent
decl_stmt|;
comment|/* last not NORMAL status */
name|U_LONG
name|lastchange
decl_stmt|;
comment|/* time (xntp) when last state change accured */
name|U_LONG
name|statetime
index|[
name|CEVNT_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* accumulated time of clock states */
name|struct
name|event
name|stattimer
decl_stmt|;
comment|/* statistics timer */
name|U_LONG
name|polls
decl_stmt|;
comment|/* polls from NTP protocol machine */
name|U_LONG
name|noresponse
decl_stmt|;
comment|/* number of expected but not seen datagrams */
name|U_LONG
name|badformat
decl_stmt|;
comment|/* bad format (failed format conversions) */
name|U_LONG
name|baddata
decl_stmt|;
comment|/* usually bad receive length, bad format */
name|u_char
name|pollonly
decl_stmt|;
comment|/* 1 for polling only (no PPS mode) */
name|u_char
name|pollneeddata
decl_stmt|;
comment|/* 1 for receive sample expected in PPS mode */
name|U_LONG
name|laststatus
decl_stmt|;
comment|/* last packet status (error indication) */
name|u_short
name|lastformat
decl_stmt|;
comment|/* last format used */
name|U_LONG
name|lastsync
decl_stmt|;
comment|/* time (xntp) when clock was last seen fully synchronized */
name|U_LONG
name|timestarted
decl_stmt|;
comment|/* time (xntp) when peer clock was instantiated */
name|U_LONG
name|nosynctime
decl_stmt|;
comment|/* time (xntp) when last nosync message was posted */
name|U_LONG
name|lastmissed
decl_stmt|;
comment|/* time (xntp) when poll didn't get data (powerup heuristic) */
name|U_LONG
name|ppsserial
decl_stmt|;
comment|/* magic cookie for ppsclock serials (avoids stale ppsclock data) */
name|parsetime_t
name|time
decl_stmt|;
comment|/* last (parse module) data */
name|void
modifier|*
name|localdata
decl_stmt|;
comment|/* optional local data */
block|}
struct|;
end_struct

begin_comment
comment|/**===========================================================================  ** Clockinfo section all parameter for specific clock types  ** includes NTP paramaters, TTY parameters and IO handling parameters  **/
end_comment

begin_decl_stmt
specifier|static
name|void
name|poll_dpoll
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|poll_poll
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|poll_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|poll_end
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|poll_info
block|{
name|U_LONG
name|rate
decl_stmt|;
comment|/* poll rate - once every "rate" seconds - 0 off */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string to send for polling */
name|U_LONG
name|count
decl_stmt|;
comment|/* number of charcters in string */
block|}
name|poll_info_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NO_FLAGS
value|0
end_define

begin_define
define|#
directive|define
name|NO_POLL
value|(void (*)())0
end_define

begin_define
define|#
directive|define
name|NO_INIT
value|(int  (*)())0
end_define

begin_define
define|#
directive|define
name|NO_END
value|(void (*)())0
end_define

begin_define
define|#
directive|define
name|NO_DATA
value|(void *)0
end_define

begin_define
define|#
directive|define
name|NO_FORMAT
value|""
end_define

begin_define
define|#
directive|define
name|NO_PPSDELAY
value|0
end_define

begin_define
define|#
directive|define
name|DCF_ID
value|"DCF"
end_define

begin_comment
comment|/* generic DCF */
end_comment

begin_define
define|#
directive|define
name|DCF_A_ID
value|"DCFa"
end_define

begin_comment
comment|/* AM demodulation */
end_comment

begin_define
define|#
directive|define
name|DCF_P_ID
value|"DCFp"
end_define

begin_comment
comment|/* psuedo random phase shift */
end_comment

begin_define
define|#
directive|define
name|GPS_ID
value|"GPS"
end_define

begin_comment
comment|/* GPS receiver */
end_comment

begin_define
define|#
directive|define
name|NOCLOCK_ROOTDELAY
value|0x00000000
end_define

begin_define
define|#
directive|define
name|NOCLOCK_BASEDELAY
value|0x00000000
end_define

begin_define
define|#
directive|define
name|NOCLOCK_DESCRIPTION
value|((char *)0)
end_define

begin_define
define|#
directive|define
name|NOCLOCK_MAXUNSYNC
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_CFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_IFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_LFLAG
value|0
end_define

begin_define
define|#
directive|define
name|NOCLOCK_ID
value|"TILT"
end_define

begin_define
define|#
directive|define
name|NOCLOCK_POLL
value|NO_POLL
end_define

begin_define
define|#
directive|define
name|NOCLOCK_INIT
value|NO_INIT
end_define

begin_define
define|#
directive|define
name|NOCLOCK_END
value|NO_END
end_define

begin_define
define|#
directive|define
name|NOCLOCK_DATA
value|NO_DATA
end_define

begin_define
define|#
directive|define
name|NOCLOCK_FORMAT
value|NO_FORMAT
end_define

begin_define
define|#
directive|define
name|NOCLOCK_TYPE
value|CTL_SST_TS_UNSPEC
end_define

begin_define
define|#
directive|define
name|DCF_TYPE
value|CTL_SST_TS_LF
end_define

begin_define
define|#
directive|define
name|GPS_TYPE
value|CTL_SST_TS_UHF
end_define

begin_comment
comment|/*  * receiver specific constants  */
end_comment

begin_define
define|#
directive|define
name|MBG_CFLAG19200
value|(B19200|CS7|PARENB|CREAD|HUPCL)
end_define

begin_define
define|#
directive|define
name|MBG_CFLAG
value|(B9600|CS7|PARENB|CREAD|HUPCL)
end_define

begin_define
define|#
directive|define
name|MBG_IFLAG
value|(IGNBRK|IGNPAR|ISTRIP)
end_define

begin_define
define|#
directive|define
name|MBG_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|MBG_LFLAG
value|0
end_define

begin_comment
comment|/*  * Meinberg DCF U/A 31 (AM) receiver  */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_ROOTDELAY
value|0x00000D00
end_define

begin_comment
comment|/* 50.78125ms */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_BASEDELAY
value|0x02C00000
end_define

begin_comment
comment|/* 10.7421875ms: 10 ms (+/- 3 ms) */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_DESCRIPTION
value|"Meinberg DCF U/A 31"
end_define

begin_define
define|#
directive|define
name|DCFUA31_MAXUNSYNC
value|60*30
end_define

begin_comment
comment|/* only trust clock for 1/2 hour */
end_comment

begin_define
define|#
directive|define
name|DCFUA31_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|DCFUA31_LFLAG
value|MBG_LFLAG
end_define

begin_comment
comment|/*  * Meinberg DCF PZF535/TCXO (FM/PZF) receiver  */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_ROOTDELAY
value|0x00000034
end_define

begin_comment
comment|/* 800us */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_BASEDELAY
value|0x00800000
end_define

begin_comment
comment|/* 1.968ms +- 104us (oscilloscope) - relative to start (end of STX) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_DESCRIPTION
value|"Meinberg DCF PZF 535/TCXO"
end_define

begin_define
define|#
directive|define
name|DCFPZF535_MAXUNSYNC
value|60*60*12
end_define

begin_comment
comment|/* only trust clock for 12 hours 						    * @ 5e-8df/f we have accumulated 						    * at most 2.16 ms (thus we move to 						    * NTP synchronisation */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535_LFLAG
value|MBG_LFLAG
end_define

begin_comment
comment|/*  * Meinberg DCF PZF535/OCXO receiver  */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_ROOTDELAY
value|0x00000034
end_define

begin_comment
comment|/* 800us (max error * 10) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_BASEDELAY
value|0x00800000
end_define

begin_comment
comment|/* 1.968ms +- 104us (oscilloscope) - relative to start (end of STX) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_DESCRIPTION
value|"Meinberg DCF PZF 535/OCXO"
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_MAXUNSYNC
value|60*60*96
end_define

begin_comment
comment|/* only trust clock for 4 days 						    * @ 5e-9df/f we have accumulated 						    * at most an error of 1.73 ms 						    * (thus we move to NTP synchronisation) */
end_comment

begin_define
define|#
directive|define
name|DCFPZF535OCXO_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|DCFPZF535OCXO_LFLAG
value|MBG_LFLAG
end_define

begin_comment
comment|/*  * Meinberg GPS166 receiver  */
end_comment

begin_define
define|#
directive|define
name|GPS166_ROOTDELAY
value|0x00000000
end_define

begin_comment
comment|/* nothing here */
end_comment

begin_define
define|#
directive|define
name|GPS166_BASEDELAY
value|0x00800000
end_define

begin_comment
comment|/* XXX to be fixed ! 1.968ms +- 104us (oscilloscope) - relative to start (end of STX) */
end_comment

begin_define
define|#
directive|define
name|GPS166_DESCRIPTION
value|"Meinberg GPS166 receiver"
end_define

begin_define
define|#
directive|define
name|GPS166_MAXUNSYNC
value|0
end_define

begin_comment
comment|/* this clock is immediately lost */
end_comment

begin_define
define|#
directive|define
name|GPS166_CFLAG
value|MBG_CFLAG
end_define

begin_define
define|#
directive|define
name|GPS166_IFLAG
value|MBG_IFLAG
end_define

begin_define
define|#
directive|define
name|GPS166_OFLAG
value|MBG_OFLAG
end_define

begin_define
define|#
directive|define
name|GPS166_LFLAG
value|MBG_LFLAG
end_define

begin_define
define|#
directive|define
name|GPS166_POLL
value|NO_POLL
end_define

begin_define
define|#
directive|define
name|GPS166_INIT
value|NO_INIT
end_define

begin_define
define|#
directive|define
name|GPS166_END
value|NO_END
end_define

begin_define
define|#
directive|define
name|GPS166_DATA
value|NO_DATA
end_define

begin_define
define|#
directive|define
name|GPS166_ID
value|GPS_ID
end_define

begin_define
define|#
directive|define
name|GPS166_FORMAT
value|NO_FORMAT
end_define

begin_comment
comment|/*  * ELV DCF7000 Wallclock-Receiver/Switching Clock (Kit)  *  * This is really not the hottest clock - but before you have nothing ...  */
end_comment

begin_define
define|#
directive|define
name|DCF7000_ROOTDELAY
value|0x00000364
end_define

begin_comment
comment|/* 13 ms */
end_comment

begin_define
define|#
directive|define
name|DCF7000_BASEDELAY
value|0x67AE0000
end_define

begin_comment
comment|/* 405 ms - slow blow */
end_comment

begin_define
define|#
directive|define
name|DCF7000_DESCRIPTION
value|"ELV DCF7000"
end_define

begin_define
define|#
directive|define
name|DCF7000_MAXUNSYNC
value|(60*5)
end_define

begin_comment
comment|/* sorry - but it just was not build as a clock */
end_comment

begin_define
define|#
directive|define
name|DCF7000_CFLAG
value|(B9600|CS8|CREAD|PARENB|PARODD|CLOCAL|HUPCL)
end_define

begin_define
define|#
directive|define
name|DCF7000_IFLAG
value|(IGNBRK)
end_define

begin_define
define|#
directive|define
name|DCF7000_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|DCF7000_LFLAG
value|0
end_define

begin_comment
comment|/*  * Schmid DCF Receiver Kit  *  * When the WSDCF clock is operating optimally we want the primary clock  * distance to come out at 300 ms.  Thus, peer.distance in the WSDCF peer  * structure is set to 290 ms and we compute delays which are at least  * 10 ms long.  The following are 290 ms and 10 ms expressed in u_fp format  */
end_comment

begin_define
define|#
directive|define
name|WS_POLLRATE
value|1
end_define

begin_comment
comment|/* every second - watch interdependency with poll routine */
end_comment

begin_define
define|#
directive|define
name|WS_POLLCMD
value|"\163"
end_define

begin_define
define|#
directive|define
name|WS_CMDSIZE
value|1
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|wsdcf_pollinfo
init|=
block|{
name|WS_POLLRATE
block|,
name|WS_POLLCMD
block|,
name|WS_CMDSIZE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WSDCF_INIT
value|poll_init
end_define

begin_define
define|#
directive|define
name|WSDCF_POLL
value|poll_dpoll
end_define

begin_define
define|#
directive|define
name|WSDCF_END
value|poll_end
end_define

begin_define
define|#
directive|define
name|WSDCF_DATA
value|((void *)(&wsdcf_pollinfo))
end_define

begin_define
define|#
directive|define
name|WSDCF_ROOTDELAY
value|0X00004A3D
end_define

begin_comment
comment|/*  ~ 290ms */
end_comment

begin_define
define|#
directive|define
name|WSDCF_BASEDELAY
value|0x028F5C29
end_define

begin_comment
comment|/*  ~  10ms */
end_comment

begin_define
define|#
directive|define
name|WSDCF_DESCRIPTION
value|"WS/DCF Receiver"
end_define

begin_define
define|#
directive|define
name|WSDCF_FORMAT
value|"Schmid"
end_define

begin_define
define|#
directive|define
name|WSDCF_MAXUNSYNC
value|(60*60)
end_define

begin_comment
comment|/* assume this beast hold at 1 h better than 2 ms XXX-must verify */
end_comment

begin_define
define|#
directive|define
name|WSDCF_CFLAG
value|(B1200|CS8|CREAD|CLOCAL)
end_define

begin_define
define|#
directive|define
name|WSDCF_IFLAG
value|0
end_define

begin_define
define|#
directive|define
name|WSDCF_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|WSDCF_LFLAG
value|0
end_define

begin_comment
comment|/*  * RAW DCF77 - input of DCF marks via RS232 - many variants  */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_FLAGS
value|PARSE_F_NOPOLLONLY
end_define

begin_define
define|#
directive|define
name|RAWDCF_ROOTDELAY
value|0x00000364
end_define

begin_comment
comment|/* 13 ms */
end_comment

begin_define
define|#
directive|define
name|RAWDCF_FORMAT
value|"RAW DCF77 Timecode"
end_define

begin_define
define|#
directive|define
name|RAWDCF_MAXUNSYNC
value|(0)
end_define

begin_comment
comment|/* sorry - its a true receiver - no signal - no time */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREEBSD_CONRAD
end_ifdef

begin_define
define|#
directive|define
name|RAWDCF_CFLAG
value|(CS8|CREAD|CLOCAL)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RAWDCF_CFLAG
value|(B50|CS8|CREAD|CLOCAL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RAWDCF_IFLAG
value|0
end_define

begin_define
define|#
directive|define
name|RAWDCF_OFLAG
value|0
end_define

begin_define
define|#
directive|define
name|RAWDCF_LFLAG
value|0
end_define

begin_comment
comment|/*  * RAW DCF variants  */
end_comment

begin_comment
comment|/*  * Conrad receiver  *  * simplest (cheapest) DCF clock - e. g. DCF77 receiver by Conrad  * (~40DM - roughly $30 ) followed by a level converter for RS232  */
end_comment

begin_define
define|#
directive|define
name|CONRAD_BASEDELAY
value|0x420C49B0
end_define

begin_comment
comment|/* ~258 ms - Conrad receiver @ 50 Baud on a Sun */
end_comment

begin_define
define|#
directive|define
name|CONRAD_DESCRIPTION
value|"RAW DCF77 CODE (Conrad DCF77 receiver module)"
end_define

begin_comment
comment|/*  * TimeBrick receiver  */
end_comment

begin_define
define|#
directive|define
name|TIMEBRICK_BASEDELAY
value|0x35C29000
end_define

begin_comment
comment|/* ~210 ms - TimeBrick @ 50 Baud on a Sun */
end_comment

begin_define
define|#
directive|define
name|TIMEBRICK_DESCRIPTION
value|"RAW DCF77 CODE (TimeBrick)"
end_define

begin_comment
comment|/*  * Trimble SV6 GPS receiver  */
end_comment

begin_define
define|#
directive|define
name|TRIM_POLLRATE
value|0
end_define

begin_comment
comment|/* only true direct polling */
end_comment

begin_define
define|#
directive|define
name|TRIM_POLLCMD
value|">QTM<"
end_define

begin_define
define|#
directive|define
name|TRIM_CMDSIZE
value|5
end_define

begin_decl_stmt
specifier|static
name|poll_info_t
name|trimble_pollinfo
init|=
block|{
name|TRIM_POLLRATE
block|,
name|TRIM_POLLCMD
block|,
name|TRIM_CMDSIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trimble_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRIMBLESV6_CFLAG
value|(B4800|CS8|CREAD)
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_IFLAG
value|(BRKINT|IGNPAR|ISTRIP|ICRNL|IXON)
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_OFLAG
value|(OPOST|ONLCR)
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_LFLAG
value|(ICANON|ECHOK)
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_FLAGS
value|(PARSE_F_PPSPPS|PARSE_F_PPSONSECOND)
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_POLL
value|poll_dpoll
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_INIT
value|trimble_init
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_END
value|poll_end
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_DATA
value|((void *)(&trimble_pollinfo))
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_ID
value|GPS_ID
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_FORMAT
value|NO_FORMAT
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_ROOTDELAY
value|0x0
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_BASEDELAY
value|0x0
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_DESCRIPTION
value|"Trimble SV6 GPS receiver"
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_MAXUNSYNC
value|0
end_define

begin_define
define|#
directive|define
name|TRIMBLESV6_EOL
value|'<'
end_define

begin_struct
specifier|static
struct|struct
name|clockinfo
block|{
name|U_LONG
name|cl_flags
decl_stmt|;
comment|/* operation flags (io modes) */
name|void
function_decl|(
modifier|*
name|cl_poll
function_decl|)
parameter_list|()
function_decl|;
comment|/* active poll routine */
name|int
function_decl|(
modifier|*
name|cl_init
function_decl|)
parameter_list|()
function_decl|;
comment|/* active poll init routine */
name|void
function_decl|(
modifier|*
name|cl_end
function_decl|)
parameter_list|()
function_decl|;
comment|/* active poll end routine */
name|void
modifier|*
name|cl_data
decl_stmt|;
comment|/* local data area for "poll" mechanism */
name|u_fp
name|cl_rootdelay
decl_stmt|;
comment|/* rootdelay */
name|U_LONG
name|cl_basedelay
decl_stmt|;
comment|/* current offset - unsigned l_fp fractional part */
name|U_LONG
name|cl_ppsdelay
decl_stmt|;
comment|/* current PPS offset - unsigned l_fp fractional part */
name|char
modifier|*
name|cl_id
decl_stmt|;
comment|/* ID code (usually "DCF") */
name|char
modifier|*
name|cl_description
decl_stmt|;
comment|/* device name */
name|char
modifier|*
name|cl_format
decl_stmt|;
comment|/* fixed format */
name|u_char
name|cl_type
decl_stmt|;
comment|/* clock type (ntp control) */
name|U_LONG
name|cl_maxunsync
decl_stmt|;
comment|/* time to trust oscillator after loosing synch */
name|U_LONG
name|cl_cflag
decl_stmt|;
comment|/* terminal io flags */
name|U_LONG
name|cl_iflag
decl_stmt|;
comment|/* terminal io flags */
name|U_LONG
name|cl_oflag
decl_stmt|;
comment|/* terminal io flags */
name|U_LONG
name|cl_lflag
decl_stmt|;
comment|/* terminal io flags */
block|}
name|clockinfo
index|[]
init|=
block|{
comment|/*   0.  0.0.128 - base offset for PPS support */
block|{
comment|/* 127.127.8.<device> */
name|NO_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_END
block|,
name|NO_DATA
block|,
name|DCFPZF535_ROOTDELAY
block|,
name|DCFPZF535_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_P_ID
block|,
name|DCFPZF535_DESCRIPTION
block|,
name|NO_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCFPZF535_MAXUNSYNC
block|,
name|DCFPZF535_CFLAG
block|,
name|DCFPZF535_IFLAG
block|,
name|DCFPZF535_OFLAG
block|,
name|DCFPZF535_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.4+<device> */
name|NO_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_END
block|,
name|NO_DATA
block|,
name|DCFPZF535OCXO_ROOTDELAY
block|,
name|DCFPZF535OCXO_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_P_ID
block|,
name|DCFPZF535OCXO_DESCRIPTION
block|,
name|NO_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCFPZF535OCXO_MAXUNSYNC
block|,
name|DCFPZF535OCXO_CFLAG
block|,
name|DCFPZF535OCXO_IFLAG
block|,
name|DCFPZF535OCXO_OFLAG
block|,
name|DCFPZF535OCXO_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.8+<device> */
name|NO_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_END
block|,
name|NO_DATA
block|,
name|DCFUA31_ROOTDELAY
block|,
name|DCFUA31_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_A_ID
block|,
name|DCFUA31_DESCRIPTION
block|,
name|NO_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCFUA31_MAXUNSYNC
block|,
name|DCFUA31_CFLAG
block|,
name|DCFUA31_IFLAG
block|,
name|DCFUA31_OFLAG
block|,
name|DCFUA31_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.12+<device> */
name|NO_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_END
block|,
name|NO_DATA
block|,
name|DCF7000_ROOTDELAY
block|,
name|DCF7000_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_A_ID
block|,
name|DCF7000_DESCRIPTION
block|,
name|NO_FORMAT
block|,
name|DCF_TYPE
block|,
name|DCF7000_MAXUNSYNC
block|,
name|DCF7000_CFLAG
block|,
name|DCF7000_IFLAG
block|,
name|DCF7000_OFLAG
block|,
name|DCF7000_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.16+<device> */
name|NO_FLAGS
block|,
name|WSDCF_POLL
block|,
name|WSDCF_INIT
block|,
name|WSDCF_END
block|,
name|WSDCF_DATA
block|,
name|WSDCF_ROOTDELAY
block|,
name|WSDCF_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_A_ID
block|,
name|WSDCF_DESCRIPTION
block|,
name|WSDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|WSDCF_MAXUNSYNC
block|,
name|WSDCF_CFLAG
block|,
name|WSDCF_IFLAG
block|,
name|WSDCF_OFLAG
block|,
name|WSDCF_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.20+<device> */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_END
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|CONRAD_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_A_ID
block|,
name|CONRAD_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|RAWDCF_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.24+<device> */
name|RAWDCF_FLAGS
block|,
name|NO_POLL
block|,
name|NO_INIT
block|,
name|NO_END
block|,
name|NO_DATA
block|,
name|RAWDCF_ROOTDELAY
block|,
name|TIMEBRICK_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|DCF_A_ID
block|,
name|TIMEBRICK_DESCRIPTION
block|,
name|RAWDCF_FORMAT
block|,
name|DCF_TYPE
block|,
name|RAWDCF_MAXUNSYNC
block|,
name|RAWDCF_CFLAG
block|,
name|RAWDCF_IFLAG
block|,
name|RAWDCF_OFLAG
block|,
name|RAWDCF_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.28+<device> */
name|NO_FLAGS
block|,
name|GPS166_POLL
block|,
name|GPS166_INIT
block|,
name|GPS166_END
block|,
name|GPS166_DATA
block|,
name|GPS166_ROOTDELAY
block|,
name|GPS166_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|GPS166_ID
block|,
name|GPS166_DESCRIPTION
block|,
name|GPS166_FORMAT
block|,
name|GPS_TYPE
block|,
name|GPS166_MAXUNSYNC
block|,
name|GPS166_CFLAG
block|,
name|GPS166_IFLAG
block|,
name|GPS166_OFLAG
block|,
name|GPS166_LFLAG
block|}
block|,
block|{
comment|/* 127.127.8.32+<device> */
name|TRIMBLESV6_FLAGS
block|,
name|TRIMBLESV6_POLL
block|,
name|TRIMBLESV6_INIT
block|,
name|TRIMBLESV6_END
block|,
name|TRIMBLESV6_DATA
block|,
name|TRIMBLESV6_ROOTDELAY
block|,
name|TRIMBLESV6_BASEDELAY
block|,
name|NO_PPSDELAY
block|,
name|TRIMBLESV6_ID
block|,
name|TRIMBLESV6_DESCRIPTION
block|,
name|TRIMBLESV6_FORMAT
block|,
name|GPS_TYPE
block|,
name|TRIMBLESV6_MAXUNSYNC
block|,
name|TRIMBLESV6_CFLAG
block|,
name|TRIMBLESV6_IFLAG
block|,
name|TRIMBLESV6_OFLAG
block|,
name|TRIMBLESV6_LFLAG
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ncltypes
init|=
sizeof|sizeof
argument_list|(
name|clockinfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|clockinfo
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CL_REALTYPE
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 2)& 0x1F)
end_define

begin_define
define|#
directive|define
name|CL_TYPE
parameter_list|(
name|x
parameter_list|)
value|((CL_REALTYPE(x)>= ncltypes) ? ~0 : CL_REALTYPE(x))
end_define

begin_define
define|#
directive|define
name|CL_PPS
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x80)
end_define

begin_define
define|#
directive|define
name|CL_UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x3)
end_define

begin_comment
comment|/*  * Other constant stuff  */
end_comment

begin_define
define|#
directive|define
name|PARSEHSREFID
value|0x7f7f08ff
end_define

begin_comment
comment|/* 127.127.8.255 refid for hi strata */
end_comment

begin_define
define|#
directive|define
name|PARSENOSYNCREPEAT
value|(10*60)
end_define

begin_comment
comment|/* mention uninitialized clocks all 10 minutes */
end_comment

begin_define
define|#
directive|define
name|PARSESTATISTICS
value|(60*60)
end_define

begin_comment
comment|/* output state statistics every hour */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|parseunit
modifier|*
name|parseunits
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPSPPS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|notice
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PARSE_STATETIME
parameter_list|(
name|parse
parameter_list|,
name|i
parameter_list|)
value|((parse->status == i) ? parse->statetime[i] + current_time - parse->lastchange : parse->statetime[i])
end_define

begin_decl_stmt
specifier|static
name|void
name|parse_event
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_process
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsetime_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**===========================================================================  ** implementation of i/o handling methods  ** (all STREAM, partial STREAM, user level)  **/
end_comment

begin_comment
comment|/*  * define possible io handling methods  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ppsclock_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stream_nop
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_enable
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_disable
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_setcs
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_getfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_setfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_getstat
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_setstat
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stream_timecode
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stream_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stream_poll
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|local_init
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_end
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_nop
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_setcs
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_getfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_setfmt
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_getstat
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_setstat
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_timecode
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|,
name|parsectl_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_poll
name|P
argument_list|(
operator|(
expr|struct
name|parseunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bind_t
name|io_bindings
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|STREAM
block|{
literal|"parse STREAM"
block|,
name|stream_init
block|,
name|stream_nop
block|,
name|stream_setcs
block|,
name|stream_disable
block|,
name|stream_enable
block|,
name|stream_getfmt
block|,
name|stream_setfmt
block|,
name|stream_getstat
block|,
name|stream_setstat
block|,
name|stream_timecode
block|,
name|stream_receive
block|,
name|stream_poll
block|}
block|,
block|{
literal|"ppsclock STREAM"
block|,
name|ppsclock_init
block|,
name|local_end
block|,
name|local_setcs
block|,
name|local_nop
block|,
name|local_nop
block|,
name|local_getfmt
block|,
name|local_setfmt
block|,
name|local_getstat
block|,
name|local_setstat
block|,
name|local_timecode
block|,
name|local_receive
block|,
name|local_poll
block|}
block|,
endif|#
directive|endif
block|{
literal|"normal"
block|,
name|local_init
block|,
name|local_end
block|,
name|local_setcs
block|,
name|local_nop
block|,
name|local_nop
block|,
name|local_getfmt
block|,
name|local_setfmt
block|,
name|local_getstat
block|,
name|local_setstat
block|,
name|local_timecode
block|,
name|local_receive
block|,
name|local_poll
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,   }
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STREAM
end_ifdef

begin_comment
comment|/*--------------------------------------------------  * ppsclock STREAM init  */
end_comment

begin_function
specifier|static
name|int
name|ppsclock_init
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
comment|/*    * now push the parse streams module    * it will ensure exclusive access to the device    */
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
literal|"ppsclocd"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
literal|"ppsclock"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: ppsclock_init: ioctl(fd, I_PUSH, \"ppsclock\"): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|local_init
argument_list|(
name|parse
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_POP
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|parse
operator|->
name|flags
operator||=
name|PARSE_PPSCLOCK
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse STREAM init  */
end_comment

begin_function
specifier|static
name|int
name|stream_init
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
comment|/*    * now push the parse streams module    * to test whether it is there (Oh boy - neat kernel interface)    */
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
literal|"parse"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_init: ioctl(fd, I_PUSH, \"parse\"): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_POP
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
comment|/* empty loop */
empty_stmt|;
comment|/*        * now push it a second time after we have removed all        * module garbage        */
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_PUSH
argument_list|,
operator|(
name|caddr_t
operator|)
literal|"parse"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_init: ioctl(fd, I_PUSH, \"parse\"): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM setcs  */
end_comment

begin_function
specifier|static
name|int
name|stream_setcs
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_SETCS
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_setcs: ioctl(fd, I_STR, PARSEIOC_SETCS): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM nop  */
end_comment

begin_function
specifier|static
name|void
name|stream_nop
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM enable  */
end_comment

begin_function
specifier|static
name|int
name|stream_enable
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_ENABLE
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_enable: ioctl(fd, I_STR, PARSEIOC_ENABLE): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM disable  */
end_comment

begin_function
specifier|static
name|int
name|stream_disable
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_DISABLE
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_disable: ioctl(fd, I_STR, PARSEIOC_DISABLE): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM getfmt  */
end_comment

begin_function
specifier|static
name|int
name|stream_getfmt
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_GETFMT
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: ioctl(fd, I_STR, PARSEIOC_GETFMT): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM setfmt  */
end_comment

begin_function
specifier|static
name|int
name|stream_setfmt
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_SETFMT
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_setfmt: ioctl(fd, I_STR, PARSEIOC_SETFMT): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM getstat  */
end_comment

begin_function
specifier|static
name|int
name|stream_getstat
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_GETSTAT
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_getstat: ioctl(fd, I_STR, PARSEIOC_GETSTAT): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM setstat  */
end_comment

begin_function
specifier|static
name|int
name|stream_setstat
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_SETSTAT
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: stream_setstat: ioctl(fd, I_STR, PARSEIOC_SETSTAT): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM timecode  */
end_comment

begin_function
specifier|static
name|int
name|stream_timecode
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
name|struct
name|strioctl
name|strioc
decl_stmt|;
name|strioc
operator|.
name|ic_cmd
operator|=
name|PARSEIOC_TIMECODE
expr_stmt|;
name|strioc
operator|.
name|ic_timout
operator|=
literal|0
expr_stmt|;
name|strioc
operator|.
name|ic_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|tcl
expr_stmt|;
name|strioc
operator|.
name|ic_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|strioc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_process: ioctl(fd, I_STR, PARSEIOC_TIMECODE): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parse
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM receive  */
end_comment

begin_function
specifier|static
name|void
name|stream_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
decl_stmt|;
name|parsetime_t
name|parsetime
decl_stmt|;
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|!=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_receive: bad size (got %d expected %d)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|baddata
operator|++
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
name|memmove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parsetime
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * switch time stamp world - be sure to normalize small usec field    * errors.    */
define|#
directive|define
name|fix_ts
parameter_list|(
name|_X_
parameter_list|)
define|\
value|if ((&(_X_))->tv.tv_usec>= 1000000)                \     {                                                 \       (&(_X_))->tv.tv_usec -= 1000000;                \       (&(_X_))->tv.tv_sec  += 1;                      \     }
define|#
directive|define
name|cvt_ts
parameter_list|(
name|_X_
parameter_list|,
name|_Y_
parameter_list|)
define|\
value|{                                                   \     l_fp ts;                                          \                                                       \     fix_ts((_X_));                                    \     if (!buftvtots((const char *)&(&(_X_))->tv,&ts)) \       {                                               \ 	syslog(LOG_ERR,"parse: stream_receive: timestamp conversion error (buftvtots) (%s) (%d.%06d) ", (_Y_), (&(_X_))->tv.tv_sec, (&(_X_))->tv.tv_usec);\ 	return;                                       \       }                                               \     else                                              \       {                                               \ 	(&(_X_))->fp = ts;                            \       }                                               \   }
if|if
condition|(
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|.
name|parse_state
argument_list|)
condition|)
block|{
name|cvt_ts
argument_list|(
name|parsetime
operator|.
name|parse_time
argument_list|,
literal|"parse_time"
argument_list|)
expr_stmt|;
name|cvt_ts
argument_list|(
name|parsetime
operator|.
name|parse_stime
argument_list|,
literal|"parse_stime"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parsetime
operator|.
name|parse_state
argument_list|)
condition|)
name|cvt_ts
argument_list|(
name|parsetime
operator|.
name|parse_ptime
argument_list|,
literal|"parse_ptime"
argument_list|)
expr_stmt|;
name|parse_process
argument_list|(
name|parse
argument_list|,
operator|&
name|parsetime
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * STREAM poll  */
end_comment

begin_function
specifier|static
name|void
name|stream_poll
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|rtc
decl_stmt|;
name|fd_set
name|fdmask
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|,
name|starttime
decl_stmt|,
name|curtime
decl_stmt|,
name|selecttime
decl_stmt|;
name|parsetime_t
name|parsetime
decl_stmt|;
comment|/*    * now we do the following:    *    - read the first packet from the parse module  (OLD !!!)    *    - read the second packet from the parse module (fresh)    *    - compute values for xntp    */
name|FD_ZERO
argument_list|(
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|fd
operator|=
name|parse
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
comment|/* 0.5 sec */
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GETTIMEOFDAY
argument_list|(
operator|&
name|starttime
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|selecttime
operator|=
name|timeout
expr_stmt|;
while|while
condition|(
operator|(
name|rtc
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|selecttime
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* no data from the radio clock */
if|if
condition|(
name|rtc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|GETTIMEOFDAY
argument_list|(
operator|&
name|curtime
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|selecttime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
operator|-
name|starttime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|curtime
operator|.
name|tv_usec
operator|<
name|starttime
operator|.
name|tv_usec
condition|)
block|{
name|selecttime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|selecttime
operator|.
name|tv_usec
operator|=
literal|1000000
operator|+
name|curtime
operator|.
name|tv_usec
operator|-
name|starttime
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|selecttime
operator|.
name|tv_usec
operator|=
name|curtime
operator|.
name|tv_usec
operator|-
name|starttime
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|selecttime
argument_list|,
operator|&
name|timeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* 		   * elapsed real time passed timeout value - consider it timed out 		   */
break|break;
block|}
comment|/* 	       * calculate residual timeout value 	       */
name|selecttime
operator|.
name|tv_sec
operator|=
name|timeout
operator|.
name|tv_sec
operator|-
name|selecttime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|selecttime
operator|.
name|tv_usec
operator|>
name|timeout
operator|.
name|tv_usec
condition|)
block|{
name|selecttime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|selecttime
operator|.
name|tv_usec
operator|=
literal|1000000
operator|+
name|timeout
operator|.
name|tv_usec
operator|-
name|selecttime
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|selecttime
operator|.
name|tv_usec
operator|=
name|timeout
operator|.
name|tv_usec
operator|-
name|selecttime
operator|.
name|tv_usec
expr_stmt|;
block|}
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data[old] from device (select() error: %m)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data[old] from device"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|noresponse
operator|++
expr_stmt|;
name|parse
operator|->
name|lastmissed
operator|=
name|current_time
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|parsetime
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
argument_list|)
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
operator|)
condition|)
block|{
comment|/* bad packet */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: bad read[old] from streams module (read() error: %m)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: bad read[old] from streams module (got %d bytes - expected %d bytes)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|baddata
operator|++
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
comment|/* 1.500 sec */
name|FD_ZERO
argument_list|(
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETTIMEOFDAY
argument_list|(
operator|&
name|starttime
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|selecttime
operator|=
name|timeout
expr_stmt|;
while|while
condition|(
operator|(
name|rtc
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|selecttime
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* no data from the radio clock */
if|if
condition|(
name|rtc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|GETTIMEOFDAY
argument_list|(
operator|&
name|curtime
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|selecttime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
operator|-
name|starttime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|curtime
operator|.
name|tv_usec
operator|<
name|starttime
operator|.
name|tv_usec
condition|)
block|{
name|selecttime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|selecttime
operator|.
name|tv_usec
operator|=
literal|1000000
operator|+
name|curtime
operator|.
name|tv_usec
operator|-
name|starttime
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|selecttime
operator|.
name|tv_usec
operator|=
name|curtime
operator|.
name|tv_usec
operator|-
name|starttime
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|selecttime
argument_list|,
operator|&
name|timeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* 		   * elapsed real time passed timeout value - consider it timed out 		   */
break|break;
block|}
comment|/* 	       * calculate residual timeout value 	       */
name|selecttime
operator|.
name|tv_sec
operator|=
name|timeout
operator|.
name|tv_sec
operator|-
name|selecttime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|selecttime
operator|.
name|tv_usec
operator|>
name|timeout
operator|.
name|tv_usec
condition|)
block|{
name|selecttime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|selecttime
operator|.
name|tv_usec
operator|=
literal|1000000
operator|+
name|timeout
operator|.
name|tv_usec
operator|-
name|selecttime
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|selecttime
operator|.
name|tv_usec
operator|=
name|timeout
operator|.
name|tv_usec
operator|-
name|selecttime
operator|.
name|tv_usec
expr_stmt|;
block|}
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data[new] from device (select() error: %m)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data[new] from device"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*        * we will return here iff we got a good old sample as this would        * be misinterpreted. bad samples are passed on to be logged into the        * state statistics        */
if|if
condition|(
operator|(
name|parsetime
operator|.
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_OK
condition|)
block|{
name|parse
operator|->
name|noresponse
operator|++
expr_stmt|;
name|parse
operator|->
name|lastmissed
operator|=
name|current_time
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*    * we get here either by a possible read() (rtc == 1 - while assertion)    * or by a timeout or a system call error. when a read() is possible we    * get the new data, otherwise we stick with the old    */
if|if
condition|(
operator|(
name|rtc
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|parsetime
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
argument_list|)
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
operator|)
condition|)
block|{
comment|/* bad packet */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: bad read[new] from streams module (read() error: %m)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: bad read[new] from streams module (got %d bytes - expected %d bytes)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|baddata
operator|++
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * process what we got    */
name|parse_process
argument_list|(
name|parse
argument_list|,
operator|&
name|parsetime
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------  * local init  */
end_comment

begin_function
specifier|static
name|int
name|local_init
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
return|return
name|parse_ioinit
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local end  */
end_comment

begin_function
specifier|static
name|void
name|local_end
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
name|parse_ioend
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local nop  */
end_comment

begin_function
specifier|static
name|int
name|local_nop
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local setcs  */
end_comment

begin_function
specifier|static
name|int
name|local_setcs
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
return|return
name|parse_setcs
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local getfmt  */
end_comment

begin_function
specifier|static
name|int
name|local_getfmt
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
return|return
name|parse_getfmt
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local setfmt  */
end_comment

begin_function
specifier|static
name|int
name|local_setfmt
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
return|return
name|parse_setfmt
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local getstat  */
end_comment

begin_function
specifier|static
name|int
name|local_getstat
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
return|return
name|parse_getstat
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local setstat  */
end_comment

begin_function
specifier|static
name|int
name|local_setstat
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
return|return
name|parse_setstat
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local timecode  */
end_comment

begin_function
specifier|static
name|int
name|local_timecode
parameter_list|(
name|parse
parameter_list|,
name|tcl
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
modifier|*
name|tcl
decl_stmt|;
block|{
return|return
name|parse_timecode
argument_list|(
name|tcl
argument_list|,
operator|&
name|parse
operator|->
name|parseio
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local receive  */
end_comment

begin_function
specifier|static
name|void
name|local_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_CONRAD
name|struct
name|timeval
name|foo
decl_stmt|;
endif|#
directive|endif
comment|/*    * eat all characters, parsing then and feeding complete samples    */
name|count
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
name|s
operator|=
name|rbufp
operator|->
name|recv_buffer
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_CONRAD
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|TIOCTIMESTAMP
argument_list|,
operator|&
name|foo
argument_list|)
expr_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
name|rbufp
operator|->
name|recv_time
operator|.
name|l_uf
operator|+=
name|TS_ROUNDBIT
expr_stmt|;
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|rbufp
operator|->
name|recv_time
operator|.
name|l_uf
operator|&=
name|TS_MASK
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|,
operator|*
name|s
operator|++
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
condition|)
block|{
comment|/* 	   * got something good to eat 	   */
ifdef|#
directive|ifdef
name|PPSPPS
if|if
condition|(
operator|!
name|PARSE_PPS
argument_list|(
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_state
argument_list|)
operator|&&
operator|(
name|parse
operator|->
name|flags
operator|&
name|PARSE_PPSCLOCK
operator|)
condition|)
block|{
name|l_fp
name|ts
decl_stmt|;
name|struct
name|ppsclockev
name|ev
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|CIOGETEV
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ev
operator|.
name|serial
operator|!=
name|parse
operator|->
name|ppsserial
condition|)
block|{
comment|/*                        * add PPS time stamp if available via ppsclock module 		       * and not supplied already. 		       */
if|if
condition|(
operator|!
name|buftvtots
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|ev
operator|.
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse: local_receive: timestamp conversion error (buftvtots) (ppsclockev.tv)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_ptime
operator|.
name|fp
operator|=
name|ts
expr_stmt|;
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
block|}
block|}
name|parse
operator|->
name|ppsserial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|parse_process
argument_list|(
name|parse
argument_list|,
operator|&
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * local poll  */
end_comment

begin_function
specifier|static
name|void
name|local_poll
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|rtc
decl_stmt|;
name|fd_set
name|fdmask
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|,
name|starttime
decl_stmt|,
name|curtime
decl_stmt|,
name|selecttime
decl_stmt|;
specifier|static
name|struct
name|timeval
name|null_time
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|timestamp_t
name|ts
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|fd
operator|=
name|parse
operator|->
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
comment|/* 1.5 sec */
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GETTIMEOFDAY
argument_list|(
operator|&
name|starttime
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|selecttime
operator|=
name|timeout
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|(
name|rtc
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|selecttime
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* no data from the radio clock */
if|if
condition|(
name|rtc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|GETTIMEOFDAY
argument_list|(
operator|&
name|curtime
argument_list|,
literal|0L
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|selecttime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
operator|-
name|starttime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|curtime
operator|.
name|tv_usec
operator|<
name|starttime
operator|.
name|tv_usec
condition|)
block|{
name|selecttime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|selecttime
operator|.
name|tv_usec
operator|=
literal|1000000
operator|+
name|curtime
operator|.
name|tv_usec
operator|-
name|starttime
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|selecttime
operator|.
name|tv_usec
operator|=
name|curtime
operator|.
name|tv_usec
operator|-
name|starttime
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timercmp
argument_list|(
operator|&
name|selecttime
argument_list|,
operator|&
name|timeout
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* 		       * calculate residual timeout value 		       */
name|selecttime
operator|.
name|tv_sec
operator|=
name|timeout
operator|.
name|tv_sec
operator|-
name|selecttime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|selecttime
operator|.
name|tv_usec
operator|>
name|timeout
operator|.
name|tv_usec
condition|)
block|{
name|selecttime
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|selecttime
operator|.
name|tv_usec
operator|=
literal|1000000
operator|+
name|timeout
operator|.
name|tv_usec
operator|-
name|selecttime
operator|.
name|tv_usec
expr_stmt|;
block|}
else|else
block|{
name|selecttime
operator|.
name|tv_usec
operator|=
name|timeout
operator|.
name|tv_usec
operator|-
name|selecttime
operator|.
name|tv_usec
expr_stmt|;
block|}
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data from device (select() error: %m)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data from device"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|noresponse
operator|++
expr_stmt|;
name|parse
operator|->
name|lastmissed
operator|=
name|current_time
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*        * at least 1 character is available - gobble everthing up that is available        */
do|do
block|{
name|char
name|inbuf
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|inbuf
decl_stmt|;
name|rtc
operator|=
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
operator|.
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|,
operator|*
name|s
operator|++
argument_list|,
name|ts
argument_list|)
condition|)
block|{
comment|/* 		   * got something good to eat 		   */
name|parse_process
argument_list|(
name|parse
argument_list|,
operator|&
name|parse
operator|->
name|parseio
operator|.
name|parse_dtime
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parseio
argument_list|)
expr_stmt|;
comment|/* 		   * done if no more characters are available 		   */
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|null_time
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
block|}
block|}
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rtc
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|null_time
argument_list|)
operator|)
operator|==
literal|1
condition|)
do|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * init_iobinding - find and initialize lower layers  */
end_comment

begin_function
specifier|static
name|bind_t
modifier|*
name|init_iobinding
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|bind_t
modifier|*
name|b
init|=
name|io_bindings
decl_stmt|;
while|while
condition|(
name|b
operator|->
name|bd_description
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|b
operator|->
name|bd_init
call|)
argument_list|(
name|parse
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
name|b
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bind_t
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/**===========================================================================  ** support routines  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * convert a flag field to a string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parsestate
parameter_list|(
name|state
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|LONG
name|state
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
struct|struct
name|bits
block|{
name|unsigned
name|LONG
name|bit
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|flagstrings
index|[]
init|=
block|{
block|{
name|PARSEB_ANNOUNCE
block|,
literal|"DST SWITCH WARNING"
block|}
block|,
block|{
name|PARSEB_POWERUP
block|,
literal|"NOT SYNCHRONIZED"
block|}
block|,
block|{
name|PARSEB_NOSYNC
block|,
literal|"TIME CODE NOT CONFIRMED"
block|}
block|,
block|{
name|PARSEB_DST
block|,
literal|"DST"
block|}
block|,
block|{
name|PARSEB_UTC
block|,
literal|"UTC DISPLAY"
block|}
block|,
block|{
name|PARSEB_LEAPADD
block|,
literal|"LEAP ADD WARNING"
block|}
block|,
block|{
name|PARSEB_LEAPDEL
block|,
literal|"LEAP DELETE WARNING"
block|}
block|,
block|{
name|PARSEB_LEAPSECOND
block|,
literal|"LEAP SECOND"
block|}
block|,
block|{
name|PARSEB_ALTERNATE
block|,
literal|"ALTERNATE ANTENNA"
block|}
block|,
block|{
name|PARSEB_TIMECODE
block|,
literal|"TIME CODE"
block|}
block|,
block|{
name|PARSEB_PPS
block|,
literal|"PPS"
block|}
block|,
block|{
name|PARSEB_POSITION
block|,
literal|"POSITION"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
specifier|static
struct|struct
name|sbits
block|{
name|unsigned
name|LONG
name|bit
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|sflagstrings
index|[]
init|=
block|{
block|{
name|PARSEB_S_LEAP
block|,
literal|"LEAP INDICATION"
block|}
block|,
block|{
name|PARSEB_S_PPS
block|,
literal|"PPS SIGNAL"
block|}
block|,
block|{
name|PARSEB_S_ANTENNA
block|,
literal|"ANTENNA"
block|}
block|,
block|{
name|PARSEB_S_POSITION
block|,
literal|"POSITION"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
operator|&
name|state
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|flagstrings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|&
operator|(
name|PARSEB_S_LEAP
operator||
name|PARSEB_S_ANTENNA
operator||
name|PARSEB_S_PPS
operator||
name|PARSEB_S_POSITION
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sflagstrings
index|[
name|i
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|sflagstrings
index|[
name|i
index|]
operator|.
name|bit
operator|&
name|state
condition|)
block|{
if|if
condition|(
name|t
operator|!=
name|s
condition|)
block|{
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|t
operator|+=
literal|2
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
name|sflagstrings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * convert a status flag field to a string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parsestatus
parameter_list|(
name|state
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|LONG
name|state
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
struct|struct
name|bits
block|{
name|unsigned
name|LONG
name|bit
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|flagstrings
index|[]
init|=
block|{
block|{
name|CVT_OK
block|,
literal|"CONVERSION SUCCESSFUL"
block|}
block|,
block|{
name|CVT_NONE
block|,
literal|"NO CONVERSION"
block|}
block|,
block|{
name|CVT_FAIL
block|,
literal|"CONVERSION FAILED"
block|}
block|,
block|{
name|CVT_BADFMT
block|,
literal|"ILLEGAL FORMAT"
block|}
block|,
block|{
name|CVT_BADDATE
block|,
literal|"DATE ILLEGAL"
block|}
block|,
block|{
name|CVT_BADTIME
block|,
literal|"TIME ILLEGAL"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|bit
operator|&
name|state
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|flagstrings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * convert a clock status flag field to a string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|clockstatus
parameter_list|(
name|state
parameter_list|)
name|unsigned
name|LONG
name|state
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
specifier|static
struct|struct
name|status
block|{
name|unsigned
name|LONG
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|flagstrings
index|[]
init|=
block|{
block|{
name|CEVNT_NOMINAL
block|,
literal|"NOMINAL"
block|}
block|,
block|{
name|CEVNT_TIMEOUT
block|,
literal|"NO RESPONSE"
block|}
block|,
block|{
name|CEVNT_BADREPLY
block|,
literal|"BAD FORMAT"
block|}
block|,
block|{
name|CEVNT_FAULT
block|,
literal|"FAULT"
block|}
block|,
block|{
name|CEVNT_PROP
block|,
literal|"PROPAGATION DELAY"
block|}
block|,
block|{
name|CEVNT_BADDATE
block|,
literal|"ILLEGAL DATE"
block|}
block|,
block|{
name|CEVNT_BADTIME
block|,
literal|"ILLEGAL TIME"
block|}
block|,
block|{
operator|~
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|value
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|flagstrings
index|[
name|i
index|]
operator|.
name|value
operator|==
name|state
condition|)
block|{
return|return
name|flagstrings
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unknown #%d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * mkascii - make a printable ascii string  * assumes (unless defined better) 7-bit ASCII  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|isprint
end_ifndef

begin_define
define|#
directive|define
name|isprint
parameter_list|(
name|_X_
parameter_list|)
value|(((_X_)> 0x1F)&& ((_X_)< 0x7F))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|mkascii
parameter_list|(
name|buffer
parameter_list|,
name|blen
parameter_list|,
name|src
parameter_list|,
name|srclen
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|LONG
name|blen
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|LONG
name|srclen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|b
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|endb
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|blen
operator|<
literal|4
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
comment|/* don't bother with mini buffers */
name|endb
operator|=
name|buffer
operator|+
name|blen
operator|-
literal|4
expr_stmt|;
name|blen
operator|--
expr_stmt|;
comment|/* account for '\0' */
while|while
condition|(
name|blen
operator|&&
name|srclen
operator|--
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|src
operator|!=
literal|'\\'
operator|)
operator|&&
name|isprint
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
comment|/* printables are easy... */
operator|*
name|buffer
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|blen
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|blen
operator|<
literal|4
condition|)
block|{
while|while
condition|(
name|blen
operator|--
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|buffer
operator|+=
literal|2
expr_stmt|;
name|blen
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\\x%02x"
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
name|blen
operator|-=
literal|4
expr_stmt|;
name|buffer
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|srclen
operator|&&
operator|!
name|blen
operator|&&
name|endb
condition|)
comment|/* overflow - set last chars to ... */
name|strcpy
argument_list|(
name|endb
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * l_mktime - make representation of a relative time  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|l_mktime
parameter_list|(
name|delta
parameter_list|)
name|unsigned
name|LONG
name|delta
decl_stmt|;
block|{
name|unsigned
name|LONG
name|tmp
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|delta
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%dd+"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|delta
operator|-=
name|tmp
operator|*
literal|60
operator|*
literal|60
operator|*
literal|24
expr_stmt|;
block|}
name|s
operator|=
name|delta
operator|%
literal|60
expr_stmt|;
name|delta
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|delta
operator|%
literal|60
expr_stmt|;
name|delta
operator|/=
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%02d:%02d:%02d"
argument_list|,
name|delta
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_statistics - list summary of clock states  */
end_comment

begin_function
specifier|static
name|void
name|parse_statistics
parameter_list|(
name|parse
parameter_list|)
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: running time: %s"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|current_time
operator|-
name|parse
operator|->
name|timestarted
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: current status: %s"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|clockstatus
argument_list|(
name|parse
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|CEVNT_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|unsigned
name|LONG
name|stime
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|percent
decl_stmt|,
name|div
init|=
name|current_time
operator|-
name|parse
operator|->
name|timestarted
decl_stmt|;
name|percent
operator|=
name|stime
operator|=
name|PARSE_STATETIME
argument_list|(
name|parse
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|unsigned
name|LONG
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|/
literal|10000
operator|)
operator|<
name|percent
condition|)
block|{
name|percent
operator|/=
literal|10
expr_stmt|;
name|div
operator|/=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|div
condition|)
name|percent
operator|=
operator|(
name|percent
operator|*
literal|10000
operator|)
operator|/
name|div
expr_stmt|;
else|else
name|percent
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|stime
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: state %18s: %13s (%3d.%02d%%)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|clockstatus
argument_list|(
name|i
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|stime
argument_list|)
argument_list|,
name|percent
operator|/
literal|100
argument_list|,
name|percent
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * cparse_statistics - wrapper for statistics call  */
end_comment

begin_function
specifier|static
name|void
name|cparse_statistics
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
init|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|peer
decl_stmt|;
name|parse_statistics
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|parse
operator|->
name|stattimer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|PARSESTATISTICS
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|parse
operator|->
name|stattimer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**===========================================================================  ** xntp interface routines  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * parse_init - initialize internal parse driver data  */
end_comment

begin_function
specifier|static
name|void
name|parse_init
parameter_list|()
block|{
name|memset
argument_list|(
operator|(
name|caddr_t
operator|)
name|parseunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|parseunits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_shutdown - shut down a PARSE clock  */
end_comment

begin_function
specifier|static
name|void
name|parse_shutdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|unit
operator|=
name|CL_UNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_shutdown: INTERNAL ERROR, unit invalid (max %d)"
argument_list|,
name|unit
argument_list|,
name|MAXUNITS
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse
operator|=
name|parseunits
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|parse
operator|&&
operator|!
name|parse
operator|->
name|peer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_shutdown: INTERNAL ERROR, unit not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * print statistics a last time and 	 * stop statistics machine 	 */
name|parse_statistics
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|parse
operator|->
name|stattimer
argument_list|)
expr_stmt|;
if|#
directive|if
name|PPSPPS
block|{
comment|/* 	   * kill possible PPS association 	   */
if|if
condition|(
name|fdpps
operator|==
name|parse
operator|->
name|fd
condition|)
name|fdpps
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_end
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_end
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parse
operator|->
name|binding
condition|)
name|PARSE_END
argument_list|(
name|parse
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the I/O module to turn us off.  We're history. 	 */
if|if
condition|(
operator|!
name|parse
operator|->
name|pollonly
condition|)
name|io_closeclock
argument_list|(
operator|&
name|parse
operator|->
name|io
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|close
argument_list|(
name|parse
operator|->
name|fd
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: reference clock \"%s\" removed"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_description
argument_list|)
expr_stmt|;
name|parse
operator|->
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* unused now */
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_start - open the PARSE devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|parse_start
parameter_list|(
name|sysunit
parameter_list|,
name|peer
parameter_list|)
name|u_int
name|sysunit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
name|u_int
name|unit
decl_stmt|;
name|int
name|fd232
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tm
decl_stmt|;
comment|/* NEEDED FOR A LONG TIME ! */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|tm
decl_stmt|;
comment|/* NEEDED FOR A LONG TIME ! */
endif|#
directive|endif
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|char
name|parsedev
index|[
sizeof|sizeof
argument_list|(
name|PARSEDEVICE
argument_list|)
operator|+
literal|20
index|]
decl_stmt|;
name|parsectl_t
name|tmp_ctl
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|type
operator|=
name|CL_TYPE
argument_list|(
name|sysunit
argument_list|)
expr_stmt|;
name|unit
operator|=
name|CL_UNIT
argument_list|(
name|sysunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: unit number invalid (max %d)"
argument_list|,
name|unit
argument_list|,
name|MAXUNITS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|type
operator|==
operator|~
literal|0
operator|)
operator|||
operator|(
name|clockinfo
index|[
name|type
index|]
operator|.
name|cl_description
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: unsupported clock type %d (max %d)"
argument_list|,
name|unit
argument_list|,
name|CL_REALTYPE
argument_list|(
name|sysunit
argument_list|)
argument_list|,
name|ncltypes
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parseunits
index|[
name|unit
index|]
operator|&&
name|parseunits
index|[
name|unit
index|]
operator|->
name|peer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: unit in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Unit okay, attempt to open the device.    */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|parsedev
argument_list|,
name|PARSEDEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|O_NOCTTY
define|#
directive|define
name|O_NOCTTY
value|0
endif|#
directive|endif
name|fd232
operator|=
name|open
argument_list|(
name|parsedev
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: open of %s failed: %m"
argument_list|,
name|unit
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Looks like this might succeed.  Find memory for the structure.    * Look to see if there are any unused ones, if not we malloc()    * one.    */
if|if
condition|(
name|parseunits
index|[
name|unit
index|]
condition|)
block|{
name|parse
operator|=
name|parseunits
index|[
name|unit
index|]
expr_stmt|;
comment|/* The one we want is okay - and free */
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parseunits
index|[
name|i
index|]
operator|&&
operator|!
name|parseunits
index|[
name|i
index|]
operator|->
name|peer
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|MAXUNITS
condition|)
block|{
comment|/* 	   * Reclaim this one 	   */
name|parse
operator|=
name|parseunits
index|[
name|i
index|]
expr_stmt|;
name|parseunits
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|=
operator|(
expr|struct
name|parseunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|parseunit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|parseunit
argument_list|)
argument_list|)
expr_stmt|;
name|parseunits
index|[
name|unit
index|]
operator|=
name|parse
expr_stmt|;
comment|/*    * Set up the structures    */
name|parse
operator|->
name|unit
operator|=
operator|(
name|u_char
operator|)
name|sysunit
expr_stmt|;
name|parse
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|parse
operator|->
name|lastchange
operator|=
name|current_time
expr_stmt|;
comment|/*    * we want to filter input for the sake of    * getting an impression on dispersion    * also we like to average the median range    */
name|parse
operator|->
name|flags
operator|=
name|PARSE_STAT_FILTER
operator||
name|PARSE_STAT_AVG
expr_stmt|;
name|parse
operator|->
name|pollneeddata
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|pollonly
operator|=
literal|1
expr_stmt|;
comment|/* go for default polling mode */
name|parse
operator|->
name|lastformat
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* assume no format known */
name|parse
operator|->
name|status
operator|=
name|CEVNT_TIMEOUT
expr_stmt|;
comment|/* expect the worst */
name|parse
operator|->
name|laststatus
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* be sure to mark initial status change */
name|parse
operator|->
name|nosynctime
operator|=
literal|0
expr_stmt|;
comment|/* assume clock reasonable */
name|parse
operator|->
name|lastmissed
operator|=
literal|0
expr_stmt|;
comment|/* assume got everything */
name|parse
operator|->
name|ppsserial
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|localdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_type
operator|=
operator|&
name|clockinfo
index|[
name|type
index|]
expr_stmt|;
name|parse
operator|->
name|basedelay
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* we can only pre-configure delays less than 1 second */
name|parse
operator|->
name|basedelay
operator|.
name|l_uf
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_basedelay
expr_stmt|;
name|parse
operator|->
name|ppsdelay
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* we can only pre-configure delays less than 1 second */
name|parse
operator|->
name|ppsdelay
operator|.
name|l_uf
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_ppsdelay
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_rootdelay
expr_stmt|;
name|peer
operator|->
name|sstclktype
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_type
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|STRATUM_REFCLOCK
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|PARSEHSREFID
argument_list|)
expr_stmt|;
name|parse
operator|->
name|fd
operator|=
name|fd232
expr_stmt|;
name|parse
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
comment|/* marks it also as busy */
name|parse
operator|->
name|binding
operator|=
name|init_iobinding
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|binding
operator|==
operator|(
name|bind_t
operator|*
operator|)
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: io sub system initialisation failed."
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
comment|/*    * configure terminal line    */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|fd232
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: tcgetattr(%d,&tm): %m"
argument_list|,
name|unit
argument_list|,
name|fd232
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|_PC_VDISABLE
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tm
operator|.
name|c_cc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|disablec
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* pathconf can deliver -1 without changing errno ! */
name|disablec
operator|=
name|fpathconf
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|_PC_VDISABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|disablec
operator|==
operator|-
literal|1
operator|&&
name|errno
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: fpathconf(fd, _PC_VDISABLE): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tm
operator|.
name|c_cc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* best guess */
block|}
elseif|else
if|if
condition|(
name|disablec
operator|!=
operator|-
literal|1
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tm
operator|.
name|c_cc
argument_list|,
name|disablec
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tm
operator|.
name|c_cflag
operator|=
name|clockinfo
index|[
name|type
index|]
operator|.
name|cl_cflag
expr_stmt|;
name|tm
operator|.
name|c_iflag
operator|=
name|clockinfo
index|[
name|type
index|]
operator|.
name|cl_iflag
expr_stmt|;
name|tm
operator|.
name|c_oflag
operator|=
name|clockinfo
index|[
name|type
index|]
operator|.
name|cl_oflag
expr_stmt|;
name|tm
operator|.
name|c_lflag
operator|=
name|clockinfo
index|[
name|type
index|]
operator|.
name|cl_lflag
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_CONRAD
name|tm
operator|.
name|c_ispeed
operator|=
literal|50
expr_stmt|;
name|tm
operator|.
name|c_ospeed
operator|=
literal|50
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|fd232
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: tcsetattr(%d,&tm): %m"
argument_list|,
name|unit
argument_list|,
name|fd232
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
block|}
comment|/*    * as we always(?) get 8 bit chars we want to be    * sure, that the upper bits are zero for less    * than 8 bit I/O - so we pass that information on.    * note that there can be only one bit count format    * per file descriptor    */
switch|switch
condition|(
name|tm
operator|.
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS7
expr_stmt|;
break|break;
case|case
name|CS8
case|:
name|tmp_ctl
operator|.
name|parsesetcs
operator|.
name|parse_cs
operator|=
name|PARSE_IO_CS8
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|PARSE_SETCS
argument_list|(
name|parse
argument_list|,
operator|&
name|tmp_ctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: parse_setcs() FAILED."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
ifdef|#
directive|ifdef
name|FREEBSD_CONRAD
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|TIOCTIMESTAMP
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|j
operator|=
name|TIOCM_RTS
expr_stmt|;
name|i
operator|=
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: lowrts_poll: failed to lower RTS: %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|tmp_ctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_format
argument_list|)
expr_stmt|;
name|tmp_ctl
operator|.
name|parseformat
operator|.
name|parse_count
operator|=
name|strlen
argument_list|(
name|tmp_ctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_SETFMT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmp_ctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: parse_setfmt() FAILED."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
ifdef|#
directive|ifdef
name|TCFLSH
comment|/*    * get rid of all IO accumulated so far    */
block|{
ifndef|#
directive|ifndef
name|TCIOFLUSH
define|#
directive|define
name|TCIOFLUSH
value|2
endif|#
directive|endif
name|int
name|flshcmd
init|=
name|TCIOFLUSH
decl_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|TCFLSH
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|flshcmd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tmp_ctl
operator|.
name|parsestatus
operator|.
name|flags
operator|=
name|parse
operator|->
name|flags
operator|&
name|PARSE_STAT_FLAGS
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_SETSTAT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmp_ctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: parse_setstat() FAILED."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
comment|/*    * try to do any special initializations    */
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_init
condition|)
block|{
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_init
argument_list|(
name|parse
argument_list|)
condition|)
block|{
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
comment|/* well, ok - special initialisation broke */
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_flags
operator|&
name|PARSE_F_POLLONLY
operator|)
operator|&&
operator|(
name|CL_PPS
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
operator|||
operator|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_flags
operator|&
name|PARSE_F_NOPOLLONLY
operator|)
operator|)
condition|)
block|{
comment|/*        * Insert in async io device list.        */
name|parse
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|parse
operator|->
name|binding
operator|->
name|bd_receive
expr_stmt|;
comment|/* pick correct receive routine */
name|parse
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|parse
expr_stmt|;
name|parse
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|io
operator|.
name|fd
operator|=
name|parse
operator|->
name|fd
expr_stmt|;
comment|/* replicated, but what the heck */
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|parse
operator|->
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_flags
operator|&
name|PARSE_F_NOPOLLONLY
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: addclock %s fails (ABORT - clock type requires async io)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: addclock %s fails (switching to polling mode)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|parse
operator|->
name|pollonly
operator|=
literal|0
expr_stmt|;
comment|/* 				 * update at receipt of time_stamp - also 				 * supports PPS processing 				 */
block|}
block|}
ifdef|#
directive|ifdef
name|PPSPPS
if|if
condition|(
name|parse
operator|->
name|pollonly
operator|||
operator|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_flags
operator|&
name|PARSE_F_PPSPPS
operator|)
condition|)
block|{
if|if
condition|(
name|fdpps
operator|==
operator|-
literal|1
condition|)
block|{
name|fdpps
operator|=
name|parse
operator|->
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_DISABLE
argument_list|(
name|parse
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_start: parse_disable() FAILED"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|parse_shutdown
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* let our cleaning staff do the work */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"PARSE receiver #%d: parse_start: loopfilter PPS already active - no PPS via CIOGETEV"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*    * wind up statistics timer    */
name|parse
operator|->
name|stattimer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|parse
expr_stmt|;
comment|/* we know better, but what the heck */
name|parse
operator|->
name|stattimer
operator|.
name|event_handler
operator|=
name|cparse_statistics
expr_stmt|;
name|parse
operator|->
name|stattimer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|PARSESTATISTICS
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|parse
operator|->
name|stattimer
argument_list|)
expr_stmt|;
comment|/*    * get out Copyright information once    */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NTP PARSE support: Copyright (c) 1989-1993, Frank Kardel"
argument_list|)
expr_stmt|;
name|notice
operator|=
literal|1
expr_stmt|;
block|}
comment|/*    * print out configuration    */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: reference clock \"%s\" (device %s) added"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_description
argument_list|,
name|parsedev
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  Stratum %d, %sPPS support, trust time %s, precision %d"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parse
operator|->
name|peer
operator|->
name|stratum
argument_list|,
operator|(
name|parse
operator|->
name|pollonly
operator|||
operator|!
name|CL_PPS
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
operator|)
condition|?
literal|"no "
else|:
literal|""
argument_list|,
name|l_mktime
argument_list|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_maxunsync
argument_list|)
argument_list|,
name|parse
operator|->
name|peer
operator|->
name|precision
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  rootdelay %s s, phaseadjust %s s, %s IO handling"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_rootdelay
argument_list|,
literal|6
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|parse
operator|->
name|basedelay
argument_list|,
literal|8
argument_list|)
argument_list|,
name|parse
operator|->
name|binding
operator|->
name|bd_description
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d:  Format recognition: %s"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
operator|!
operator|(
operator|*
name|parse
operator|->
name|parse_type
operator|->
name|cl_format
operator|)
condition|?
literal|"<AUTOMATIC>"
else|:
name|parse
operator|->
name|parse_type
operator|->
name|cl_format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPSPPS
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: %sCD PPS support"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
operator|(
name|fdpps
operator|==
name|parse
operator|->
name|fd
operator|)
condition|?
literal|""
else|:
literal|"NO "
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|parse_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|unit
operator|=
name|CL_UNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll: INTERNAL: unit invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse
operator|=
name|parseunits
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse
operator|->
name|peer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll: INTERNAL: unit unused"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|peer
operator|!=
name|parse
operator|->
name|peer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll: INTERNAL: peer incorrect"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Update clock stat counters    */
name|parse
operator|->
name|polls
operator|++
expr_stmt|;
comment|/*    * in PPS mode we just mark that we want the next sample    * for the clock filter    */
if|if
condition|(
operator|!
name|parse
operator|->
name|pollonly
condition|)
block|{
if|if
condition|(
name|parse
operator|->
name|pollneeddata
condition|)
block|{
comment|/* 	   * bad news - didn't get a response last time 	   */
name|parse
operator|->
name|noresponse
operator|++
expr_stmt|;
name|parse
operator|->
name|lastmissed
operator|=
name|current_time
expr_stmt|;
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: no data from device within poll interval"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|pollneeddata
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
condition|)
block|{
name|parse
operator|->
name|parse_type
operator|->
name|cl_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*    * the following code is only executed only when polling is used    */
name|PARSE_POLL
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_leap - called when a leap second occurs  */
end_comment

begin_function
specifier|static
name|void
name|parse_leap
parameter_list|()
block|{
comment|/* 	 * PARSE encodes the LEAP correction direction. 	 * For timecodes that do not pass on the leap correction direction 	 * the default PARSEB_LEAPADD must be used. It may then be modified 	 * with a fudge flag (flag2). 	 */
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * parse_control - set fudge factors, return statistics  */
end_comment

begin_function
specifier|static
name|void
name|parse_control
parameter_list|(
name|unit
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|in
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsectl_t
name|tmpctl
decl_stmt|;
name|unsigned
name|LONG
name|type
decl_stmt|;
specifier|static
name|char
name|outstatus
index|[
literal|400
index|]
decl_stmt|;
comment|/* status output buffer */
name|type
operator|=
name|CL_TYPE
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit
operator|=
name|CL_UNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|out
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|out
operator|->
name|noresponse
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|out
operator|->
name|baddata
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|out
operator|->
name|lastevent
operator|=
name|CEVNT_NOMINAL
expr_stmt|;
name|out
operator|->
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: unit invalid (max %d)"
argument_list|,
name|unit
argument_list|,
name|MAXUNITS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse
operator|=
name|parseunits
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|parse
operator|||
operator|!
name|parse
operator|->
name|peer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: unit invalid (UNIT INACTIVE)"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|parse
operator|->
name|basedelay
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
block|{
name|parse
operator|->
name|ppsdelay
operator|=
name|in
operator|->
name|fudgetime2
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
block|{
name|parse
operator|->
name|peer
operator|->
name|stratum
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|->
name|fudgeval1
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|peer
operator|->
name|stratum
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|parse
operator|->
name|peer
operator|->
name|refid
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|parse
operator|->
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|PARSEHSREFID
argument_list|)
expr_stmt|;
block|}
comment|/*        * NOT USED - yet        *       if (in->haveflags& CLK_HAVEVAL2) 	{ 	}        */
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
operator|(
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
operator||
name|CLK_HAVEFLAG4
operator|)
condition|)
block|{
name|parse
operator|->
name|flags
operator|=
operator|(
name|in
operator|->
name|flags
operator|&
operator|(
name|CLK_FLAG1
operator||
name|CLK_FLAG2
operator||
name|CLK_FLAG3
operator||
name|CLK_FLAG4
operator|)
operator|)
operator||
operator|(
name|parse
operator|->
name|flags
operator|&
operator|~
name|PARSE_STAT_FLAGS
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
operator|(
name|CLK_HAVEVAL2
operator||
name|CLK_HAVETIME2
operator||
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
operator||
name|CLK_HAVEFLAG4
operator|)
condition|)
block|{
name|parsectl_t
name|tmpctl
decl_stmt|;
name|tmpctl
operator|.
name|parsestatus
operator|.
name|flags
operator|=
name|parse
operator|->
name|flags
operator|&
name|PARSE_STAT_FLAGS
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_SETSTAT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: parse_setstat() FAILED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|out
condition|)
block|{
specifier|register
name|unsigned
name|LONG
name|sum
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|tt
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|register
name|short
name|utcoff
decl_stmt|;
specifier|register
name|char
name|sign
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|time_t
name|tim
decl_stmt|;
name|outstatus
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
operator||
name|CLK_HAVETIME2
operator||
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|parse
operator|->
name|parse_type
operator|->
name|cl_description
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|parse
operator|->
name|basedelay
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|=
name|parse
operator|->
name|ppsdelay
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
operator|(
name|LONG
operator|)
name|parse
operator|->
name|peer
operator|->
name|stratum
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|parse
operator|->
name|flags
operator|&
name|PARSE_STAT_FLAGS
expr_stmt|;
name|out
operator|->
name|type
operator|=
name|REFCLK_PARSE
expr_stmt|;
comment|/*        * figure out skew between PPS and RS232 - just for informational        * purposes - returned in time2 value        */
if|if
condition|(
name|PARSE_SYNC
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
operator|&&
name|PARSE_TIMECODE
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
condition|)
block|{
name|l_fp
name|off
decl_stmt|;
comment|/* 		* we have a PPS and RS232 signal - calculate the skew 		* WARNING: assumes on TIMECODE == PULSE (timecode after pulse) 		*/
name|off
operator|=
name|parse
operator|->
name|time
operator|.
name|parse_stime
operator|.
name|fp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_ptime
operator|.
name|fp
argument_list|)
expr_stmt|;
comment|/* true offset */
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|40
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_ppsskew=%s"
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|off
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|)
condition|)
block|{
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_ppstime=\"%s\""
argument_list|,
name|prettydate
argument_list|(
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_ptime
operator|.
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*        * all this for just finding out the +-xxxx part (there are always        * new and changing fields in the standards 8-().        *        * but we do it for the human user...        */
name|tim
operator|=
name|parse
operator|->
name|time
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|-
name|JAN_1970
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|tim
argument_list|)
expr_stmt|;
name|utcoff
operator|=
name|tm
operator|->
name|tm_hour
operator|*
literal|60
operator|+
name|tm
operator|->
name|tm_min
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|tim
argument_list|)
expr_stmt|;
name|utcoff
operator|=
name|tm
operator|->
name|tm_hour
operator|*
literal|60
operator|+
name|tm
operator|->
name|tm_min
operator|-
name|utcoff
operator|+
literal|12
operator|*
literal|60
expr_stmt|;
name|utcoff
operator|+=
literal|24
operator|*
literal|60
expr_stmt|;
name|utcoff
operator|%=
literal|24
operator|*
literal|60
expr_stmt|;
name|utcoff
operator|-=
literal|12
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|utcoff
operator|<
literal|0
condition|)
block|{
name|utcoff
operator|=
operator|-
name|utcoff
expr_stmt|;
name|sign
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|'+'
expr_stmt|;
block|}
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|128
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_time=\""
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|time
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|tt
argument_list|,
literal|"<UNDEFINED>\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|tt
argument_list|,
name|prettydate
argument_list|(
operator|&
name|parse
operator|->
name|time
operator|.
name|parse_time
operator|.
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|tt
operator|+
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|" (%c%02d%02d)\""
argument_list|,
name|sign
argument_list|,
name|utcoff
operator|/
literal|60
argument_list|,
name|utcoff
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PARSE_GETTIMECODE
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: parse_timecode() FAILED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|128
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_status=\""
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
comment|/* 	   * copy PPS flags from last read transaction (informational only) 	   */
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_state
operator||=
name|parse
operator|->
name|time
operator|.
name|parse_state
operator|&
operator|(
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|parsestate
argument_list|(
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_state
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_count
condition|)
name|mkascii
argument_list|(
name|outstatus
operator|+
name|strlen
argument_list|(
name|outstatus
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|outstatus
argument_list|)
operator|-
name|strlen
argument_list|(
name|outstatus
argument_list|)
operator|-
literal|1
argument_list|,
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_buffer
argument_list|,
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|parse
operator|->
name|badformat
operator|+=
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_badformat
expr_stmt|;
block|}
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_format
operator|=
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_format
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_GETFMT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_control: parse_getfmt() FAILED"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_format=\""
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tt
argument_list|,
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_count
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
comment|/*        * gather state statistics        */
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|200
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tt
argument_list|,
literal|"refclock_states=\""
argument_list|)
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|CEVNT_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|unsigned
name|LONG
name|stime
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|div
init|=
name|current_time
operator|-
name|parse
operator|->
name|timestarted
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|percent
decl_stmt|;
name|percent
operator|=
name|stime
operator|=
name|PARSE_STATETIME
argument_list|(
name|parse
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|unsigned
name|LONG
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|/
literal|10000
operator|)
operator|<
name|percent
condition|)
block|{
name|percent
operator|/=
literal|10
expr_stmt|;
name|div
operator|/=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|div
condition|)
name|percent
operator|=
operator|(
name|percent
operator|*
literal|10000
operator|)
operator|/
name|div
expr_stmt|;
else|else
name|percent
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|stime
condition|)
block|{
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"%s%s%s: %s (%d.%02d%%)"
argument_list|,
name|sum
condition|?
literal|"; "
else|:
literal|""
argument_list|,
operator|(
name|parse
operator|->
name|status
operator|==
name|i
operator|)
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|clockstatus
argument_list|(
name|i
argument_list|)
argument_list|,
name|l_mktime
argument_list|(
name|stime
argument_list|)
argument_list|,
name|percent
operator|/
literal|100
argument_list|,
name|percent
operator|%
literal|100
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|stime
expr_stmt|;
name|tt
operator|+=
name|strlen
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"; running time: %s\""
argument_list|,
name|l_mktime
argument_list|(
name|sum
argument_list|)
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|32
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_id=\"%s\""
argument_list|,
name|parse
operator|->
name|parse_type
operator|->
name|cl_id
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|80
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_iomode=\"%s\""
argument_list|,
name|parse
operator|->
name|binding
operator|->
name|bd_description
argument_list|)
expr_stmt|;
name|tt
operator|=
name|add_var
argument_list|(
operator|&
name|out
operator|->
name|kv_list
argument_list|,
literal|128
argument_list|,
name|RO
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tt
argument_list|,
literal|"refclock_driver_version=\"refclock_parse.c,v 3.53 1994/03/25 13:07:39 kardel Exp\""
argument_list|)
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
name|strlen
argument_list|(
name|outstatus
argument_list|)
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
name|outstatus
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|parse
operator|->
name|timestarted
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|parse
operator|->
name|polls
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
name|parse
operator|->
name|noresponse
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|parse
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|parse
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|parse
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|parse
operator|->
name|status
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**===========================================================================  ** processing routines  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * event handling - note that nominal events will also be posted  */
end_comment

begin_function
specifier|static
name|void
name|parse_event
parameter_list|(
name|parse
parameter_list|,
name|event
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|int
name|event
decl_stmt|;
block|{
if|if
condition|(
name|parse
operator|->
name|status
operator|!=
operator|(
name|u_char
operator|)
name|event
condition|)
block|{
name|parse
operator|->
name|statetime
index|[
name|parse
operator|->
name|status
index|]
operator|+=
name|current_time
operator|-
name|parse
operator|->
name|lastchange
expr_stmt|;
name|parse
operator|->
name|lastchange
operator|=
name|current_time
expr_stmt|;
name|parse
operator|->
name|status
operator|=
operator|(
name|u_char
operator|)
name|event
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|CEVNT_NOMINAL
condition|)
name|parse
operator|->
name|lastevent
operator|=
name|parse
operator|->
name|status
expr_stmt|;
name|report_event
argument_list|(
name|EVNT_PEERCLOCK
argument_list|,
name|parse
operator|->
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * process a PARSE time sample  */
end_comment

begin_function
specifier|static
name|void
name|parse_process
parameter_list|(
name|parse
parameter_list|,
name|parsetime
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
name|parsetime_t
modifier|*
name|parsetime
decl_stmt|;
block|{
name|unsigned
name|char
name|leap
decl_stmt|;
name|struct
name|timeval
name|usecdisp
decl_stmt|;
name|l_fp
name|off
decl_stmt|,
name|rectime
decl_stmt|,
name|reftime
decl_stmt|,
name|dispersion
decl_stmt|;
comment|/*    * check for changes in conversion status    * (only one for each new status !)    */
if|if
condition|(
name|parse
operator|->
name|laststatus
operator|!=
name|parsetime
operator|->
name|parse_status
condition|)
block|{
name|char
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: conversion status \"%s\""
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|parsestatus
argument_list|(
name|parsetime
operator|->
name|parse_status
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|==
name|CVT_FAIL
condition|)
block|{
comment|/* 	   * tell more about the story - list time code 	   * there is a slight change for a race condition and 	   * the time code might be overwritten by the next packet 	   */
name|parsectl_t
name|tmpctl
decl_stmt|;
if|if
condition|(
operator|!
name|PARSE_GETTIMECODE
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_process: parse_timecode() FAILED"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PARSE receiver #%d: FAILED TIMECODE: \"%s\""
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|mkascii
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_buffer
argument_list|,
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_count
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|badformat
operator|+=
name|tmpctl
operator|.
name|parsegettc
operator|.
name|parse_badformat
expr_stmt|;
block|}
block|}
name|parse
operator|->
name|laststatus
operator|=
name|parsetime
operator|->
name|parse_status
expr_stmt|;
block|}
comment|/*    * examine status and post appropriate events    */
if|if
condition|(
operator|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_OK
condition|)
block|{
comment|/*        * got bad data - tell the rest of the system        */
switch|switch
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_MASK
condition|)
block|{
case|case
name|CVT_NONE
case|:
break|break;
comment|/* well, still waiting - timeout is handled at higher levels */
case|case
name|CVT_FAIL
case|:
name|parse
operator|->
name|badformat
operator|++
expr_stmt|;
if|if
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_BADFMT
condition|)
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_BADDATE
condition|)
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parsetime
operator|->
name|parse_status
operator|&
name|CVT_BADTIME
condition|)
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
comment|/* for the lack of something better */
block|}
block|}
return|return;
comment|/* skip the rest - useless */
block|}
comment|/*    * check for format changes    * (in case somebody has swapped clocks 8-)    */
if|if
condition|(
name|parse
operator|->
name|lastformat
operator|!=
name|parsetime
operator|->
name|parse_format
condition|)
block|{
name|parsectl_t
name|tmpctl
decl_stmt|;
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_format
operator|=
name|parsetime
operator|->
name|parse_format
expr_stmt|;
if|if
condition|(
operator|!
name|PARSE_GETFMT
argument_list|(
name|parse
argument_list|,
operator|&
name|tmpctl
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: parse_getfmt() FAILED"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: new packet format \"%s\""
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|tmpctl
operator|.
name|parseformat
operator|.
name|parse_buffer
argument_list|)
expr_stmt|;
block|}
name|parse
operator|->
name|lastformat
operator|=
name|parsetime
operator|->
name|parse_format
expr_stmt|;
block|}
comment|/*    * now, any changes ?    */
if|if
condition|(
name|parse
operator|->
name|time
operator|.
name|parse_state
operator|!=
name|parsetime
operator|->
name|parse_state
condition|)
block|{
name|char
name|tmp1
index|[
literal|200
index|]
decl_stmt|;
name|char
name|tmp2
index|[
literal|200
index|]
decl_stmt|;
comment|/*        * something happend        */
operator|(
name|void
operator|)
name|parsestate
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parsestate
argument_list|(
name|parse
operator|->
name|time
operator|.
name|parse_state
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PARSE receiver #%d: STATE CHANGE: %s -> %s"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
comment|/*    * remember for future    */
name|parse
operator|->
name|time
operator|=
operator|*
name|parsetime
expr_stmt|;
comment|/*    * check to see, whether the clock did a complete powerup or lost PZF signal    * and post correct events for current condition    */
if|if
condition|(
name|PARSE_POWERUP
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/*        * this is bad, as we have completely lost synchronisation        * well this is a problem with the receiver here        * for PARSE U/A 31 the lost synchronisation ist true        * as it is the powerup state and the time is taken        * from a crude real time clock chip        * for the PZF series this is only partly true, as        * PARSE_POWERUP only means that the pseudo random        * phase shift sequence cannot be found. this is only        * bad, if we have never seen the clock in the SYNC        * state, where the PHASE and EPOCH are correct.        * for reporting events the above business does not        * really matter, but we can use the time code        * even in the POWERUP state after having seen        * the clock in the synchronized state (PZF class        * receivers) unless we have had a telegram disruption        * after having seen the clock in the SYNC state. we        * thus require having seen the clock in SYNC state        * *after* having missed telegrams (noresponse) from        * the clock. one problem remains: we might use erroneously        * POWERUP data if the disruption is shorter than 1 polling        * interval. fortunately powerdowns last usually longer than 64        * seconds and the receiver is at least 2 minutes in the        * POWERUP or NOSYNC state before switching to SYNC        */
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|nosynctime
condition|)
block|{
comment|/* 	   * repeated POWERUP/NOSYNC state - look whether 	   * the message should be repeated 	   */
if|if
condition|(
name|current_time
operator|-
name|parse
operator|->
name|nosynctime
operator|>
name|PARSENOSYNCREPEAT
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: *STILL* NOT SYNCHRONIZED (POWERUP or no PZF signal)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|nosynctime
operator|=
name|current_time
expr_stmt|;
block|}
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: NOT SYNCHRONIZED"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|nosynctime
operator|=
name|current_time
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*        * we have two states left        *        * SYNC:        *  this state means that the EPOCH (timecode) and PHASE        *  information has be read correctly (at least two        *  successive PARSE timecodes were received correctly)        *  this is the best possible state - full trust        *        * NOSYNC:        *  The clock should be on phase with respect to the second        *  signal, but the timecode has not been received correctly within        *  at least the last two minutes. this is a sort of half baked state        *  for PARSE U/A 31 this is bad news (clock running without timecode        *  confirmation)        *  PZF 535 has also no time confirmation, but the phase should be        *  very precise as the PZF signal can be decoded        */
name|parse
operator|->
name|nosynctime
operator|=
literal|0
expr_stmt|;
comment|/* current state is better than worst state */
if|if
condition|(
name|PARSE_SYNC
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 	   * currently completely synchronized - best possible state 	   */
name|parse
operator|->
name|lastsync
operator|=
name|current_time
expr_stmt|;
comment|/* 	   * log OK status 	   */
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * we have had some problems receiving the time code 	   */
name|parse_event
argument_list|(
name|parse
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
name|l_fp
name|offset
decl_stmt|;
comment|/*        * calculate time offset including systematic delays        * off = PARSE-timestamp + propagation delay - kernel time stamp        */
name|offset
operator|=
name|parse
operator|->
name|basedelay
expr_stmt|;
name|off
operator|=
name|parsetime
operator|->
name|parse_time
operator|.
name|fp
expr_stmt|;
name|reftime
operator|=
name|off
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|rectime
operator|=
name|off
expr_stmt|;
comment|/* this makes org time and xmt time somewhat artificial */
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|parsetime
operator|->
name|parse_stime
operator|.
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parse
operator|->
name|flags
operator|&
name|PARSE_STAT_FILTER
operator|)
operator|&&
operator|(
name|off
operator|.
name|l_i
operator|>
operator|-
literal|60
operator|)
operator|&&
operator|(
name|off
operator|.
name|l_i
operator|<
literal|60
operator|)
condition|)
comment|/* take usec error only if within +- 60 secs */
block|{
name|struct
name|timeval
name|usecerror
decl_stmt|;
comment|/* 	   * offset is already calculated 	   */
name|usecerror
operator|.
name|tv_sec
operator|=
name|parsetime
operator|->
name|parse_usecerror
operator|/
literal|1000000
expr_stmt|;
name|usecerror
operator|.
name|tv_usec
operator|=
name|parsetime
operator|->
name|parse_usecerror
operator|%
literal|1000000
expr_stmt|;
name|sTVTOTS
argument_list|(
operator|&
name|usecerror
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
operator|&&
name|CL_PPS
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
condition|)
block|{
name|l_fp
name|offset
decl_stmt|;
comment|/*        * we have a PPS signal - much better than the RS232 stuff (we hope)        */
name|offset
operator|=
name|parsetime
operator|->
name|parse_ptime
operator|.
name|fp
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|parse
operator|->
name|ppsdelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|M_ISGEQ
argument_list|(
name|off
operator|.
name|l_i
argument_list|,
name|off
operator|.
name|l_f
argument_list|,
operator|-
literal|1
argument_list|,
literal|0x80000000
argument_list|)
operator|&&
name|M_ISGEQ
argument_list|(
literal|0
argument_list|,
literal|0x7fffffff
argument_list|,
name|off
operator|.
name|l_i
argument_list|,
name|off
operator|.
name|l_f
argument_list|)
condition|)
block|{
comment|/* 	       * RS232 offsets within [-0.5..0.5[ - take PPS offsets 	       */
if|if
condition|(
name|parse
operator|->
name|parse_type
operator|->
name|cl_flags
operator|&
name|PARSE_F_PPSONSECOND
condition|)
block|{
name|reftime
operator|=
name|off
operator|=
name|offset
expr_stmt|;
name|rectime
operator|=
name|offset
expr_stmt|;
comment|/* 		   * implied on second offset 		   */
name|off
operator|.
name|l_uf
operator|=
operator|~
name|off
operator|.
name|l_uf
expr_stmt|;
comment|/* map [0.5..1[ -> [-0.5..0[ */
name|off
operator|.
name|l_ui
operator|=
operator|(
name|off
operator|.
name|l_f
operator|<
literal|0
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
comment|/* sign extend */
block|}
else|else
block|{
comment|/* 		   * time code describes pulse 		   */
name|off
operator|=
name|parsetime
operator|->
name|parse_time
operator|.
name|fp
expr_stmt|;
name|rectime
operator|=
name|reftime
operator|=
name|off
expr_stmt|;
comment|/* take reference time - fake rectime */
name|L_SUB
argument_list|(
operator|&
name|off
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* true offset */
block|}
block|}
comment|/* 	   * take RS232 offset when PPS when out of bounds 	   */
block|}
else|else
block|{
comment|/* 	   * Well, no time code to guide us - assume on second pulse 	   * and pray, that we are within [-0.5..0.5[ 	   */
name|reftime
operator|=
name|off
operator|=
name|offset
expr_stmt|;
name|rectime
operator|=
name|offset
expr_stmt|;
comment|/* 	   * implied on second offset 	   */
name|off
operator|.
name|l_uf
operator|=
operator|~
name|off
operator|.
name|l_uf
expr_stmt|;
comment|/* map [0.5..1[ -> [-0.5..0[ */
name|off
operator|.
name|l_ui
operator|=
operator|(
name|off
operator|.
name|l_f
operator|<
literal|0
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
comment|/* sign extend */
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PARSE_TIMECODE
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 	   * Well, no PPS, no TIMECODE, no more work ... 	   */
return|return;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PARSEPPS
argument_list|)
if|if
condition|(
name|CL_PPS
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
operator|&&
operator|!
name|parse
operator|->
name|pollonly
operator|&&
name|PARSE_SYNC
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/*        * only provide PPS information when clock        * is in sync        * thus PHASE and EPOCH are correct and PPS is not        * done via the CIOGETEV loopfilter mechanism        */
ifdef|#
directive|ifdef
name|PPSPPS
if|if
condition|(
name|fdpps
operator|!=
name|parse
operator|->
name|fd
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|pps_sample
argument_list|(
operator|&
name|off
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PPS || PPSCLK || PPSPPS || PARSEPPS */
comment|/*    * ready, unless the machine wants a sample    */
if|if
condition|(
operator|!
name|parse
operator|->
name|pollonly
operator|&&
operator|!
name|parse
operator|->
name|pollneeddata
condition|)
return|return;
name|parse
operator|->
name|pollneeddata
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PARSE_PPS
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
name|L_CLR
argument_list|(
operator|&
name|dispersion
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        * convert usec dispersion into NTP TS world        */
name|usecdisp
operator|.
name|tv_sec
operator|=
name|parsetime
operator|->
name|parse_usecdisp
operator|/
literal|1000000
expr_stmt|;
name|usecdisp
operator|.
name|tv_usec
operator|=
name|parsetime
operator|->
name|parse_usecdisp
operator|%
literal|1000000
expr_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|usecdisp
argument_list|,
operator|&
name|dispersion
argument_list|)
expr_stmt|;
block|}
comment|/*    * and now stick it into the clock machine    * samples are only valid iff lastsync is not too old and    * we have seen the clock in sync at least once    * after the last time we didn't see an expected data telegram    * see the clock states section above for more reasoning    */
if|if
condition|(
operator|(
operator|(
name|current_time
operator|-
name|parse
operator|->
name|lastsync
operator|)
operator|>
name|parse
operator|->
name|parse_type
operator|->
name|cl_maxunsync
operator|)
operator|||
operator|(
name|parse
operator|->
name|lastsync
operator|<=
name|parse
operator|->
name|lastmissed
operator|)
condition|)
block|{
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PARSE_LEAPADD
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
comment|/* 	   * we pick this state also for time code that pass leap warnings 	   * without direction information (as earth is currently slowing 	   * down). 	   */
name|leap
operator|=
operator|(
name|parse
operator|->
name|flags
operator|&
name|PARSE_LEAP_DELETE
operator|)
condition|?
name|LEAP_DELSECOND
else|:
name|LEAP_ADDSECOND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PARSE_LEAPDEL
argument_list|(
name|parsetime
operator|->
name|parse_state
argument_list|)
condition|)
block|{
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
block|}
else|else
block|{
name|leap
operator|=
name|LEAP_NOWARNING
expr_stmt|;
block|}
block|}
name|refclock_receive
argument_list|(
name|parse
operator|->
name|peer
argument_list|,
operator|&
name|off
argument_list|,
literal|0
argument_list|,
name|LFPTOFP
argument_list|(
operator|&
name|dispersion
argument_list|)
argument_list|,
operator|&
name|reftime
argument_list|,
operator|&
name|rectime
argument_list|,
name|leap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**===========================================================================  ** clock polling support  **/
end_comment

begin_struct
struct|struct
name|poll_timer
block|{
name|struct
name|event
name|timer
decl_stmt|;
comment|/* we'd like to poll a a higher rate than 1/64s */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|poll_timer
name|poll_timer_t
typedef|;
end_typedef

begin_comment
comment|/*--------------------------------------------------  * direct poll routine  */
end_comment

begin_function
specifier|static
name|void
name|poll_dpoll
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|int
name|rtc
decl_stmt|;
specifier|register
name|char
modifier|*
name|ps
init|=
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|string
decl_stmt|;
specifier|register
name|int
name|ct
init|=
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|count
decl_stmt|;
name|rtc
operator|=
name|write
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
name|ps
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll_dpoll: failed to send cmd to clock: %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtc
operator|!=
name|ct
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: poll_dpoll: failed to send cmd incomplete (%d of %d bytes sent)"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|,
name|rtc
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * periodic poll routine  */
end_comment

begin_function
specifier|static
name|void
name|poll_poll
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|poll_timer_t
modifier|*
name|pt
init|=
operator|(
name|poll_timer_t
operator|*
operator|)
name|parse
operator|->
name|localdata
decl_stmt|;
name|poll_dpoll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
operator|(
name|poll_timer_t
operator|*
operator|)
literal|0
condition|)
block|{
name|pt
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
expr_stmt|;
name|TIMER_ENQUEUE
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|pt
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * init routine - setup timer  */
end_comment

begin_function
specifier|static
name|int
name|poll_init
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
specifier|register
name|poll_timer_t
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|poll_info_t
operator|*
operator|)
name|parse
operator|->
name|parse_type
operator|->
name|cl_data
operator|)
operator|->
name|rate
condition|)
block|{
name|parse
operator|->
name|localdata
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|poll_timer_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parse
operator|->
name|localdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|poll_timer_t
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|=
operator|(
name|poll_timer_t
operator|*
operator|)
name|parse
operator|->
name|localdata
expr_stmt|;
name|pt
operator|->
name|timer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|parse
expr_stmt|;
comment|/* well, only we know what it is */
name|pt
operator|->
name|timer
operator|.
name|event_handler
operator|=
name|poll_poll
expr_stmt|;
name|poll_poll
argument_list|(
name|parse
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|->
name|localdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------  * end routine - clean up timer  */
end_comment

begin_function
specifier|static
name|void
name|poll_end
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
if|if
condition|(
name|parse
operator|->
name|localdata
operator|!=
operator|(
name|void
operator|*
operator|)
literal|0
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
operator|(
operator|(
name|poll_timer_t
operator|*
operator|)
name|parse
operator|->
name|localdata
operator|)
operator|->
name|timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parse
operator|->
name|localdata
argument_list|)
expr_stmt|;
name|parse
operator|->
name|localdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**===========================================================================  ** special code for special clocks  **/
end_comment

begin_comment
comment|/*--------------------------------------------------  * trimble init routine - setup EOL and then do poll_init.  */
end_comment

begin_function
specifier|static
name|int
name|trimble_init
parameter_list|(
name|parse
parameter_list|)
name|struct
name|parseunit
modifier|*
name|parse
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
name|struct
name|termios
name|tm
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SYSV_TTYS
name|struct
name|termio
name|tm
decl_stmt|;
endif|#
directive|endif
comment|/*    * configure terminal line for trimble receiver    */
if|if
condition|(
name|TTY_GETATTR
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimble_init: tcgetattr(fd,&tm): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tm
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
name|TRIMBLESV6_EOL
expr_stmt|;
if|if
condition|(
name|TTY_SETATTR
argument_list|(
name|parse
operator|->
name|fd
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PARSE receiver #%d: trimble_init: tcsetattr(fd,&tm): %m"
argument_list|,
name|CL_UNIT
argument_list|(
name|parse
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|poll_init
argument_list|(
name|parse
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(REFCLOCK)&& defined(PARSE) */
end_comment

begin_comment
comment|/*  * History:  *  * refclock_parse.c,v  * Revision 3.53  1994/03/25  13:07:39  kardel  * fixed offset calculation for large (>4 Min) offsets  *  * Revision 3.52  1994/03/03  09:58:00  kardel  * stick -kv in cvs is no fun  *  * Revision 3.49  1994/02/20  13:26:00  kardel  * rcs id cleanup  *  * Revision 3.48  1994/02/20  13:04:56  kardel  * parse add/delete second support  *  * Revision 3.47  1994/02/02  17:44:30  kardel  * rcs ids fixed  *  * Revision 3.45  1994/01/25  19:06:27  kardel  * 94/01/23 reconcilation  *  * Revision 3.44  1994/01/25  17:32:23  kardel  * settable extended variables  *  * Revision 3.43  1994/01/23  16:28:39  kardel  * HAVE_TERMIOS introduced  *  * Revision 3.42  1994/01/22  11:35:04  kardel  * added HAVE_TERMIOS  *  * Revision 3.41  1993/11/27  18:44:37  kardel  * can't trust GPS166 on unsync  *  * Revision 3.40  1993/11/21  18:03:36  kardel  * useless declaration deleted  *  * Revision 3.39  1993/11/21  15:30:15  kardel  * static funcitions may be declared only at outer level  *  * Revision 3.38  1993/11/15  21:26:49  kardel  * conditional define comments fixed  *  * Revision 3.37  1993/11/11  11:20:49  kardel  * declaration fixes  *  * Revision 3.36  1993/11/10  12:17:14  kardel  * #ifdef glitch  *  * Revision 3.35  1993/11/01  21:15:06  kardel  * comments updated  *  * Revision 3.34  1993/11/01  20:01:08  kardel  * parse Solaris support (initial version)  *  * Revision 3.33  1993/10/30  09:44:58  kardel  * conditional compilation flag cleanup  *  * Revision 3.32  1993/10/22  14:28:43  kardel  * Oct. 22nd 1993 reconcilation  *  * Revision 3.31  1993/10/10  21:19:10  kardel  * compilation cleanup - (minimal porting tests)  *  * Revision 3.30  1993/10/09  21:44:35  kardel  * syslog strings fixed  *  * Revision 3.29  1993/10/09  14:40:15  kardel  * default precision setting fixed  *  * Revision 3.28  1993/10/08  14:48:22  kardel  * Changed offset determination logic:  * 	Take the PPS offset if it is available and the time  * 	code offset is within [-0.5..0.5[, otherwise stick  * 	to the time code offset  *  * Revision 3.27  1993/10/08  00:53:17  kardel  * announce also simulated PPS via CIOGETEV in ntpq cl  *  * Revision 3.26  1993/10/07  23:29:35  kardel  * trimble fixes  *  * Revision 3.25  1993/10/06  21:13:35  kardel  * test reversed (CIOGETEV support)  *  * Revision 3.24  1993/10/03  20:18:26  kardel  * Well, values> 999999 in the usec field from uniqtime() timestamps  * can prove harmful.  *  * Revision 3.23  1993/10/03  19:49:54  kardel  * buftvtots where failing on uninitialized time stamps  *  * Revision 3.22  1993/10/03  19:11:09  kardel  * restructured I/O handling  *  * Revision 3.21  1993/09/29  11:30:18  kardel  * special init for trimble to set EOL  *  * Revision 3.20  1993/09/27  22:46:28  kardel  * preserve module stack if I_PUSH parse fails  *  * Revision 3.19  1993/09/27  21:10:11  kardel  * wrong structure member  *  * Revision 3.18  1993/09/27  13:05:06  kardel  * Trimble is true polling only  *  * Revision 3.17  1993/09/27  12:47:10  kardel  * poll string support generalized  *  * Revision 3.16  1993/09/26  23:40:56  kardel  * new parse driver logic  *  * Revision 3.15  1993/09/24  15:00:51  kardel  * Sep 23rd distribution...  *  * Revision 3.14  1993/09/22  18:21:15  kardel  * support ppsclock streams module (-DSTREAM -DPPSPPS -DPARSEPPS -UPARSESTREAM)  *  * Revision 3.13  1993/09/05  15:38:33  kardel  * not every cpp understands #error...  *  * Revision 3.12  1993/09/02  20:04:19  kardel  * TTY cleanup  *  * Revision 3.11  1993/09/01  21:48:47  kardel  * conditional cleanup  *  * Revision 3.10  1993/09/01  11:32:45  kardel  * assuming HAVE_POSIX_TTYS when STREAM defined  *  * Revision 3.9  1993/08/31  22:31:46  kardel  * SINIX-M SysVR4 integration  *  * Revision 3.8  1993/08/27  00:29:50  kardel  * compilation cleanup  *  * Revision 3.7  1993/08/24  22:27:30  kardel  * cleaned up AUTOCONF DCF77 mess 8-) - wasn't too bad  *  * Revision 3.6  1993/08/24  21:36:23  kardel  * casting and ifdefs  *  * Revision 3.5  1993/07/09  23:36:59  kardel  * HAVE_POSIX_TTYS used to produce errors 8-( - BSD driver support still lacking  *  * Revision 3.4  1993/07/09  12:42:29  kardel  * RAW DCF now officially released  *  * Revision 3.3  1993/07/09  11:50:37  kardel  * running GPS also on 960 to be able to switch GPS/DCF77  *  * Revision 3.2  1993/07/09  11:37:34  kardel  * Initial restructured version + GPS support  *  * Revision 3.1  1993/07/06  10:01:07  kardel  * DCF77 driver goes generic...  *  */
end_comment

end_unit

