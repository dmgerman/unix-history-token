begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_config.c - read and apply configuration information  */
end_comment

begin_define
define|#
directive|define
name|RESOLVE_INTERNAL
end_define

begin_comment
comment|/* gdt */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * These routines are used to read the configuration file at  * startup time.  An entry in the file must fit on a single line.  * Entries are processed as multiple tokens separated by white space  * Lines are considered terminated when a '#' is encountered.  Blank  * lines are ignored.  */
end_comment

begin_comment
comment|/*  * Configuration file name  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_FILE
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__bsdi__
argument_list|)
end_if

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/usr/local/etc/xntp.conf"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/etc/ntp.conf"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_FILE */
end_comment

begin_comment
comment|/*  * We understand the following configuration entries and defaults.  *  * peer 128.100.1.1 [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * server 128.100.2.2 [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * precision -7  * broadcast 128.100.224.255 [ version 3 ] [ key 0 ]  * broadcastclient yes|no  * broadcastdelay 0.0102  * authenticate yes|no  * monitor yes|no  * authdelay 0.00842  * pps [ delay 0.000247 ] [ baud 38400 ]  * restrict 128.100.100.0 [ mask 255.255.255.0 ] ignore|noserve|notrust|noquery  * driftfile file_name  * keys file_name  * statsdir /var/NTP/  * filegen peerstats [ file peerstats ] [ type day ] [ link ]  * resolver /path/progname  *  * And then some.  See the manual page.  */
end_comment

begin_comment
comment|/*  * Types of entries we understand.  */
end_comment

begin_define
define|#
directive|define
name|CONFIG_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|CONFIG_PEER
value|1
end_define

begin_define
define|#
directive|define
name|CONFIG_SERVER
value|2
end_define

begin_define
define|#
directive|define
name|CONFIG_PRECISION
value|3
end_define

begin_define
define|#
directive|define
name|CONFIG_DRIFTFILE
value|4
end_define

begin_define
define|#
directive|define
name|CONFIG_BROADCAST
value|5
end_define

begin_define
define|#
directive|define
name|CONFIG_BROADCASTCLIENT
value|6
end_define

begin_define
define|#
directive|define
name|CONFIG_AUTHENTICATE
value|7
end_define

begin_define
define|#
directive|define
name|CONFIG_KEYS
value|8
end_define

begin_define
define|#
directive|define
name|CONFIG_MONITOR
value|9
end_define

begin_define
define|#
directive|define
name|CONFIG_AUTHDELAY
value|10
end_define

begin_define
define|#
directive|define
name|CONFIG_RESTRICT
value|11
end_define

begin_define
define|#
directive|define
name|CONFIG_BDELAY
value|12
end_define

begin_define
define|#
directive|define
name|CONFIG_TRUSTEDKEY
value|13
end_define

begin_define
define|#
directive|define
name|CONFIG_REQUESTKEY
value|14
end_define

begin_define
define|#
directive|define
name|CONFIG_CONTROLKEY
value|15
end_define

begin_define
define|#
directive|define
name|CONFIG_TRAP
value|16
end_define

begin_define
define|#
directive|define
name|CONFIG_FUDGE
value|17
end_define

begin_define
define|#
directive|define
name|CONFIG_MAXSKEW
value|18
end_define

begin_define
define|#
directive|define
name|CONFIG_RESOLVER
value|19
end_define

begin_define
define|#
directive|define
name|CONFIG_SELECT
value|20
end_define

begin_define
define|#
directive|define
name|CONFIG_STATSDIR
value|21
end_define

begin_define
define|#
directive|define
name|CONFIG_FILEGEN
value|22
end_define

begin_define
define|#
directive|define
name|CONFIG_STATISTICS
value|23
end_define

begin_define
define|#
directive|define
name|CONFIG_PPS
value|24
end_define

begin_define
define|#
directive|define
name|CONFIG_PIDFILE
value|25
end_define

begin_define
define|#
directive|define
name|CONFIG_LOGFILE
value|26
end_define

begin_define
define|#
directive|define
name|CONFIG_SETVAR
value|27
end_define

begin_define
define|#
directive|define
name|CONF_MOD_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|CONF_MOD_KEY
value|2
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MINPOLL
value|3
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MAXPOLL
value|4
end_define

begin_define
define|#
directive|define
name|CONF_MOD_PREFER
value|5
end_define

begin_define
define|#
directive|define
name|CONF_PPS_DELAY
value|1
end_define

begin_define
define|#
directive|define
name|CONF_PPS_BAUD
value|2
end_define

begin_define
define|#
directive|define
name|CONF_RES_MASK
value|1
end_define

begin_define
define|#
directive|define
name|CONF_RES_IGNORE
value|2
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOSERVE
value|3
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOTRUST
value|4
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOQUERY
value|5
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOMODIFY
value|6
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOPEER
value|7
end_define

begin_define
define|#
directive|define
name|CONF_RES_NOTRAP
value|8
end_define

begin_define
define|#
directive|define
name|CONF_RES_LPTRAP
value|9
end_define

begin_define
define|#
directive|define
name|CONF_RES_NTPPORT
value|10
end_define

begin_define
define|#
directive|define
name|CONF_TRAP_PORT
value|1
end_define

begin_define
define|#
directive|define
name|CONF_TRAP_INTERFACE
value|2
end_define

begin_define
define|#
directive|define
name|CONF_FDG_TIME1
value|1
end_define

begin_define
define|#
directive|define
name|CONF_FDG_TIME2
value|2
end_define

begin_define
define|#
directive|define
name|CONF_FDG_VALUE1
value|3
end_define

begin_define
define|#
directive|define
name|CONF_FDG_VALUE2
value|4
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG1
value|5
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG2
value|6
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG3
value|7
end_define

begin_define
define|#
directive|define
name|CONF_FDG_FLAG4
value|8
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FILE
value|1
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_TYPE
value|2
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_LINK
value|3
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_NOLINK
value|4
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_ENABLE
value|5
end_define

begin_define
define|#
directive|define
name|CONF_FGEN_FLAG_DISABLE
value|6
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_300
value|1
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_600
value|2
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_1200
value|3
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_2400
value|4
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_4800
value|5
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_9600
value|6
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_19200
value|7
end_define

begin_define
define|#
directive|define
name|CONF_BAUD_38400
value|8
end_define

begin_comment
comment|/*  * Translation table - keywords to function index  */
end_comment

begin_struct
struct|struct
name|keyword
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|keytype
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|keywords
index|[]
init|=
block|{
block|{
literal|"peer"
block|,
name|CONFIG_PEER
block|}
block|,
block|{
literal|"server"
block|,
name|CONFIG_SERVER
block|}
block|,
block|{
literal|"precision"
block|,
name|CONFIG_PRECISION
block|}
block|,
block|{
literal|"driftfile"
block|,
name|CONFIG_DRIFTFILE
block|}
block|,
block|{
literal|"broadcast"
block|,
name|CONFIG_BROADCAST
block|}
block|,
block|{
literal|"broadcastclient"
block|,
name|CONFIG_BROADCASTCLIENT
block|}
block|,
block|{
literal|"authenticate"
block|,
name|CONFIG_AUTHENTICATE
block|}
block|,
block|{
literal|"keys"
block|,
name|CONFIG_KEYS
block|}
block|,
block|{
literal|"monitor"
block|,
name|CONFIG_MONITOR
block|}
block|,
block|{
literal|"authdelay"
block|,
name|CONFIG_AUTHDELAY
block|}
block|,
block|{
literal|"pps"
block|,
name|CONFIG_PPS
block|}
block|,
block|{
literal|"restrict"
block|,
name|CONFIG_RESTRICT
block|}
block|,
block|{
literal|"broadcastdelay"
block|,
name|CONFIG_BDELAY
block|}
block|,
block|{
literal|"trustedkey"
block|,
name|CONFIG_TRUSTEDKEY
block|}
block|,
block|{
literal|"requestkey"
block|,
name|CONFIG_REQUESTKEY
block|}
block|,
block|{
literal|"controlkey"
block|,
name|CONFIG_CONTROLKEY
block|}
block|,
block|{
literal|"trap"
block|,
name|CONFIG_TRAP
block|}
block|,
block|{
literal|"fudge"
block|,
name|CONFIG_FUDGE
block|}
block|,
block|{
literal|"maxskew"
block|,
name|CONFIG_MAXSKEW
block|}
block|,
block|{
literal|"resolver"
block|,
name|CONFIG_RESOLVER
block|}
block|,
block|{
literal|"select"
block|,
name|CONFIG_SELECT
block|}
block|,
block|{
literal|"statsdir"
block|,
name|CONFIG_STATSDIR
block|}
block|,
block|{
literal|"filegen"
block|,
name|CONFIG_FILEGEN
block|}
block|,
block|{
literal|"statistics"
block|,
name|CONFIG_STATISTICS
block|}
block|,
block|{
literal|"pidfile"
block|,
name|CONFIG_PIDFILE
block|}
block|,
block|{
literal|"logfile"
block|,
name|CONFIG_LOGFILE
block|}
block|,
block|{
literal|"setvar"
block|,
name|CONFIG_SETVAR
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|mod_keywords
index|[]
init|=
block|{
block|{
literal|"version"
block|,
name|CONF_MOD_VERSION
block|}
block|,
block|{
literal|"key"
block|,
name|CONF_MOD_KEY
block|}
block|,
block|{
literal|"minpoll"
block|,
name|CONF_MOD_MINPOLL
block|}
block|,
block|{
literal|"maxpoll"
block|,
name|CONF_MOD_MAXPOLL
block|}
block|,
block|{
literal|"prefer"
block|,
name|CONF_MOD_PREFER
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PPS modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|pps_keywords
index|[]
init|=
block|{
block|{
literal|"delay"
block|,
name|CONF_PPS_DELAY
block|}
block|,
block|{
literal|"baud"
block|,
name|CONF_PPS_BAUD
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special restrict keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|res_keywords
index|[]
init|=
block|{
block|{
literal|"mask"
block|,
name|CONF_RES_MASK
block|}
block|,
block|{
literal|"ignore"
block|,
name|CONF_RES_IGNORE
block|}
block|,
block|{
literal|"noserve"
block|,
name|CONF_RES_NOSERVE
block|}
block|,
block|{
literal|"notrust"
block|,
name|CONF_RES_NOTRUST
block|}
block|,
block|{
literal|"noquery"
block|,
name|CONF_RES_NOQUERY
block|}
block|,
block|{
literal|"nomodify"
block|,
name|CONF_RES_NOMODIFY
block|}
block|,
block|{
literal|"nopeer"
block|,
name|CONF_RES_NOPEER
block|}
block|,
block|{
literal|"notrap"
block|,
name|CONF_RES_NOTRAP
block|}
block|,
block|{
literal|"lowpriotrap"
block|,
name|CONF_RES_LPTRAP
block|}
block|,
block|{
literal|"ntpport"
block|,
name|CONF_RES_NTPPORT
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Baud rate keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|baud_keywords
index|[]
init|=
block|{
block|{
literal|"300"
block|,
name|CONF_BAUD_300
block|}
block|,
block|{
literal|"600"
block|,
name|CONF_BAUD_600
block|}
block|,
block|{
literal|"1200"
block|,
name|CONF_BAUD_1200
block|}
block|,
block|{
literal|"2400"
block|,
name|CONF_BAUD_2400
block|}
block|,
block|{
literal|"4800"
block|,
name|CONF_BAUD_4800
block|}
block|,
block|{
literal|"9600"
block|,
name|CONF_BAUD_9600
block|}
block|,
block|{
literal|"19200"
block|,
name|CONF_BAUD_19200
block|}
block|,
block|{
literal|"38400"
block|,
name|CONF_BAUD_38400
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keywords for the trap command  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|trap_keywords
index|[]
init|=
block|{
block|{
literal|"port"
block|,
name|CONF_TRAP_PORT
block|}
block|,
block|{
literal|"interface"
block|,
name|CONF_TRAP_INTERFACE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keywords for the fudge command  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|fudge_keywords
index|[]
init|=
block|{
block|{
literal|"time1"
block|,
name|CONF_FDG_TIME1
block|}
block|,
block|{
literal|"time2"
block|,
name|CONF_FDG_TIME2
block|}
block|,
block|{
literal|"value1"
block|,
name|CONF_FDG_VALUE1
block|}
block|,
block|{
literal|"value2"
block|,
name|CONF_FDG_VALUE2
block|}
block|,
block|{
literal|"flag1"
block|,
name|CONF_FDG_FLAG1
block|}
block|,
block|{
literal|"flag2"
block|,
name|CONF_FDG_FLAG2
block|}
block|,
block|{
literal|"flag3"
block|,
name|CONF_FDG_FLAG3
block|}
block|,
block|{
literal|"flag4"
block|,
name|CONF_FDG_FLAG4
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keywords for the filegen command  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|filegen_keywords
index|[]
init|=
block|{
block|{
literal|"file"
block|,
name|CONF_FGEN_FILE
block|}
block|,
block|{
literal|"type"
block|,
name|CONF_FGEN_TYPE
block|}
block|,
block|{
literal|"link"
block|,
name|CONF_FGEN_FLAG_LINK
block|}
block|,
block|{
literal|"nolink"
block|,
name|CONF_FGEN_FLAG_NOLINK
block|}
block|,
block|{
literal|"enable"
block|,
name|CONF_FGEN_FLAG_ENABLE
block|}
block|,
block|{
literal|"disable"
block|,
name|CONF_FGEN_FLAG_DISABLE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|fgen_types
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|FILEGEN_NONE
block|}
block|,
block|{
literal|"pid"
block|,
name|FILEGEN_PID
block|}
block|,
block|{
literal|"day"
block|,
name|FILEGEN_DAY
block|}
block|,
block|{
literal|"week"
block|,
name|FILEGEN_WEEK
block|}
block|,
block|{
literal|"month"
block|,
name|FILEGEN_MONTH
block|}
block|,
block|{
literal|"year"
block|,
name|FILEGEN_YEAR
block|}
block|,
block|{
literal|"age"
block|,
name|FILEGEN_AGE
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Limits on things  */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|20
end_define

begin_comment
comment|/* 20 tokens on line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|1024
end_define

begin_comment
comment|/* maximum length of line */
end_comment

begin_define
define|#
directive|define
name|MAXFILENAME
value|128
end_define

begin_comment
comment|/* maximum length of a file name (alloca()?) */
end_comment

begin_comment
comment|/*  * Miscellaneous macros  */
end_comment

begin_define
define|#
directive|define
name|STRSAME
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(*(s1) == *(s2)&& strcmp((s1), (s2)) == 0)
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '#' || (c) == '\n' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * File descriptor used by the resolver save routines, and temporary file  * name.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|res_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|res_file
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enough for /tmp/xntpXXXXXX\0 */
end_comment

begin_define
define|#
directive|define
name|RES_TEMPFILE
value|"/tmp/xntpXXXXXX"
end_define

begin_comment
comment|/*  * Definitions of things either imported from or exported to outside  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|FindConfig
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xntp_options
init|=
literal|"abc:de:f:k:l:p:r:s:t:v:V:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettokens
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|matchkey
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|keyword
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getnetnum
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sockaddr_in
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_resolve
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|U_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_resolve
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|U_LONG
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|do_resolve_internal
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RESOLVE_INTERNAL */
end_comment

begin_decl_stmt
specifier|static
name|void
name|abort_resolve
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|catchchild
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * getstartup - search through the options looking for a debugging flag  */
end_comment

begin_function
name|void
name|getstartup
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|errflg
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
comment|/* no debugging by default */
comment|/* 	 * This is a big hack.  We don't really want to read command line 	 * configuration until everything else is initialized, since 	 * the ability to configure the system may depend on storage 	 * and the like having been initialized.  Except that we also 	 * don't want to initialize anything until after detaching from 	 * the terminal, but we won't know to do that until we've 	 * parsed the command line.  Do that now, crudely, and do it 	 * again later.  Our ntp_getopt() is explicitly reusable, by the 	 * way.  Your own mileage may vary. 	 */
name|errflg
operator|=
literal|0
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Decode argument list 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|xntp_options
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|errflg
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|!=
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [ -abd ] [ -c config_file ] [ -e encryption delay ]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -f frequency file ] [ -k key file ] [ -l log file ]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -p pid file ] [ -r broadcast delay ] [ -s status directory ]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t[ -t trusted key ] [ -v sys variable ] [ -V default sys variable ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ntp_optind
operator|=
literal|0
expr_stmt|;
comment|/* reset ntp_optind to restart ntp_getopt */
if|if
condition|(
name|debug
condition|)
block|{
ifdef|#
directive|ifdef
name|NTP_POSIX_SOURCE
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|buf
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * getconfig - get command line options and read the configuration file  */
end_comment

begin_function
name|void
name|getconfig
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|peerversion
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|U_LONG
name|peerkey
decl_stmt|;
name|int
name|peerflags
decl_stmt|;
name|int
name|hmode
decl_stmt|;
name|struct
name|sockaddr_in
name|peeraddr
decl_stmt|;
name|struct
name|sockaddr_in
name|maskaddr
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
argument_list|*
operator|(
name|tokens
index|[
name|MAXTOKENS
index|]
operator|)
argument_list|;
name|int
name|ntokens
argument_list|;
name|int
name|tok
argument_list|;
expr|struct
name|interface
operator|*
name|localaddr
argument_list|;
name|char
operator|*
name|config_file
argument_list|;
expr|struct
name|refclockstat
name|clock
argument_list|;
name|int
name|have_resolver
argument_list|;
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
name|int
name|resolve_internal
argument_list|;
endif|#
directive|endif
name|char
name|resolver_name
index|[
name|MAXFILENAME
index|]
argument_list|;
name|int
name|have_keyfile
argument_list|;
name|char
name|keyfile
index|[
name|MAXFILENAME
index|]
argument_list|;
specifier|extern
name|int
name|ntp_optind
argument_list|;
specifier|extern
name|char
operator|*
name|ntp_optarg
argument_list|;
specifier|extern
name|char
operator|*
name|Version
argument_list|;
specifier|extern
name|U_LONG
name|info_auth_keyid
argument_list|;
name|FILEGEN
operator|*
name|filegen
argument_list|;
comment|/* 	 * Initialize, initialize 	 */
name|errflg
operator|=
literal|0
argument_list|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|0
argument_list|;
endif|#
directive|endif
comment|/* DEBUG */
name|config_file
operator|=
name|CONFIG_FILE
argument_list|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
argument_list|;
name|res_fp
operator|=
name|NULL
argument_list|;
name|have_resolver
operator|=
name|have_keyfile
operator|=
literal|0
argument_list|;
comment|/* 	 * install a non default variable with this daemon version 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"daemon_version=\"%s\""
argument_list|,
name|Version
argument_list|)
argument_list|;
name|set_sys_var
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
argument_list|)
argument_list|;
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
name|resolve_internal
operator|=
literal|1
argument_list|;
endif|#
directive|endif
comment|/* 	 * Decode argument list 	 */
argument_list|while
operator|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|xntp_options
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
operator|(
name|LONG
operator|)
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
operator|(
name|LONG
operator|)
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|config_file
operator|=
name|ntp_optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|++
expr_stmt|;
else|#
directive|else
name|errflg
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
case|case
literal|'e'
case|:
do|do
block|{
name|l_fp
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line encryption delay value %s undecodable"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line encryption delay value %s is unlikely"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
argument_list|else
block|{
name|proto_config
argument_list|(
name|PROTO_AUTHDELAY
argument_list|,
name|tmp
operator|.
name|l_f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_while
while|while
condition|(
literal|0
condition|)
empty_stmt|;
end_while

begin_break
break|break;
end_break

begin_case
case|case
literal|'f'
case|:
end_case

begin_expr_stmt
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
literal|'k'
case|:
end_case

begin_expr_stmt
name|getauthkeys
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ntp_optarg
argument_list|)
operator|>=
name|MAXFILENAME
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key file name too LONG (>%d, sigh), no name resolution possible"
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|have_keyfile
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|keyfile
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
end_if

begin_break
break|break;
end_break

begin_case
case|case
literal|'p'
case|:
end_case

begin_expr_stmt
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
literal|'r'
case|:
end_case

begin_do
do|do
block|{
name|l_fp
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line broadcast delay value %s undecodable"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line broadcast delay value %s is unlikely"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
name|tmp
operator|.
name|l_f
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
end_do

begin_break
break|break;
end_break

begin_case
case|case
literal|'s'
case|:
end_case

begin_expr_stmt
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
literal|'t'
case|:
end_case

begin_do
do|do
block|{
name|int
name|tkey
decl_stmt|;
name|tkey
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkey
operator|<=
literal|0
operator|||
name|tkey
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"command line trusted key %s is unlikely"
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authtrust
argument_list|(
name|tkey
argument_list|,
operator|(
name|LONG
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
end_do

begin_break
break|break;
end_break

begin_case
case|case
literal|'v'
case|:
end_case

begin_case
case|case
literal|'V'
case|:
end_case

begin_expr_stmt
name|set_sys_var
argument_list|(
name|ntp_optarg
argument_list|,
name|strlen
argument_list|(
name|ntp_optarg
argument_list|)
operator|+
literal|1
argument_list|,
name|RW
operator||
operator|(
operator|(
name|c
operator|==
literal|'V'
operator|)
condition|?
name|DEF
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_expr_stmt
name|errflg
operator|++
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_if
unit|} 	}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|!=
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [ -bd ] [ -c config_file ]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Broadcast clients can sometimes run without 		 * a configuration file. 		 */
return|return;
block|}
end_if

begin_while
while|while
condition|(
operator|(
name|tok
operator|=
name|gettokens
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntokens
argument_list|)
operator|)
operator|!=
name|CONFIG_UNKNOWN
condition|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|CONFIG_PEER
case|:
case|case
name|CONFIG_SERVER
case|:
case|case
name|CONFIG_BROADCAST
case|:
if|if
condition|(
name|tok
operator|==
name|CONFIG_PEER
condition|)
name|hmode
operator|=
name|MODE_ACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|CONFIG_SERVER
condition|)
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
else|else
name|hmode
operator|=
name|MODE_BROADCAST
expr_stmt|;
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No address for %s, line ignored"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|errflg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|REFCLOCK
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
endif|#
directive|endif
name|ISBADADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|peerversion
operator|=
name|NTP_VERSION
expr_stmt|;
name|minpoll
operator|=
name|NTP_MINDPOLL
expr_stmt|;
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
name|peerkey
operator|=
literal|0
expr_stmt|;
name|peerflags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|mod_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_MOD_VERSION
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"peer/server version requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_char
operator|)
name|peerversion
operator|>
name|NTP_VERSION
operator|||
operator|(
name|u_char
operator|)
name|peerversion
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inappropriate version number %s, line ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_KEY
case|:
comment|/* 					 * XXX 					 * This is bad because atoi 					 * returns 0 on errors.  Do 					 * something later. 					 */
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
operator|(
name|U_LONG
operator|)
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|peerflags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MINPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"minpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|minpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|minpoll
operator|<
name|NTP_MINPOLL
condition|)
name|minpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MAXPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"maxpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|maxpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxpoll
operator|>
name|NTP_MAXPOLL
condition|)
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
break|break;
case|case
name|CONF_MOD_PREFER
case|:
name|peerflags
operator||=
name|FLAG_PREFER
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|minpoll
operator|>
name|maxpoll
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config error: minpoll> maxpoll"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|(
expr|struct
name|interface
operator|*
operator|)
literal|0
argument_list|,
name|hmode
argument_list|,
name|peerversion
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|peerkey
argument_list|,
name|peerflags
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configuration of %s failed"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|errflg
operator|==
operator|-
literal|1
condition|)
block|{
name|save_resolve
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
name|hmode
argument_list|,
name|peerversion
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|peerflags
argument_list|,
name|peerkey
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_PRECISION
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|||
name|i
operator|<
operator|-
literal|25
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unlikely precision %s, line ignored"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|proto_config
argument_list|(
name|PROTO_PRECISION
argument_list|,
operator|(
name|LONG
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_DRIFTFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|stats_config
argument_list|(
name|STATS_FREQ_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_PIDFILE
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|stats_config
argument_list|(
name|STATS_PID_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_LOGFILE
case|:
block|{
ifdef|#
directive|ifdef
name|SYSLOG_FILE
specifier|extern
name|int
name|syslogit
decl_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|new_file
operator|=
name|fopen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|syslog_file
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|syslog_file
argument_list|)
expr_stmt|;
name|syslog_file
operator|=
name|new_file
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot open log file %s"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logfile needs one argument"
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"logging to logfile not compiled into xntpd - logfile \"%s\" ignored"
argument_list|,
operator|(
name|ntokens
operator|==
literal|2
operator|)
condition|?
name|tokens
index|[
literal|1
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|CONFIG_BROADCASTCLIENT
case|:
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
operator|(
name|LONG
operator|)
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"no"
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
operator|(
name|LONG
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"should be `broadcastclient yes|no'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_AUTHENTICATE
case|:
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
operator|(
name|LONG
operator|)
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"no"
argument_list|)
condition|)
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
operator|(
name|LONG
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"should be `authenticate yes|no'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_KEYS
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|getauthkeys
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|>=
name|MAXFILENAME
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key file name too LONG (>%d, sigh), no name resolution possible"
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|have_keyfile
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|keyfile
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_MONITOR
case|:
name|errflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|mon_start
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"no"
argument_list|)
condition|)
name|mon_stop
argument_list|()
expr_stmt|;
else|else
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"should be `monitor yes|no'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_AUTHDELAY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|l_fp
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"authdelay value %s undecodable"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"authdelay value %s is unlikely"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_AUTHDELAY
argument_list|,
name|tmp
operator|.
name|l_f
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_PPS
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|pps_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_PPS_DELAY
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pps delay requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|{
name|l_fp
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pps delay value %s undecodable"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loop_config
argument_list|(
name|LOOP_PPSDELAY
argument_list|,
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONF_PPS_BAUD
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pps baud requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|{
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
name|baud_keywords
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|atoi
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|19200
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"pps baud %d unlikely\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|loop_config
argument_list|(
name|LOOP_PPSBAUD
argument_list|,
name|NULL
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|CONFIG_RESTRICT
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"restrict requires an address"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
literal|"default"
argument_list|)
condition|)
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
comment|/* 			 * Use peerversion as flags, peerkey as mflags.  Ick. 			 */
name|peerversion
operator|=
literal|0
expr_stmt|;
name|peerkey
operator|=
literal|0
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|maskaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|~
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|res_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_RES_MASK
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mask keyword needs argument"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
operator|&
name|maskaddr
argument_list|,
literal|1
argument_list|)
condition|)
name|errflg
operator|++
expr_stmt|;
break|break;
case|case
name|CONF_RES_IGNORE
case|:
name|peerversion
operator||=
name|RES_IGNORE
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOSERVE
case|:
name|peerversion
operator||=
name|RES_DONTSERVE
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOTRUST
case|:
name|peerversion
operator||=
name|RES_DONTTRUST
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOQUERY
case|:
name|peerversion
operator||=
name|RES_NOQUERY
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOMODIFY
case|:
name|peerversion
operator||=
name|RES_NOMODIFY
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOPEER
case|:
name|peerversion
operator||=
name|RES_NOPEER
expr_stmt|;
break|break;
case|case
name|CONF_RES_NOTRAP
case|:
name|peerversion
operator||=
name|RES_NOTRAP
expr_stmt|;
break|break;
case|case
name|CONF_RES_LPTRAP
case|:
name|peerversion
operator||=
name|RES_LPTRAP
expr_stmt|;
break|break;
case|case
name|CONF_RES_NTPPORT
case|:
name|peerkey
operator||=
name|RESM_NTPONLY
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|SRCADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|==
name|INADDR_ANY
condition|)
name|maskaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errflg
condition|)
specifier|restrict
operator|(
name|RESTRICT_FLAGS
operator|,
operator|&
name|peeraddr
operator|,
operator|&
name|maskaddr
operator|,
operator|(
name|int
operator|)
name|peerkey
operator|,
name|peerversion
operator|)
expr_stmt|;
break|break;
case|case
name|CONFIG_BDELAY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|l_fp
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"broadcastdelay value %s undecodable"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"broadcastdelay value %s is unlikely"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto_config
argument_list|(
name|PROTO_BROADDELAY
argument_list|,
name|tmp
operator|.
name|l_f
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_TRUSTEDKEY
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|U_LONG
name|tkey
decl_stmt|;
name|tkey
operator|=
operator|(
name|U_LONG
operator|)
name|atoi
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkey
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trusted key %s unlikely"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authtrust
argument_list|(
name|tkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_REQUESTKEY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|U_LONG
name|rkey
decl_stmt|;
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|rkey
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is undecodeable as request key"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rkey
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s makes a poor request keyid"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"set info_auth_key to %lu\n"
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info_auth_keyid
operator|=
name|rkey
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_CONTROLKEY
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|U_LONG
name|ckey
decl_stmt|;
specifier|extern
name|U_LONG
name|ctl_auth_keyid
decl_stmt|;
name|ckey
operator|=
operator|(
name|U_LONG
operator|)
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckey
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s makes a poor control keyid"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_auth_keyid
operator|=
name|ckey
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_TRAP
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no address for trap command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
comment|/* 			 * Use peerversion for port number.  Barf. 			 */
name|errflg
operator|=
literal|0
expr_stmt|;
name|peerversion
operator|=
literal|0
expr_stmt|;
name|localaddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
operator|-
literal|1
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|trap_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_TRAP_PORT
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap port requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerversion
operator|<=
literal|0
operator|||
name|peerversion
operator|>
literal|32767
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid port number %s, trap ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_TRAP_INTERFACE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"trap interface requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|maskaddr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|localaddr
operator|=
name|findinterface
argument_list|(
operator|&
name|maskaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find interface with address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|maskaddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
specifier|extern
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
if|if
condition|(
name|peerversion
operator|!=
literal|0
condition|)
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|peerversion
argument_list|)
expr_stmt|;
else|else
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|TRAPPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|localaddr
operator|==
name|NULL
condition|)
name|localaddr
operator|=
name|any_interface
expr_stmt|;
if|if
condition|(
operator|!
name|ctlsettrap
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
name|NTP_VERSION
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't set trap for %s, no resources"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_FUDGE
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no address for fudge command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is inappropriate address for the fudge command, line ignored"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|clock
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|fudge_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_FDG_TIME1
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|clock
operator|.
name|fudgetime1
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s time1 value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_TIME2
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|clock
operator|.
name|fudgetime2
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s time2 value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVETIME2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_VALUE1
case|:
if|if
condition|(
operator|!
name|atoint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|clock
operator|.
name|fudgeval1
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s value1 value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_VALUE2
case|:
if|if
condition|(
operator|!
name|atoint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|clock
operator|.
name|fudgeval2
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s value2 value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVEVAL2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG1
case|:
case|case
name|CONF_FDG_FLAG2
case|:
case|case
name|CONF_FDG_FLAG3
case|:
case|case
name|CONF_FDG_FLAG4
case|:
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
operator|&
name|peerkey
argument_list|)
operator|||
name|peerkey
operator|>
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fudge %s flag value in error"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CONF_FDG_FLAG1
case|:
name|c
operator|=
name|CLK_FLAG1
expr_stmt|;
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG1
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG2
case|:
name|c
operator|=
name|CLK_FLAG2
expr_stmt|;
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG2
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG3
case|:
name|c
operator|=
name|CLK_FLAG3
expr_stmt|;
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG3
expr_stmt|;
break|break;
case|case
name|CONF_FDG_FLAG4
case|:
name|c
operator|=
name|CLK_FLAG4
expr_stmt|;
name|clock
operator|.
name|haveflags
operator||=
name|CLK_HAVEFLAG4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|peerkey
operator|==
literal|0
condition|)
name|clock
operator|.
name|flags
operator|&=
operator|~
name|c
expr_stmt|;
else|else
name|clock
operator|.
name|flags
operator||=
name|c
expr_stmt|;
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/* 			 * If reference clock support isn't defined the 			 * fudge line will still be accepted and syntax 			 * checked, but will essentially do nothing. 			 */
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
name|refclock_control
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|&
name|clock
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|CONFIG_MAXSKEW
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|l_fp
name|tmp
decl_stmt|;
name|u_fp
name|utmp
decl_stmt|;
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"maxskew value %s undecodable"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"maxskew value %s is unlikely"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utmp
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|proto_config
argument_list|(
name|PROTO_MAXSKEW
argument_list|,
operator|(
name|LONG
operator|)
name|utmp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONFIG_RESOLVER
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|>=
operator|(
name|size_t
operator|)
name|MAXFILENAME
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"resolver path name too LONG (>%d, sigh), no name resolution possible"
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|resolver_name
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|have_resolver
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
name|resolve_internal
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|CONFIG_SELECT
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|SELECT_1
operator|||
name|i
operator|>
name|SELECT_5
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid selection algorithm %s, line ignored"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|proto_config
argument_list|(
name|PROTO_SELECT
argument_list|,
operator|(
name|LONG
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_STATSDIR
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|stats_config
argument_list|(
name|STATS_STATSDIR
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_STATISTICS
case|:
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
name|filegen
operator|=
name|filegen_get
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filegen
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no statistics named %s available"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"enabling filegen for %s statistics \"%s%s\"\n"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|,
name|filegen
operator|->
name|prefix
argument_list|,
name|filegen
operator|->
name|basename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filegen
operator|->
name|flag
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_FILEGEN
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no id for filegen command, line ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
name|filegen
operator|=
name|filegen_get
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filegen
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown filegen \"%s\" ignored"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * peerversion is (ab)used for filegen file (index) 			 * peerkey     is (ab)used for filegen type 			 * peerflags   is (ab)used for filegen flags 			 */
name|peerversion
operator|=
literal|0
expr_stmt|;
name|peerkey
operator|=
name|filegen
operator|->
name|type
expr_stmt|;
name|peerflags
operator|=
name|filegen
operator|->
name|flag
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|filegen_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_FGEN_FILE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s file requires argument"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
operator|++
name|i
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_TYPE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s type requires argument"
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|peerkey
operator|=
name|matchkey
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|,
name|fgen_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|peerkey
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"filegen %s unknown type \"%s\""
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
name|i
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONF_FGEN_FLAG_LINK
case|:
name|peerflags
operator||=
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_NOLINK
case|:
name|peerflags
operator|&=
operator|~
name|FGEN_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_ENABLE
case|:
name|peerflags
operator||=
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
case|case
name|CONF_FGEN_FLAG_DISABLE
case|:
name|peerflags
operator|&=
operator|~
name|FGEN_FLAG_ENABLED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
block|{
name|filegen_config
argument_list|(
name|filegen
argument_list|,
name|tokens
index|[
name|peerversion
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|peerkey
argument_list|,
operator|(
name|u_char
operator|)
name|peerflags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_SETVAR
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for setvar command - line ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_sys_var
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|,
name|RW
operator||
operator|(
operator|(
operator|(
operator|(
name|ntokens
operator|>
literal|2
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|tokens
index|[
literal|2
index|]
argument_list|,
literal|"default"
argument_list|)
operator|)
operator|)
condition|?
name|DEF
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_while

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Need name resolution 		 */
name|errflg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
if|if
condition|(
name|resolve_internal
condition|)
name|do_resolve_internal
argument_list|()
expr_stmt|;
else|else
block|{
endif|#
directive|endif
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no request key defined, peer name resolution not possible"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_resolver
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no resolver defined, peer name resolution not possible"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_keyfile
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no key file specified, peer name resolution not possible"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|errflg
condition|)
name|do_resolve
argument_list|(
name|resolver_name
argument_list|,
name|info_auth_keyid
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
else|else
name|abort_resolve
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
block|}
endif|#
directive|endif
block|}
end_if

begin_comment
unit|}
comment|/*  * gettokens - read a line and return tokens  */
end_comment

begin_function
unit|static
name|int
name|gettokens
parameter_list|(
name|fp
parameter_list|,
name|line
parameter_list|,
name|tokenlist
parameter_list|,
name|ntokens
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
modifier|*
name|tokenlist
decl_stmt|;
name|int
modifier|*
name|ntokens
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|eol
decl_stmt|;
specifier|register
name|int
name|ntok
decl_stmt|;
specifier|register
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find start of first token 	 */
name|again
label|:
while|while
condition|(
operator|(
name|cp
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|MAXLINE
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|*
name|ntokens
operator|=
literal|0
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* hack.  Is recognized as EOF */
block|}
comment|/* 	 * Now separate out the tokens 	 */
name|eol
operator|=
literal|0
expr_stmt|;
name|ntok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|eol
condition|)
block|{
name|tokenlist
index|[
name|ntok
operator|++
index|]
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|cp
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|eol
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ntok
operator|==
name|MAXTOKENS
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Return the match 	 */
operator|*
name|ntokens
operator|=
name|ntok
expr_stmt|;
name|ntok
operator|=
name|matchkey
argument_list|(
name|tokenlist
index|[
literal|0
index|]
argument_list|,
name|keywords
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|CONFIG_UNKNOWN
condition|)
goto|goto
name|again
goto|;
return|return
name|ntok
return|;
block|}
end_function

begin_comment
comment|/*  * matchkey - match a keyword to a list  */
end_comment

begin_function
specifier|static
name|int
name|matchkey
parameter_list|(
name|word
parameter_list|,
name|keys
parameter_list|)
specifier|register
name|char
modifier|*
name|word
decl_stmt|;
specifier|register
name|struct
name|keyword
modifier|*
name|keys
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|keys
operator|->
name|keytype
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configure: keyword \"%s\" unknown, line ignored"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
block|}
if|if
condition|(
name|STRSAME
argument_list|(
name|word
argument_list|,
name|keys
operator|->
name|text
argument_list|)
condition|)
return|return
name|keys
operator|->
name|keytype
return|;
name|keys
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * getnetnum - return a net number (this is crude, but careful)  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
name|num
parameter_list|,
name|addr
parameter_list|,
name|complain
parameter_list|)
name|char
modifier|*
name|num
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* will core dump on really stupid stuff */
name|U_LONG
name|netnum
decl_stmt|;
comment|/* XXX ELIMINATE replace with decodenetnum */
name|cp
operator|=
name|num
expr_stmt|;
name|netnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|buf
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
break|break;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|255
condition|)
break|break;
name|netnum
operator|<<=
literal|8
expr_stmt|;
name|netnum
operator|+=
name|temp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"getnetnum %s step %d buf %s temp %d netnum %d\n"
argument_list|,
name|num
argument_list|,
name|i
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
name|netnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"configure: \"%s\" not valid host number, line ignored"
argument_list|,
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"configure: \"%s\" not valid host number, line ignored\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* 	 * make up socket address.  Clear it out for neatness. 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|netnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"getnetnum given %s, got %s (%x)\n"
argument_list|,
name|num
argument_list|,
name|ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|netnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * catchchild - receive the resolver's exit status  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|catchchild
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* 	 * We only start up one child, and if we're here 	 * it should have already exited.  Hence the following 	 * shouldn't hang.  If it does, please tell me. 	 */
operator|(
name|void
operator|)
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * save_resolve - save configuration info into a file for later name resolution  */
end_comment

begin_function
specifier|static
name|void
name|save_resolve
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|,
name|version
parameter_list|,
name|minpoll
parameter_list|,
name|maxpoll
parameter_list|,
name|flags
parameter_list|,
name|keyid
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|version
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|U_LONG
name|keyid
decl_stmt|;
block|{
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|res_file
argument_list|,
name|RES_TEMPFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|fopen
argument_list|(
name|res_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open failed for %s: %m"
argument_list|,
name|res_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"resolving %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|res_fp
argument_list|,
literal|"%s %d %d %d %d %d %lu\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
name|minpoll
argument_list|,
name|maxpoll
argument_list|,
name|flags
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * abort_resolve - terminate the resolver stuff and delete the file  */
end_comment

begin_function
specifier|static
name|void
name|abort_resolve
parameter_list|()
block|{
comment|/* 	 * In an ideal world we would might reread the file and 	 * log the hosts which aren't getting configured.  Since 	 * this is too much work, however, just close and delete 	 * the temp file. 	 */
if|if
condition|(
name|res_fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|res_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * do_resolve - start up the resolver program  */
end_comment

begin_function
specifier|static
name|void
name|do_resolve
parameter_list|(
name|program
parameter_list|,
name|auth_keyid
parameter_list|,
name|keyfile
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|U_LONG
name|auth_keyid
decl_stmt|;
name|char
modifier|*
name|keyfile
decl_stmt|;
block|{
specifier|register
name|LONG
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
comment|/* 1 progname + 5 -d's + 1 -r + keyid + keyfile + tempfile + 1 */
name|char
modifier|*
name|argv
index|[
literal|15
index|]
decl_stmt|;
name|char
name|numbuf
index|[
literal|15
index|]
decl_stmt|;
comment|/* 	 * Clean environment so the resolver is consistant 	 */
specifier|static
name|char
modifier|*
name|resenv
index|[]
init|=
block|{
literal|"HOME=/"
block|,
literal|"SHELL=/bin/sh"
block|,
literal|"TERM=dumb"
block|,
literal|"USER=root"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
comment|/* belch */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error in do_resolve: res_fp == NULL"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
name|ap
operator|=
name|argv
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|program
expr_stmt|;
comment|/* 	 * xntpres [-d ...] -r key# keyfile tempfile 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|i
operator|=
name|debug
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|5
condition|)
name|i
operator|=
literal|5
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|ap
operator|++
operator|=
literal|"-d"
expr_stmt|;
endif|#
directive|endif
operator|*
name|ap
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|numbuf
argument_list|,
literal|"%lu"
argument_list|,
name|auth_keyid
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|numbuf
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|keyfile
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|res_file
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|catchchild
argument_list|)
expr_stmt|;
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		 * In child here, close up all descriptors and 		 * exec the resolver program.  Close the syslog() 		 * facility gracefully in case we must reopen it. 		 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NTP_POSIX_SOURCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_386BSD
argument_list|)
name|i
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
while|while
condition|(
name|i
operator|--
operator|>
literal|2
condition|)
else|#
directive|else
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execve
argument_list|(
name|program
argument_list|,
name|argv
argument_list|,
name|resenv
argument_list|)
expr_stmt|;
comment|/* 		 * If we got here, the exec screwed up.  Open the log file 		 * and print something so we don't die without complaint 		 */
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"xntpd"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"xntpd"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_DAEMON */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"exec of resolver %s failed!"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork() failed, can't start %s"
argument_list|,
name|program
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RESOLVE_INTERNAL
end_ifdef

begin_define
define|#
directive|define
name|KEY_TYPE_ASCII
value|3
end_define

begin_comment
comment|/*  * do_resolve_internal - start up the resolver function (not program)  */
end_comment

begin_function
specifier|static
name|void
name|do_resolve_internal
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|extern
name|U_LONG
name|req_keyid
decl_stmt|;
comment|/* request keyid */
specifier|extern
name|char
modifier|*
name|req_file
decl_stmt|;
comment|/* name of the file with configuration info */
specifier|extern
name|U_LONG
name|info_auth_keyid
decl_stmt|;
if|if
condition|(
name|res_fp
operator|==
name|NULL
condition|)
block|{
comment|/* belch */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error in do_resolve_internal: res_fp == NULL"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* we are done with this now */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|res_fp
argument_list|)
expr_stmt|;
name|res_fp
operator|=
name|NULL
expr_stmt|;
comment|/* find a keyid */
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
name|req_keyid
operator|=
literal|65535
expr_stmt|;
else|else
name|req_keyid
operator|=
name|info_auth_keyid
expr_stmt|;
comment|/* if doesn't exist, make up one at random */
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|req_keyid
argument_list|)
condition|)
block|{
name|char
name|rankey
index|[
literal|9
index|]
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
comment|/* generate random key */
name|GETTIMEOFDAY
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|srand
argument_list|(
name|now
operator|.
name|tv_sec
operator|*
name|now
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|rankey
index|[
name|i
index|]
operator|=
operator|(
name|rand
argument_list|()
operator|%
literal|255
operator|)
operator|+
literal|1
expr_stmt|;
name|rankey
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|authusekey
argument_list|(
name|req_keyid
argument_list|,
name|KEY_TYPE_ASCII
argument_list|,
name|rankey
argument_list|)
expr_stmt|;
block|}
comment|/* save keyid so we will accept config requests with it */
name|info_auth_keyid
operator|=
name|req_keyid
expr_stmt|;
name|req_file
operator|=
name|res_file
expr_stmt|;
comment|/* set up pointer to res file */
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|catchchild
argument_list|)
expr_stmt|;
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* this used to close everything      * I don't think this is necessary */
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|ntp_intres
argument_list|()
expr_stmt|;
comment|/*      * If we got here, the intres code screwed up.      * Print something so we don't die without complaint      */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"call to ntp_intres lost"
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork() failed, can't start ntp_intres"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort_resolve
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

