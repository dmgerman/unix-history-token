begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_heath - clock driver for Heath GC-1000 Most Accurate Clock  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HEATH
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * This driver supports the Heath GC-1000 Most Accurate Clock, with  * RS232C Output Accessory. This is a WWV/WWVH receiver somewhat less  * robust than other supported receivers. Its claimed accuracy is 100 ms  * when actually synchronized to the broadcast signal, but this doesn't  * happen even most of the time, due to propagation conditions, ambient  * noise sources, etc. When not synchronized, the accuracy is at the  * whim of the internal clock oscillator, which can wander into the  * sunset without warning. Since the indicated precision is 100 ms,  * expect a host synchronized only to this thing to wander to and fro,  * occasionally being rudely stepped when the offset exceeds the default  * CLOCK_MAX of 128 ms.  *  * The internal DIPswitches should be set to operate at 1200 baud in  * MANUAL mode and the current year. The external DIPswitches should be  * set to GMT and 24-hour format, or to the host local time zone (with  * DST) and 12-hour format. It is very important that the year be  * set correctly in the DIPswitches. Otherwise, the day of year will be  * incorrect after 28 April of a normal or leap year.  In 12-hour mode  * with DST selected the clock will be incorrect by an hour for an  * indeterminate amount of time between 0000Z and 0200 on the day DST  * changes.  *  * In MANUAL mode the clock responds to a rising edge of the request to  * send (RTS) modem control line by sending the timecode. Therefore, it  * is necessary that the operating system implement the TIOCMBIC and  * TIOCMBIS ioctl system calls and TIOCM_RTS control bit. Present  * restrictions require the use of a POSIX-compatible programming  * interface, although other interfaces may work as well.  *  * A simple hardware modification to the clock can be made which  * prevents the clock hearing the request to send (RTS) if the HI SPEC  * lamp is out. Route the HISPEC signal to the tone decoder board pin  * 19, from the display, pin 19. Isolate pin 19 of the decoder board  * first, but maintain connection with pin 10. Also isolate pin 38 of  * the CPU on the tone board, and use half an added 7400 to gate the  * original signal to pin 38 with that from pin 19.  *  * The clock message consists of 23 ASCII printing characters in the  * following format:  *  * hh:mm:ss.f AM  dd/mm/yr<cr>  *  *	hh:mm:ss.f = hours, minutes, seconds  *	f = deciseconds ('?' when out of spec)  *	AM/PM/bb = blank in 24-hour mode  *	dd/mm/yr = day, month, year  *  * The alarm condition is indicated by '?', rather than a digit, at f.  * Note that 0?:??:??.? is displayed before synchronization is first  * established and hh:mm:ss.? once synchronization is established and  * then lost again for about a day.  *  * Fudge Factors  *  * A fudge time1 value of .04 s appears to center the clock offset  * residuals. The fudge time2 parameter is the local time offset east of  * Greenwich, which depends on DST. Sorry about that, but the clock  * gives no hint on what the DIPswitches say.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/heath%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B1200
end_define

begin_comment
comment|/* uart speed (1200 baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-4)
end_define

begin_comment
comment|/* precision assumed (about 100 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"WWV\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"Heath GC-1000 Most Accurate Clock"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|NSAMPLES
value|3
end_define

begin_comment
comment|/* stages of median filter */
end_comment

begin_define
define|#
directive|define
name|LENHEATH
value|23
end_define

begin_comment
comment|/* min timecode length */
end_comment

begin_comment
comment|/*  * Imported from ntp_timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time (s) */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Tables to compute the ddd of year form icky dd/mm timecode. Viva la  * leap.  */
end_comment

begin_expr_stmt
specifier|static
name|day1tab
index|[]
operator|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|day2tab
index|[]
operator|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|heathunit
block|{
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
name|l_fp
name|tstamp
decl_stmt|;
comment|/* timestamp of last poll */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|heath_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|heath_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|heath_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|heath_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_heath
init|=
block|{
name|heath_start
block|,
comment|/* start up driver */
name|heath_shutdown
block|,
comment|/* shut down driver */
name|heath_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old heath_control) */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old heath_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * heath_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|heath_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Open serial port 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|heathunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|heathunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|heath_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * heath_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|heath_shutdown
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * heath_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|heath_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|trtmp
decl_stmt|;
name|int
name|month
decl_stmt|,
name|day
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|dsec
decl_stmt|,
name|a
index|[
literal|5
index|]
decl_stmt|;
comment|/* 	 * Initialize pointers and read the timecode and timestamp 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|trtmp
argument_list|)
expr_stmt|;
comment|/* 	 * We get a buffer and timestamp for each<cr>; however, we use 	 * the timestamp captured at the RTS modem control line toggle 	 * on the assumption that's what the radio bases the timecode 	 * on. Apparently, the radio takes about a second to make up its 	 * mind to send a timecode, so the receive timestamp is 	 * worthless. 	 */
name|pp
operator|->
name|lastrec
operator|=
name|up
operator|->
name|tstamp
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"heath: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We get down to business, check the timecode format and decode 	 * its contents. If the timecode has invalid length or is not in 	 * proper format, we declare bad format and exit. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|<
name|LENHEATH
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Timecode format: "hh:mm:ss.f AM  mm/dd/yy" 	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|lastcode
argument_list|,
literal|"%2d:%2d:%2d.%c%5c%2d/%2d/%2d"
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|dsec
argument_list|,
name|a
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If AM or PM is received, assume the clock is displaying local 	 * time. First, convert to 24-hour format, then add the local 	 * time correction (in hours east of Greenwich) from 	 * fudgetime2. 	 */
switch|switch
condition|(
name|a
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'P'
case|:
if|if
condition|(
name|pp
operator|->
name|hour
operator|<
literal|12
condition|)
name|pp
operator|->
name|hour
operator|+=
literal|12
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|pp
operator|->
name|hour
operator|==
literal|12
condition|)
name|pp
operator|->
name|hour
operator|-=
literal|12
expr_stmt|;
break|break;
block|}
name|i
operator|=
operator|(
name|int
operator|)
name|pp
operator|->
name|hour
operator|-
operator|(
name|int
operator|)
name|pp
operator|->
name|fudgetime2
operator|.
name|l_ui
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
literal|24
expr_stmt|;
name|pp
operator|->
name|hour
operator|=
name|i
operator|%
literal|24
expr_stmt|;
comment|/* 	 * We determine the day of the year from the DIPswitches. This 	 * should be fixed, since somebody might forget to set them. 	 * Someday this hazard will be fixed by a fiendish scheme that 	 * looks at the timecode and year the radio shows, then computes 	 * the residue of the seconds mod the seconds in a leap cycle. 	 * If in the third year of that cycle and the third and later 	 * months of that year, add one to the day. Then, correct the 	 * timecode accordingly. Icky pooh. This bit of nonsense could 	 * be avoided if the engineers had been required to write a 	 * device driver before finalizing the timecode format. 	 * 	 * Yes, I know this code incorrectly thinks that 2000 is a leap 	 * year; but, the latest year that can be set by the DIPswitches 	 * is 1997 anyay. Life is short. 	 */
if|if
condition|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pp
operator|->
name|year
operator|%
literal|4
condition|)
block|{
if|if
condition|(
name|day
operator|>
name|day1tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day1tab
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|day
operator|>
name|day2tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day2tab
index|[
name|i
index|]
expr_stmt|;
block|}
name|pp
operator|->
name|day
operator|=
name|day
expr_stmt|;
comment|/* 	 * Determine synchronization and last update 	 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|dsec
argument_list|)
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|leap
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
name|pp
operator|->
name|msec
operator|=
operator|(
name|dsec
operator|-
literal|'0'
operator|)
operator|*
literal|100
expr_stmt|;
block|}
comment|/* 	 * Process the new sample in the median filter and determine the 	 * reference clock offset and dispersion. We use lastrec as both 	 * the reference time and receive time, in order to avoid being 	 * cute, like setting the reference time later than the receive 	 * time, which may cause a paranoid protocol module to chuck out 	 * the data.  	 */
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|,
name|NSAMPLES
argument_list|,
name|NSAMPLES
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_receive
argument_list|(
name|peer
argument_list|,
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|dispersion
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
name|pp
operator|->
name|leap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * heath_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|heath_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|heathunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|bits
init|=
name|TIOCM_RTS
decl_stmt|;
comment|/* 	 * At each poll we check for timeout and toggle the RTS modem 	 * control line, then take a timestamp. Presumably, this is the 	 * event the radio captures to generate the timecode. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|heathunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
comment|/* 	 * We toggle the RTS modem control lead to kick a timecode loose 	 * from the radio. This code works only for POSIX and SYSV 	 * interfaces. With bsd you are on your own. We take a timestamp 	 * between the up and down edges to lengthen the pulse, which 	 * should be about 50 usec on a Sun IPC. With hotshot CPUs, the 	 * pulse might get too short. Later. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bits
argument_list|)
operator|<
literal|0
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
name|gettstamp
argument_list|(
operator|&
name|up
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

