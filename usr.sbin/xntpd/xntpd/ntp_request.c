begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_request.c,v 3.1 1993/07/06 01:11:26 jbj Exp  * ntp_request.c - respond to information requests  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_control.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Structure to hold request procedure information  */
end_comment

begin_define
define|#
directive|define
name|NOAUTH
value|0
end_define

begin_define
define|#
directive|define
name|AUTH
value|1
end_define

begin_define
define|#
directive|define
name|NO_REQUEST
value|(-1)
end_define

begin_struct
struct|struct
name|req_proc
block|{
name|short
name|request_code
decl_stmt|;
comment|/* defined request code */
name|short
name|needs_auth
decl_stmt|;
comment|/* true when authentication needed */
name|short
name|sizeofitem
decl_stmt|;
comment|/* size of request data item */
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
comment|/* routine to handle request */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Universal request codes  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|req_proc
name|univ_codes
index|[]
init|=
block|{
block|{
name|NO_REQUEST
block|,
name|NOAUTH
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|req_ack
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prepare_pkt
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|more_pkt
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_pkt
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_list
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_list_sum
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peer_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sys_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sys_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mem_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|io_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|timer_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_conf
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_unconf
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_sys_flag
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clr_sys_flag
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setclr_flags
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_monitor
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_nomonitor
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_restrict
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_resaddflags
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ressubflags
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_unrestrict
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_restrict
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mon_getlist
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_peer
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_key_reread
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_dirty_hack
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dont_dirty_hack
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trust_key
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|untrust_key
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_trustkey
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_auth_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_auth_stats
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|req_get_traps
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|req_set_trap
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|req_clr_trap
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_setclr_trap
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_request_keyid
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_control_keyid
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_ctl_stats
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_leap_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|get_clock_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_clock_fudge
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_maxskew
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_precision
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_select_code
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|get_clkbug_info
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|interface
operator|*
operator|,
expr|struct
name|req_pkt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

begin_comment
comment|/*  * Xntpd request codes  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|req_proc
name|xntp_codes
index|[]
init|=
block|{
block|{
name|REQ_PEER_LIST
block|,
name|NOAUTH
block|,
literal|0
block|,
name|peer_list
block|}
block|,
block|{
name|REQ_PEER_LIST_SUM
block|,
name|NOAUTH
block|,
literal|0
block|,
name|peer_list_sum
block|}
block|,
block|{
name|REQ_PEER_INFO
block|,
name|NOAUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_peer_list
argument_list|)
block|,
name|peer_info
block|}
block|,
block|{
name|REQ_PEER_STATS
block|,
name|NOAUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_peer_list
argument_list|)
block|,
name|peer_stats
block|}
block|,
block|{
name|REQ_SYS_INFO
block|,
name|NOAUTH
block|,
literal|0
block|,
name|sys_info
block|}
block|,
block|{
name|REQ_SYS_STATS
block|,
name|NOAUTH
block|,
literal|0
block|,
name|sys_stats
block|}
block|,
block|{
name|REQ_IO_STATS
block|,
name|NOAUTH
block|,
literal|0
block|,
name|io_stats
block|}
block|,
block|{
name|REQ_MEM_STATS
block|,
name|NOAUTH
block|,
literal|0
block|,
name|mem_stats
block|}
block|,
block|{
name|REQ_LOOP_INFO
block|,
name|NOAUTH
block|,
literal|0
block|,
name|loop_info
block|}
block|,
block|{
name|REQ_TIMER_STATS
block|,
name|NOAUTH
block|,
literal|0
block|,
name|timer_stats
block|}
block|,
block|{
name|REQ_CONFIG
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_peer
argument_list|)
block|,
name|do_conf
block|}
block|,
block|{
name|REQ_UNCONFIG
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_unpeer
argument_list|)
block|,
name|do_unconf
block|}
block|,
block|{
name|REQ_SET_SYS_FLAG
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_sys_flags
argument_list|)
block|,
name|set_sys_flag
block|}
block|,
block|{
name|REQ_CLR_SYS_FLAG
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_sys_flags
argument_list|)
block|,
name|clr_sys_flag
block|}
block|,
block|{
name|REQ_MONITOR
block|,
name|AUTH
block|,
literal|0
block|,
name|do_monitor
block|}
block|,
block|{
name|REQ_NOMONITOR
block|,
name|AUTH
block|,
literal|0
block|,
name|do_nomonitor
block|}
block|,
block|{
name|REQ_GET_RESTRICT
block|,
name|NOAUTH
block|,
literal|0
block|,
name|list_restrict
block|}
block|,
block|{
name|REQ_RESADDFLAGS
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_restrict
argument_list|)
block|,
name|do_resaddflags
block|}
block|,
block|{
name|REQ_RESSUBFLAGS
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_restrict
argument_list|)
block|,
name|do_ressubflags
block|}
block|,
block|{
name|REQ_UNRESTRICT
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_restrict
argument_list|)
block|,
name|do_unrestrict
block|}
block|,
block|{
name|REQ_MON_GETLIST
block|,
name|NOAUTH
block|,
literal|0
block|,
name|mon_getlist
block|}
block|,
block|{
name|REQ_RESET_STATS
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|reset_flags
argument_list|)
block|,
name|reset_stats
block|}
block|,
block|{
name|REQ_RESET_PEER
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_unpeer
argument_list|)
block|,
name|reset_peer
block|}
block|,
block|{
name|REQ_REREAD_KEYS
block|,
name|AUTH
block|,
literal|0
block|,
name|do_key_reread
block|}
block|,
block|{
name|REQ_DO_DIRTY_HACK
block|,
name|AUTH
block|,
literal|0
block|,
name|do_dirty_hack
block|}
block|,
block|{
name|REQ_DONT_DIRTY_HACK
block|,
name|AUTH
block|,
literal|0
block|,
name|dont_dirty_hack
block|}
block|,
block|{
name|REQ_TRUSTKEY
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|trust_key
block|}
block|,
block|{
name|REQ_UNTRUSTKEY
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|untrust_key
block|}
block|,
block|{
name|REQ_AUTHINFO
block|,
name|NOAUTH
block|,
literal|0
block|,
name|get_auth_info
block|}
block|,
block|{
name|REQ_TRAPS
block|,
name|NOAUTH
block|,
literal|0
block|,
name|req_get_traps
block|}
block|,
block|{
name|REQ_ADD_TRAP
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_trap
argument_list|)
block|,
name|req_set_trap
block|}
block|,
block|{
name|REQ_CLR_TRAP
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_trap
argument_list|)
block|,
name|req_clr_trap
block|}
block|,
block|{
name|REQ_REQUEST_KEY
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|set_request_keyid
block|}
block|,
block|{
name|REQ_CONTROL_KEY
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|set_control_keyid
block|}
block|,
block|{
name|REQ_GET_CTLSTATS
block|,
name|NOAUTH
block|,
literal|0
block|,
name|get_ctl_stats
block|}
block|,
block|{
name|REQ_GET_LEAPINFO
block|,
name|NOAUTH
block|,
literal|0
block|,
name|get_leap_info
block|}
block|,
block|{
name|REQ_SET_MAXSKEW
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|u_fp
argument_list|)
block|,
name|set_maxskew
block|}
block|,
block|{
name|REQ_SET_PRECISION
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
block|,
name|set_precision
block|}
block|,
block|{
name|REQ_SET_SELECT_CODE
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|set_select_code
block|}
block|,
ifdef|#
directive|ifdef
name|REFCLOCK
block|{
name|REQ_GET_CLOCKINFO
block|,
name|NOAUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|get_clock_info
block|}
block|,
block|{
name|REQ_SET_CLKFUDGE
block|,
name|AUTH
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|conf_fudge
argument_list|)
block|,
name|set_clock_fudge
block|}
block|,
block|{
name|REQ_GET_CLKBUGINFO
block|,
name|NOAUTH
block|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
block|,
name|get_clkbug_info
block|}
block|,
endif|#
directive|endif
block|{
name|NO_REQUEST
block|,
name|NOAUTH
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Authentication keyid used to authenticate requests.  Zero means we  * don't allow writing anything.  */
end_comment

begin_decl_stmt
name|U_LONG
name|info_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistic counters to keep track of requests and responses.  */
end_comment

begin_decl_stmt
name|U_LONG
name|numrequests
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of requests we've received */
end_comment

begin_decl_stmt
name|U_LONG
name|numresppkts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of resp packets sent with data */
end_comment

begin_decl_stmt
name|U_LONG
name|errorcounter
index|[
name|INFO_ERR_AUTH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lazy way to count errors, indexed */
end_comment

begin_comment
comment|/* by the error code */
end_comment

begin_comment
comment|/*  * Imported from the I/O module  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the main routines  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A hack.  To keep the authentication module clear of xntp-ism's, we  * include a time reset variable for its stats here.  */
end_comment

begin_decl_stmt
specifier|static
name|U_LONG
name|auth_timereset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Response packet used by these routines.  Also some state information  * so that we can handle packet formatting within a common set of  * subroutines.  Note we try to enter data in place whenever possible,  * but the need to set the more bit correctly means we occasionally  * use the extra buffer and copy.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|resp_pkt
name|rpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|seqno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nitems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itemsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|databytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|exbuf
index|[
name|RESP_DATA_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usingexbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|toaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|frominter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_request - initialize request data  */
end_comment

begin_function
name|void
name|init_request
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|numrequests
operator|=
literal|0
expr_stmt|;
name|numresppkts
operator|=
literal|0
expr_stmt|;
name|auth_timereset
operator|=
literal|0
expr_stmt|;
name|info_auth_keyid
operator|=
literal|0
expr_stmt|;
comment|/* by default, can't do this */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|errorcounter
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|errorcounter
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|errorcounter
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * req_ack - acknowledge request with no data  */
end_comment

begin_function
specifier|static
name|void
name|req_ack
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|,
name|errcode
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
name|int
name|errcode
decl_stmt|;
block|{
comment|/* 	 * fill in the fields 	 */
name|rpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
name|RESP_BIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|implementation
operator|=
name|inpkt
operator|->
name|implementation
expr_stmt|;
name|rpkt
operator|.
name|request
operator|=
name|inpkt
operator|->
name|request
expr_stmt|;
name|rpkt
operator|.
name|err_nitems
operator|=
name|ERR_NITEMS
argument_list|(
name|errcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * send packet and bump counters 	 */
name|sendpkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|RESP_HEADER_SIZE
argument_list|)
expr_stmt|;
name|errorcounter
index|[
name|errcode
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * prepare_pkt - prepare response packet for transmission, return pointer  *		 to storage for data item.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|prepare_pkt
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|pkt
parameter_list|,
name|structsize
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|pkt
decl_stmt|;
name|u_int
name|structsize
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"request: preparing pkt\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Fill in the implementation, reqest and itemsize fields 	 * since these won't change. 	 */
name|rpkt
operator|.
name|implementation
operator|=
name|pkt
operator|->
name|implementation
expr_stmt|;
name|rpkt
operator|.
name|request
operator|=
name|pkt
operator|->
name|request
expr_stmt|;
name|rpkt
operator|.
name|mbz_itemsize
operator|=
name|MBZ_ITEMSIZE
argument_list|(
name|structsize
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the static data needed to carry on. 	 */
name|toaddr
operator|=
name|srcadr
expr_stmt|;
name|frominter
operator|=
name|inter
expr_stmt|;
name|seqno
operator|=
literal|0
expr_stmt|;
name|nitems
operator|=
literal|0
expr_stmt|;
name|itemsize
operator|=
name|structsize
expr_stmt|;
name|databytes
operator|=
literal|0
expr_stmt|;
name|usingexbuf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * return the beginning of the packet buffer. 	 */
return|return
operator|&
name|rpkt
operator|.
name|data
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * more_pkt - return a data pointer for a new item.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|more_pkt
parameter_list|()
block|{
comment|/* 	 * If we were using the extra buffer, send the packet. 	 */
if|if
condition|(
name|usingexbuf
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"request: sending pkt\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
name|RESP_BIT
argument_list|,
name|MORE_BIT
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|0
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|err_nitems
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|nitems
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|toaddr
argument_list|,
name|frominter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|RESP_HEADER_SIZE
operator|+
name|databytes
argument_list|)
expr_stmt|;
name|numresppkts
operator|++
expr_stmt|;
comment|/* 		 * Copy data out of exbuf into the packet. 		 */
name|memmove
argument_list|(
operator|&
name|rpkt
operator|.
name|data
index|[
literal|0
index|]
argument_list|,
name|exbuf
argument_list|,
name|itemsize
argument_list|)
expr_stmt|;
name|seqno
operator|++
expr_stmt|;
name|databytes
operator|=
literal|0
expr_stmt|;
name|nitems
operator|=
literal|0
expr_stmt|;
name|usingexbuf
operator|=
literal|0
expr_stmt|;
block|}
name|databytes
operator|+=
name|itemsize
expr_stmt|;
name|nitems
operator|++
expr_stmt|;
if|if
condition|(
name|databytes
operator|+
name|itemsize
operator|<=
name|RESP_DATA_SIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"request: giving him more data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * More room in packet.  Give him the 		 * next address. 		 */
return|return
operator|&
name|rpkt
operator|.
name|data
index|[
name|databytes
index|]
return|;
block|}
else|else
block|{
comment|/* 		 * No room in packet.  Give him the extra 		 * buffer unless this was the last in the sequence. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"request: into extra buffer\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|seqno
operator|==
name|MAXSEQ
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
else|else
block|{
name|usingexbuf
operator|=
literal|1
expr_stmt|;
return|return
name|exbuf
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * flush_pkt - we're done, return remaining information.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pkt
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"request: flushing packet, %d items\n"
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Must send the last packet.  If nothing in here and nothing 	 * has been sent, send an error saying no data to be found. 	 */
if|if
condition|(
name|seqno
operator|==
literal|0
operator|&&
name|nitems
operator|==
literal|0
condition|)
name|req_ack
argument_list|(
name|toaddr
argument_list|,
name|frominter
argument_list|,
operator|(
expr|struct
name|req_pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
else|else
block|{
name|rpkt
operator|.
name|rm_vn_mode
operator|=
name|RM_VN_MODE
argument_list|(
name|RESP_BIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|auth_seq
operator|=
name|AUTH_SEQ
argument_list|(
literal|0
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|rpkt
operator|.
name|err_nitems
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|nitems
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
name|toaddr
argument_list|,
name|frominter
argument_list|,
operator|(
expr|struct
name|pkt
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|RESP_HEADER_SIZE
operator|+
name|databytes
argument_list|)
expr_stmt|;
name|numresppkts
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process_private - process private mode (7) packets  */
end_comment

begin_function
name|void
name|process_private
parameter_list|(
name|rbufp
parameter_list|,
name|mod_okay
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
name|int
name|mod_okay
decl_stmt|;
block|{
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_proc
modifier|*
name|proc
decl_stmt|;
comment|/* 	 * Initialize pointers, for convenience 	 */
name|inpkt
operator|=
operator|(
expr|struct
name|req_pkt
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|srcadr
operator|=
operator|&
name|rbufp
operator|->
name|recv_srcadr
expr_stmt|;
name|inter
operator|=
name|rbufp
operator|->
name|dstadr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"prepare_pkt: impl %d req %d\n"
argument_list|,
name|inpkt
operator|->
name|implementation
argument_list|,
name|inpkt
operator|->
name|request
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Do some sanity checks on the packet.  Return a format 	 * error if it fails. 	 */
if|if
condition|(
name|ISRESPONSE
argument_list|(
name|inpkt
operator|->
name|rm_vn_mode
argument_list|)
operator|||
name|ISMORE
argument_list|(
name|inpkt
operator|->
name|rm_vn_mode
argument_list|)
operator|||
name|INFO_VERSION
argument_list|(
name|inpkt
operator|->
name|rm_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|||
name|INFO_VERSION
argument_list|(
name|inpkt
operator|->
name|rm_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
operator|||
name|INFO_SEQ
argument_list|(
name|inpkt
operator|->
name|auth_seq
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_ERR
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|!=
literal|0
operator|||
name|INFO_MBZ
argument_list|(
name|inpkt
operator|->
name|mbz_itemsize
argument_list|)
operator|!=
literal|0
operator|||
name|rbufp
operator|->
name|recv_length
operator|>
name|REQ_LEN_MAC
operator|||
name|rbufp
operator|->
name|recv_length
operator|<
name|REQ_LEN_NOMAC
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the appropriate procedure list to search. 	 */
if|if
condition|(
name|inpkt
operator|->
name|implementation
operator|==
name|IMPL_UNIV
condition|)
name|proc
operator|=
name|univ_codes
expr_stmt|;
elseif|else
if|if
condition|(
name|inpkt
operator|->
name|implementation
operator|==
name|IMPL_XNTPD
condition|)
name|proc
operator|=
name|xntp_codes
expr_stmt|;
else|else
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_IMPL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Search the list for the request codes.  If it isn't one 	 * we know, return an error. 	 */
while|while
condition|(
name|proc
operator|->
name|request_code
operator|!=
name|NO_REQUEST
condition|)
block|{
if|if
condition|(
name|proc
operator|->
name|request_code
operator|==
operator|(
name|short
operator|)
name|inpkt
operator|->
name|request
condition|)
break|break;
name|proc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|->
name|request_code
operator|==
name|NO_REQUEST
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_REQ
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"found request in tables\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we need to authenticate, do so.  Note that an 	 * authenticatable packet must include a mac field, must 	 * have used key info_auth_keyid and must have included 	 * a time stamp in the appropriate field.  The time stamp 	 * must be within INFO_TS_MAXSKEW of the receive 	 * time stamp. 	 */
if|if
condition|(
name|proc
operator|->
name|needs_auth
condition|)
block|{
specifier|register
name|U_LONG
name|tmp_ui
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_uf
decl_stmt|;
comment|/* 		 * If this guy is restricted from doing this, don't let him 		 * If wrong key was used, or packet doesn't have mac, return. 		 */
if|if
condition|(
operator|!
name|INFO_IS_AUTH
argument_list|(
name|inpkt
operator|->
name|auth_seq
argument_list|)
operator|||
name|info_auth_keyid
operator|==
literal|0
operator|||
name|ntohl
argument_list|(
name|inpkt
operator|->
name|keyid
argument_list|)
operator|!=
name|info_auth_keyid
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"failed auth %d info_auth_keyid %u pkt keyid %u\n"
argument_list|,
name|INFO_IS_AUTH
argument_list|(
name|inpkt
operator|->
name|auth_seq
argument_list|)
argument_list|,
name|info_auth_keyid
argument_list|,
name|ntohl
argument_list|(
name|inpkt
operator|->
name|keyid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_AUTH
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>
name|REQ_LEN_MAC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"failed pkt length pkt %d req %d too long\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
name|REQ_LEN_MAC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mod_okay
operator|||
operator|!
name|authhavekey
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"failed auth mod_okay %d\n"
argument_list|,
name|mod_okay
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_AUTH
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * calculate absolute time difference between xmit time stamp 		 * and receive time stamp.  If too large, too bad. 		 */
name|tmp_ui
operator|=
name|ntohl
argument_list|(
name|inpkt
operator|->
name|tstamp
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|tmp_uf
operator|=
name|ntohl
argument_list|(
name|inpkt
operator|->
name|tstamp
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
condition|)
name|M_NEG
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISHIS
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|,
name|INFO_TS_MAXSKEW_UI
argument_list|,
name|INFO_TS_MAXSKEW_UF
argument_list|)
condition|)
block|{
comment|/* 			 * He's a loser.  Tell him. 			 */
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_AUTH
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * So far so good.  See if decryption works out okay. 		 */
if|if
condition|(
operator|!
name|authdecrypt
argument_list|(
name|info_auth_keyid
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|inpkt
argument_list|,
name|REQ_LEN_NOMAC
argument_list|)
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_AUTH
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If we need data, check to see if we have some.  If we 	 * don't, check to see that there is none (picky, picky). 	 */
if|if
condition|(
name|INFO_ITEMSIZE
argument_list|(
name|inpkt
operator|->
name|mbz_itemsize
argument_list|)
operator|!=
name|proc
operator|->
name|sizeofitem
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|proc
operator|->
name|sizeofitem
operator|!=
literal|0
condition|)
if|if
condition|(
name|proc
operator|->
name|sizeofitem
operator|*
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|inpkt
operator|->
name|data
argument_list|)
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"process_private: all okay, into handler\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Packet is okay.  Call the handler to send him data. 	 */
call|(
name|proc
operator|->
name|handler
call|)
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * peer_list - send a list of the peers  */
end_comment

begin_function
specifier|static
name|void
name|peer_list
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_peer_list
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|peer_hash
index|[]
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|info_peer_list
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_peer_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
operator|&&
name|ip
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
name|peer_hash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|pp
operator|!=
literal|0
operator|&&
name|ip
operator|!=
literal|0
condition|)
block|{
name|ip
operator|->
name|address
operator|=
name|pp
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ip
operator|->
name|port
operator|=
name|pp
operator|->
name|srcadr
operator|.
name|sin_port
expr_stmt|;
name|ip
operator|->
name|hmode
operator|=
name|pp
operator|->
name|hmode
expr_stmt|;
name|ip
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_CONFIG
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|sys_peer
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SYSPEER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|candidate
operator|!=
literal|0
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SEL_CANDIDATE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|select
operator|!=
literal|0
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SHORTLIST
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|info_peer_list
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|next
expr_stmt|;
block|}
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * peer_list_sum - return extended peer list  */
end_comment

begin_function
specifier|static
name|void
name|peer_list_sum
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_peer_summary
modifier|*
name|ips
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|peer_hash
index|[]
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"wants peer list summary\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ips
operator|=
operator|(
expr|struct
name|info_peer_summary
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_peer_summary
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
operator|&&
name|ips
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
name|peer_hash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|pp
operator|!=
literal|0
operator|&&
name|ips
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"sum: got one\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pp
operator|->
name|dstadr
operator|==
name|any_interface
condition|)
name|ips
operator|->
name|dstadr
operator|=
literal|0
expr_stmt|;
else|else
name|ips
operator|->
name|dstadr
operator|=
name|pp
operator|->
name|dstadr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ips
operator|->
name|srcadr
operator|=
name|pp
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ips
operator|->
name|srcport
operator|=
name|pp
operator|->
name|srcadr
operator|.
name|sin_port
expr_stmt|;
name|ips
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
name|ips
operator|->
name|hpoll
operator|=
name|pp
operator|->
name|hpoll
expr_stmt|;
name|ips
operator|->
name|ppoll
operator|=
name|pp
operator|->
name|ppoll
expr_stmt|;
name|ips
operator|->
name|reach
operator|=
name|pp
operator|->
name|reach
expr_stmt|;
name|ips
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|sys_peer
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_SYSPEER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_CONFIG
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_REFCLOCK
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_PREFER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|candidate
operator|!=
literal|0
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_SEL_CANDIDATE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|select
operator|!=
literal|0
condition|)
name|ips
operator|->
name|flags
operator||=
name|INFO_FLAG_SHORTLIST
expr_stmt|;
name|ips
operator|->
name|hmode
operator|=
name|pp
operator|->
name|hmode
expr_stmt|;
name|ips
operator|->
name|delay
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|delay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
operator|&
name|ips
operator|->
name|offset
argument_list|)
expr_stmt|;
name|ips
operator|->
name|dispersion
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|next
expr_stmt|;
name|ips
operator|=
operator|(
expr|struct
name|info_peer_summary
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * peer_info - send information for one or more peers  */
end_comment

begin_function
specifier|static
name|void
name|peer_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_peer_list
modifier|*
name|ipl
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|info_peer
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|ipl
operator|=
operator|(
expr|struct
name|info_peer_list
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|info_peer
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_peer
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
operator|&&
name|ip
operator|!=
literal|0
condition|)
block|{
name|addr
operator|.
name|sin_port
operator|=
name|ipl
operator|->
name|port
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ipl
operator|->
name|address
expr_stmt|;
name|ipl
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ip
operator|->
name|dstadr
operator|=
name|NSRCADR
argument_list|(
operator|&
name|pp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
expr_stmt|;
name|ip
operator|->
name|srcadr
operator|=
name|NSRCADR
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|ip
operator|->
name|srcport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|ip
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|sys_peer
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SYSPEER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_CONFIG
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_REFCLOCK
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_PREFER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|candidate
operator|!=
literal|0
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SEL_CANDIDATE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|select
operator|!=
literal|0
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SHORTLIST
expr_stmt|;
name|ip
operator|->
name|leap
operator|=
name|pp
operator|->
name|leap
expr_stmt|;
name|ip
operator|->
name|hmode
operator|=
name|pp
operator|->
name|hmode
expr_stmt|;
name|ip
operator|->
name|keyid
operator|=
name|pp
operator|->
name|keyid
expr_stmt|;
name|ip
operator|->
name|pkeyid
operator|=
name|pp
operator|->
name|pkeyid
expr_stmt|;
name|ip
operator|->
name|stratum
operator|=
name|pp
operator|->
name|stratum
expr_stmt|;
name|ip
operator|->
name|ppoll
operator|=
name|pp
operator|->
name|ppoll
expr_stmt|;
name|ip
operator|->
name|hpoll
operator|=
name|pp
operator|->
name|hpoll
expr_stmt|;
name|ip
operator|->
name|precision
operator|=
name|pp
operator|->
name|precision
expr_stmt|;
name|ip
operator|->
name|version
operator|=
name|pp
operator|->
name|version
expr_stmt|;
name|ip
operator|->
name|valid
operator|=
name|pp
operator|->
name|valid
expr_stmt|;
name|ip
operator|->
name|reach
operator|=
name|pp
operator|->
name|reach
expr_stmt|;
name|ip
operator|->
name|unreach
operator|=
name|pp
operator|->
name|unreach
expr_stmt|;
name|ip
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|associd
operator|=
name|htons
argument_list|(
name|pp
operator|->
name|associd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|rootdelay
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|ip
operator|->
name|rootdispersion
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|rootdispersion
argument_list|)
expr_stmt|;
name|ip
operator|->
name|refid
operator|=
name|pp
operator|->
name|refid
expr_stmt|;
name|ip
operator|->
name|timer
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|event_timer
operator|.
name|event_time
operator|-
name|current_time
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|reftime
argument_list|,
operator|&
name|ip
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|org
argument_list|,
operator|&
name|ip
operator|->
name|org
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|rec
argument_list|,
operator|&
name|ip
operator|->
name|rec
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|xmt
argument_list|,
operator|&
name|ip
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|j
operator|=
name|pp
operator|->
name|filter_nextpt
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
name|NTP_SHIFT
operator|-
literal|1
expr_stmt|;
name|ip
operator|->
name|filtdelay
index|[
name|i
index|]
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|filter_delay
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|filter_offset
index|[
name|j
index|]
argument_list|,
operator|&
name|ip
operator|->
name|filtoffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ip
operator|->
name|order
index|[
name|i
index|]
operator|=
operator|(
name|pp
operator|->
name|filter_nextpt
operator|+
name|NTP_SHIFT
operator|-
literal|1
operator|)
operator|-
name|pp
operator|->
name|filter_order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|order
index|[
name|i
index|]
operator|>=
name|NTP_SHIFT
condition|)
name|ip
operator|->
name|order
index|[
name|i
index|]
operator|-=
name|NTP_SHIFT
expr_stmt|;
block|}
name|ip
operator|->
name|delay
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|delay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
operator|&
name|ip
operator|->
name|offset
argument_list|)
expr_stmt|;
name|ip
operator|->
name|dispersion
operator|=
name|HTONS_FP
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|bdelay
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|estbdelay
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|estbdelay
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|info_peer
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * peer_stats - send statistics for one or more peers  */
end_comment

begin_function
specifier|static
name|void
name|peer_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_peer_list
modifier|*
name|ipl
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|info_peer_stats
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|ipl
operator|=
operator|(
expr|struct
name|info_peer_list
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|info_peer_stats
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_peer_stats
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
operator|&&
name|ip
operator|!=
literal|0
condition|)
block|{
name|addr
operator|.
name|sin_port
operator|=
name|ipl
operator|->
name|port
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ipl
operator|->
name|address
expr_stmt|;
name|ipl
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ip
operator|->
name|dstadr
operator|=
name|NSRCADR
argument_list|(
operator|&
name|pp
operator|->
name|dstadr
operator|->
name|sin
argument_list|)
expr_stmt|;
name|ip
operator|->
name|srcadr
operator|=
name|NSRCADR
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|ip
operator|->
name|srcport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|ip
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|sys_peer
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SYSPEER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_CONFIG
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_REFCLOCK
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_REFCLOCK
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_AUTHENABLE
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|FLAG_PREFER
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_PREFER
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|candidate
operator|!=
literal|0
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SEL_CANDIDATE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|select
operator|!=
literal|0
condition|)
name|ip
operator|->
name|flags
operator||=
name|INFO_FLAG_SHORTLIST
expr_stmt|;
name|ip
operator|->
name|timereceived
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|pp
operator|->
name|timereceived
argument_list|)
expr_stmt|;
name|ip
operator|->
name|timetosend
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|event_timer
operator|.
name|event_time
operator|-
name|current_time
argument_list|)
expr_stmt|;
name|ip
operator|->
name|timereachable
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|pp
operator|->
name|timereachable
argument_list|)
expr_stmt|;
name|ip
operator|->
name|sent
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|sent
argument_list|)
expr_stmt|;
name|ip
operator|->
name|received
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|received
argument_list|)
expr_stmt|;
name|ip
operator|->
name|processed
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|processed
argument_list|)
expr_stmt|;
name|ip
operator|->
name|badlength
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|badauth
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|badauth
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bogusorg
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|bogusorg
argument_list|)
expr_stmt|;
name|ip
operator|->
name|oldpkt
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|oldpkt
argument_list|)
expr_stmt|;
name|ip
operator|->
name|baddelay
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|seldelay
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|seldisp
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|seldisptoolarge
argument_list|)
expr_stmt|;
name|ip
operator|->
name|selbroken
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|selbroken
argument_list|)
expr_stmt|;
name|ip
operator|->
name|selold
operator|=
name|htonl
argument_list|(
name|pp
operator|->
name|seltooold
argument_list|)
expr_stmt|;
name|ip
operator|->
name|candidate
operator|=
name|pp
operator|->
name|candidate
expr_stmt|;
name|ip
operator|->
name|falseticker
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|select
operator|=
name|pp
operator|->
name|select
expr_stmt|;
name|ip
operator|->
name|select_total
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|info_peer_stats
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sys_info - return system info  */
end_comment

begin_function
specifier|static
name|void
name|sys_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_sys
modifier|*
name|is
decl_stmt|;
comment|/* 	 * Importations from the protocol module 	 */
specifier|extern
name|u_char
name|sys_leap
decl_stmt|;
specifier|extern
name|u_char
name|sys_stratum
decl_stmt|;
specifier|extern
name|s_char
name|sys_precision
decl_stmt|;
specifier|extern
name|s_fp
name|sys_rootdelay
decl_stmt|;
specifier|extern
name|u_fp
name|sys_rootdispersion
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_refid
decl_stmt|;
specifier|extern
name|l_fp
name|sys_reftime
decl_stmt|;
specifier|extern
name|u_char
name|sys_poll
decl_stmt|;
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
specifier|extern
name|int
name|sys_bclient
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_bdelay
decl_stmt|;
specifier|extern
name|int
name|sys_authenticate
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_authdelay
decl_stmt|;
name|is
operator|=
operator|(
expr|struct
name|info_sys
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_sys
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_peer
operator|!=
literal|0
condition|)
block|{
name|is
operator|->
name|peer
operator|=
name|NSRCADR
argument_list|(
operator|&
name|sys_peer
operator|->
name|srcadr
argument_list|)
expr_stmt|;
name|is
operator|->
name|peer_mode
operator|=
name|sys_peer
operator|->
name|hmode
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|peer
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|peer_mode
operator|=
literal|0
expr_stmt|;
block|}
name|is
operator|->
name|leap
operator|=
name|sys_leap
expr_stmt|;
name|is
operator|->
name|stratum
operator|=
name|sys_stratum
expr_stmt|;
name|is
operator|->
name|precision
operator|=
name|sys_precision
expr_stmt|;
name|is
operator|->
name|rootdelay
operator|=
name|htonl
argument_list|(
name|sys_rootdelay
argument_list|)
expr_stmt|;
name|is
operator|->
name|rootdispersion
operator|=
name|htonl
argument_list|(
name|sys_rootdispersion
argument_list|)
expr_stmt|;
name|is
operator|->
name|refid
operator|=
name|sys_refid
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|sys_reftime
argument_list|,
operator|&
name|is
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|is
operator|->
name|poll
operator|=
name|sys_poll
expr_stmt|;
name|is
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sys_bclient
condition|)
name|is
operator|->
name|flags
operator||=
name|INFO_FLAG_BCLIENT
expr_stmt|;
if|if
condition|(
name|sys_authenticate
condition|)
name|is
operator|->
name|flags
operator||=
name|INFO_FLAG_AUTHENABLE
expr_stmt|;
name|is
operator|->
name|selection
operator|=
literal|0
expr_stmt|;
comment|/* Obsolete */
name|HTONL_UF
argument_list|(
name|sys_bdelay
argument_list|,
operator|&
name|is
operator|->
name|bdelay
argument_list|)
expr_stmt|;
name|HTONL_UF
argument_list|(
name|sys_authdelay
argument_list|,
operator|&
name|is
operator|->
name|authdelay
argument_list|)
expr_stmt|;
name|is
operator|->
name|maxskew
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sys_stats - return system statistics  */
end_comment

begin_function
specifier|static
name|void
name|sys_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_sys_stats
modifier|*
name|ss
decl_stmt|;
comment|/* 	 * Importations from the protocol module 	 */
specifier|extern
name|U_LONG
name|sys_stattime
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_badstratum
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_oldversionpkt
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_newversionpkt
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_unknownversion
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_badlength
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_processed
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_badauth
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_wanderhold
decl_stmt|;
specifier|extern
name|U_LONG
name|sys_limitrejected
decl_stmt|;
name|ss
operator|=
operator|(
expr|struct
name|info_sys_stats
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_sys_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|timeup
operator|=
name|htonl
argument_list|(
name|current_time
argument_list|)
expr_stmt|;
name|ss
operator|->
name|timereset
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|sys_stattime
argument_list|)
expr_stmt|;
name|ss
operator|->
name|badstratum
operator|=
name|htonl
argument_list|(
name|sys_badstratum
argument_list|)
expr_stmt|;
name|ss
operator|->
name|oldversionpkt
operator|=
name|htonl
argument_list|(
name|sys_oldversionpkt
argument_list|)
expr_stmt|;
name|ss
operator|->
name|newversionpkt
operator|=
name|htonl
argument_list|(
name|sys_newversionpkt
argument_list|)
expr_stmt|;
name|ss
operator|->
name|unknownversion
operator|=
name|htonl
argument_list|(
name|sys_unknownversion
argument_list|)
expr_stmt|;
name|ss
operator|->
name|badlength
operator|=
name|htonl
argument_list|(
name|sys_badlength
argument_list|)
expr_stmt|;
name|ss
operator|->
name|processed
operator|=
name|htonl
argument_list|(
name|sys_processed
argument_list|)
expr_stmt|;
name|ss
operator|->
name|badauth
operator|=
name|htonl
argument_list|(
name|sys_badauth
argument_list|)
expr_stmt|;
name|ss
operator|->
name|wanderhold
operator|=
name|htonl
argument_list|(
name|sys_wanderhold
argument_list|)
expr_stmt|;
name|ss
operator|->
name|limitrejected
operator|=
name|htonl
argument_list|(
name|sys_limitrejected
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mem_stats - return memory statistics  */
end_comment

begin_function
specifier|static
name|void
name|mem_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_mem_stats
modifier|*
name|ms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Importations from the peer module 	 */
specifier|extern
name|int
name|peer_hash_count
index|[
name|HASH_SIZE
index|]
decl_stmt|;
specifier|extern
name|int
name|peer_free_count
decl_stmt|;
specifier|extern
name|U_LONG
name|peer_timereset
decl_stmt|;
specifier|extern
name|U_LONG
name|findpeer_calls
decl_stmt|;
specifier|extern
name|U_LONG
name|peer_allocations
decl_stmt|;
specifier|extern
name|U_LONG
name|peer_demobilizations
decl_stmt|;
specifier|extern
name|int
name|total_peer_structs
decl_stmt|;
name|ms
operator|=
operator|(
expr|struct
name|info_mem_stats
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_mem_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|->
name|timereset
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|peer_timereset
argument_list|)
expr_stmt|;
name|ms
operator|->
name|totalpeermem
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|total_peer_structs
argument_list|)
expr_stmt|;
name|ms
operator|->
name|freepeermem
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|peer_free_count
argument_list|)
expr_stmt|;
name|ms
operator|->
name|findpeer_calls
operator|=
name|htonl
argument_list|(
name|findpeer_calls
argument_list|)
expr_stmt|;
name|ms
operator|->
name|allocations
operator|=
name|htonl
argument_list|(
name|peer_allocations
argument_list|)
expr_stmt|;
name|ms
operator|->
name|demobilizations
operator|=
name|htonl
argument_list|(
name|peer_demobilizations
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peer_hash_count
index|[
name|i
index|]
operator|>
literal|255
condition|)
name|ms
operator|->
name|hashcount
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
else|else
name|ms
operator|->
name|hashcount
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|peer_hash_count
index|[
name|i
index|]
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * io_stats - return io statistics  */
end_comment

begin_function
specifier|static
name|void
name|io_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_io_stats
modifier|*
name|io
decl_stmt|;
comment|/* 	 * Importations from the io module 	 */
specifier|extern
name|U_LONG
name|io_timereset
decl_stmt|;
specifier|extern
name|U_LONG
name|full_recvbufs
decl_stmt|;
specifier|extern
name|U_LONG
name|free_recvbufs
decl_stmt|;
specifier|extern
name|U_LONG
name|total_recvbufs
decl_stmt|;
specifier|extern
name|U_LONG
name|lowater_additions
decl_stmt|;
specifier|extern
name|U_LONG
name|packets_dropped
decl_stmt|;
specifier|extern
name|U_LONG
name|packets_ignored
decl_stmt|;
specifier|extern
name|U_LONG
name|packets_received
decl_stmt|;
specifier|extern
name|U_LONG
name|packets_sent
decl_stmt|;
specifier|extern
name|U_LONG
name|packets_notsent
decl_stmt|;
specifier|extern
name|U_LONG
name|handler_calls
decl_stmt|;
specifier|extern
name|U_LONG
name|handler_pkts
decl_stmt|;
name|io
operator|=
operator|(
expr|struct
name|info_io_stats
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_io_stats
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|timereset
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|io_timereset
argument_list|)
expr_stmt|;
name|io
operator|->
name|totalrecvbufs
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|total_recvbufs
argument_list|)
expr_stmt|;
name|io
operator|->
name|freerecvbufs
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|free_recvbufs
argument_list|)
expr_stmt|;
name|io
operator|->
name|fullrecvbufs
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|full_recvbufs
argument_list|)
expr_stmt|;
name|io
operator|->
name|lowwater
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|lowater_additions
argument_list|)
expr_stmt|;
name|io
operator|->
name|dropped
operator|=
name|htonl
argument_list|(
name|packets_dropped
argument_list|)
expr_stmt|;
name|io
operator|->
name|ignored
operator|=
name|htonl
argument_list|(
name|packets_ignored
argument_list|)
expr_stmt|;
name|io
operator|->
name|received
operator|=
name|htonl
argument_list|(
name|packets_received
argument_list|)
expr_stmt|;
name|io
operator|->
name|sent
operator|=
name|htonl
argument_list|(
name|packets_sent
argument_list|)
expr_stmt|;
name|io
operator|->
name|notsent
operator|=
name|htonl
argument_list|(
name|packets_notsent
argument_list|)
expr_stmt|;
name|io
operator|->
name|interrupts
operator|=
name|htonl
argument_list|(
name|handler_calls
argument_list|)
expr_stmt|;
name|io
operator|->
name|int_received
operator|=
name|htonl
argument_list|(
name|handler_pkts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timer_stats - return timer statistics  */
end_comment

begin_function
specifier|static
name|void
name|timer_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_timer_stats
modifier|*
name|ts
decl_stmt|;
comment|/* 	 * Importations from the timer module 	 */
specifier|extern
name|U_LONG
name|alarm_overflow
decl_stmt|;
specifier|extern
name|U_LONG
name|timer_timereset
decl_stmt|;
specifier|extern
name|U_LONG
name|timer_overflows
decl_stmt|;
specifier|extern
name|U_LONG
name|timer_xmtcalls
decl_stmt|;
name|ts
operator|=
operator|(
expr|struct
name|info_timer_stats
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_timer_stats
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|timereset
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|timer_timereset
argument_list|)
expr_stmt|;
name|ts
operator|->
name|alarms
operator|=
name|htonl
argument_list|(
name|alarm_overflow
argument_list|)
expr_stmt|;
name|ts
operator|->
name|overflows
operator|=
name|htonl
argument_list|(
name|timer_overflows
argument_list|)
expr_stmt|;
name|ts
operator|->
name|xmtcalls
operator|=
name|htonl
argument_list|(
name|timer_xmtcalls
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * loop_info - return the current state of the loop filter  */
end_comment

begin_function
specifier|static
name|void
name|loop_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_loop
modifier|*
name|li
decl_stmt|;
name|l_fp
name|tmp
decl_stmt|;
comment|/* 	 * Importations from the loop filter module 	 */
specifier|extern
name|l_fp
name|last_offset
decl_stmt|;
specifier|extern
name|s_fp
name|drift_comp
decl_stmt|;
specifier|extern
name|int
name|time_constant
decl_stmt|;
specifier|extern
name|U_LONG
name|watchdog_timer
decl_stmt|;
name|li
operator|=
operator|(
expr|struct
name|info_loop
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_loop
argument_list|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|last_offset
argument_list|,
operator|&
name|li
operator|->
name|last_offset
argument_list|)
expr_stmt|;
name|FPTOLFP
argument_list|(
name|drift_comp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|li
operator|->
name|drift_comp
argument_list|)
expr_stmt|;
name|li
operator|->
name|compliance
operator|=
name|htonl
argument_list|(
name|time_constant
argument_list|)
expr_stmt|;
name|li
operator|->
name|watchdog_timer
operator|=
name|htonl
argument_list|(
name|watchdog_timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * do_conf - add a peer to the configuration list  */
end_comment

begin_function
specifier|static
name|void
name|do_conf
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_peer
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|struct
name|sockaddr_in
name|peeraddr
decl_stmt|;
name|int
name|fl
decl_stmt|;
comment|/* 	 * Do a check of everything to see that it looks 	 * okay.  If not, complain about it.  Note we are 	 * very picky here. 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|conf_peer
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|fl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
operator|&&
operator|!
name|fl
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|version
operator|>
name|NTP_VERSION
operator|||
name|cp
operator|->
name|version
operator|<
name|NTP_OLDVERSION
condition|)
name|fl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|hmode
operator|!=
name|MODE_ACTIVE
operator|&&
name|cp
operator|->
name|hmode
operator|!=
name|MODE_CLIENT
operator|&&
name|cp
operator|->
name|hmode
operator|!=
name|MODE_BROADCAST
condition|)
name|fl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|flags
operator|&
operator|~
operator|(
name|CONF_FLAG_AUTHENABLE
operator||
name|CONF_FLAG_PREFER
operator|)
condition|)
name|fl
operator|=
literal|1
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fl
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Looks okay, try it out 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|conf_peer
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peeraddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|peeraddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the address is valid 	 */
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
operator|&&
name|ISBADADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|ISBADADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|fl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|flags
operator|&
name|CONF_FLAG_AUTHENABLE
condition|)
name|fl
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|flags
operator|&
name|CONF_FLAG_PREFER
condition|)
name|fl
operator||=
name|FLAG_PREFER
expr_stmt|;
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cp
operator|->
name|peeraddr
expr_stmt|;
comment|/* XXX W2DO? minpoll/maxpoll arguments ??? */
if|if
condition|(
name|peer_config
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|(
expr|struct
name|interface
operator|*
operator|)
literal|0
argument_list|,
name|cp
operator|->
name|hmode
argument_list|,
name|cp
operator|->
name|version
argument_list|,
name|cp
operator|->
name|minpoll
argument_list|,
name|cp
operator|->
name|maxpoll
argument_list|,
name|cp
operator|->
name|keyid
argument_list|,
name|fl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|++
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_unconf - remove a peer from the configuration list  */
specifier|static
name|void
name|do_unconf
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_unpeer
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|sockaddr_in
name|peeraddr
decl_stmt|;
name|int
name|bad
decl_stmt|,
name|found
decl_stmt|;
comment|/* 	 * This is a bit unstructured, but I like to be careful. 	 * We check to see that every peer exists and is actually 	 * configured.  If so, we remove them.  If not, we return 	 * an error. 	 */
name|peeraddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|conf_unpeer
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|bad
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
operator|&&
operator|!
name|bad
condition|)
block|{
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cp
operator|->
name|peeraddr
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
name|peer
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|peeraddr
argument_list|,
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
condition|)
break|break;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|FLAG_CONFIG
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now do it in earnest. 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|conf_unpeer
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cp
operator|->
name|peeraddr
expr_stmt|;
name|peer_unconfig
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|(
expr|struct
name|interface
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * set_sys_flag - set system flags  */
specifier|static
name|void
name|set_sys_flag
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|setclr_flags
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * clr_sys_flag - clear system flags  */
specifier|static
name|void
name|clr_sys_flag
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|setclr_flags
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * setclr_flags - do the grunge work of flag setting/clearing  */
specifier|static
name|void
name|setclr_flags
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|,
name|set
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
specifier|register
name|U_LONG
name|flags
decl_stmt|;
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
operator|(
operator|(
expr|struct
name|conf_sys_flags
operator|*
operator|)
name|inpkt
operator|->
name|data
operator|)
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|SYS_FLAG_BCLIENT
operator||
name|SYS_FLAG_AUTHENTICATE
operator|)
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|SYS_FLAG_BCLIENT
condition|)
name|proto_config
argument_list|(
name|PROTO_BROADCLIENT
argument_list|,
operator|(
name|LONG
operator|)
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYS_FLAG_AUTHENTICATE
condition|)
name|proto_config
argument_list|(
name|PROTO_AUTHENTICATE
argument_list|,
operator|(
name|LONG
operator|)
name|set
argument_list|)
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_monitor - turn on monitoring  */
specifier|static
name|void
name|do_monitor
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|mon_start
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_nomonitor - turn off monitoring  */
specifier|static
name|void
name|do_nomonitor
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|mon_stop
argument_list|(
name|MON_ON
argument_list|)
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * list_restrict - return the restrict list  */
specifier|static
name|void
name|list_restrict
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_restrict
modifier|*
name|ir
decl_stmt|;
specifier|register
name|struct
name|restrictlist
modifier|*
name|rl
decl_stmt|;
specifier|extern
name|struct
name|restrictlist
modifier|*
name|restrictlist
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"wants peer list summary\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ir
operator|=
operator|(
expr|struct
name|info_restrict
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_restrict
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rl
operator|=
name|restrictlist
init|;
name|rl
operator|!=
literal|0
operator|&&
name|ir
operator|!=
literal|0
condition|;
name|rl
operator|=
name|rl
operator|->
name|next
control|)
block|{
name|ir
operator|->
name|addr
operator|=
name|htonl
argument_list|(
name|rl
operator|->
name|addr
argument_list|)
expr_stmt|;
name|ir
operator|->
name|mask
operator|=
name|htonl
argument_list|(
name|rl
operator|->
name|mask
argument_list|)
expr_stmt|;
name|ir
operator|->
name|count
operator|=
name|htonl
argument_list|(
name|rl
operator|->
name|count
argument_list|)
expr_stmt|;
name|ir
operator|->
name|flags
operator|=
name|htons
argument_list|(
name|rl
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ir
operator|->
name|mflags
operator|=
name|htons
argument_list|(
name|rl
operator|->
name|mflags
argument_list|)
expr_stmt|;
name|ir
operator|=
operator|(
expr|struct
name|info_restrict
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
comment|/*  * do_resaddflags - add flags to a restrict entry (or create one)  */
specifier|static
name|void
name|do_resaddflags
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_restrict
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|RESTRICT_FLAGS
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_ressubflags - remove flags from a restrict entry  */
specifier|static
name|void
name|do_ressubflags
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_restrict
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|RESTRICT_UNFLAG
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_unrestrict - remove a restrict entry from the list  */
specifier|static
name|void
name|do_unrestrict
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_restrict
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|RESTRICT_REMOVE
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_restrict - do the dirty stuff of dealing with restrictions  */
specifier|static
name|void
name|do_restrict
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|,
name|op
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
name|int
name|op
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_restrict
modifier|*
name|cr
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|struct
name|sockaddr_in
name|matchaddr
decl_stmt|;
name|struct
name|sockaddr_in
name|matchmask
decl_stmt|;
name|int
name|bad
decl_stmt|;
comment|/* 	 * Do a check of the flags to make sure that only 	 * the NTPPORT flag is set, if any.  If not, complain 	 * about it.  Note we are very picky here. 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cr
operator|=
operator|(
expr|struct
name|conf_restrict
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|bad
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
operator|&&
operator|!
name|bad
condition|)
block|{
if|if
condition|(
name|cr
operator|->
name|mflags
operator|&
operator|~
operator|(
name|RESM_NTPONLY
operator|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|flags
operator|&
operator|~
operator|(
name|RES_ALLFLAGS
operator|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|addr
operator|==
name|INADDR_ANY
operator|&&
name|cr
operator|->
name|mask
operator|!=
name|INADDR_ANY
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
name|cr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Looks okay, try it out 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cr
operator|=
operator|(
expr|struct
name|conf_restrict
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|matchaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|matchmask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|matchaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|matchmask
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|matchaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cr
operator|->
name|addr
expr_stmt|;
name|matchmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cr
operator|->
name|mask
expr_stmt|;
specifier|restrict
operator|(
name|op
operator|,
operator|&
name|matchaddr
operator|,
operator|&
name|matchmask
operator|,
name|cr
operator|->
name|mflags
operator|,
name|cr
operator|->
name|flags
operator|)
expr_stmt|;
name|cr
operator|++
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * mon_getlist - return monitor data  */
specifier|static
name|void
name|mon_getlist
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_monitor
modifier|*
name|im
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|extern
name|struct
name|mon_data
name|mon_mru_list
decl_stmt|;
specifier|extern
name|int
name|mon_enabled
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"wants monitor list\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mon_enabled
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|im
operator|=
operator|(
expr|struct
name|info_monitor
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_monitor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|md
operator|=
name|mon_mru_list
operator|.
name|mru_next
init|;
name|md
operator|!=
operator|&
name|mon_mru_list
operator|&&
name|im
operator|!=
literal|0
condition|;
name|md
operator|=
name|md
operator|->
name|mru_next
control|)
block|{
name|im
operator|->
name|lasttime
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|md
operator|->
name|lasttime
argument_list|)
expr_stmt|;
name|im
operator|->
name|firsttime
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|md
operator|->
name|firsttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|lastdrop
condition|)
name|im
operator|->
name|lastdrop
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|md
operator|->
name|lastdrop
argument_list|)
expr_stmt|;
else|else
name|im
operator|->
name|lastdrop
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|count
operator|=
name|htonl
argument_list|(
name|md
operator|->
name|count
argument_list|)
expr_stmt|;
name|im
operator|->
name|addr
operator|=
name|md
operator|->
name|rmtadr
expr_stmt|;
name|im
operator|->
name|port
operator|=
name|md
operator|->
name|rmtport
expr_stmt|;
name|im
operator|->
name|mode
operator|=
name|md
operator|->
name|mode
expr_stmt|;
name|im
operator|->
name|version
operator|=
name|md
operator|->
name|version
expr_stmt|;
name|im
operator|=
operator|(
expr|struct
name|info_monitor
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
comment|/*  * Module entry points and the flags they correspond with  */
struct|struct
name|reset_entry
block|{
name|int
name|flag
decl_stmt|;
comment|/* flag this corresponds to */
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
comment|/* routine to handle request */
block|}
struct|;
name|struct
name|reset_entry
name|reset_entries
index|[]
init|=
block|{
block|{
name|RESET_FLAG_ALLPEERS
block|,
name|peer_all_reset
block|}
block|,
block|{
name|RESET_FLAG_IO
block|,
name|io_clr_stats
block|}
block|,
block|{
name|RESET_FLAG_SYS
block|,
name|proto_clr_stats
block|}
block|,
block|{
name|RESET_FLAG_MEM
block|,
name|peer_clr_stats
block|}
block|,
block|{
name|RESET_FLAG_TIMER
block|,
name|timer_clr_stats
block|}
block|,
block|{
name|RESET_FLAG_AUTH
block|,
name|reset_auth_stats
block|}
block|,
block|{
name|RESET_FLAG_CTL
block|,
name|ctl_clr_stats
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|/*  * reset_stats - reset statistic counters here and there  */
specifier|static
name|void
name|reset_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|U_LONG
name|flags
decl_stmt|;
name|struct
name|reset_entry
modifier|*
name|rent
decl_stmt|;
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
operator|(
operator|(
expr|struct
name|reset_flags
operator|*
operator|)
name|inpkt
operator|->
name|data
operator|)
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|~
name|RESET_ALLFLAGS
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|rent
operator|=
name|reset_entries
init|;
name|rent
operator|->
name|flag
operator|!=
literal|0
condition|;
name|rent
operator|++
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|rent
operator|->
name|flag
condition|)
call|(
name|rent
operator|->
name|handler
call|)
argument_list|()
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * reset_peer - clear a peer's statistics  */
specifier|static
name|void
name|reset_peer
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_unpeer
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
specifier|register
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|sockaddr_in
name|peeraddr
decl_stmt|;
name|int
name|bad
decl_stmt|;
comment|/* 	 * We check first to see that every peer exists.  If not, 	 * we return an error. 	 */
name|peeraddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|peeraddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|conf_unpeer
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|bad
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
operator|&&
operator|!
name|bad
condition|)
block|{
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cp
operator|->
name|peeraddr
expr_stmt|;
name|peer
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
condition|)
name|bad
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now do it in earnest. 	 */
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|conf_unpeer
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cp
operator|->
name|peeraddr
expr_stmt|;
name|peer
operator|=
name|findexistingpeer
argument_list|(
operator|&
name|peeraddr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|peer_reset
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_key_reread - reread the encryption key file  */
specifier|static
name|void
name|do_key_reread
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|rereadkeys
argument_list|()
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_dirty_hack  */
specifier|static
name|void
name|do_dirty_hack
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
comment|/* historical placeholder */
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * dont_dirty_hack  */
specifier|static
name|void
name|dont_dirty_hack
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
comment|/* historical placeholder */
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * trust_key - make one or more keys trusted  */
specifier|static
name|void
name|trust_key
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_trustkey
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * untrust_key - make one or more keys untrusted  */
specifier|static
name|void
name|untrust_key
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_trustkey
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_trustkey - make keys either trustable or untrustable  */
specifier|static
name|void
name|do_trustkey
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|,
name|trust
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
name|int
name|trust
decl_stmt|;
block|{
specifier|register
name|U_LONG
modifier|*
name|kp
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|kp
operator|=
operator|(
name|U_LONG
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|authtrust
argument_list|(
operator|*
name|kp
argument_list|,
name|trust
argument_list|)
expr_stmt|;
name|kp
operator|++
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * get_auth_info - return some stats concerning the authentication module  */
specifier|static
name|void
name|get_auth_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_auth
modifier|*
name|ia
decl_stmt|;
comment|/* 	 * Importations from the authentication module 	 */
specifier|extern
name|U_LONG
name|authnumkeys
decl_stmt|;
specifier|extern
name|U_LONG
name|authnumfreekeys
decl_stmt|;
specifier|extern
name|U_LONG
name|authkeylookups
decl_stmt|;
specifier|extern
name|U_LONG
name|authkeynotfound
decl_stmt|;
specifier|extern
name|U_LONG
name|authencryptions
decl_stmt|;
specifier|extern
name|U_LONG
name|authdecryptions
decl_stmt|;
specifier|extern
name|U_LONG
name|authdecryptok
decl_stmt|;
specifier|extern
name|U_LONG
name|authkeyuncached
decl_stmt|;
name|ia
operator|=
operator|(
expr|struct
name|info_auth
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_auth
argument_list|)
argument_list|)
expr_stmt|;
name|ia
operator|->
name|numkeys
operator|=
name|htonl
argument_list|(
name|authnumkeys
argument_list|)
expr_stmt|;
name|ia
operator|->
name|numfreekeys
operator|=
name|htonl
argument_list|(
name|authnumfreekeys
argument_list|)
expr_stmt|;
name|ia
operator|->
name|keylookups
operator|=
name|htonl
argument_list|(
name|authkeylookups
argument_list|)
expr_stmt|;
name|ia
operator|->
name|keynotfound
operator|=
name|htonl
argument_list|(
name|authkeynotfound
argument_list|)
expr_stmt|;
name|ia
operator|->
name|encryptions
operator|=
name|htonl
argument_list|(
name|authencryptions
argument_list|)
expr_stmt|;
name|ia
operator|->
name|decryptions
operator|=
name|htonl
argument_list|(
name|authdecryptions
argument_list|)
expr_stmt|;
name|ia
operator|->
name|decryptok
operator|=
name|htonl
argument_list|(
name|authdecryptok
argument_list|)
expr_stmt|;
name|ia
operator|->
name|keyuncached
operator|=
name|htonl
argument_list|(
name|authkeyuncached
argument_list|)
expr_stmt|;
name|ia
operator|->
name|timereset
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|auth_timereset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
comment|/*  * reset_auth_stats - reset the authentication stat counters.  Done here  *		      to keep xntp-isms out of the authentication module  */
specifier|static
name|void
name|reset_auth_stats
parameter_list|()
block|{
comment|/* 	 * Importations from the authentication module 	 */
specifier|extern
name|U_LONG
name|authkeylookups
decl_stmt|;
specifier|extern
name|U_LONG
name|authkeynotfound
decl_stmt|;
specifier|extern
name|U_LONG
name|authencryptions
decl_stmt|;
specifier|extern
name|U_LONG
name|authdecryptions
decl_stmt|;
specifier|extern
name|U_LONG
name|authdecryptok
decl_stmt|;
specifier|extern
name|U_LONG
name|authkeyuncached
decl_stmt|;
name|authkeylookups
operator|=
literal|0
expr_stmt|;
name|authkeynotfound
operator|=
literal|0
expr_stmt|;
name|authencryptions
operator|=
literal|0
expr_stmt|;
name|authdecryptions
operator|=
literal|0
expr_stmt|;
name|authdecryptok
operator|=
literal|0
expr_stmt|;
name|authkeyuncached
operator|=
literal|0
expr_stmt|;
name|auth_timereset
operator|=
name|current_time
expr_stmt|;
block|}
comment|/*  * req_get_traps - return information about current trap holders  */
specifier|static
name|void
name|req_get_traps
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_trap
modifier|*
name|it
decl_stmt|;
specifier|register
name|struct
name|ctl_trap
modifier|*
name|tr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Imported from the control module 	 */
specifier|extern
name|struct
name|ctl_trap
name|ctl_trap
index|[]
decl_stmt|;
specifier|extern
name|int
name|num_ctl_traps
decl_stmt|;
if|if
condition|(
name|num_ctl_traps
operator|==
literal|0
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|it
operator|=
operator|(
expr|struct
name|info_trap
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_trap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tr
operator|=
name|ctl_trap
init|;
name|i
operator|<
name|CTL_MAXTRAPS
condition|;
name|i
operator|++
operator|,
name|tr
operator|++
control|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_flags
operator|&
name|TRAP_INUSE
condition|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_localaddr
operator|==
name|any_interface
condition|)
name|it
operator|->
name|local_address
operator|=
literal|0
expr_stmt|;
else|else
name|it
operator|->
name|local_address
operator|=
name|NSRCADR
argument_list|(
operator|&
name|tr
operator|->
name|tr_localaddr
operator|->
name|sin
argument_list|)
expr_stmt|;
name|it
operator|->
name|trap_address
operator|=
name|NSRCADR
argument_list|(
operator|&
name|tr
operator|->
name|tr_addr
argument_list|)
expr_stmt|;
name|it
operator|->
name|trap_port
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|tr
operator|->
name|tr_addr
argument_list|)
expr_stmt|;
name|it
operator|->
name|sequence
operator|=
name|htons
argument_list|(
name|tr
operator|->
name|tr_sequence
argument_list|)
expr_stmt|;
name|it
operator|->
name|settime
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|tr
operator|->
name|tr_settime
argument_list|)
expr_stmt|;
name|it
operator|->
name|origtime
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|tr
operator|->
name|tr_origtime
argument_list|)
expr_stmt|;
name|it
operator|->
name|resets
operator|=
name|htonl
argument_list|(
name|tr
operator|->
name|tr_resets
argument_list|)
expr_stmt|;
name|it
operator|->
name|flags
operator|=
name|htonl
argument_list|(
operator|(
name|U_LONG
operator|)
name|tr
operator|->
name|tr_flags
argument_list|)
expr_stmt|;
name|it
operator|=
operator|(
expr|struct
name|info_trap
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
comment|/*  * req_set_trap - configure a trap  */
specifier|static
name|void
name|req_set_trap
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_setclr_trap
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * req_clr_trap - unconfigure a trap  */
specifier|static
name|void
name|req_clr_trap
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|do_setclr_trap
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * do_setclr_trap - do the grunge work of (un)configuring a trap  */
specifier|static
name|void
name|do_setclr_trap
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|,
name|set
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_trap
modifier|*
name|ct
decl_stmt|;
specifier|register
name|struct
name|interface
modifier|*
name|linter
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|sockaddr_in
name|laddr
decl_stmt|;
comment|/* 	 * Prepare sockaddr_in structure 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|laddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|laddr
argument_list|)
expr_stmt|;
name|laddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|laddr
operator|.
name|sin_port
operator|=
name|ntohs
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
comment|/* 	 * Restrict ourselves to one item only.  This eliminates 	 * the error reporting problem. 	 */
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|ct
operator|=
operator|(
expr|struct
name|conf_trap
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
comment|/* 	 * Look for the local interface.  If none, use the default. 	 */
if|if
condition|(
name|ct
operator|->
name|local_address
operator|==
literal|0
condition|)
block|{
name|linter
operator|=
name|any_interface
expr_stmt|;
block|}
else|else
block|{
name|laddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ct
operator|->
name|local_address
expr_stmt|;
name|linter
operator|=
name|findinterface
argument_list|(
operator|&
name|laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|linter
operator|==
name|NULL
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|laddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ct
operator|->
name|trap_address
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|trap_port
operator|!=
literal|0
condition|)
name|laddr
operator|.
name|sin_port
operator|=
name|ct
operator|->
name|trap_port
expr_stmt|;
else|else
name|laddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|TRAPPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|res
operator|=
name|ctlsettrap
argument_list|(
operator|&
name|laddr
argument_list|,
name|linter
argument_list|,
literal|0
argument_list|,
name|INFO_VERSION
argument_list|(
name|inpkt
operator|->
name|rm_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|ctlclrtrap
argument_list|(
operator|&
name|laddr
argument_list|,
name|linter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*  * set_request_keyid - set the keyid used to authenticate requests  */
specifier|static
name|void
name|set_request_keyid
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|U_LONG
name|keyid
decl_stmt|;
comment|/* 	 * Restrict ourselves to one item only. 	 */
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|keyid
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|U_LONG
operator|*
operator|)
operator|(
name|inpkt
operator|->
name|data
operator|)
operator|)
argument_list|)
expr_stmt|;
name|info_auth_keyid
operator|=
name|keyid
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * set_control_keyid - set the keyid used to authenticate requests  */
specifier|static
name|void
name|set_control_keyid
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
name|U_LONG
name|keyid
decl_stmt|;
specifier|extern
name|U_LONG
name|ctl_auth_keyid
decl_stmt|;
comment|/* 	 * Restrict ourselves to one item only. 	 */
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|keyid
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|U_LONG
operator|*
operator|)
operator|(
name|inpkt
operator|->
name|data
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ctl_auth_keyid
operator|=
name|keyid
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * get_ctl_stats - return some stats concerning the control message module  */
specifier|static
name|void
name|get_ctl_stats
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_control
modifier|*
name|ic
decl_stmt|;
comment|/* 	 * Importations from the control module 	 */
specifier|extern
name|U_LONG
name|ctltimereset
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlreq
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlbadpkts
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlresponses
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlfrags
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlerrors
decl_stmt|;
specifier|extern
name|U_LONG
name|numctltooshort
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlinputresp
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlinputfrag
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlinputerr
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlbadoffset
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlbadversion
decl_stmt|;
specifier|extern
name|U_LONG
name|numctldatatooshort
decl_stmt|;
specifier|extern
name|U_LONG
name|numctlbadop
decl_stmt|;
specifier|extern
name|U_LONG
name|numasyncmsgs
decl_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|info_control
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_control
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ctltimereset
operator|=
name|htonl
argument_list|(
name|current_time
operator|-
name|ctltimereset
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlreq
operator|=
name|htonl
argument_list|(
name|numctlreq
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlbadpkts
operator|=
name|htonl
argument_list|(
name|numctlbadpkts
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlresponses
operator|=
name|htonl
argument_list|(
name|numctlresponses
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlfrags
operator|=
name|htonl
argument_list|(
name|numctlfrags
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlerrors
operator|=
name|htonl
argument_list|(
name|numctlerrors
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctltooshort
operator|=
name|htonl
argument_list|(
name|numctltooshort
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlinputresp
operator|=
name|htonl
argument_list|(
name|numctlinputresp
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlinputfrag
operator|=
name|htonl
argument_list|(
name|numctlinputfrag
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlinputerr
operator|=
name|htonl
argument_list|(
name|numctlinputerr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlbadoffset
operator|=
name|htonl
argument_list|(
name|numctlbadoffset
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlbadversion
operator|=
name|htonl
argument_list|(
name|numctlbadversion
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctldatatooshort
operator|=
name|htonl
argument_list|(
name|numctldatatooshort
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numctlbadop
operator|=
name|htonl
argument_list|(
name|numctlbadop
argument_list|)
expr_stmt|;
name|ic
operator|->
name|numasyncmsgs
operator|=
name|htonl
argument_list|(
name|numasyncmsgs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
comment|/*  * get_leap_info - return some stats concerning the control message module  */
specifier|static
name|void
name|get_leap_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_leap
modifier|*
name|il
decl_stmt|;
comment|/* 	 * Imported from the protocol module 	 */
specifier|extern
name|u_char
name|sys_leap
decl_stmt|;
comment|/* 	 * Importations from the leap module 	 */
specifier|extern
name|u_char
name|leap_indicator
decl_stmt|;
specifier|extern
name|u_char
name|leap_warning
decl_stmt|;
specifier|extern
name|u_char
name|leapbits
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_timer
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_processcalls
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_notclose
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_monthofleap
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_dayofleap
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_hoursfromleap
decl_stmt|;
specifier|extern
name|U_LONG
name|leap_happened
decl_stmt|;
name|il
operator|=
operator|(
expr|struct
name|info_leap
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_leap
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|->
name|sys_leap
operator|=
name|sys_leap
expr_stmt|;
name|il
operator|->
name|leap_indicator
operator|=
name|leap_indicator
expr_stmt|;
name|il
operator|->
name|leap_warning
operator|=
name|leap_warning
expr_stmt|;
name|il
operator|->
name|leap_bits
operator|=
operator|(
name|leapbits
operator|&
name|INFO_LEAP_MASK
operator|)
operator||
operator|(
operator|(
name|leap_indicator
operator|!=
name|LEAP_NOWARNING
operator|)
condition|?
name|INFO_LEAP_OVERRIDE
else|:
literal|0
operator|)
expr_stmt|;
name|il
operator|->
name|leap_timer
operator|=
name|htonl
argument_list|(
name|leap_timer
operator|-
name|current_time
argument_list|)
expr_stmt|;
name|il
operator|->
name|leap_processcalls
operator|=
name|htonl
argument_list|(
name|leap_processcalls
argument_list|)
expr_stmt|;
name|il
operator|->
name|leap_notclose
operator|=
name|htonl
argument_list|(
name|leap_notclose
argument_list|)
expr_stmt|;
name|il
operator|->
name|leap_monthofleap
operator|=
name|htonl
argument_list|(
name|leap_monthofleap
argument_list|)
expr_stmt|;
name|il
operator|->
name|leap_dayofleap
operator|=
name|htonl
argument_list|(
name|leap_dayofleap
argument_list|)
expr_stmt|;
name|il
operator|->
name|leap_hoursfromleap
operator|=
name|htonl
argument_list|(
name|leap_hoursfromleap
argument_list|)
expr_stmt|;
name|il
operator|->
name|leap_happened
operator|=
name|htonl
argument_list|(
name|leap_happened
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/*  * get_clock_info - get info about a clock  */
specifier|static
name|void
name|get_clock_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|info_clock
modifier|*
name|ic
decl_stmt|;
specifier|register
name|U_LONG
modifier|*
name|clkaddr
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|struct
name|refclockstat
name|clock
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|clkaddr
operator|=
operator|(
name|U_LONG
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|info_clock
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_clock
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
name|clkaddr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|addr
argument_list|)
operator|||
name|findexistingpeer
argument_list|(
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|clock
operator|.
name|kv_list
operator|=
operator|(
expr|struct
name|ctl_var
operator|*
operator|)
literal|0
expr_stmt|;
name|refclock_control
argument_list|(
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|clock
argument_list|)
expr_stmt|;
name|ic
operator|->
name|clockadr
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ic
operator|->
name|type
operator|=
name|clock
operator|.
name|type
expr_stmt|;
name|ic
operator|->
name|flags
operator|=
name|clock
operator|.
name|flags
expr_stmt|;
name|ic
operator|->
name|lastevent
operator|=
name|clock
operator|.
name|lastevent
expr_stmt|;
name|ic
operator|->
name|currentstatus
operator|=
name|clock
operator|.
name|currentstatus
expr_stmt|;
name|ic
operator|->
name|polls
operator|=
name|htonl
argument_list|(
name|clock
operator|.
name|polls
argument_list|)
expr_stmt|;
name|ic
operator|->
name|noresponse
operator|=
name|htonl
argument_list|(
name|clock
operator|.
name|noresponse
argument_list|)
expr_stmt|;
name|ic
operator|->
name|badformat
operator|=
name|htonl
argument_list|(
name|clock
operator|.
name|badformat
argument_list|)
expr_stmt|;
name|ic
operator|->
name|baddata
operator|=
name|htonl
argument_list|(
name|clock
operator|.
name|baddata
argument_list|)
expr_stmt|;
name|ic
operator|->
name|timestarted
operator|=
name|clock
operator|.
name|timereset
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|clock
operator|.
name|fudgetime1
argument_list|,
operator|&
name|ic
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|clock
operator|.
name|fudgetime2
argument_list|,
operator|&
name|ic
operator|->
name|fudgetime2
argument_list|)
expr_stmt|;
name|ic
operator|->
name|fudgeval1
operator|=
name|htonl
argument_list|(
name|clock
operator|.
name|fudgeval1
argument_list|)
expr_stmt|;
name|ic
operator|->
name|fudgeval2
operator|=
name|htonl
argument_list|(
name|clock
operator|.
name|fudgeval2
argument_list|)
expr_stmt|;
name|free_varlist
argument_list|(
name|clock
operator|.
name|kv_list
argument_list|)
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|info_clock
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
comment|/*  * set_clock_fudge - get a clock's fudge factors  */
specifier|static
name|void
name|set_clock_fudge
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|struct
name|conf_fudge
modifier|*
name|cf
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|struct
name|refclockstat
name|clock
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|clock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|clock
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|cf
operator|=
operator|(
expr|struct
name|conf_fudge
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cf
operator|->
name|clockadr
expr_stmt|;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|addr
argument_list|)
operator|||
name|findexistingpeer
argument_list|(
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ntohl
argument_list|(
name|cf
operator|->
name|which
argument_list|)
condition|)
block|{
case|case
name|FUDGE_TIME1
case|:
name|NTOHL_FP
argument_list|(
operator|&
name|cf
operator|->
name|fudgetime
argument_list|,
operator|&
name|clock
operator|.
name|fudgetime1
argument_list|)
expr_stmt|;
name|clock
operator|.
name|haveflags
operator|=
name|CLK_HAVETIME1
expr_stmt|;
break|break;
case|case
name|FUDGE_TIME2
case|:
name|NTOHL_FP
argument_list|(
operator|&
name|cf
operator|->
name|fudgetime
argument_list|,
operator|&
name|clock
operator|.
name|fudgetime2
argument_list|)
expr_stmt|;
name|clock
operator|.
name|haveflags
operator|=
name|CLK_HAVETIME2
expr_stmt|;
break|break;
case|case
name|FUDGE_VAL1
case|:
name|clock
operator|.
name|fudgeval1
operator|=
name|ntohl
argument_list|(
name|cf
operator|->
name|fudgeval_flags
argument_list|)
expr_stmt|;
name|clock
operator|.
name|haveflags
operator|=
name|CLK_HAVEVAL1
expr_stmt|;
break|break;
case|case
name|FUDGE_VAL2
case|:
name|clock
operator|.
name|fudgeval2
operator|=
name|ntohl
argument_list|(
name|cf
operator|->
name|fudgeval_flags
argument_list|)
expr_stmt|;
name|clock
operator|.
name|haveflags
operator|=
name|CLK_HAVEVAL2
expr_stmt|;
break|break;
case|case
name|FUDGE_FLAGS
case|:
name|clock
operator|.
name|flags
operator|=
name|ntohl
argument_list|(
name|cf
operator|->
name|fudgeval_flags
argument_list|)
operator|&
literal|0xf
expr_stmt|;
name|clock
operator|.
name|haveflags
operator|=
operator|(
name|CLK_HAVEFLAG1
operator||
name|CLK_HAVEFLAG2
operator||
name|CLK_HAVEFLAG3
operator||
name|CLK_HAVEFLAG4
operator|)
expr_stmt|;
break|break;
default|default:
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|refclock_control
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|clock
argument_list|,
operator|(
expr|struct
name|refclockstat
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  * set_maxskew - set the system maxskew parameter  */
specifier|static
name|void
name|set_maxskew
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|u_fp
name|maxskew
decl_stmt|;
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|maxskew
operator|=
name|NTOHS_FP
argument_list|(
operator|*
operator|(
name|u_fp
operator|*
operator|)
operator|(
name|inpkt
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|proto_config
argument_list|(
name|PROTO_MAXSKEW
argument_list|,
operator|(
name|LONG
operator|)
name|maxskew
argument_list|)
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * set_precision - set the system precision  */
specifier|static
name|void
name|set_precision
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|LONG
name|precision
decl_stmt|;
name|precision
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|LONG
operator|*
operator|)
operator|(
name|inpkt
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
operator|||
name|precision
operator|>
operator|-
literal|1
operator|||
name|precision
operator|<
operator|-
literal|20
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|proto_config
argument_list|(
name|PROTO_PRECISION
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
comment|/*  * set_select_code - set a select code to use  */
specifier|static
name|void
name|set_select_code
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|U_LONG
name|select_code
decl_stmt|;
name|select_code
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|U_LONG
operator|*
operator|)
operator|(
name|inpkt
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
operator|>
literal|1
operator|||
name|select_code
operator|<
name|SELECT_1
operator|||
name|select_code
operator|>
name|SELECT_5
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_FMT
argument_list|)
expr_stmt|;
return|return;
block|}
name|proto_config
argument_list|(
name|PROTO_SELECT
argument_list|,
operator|(
name|LONG
operator|)
name|select_code
argument_list|)
expr_stmt|;
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_OKAY
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
comment|/*  * get_clkbug_info - get debugging info about a clock  */
specifier|static
name|void
name|get_clkbug_info
parameter_list|(
name|srcadr
parameter_list|,
name|inter
parameter_list|,
name|inpkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|srcadr
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
decl_stmt|;
name|struct
name|req_pkt
modifier|*
name|inpkt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|info_clkbug
modifier|*
name|ic
decl_stmt|;
specifier|register
name|U_LONG
modifier|*
name|clkaddr
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|struct
name|refclockbug
name|bug
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|items
operator|=
name|INFO_NITEMS
argument_list|(
name|inpkt
operator|->
name|err_nitems
argument_list|)
expr_stmt|;
name|clkaddr
operator|=
operator|(
name|U_LONG
operator|*
operator|)
name|inpkt
operator|->
name|data
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|info_clkbug
operator|*
operator|)
name|prepare_pkt
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|info_clkbug
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
name|clkaddr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISREFCLOCKADR
argument_list|(
operator|&
name|addr
argument_list|)
operator|||
name|findexistingpeer
argument_list|(
operator|&
name|addr
argument_list|,
operator|(
expr|struct
name|peer
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|bug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bug
argument_list|)
expr_stmt|;
name|refclock_buginfo
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|bug
argument_list|)
expr_stmt|;
if|if
condition|(
name|bug
operator|.
name|nvalues
operator|==
literal|0
operator|&&
name|bug
operator|.
name|ntimes
operator|==
literal|0
condition|)
block|{
name|req_ack
argument_list|(
name|srcadr
argument_list|,
name|inter
argument_list|,
name|inpkt
argument_list|,
name|INFO_ERR_NODATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|ic
operator|->
name|clockadr
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|i
operator|=
name|bug
operator|.
name|nvalues
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|NUMCBUGVALUES
condition|)
name|i
operator|=
name|NUMCBUGVALUES
expr_stmt|;
name|ic
operator|->
name|nvalues
operator|=
operator|(
name|u_char
operator|)
name|i
expr_stmt|;
name|ic
operator|->
name|svalues
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|bug
operator|.
name|svalues
operator|&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|ic
operator|->
name|values
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|bug
operator|.
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|bug
operator|.
name|ntimes
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|NUMCBUGTIMES
condition|)
name|i
operator|=
name|NUMCBUGTIMES
expr_stmt|;
name|ic
operator|->
name|ntimes
operator|=
operator|(
name|u_char
operator|)
name|i
expr_stmt|;
name|ic
operator|->
name|stimes
operator|=
name|htonl
argument_list|(
operator|(
name|U_LONG
operator|)
name|bug
operator|.
name|stimes
operator|&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|ic
operator|->
name|times
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
name|htonl
argument_list|(
name|bug
operator|.
name|times
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|)
expr_stmt|;
name|ic
operator|->
name|times
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|htonl
argument_list|(
name|bug
operator|.
name|times
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
block|}
name|ic
operator|=
operator|(
expr|struct
name|info_clkbug
operator|*
operator|)
name|more_pkt
argument_list|()
expr_stmt|;
block|}
name|flush_pkt
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

