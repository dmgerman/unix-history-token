begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_atom - clock driver for 1-pps signals  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|ATOM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PPS
end_ifdef

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS */
end_comment

begin_comment
comment|/*  * This driver furnishes an interface for pulse-per-second (PPS) signals  * produced by a cesium clock, timing receiver or related  equipment. It  * can be used to remove accumulated jitter and retime a secondary  * server when synchronized to a primary server over a congested, wide-  * area network and before redistributing the time to local clients.  *  * In order for this driver to work, the local clock must be set to  * within +-500 ms by another means, such as a radio clock or NTP  * itself. The 1-pps signal is connected via a serial port and gadget  * box consisting of a one-shot and RS232 level converter. When operated  * at 38.4 kbps with a SPARCstation IPC, this arrangement has a worst-  * case jitter less than 26 us.  *  * There are three ways in which this driver can be used. The first way  * uses the LDISC_PPS line discipline and works only for the baseboard  * serial ports of the Sun SPARCstation. The PPS signal is connected via  * a gadget box to the carrier detect (CD) line of a serial port and  * flag3 of the driver configured for that port is set. This causes the  * ppsclock streams module to be configured for that port and capture a  * timestamp at the on-time transition of the PPS signal. This driver  * then reads the timestamp directly by a designated ioctl() system  * call. This provides the most accurate time and least jitter of any  * other scheme. There is no need to configure a dedicated device for  * this purpose, which ordinarily is the device used for the associated  * radio clock.  *  * The second way uses the LDISC_CLKPPS line discipline and works for  * any architecture supporting a serial port. If after a few seconds  * this driver finds no ppsclock module configured, it attempts to open  * a serial port device /dev/pps%d, where %d is the unit number, and  * assign the LDISC_CLKPPS line discipline to it. If the line discipline  * fails, no harm is done except the accuracy is reduced somewhat. The  * pulse generator in the gadget box is adjusted to produce a start bit  * of length 26 usec at 38400 bps. Used with the LDISC_CLKPPS line  * discipline, this produces an ASCII DEL character ('\377') followed by  * a timestamp at each seconds epoch.   *  * The third way involves an auxiliary radio clock driver which calls  * the PPS driver with a timestamp captured by that driver. This use is  * documented in the source code for the driver(s) involved.  *  * Fudge Factors  *  * There are no special fudge factors other than the generic and those  * explicitly defined above. The fudge time1 parameter can be used to  * compensate for miscellaneous UART and OS delays. Allow about 247 us  * for uart delays at 38400 bps and about 1 ms for SunOS streams  * nonsense.  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/pps%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|B38400
end_ifdef

begin_define
define|#
directive|define
name|SPEED232
value|B38400
end_define

begin_comment
comment|/* uart speed (38400 baud) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPEED232
value|EXTB
end_define

begin_comment
comment|/* as above */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRECISION
value|(-20)
end_define

begin_comment
comment|/* precision assumed (about 1 usec) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"PPS\0"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"PPS Clock Discipline"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|PPSMAXDISPERSE
value|(FP_SECOND / 100)
end_define

begin_comment
comment|/* max sample dispersion */
end_comment

begin_define
define|#
directive|define
name|NSAMPLES
value|32
end_define

begin_comment
comment|/* final stages of median filter */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PPS
end_ifdef

begin_define
define|#
directive|define
name|PPS_POLL
value|2
end_define

begin_comment
comment|/* ppsclock poll interval (s) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS */
end_comment

begin_comment
comment|/*  * Imported from ntp_timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time (s) */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inner space */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Imported from ntp_loopfilter module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|pps_update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prefer peer valid update */
end_comment

begin_comment
comment|/*  * Imported from ntp_proto module  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* somebody in charge */
end_comment

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|atomunit
block|{
ifdef|#
directive|ifdef
name|PPS
name|struct
name|event
name|timer
decl_stmt|;
comment|/* pps poll interval timer */
name|struct
name|ppsclockev
name|ev
decl_stmt|;
comment|/* ppsclock control */
endif|#
directive|endif
comment|/* PPS */
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|struct
name|peer
modifier|*
name|last_atom_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* peer structure pointer */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atom_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|atom_pps
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS */
end_comment

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_atom
init|=
block|{
name|atom_start
block|,
comment|/* start up driver */
name|atom_shutdown
block|,
comment|/* shut down driver */
name|atom_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old atom_control) */
name|noentry
block|,
comment|/* initialize driver */
name|noentry
block|,
comment|/* not used (old atom_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * atom_start - initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|atom_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|atomunit
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atomunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
name|pp
operator|->
name|nstages
operator|=
name|MAXSTAGE
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS
comment|/* 	 * Arm the timer for the first interrupt. Give it ten seconds to 	 * allow the ppsclock line to be configured, since it could be 	 * assigned to another driver. 	 */
name|up
operator|->
name|timer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|peer
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_handler
operator|=
name|atom_pps
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
literal|10
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS */
name|last_atom_peer
operator|=
name|peer
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * atom_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|atom_shutdown
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|last_atom_peer
operator|==
name|peer
condition|)
name|last_atom_peer
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS */
if|if
condition|(
name|pp
operator|->
name|io
operator|.
name|fd
condition|)
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pps_sample - process pps sample offset -- backwards compatible  *		interface  */
end_comment

begin_function
name|int
name|pps_sample
parameter_list|(
name|tsr
parameter_list|)
name|l_fp
modifier|*
name|tsr
decl_stmt|;
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|int
name|i
decl_stmt|;
name|l_fp
name|lftemp
decl_stmt|;
comment|/* l_fp temps */
comment|/* 	 * This routine is called once per second by an auxilliary 	 * routine in another driver. It saves the sign-extended 	 * fraction supplied in the argument in a circular buffer for 	 * processing at the next poll event. 	 */
name|peer
operator|=
name|last_atom_peer
expr_stmt|;
if|if
condition|(
operator|!
name|peer
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* no ATOM configured ? Forget it ! */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|lftemp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftemp
argument_list|,
name|tsr
operator|->
name|l_f
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|coderecv
argument_list|)
operator|)
operator|%
name|pp
operator|->
name|nstages
expr_stmt|;
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|lftemp
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pp
operator|->
name|nstages
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|filter
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|->
name|coderecv
operator|++
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
comment|/* HACK -- use the local UN*X clock to get the time -- this is wrong */
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
name|time
argument_list|(
literal|0
argument_list|)
operator|-
literal|2
operator|+
name|JAN_1970
expr_stmt|;
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PPS
end_ifdef

begin_comment
comment|/*  * atom_pps - receive data from the LDISC_PPS discipline  */
end_comment

begin_function
specifier|static
name|void
name|atom_pps
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|l_fp
name|lftmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * This routine is called once per second when the LDISC_PPS 	 * discipline is present. It snatches the pps timestamp from the 	 * kernel and saves the sign-extended fraction in a circular 	 * buffer for processing at the next poll event. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
comment|/* 	 * Arm the timer for the next interrupt 	 */
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|PPS_POLL
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the timeval to l_fp and save for billboards. Sign- 	 * extend the fraction and stash in the buffer. No harm is done 	 * if previous data are overwritten. If the discipline comes bum 	 * or the data grow stale, just forget it. 	 */
name|i
operator|=
name|up
operator|->
name|ev
operator|.
name|serial
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fdpps
argument_list|,
name|CIOGETEV
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|up
operator|->
name|ev
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|i
operator|==
name|up
operator|->
name|ev
operator|.
name|serial
condition|)
return|return;
name|pp
operator|->
name|lastrec
operator|.
name|l_ui
operator|=
name|up
operator|->
name|ev
operator|.
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|up
operator|->
name|ev
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|coderecv
argument_list|)
operator|)
operator|%
name|pp
operator|->
name|nstages
expr_stmt|;
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|lftmp
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pp
operator|->
name|nstages
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|filter
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|->
name|coderecv
operator|++
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS */
end_comment

begin_comment
comment|/*  * atom_receive - receive data from the serial line interface  */
end_comment

begin_function
specifier|static
name|void
name|atom_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|l_fp
name|lftmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * This routine is called once per second when the serial 	 * interface is in use. It snatches the timestamp from the 	 * buffer and saves the sign-extended fraction in a circular 	 * buffer for processing at the next poll event. 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
comment|/* 	 * Save the timestamp for billboards. Sign-extend the fraction 	 * and stash in the buffer. No harm is done if previous data are 	 * overwritten. 	 */
name|L_CLR
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|L_ADDF
argument_list|(
operator|&
name|lftmp
argument_list|,
name|pp
operator|->
name|lastrec
operator|.
name|l_f
argument_list|)
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|lftmp
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|pp
operator|->
name|coderecv
argument_list|)
operator|)
operator|%
name|pp
operator|->
name|nstages
expr_stmt|;
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|lftmp
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|coderecv
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pp
operator|->
name|nstages
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|filter
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|filter
index|[
literal|0
index|]
expr_stmt|;
name|pp
operator|->
name|coderecv
operator|++
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare two l_fp's - used with qsort()  */
end_comment

begin_function
specifier|static
name|int
name|atom_cmpl_fp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|register
name|void
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_comment
comment|/* l_fp to compare */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|L_ISGEQ
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|l_fp
operator|*
operator|)
name|p2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|L_ISEQU
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|l_fp
operator|*
operator|)
name|p2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * atom_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|atom_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|atomunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|l_fp
name|median
decl_stmt|,
name|lftmp
decl_stmt|;
name|l_fp
name|off
index|[
name|MAXSTAGE
index|]
decl_stmt|;
name|u_fp
name|disp
decl_stmt|;
comment|/* 	 * At each poll we check for timeout. At the first timeout we 	 * test to see if the LDISC_PPS discipline is present and, if 	 * so, use that. If not, we attempt to open a serial line with 	 * LDISC_CLKPPS discipline. If that fails, we bitch to the log 	 * and clam up. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|atomunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
name|up
operator|->
name|pollcnt
operator|--
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|pollcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pp
operator|->
name|io
operator|.
name|fd
operator|&&
name|fdpps
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
comment|/* 			 * Open serial port. Use CLKPPS line discipline, 			 * if available. If unavailable, the code works 			 * anyway, but at reduced accuracy. 			 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_CLKPPS
argument_list|)
operator|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|atom_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * Valid time (leap bits zero) is returned only if the prefer 	 * peer has survived the intersection algorithm and within 	 * CLOCK_MAX of local time and not too long ago. This insures 	 * the pps time is within +-0.5 s of the local time and the 	 * seconds numbering is unambiguous. 	 */
if|if
condition|(
name|pps_update
condition|)
block|{
name|pp
operator|->
name|leap
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
block|}
else|else
name|pp
operator|->
name|leap
operator|=
name|LEAP_NOTINSYNC
expr_stmt|;
comment|/* 	 * Copy the raw offsets and sort into ascending order 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSTAGE
condition|;
name|i
operator|++
control|)
name|off
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|filter
index|[
name|i
index|]
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|off
argument_list|,
name|pp
operator|->
name|nstages
argument_list|,
sizeof|sizeof
argument_list|(
name|l_fp
argument_list|)
argument_list|,
name|atom_cmpl_fp
argument_list|)
expr_stmt|;
comment|/* 	 * Reject the furthest from the median of nstages samples until 	 * nskeep samples remain. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|pp
operator|->
name|nstages
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|-
name|i
operator|)
operator|>
name|NSAMPLES
condition|)
block|{
name|lftmp
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|median
operator|=
name|off
index|[
operator|(
name|n
operator|+
name|i
operator|)
operator|/
literal|2
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|lftmp
argument_list|,
operator|&
name|median
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|median
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISHIS
argument_list|(
operator|&
name|median
argument_list|,
operator|&
name|lftmp
argument_list|)
condition|)
block|{
comment|/* reject low end */
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* reject high end */
name|n
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Compute the dispersion based on the difference between the 	 * extremes of the remaining offsets. Add to this the time since 	 * the last clock update, which represents the dispersion 	 * increase with time. We know that NTP_MAXSKEW is 16. If the 	 * sum is greater than the allowed sample dispersion, bail out. 	 * Otherwise, return the median offset plus the configured 	 * fudgetime1 value. 	 */
name|lftmp
operator|=
name|off
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|lftmp
argument_list|,
operator|&
name|off
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|disp
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|lftmp
argument_list|)
operator|+
name|current_time
operator|-
name|pp
operator|->
name|lasttime
expr_stmt|;
if|if
condition|(
name|disp
operator|>
name|PPSMAXDISPERSE
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|offset
operator|=
name|off
index|[
operator|(
name|n
operator|+
literal|1
operator|)
operator|/
literal|2
index|]
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
operator|&
name|pp
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|dispersion
operator|=
name|disp
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|,
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|dispersion
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
name|pp
operator|->
name|leap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

