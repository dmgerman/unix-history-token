begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpdate - set the time of day by polling one or more NTP servers  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_LINUX
end_ifdef

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSLOG_FILE
end_ifndef

begin_define
define|#
directive|define
name|SYSLOG_FILE
end_define

begin_comment
comment|/* we want to go through the syslog/printf/file code */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntpdate.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_comment
comment|/*  * Scheduling priority we run at  */
end_comment

begin_define
define|#
directive|define
name|NTPDATE_PRIO
value|(-12)
end_define

begin_comment
comment|/*  * Compatibility stuff for Version 2  */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXSKW
value|0x28f
end_define

begin_comment
comment|/* 0.01 sec in fp format */
end_comment

begin_define
define|#
directive|define
name|NTP_MINDIST
value|0x51f
end_define

begin_comment
comment|/* 0.02 sec in fp format */
end_comment

begin_define
define|#
directive|define
name|PEER_MAXDISP
value|(64*FP_SECOND)
end_define

begin_comment
comment|/* maximum dispersion (fp 64) */
end_comment

begin_define
define|#
directive|define
name|NTP_INFIN
value|15
end_define

begin_comment
comment|/* max stratum, infinity a la Bellman-Ford */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXWGT
value|(8*FP_SECOND)
end_define

begin_comment
comment|/* maximum select weight 8 seconds */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXLIST
value|5
end_define

begin_comment
comment|/* maximum select list size */
end_comment

begin_define
define|#
directive|define
name|PEER_SHIFT
value|8
end_define

begin_comment
comment|/* 8 suitable for crystal time base */
end_comment

begin_comment
comment|/*  * Debugging flag  */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File descriptor masks etc. for call to select  */
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fd_set
name|fdmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initializing flag.  All async routines watch this and only do their  * thing when it is clear.  */
end_comment

begin_decl_stmt
name|int
name|initializing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Alarm flag.  Set when an alarm occurs  */
end_comment

begin_decl_stmt
name|int
name|alarm_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Simple query flag.  */
end_comment

begin_decl_stmt
name|int
name|simple_query
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Program name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Systemwide parameters and flags  */
end_comment

begin_decl_stmt
name|int
name|sys_samples
init|=
name|DEFSAMPLES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of samples/server */
end_comment

begin_decl_stmt
name|u_long
name|sys_timeout
init|=
name|DEFTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timeout time, in TIMER_HZ units */
end_comment

begin_decl_stmt
name|struct
name|server
modifier|*
modifier|*
name|sys_servers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the server list */
end_comment

begin_decl_stmt
name|int
name|sys_numservers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of servers to poll */
end_comment

begin_decl_stmt
name|int
name|sys_maxservers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max number of servers to deal with */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true when authenticating */
end_comment

begin_decl_stmt
name|u_long
name|sys_authkey
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to authentication key in use */
end_comment

begin_decl_stmt
name|u_long
name|sys_authdelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
name|int
name|sys_version
init|=
name|NTP_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version to poll with */
end_comment

begin_comment
comment|/*  * The current internal time  */
end_comment

begin_decl_stmt
name|u_long
name|current_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Counter for keeping track of completed servers  */
end_comment

begin_decl_stmt
name|int
name|complete_servers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File of encryption keys  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KEYFILE
end_ifndef

begin_define
define|#
directive|define
name|KEYFILE
value|"/etc/ntp.keys"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KEYFILE */
end_comment

begin_decl_stmt
name|char
modifier|*
name|key_file
init|=
name|KEYFILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Miscellaneous flags  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|syslogit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|always_step
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|transmit
name|P
argument_list|(
operator|(
expr|struct
name|server
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|server_data
name|P
argument_list|(
operator|(
expr|struct
name|server
operator|*
operator|,
name|s_fp
operator|,
name|l_fp
operator|*
operator|,
name|u_fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_filter
name|P
argument_list|(
operator|(
expr|struct
name|server
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|server
modifier|*
name|clock_select
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clock_adjust
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addserver
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|server
modifier|*
name|findserver
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|timer
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_alarm
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|alarming
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_io
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|recvbuf
modifier|*
name|getrecvbufs
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freerecvbuf
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sendpkt
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
expr|struct
name|pkt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|input_handler
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|l_adj_systime
name|P
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|l_step_systime
name|P
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getnetnum
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printserver
name|P
argument_list|(
operator|(
expr|struct
name|server
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main program.  Initialize us and loop waiting for I/O and/or  * timer expiries.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|was_alarmed
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbuflist
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbuf
decl_stmt|;
name|l_fp
name|tmp
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Version
decl_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decode argument list 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:bde:k:o:p:qst:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|c
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|sys_authkey
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|always_step
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
operator|||
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: encryption delay %s is unlikely\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_authdelay
operator|=
name|tmp
operator|.
name|l_uf
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
name|key_file
operator|=
name|ntp_optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|sys_version
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|c
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
operator|||
name|c
operator|>
name|NTP_SHIFT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: number of samples (%d) is invalid\n"
argument_list|,
name|progname
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_samples
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|simple_query
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|syslogit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timeout %s is undecodeable\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_timeout
operator|=
operator|(
operator|(
name|LFPTOFP
argument_list|(
operator|&
name|tmp
argument_list|)
operator|*
name|TIMER_HZ
operator|)
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|sys_timeout
operator|==
literal|0
condition|)
name|sys_timeout
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|errflg
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|sys_maxservers
operator|=
name|argc
operator|-
name|ntp_optind
expr_stmt|;
if|if
condition|(
name|errflg
operator|||
name|sys_maxservers
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-bdqsv] [-o version] [-a key#] [-e authdelay] [-k keyfile] [-p samples] [-t timeout] server ...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|sys_servers
operator|=
operator|(
expr|struct
name|server
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|sys_maxservers
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|server
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|||
name|simple_query
condition|)
block|{
ifdef|#
directive|ifdef
name|NTP_POSIX_SOURCE
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|buf
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Logging.  Open the syslog if we have to 	 */
if|if
condition|(
name|syslogit
condition|)
block|{
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"ntpdate"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"ntpdate"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_DAEMON */
block|}
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* 	 * Add servers we are going to be polling 	 */
for|for
control|(
init|;
name|ntp_optind
operator|<
name|argc
condition|;
name|ntp_optind
operator|++
control|)
name|addserver
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_numservers
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no servers can be used, exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the time of day routines and the I/O subsystem 	 */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
name|init_auth
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|authreadkeys
argument_list|(
name|key_file
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no key file, exitting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|sys_authkey
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sys_authkey
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"authentication key %s unknown"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|init_io
argument_list|()
expr_stmt|;
name|init_alarm
argument_list|()
expr_stmt|;
comment|/* 	 * Set the priority. 	 */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATT_NICE
argument_list|)
name|nice
argument_list|(
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_NICE
argument_list|)
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initializing
operator|=
literal|0
expr_stmt|;
name|was_alarmed
operator|=
literal|0
expr_stmt|;
name|rbuflist
operator|=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|complete_servers
operator|<
name|sys_numservers
condition|)
block|{
name|fd_set
name|rdfdes
decl_stmt|;
name|int
name|nfound
decl_stmt|;
if|if
condition|(
name|alarm_flag
condition|)
block|{
comment|/* alarmed? */
name|was_alarmed
operator|=
literal|1
expr_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
block|}
name|rbuflist
operator|=
name|getrecvbufs
argument_list|()
expr_stmt|;
comment|/* get received buffers */
if|if
condition|(
operator|!
name|was_alarmed
operator|&&
name|rbuflist
operator|==
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
condition|)
block|{
comment|/*                          * Nothing to do.  Wait for something.                          */
name|rdfdes
operator|=
name|fdmask
expr_stmt|;
name|nfound
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|rdfdes
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfound
operator|>
literal|0
condition|)
name|input_handler
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nfound
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() error: %m"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alarm_flag
condition|)
block|{
comment|/* alarmed? */
name|was_alarmed
operator|=
literal|1
expr_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
block|}
name|rbuflist
operator|=
name|getrecvbufs
argument_list|()
expr_stmt|;
comment|/* get received buffers */
block|}
comment|/* 		 * Out here, signals are unblocked.  Call receive 		 * procedure for each incoming packet. 		 */
while|while
condition|(
name|rbuflist
operator|!=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
condition|)
block|{
name|rbuf
operator|=
name|rbuflist
expr_stmt|;
name|rbuflist
operator|=
name|rbuf
operator|->
name|next
expr_stmt|;
name|receive
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Call timer to process any timeouts 		 */
if|if
condition|(
name|was_alarmed
condition|)
block|{
name|timer
argument_list|()
expr_stmt|;
name|was_alarmed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Go around again 		 */
block|}
comment|/* 	 * When we get here we've completed the polling of all servers. 	 * Adjust the clock, then exit. 	 */
name|exit
argument_list|(
name|clock_adjust
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * transmit - transmit a packet to the given server, or mark it completed.  *	      This is called by the timeout routine and by the receive  *	      procedure.  */
end_comment

begin_function
specifier|static
name|void
name|transmit
parameter_list|(
name|server
parameter_list|)
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|filter_nextpt
operator|<
name|server
operator|->
name|xmtcnt
condition|)
block|{
name|l_fp
name|ts
decl_stmt|;
comment|/* 		 * Last message to this server timed out.  Shift 		 * zeros into the filter. 		 */
name|L_CLR
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|server_data
argument_list|(
name|server
argument_list|,
literal|0
argument_list|,
operator|&
name|ts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|server
operator|->
name|filter_nextpt
operator|>=
name|sys_samples
condition|)
block|{
comment|/* 		 * Got all the data we need.  Mark this guy 		 * completed and return. 		 */
name|server
operator|->
name|event_time
operator|=
literal|0
expr_stmt|;
name|complete_servers
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're here, send another message to the server.  Fill in 	 * the packet and let 'er rip. 	 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|sys_version
argument_list|,
name|MODE_CLIENT
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|NTPDATE_PRECISION
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|htonl
argument_list|(
name|NTPDATE_DISTANCE
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|htonl
argument_list|(
name|NTPDATE_DISP
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|htonl
argument_list|(
name|NTPDATE_REFID
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * Determine whether to authenticate or not.  If so, 	 * fill in the extended part of the packet and do it. 	 * If not, just timestamp it and send it away. 	 */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
name|int
name|len
decl_stmt|;
name|xpkt
operator|.
name|keyid
operator|=
name|htonl
argument_list|(
name|sys_authkey
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|auth2crypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit auth to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_systime
argument_list|(
operator|&
operator|(
name|server
operator|->
name|xmt
operator|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the server timeout and transmit count 	 */
name|server
operator|->
name|event_time
operator|=
name|current_time
operator|+
name|sys_timeout
expr_stmt|;
name|server
operator|->
name|xmtcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - receive and process an incoming frame  */
end_comment

begin_function
specifier|static
name|void
name|receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
specifier|register
name|s_fp
name|di
decl_stmt|;
name|l_fp
name|t10
decl_stmt|,
name|t23
decl_stmt|;
name|l_fp
name|org
decl_stmt|;
name|l_fp
name|rec
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|is_authentic
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if the packet basically looks like something 	 * intended for us. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|LEN_PKT_NOMAC
condition|)
name|has_mac
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|LEN_PKT_NOMAC
condition|)
name|has_mac
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: packet length %d\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
return|return;
comment|/* funny length packet */
block|}
name|rpkt
operator|=
operator|&
operator|(
name|rbufp
operator|->
name|recv_pkt
operator|)
expr_stmt|;
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_SERVER
operator|&&
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_PASSIVE
operator|)
operator|||
name|rpkt
operator|->
name|stratum
operator|>
name|NTP_MAXSTRATUM
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: mode %d stratum %d\n"
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * So far, so good.  See if this is from a server we know. 	 */
name|server
operator|=
name|findserver
argument_list|(
operator|&
operator|(
name|rbufp
operator|->
name|srcadr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: server not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Decode the org timestamp and make sure we're getting a response 	 * to our last request. 	 */
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|org
argument_list|,
operator|&
name|org
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|org
argument_list|,
operator|&
name|server
operator|->
name|xmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: pkt.org and peer.xmt differ\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check out the authenticity if we're doing that. 	 */
if|if
condition|(
operator|!
name|sys_authenticate
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|is_authentic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: rpkt keyid=%ld sys_authkey=%ld decrypt=%ld\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|ntohl
argument_list|(
name|rpkt
operator|->
name|keyid
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|sys_authkey
argument_list|,
operator|(
name|long
name|int
operator|)
name|authdecrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|rpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mac
operator|&&
name|ntohl
argument_list|(
name|rpkt
operator|->
name|keyid
argument_list|)
operator|==
name|sys_authkey
operator|&&
name|authdecrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|U_LONG
operator|*
operator|)
name|rpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: authentication %s\n"
argument_list|,
name|is_authentic
condition|?
literal|"passed"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
block|}
name|server
operator|->
name|trust
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_authentic
condition|)
name|server
operator|->
name|trust
operator||=
literal|1
expr_stmt|;
comment|/* 	 * Looks good.  Record info from the packet. 	 */
name|server
operator|->
name|leap
operator|=
name|PKT_LEAP
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|server
operator|->
name|stratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|server
operator|->
name|precision
operator|=
name|rpkt
operator|->
name|precision
expr_stmt|;
name|server
operator|->
name|rootdelay
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|server
operator|->
name|rootdispersion
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|rootdispersion
argument_list|)
expr_stmt|;
name|server
operator|->
name|refid
operator|=
name|rpkt
operator|->
name|refid
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|reftime
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|rec
argument_list|,
operator|&
name|rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|xmt
argument_list|,
operator|&
name|server
operator|->
name|org
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the server is at least somewhat sane.  If not, try 	 * again. 	 */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|rec
argument_list|)
operator|||
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|rec
argument_list|)
condition|)
block|{
name|transmit
argument_list|(
name|server
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Calculate the round trip delay (di) and the clock offset (ci). 	 * We use the equations (reordered from those in the spec): 	 * 	 * d = (t2 - t3) - (t1 - t0) 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 */
name|t10
operator|=
name|server
operator|->
name|org
expr_stmt|;
comment|/* pkt.xmt == t1 */
name|L_SUB
argument_list|(
operator|&
name|t10
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
comment|/* recv_time == t0*/
name|t23
operator|=
name|rec
expr_stmt|;
comment|/* pkt.rec == t2 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|org
argument_list|)
expr_stmt|;
comment|/* pkt->org == t3 */
comment|/* now have (t2 - t3) and (t0 - t1).  Calculate (ci) and (di) */
name|ci
operator|=
name|t10
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t23
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate di in t23 in full precision, then truncate 	 * to an s_fp. 	 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|di
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|t23
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"offset: %s, delay %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|ci
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|di
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|+=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|NTPDATE_PRECISION
operator|)
operator|)
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|server
operator|->
name|precision
operator|)
operator|)
operator|+
name|NTP_MAXSKW
expr_stmt|;
if|if
condition|(
name|di
operator|<=
literal|0
condition|)
block|{
comment|/* value still too raunchy to use? */
name|L_CLR
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|di
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|di
operator|=
name|max
argument_list|(
name|di
argument_list|,
name|NTP_MINDIST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shift this data in, then transmit again. 	 */
name|server_data
argument_list|(
name|server
argument_list|,
operator|(
name|u_fp
operator|)
name|di
argument_list|,
operator|&
name|ci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|transmit
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * server_data - add a sample to the server's filter registers  */
end_comment

begin_function
specifier|static
name|void
name|server_data
parameter_list|(
name|server
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|,
name|e
parameter_list|)
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|s_fp
name|d
decl_stmt|;
name|l_fp
modifier|*
name|c
decl_stmt|;
name|u_fp
name|e
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|server
operator|->
name|filter_nextpt
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|NTP_SHIFT
condition|)
block|{
name|server
operator|->
name|filter_delay
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
name|server
operator|->
name|filter_offset
index|[
name|i
index|]
operator|=
operator|*
name|c
expr_stmt|;
name|server
operator|->
name|filter_soffset
index|[
name|i
index|]
operator|=
name|LFPTOFP
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|server
operator|->
name|filter_error
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
name|server
operator|->
name|filter_nextpt
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clock_filter - determine a server's delay, dispersion and offset  */
end_comment

begin_function
specifier|static
name|void
name|clock_filter
parameter_list|(
name|server
parameter_list|)
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* 	 * Sort indices into increasing delay order 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_samples
condition|;
name|i
operator|++
control|)
name|ord
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sys_samples
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|sys_samples
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|j
index|]
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|==
literal|0
operator|||
operator|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|>
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|j
index|]
index|]
operator|)
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now compute the dispersion, and assign values to delay and 	 * offset.  If there are no samples in the register, delay and 	 * offset go to zero and dispersion is set to the maximum. 	 */
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|server
operator|->
name|delay
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
expr_stmt|;
name|server
operator|->
name|soffset
operator|=
literal|0
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|s_fp
name|d
decl_stmt|;
name|server
operator|->
name|delay
operator|=
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|server
operator|->
name|offset
operator|=
name|server
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|server
operator|->
name|soffset
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sys_samples
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|==
literal|0
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
else|else
block|{
name|d
operator|=
name|server
operator|->
name|filter_soffset
index|[
name|ord
index|[
name|i
index|]
index|]
operator|-
name|server
operator|->
name|filter_soffset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|PEER_MAXDISP
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
comment|/* 			 * XXX This *knows* PEER_FILTER is 1/2 			 */
name|server
operator|->
name|dispersion
operator|+=
call|(
name|u_fp
call|)
argument_list|(
name|d
argument_list|)
operator|>>
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * We're done 	 */
block|}
end_function

begin_comment
comment|/*  * clock_select - select the pick-of-the-litter clock from the samples  *		  we've got.  */
end_comment

begin_function
specifier|static
name|struct
name|server
modifier|*
name|clock_select
parameter_list|()
block|{
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nlist
decl_stmt|;
specifier|register
name|s_fp
name|d
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|s_fp
name|local_threshold
decl_stmt|;
name|struct
name|server
modifier|*
name|server_list
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|u_fp
name|server_badness
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|server
modifier|*
name|sys_server
decl_stmt|;
comment|/* 	 * This first chunk of code is supposed to go through all 	 * servers we know about to find the NTP_MAXLIST servers which 	 * are most likely to succeed.  We run through the list 	 * doing the sanity checks and trying to insert anyone who 	 * looks okay.  We are at all times aware that we should 	 * only keep samples from the top two strata and we only need 	 * NTP_MAXLIST of them. 	 */
name|nlist
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sys_numservers
condition|;
name|n
operator|++
control|)
block|{
name|server
operator|=
name|sys_servers
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|delay
operator|==
literal|0
condition|)
continue|continue;
comment|/* no data */
if|if
condition|(
name|server
operator|->
name|stratum
operator|>
name|NTP_INFIN
condition|)
continue|continue;
comment|/* stratum no good */
if|if
condition|(
name|server
operator|->
name|delay
operator|>
name|NTP_MAXWGT
condition|)
block|{
continue|continue;
comment|/* too far away */
block|}
if|if
condition|(
name|server
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
continue|continue;
comment|/* he's in trouble */
if|if
condition|(
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
condition|)
block|{
continue|continue;
comment|/* very broken host */
block|}
if|if
condition|(
operator|(
name|server
operator|->
name|org
operator|.
name|l_ui
operator|-
name|server
operator|->
name|reftime
operator|.
name|l_ui
operator|)
operator|>=
name|NTP_MAXAGE
condition|)
block|{
continue|continue;
comment|/* too long without sync */
block|}
if|if
condition|(
name|server
operator|->
name|trust
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * This one seems sane.  Find where he belongs 		 * on the list. 		 */
name|d
operator|=
name|server
operator|->
name|dispersion
operator|+
name|server
operator|->
name|dispersion
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|server
operator|->
name|stratum
operator|<=
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
condition|)
break|break;
for|for
control|(
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|stratum
operator|<
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
condition|)
break|break;
if|if
condition|(
name|d
operator|<
name|server_badness
index|[
name|i
index|]
condition|)
break|break;
block|}
comment|/* 		 * If i points past the end of the list, this 		 * guy is a loser, else stick him in. 		 */
if|if
condition|(
name|i
operator|>=
name|NTP_MAXLIST
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|nlist
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|j
operator|<
name|NTP_MAXLIST
condition|)
block|{
name|server_list
index|[
name|j
index|]
operator|=
name|server_list
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|server_badness
index|[
name|j
index|]
operator|=
name|server_badness
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|server_list
index|[
name|i
index|]
operator|=
name|server
expr_stmt|;
name|server_badness
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|nlist
operator|<
name|NTP_MAXLIST
condition|)
name|nlist
operator|++
expr_stmt|;
block|}
comment|/* 	 * Got the five-or-less best.  Cut the list where the number of 	 * strata exceeds two. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
operator|>
name|server_list
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|stratum
condition|)
if|if
condition|(
operator|++
name|j
operator|==
literal|2
condition|)
block|{
name|nlist
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* 	 * Whew!  What we should have by now is 0 to 5 candidates for 	 * the job of syncing us.  If we have none, we're out of luck. 	 * If we have one, he's a winner.  If we have more, do falseticker 	 * detection. 	 */
if|if
condition|(
name|nlist
operator|==
literal|0
condition|)
name|sys_server
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nlist
operator|==
literal|1
condition|)
block|{
name|sys_server
operator|=
name|server_list
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Re-sort by stratum, bdelay estimate quality and 		 * server.delay. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
operator|-
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
operator|<
name|server_list
index|[
name|j
index|]
operator|->
name|stratum
condition|)
break|break;
comment|/* already sorted by stratum */
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|delay
operator|<
name|server_list
index|[
name|j
index|]
operator|->
name|delay
condition|)
continue|continue;
name|server
operator|=
name|server_list
index|[
name|i
index|]
expr_stmt|;
name|server_list
index|[
name|i
index|]
operator|=
name|server_list
index|[
name|j
index|]
expr_stmt|;
name|server_list
index|[
name|j
index|]
operator|=
name|server
expr_stmt|;
block|}
comment|/* 		 * Calculate the fixed part of the dispersion limit 		 */
name|local_threshold
operator|=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|NTPDATE_PRECISION
operator|)
operator|)
operator|+
name|NTP_MAXSKW
expr_stmt|;
comment|/* 		 * Now drop samples until we're down to one. 		 */
while|while
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nlist
condition|;
name|n
operator|++
control|)
block|{
name|server_badness
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|n
condition|)
comment|/* with self? */
continue|continue;
name|d
operator|=
name|server_list
index|[
name|j
index|]
operator|->
name|soffset
operator|-
name|server_list
index|[
name|n
index|]
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
comment|/* absolute value */
name|d
operator|=
operator|-
name|d
expr_stmt|;
comment|/* 					 * XXX This code *knows* that 					 * NTP_SELECT is 3/4 					 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|>>
literal|2
operator|)
expr_stmt|;
name|server_badness
index|[
name|n
index|]
operator|+=
name|d
expr_stmt|;
block|}
block|}
comment|/* 			 * We now have an array of nlist badness 			 * coefficients.  Find the badest.  Find 			 * the minimum precision while we're at 			 * it. 			 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|server_list
index|[
literal|0
index|]
operator|->
name|precision
expr_stmt|;
empty_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server_badness
index|[
name|j
index|]
operator|>=
name|server_badness
index|[
name|i
index|]
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|server_list
index|[
name|j
index|]
operator|->
name|precision
condition|)
name|n
operator|=
name|server_list
index|[
name|j
index|]
operator|->
name|precision
expr_stmt|;
block|}
comment|/* 			 * i is the index of the server with the worst 			 * dispersion.  If his dispersion is less than 			 * the threshold, stop now, else delete him and 			 * continue around again. 			 */
if|if
condition|(
name|server_badness
index|[
name|i
index|]
operator|<
operator|(
name|local_threshold
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
name|n
operator|)
operator|)
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|server_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|server_list
index|[
name|j
index|]
expr_stmt|;
name|nlist
operator|--
expr_stmt|;
block|}
comment|/* 		 * What remains is a list of less than 5 servers.  Take 		 * the best. 		 */
name|sys_server
operator|=
name|server_list
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * That's it.  Return our server. 	 */
return|return
name|sys_server
return|;
block|}
end_function

begin_comment
comment|/*  * clock_adjust - process what we've received, and adjust the time  *	         if we got anything decent.  */
end_comment

begin_function
specifier|static
name|int
name|clock_adjust
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|s_fp
name|absoffset
decl_stmt|;
name|int
name|dostep
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
name|clock_filter
argument_list|(
name|sys_servers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|server
operator|=
name|clock_select
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
operator|||
name|simple_query
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
name|printserver
argument_list|(
name|sys_servers
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|server
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no server suitable for synchronization found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dostep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|always_step
condition|)
block|{
name|absoffset
operator|=
name|server
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|absoffset
operator|<
literal|0
condition|)
name|absoffset
operator|=
operator|-
name|absoffset
expr_stmt|;
if|if
condition|(
name|absoffset
operator|<
name|NTPDATE_THRESHOLD
condition|)
name|dostep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dostep
condition|)
block|{
if|if
condition|(
name|simple_query
operator|||
name|l_step_systime
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"step time server %s offset %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|simple_query
operator|||
name|l_adj_systime
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"adjust time server %s offset %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE: merge BIG slew into adj_systime in lib/systime.c */
end_comment

begin_comment
comment|/*  * addserver - determine a server's address and allocate a new structure  *	       for it.  */
end_comment

begin_function
specifier|static
name|void
name|addserver
parameter_list|(
name|serv
parameter_list|)
name|char
modifier|*
name|serv
decl_stmt|;
block|{
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|u_long
name|netnum
decl_stmt|;
specifier|static
name|int
name|toomany
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sys_numservers
operator|>=
name|sys_maxservers
condition|)
block|{
if|if
condition|(
operator|!
name|toomany
condition|)
block|{
comment|/* 			 * This is actually a `can't happen' now.  Leave 			 * the error message in anyway, though 			 */
name|toomany
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"too many servers (> %d) specified, remainder not used"
argument_list|,
name|sys_maxservers
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|serv
argument_list|,
operator|&
name|netnum
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't find host %s\n"
argument_list|,
name|serv
argument_list|)
expr_stmt|;
return|return;
block|}
name|server
operator|=
operator|(
expr|struct
name|server
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|->
name|srcadr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|netnum
expr_stmt|;
name|server
operator|->
name|srcadr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|sys_servers
index|[
name|sys_numservers
operator|++
index|]
operator|=
name|server
expr_stmt|;
name|server
operator|->
name|event_time
operator|=
name|sys_numservers
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * findserver - find a server in the list given its address  */
end_comment

begin_function
specifier|static
name|struct
name|server
modifier|*
name|findserver
parameter_list|(
name|addr
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
name|netnum
decl_stmt|;
if|if
condition|(
name|htons
argument_list|(
name|addr
operator|->
name|sin_port
argument_list|)
operator|!=
name|NTP_PORT
condition|)
return|return
literal|0
return|;
name|netnum
operator|=
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|netnum
operator|==
name|sys_servers
index|[
name|i
index|]
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
name|sys_servers
index|[
name|i
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * timer - process a timer interrupt  */
end_comment

begin_function
specifier|static
name|void
name|timer
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Bump the current idea of the time 	 */
name|current_time
operator|++
expr_stmt|;
comment|/* 	 * Search through the server list looking for guys 	 * who's event timers have expired.  Give these to 	 * the transmit routine. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sys_servers
index|[
name|i
index|]
operator|->
name|event_time
operator|!=
literal|0
operator|&&
name|sys_servers
index|[
name|i
index|]
operator|->
name|event_time
operator|<=
name|current_time
condition|)
name|transmit
argument_list|(
name|sys_servers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * init_alarm - set up the timer interrupt  */
end_comment

begin_function
specifier|static
name|void
name|init_alarm
parameter_list|()
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up the alarm interrupt.  The first comes 1/(2*TIMER_HZ) 	 * seconds from now and they continue on every 1/TIMER_HZ seconds. 	 */
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|1000000
operator|/
name|TIMER_HZ
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|1000000
operator|/
operator|(
name|TIMER_HZ
operator|<<
literal|1
operator|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * alarming - record the occurance of an alarm interrupt  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|alarm_flag
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.  In the signal  * handler we poll to see if the socket is ready and read the  * packets from it into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We allocate a number of recvbufs equal to the number of servers  * plus 2.  This should be plenty.  */
end_comment

begin_comment
comment|/*  * recvbuf lists  */
end_comment

begin_decl_stmt
name|struct
name|recvbuf
modifier|*
name|freelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free buffers */
end_comment

begin_decl_stmt
name|struct
name|recvbuf
modifier|*
name|fulllist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers with data */
end_comment

begin_decl_stmt
name|int
name|full_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of full ones */
end_comment

begin_decl_stmt
name|int
name|free_recvbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_io - initialize I/O data and open socket  */
end_comment

begin_function
specifier|static
name|void
name|init_io
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
comment|/* 	 * Init buffer free list and stat counters 	 */
name|rb
operator|=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|sys_numservers
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|recvbuf
argument_list|)
argument_list|)
expr_stmt|;
name|freelist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sys_numservers
operator|+
literal|2
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rb
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
expr_stmt|;
name|rb
operator|++
expr_stmt|;
block|}
name|fulllist
operator|=
literal|0
expr_stmt|;
name|full_recvbufs
operator|=
literal|0
expr_stmt|;
name|free_recvbufs
operator|=
name|sys_numservers
operator|+
literal|2
expr_stmt|;
comment|/* 	 * Open the socket 	 */
comment|/* create a datagram (UDP) socket */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * bind the socket to the NTP port 	 */
if|if
condition|(
operator|!
name|debug
operator|&&
operator|!
name|simple_query
condition|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"the NTP socket is in use, exiting"
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind() fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|FD_ZERO
argument_list|(
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
comment|/*          * set non-blocking,          */
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* O_NONBLOCK */
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* FNDELAY */
name|Need
name|non
name|blocking
name|I
operator|/
name|O
endif|#
directive|endif
comment|/* FNDELAY */
endif|#
directive|endif
comment|/* O_NONBLOCK */
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE getrecvbufs (almost) identical to ntpdate.c, ntptrace.c, ntp_io.c */
end_comment

begin_comment
comment|/*  * getrecvbufs - get receive buffers which have data in them  *  * ***N.B. must be called with SIGIO blocked***  */
end_comment

begin_function
specifier|static
name|struct
name|recvbuf
modifier|*
name|getrecvbufs
parameter_list|()
block|{
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
if|if
condition|(
name|full_recvbufs
operator|==
literal|0
condition|)
block|{
return|return
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
return|;
comment|/* nothing has arrived */
block|}
comment|/* 	 * Get the fulllist chain and mark it empty 	 */
name|rb
operator|=
name|fulllist
expr_stmt|;
name|fulllist
operator|=
literal|0
expr_stmt|;
name|full_recvbufs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Return the chain 	 */
return|return
name|rb
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE freerecvbuf (almost) identical to ntpdate.c, ntptrace.c, ntp_io.c */
end_comment

begin_comment
comment|/*  * freerecvbuf - make a single recvbuf available for reuse  */
end_comment

begin_function
specifier|static
name|void
name|freerecvbuf
parameter_list|(
name|rb
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
block|{
name|rb
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sendpkt - send a packet to the specified destination  */
end_comment

begin_function
specifier|static
name|void
name|sendpkt
parameter_list|(
name|dest
parameter_list|,
name|pkt
parameter_list|,
name|len
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|dest
decl_stmt|;
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
name|cc
operator|=
name|sendto
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s): %m"
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * input_handler - receive packets asynchronously  */
end_comment

begin_function
specifier|static
name|void
name|input_handler
parameter_list|()
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
comment|/* 	 * Do a poll to see if we have data 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|fds
operator|=
name|fdmask
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
comment|/* 		 * If nothing to do, just return.  If an error occurred, 		 * complain and return.  If we've got some, freeze a 		 * timestamp. 		 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() error: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 		 * Get a buffer and read the frame.  If we 		 * haven't got a buffer, or this is received 		 * on the wild card socket, just dump the packet. 		 */
if|if
condition|(
name|initializing
operator|||
name|free_recvbufs
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rb
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
operator|->
name|next
expr_stmt|;
name|free_recvbufs
operator|--
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_pkt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|rb
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|rb
expr_stmt|;
name|free_recvbufs
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Got one.  Mark how and when it got here, 		 * put it on the full list. 		 */
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|rb
operator|->
name|next
operator|=
name|fulllist
expr_stmt|;
name|fulllist
operator|=
name|rb
expr_stmt|;
name|full_recvbufs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * adj_systime - do a big long slew of the system time  */
end_comment

begin_function
specifier|static
name|int
name|l_adj_systime
parameter_list|(
name|ts
parameter_list|)
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|,
name|oadjtv
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
name|l_fp
name|overshoot
decl_stmt|;
comment|/* 	 * Take the absolute value of the offset 	 */
name|offset
operator|=
operator|*
name|ts
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|offset
argument_list|)
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|STEP_SLEW
comment|/* 	 * Calculate the overshoot.  XXX N.B. This code *knows* 	 * ADJ_OVERSHOOT is 1/2. 	 */
name|overshoot
operator|=
name|offset
expr_stmt|;
name|L_RSHIFTU
argument_list|(
operator|&
name|overshoot
argument_list|)
expr_stmt|;
if|if
condition|(
name|overshoot
operator|.
name|l_ui
operator|!=
literal|0
operator|||
operator|(
name|overshoot
operator|.
name|l_uf
operator|>
name|ADJ_MAXOVERSHOOT
operator|)
condition|)
block|{
name|overshoot
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|overshoot
operator|.
name|l_uf
operator|=
name|ADJ_MAXOVERSHOOT
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|overshoot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TSTOTV
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|adjtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
name|adjtv
operator|.
name|tv_usec
operator|!=
literal|0
operator|&&
operator|!
name|debug
condition|)
block|{
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|adjtv
argument_list|,
operator|&
name|oadjtv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't adjust the time of day: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This fuction is not the same as lib/systime step_systime!!!  */
end_comment

begin_function
specifier|static
name|int
name|l_step_systime
parameter_list|(
name|ts
parameter_list|)
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SLEWALWAYS
ifdef|#
directive|ifdef
name|STEP_SLEW
name|l_fp
name|ftmp
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|debug
condition|)
return|return
literal|1
return|;
comment|/* 	 * Take the absolute value of the offset 	 */
name|ftmp
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|ftmp
argument_list|)
condition|)
block|{
name|L_NEG
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp_ui
operator|>=
literal|3
condition|)
block|{
comment|/* Step it and slew - we might win */
name|n
operator|=
name|step_systime_real
argument_list|(
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|n
return|;
if|if
condition|(
name|isneg
condition|)
name|ts
operator|->
name|l_ui
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|ts
operator|->
name|l_ui
operator|=
operator|~
literal|0
expr_stmt|;
block|}
comment|/*          * Just add adjustment into the current offset.  The update          * routine will take care of bringing the system clock into          * line.          */
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|FORCE_NTPDATE_STEP
return|return
name|step_systime_real
argument_list|(
name|ts
argument_list|)
return|;
else|#
directive|else
name|l_adj_systime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
else|#
directive|else
comment|/* SLEWALWAYS  */
if|if
condition|(
name|debug
condition|)
return|return
literal|1
return|;
return|return
name|step_systime_real
argument_list|(
name|ts
argument_list|)
return|;
endif|#
directive|endif
comment|/* SLEWALWAYS */
block|}
end_function

begin_comment
comment|/*  * getnetnum - given a host name, return its net number  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
name|host
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|u_long
modifier|*
name|num
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|decodenetnum
argument_list|(
name|host
argument_list|,
name|num
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|U_LONG
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE printserver similar in ntptrace.c, ntpdate.c */
end_comment

begin_comment
comment|/*  * printserver - print detail information for a server  */
end_comment

begin_function
specifier|static
name|void
name|printserver
parameter_list|(
name|pp
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|struct
name|server
modifier|*
name|pp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|junk
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server %s, stratum %d, offset %s, delay %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
argument_list|,
name|pp
operator|->
name|stratum
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server %s, port %d\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|pp
operator|->
name|srcadr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"stratum %d, precision %d, leap %c%c, trust %03o\n"
argument_list|,
name|pp
operator|->
name|stratum
argument_list|,
name|pp
operator|->
name|precision
argument_list|,
name|pp
operator|->
name|leap
operator|&
literal|0x2
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|pp
operator|->
name|leap
operator|&
literal|0x1
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|pp
operator|->
name|trust
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|stratum
operator|==
literal|1
condition|)
block|{
name|junk
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|memmove
argument_list|(
name|junk
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|str
operator|=
name|junk
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|numtoa
argument_list|(
name|pp
operator|->
name|refid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"refid [%s], delay %s, dispersion %s\n"
argument_list|,
name|str
argument_list|,
name|fptoa
argument_list|(
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"transmitted %d, in filter %d\n"
argument_list|,
name|pp
operator|->
name|xmtcnt
argument_list|,
name|pp
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"reference time:      %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|reftime
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"originate timestamp: %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|org
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"transmit timestamp:  %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|xmt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"filter delay: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-8.8s"
argument_list|,
name|fptoa
argument_list|(
name|pp
operator|->
name|filter_delay
index|[
name|i
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|NTP_SHIFT
operator|>>
literal|1
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"filter offset:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEER_SHIFT
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-8.8s"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|filter_offset
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|PEER_SHIFT
operator|>>
literal|1
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n              "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %s, dispersion %s\n"
argument_list|,
name|fptoa
argument_list|(
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"offset %s\n\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_VSPRINTF
argument_list|)
end_if

begin_comment
comment|/*  * This nugget for pre-tahoe 4.3bsd systems  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
operator|!
name|__STDC__
end_if

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|vsprintf
parameter_list|(
name|str
parameter_list|,
name|fmt
parameter_list|,
name|ap
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|FILE
name|f
decl_stmt|;
name|int
name|len
decl_stmt|;
name|f
operator|.
name|_flag
operator|=
name|_IOWRT
operator|+
name|_IOSTRG
expr_stmt|;
name|f
operator|.
name|_ptr
operator|=
name|str
expr_stmt|;
name|f
operator|.
name|_cnt
operator|=
literal|32767
expr_stmt|;
name|len
operator|=
name|_doprnt
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
operator|*
name|f
operator|.
name|_ptr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

