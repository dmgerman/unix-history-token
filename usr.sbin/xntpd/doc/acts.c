begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_acts - clock driver for the NIST Automated Computer Time  *	Service aka Amalgamated Containerized Trash Service (ACTS)  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|ACTS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * This driver supports the NIST Automated Computer Time Service (ACTS).  * It periodically dials a prespecified telephone number, receives the  * NIST timecode data and calculates the local clock correction. It is  * designed primarily for use as a backup when neither a radio clock nor  * connectivity to Internet time servers is available. For the best  * accuracy, the individual telephone line/modem delay needs to be  * calibrated using outside sources.  *  * The ACTS is located at NIST Boulder, CO, telephone 303 494 4774. A  * toll call from a residence telephone in Newark, DE, costs between 14  * and 27 cents, depending on time of day, and from a campus telephone  * between 3 and 4 cents, although it is not clear what carrier and time  * of day discounts apply in this case. The modem dial string will  * differ depending on local telephone configuration, etc., and is  * specified by the phone command in the configuration file. The  * argument to this command is an AT command for a Hayes compatible  * modem.  *  * The accuracy produced by this driver should be in the range of a  * millisecond or two, but may need correction due to the delay  * characteristics of the individual modem involved. For undetermined  * reasons, some modems work with the ACTS echo-delay measurement scheme  * and some don't. This driver tries to do the best it can with what it  * gets. Initial experiments with a Practical Peripherals 9600SA modem  * here in Delaware suggest an accuracy of a millisecond or two can be  * achieved without the scheme by using a fudge time1 value of 65.0 ms.  * In either case, the dispersion for a single call involving ten  * samples is about 1.3 ms.  *  * The driver can operate in either of two modes, as determined by the  * mode parameter in the server configuration command. In mode 0 the  * driver operates continuously at intervals determined by the fudge  * time1 parameter, as described above. In mode 1 the driver is enabled  * only when no other sources of synchronization are available and when  * we have gone more than MAXOUTAGE (3600 s) since last synchronized by  * other sources of synchronization.  *  * For reliable call management, this driver requires a 1200-bps modem  * with a Hayes-compatible command set and control over the modem data  * terminal ready (DTR) control line. Present restrictions require the  * use of a POSIX-compatible programming interface, although other  * interfaces may work as well. The modem setup string is hard-coded in  * the driver and may require changes for nonstandard modems or special  * circumstances.  *  * Further information can be found in the README.refclock file in the  * xntp3 distribution.  *  * Fudge Factors  *  * Ordinarily, the propagation time correction is computed automatically  * by ACTS and the driver. When this is not possible or erratic due to  * individual modem characteristics, the fudge flag2 switch should be  * set to disable the ACTS echo-delay scheme. In any case, the fudge  * time1 parameter can be used to adjust the propagation delay as  * required.  *  * The ACTS call interval is determined in one of three ways. In MANUAL  * mode a call is initiated by setting fudge flag1 using xntpdc, either  * manually or via a cron job. In AUTO mode this flag is set by the peer  * timer, which is controlled by the sys_poll variable in response to  * measured errors. In BACKUP mode the driver is ordinarily asleep, but  * awakes (in AUTO mode) if all other synchronization sources are lost.  * In either AUTO or BACKUP modes, the call interval increases as long  * as the measured errors do not exceed the value of the fudge time2  * parameter.  *  * When the fudge flag1 is set, the ACTS calling program is activated.  * This program dials each number listed in the phones command of the  * configuration file in turn. If a call attempt fails, the next number  * in the list is dialed. The fudge flag1 and counter are reset and the  * calling program terminated if (a) a valid clock update has been  * determined, (b) no more numbers remain in the list, (c) a device  * fault or timeout occurs or (d) fudge flag1 is reset manually using  * xntpdc.  */
end_comment

begin_comment
comment|/*  * DESCRIPTION OF THE AUTOMATED COMPUTER TELEPHONE SERVICE (ACTS)  * (reformatted from ACTS on-line computer help information)  *  * The following is transmitted (at 1200 baud) following completion of  * the telephone connection.  *  * National Institute of Standards and Technology  * Telephone Time Service, Generator 3B  * Enter question mark "?" for HELP  *                         D  L D  *  MJD  YR MO DA H  M  S  ST S UT1 msADV<OTM>  * 47999 90-04-18 21:39:15 50 0 +.1 045.0 UTC(NIST) *  * 47999 90-04-18 21:39:16 50 0 +.1 045.0 UTC(NIST) *  * 47999 90-04-18 21:39:17 50 0 +.1 045.0 UTC(NIST) *  * 47999 90-04-18 21:39:18 50 0 +.1 045.0 UTC(NIST) *  * 47999 90-04-18 21:39:19 50 0 +.1 037.6 UTC(NIST) #  * 47999 90-04-18 21:39:20 50 0 +.1 037.6 UTC(NIST) #  * etc..etc...etc.......  *  * UTC = Universal Time Coordinated, the official world time referred to  * the zero meridian.  *  * DST	Daylight savings time characters, valid for the continental  *	U.S., are set as follows:  *  *	00	We are on standard time (ST).  *	01-49	Now on DST, go to ST when your local time is 2:00 am and  *		the count is 01. The count is decremented daily at 00  *		(UTC).  *	50	We are on DST.  *	51-99	Now on ST, go to DST when your local time is 2:00 am and  *		the count is 51. The count is decremented daily at 00  *		(UTC).  *  *	The two DST characters provide up to 48 days advance notice of a  *	change in time. The count remains at 00 or 50 at other times.  *  * LS	Leap second flag is set to "1" to indicate that a leap second is  *	to be added as 23:59:60 (UTC) on the last day of the current UTC  *	month. The LS flag will be reset to "0" starting with 23:59:60  *	(UTC). The flag will remain on for the entire month before the  *	second is added. Leap seconds are added as needed at the end of  *	any month. Usually June and/or December are chosen.  *  *	The leap second flag will be set to a "2" to indicate that a  *	leap second is to be deleted at 23:59:58--00:00:00 on the last  *	day of the current month. (This latter provision is included per  *	international recommendation, however it is not likely to be  *	required in the near future.)  *  * DUT1	Approximate difference between earth rotation time (UT1) and  *	UTC, in steps of 0.1 second: DUT1 = UT1 - UTC.  *  * MJD	Modified Julian Date, often used to tag certain scientific data.  *  * The full time format is sent at 1200 baud, 8 bit, 1 stop, no parity.  * The format at 300 Baud is also 8 bit, 1 stop, no parity. At 300 Baud  * the MJD and DUT1 values are deleted and the time is transmitted only  * on even seconds.  *  * Maximum on line time will be 56 seconds. If all lines are busy at any  * time, the oldest call will be terminated if it has been on line more  * than 28 seconds, otherwise, the call that first reaches 28 seconds  * will be terminated.  *  * Current time is valid at the "on-time" marker (OTM), either "*" or  * "#". The nominal on-time marker (*) will be transmitted 45 ms early  * to account for the 8 ms required to send 1 character at 1200 Baud,  * plus an additional 7 ms for delay from NIST to the user, and  * approximately 30 ms "scrambler" delay inherent in 1200 Baud modems.  * If the caller echoes all characters, NIST will measure the round trip  * delay and advance the on-time marker so that the midpoint of the stop  * bit arrives at the user on time. The amount of msADV will reflect the  * actual required advance in milliseconds and the OTM will be a "#".  *  * (The NIST system requires 4 or 5 consecutive delay measurements which  * are consistent before switching from "*" to "#". If the user has a  * 1200 Baud modem with the same internal delay as that used by NIST,  * then the "#" OTM should arrive at the user within +-2 ms of the  * correct time.   *  * However, NIST has studied different brands of 1200 Baud modems and  * found internal delays from 24 ms to 40 ms and offsets of the "#" OTM  * of +-10 ms. For many computer users, +-10 ms accuracy should be more  * than adequate since many computer internal clocks can only be set  * with granularity of 20 to 50 ms. In any case, the repeatability of  * the offset for the "#" OTM should be within +-2 ms, if the dial-up  * path is reciprocal and the user doesn't change the brand or model of  * modem used.   *  * This should be true even if the dial-up path on one day is a land-  * line of less than 40 ms (one way) and on the next day is a satellite  * link of 260 to 300 ms. In the rare event that the path is one way by  * satellite and the other way by land line with a round trip  * measurement in the range of 90 to 260 ms, the OTM will remain a "*"  * indicating 45 ms advance.  *  * For user comments write:  * NIST-ACTS  * Time and Frequency Division  * Mail Stop 847  * 325 Broadway  * Boulder, CO 80303  *  * Software for setting (PC)DOS compatable machines is available on a  * 360-kbyte diskette for $35.00 from: NIST Office of Standard Reference  * Materials B311-Chemistry Bldg, NIST, Gaithersburg, MD, 20899, (301)  * 975-6776  */
end_comment

begin_comment
comment|/*  * Interface definitions  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/acts%d"
end_define

begin_comment
comment|/* device name and unit */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B1200
end_define

begin_comment
comment|/* uart speed (1200 cowardly baud) */
end_comment

begin_define
define|#
directive|define
name|PRECISION
value|(-10)
end_define

begin_comment
comment|/* precision assumed (about 1 ms) */
end_comment

begin_define
define|#
directive|define
name|REFID
value|"ACTS"
end_define

begin_comment
comment|/* reference ID */
end_comment

begin_define
define|#
directive|define
name|DESCRIPTION
value|"NIST Automated Computer Time Service"
end_define

begin_comment
comment|/* WRU */
end_comment

begin_define
define|#
directive|define
name|MODE_AUTO
value|0
end_define

begin_comment
comment|/* automatic mode */
end_comment

begin_define
define|#
directive|define
name|MODE_BACKUP
value|1
end_define

begin_comment
comment|/* backup mode */
end_comment

begin_define
define|#
directive|define
name|MODE_MANUAL
value|2
end_define

begin_comment
comment|/* manual mode */
end_comment

begin_define
define|#
directive|define
name|NSAMPLES
value|3
end_define

begin_comment
comment|/* stages of median filter */
end_comment

begin_define
define|#
directive|define
name|MSGCNT
value|10
end_define

begin_comment
comment|/* we need this many ACTS messages */
end_comment

begin_define
define|#
directive|define
name|SMAX
value|80
end_define

begin_comment
comment|/* max token string length */
end_comment

begin_define
define|#
directive|define
name|LENCODE
value|50
end_define

begin_comment
comment|/* length of valid timecode string */
end_comment

begin_define
define|#
directive|define
name|ACTS_MINPOLL
value|10
end_define

begin_comment
comment|/* log2 min poll interval (1024 s) */
end_comment

begin_define
define|#
directive|define
name|ACTS_MAXPOLL
value|14
end_define

begin_comment
comment|/* log2 max poll interval (16384 s) */
end_comment

begin_define
define|#
directive|define
name|MAXOUTAGE
value|3600
end_define

begin_comment
comment|/* max outage before ACTS kicks in (s) */
end_comment

begin_comment
comment|/*  * Modem control strings. These may have to be changed for some modems.  *  * AT	command prefix  * B1	initiate call negotiation using Bell 212A  *&C1	enable carrier detect  *&D2	hang up and return to command mode on DTR transition  * E0	modem command echo disabled  * l1	set modem speaker volume to low level  * M1	speaker enabled untill carrier detect  * Q0	return result codes  * V1	return result codes as English words  */
end_comment

begin_define
define|#
directive|define
name|MODEM_SETUP
value|"ATB1&C1&D2E0L1M1Q0V1"
end_define

begin_comment
comment|/* modem setup */
end_comment

begin_define
define|#
directive|define
name|MODEM_HANGUP
value|"ATH"
end_define

begin_comment
comment|/* modem disconnect */
end_comment

begin_comment
comment|/*  * Timeouts  */
end_comment

begin_define
define|#
directive|define
name|IDLE
value|60
end_define

begin_comment
comment|/* idle timeout (s) */
end_comment

begin_define
define|#
directive|define
name|WAIT
value|2
end_define

begin_comment
comment|/* wait timeout (s) */
end_comment

begin_define
define|#
directive|define
name|ANSWER
value|30
end_define

begin_comment
comment|/* answer timeout (s) */
end_comment

begin_define
define|#
directive|define
name|CONNECT
value|10
end_define

begin_comment
comment|/* connect timeout (s) */
end_comment

begin_define
define|#
directive|define
name|TIMECODE
value|15
end_define

begin_comment
comment|/* timecode timeout (s) */
end_comment

begin_comment
comment|/*  * Imported from ntp_timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time (s) */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|last_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last clock update time (s) */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inner space */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Imported from ntp_config module  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|sys_phone
index|[]
index|[
name|MAXDIAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modem dial strings */
end_comment

begin_comment
comment|/*  * Imported from ntp_proto module  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* who is running the show */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_poll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2 of system poll interval */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|peer
modifier|*
name|sys_peer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system peer structure pointer */
end_comment

begin_comment
comment|/*  * Tables to compute the ddd of year form icky dd/mm timecode. Viva la  * leap.  */
end_comment

begin_expr_stmt
specifier|static
name|day1tab
index|[]
operator|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|day2tab
index|[]
operator|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Unit control structure  */
end_comment

begin_struct
struct|struct
name|actsunit
block|{
name|struct
name|event
name|timer
decl_stmt|;
comment|/* timeout timer */
name|int
name|pollcnt
decl_stmt|;
comment|/* poll message counter */
name|int
name|state
decl_stmt|;
comment|/* the first one was Delaware */
name|int
name|run
decl_stmt|;
comment|/* call program run switch */
name|int
name|msgcnt
decl_stmt|;
comment|/* count of ACTS messages received */
name|long
name|redial
decl_stmt|;
comment|/* interval to next automatic call */
name|double
name|msADV
decl_stmt|;
comment|/* millisecond advance of last message */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|acts_start
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acts_shutdown
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acts_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acts_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acts_timeout
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|acts_disc
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acts_write
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_acts
init|=
block|{
name|acts_start
block|,
comment|/* start up driver */
name|acts_shutdown
block|,
comment|/* shut down driver */
name|acts_poll
block|,
comment|/* transmit poll message */
name|noentry
block|,
comment|/* not used (old acts_control) */
name|noentry
block|,
comment|/* not used (old acts_init) */
name|noentry
block|,
comment|/* not used (old acts_buginfo) */
name|NOFLAGS
comment|/* not used */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * acts_start - open the devices and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|acts_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
name|int
name|dtr
init|=
name|TIOCM_DTR
decl_stmt|;
comment|/* 	 * Open serial port. Use ACTS line discipline, if available. It 	 * pumps a timestamp into the data stream at every on-time 	 * character '*' found. Note: the port must have modem control 	 * or deep pockets for the phone bill. HP-UX 9.03 users should 	 * have very deep pockets. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|=
name|refclock_open
argument_list|(
name|device
argument_list|,
name|SPEED232
argument_list|,
name|LDISC_ACTS
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dtr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"clock %s ACTS no modem control"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate and initialize unit structure 	 */
if|if
condition|(
operator|!
operator|(
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|actsunit
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|actsunit
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|clock_recv
operator|=
name|acts_receive
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|peer
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|io
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|->
name|unitptr
operator|=
operator|(
name|caddr_t
operator|)
name|up
expr_stmt|;
comment|/* 	 * Initialize miscellaneous variables 	 */
name|peer
operator|->
name|precision
operator|=
name|PRECISION
expr_stmt|;
name|pp
operator|->
name|clockdesc
operator|=
name|DESCRIPTION
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
name|REFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|minpoll
operator|=
name|ACTS_MINPOLL
expr_stmt|;
name|peer
operator|->
name|maxpoll
operator|=
name|ACTS_MAXPOLL
expr_stmt|;
comment|/* 	 * Initialize modem and kill DTR. We skedaddle if this comes 	 * bum. 	 */
if|if
condition|(
operator|!
name|acts_write
argument_list|(
name|peer
argument_list|,
name|MODEM_SETUP
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set up the driver timeout 	 */
name|up
operator|->
name|timer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|peer
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_handler
operator|=
name|acts_timeout
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|WAIT
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * acts_shutdown - shut down the clock  */
end_comment

begin_function
specifier|static
name|void
name|acts_shutdown
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|pp
operator|->
name|io
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_receive - receive data from the serial interface  */
end_comment

begin_function
specifier|static
name|void
name|acts_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
name|str
index|[
name|SMAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|l_fp
name|tstmp
decl_stmt|;
name|u_fp
name|disp
decl_stmt|;
name|char
name|hangup
init|=
literal|'%'
decl_stmt|;
comment|/* ACTS hangup */
name|int
name|day
decl_stmt|;
comment|/* day of the month */
name|int
name|month
decl_stmt|;
comment|/* month of the year */
name|u_long
name|mjd
decl_stmt|;
comment|/* Modified Julian Day */
name|u_int
name|dst
decl_stmt|;
comment|/* daylight/standard time indicator */
name|u_int
name|leap
decl_stmt|;
comment|/* leap-second indicator */
name|double
name|dut1
decl_stmt|;
comment|/* DUT adjustment */
name|double
name|msADV
decl_stmt|;
comment|/* ACTS transmit advance (ms) */
name|char
name|utc
index|[
literal|10
index|]
decl_stmt|;
comment|/* this is NIST and you're not */
name|char
name|flag
decl_stmt|;
comment|/* calibration flag */
comment|/* 	 * Initialize pointers and read the timecode and timestamp. If 	 * the OK modem status code, leave it where folks can find it. 	 */
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|pp
operator|->
name|lencode
operator|=
name|refclock_gtlin
argument_list|(
name|rbufp
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|,
name|BMAX
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|lencode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|lastcode
argument_list|,
literal|"OK"
argument_list|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|lencode
operator|=
literal|2
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"acts: timecode %d %s\n"
argument_list|,
name|pp
operator|->
name|lencode
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|up
operator|->
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * State 0. We are not expecting anything. Probably 		 * modem disconnect noise. Go back to sleep. 		 */
return|return;
case|case
literal|1
case|:
comment|/* 		 * State 1. We are waiting for the call to be answered. 		 * All we care about here is CONNECT as the first token 		 * in the string. If the modem signals BUSY, ERROR, NO 		 * ANSWER, NO CARRIER or NO DIALTONE, we immediately 		 * hang up the phone. If CONNECT doesn't happen after 		 * ANSWER seconds, hang up the phone. If everything is 		 * okay, start the connect timeout and slide into state 		 * 2. 		 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|str
argument_list|,
name|strtok
argument_list|(
name|pp
operator|->
name|lastcode
argument_list|,
literal|" "
argument_list|)
argument_list|,
name|SMAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"BUSY"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ERROR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"NO"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS modem status %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
name|acts_disc
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"CONNECT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|CONNECT
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
name|up
operator|->
name|msgcnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|state
operator|++
expr_stmt|;
block|}
return|return;
case|case
literal|2
case|:
comment|/* 		 * State 2. The call has been answered and we are 		 * waiting for the first ACTS message. If this doesn't 		 * happen within the timecode timeout, hang up the 		 * phone. We probably got a wrong number or ACTS is 		 * down. 		 */
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|TIMECODE
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|++
expr_stmt|;
block|}
comment|/* 	 * Real yucky things here. Ignore everything except timecode 	 * messages, as determined by the message length. We told the 	 * terminal routines to end the line with '*' and the line 	 * discipline to strike a timestamp on that character. However, 	 * when the ACTS echo-delay scheme works, the '*' eventually 	 * becomes a '#'. In this case the message is ended by the<CR> 	 * that comes about 200 ms after the '#' and the '#' cannot be 	 * echoed at the proper time. But, this may not be a lose, since 	 * we already have good data from prior messages and only need 	 * the millisecond advance calculated by ACTS. So, if the 	 * message is long enough and has an on-time character at the 	 * right place, we consider the message (but not neccesarily the 	 * timestmap) to be valid. 	 */
if|if
condition|(
name|pp
operator|->
name|lencode
operator|!=
name|LENCODE
condition|)
return|return;
comment|/* 	 * We apparently have a valid timecode message, so dismember it 	 * with sscan(). This routine does a good job in spotting syntax 	 * errors without becoming overly pedantic. 	 * 	 *                         D  L D 	 *  MJD  YR MO DA H  M  S  ST S UT1 msADV         OTM 	 * 47222 88-03-02 21:39:15 83 0 +.3 045.0 UTC(NBS) * 	 */
if|if
condition|(
name|sscanf
argument_list|(
name|pp
operator|->
name|lastcode
argument_list|,
literal|"%5ld %2d-%2d-%2d %2d:%2d:%2d %2d %1d %3lf %5lf %s %c"
argument_list|,
operator|&
name|mjd
argument_list|,
operator|&
name|pp
operator|->
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|pp
operator|->
name|hour
argument_list|,
operator|&
name|pp
operator|->
name|minute
argument_list|,
operator|&
name|pp
operator|->
name|second
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|leap
argument_list|,
operator|&
name|dut1
argument_list|,
operator|&
name|msADV
argument_list|,
name|utc
argument_list|,
operator|&
name|flag
argument_list|)
operator|!=
literal|13
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Some modems can't be trusted (the Practical Peripherals 	 * 9600SA comes to mind) and, even if they manage to unstick 	 * ACTS, the millisecond advance is wrong, so we use CLK_FLAG2 	 * to disable echoes, if neccessary. 	 */
if|if
condition|(
operator|(
name|flag
operator|==
literal|'*'
operator|||
name|flag
operator|==
literal|'#'
operator|)
operator|&&
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG2
operator|)
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|flag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Yes, I know this code incorrectly thinks that 2000 is a leap 	 * year. The ACTS timecode format croaks then anyway. Life is 	 * short. Would only the timecode mavens resist the urge to 	 * express months of the year and days of the month in favor of 	 * days of the year. 	 */
if|if
condition|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pp
operator|->
name|year
operator|%
literal|4
condition|)
block|{
if|if
condition|(
name|day
operator|>
name|day1tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day1tab
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|day
operator|>
name|day2tab
index|[
name|month
operator|-
literal|1
index|]
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|day
operator|+=
name|day2tab
index|[
name|i
index|]
expr_stmt|;
block|}
name|pp
operator|->
name|day
operator|=
name|day
expr_stmt|;
if|if
condition|(
name|leap
operator|==
literal|1
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_ADDSECOND
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|leap
operator|==
literal|2
condition|)
name|pp
operator|->
name|leap
operator|=
name|LEAP_DELSECOND
expr_stmt|;
else|else
name|pp
operator|->
name|leap
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * Colossal hack here. We process each sample in a trimmed-mean 	 * filter and determine the reference clock offset and 	 * dispersion. The fudge time1 value is added to each sample as 	 * received. If we collect MSGCNT samples before the '#' on-time 	 * character, we use the results of the filter as is. If the '#' 	 * is found before that, the adjusted msADV is used to correct 	 * the propagation delay. 	 */
name|up
operator|->
name|msgcnt
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|'#'
condition|)
block|{
name|L_CLR
argument_list|(
operator|&
name|tstmp
argument_list|)
expr_stmt|;
name|TVUTOTSF
argument_list|(
call|(
name|long
call|)
argument_list|(
operator|(
name|msADV
operator|-
name|up
operator|->
name|msADV
operator|)
operator|*
literal|1000.
argument_list|)
argument_list|,
name|tstmp
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
operator|&
name|tstmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|up
operator|->
name|msADV
operator|=
name|msADV
expr_stmt|;
if|if
condition|(
operator|!
name|refclock_process
argument_list|(
name|pp
argument_list|,
name|up
operator|->
name|msgcnt
argument_list|,
name|up
operator|->
name|msgcnt
operator|-
name|up
operator|->
name|msgcnt
operator|/
literal|3
argument_list|)
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|msgcnt
operator|<
name|MSGCNT
condition|)
return|return;
block|}
comment|/* 	 * We have a filtered sample offset ready for peer processing. 	 * We use lastrec as both the reference time and receive time in 	 * order to avoid being cute, like setting the reference time 	 * later than the receive time, which may cause a paranoid 	 * protocol module to chuck out the data. Finaly, we unhook the 	 * timeout, arm for the next call, fold the tent and go home. 	 * The little dance with the '%' character is an undocumented 	 * ACTS feature that hangs up the phone real quick without 	 * waiting for carrier loss or long-space disconnect, but we do 	 * these clumsy things anyway. 	 */
name|disp
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|pp
operator|->
name|fudgetime2
argument_list|)
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|,
name|pp
operator|->
name|lastcode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|,
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|dispersion
operator|+
operator|(
name|u_fp
operator|)
name|disp
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
operator|&
name|pp
operator|->
name|lastrec
argument_list|,
name|pp
operator|->
name|leap
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|=
literal|0
expr_stmt|;
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|hangup
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|acts_disc
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_poll - called by the transmit routine  */
end_comment

begin_function
specifier|static
name|void
name|acts_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * If the driver is running, we set the enable flag (fudge 	 * flag1), which causes the driver timeout routine to initiate a 	 * call to ACTS. If not, the enable flag can be set using 	 * xntpdc. If this is the sustem peer, then follow the system 	 * poll interval. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|run
condition|)
block|{
name|pp
operator|->
name|sloppyclockflag
operator||=
name|CLK_FLAG1
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|sys_peer
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|sys_poll
expr_stmt|;
else|else
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * acts_timeout - called by the timer interrupt  */
end_comment

begin_function
specifier|static
name|void
name|acts_timeout
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|dtr
init|=
name|TIOCM_DTR
decl_stmt|;
comment|/* 	 * If a timeout occurs in other than state 0, the call has 	 * failed. If in state 0, we just see if there is other work to 	 * do. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|state
condition|)
block|{
name|acts_disc
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|peer
operator|->
name|ttl
condition|)
block|{
comment|/* 		 * In manual mode the ACTS calling program is activated 		 * by the xntpdc program using the enable flag (fudge 		 * flag1), either manually or by a cron job. 		 */
case|case
name|MODE_MANUAL
case|:
name|up
operator|->
name|run
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * In automatic mode the ACTS calling program runs 		 * continuously at intervals determined by the sys_poll 		 * variable. 		 */
case|case
name|MODE_AUTO
case|:
if|if
condition|(
operator|!
name|up
operator|->
name|run
condition|)
name|pp
operator|->
name|sloppyclockflag
operator||=
name|CLK_FLAG1
expr_stmt|;
name|up
operator|->
name|run
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 		 * In backup mode the ACTS calling program is disabled, 		 * unless no system peer has been selected for MAXOUTAGE 		 * (3600 s). Once enabled, it runs until some other NTP 		 * peer shows up. 		 */
case|case
name|MODE_BACKUP
case|:
if|if
condition|(
operator|!
name|up
operator|->
name|run
operator|&&
name|sys_peer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_time
operator|-
name|last_time
operator|>
name|MAXOUTAGE
condition|)
block|{
name|up
operator|->
name|run
operator|=
literal|1
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS backup started "
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|up
operator|->
name|run
operator|&&
name|sys_peer
operator|->
name|refclktype
operator|!=
name|REFCLK_NIST_ACTS
condition|)
block|{
name|peer
operator|->
name|hpoll
operator|=
name|peer
operator|->
name|minpoll
expr_stmt|;
name|up
operator|->
name|run
operator|=
literal|0
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS backup stopped"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS invalid mode"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The fudge flag1 is used as an enable/disable; if set either 	 * by the code or via xntpdc, the ACTS calling program is 	 * started; if reset, the phones stop ringing. 	 */
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sloppyclockflag
operator|&
name|CLK_FLAG1
operator|)
condition|)
block|{
name|up
operator|->
name|pollcnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|IDLE
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Initiate a call to the ACTS service. If we wind up here in 	 * other than state 0, a successful call could not be completed 	 * within minpoll seconds. We advance to the next modem dial 	 * string. If none are left, we log a notice and clear the 	 * enable flag. For future enhancement: call the site RP and 	 * leave an obscene message in his voicemail. 	 */
if|if
condition|(
name|sys_phone
index|[
name|up
operator|->
name|pollcnt
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_TIMEOUT
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS calling program terminated"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sloppyclockflag
operator|&=
operator|~
name|CLK_FLAG1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"acts: calling program terminated\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|up
operator|->
name|pollcnt
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|IDLE
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Raise DTR, call ACTS and start the answer timeout. We think 	 * it strange if the OK status has not been received from the 	 * modem, but plow ahead anyway. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|lastcode
argument_list|,
literal|"OK"
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS no modem status"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|acts_write
argument_list|(
name|peer
argument_list|,
name|sys_phone
index|[
name|up
operator|->
name|pollcnt
index|]
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS calling %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|sys_phone
index|[
name|up
operator|->
name|pollcnt
index|]
argument_list|)
expr_stmt|;
name|up
operator|->
name|state
operator|=
literal|1
expr_stmt|;
name|up
operator|->
name|pollcnt
operator|++
expr_stmt|;
name|pp
operator|->
name|polls
operator|++
expr_stmt|;
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|ANSWER
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_disc - disconnect the call and wait for the ruckus to cool  */
end_comment

begin_function
specifier|static
name|void
name|acts_disc
parameter_list|(
name|peer
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|dtr
init|=
name|TIOCM_DTR
decl_stmt|;
comment|/* 	 * We should never get here other than in state 0, unless a call 	 * has timed out. We drop DTR, which will reliably get the modem 	 * off the air, even while ACTS is hammering away full tilt. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|state
operator|>
literal|0
condition|)
block|{
name|up
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock %s ACTS call failed %d"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|,
name|up
operator|->
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"acts: call failed %d\n"
argument_list|,
name|up
operator|->
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|up
operator|->
name|timer
operator|.
name|event_time
operator|=
name|current_time
operator|+
name|WAIT
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|up
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * acts_write - write a message to the serial port  */
end_comment

begin_function
name|int
name|acts_write
parameter_list|(
name|peer
parameter_list|,
name|str
parameter_list|)
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|struct
name|actsunit
modifier|*
name|up
decl_stmt|;
name|struct
name|refclockproc
modifier|*
name|pp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
name|cr
init|=
literal|'\r'
decl_stmt|;
comment|/* 	 * Not much to do here, other than send the message, handle 	 * debug and report faults. 	 */
name|pp
operator|=
name|peer
operator|->
name|procptr
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|actsunit
operator|*
operator|)
name|pp
operator|->
name|unitptr
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"acts: state %d send %d %s\n"
argument_list|,
name|up
operator|->
name|state
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|==
name|len
expr_stmt|;
name|code
operator||=
name|write
argument_list|(
name|pp
operator|->
name|io
operator|.
name|fd
argument_list|,
operator|&
name|cr
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|refclock_report
argument_list|(
name|peer
argument_list|,
name|CEVNT_FAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

