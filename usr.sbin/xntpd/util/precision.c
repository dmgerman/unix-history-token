begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_define
define|#
directive|define
name|DEFAULT_SYS_PRECISION
value|-99
end_define

begin_function_decl
name|int
name|default_get_resolution
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|default_get_precision
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"log2(resolution) = %d, log2(precision) = %d\n"
argument_list|,
name|default_get_resolution
argument_list|()
argument_list|,
name|default_get_precision
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the resolution of the system clock by watching how the current time  * changes as we read it repeatedly.  *  * struct timeval is only good to 1us, which may cause problems as machines  * get faster, but until then the logic goes:  *  * If a machine has resolution (i.e. accurate timing info)> 1us, then it will  * probably use the "unused" low order bits as a counter (to force time to be  * a strictly increaing variable), incrementing it each time any process  * requests the time [[ or maybe time will stand still ? ]].  *  * SO: the logic goes:  *  *      IF      the difference from the last time is "small" (< MINSTEP)  *      THEN    this machine is "counting" with the low order bits  *      ELIF    this is not the first time round the loop  *      THEN    this machine *WAS* counting, and has now stepped  *      ELSE    this machine has resolution< time to read clock  *  * SO: if it exits on the first loop, assume "full accuracy" (1us)  *     otherwise, take the log2(observered difference, rounded UP)  *  * MINLOOPS> 1 ensures that even if there is a STEP between the initial call  * and the first loop, it doesn't stop too early.  * Making it even greater allows MINSTEP to be reduced, assuming that the  * chance of MINSTEP-1 other processes getting in and calling gettimeofday  * between this processes's calls.  * Reducing MINSTEP may be necessary as this sets an upper bound for the time  * to actually call gettimeofday.  */
end_comment

begin_define
define|#
directive|define
name|DUSECS
value|1000000
end_define

begin_define
define|#
directive|define
name|HUSECS
value|(1024 * 1024)
end_define

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* some systems increment uS on each call */
end_comment

begin_comment
comment|/* Don't use "1" as some *other* process may read too*/
end_comment

begin_comment
comment|/*We assume no system actually *ANSWERS* in this time*/
end_comment

begin_define
define|#
directive|define
name|MAXSTEP
value|20000
end_define

begin_comment
comment|/* maximum clock increment (us) */
end_comment

begin_define
define|#
directive|define
name|MINLOOPS
value|5
end_define

begin_comment
comment|/* minimum number of step samples */
end_comment

begin_define
define|#
directive|define
name|MAXLOOPS
value|HUSECS
end_define

begin_comment
comment|/* Assume precision< .1s ! */
end_comment

begin_function
name|int
name|default_get_resolution
parameter_list|()
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|minsteps
init|=
name|MINLOOPS
decl_stmt|;
comment|/* need at least this many steps */
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
operator|--
name|minsteps
init|;
name|i
operator|<
name|MAXLOOPS
condition|;
name|i
operator|++
control|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
if|if
condition|(
name|minsteps
operator|--
operator|<=
literal|0
condition|)
break|break;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"resolution = %ld usec after %d loop%s\n"
argument_list|,
name|diff
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
name|diff
operator|*
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAXLOOPS
condition|)
block|{
name|printf
argument_list|(
literal|"     (Boy this machine is fast ! %d loops without a step)\n"
argument_list|,
name|MAXLOOPS
argument_list|)
expr_stmt|;
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* No STEP, so FAST machine */
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"     (The resolution is less than the time to read the clock -- Assume 1us)\n"
argument_list|)
expr_stmt|;
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* time to read clock>= resolution */
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|val
operator|=
name|HUSECS
init|;
name|val
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|val
operator|>>=
literal|1
control|)
if|if
condition|(
name|diff
operator|>=
name|val
condition|)
return|return
name|i
return|;
name|printf
argument_list|(
literal|"     (Oh dear -- that wasn't expected ! I'll guess !)\n"
argument_list|)
expr_stmt|;
return|return
name|DEFAULT_SYS_PRECISION
comment|/* Something's BUST, so lie ! */
return|;
block|}
end_function

begin_comment
comment|/* ===== Rest of this code lifted straight from xntpd/ntp_proto.c ! ===== */
end_comment

begin_comment
comment|/*  * This routine calculates the differences between successive calls to  * gettimeofday(). If a difference is less than zero, the us field  * has rolled over to the next second, so we add a second in us. If  * the difference is greater than zero and less than MINSTEP, the  * clock has been advanced by a small amount to avoid standing still.  * If the clock has advanced by a greater amount, then a timer interrupt  * has occurred and this amount represents the precision of the clock.  * In order to guard against spurious values, which could occur if we  * happen to hit a fat interrupt, we do this for MINLOOPS times and  * keep the minimum value obtained.  */
end_comment

begin_function
name|int
name|default_get_precision
parameter_list|()
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|long
name|usec
decl_stmt|;
name|usec
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|MAXSTEP
expr_stmt|;
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINLOOPS
operator|&&
name|usec
operator|<
name|HUSECS
condition|;
control|)
block|{
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
name|usec
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|val
condition|)
name|val
operator|=
name|diff
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"precision  = %ld usec after %d loop%s\n"
argument_list|,
name|val
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>=
name|HUSECS
condition|)
block|{
name|printf
argument_list|(
literal|"     (Boy this machine is fast ! usec was %ld)\n"
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|val
operator|=
name|MINSTEP
expr_stmt|;
comment|/* val<= MINSTEP; fast machine */
block|}
name|diff
operator|=
name|HUSECS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|diff
operator|>
name|val
condition|;
name|i
operator|--
control|)
name|diff
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

end_unit

