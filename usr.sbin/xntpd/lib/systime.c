begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* systime.c,v 3.1 1993/07/06 01:08:46 jbj Exp  * systime -- routines to fiddle a UNIX clock.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_BSDI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_LINUX
end_ifdef

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STEP_SLEW
argument_list|)
end_if

begin_define
define|#
directive|define
name|SLEWALWAYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These routines (init_systime, get_systime, step_systime, adj_systime)  * implement an interface between the (more or less) system independent  * bits of NTP and the peculiarities of dealing with the Unix system  * clock.  These routines will run with good precision fairly independently  * of your kernel's value of tickadj.  I couldn't tell the difference  * between tickadj==40 and tickadj==5 on a microvax, though I prefer  * to set tickadj == 500/hz when in doubt.  At your option you  * may compile this so that your system's clock is always slewed to the  * correct time even for large corrections.  Of course, all of this takes  * a lot of code which wouldn't be needed with a reasonable tickadj and  * a willingness to let the clock be stepped occasionally.  Oh well.  */
end_comment

begin_comment
comment|/*  * Clock variables.  We round calls to adjtime() to adj_precision  * microseconds, and limit the adjustment to tvu_maxslew microseconds  * (tsf_maxslew fractional sec) in one adjustment interval.  As we are  * thus limited in the speed and precision with which we can adjust the  * clock, we compensate by keeping the known "error" in the system time  * in sys_clock_offset.  This is added to timestamps returned by get_systime().  * We also remember the clock precision we computed from the kernel in  * case someone asks us.  */
end_comment

begin_decl_stmt
name|LONG
name|sys_clock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LONG
name|adj_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adj precision in usec (tickadj) */
end_comment

begin_decl_stmt
name|LONG
name|tvu_maxslew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum adjust doable in 1<<CLOCK_ADJ sec (usec) */
end_comment

begin_decl_stmt
name|U_LONG
name|tsf_maxslew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* same as above, as LONG format */
end_comment

begin_decl_stmt
name|l_fp
name|sys_clock_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* correction for current system time */
end_comment

begin_comment
comment|/*  * get_systime - return the system time in timestamp format  * As a side effect, update sys_clock.  */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|ts
parameter_list|)
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SLEWALWAYS
argument_list|)
comment|/* 	 * Quickly get the time of day and convert it 	 */
operator|(
name|void
operator|)
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|tv
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|l_uf
operator|+=
name|TS_ROUNDBIT
expr_stmt|;
comment|/* guaranteed not to overflow */
else|#
directive|else
comment|/* 	 * Get the time of day, convert to time stamp format 	 * and add in the current time offset.  Then round 	 * appropriately. 	 */
operator|(
name|void
operator|)
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|tv
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|ts
argument_list|,
operator|&
name|sys_clock_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|l_uf
operator|&
name|TS_ROUNDBIT
condition|)
name|L_ADDUF
argument_list|(
name|ts
argument_list|,
operator|(
name|unsigned
name|LONG
operator|)
name|TS_ROUNDBIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(SLEWALWAYS) */
name|ts
operator|->
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|ts
operator|->
name|l_uf
operator|&=
name|TS_MASK
expr_stmt|;
name|sys_clock
operator|=
name|ts
operator|->
name|l_ui
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * step_systime - do a step adjustment in the system time (at least from  *		  NTP's point of view.  */
end_comment

begin_function
name|int
name|step_systime
parameter_list|(
name|ts
parameter_list|)
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SLEWALWAYS
ifdef|#
directive|ifdef
name|STEP_SLEW
specifier|register
name|U_LONG
name|tmp_ui
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_uf
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * Take the absolute value of the offset 	 */
name|tmp_ui
operator|=
name|ts
operator|->
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|ts
operator|->
name|l_uf
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
condition|)
block|{
name|M_NEG
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp_ui
operator|>=
literal|3
condition|)
block|{
comment|/* Step it and slew we  might win */
name|n
operator|=
name|step_systime_real
argument_list|(
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|n
return|;
if|if
condition|(
name|isneg
condition|)
name|ts
operator|->
name|l_ui
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|ts
operator|->
name|l_ui
operator|=
operator|~
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*          * Just add adjustment into the current offset.  The update          * routine will take care of bringing the system clock into          * line.          */
name|L_ADD
argument_list|(
operator|&
name|sys_clock_offset
argument_list|,
name|ts
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
comment|/* SLEWALWAYS  */
return|return
name|step_systime_real
argument_list|(
name|ts
argument_list|)
return|;
endif|#
directive|endif
comment|/* SLEWALWAYS */
block|}
end_function

begin_decl_stmt
name|int
name|max_no_complete
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * adj_systime - called once every 1<<CLOCK_ADJ seconds to make system time  *		 adjustments.  */
end_comment

begin_function
name|int
name|adj_systime
parameter_list|(
name|ts
parameter_list|)
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
specifier|register
name|unsigned
name|LONG
name|offset_i
decl_stmt|,
name|offset_f
decl_stmt|;
specifier|register
name|LONG
name|temp
decl_stmt|;
specifier|register
name|unsigned
name|LONG
name|residual
decl_stmt|;
specifier|register
name|int
name|isneg
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|adjtv
decl_stmt|,
name|oadjtv
decl_stmt|;
name|l_fp
name|oadjts
decl_stmt|;
name|LONG
name|adj
init|=
name|ts
operator|->
name|l_f
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|adjtv
operator|.
name|tv_sec
operator|=
name|adjtv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Move the current offset into the registers 	 */
name|offset_i
operator|=
name|sys_clock_offset
operator|.
name|l_ui
expr_stmt|;
name|offset_f
operator|=
name|sys_clock_offset
operator|.
name|l_uf
expr_stmt|;
comment|/* 	 * Add the new adjustment into the system offset.  Adjust the 	 * system clock to minimize this. 	 */
name|M_ADDF
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
name|adj
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|)
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|M_NEG
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"adj_systime(%s): offset = %s%s\n"
argument_list|,
name|mfptoa
argument_list|(
operator|(
name|adj
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|,
name|adj
argument_list|,
literal|9
argument_list|)
argument_list|,
name|isneg
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|umfptoa
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adjtv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset_i
operator|>
literal|0
operator|||
name|offset_f
operator|>=
name|tsf_maxslew
condition|)
block|{
comment|/* 		 * Slew is bigger than we can complete in 		 * the adjustment interval.  Make a maximum 		 * sized slew and reduce sys_clock_offset by this 		 * much. 		 */
name|M_SUBUF
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
name|tsf_maxslew
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_usec
operator|=
name|tvu_maxslew
expr_stmt|;
block|}
else|else
block|{
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|tvu_maxslew
expr_stmt|;
name|M_NEG
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"maximum slew: %s%s, remainder = %s\n"
argument_list|,
name|isneg
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|umfptoa
argument_list|(
literal|0
argument_list|,
name|tsf_maxslew
argument_list|,
literal|9
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * We can do this slew in the time period.  Do our 		 * best approximation (rounded), save residual for 		 * next adjustment. 		 * 		 * Note that offset_i is guaranteed to be 0 here. 		 */
name|TSFTOTVU
argument_list|(
name|offset_f
argument_list|,
name|temp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ADJTIME_IS_ACCURATE
comment|/* 		 * Round value to be an even multiple of adj_precision 		 */
name|residual
operator|=
name|temp
operator|%
name|adj_precision
expr_stmt|;
name|temp
operator|-=
name|residual
expr_stmt|;
if|if
condition|(
name|residual
operator|<<
literal|1
operator|>=
name|adj_precision
condition|)
name|temp
operator|+=
name|adj_precision
expr_stmt|;
endif|#
directive|endif
comment|/* ADJTIME_IS_ACCURATE */
name|TVUTOTSF
argument_list|(
name|temp
argument_list|,
name|residual
argument_list|)
expr_stmt|;
name|M_SUBUF
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
name|residual
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|temp
expr_stmt|;
name|M_NEG
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjtv
operator|.
name|tv_usec
operator|=
name|temp
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"slew adjtv = %s, adjts = %s, sys_clock_offset = %s\n"
argument_list|,
name|tvtoa
argument_list|(
operator|&
name|adjtv
argument_list|)
argument_list|,
name|umfptoa
argument_list|(
literal|0
argument_list|,
name|residual
argument_list|,
literal|9
argument_list|)
argument_list|,
name|mfptoa
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|adjtv
argument_list|,
operator|&
name|oadjtv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't do time adjustment: %m"
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sys_clock_offset
operator|.
name|l_ui
operator|=
name|offset_i
expr_stmt|;
name|sys_clock_offset
operator|.
name|l_uf
operator|=
name|offset_f
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGRS6000
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"adj_systime(%s): offset = %s%s\n"
argument_list|,
name|mfptoa
argument_list|(
operator|(
name|adj
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|,
name|adj
argument_list|,
literal|9
argument_list|)
argument_list|,
name|isneg
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|umfptoa
argument_list|(
name|offset_i
argument_list|,
name|offset_f
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%d %d %d %d\n"
argument_list|,
operator|(
name|int
operator|)
name|adjtv
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|adjtv
operator|.
name|tv_usec
argument_list|,
operator|(
name|int
operator|)
name|oadjtv
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|oadjtv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGRS6000 */
if|if
condition|(
name|oadjtv
operator|.
name|tv_sec
operator|!=
literal|0
operator|||
name|oadjtv
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
block|{
name|sTVTOTS
argument_list|(
operator|&
name|oadjtv
argument_list|,
operator|&
name|oadjts
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|sys_clock_offset
argument_list|,
operator|&
name|oadjts
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_no_complete
operator|>
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Previous time adjustment didn't complete"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Previous adjtime() incomplete, residual = %s\n"
argument_list|,
name|tvtoa
argument_list|(
operator|&
name|oadjtv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|max_no_complete
operator|==
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"*** No more 'Prev time adj didn't complete'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is used by ntpdate even when xntpd does not use it! WLJ  */
end_comment

begin_function
name|int
name|step_systime_real
parameter_list|(
name|ts
parameter_list|)
name|l_fp
modifier|*
name|ts
decl_stmt|;
block|{
name|struct
name|timeval
name|timetv
decl_stmt|,
name|adjtv
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
name|struct
name|utmp
name|ut
decl_stmt|;
name|time_t
name|oldtime
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * We can afford to be sloppy here since if this is called 	 * the time is really screwed and everything is being reset. 	 */
name|L_ADD
argument_list|(
operator|&
name|sys_clock_offset
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|sys_clock_offset
argument_list|)
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|sys_clock_offset
argument_list|)
expr_stmt|;
block|}
name|TSTOTV
argument_list|(
operator|&
name|sys_clock_offset
argument_list|,
operator|&
name|adjtv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|GETTIMEOFDAY
argument_list|(
operator|&
name|timetv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
name|oldtime
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"step: %s, sys_clock_offset = %s, adjtv = %s, timetv = %s\n"
argument_list|,
name|lfptoa
argument_list|(
name|ts
argument_list|,
literal|9
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|sys_clock_offset
argument_list|,
literal|9
argument_list|)
argument_list|,
name|tvtoa
argument_list|(
operator|&
name|adjtv
argument_list|)
argument_list|,
name|utvtoa
argument_list|(
operator|&
name|timetv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isneg
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|-=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|-=
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timetv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
block|}
else|else
block|{
name|timetv
operator|.
name|tv_sec
operator|+=
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|+=
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timetv
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|timetv
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|timetv
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SETTIMEOFDAY
argument_list|(
operator|&
name|timetv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't set time of day: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"step: new timetv = %s\n"
argument_list|,
name|utvtoa
argument_list|(
operator|&
name|timetv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sys_clock_offset
operator|.
name|l_ui
operator|=
name|sys_clock_offset
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS_HPUX
argument_list|)
if|#
directive|if
operator|(
name|SYS_HPUX
operator|<
literal|10
operator|)
comment|/* 	 * CHECKME: is this correct when called by ntpdate????? 	 */
name|_clear_adjtime
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Write old and new time entries in utmp and wtmp if step adjustment 	 * is greater than one second. 	 */
if|if
condition|(
name|oldtime
operator|!=
name|timetv
operator|.
name|tv_sec
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|oldtime
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|setutent
argument_list|()
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|utmpname
argument_list|(
name|WTMP_FILE
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|OLD_TIME
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|oldtime
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|OTIME_MSG
argument_list|)
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|ut
operator|.
name|ut_type
operator|=
name|NEW_TIME
expr_stmt|;
name|ut
operator|.
name|ut_time
operator|=
name|timetv
operator|.
name|tv_sec
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ut
operator|.
name|ut_line
argument_list|,
name|NTIME_MSG
argument_list|)
expr_stmt|;
name|pututline
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|endutent
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

end_unit

