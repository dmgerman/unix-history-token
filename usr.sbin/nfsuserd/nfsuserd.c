begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Rick Macklem, University of Guelph  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfssvc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfskpiport.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * This program loads the password and group databases into the kernel  * for NFS V4.  */
end_comment

begin_function_decl
specifier|static
name|void
name|cleanup_term
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsuserdsrv
parameter_list|(
name|struct
name|svc_req
modifier|*
parameter_list|,
name|SVCXPRT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdr_getid
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdr_getname
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdr_retval
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAXNAME
value|1024
end_define

begin_define
define|#
directive|define
name|MAXNFSUSERD
value|20
end_define

begin_define
define|#
directive|define
name|DEFNFSUSERD
value|4
end_define

begin_define
define|#
directive|define
name|MAXUSERMAX
value|100000
end_define

begin_define
define|#
directive|define
name|MINUSERMAX
value|10
end_define

begin_define
define|#
directive|define
name|DEFUSERMAX
value|200
end_define

begin_define
define|#
directive|define
name|DEFUSERTIMEOUT
value|(1 * 60)
end_define

begin_struct
struct|struct
name|info
block|{
name|long
name|id
decl_stmt|;
name|long
name|retval
decl_stmt|;
name|char
name|name
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|u_char
modifier|*
name|dnsname
init|=
literal|"default.domain"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|defaultuser
init|=
literal|"nobody"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|defaultuid
init|=
literal|65534
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|defaultgroup
init|=
literal|"nogroup"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|defaultgid
init|=
literal|65533
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|,
name|im_a_slave
init|=
literal|0
decl_stmt|,
name|nfsuserdcnt
init|=
operator|-
literal|1
decl_stmt|,
name|forcestart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|defusertimeout
init|=
name|DEFUSERTIMEOUT
decl_stmt|,
name|manage_gids
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pid_t
name|slaves
index|[
name|MAXNFSUSERD
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fnd_dup
decl_stmt|,
name|len
decl_stmt|,
name|mustfreeai
init|=
literal|0
decl_stmt|,
name|start_uidpos
decl_stmt|;
name|struct
name|nfsd_idargs
name|nid
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|int
name|sock
decl_stmt|,
name|one
init|=
literal|1
decl_stmt|;
name|SVCXPRT
modifier|*
name|udptransp
decl_stmt|;
name|u_short
name|portnum
decl_stmt|;
name|sigset_t
name|signew
decl_stmt|;
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|aip
decl_stmt|,
name|hints
decl_stmt|;
specifier|static
name|uid_t
name|check_dups
index|[
name|MAXUSERMAX
index|]
decl_stmt|;
name|gid_t
name|grps
index|[
name|NGROUPS
index|]
decl_stmt|;
name|int
name|ngroup
decl_stmt|;
if|if
condition|(
name|modfind
argument_list|(
literal|"nfscommon"
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not present in kernel, try loading it */
if|if
condition|(
name|kldload
argument_list|(
literal|"nfscommon"
argument_list|)
operator|<
literal|0
operator|||
name|modfind
argument_list|(
literal|"nfscommon"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Experimental nfs subsystem is not available"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First, figure out what our domain name and Kerberos Realm 	 * seem to be. Command line args may override these later. 	 */
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|dnsname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|hostname
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|aip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aip
operator|->
name|ai_canonname
operator|!=
name|NULL
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|aip
operator|->
name|ai_canonname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|dnsname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|mustfreeai
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|freeaddrinfo
argument_list|(
name|aip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|nid
operator|.
name|nid_usermax
operator|=
name|DEFUSERMAX
expr_stmt|;
name|nid
operator|.
name|nid_usertimeout
operator|=
name|defusertimeout
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-domain"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|hostname
argument_list|,
operator|*
name|argv
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dnsname
operator|=
name|hostname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-verbose"
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-force"
argument_list|)
condition|)
block|{
name|forcestart
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-manage-gids"
argument_list|)
condition|)
block|{
name|manage_gids
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-usermax"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|MINUSERMAX
operator|||
name|i
operator|>
name|MAXUSERMAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usermax %d out of range %d<->%d\n"
argument_list|,
name|i
argument_list|,
name|MINUSERMAX
argument_list|,
name|MAXUSERMAX
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|nid
operator|.
name|nid_usermax
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-usertimeout"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|100000
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usertimeout %d out of range 0<->100000\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|nid
operator|.
name|nid_usertimeout
operator|=
name|defusertimeout
operator|=
name|i
operator|*
literal|60
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsuserdcnt
operator|==
operator|-
literal|1
condition|)
block|{
name|nfsuserdcnt
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsuserdcnt
operator|<
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsuserdcnt
operator|>
name|MAXNFSUSERD
condition|)
block|{
name|warnx
argument_list|(
literal|"nfsuserd count %d; reset to %d"
argument_list|,
name|nfsuserdcnt
argument_list|,
name|DEFNFSUSERD
argument_list|)
expr_stmt|;
name|nfsuserdcnt
operator|=
name|DEFNFSUSERD
expr_stmt|;
block|}
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nfsuserdcnt
operator|<
literal|1
condition|)
name|nfsuserdcnt
operator|=
name|DEFNFSUSERD
expr_stmt|;
comment|/* 	 * Strip off leading and trailing '.'s in domain name and map 	 * alphabetics to lower case. 	 */
while|while
condition|(
operator|*
name|dnsname
operator|==
literal|'.'
condition|)
name|dnsname
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dnsname
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Domain name all '.'"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dnsname
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dnsname
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|cp
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|dnsname
index|[
name|i
index|]
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Domain name has non-ascii char"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|dnsname
index|[
name|i
index|]
argument_list|)
condition|)
name|dnsname
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|dnsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the nfsuserd died off ungracefully, this is necessary to 	 * get them to start again. 	 */
if|if
condition|(
name|forcestart
operator|&&
name|nfssvc
argument_list|(
name|NFSSVC_NFSUSERDDELPORT
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't do nfssvc() to delete the port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nfsuserd: domain=%s usermax=%d usertimeout=%d\n"
argument_list|,
name|dnsname
argument_list|,
name|nid
operator|.
name|nid_usermax
argument_list|,
name|nid
operator|.
name|nid_usertimeout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsuserdcnt
condition|;
name|i
operator|++
control|)
name|slaves
index|[
name|i
index|]
operator|=
operator|(
name|pid_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Set up the service port to accept requests via UDP from 	 * localhost (127.0.0.1). 	 */
if|if
condition|(
operator|(
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot create udp socket"
argument_list|)
expr_stmt|;
comment|/* 	 * Not sure what this does, so I'll leave it here for now. 	 */
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|udptransp
operator|=
name|svcudp_create
argument_list|(
name|sock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can't set up socket"
argument_list|)
expr_stmt|;
comment|/* 	 * By not specifying a protocol, it is linked into the 	 * dispatch queue, but not registered with portmapper, 	 * which is just what I want. 	 */
if|if
condition|(
operator|!
name|svc_register
argument_list|(
name|udptransp
argument_list|,
name|RPCPROG_NFSUSERD
argument_list|,
name|RPCNFSUSERD_VERS
argument_list|,
name|nfsuserdsrv
argument_list|,
literal|0
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can't register nfsuserd"
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the kernel what my port# is. 	 */
name|portnum
operator|=
name|htons
argument_list|(
name|udptransp
operator|->
name|xp_port
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"portnum=0x%x\n"
argument_list|,
name|portnum
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|nfssvc
argument_list|(
name|NFSSVC_NFSUSERDPORT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|portnum
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't start nfsuserd when already running"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" If not running, use the -force option.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't do nfssvc() to add port\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pwd
operator|=
name|getpwnam
argument_list|(
name|defaultuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
condition|)
name|nid
operator|.
name|nid_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
else|else
name|nid
operator|.
name|nid_uid
operator|=
name|defaultuid
expr_stmt|;
name|grp
operator|=
name|getgrnam
argument_list|(
name|defaultgroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
condition|)
name|nid
operator|.
name|nid_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
else|else
name|nid
operator|.
name|nid_gid
operator|=
name|defaultgid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|dnsname
expr_stmt|;
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_INITIALIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Initialize uid=%d gid=%d dns=%s\n"
argument_list|,
name|nid
operator|.
name|nid_uid
argument_list|,
name|nid
operator|.
name|nid_gid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't initialize nfs user/groups"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop around adding all groups. 	 */
name|setgrent
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nid
operator|.
name|nid_usermax
operator|&&
operator|(
name|grp
operator|=
name|getgrent
argument_list|()
operator|)
condition|)
block|{
name|nid
operator|.
name|nid_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|grp
operator|->
name|gr_name
expr_stmt|;
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_ADDGID
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"add gid=%d name=%s\n"
argument_list|,
name|nid
operator|.
name|nid_gid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't add group %s"
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
block|}
comment|/* 	 * Loop around adding all users. 	 */
name|start_uidpos
operator|=
name|i
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nid
operator|.
name|nid_usermax
operator|&&
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
condition|)
block|{
name|fnd_dup
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Yes, this is inefficient, but it is only done once when 		 * the daemon is started and will run in a fraction of a second 		 * for nid_usermax at 10000. If nid_usermax is cranked up to 		 * 100000, it will take several seconds, depending on the CPU. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|i
operator|-
name|start_uidpos
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|check_dups
index|[
name|j
index|]
operator|==
name|pwd
operator|->
name|pw_uid
condition|)
block|{
comment|/* Found another entry for uid, so skip it */
name|fnd_dup
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fnd_dup
operator|!=
literal|0
condition|)
continue|continue;
name|check_dups
index|[
name|i
operator|-
name|start_uidpos
index|]
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|nid
operator|.
name|nid_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|manage_gids
operator|!=
literal|0
condition|)
block|{
comment|/* Get the group list for this user. */
name|ngroup
operator|=
name|NGROUPS
expr_stmt|;
if|if
condition|(
name|getgrouplist
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|,
name|grps
argument_list|,
operator|&
name|ngroup
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Group list too small"
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
name|ngroup
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|grps
expr_stmt|;
block|}
else|else
block|{
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
block|}
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_ADDUID
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"add uid=%d name=%s\n"
argument_list|,
name|nid
operator|.
name|nid_uid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't add user %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
block|}
comment|/* 	 * I should feel guilty for not calling this for all the above exit() 	 * upon error cases, but I don't. 	 */
if|if
condition|(
name|mustfreeai
condition|)
name|freeaddrinfo
argument_list|(
name|aip
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Temporarily block SIGUSR1 and SIGCHLD, so slaves[] can't 	 * end up bogus. 	 */
name|sigemptyset
argument_list|(
operator|&
name|signew
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|signew
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|signew
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|signew
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|cleanup_term
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|cleanup_term
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"nfsuserd:"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
comment|/* 	 * Fork off the slave daemons that do the work. All the master 	 * does is kill them off and cleanup. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsuserdcnt
condition|;
name|i
operator|++
control|)
block|{
name|slaves
index|[
name|i
index|]
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|slaves
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|im_a_slave
operator|=
literal|1
expr_stmt|;
name|setproctitle
argument_list|(
literal|"slave"
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|signew
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|signew
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|signew
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * and away we go. 			 */
name|svc_run
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nfsuserd died: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slaves
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork: %m"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Just wait for SIGUSR1 or a child to die and then... 	 * As the Governor of California would say, "Terminate them". 	 */
name|setproctitle
argument_list|(
literal|"master"
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|signew
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|sigsuspend
argument_list|(
operator|&
name|signew
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The nfsuserd rpc service  */
end_comment

begin_function
specifier|static
name|void
name|nfsuserdsrv
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_short
name|sport
decl_stmt|;
name|struct
name|info
name|info
decl_stmt|;
name|struct
name|nfsd_idargs
name|nid
decl_stmt|;
name|u_int32_t
name|saddr
decl_stmt|;
name|gid_t
name|grps
index|[
name|NGROUPS
index|]
decl_stmt|;
name|int
name|ngroup
decl_stmt|;
comment|/* 	 * Only handle requests from 127.0.0.1 on a reserved port number. 	 * (Since a reserved port # at localhost implies a client with 	 *  local root, there won't be a security breach. This is about 	 *  the only case I can think of where a reserved port # means 	 *  something.) 	 */
name|sport
operator|=
name|ntohs
argument_list|(
name|transp
operator|->
name|xp_raddr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
name|saddr
operator|=
name|ntohl
argument_list|(
name|transp
operator|->
name|xp_raddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rqstp
operator|->
name|rq_proc
operator|!=
name|NULLPROC
operator|&&
name|sport
operator|>=
name|IPPORT_RESERVED
operator|)
operator|||
name|saddr
operator|!=
literal|0x7f000001
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"req from ip=0x%x port=%d\n"
argument_list|,
name|saddr
argument_list|,
name|sport
argument_list|)
expr_stmt|;
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|NULLPROC
case|:
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
name|NULL
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't send reply"
argument_list|)
expr_stmt|;
return|return;
case|case
name|RPCNFSUSERD_GETUID
case|:
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_getid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwd
operator|=
name|getpwuid
argument_list|(
operator|(
name|uid_t
operator|)
name|info
operator|.
name|id
argument_list|)
expr_stmt|;
name|info
operator|.
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
name|defusertimeout
expr_stmt|;
name|nid
operator|.
name|nid_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|manage_gids
operator|!=
literal|0
condition|)
block|{
comment|/* Get the group list for this user. */
name|ngroup
operator|=
name|NGROUPS
expr_stmt|;
if|if
condition|(
name|getgrouplist
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|,
name|grps
argument_list|,
operator|&
name|ngroup
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Group list too small"
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
name|ngroup
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|grps
expr_stmt|;
block|}
else|else
block|{
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
literal|5
expr_stmt|;
name|nid
operator|.
name|nid_uid
operator|=
operator|(
name|uid_t
operator|)
name|info
operator|.
name|id
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|defaultuser
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
block|}
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_ADDUID
expr_stmt|;
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|info
operator|.
name|retval
operator|=
name|error
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add user %s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Added uid=%d name=%s\n"
argument_list|,
name|nid
operator|.
name|nid_uid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_retval
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't send reply"
argument_list|)
expr_stmt|;
return|return;
case|case
name|RPCNFSUSERD_GETGID
case|:
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_getid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|grp
operator|=
name|getgrgid
argument_list|(
operator|(
name|gid_t
operator|)
name|info
operator|.
name|id
argument_list|)
expr_stmt|;
name|info
operator|.
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
name|defusertimeout
expr_stmt|;
name|nid
operator|.
name|nid_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|grp
operator|->
name|gr_name
expr_stmt|;
block|}
else|else
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
literal|5
expr_stmt|;
name|nid
operator|.
name|nid_gid
operator|=
operator|(
name|gid_t
operator|)
name|info
operator|.
name|id
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|defaultgroup
expr_stmt|;
block|}
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_ADDGID
expr_stmt|;
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|info
operator|.
name|retval
operator|=
name|error
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add group %s\n"
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Added gid=%d name=%s\n"
argument_list|,
name|nid
operator|.
name|nid_gid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_retval
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't send reply"
argument_list|)
expr_stmt|;
return|return;
case|case
name|RPCNFSUSERD_GETUSER
case|:
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_getname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwd
operator|=
name|getpwnam
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
name|info
operator|.
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
name|defusertimeout
expr_stmt|;
name|nid
operator|.
name|nid_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
block|}
else|else
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
literal|5
expr_stmt|;
name|nid
operator|.
name|nid_uid
operator|=
name|defaultuid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|info
operator|.
name|name
expr_stmt|;
block|}
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_ADDUSERNAME
expr_stmt|;
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|info
operator|.
name|retval
operator|=
name|error
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add user %s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Added uid=%d name=%s\n"
argument_list|,
name|nid
operator|.
name|nid_uid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_retval
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't send reply"
argument_list|)
expr_stmt|;
return|return;
case|case
name|RPCNFSUSERD_GETGROUP
case|:
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_getname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|grp
operator|=
name|getgrnam
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
name|info
operator|.
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
name|defusertimeout
expr_stmt|;
name|nid
operator|.
name|nid_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|grp
operator|->
name|gr_name
expr_stmt|;
block|}
else|else
block|{
name|nid
operator|.
name|nid_usertimeout
operator|=
literal|5
expr_stmt|;
name|nid
operator|.
name|nid_gid
operator|=
name|defaultgid
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|info
operator|.
name|name
expr_stmt|;
block|}
name|nid
operator|.
name|nid_namelen
operator|=
name|strlen
argument_list|(
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
name|nid
operator|.
name|nid_flag
operator|=
name|NFSID_ADDGROUPNAME
expr_stmt|;
name|error
operator|=
name|nfssvc
argument_list|(
name|NFSSVC_IDNAME
operator||
name|NFSSVC_NEWSTRUCT
argument_list|,
operator|&
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|info
operator|.
name|retval
operator|=
name|error
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add group %s\n"
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Added gid=%d name=%s\n"
argument_list|,
name|nid
operator|.
name|nid_gid
argument_list|,
name|nid
operator|.
name|nid_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_retval
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|info
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't send reply"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Xdr routine to get an id number  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_getid
parameter_list|(
name|XDR
modifier|*
name|xdrsp
parameter_list|,
name|caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|info
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|info
operator|*
operator|)
name|cp
decl_stmt|;
return|return
operator|(
name|xdr_long
argument_list|(
name|xdrsp
argument_list|,
operator|&
name|ifp
operator|->
name|id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Xdr routine to get a user name  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_getname
parameter_list|(
name|XDR
modifier|*
name|xdrsp
parameter_list|,
name|caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|info
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|info
operator|*
operator|)
name|cp
decl_stmt|;
name|long
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|xdr_long
argument_list|(
name|xdrsp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|>
name|MAXNAME
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|xdr_opaque
argument_list|(
name|xdrsp
argument_list|,
name|ifp
operator|->
name|name
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Xdr routine to return the value.  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_retval
parameter_list|(
name|XDR
modifier|*
name|xdrsp
parameter_list|,
name|caddr_t
name|cp
parameter_list|)
block|{
name|struct
name|info
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|info
operator|*
operator|)
name|cp
decl_stmt|;
name|long
name|val
decl_stmt|;
name|val
operator|=
name|ifp
operator|->
name|retval
expr_stmt|;
return|return
operator|(
name|xdr_long
argument_list|(
name|xdrsp
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cleanup_term() called via SIGUSR1.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_term
parameter_list|(
name|int
name|signo
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
if|if
condition|(
name|im_a_slave
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, so I'm the master. 	 * As the Governor of California might say, "Terminate them". 	 */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsuserdcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|slaves
index|[
name|i
index|]
operator|!=
operator|(
name|pid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|kill
argument_list|(
name|slaves
index|[
name|i
index|]
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * and wait for them to die 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|wait3
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, get rid of the socket 	 */
if|if
condition|(
name|nfssvc
argument_list|(
name|NFSSVC_NFSUSERDDELPORT
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't do nfssvc() to delete the port\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"usage: nfsuserd [-usermax cache_size] [-usertimeout minutes] [-verbose] [-manage-gids] [-domain domain_name] [n]"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

