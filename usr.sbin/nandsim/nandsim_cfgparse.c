begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2009-2012 Semihalf  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dev/nand/nandsim.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"nandsim_cfgparse.h"
end_include

begin_define
define|#
directive|define
name|warn
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \     printf("WARNING: " fmt "\n", ##args); } while (0)
end_define

begin_define
define|#
directive|define
name|error
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \     printf("ERROR: " fmt "\n", ##args); } while (0)
end_define

begin_define
define|#
directive|define
name|MSG_MANDATORYKEYMISSING
value|"mandatory key \"%s\" value belonging to " \     "section \"%s\" is missing!\n"
end_define

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \     printf("NANDSIM_CONF:" fmt "\n", ##args); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {} while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STRBUFSIZ
value|2000
end_define

begin_comment
comment|/* Macros extracts type and type size */
end_comment

begin_define
define|#
directive|define
name|TYPE
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xf8)
end_define

begin_define
define|#
directive|define
name|SIZE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x07))
end_define

begin_comment
comment|/* Erase/Prog/Read time max and min values */
end_comment

begin_define
define|#
directive|define
name|DELAYTIME_MIN
value|10000
end_define

begin_define
define|#
directive|define
name|DELAYTIME_MAX
value|10000000
end_define

begin_comment
comment|/* Structure holding configuration for controller. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sim_ctrl
name|ctrl_conf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure holding configuration for chip. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sim_chip
name|chip_conf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nandsim_key
name|nandsim_ctrl_keys
index|[]
init|=
block|{
block|{
literal|"num_cs"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
operator|.
name|num_cs
block|,
literal|0
block|}
block|,
block|{
literal|"ctrl_num"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
operator|.
name|num
block|,
literal|0
block|}
block|,
block|{
literal|"ecc_layout"
block|,
literal|1
block|,
name|VALUE_UINTARRAY
operator||
name|SIZE_16
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
operator|.
name|ecc_layout
block|,
name|MAX_ECC_BYTES
block|}
block|,
block|{
literal|"filename"
block|,
literal|0
block|,
name|VALUE_STRING
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
operator|.
name|filename
block|,
name|FILENAME_SIZE
block|}
block|,
block|{
literal|"ecc"
block|,
literal|0
block|,
name|VALUE_BOOL
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
operator|.
name|ecc
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nandsim_key
name|nandsim_chip_keys
index|[]
init|=
block|{
block|{
literal|"chip_cs"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|num
block|,
literal|0
block|}
block|,
block|{
literal|"chip_ctrl"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|ctrl_num
block|,
literal|0
block|}
block|,
block|{
literal|"device_id"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|device_id
block|,
literal|0
block|}
block|,
block|{
literal|"manufacturer_id"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|manufact_id
block|,
literal|0
block|}
block|,
block|{
literal|"model"
block|,
literal|0
block|,
name|VALUE_STRING
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|device_model
block|,
name|DEV_MODEL_STR_SIZE
block|}
block|,
block|{
literal|"manufacturer"
block|,
literal|0
block|,
name|VALUE_STRING
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|manufacturer
block|,
name|MAN_STR_SIZE
block|}
block|,
block|{
literal|"page_size"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|page_size
block|,
literal|0
block|}
block|,
block|{
literal|"oob_size"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|oob_size
block|,
literal|0
block|}
block|,
block|{
literal|"pages_per_block"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|pgs_per_blk
block|,
literal|0
block|}
block|,
block|{
literal|"blocks_per_lun"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|blks_per_lun
block|,
literal|0
block|}
block|,
block|{
literal|"luns"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|luns
block|,
literal|0
block|}
block|,
block|{
literal|"column_addr_cycle"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|col_addr_cycles
block|,
literal|0
block|}
block|,
block|{
literal|"row_addr_cycle"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|row_addr_cycles
block|,
literal|0
block|}
block|,
block|{
literal|"program_time"
block|,
literal|0
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|prog_time
block|,
literal|0
block|}
block|,
block|{
literal|"erase_time"
block|,
literal|0
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|erase_time
block|,
literal|0
block|}
block|,
block|{
literal|"read_time"
block|,
literal|0
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|read_time
block|,
literal|0
block|}
block|,
block|{
literal|"width"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_8
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|width
block|,
literal|0
block|}
block|,
block|{
literal|"wear_out"
block|,
literal|1
block|,
name|VALUE_UINT
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|wear_level
block|,
literal|0
block|}
block|,
block|{
literal|"bad_block_map"
block|,
literal|0
block|,
name|VALUE_UINTARRAY
operator||
name|SIZE_32
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|bad_block_map
block|,
name|MAX_BAD_BLOCKS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nandsim_section
name|sections
index|[]
init|=
block|{
block|{
literal|"ctrl"
block|,
operator|(
expr|struct
name|nandsim_key
operator|*
operator|)
operator|&
name|nandsim_ctrl_keys
block|}
block|,
block|{
literal|"chip"
block|,
operator|(
expr|struct
name|nandsim_key
operator|*
operator|)
operator|&
name|nandsim_chip_keys
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint8_t
name|logoutputtoint
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|validate_chips
parameter_list|(
name|struct
name|sim_chip
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sim_ctrl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|validate_ctrls
parameter_list|(
name|struct
name|sim_ctrl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|configure_sim
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|rcfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_ctrls
parameter_list|(
name|struct
name|rcfile
modifier|*
parameter_list|,
name|struct
name|sim_ctrl
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_chips
parameter_list|(
name|struct
name|rcfile
modifier|*
parameter_list|,
name|struct
name|sim_chip
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_ctrls
parameter_list|(
name|struct
name|sim_ctrl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_chips
parameter_list|(
name|struct
name|sim_chip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_section_config
parameter_list|(
name|struct
name|rcfile
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|convert_argint
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
name|value
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|0
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot convert to number argument \'%s\'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|convert_arguint
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
name|value
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtol
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|0
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot convert to number argument \'%s\'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse given ',' separated list of bytes into buffer. */
end_comment

begin_function
name|int
name|parse_intarray
parameter_list|(
name|char
modifier|*
name|array
parameter_list|,
name|int
modifier|*
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmpstr
decl_stmt|,
modifier|*
name|origstr
decl_stmt|;
name|unsigned
name|int
name|currbufp
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|,
name|from
init|=
literal|0
decl_stmt|,
name|to
init|=
literal|0
decl_stmt|;
comment|/* Remove square braces */
if|if
condition|(
name|array
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
name|array
operator|++
expr_stmt|;
if|if
condition|(
name|array
index|[
name|strlen
argument_list|(
name|array
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
name|array
index|[
name|strlen
argument_list|(
name|array
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|','
expr_stmt|;
name|from
operator|=
name|strlen
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|origstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|from
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|origstr
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|array
argument_list|,
literal|","
argument_list|)
expr_stmt|;
comment|/* First loop checks for how big int array we need to allocate */
while|while
condition|(
name|tmpstr
operator|!=
name|NULL
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|tmpstr
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tmp
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|convert_arguint
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|from
argument_list|)
operator|||
name|convert_arguint
argument_list|(
name|tmp
argument_list|,
operator|&
name|to
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|origstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|count
operator|+=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|convert_arguint
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|from
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|origstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Allocate buffer of ints */
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|origstr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Second loop is just inserting converted values into int array */
while|while
condition|(
name|tmpstr
operator|!=
name|NULL
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|tmpstr
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tmp
operator|=
literal|' '
expr_stmt|;
name|from
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|to
operator|=
name|strtol
argument_list|(
name|tmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|buffer
operator|)
index|[
name|currbufp
operator|++
index|]
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|from
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buffer
operator|)
index|[
name|currbufp
operator|++
index|]
operator|=
name|from
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|origstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert logoutput strings literals into appropriate ints. */
end_comment

begin_function
specifier|static
name|uint8_t
name|logoutputtoint
parameter_list|(
name|char
modifier|*
name|logoutput
parameter_list|,
name|int
modifier|*
name|output
parameter_list|)
block|{
name|int
name|out
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|logoutput
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
name|out
operator|=
name|NANDSIM_OUTPUT_FILE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|logoutput
argument_list|,
literal|"console"
argument_list|)
operator|==
literal|0
condition|)
name|out
operator|=
name|NANDSIM_OUTPUT_CONSOLE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|logoutput
argument_list|,
literal|"ram"
argument_list|)
operator|==
literal|0
condition|)
name|out
operator|=
name|NANDSIM_OUTPUT_RAM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|logoutput
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|out
operator|=
name|NANDSIM_OUTPUT_NONE
expr_stmt|;
else|else
name|out
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|output
operator|=
name|out
expr_stmt|;
if|if
condition|(
name|out
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|configure_sim
parameter_list|(
specifier|const
name|char
modifier|*
name|devfname
parameter_list|,
name|struct
name|rcfile
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|sim_param
name|sim_conf
decl_stmt|;
name|char
name|buf
index|[
literal|255
index|]
decl_stmt|;
name|int
name|err
decl_stmt|,
name|tmpv
decl_stmt|,
name|fd
decl_stmt|;
name|err
operator|=
name|rc_getint
argument_list|(
name|f
argument_list|,
literal|"sim"
argument_list|,
literal|0
argument_list|,
literal|"log_level"
argument_list|,
operator|&
name|tmpv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpv
operator|<
literal|0
operator|||
name|tmpv
operator|>
literal|255
operator|||
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Bad log level specified (%d)\n"
argument_list|,
name|tmpv
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
else|else
name|sim_conf
operator|.
name|log_level
operator|=
name|tmpv
expr_stmt|;
name|rc_getstring
argument_list|(
name|f
argument_list|,
literal|"sim"
argument_list|,
literal|0
argument_list|,
literal|"log_output"
argument_list|,
literal|255
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|)
expr_stmt|;
name|tmpv
operator|=
operator|-
literal|1
expr_stmt|;
name|err
operator|=
name|logoutputtoint
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|tmpv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Log output specified in config file does not seem to "
literal|"be valid (%s)!"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|sim_conf
operator|.
name|log_output
operator|=
name|tmpv
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|devfname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"could not open simulator device file (%s)!"
argument_list|,
name|devfname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
block|}
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_SIM_PARAM
argument_list|,
operator|&
name|sim_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"simulator parameters could not be modified: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_ctrls
parameter_list|(
name|struct
name|rcfile
modifier|*
name|f
parameter_list|,
name|struct
name|sim_ctrl
modifier|*
modifier|*
name|ctrls
parameter_list|,
name|int
modifier|*
name|cnt
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sim_ctrl
modifier|*
name|ctrlsptr
decl_stmt|;
name|count
operator|=
name|rc_getsectionscount
argument_list|(
name|f
argument_list|,
literal|"ctrl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|MAX_SIM_DEV
condition|)
block|{
name|error
argument_list|(
literal|"Too many CTRL sections specified(%d)"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No ctrl sections specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ctrlsptr
operator|=
operator|(
expr|struct
name|sim_ctrl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sim_ctrl
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrlsptr
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Could not allocate memory for ctrl configuration"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|ctrl_conf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * ECC layout have to end up with 0xffff, so 		 * we're filling buffer with 0xff. If ecc_layout is 		 * defined in config file, values will be overridden. 		 */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ctrl_conf
operator|.
name|ecc_layout
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|ctrl_conf
operator|.
name|ecc_layout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_section_config
argument_list|(
name|f
argument_list|,
literal|"ctrl"
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctrlsptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|parse_section
argument_list|(
name|f
argument_list|,
literal|"ctrl"
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ctrlsptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|ctrlsptr
index|[
name|i
index|]
argument_list|,
operator|&
name|ctrl_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|ctrl_conf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to create ctrl with config parsed */
name|debug
argument_list|(
literal|"NUM=%d\nNUM_CS=%d\nECC=%d\nFILENAME=%s\nECC_LAYOUT[0]"
literal|"=%d\nECC_LAYOUT[1]=%d\n\n"
argument_list|,
name|ctrlsptr
index|[
name|i
index|]
operator|.
name|num
argument_list|,
name|ctrlsptr
index|[
name|i
index|]
operator|.
name|num_cs
argument_list|,
name|ctrlsptr
index|[
name|i
index|]
operator|.
name|ecc
argument_list|,
name|ctrlsptr
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
name|ctrlsptr
index|[
name|i
index|]
operator|.
name|ecc_layout
index|[
literal|0
index|]
argument_list|,
name|ctrlsptr
index|[
name|i
index|]
operator|.
name|ecc_layout
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|cnt
operator|=
name|count
expr_stmt|;
operator|*
name|ctrls
operator|=
name|ctrlsptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_ctrls
parameter_list|(
name|struct
name|sim_ctrl
modifier|*
name|ctrls
parameter_list|)
block|{
name|free
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_chips
parameter_list|(
name|struct
name|rcfile
modifier|*
name|f
parameter_list|,
name|struct
name|sim_chip
modifier|*
modifier|*
name|chips
parameter_list|,
name|int
modifier|*
name|cnt
parameter_list|)
block|{
name|struct
name|sim_chip
modifier|*
name|chipsptr
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|count
operator|=
name|rc_getsectionscount
argument_list|(
name|f
argument_list|,
literal|"chip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
operator|(
name|MAX_CTRL_CS
operator|*
name|MAX_SIM_DEV
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Too many chip sections specified(%d)"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No chip sections specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|chipsptr
operator|=
operator|(
expr|struct
name|sim_chip
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sim_chip
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipsptr
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Could not allocate memory for chip configuration"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|chip_conf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Bad block map have to end up with 0xffff, so 		 * we're filling array with 0xff. If bad block map is 		 * defined in config file, values will be overridden. 		 */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|chip_conf
operator|.
name|bad_block_map
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|chip_conf
operator|.
name|bad_block_map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_section_config
argument_list|(
name|f
argument_list|,
literal|"chip"
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|chipsptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|parse_section
argument_list|(
name|f
argument_list|,
literal|"chip"
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|chipsptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|chipsptr
index|[
name|i
index|]
argument_list|,
operator|&
name|chip_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|chip_conf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to create chip with config parsed */
name|debug
argument_list|(
literal|"CHIP:\nNUM=%d\nCTRL_NUM=%d\nDEVID=%d\nMANID=%d\n"
literal|"PAGE_SZ=%d\nOOBSZ=%d\nREAD_T=%d\nDEVMODEL=%s\n"
literal|"MAN=%s\nCOLADDRCYCLES=%d\nROWADDRCYCLES=%d\nCHWIDTH=%d\n"
literal|"PGS/BLK=%d\nBLK/LUN=%d\nLUNS=%d\nERR_RATIO=%d\n"
literal|"WEARLEVEL=%d\nISWP=%d\n\n\n\n"
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|num
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|ctrl_num
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|device_id
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|manufact_id
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|page_size
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|oob_size
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|read_time
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|device_model
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|manufacturer
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|col_addr_cycles
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|row_addr_cycles
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|pgs_per_blk
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|blks_per_lun
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|luns
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|error_ratio
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|wear_level
argument_list|,
name|chipsptr
index|[
name|i
index|]
operator|.
name|is_wp
argument_list|)
expr_stmt|;
block|}
operator|*
name|cnt
operator|=
name|count
expr_stmt|;
operator|*
name|chips
operator|=
name|chipsptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_chips
parameter_list|(
name|struct
name|sim_chip
modifier|*
name|chips
parameter_list|)
block|{
name|free
argument_list|(
name|chips
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|parse_config
parameter_list|(
name|char
modifier|*
name|cfgfname
parameter_list|,
specifier|const
name|char
modifier|*
name|devfname
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|;
name|unsigned
name|int
name|chipsectionscnt
decl_stmt|,
name|ctrlsectionscnt
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|rcfile
modifier|*
name|f
decl_stmt|;
name|struct
name|sim_chip
modifier|*
name|chips
decl_stmt|;
name|struct
name|sim_ctrl
modifier|*
name|ctrls
decl_stmt|;
name|err
operator|=
name|rc_open
argument_list|(
name|cfgfname
argument_list|,
literal|"r"
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"could not open configuration file (%s)"
argument_list|,
name|cfgfname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_NOINPUT
operator|)
return|;
block|}
comment|/* First, try to configure simulator itself. */
if|if
condition|(
name|configure_sim
argument_list|(
name|devfname
argument_list|,
name|f
argument_list|)
operator|!=
name|EX_OK
condition|)
block|{
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"SIM CONFIGURED!\n"
argument_list|)
expr_stmt|;
comment|/* Then create controllers' configs */
if|if
condition|(
name|create_ctrls
argument_list|(
name|f
argument_list|,
operator|&
name|ctrls
argument_list|,
operator|&
name|ctrlsectionscnt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"CTRLS CONFIG READ!\n"
argument_list|)
expr_stmt|;
comment|/* Then create chips' configs */
if|if
condition|(
name|create_chips
argument_list|(
name|f
argument_list|,
operator|&
name|chips
argument_list|,
operator|&
name|chipsectionscnt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"CHIPS CONFIG READ!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_ctrls
argument_list|(
name|ctrls
argument_list|,
name|ctrlsectionscnt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
name|destroy_chips
argument_list|(
name|chips
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|validate_chips
argument_list|(
name|chips
argument_list|,
name|chipsectionscnt
argument_list|,
name|ctrls
argument_list|,
name|ctrlsectionscnt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
name|destroy_chips
argument_list|(
name|chips
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
comment|/* Open device */
name|fd
operator|=
name|open
argument_list|(
name|devfname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"could not open simulator device file (%s)!"
argument_list|,
name|devfname
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|destroy_chips
argument_list|(
name|chips
argument_list|)
expr_stmt|;
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"SIM CONFIG STARTED!\n"
argument_list|)
expr_stmt|;
comment|/* At this stage, both ctrls' and chips' configs should be valid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctrlsectionscnt
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_CREATE_CTRL
argument_list|,
operator|&
name|ctrls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EEXIST
condition|)
name|error
argument_list|(
literal|"Controller#%d already created\n"
argument_list|,
name|ctrls
index|[
name|i
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
name|error
argument_list|(
literal|"Incorrect controller number (%d)\n"
argument_list|,
name|ctrls
index|[
name|i
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Could not created controller#%d\n"
argument_list|,
name|ctrls
index|[
name|i
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
comment|/* Errors during controller creation stops parsing */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
name|destroy_chips
argument_list|(
name|chips
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"CTRL#%d CONFIG STARTED!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chipsectionscnt
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_CREATE_CHIP
argument_list|,
operator|&
name|chips
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EEXIST
condition|)
name|error
argument_list|(
literal|"Chip#%d for controller#%d already "
literal|"created\n"
argument_list|,
name|chips
index|[
name|i
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|i
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
name|error
argument_list|(
literal|"Incorrect chip number (%d:%d)\n"
argument_list|,
name|chips
index|[
name|i
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|i
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Could not create chip (%d:%d)\n"
argument_list|,
name|chips
index|[
name|i
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|i
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not start chip#%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|destroy_chips
argument_list|(
name|chips
argument_list|)
expr_stmt|;
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|debug
argument_list|(
literal|"CHIPS CONFIG STARTED!\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|rc_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|destroy_chips
argument_list|(
name|chips
argument_list|)
expr_stmt|;
name|destroy_ctrls
argument_list|(
name|ctrls
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function tries to get appropriate value for given key, convert it to  * array of ints (of given size), and perform all the necessary checks and  * conversions.  */
end_comment

begin_function
specifier|static
name|int
name|get_argument_intarray
parameter_list|(
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|int
name|sectno
parameter_list|,
name|struct
name|nandsim_key
modifier|*
name|key
parameter_list|,
name|struct
name|rcfile
modifier|*
name|f
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|STRBUFSIZ
index|]
decl_stmt|;
name|int
modifier|*
name|intbuf
decl_stmt|;
name|int
name|getres
decl_stmt|;
name|uint32_t
name|cnt
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|getres
operator|=
name|rc_getstring
argument_list|(
name|f
argument_list|,
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|STRBUFSIZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|strbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|mandatory
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_MANDATORYKEYMISSING
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
comment|/* Non-mandatory key, not present -- skip */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|parse_intarray
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|strbuf
argument_list|,
operator|&
name|intbuf
argument_list|)
expr_stmt|;
name|cnt
operator|=
operator|(
name|cnt
operator|<=
name|key
operator|->
name|maxlength
operator|)
condition|?
name|cnt
else|:
name|key
operator|->
name|maxlength
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SIZE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
operator|==
name|SIZE_8
condition|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|key
operator|->
name|field
operator|)
operator|+
name|i
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|intbuf
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|SIZE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
operator|==
name|SIZE_16
condition|)
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|key
operator|->
name|field
operator|)
operator|+
name|i
operator|)
operator|=
operator|(
name|uint16_t
operator|)
name|intbuf
index|[
name|i
index|]
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|key
operator|->
name|field
operator|)
operator|+
name|i
operator|)
operator|=
operator|(
name|uint32_t
operator|)
name|intbuf
index|[
name|i
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|intbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Function tries to get appropriate value for given key, convert it to  *  int of certain length.  */
end_comment

begin_function
specifier|static
name|int
name|get_argument_int
parameter_list|(
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|int
name|sectno
parameter_list|,
name|struct
name|nandsim_key
modifier|*
name|key
parameter_list|,
name|struct
name|rcfile
modifier|*
name|f
parameter_list|)
block|{
name|int
name|getres
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|getres
operator|=
name|rc_getint
argument_list|(
name|f
argument_list|,
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|mandatory
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_MANDATORYKEYMISSING
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
comment|/* Non-mandatory key, not present -- skip */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|SIZE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
operator|==
name|SIZE_8
condition|)
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|key
operator|->
name|field
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|SIZE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
operator|==
name|SIZE_16
condition|)
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|key
operator|->
name|field
operator|)
operator|=
operator|(
name|uint16_t
operator|)
name|val
expr_stmt|;
else|else
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|key
operator|->
name|field
operator|)
operator|=
operator|(
name|uint32_t
operator|)
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function tries to get string value for given key */
end_comment

begin_function
specifier|static
name|int
name|get_argument_string
parameter_list|(
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|int
name|sectno
parameter_list|,
name|struct
name|nandsim_key
modifier|*
name|key
parameter_list|,
name|struct
name|rcfile
modifier|*
name|f
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|STRBUFSIZ
index|]
decl_stmt|;
name|int
name|getres
decl_stmt|;
name|getres
operator|=
name|rc_getstring
argument_list|(
name|f
argument_list|,
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|STRBUFSIZ
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|mandatory
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_MANDATORYKEYMISSING
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
comment|/* Non-mandatory key, not present -- skip */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|key
operator|->
name|field
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|strbuf
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|key
operator|->
name|maxlength
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function tries to get on/off value for given key */
end_comment

begin_function
specifier|static
name|int
name|get_argument_bool
parameter_list|(
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|int
name|sectno
parameter_list|,
name|struct
name|nandsim_key
modifier|*
name|key
parameter_list|,
name|struct
name|rcfile
modifier|*
name|f
parameter_list|)
block|{
name|int
name|getres
decl_stmt|,
name|val
decl_stmt|;
name|getres
operator|=
name|rc_getbool
argument_list|(
name|f
argument_list|,
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|mandatory
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_MANDATORYKEYMISSING
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
comment|/* Non-mandatory key, not present -- skip */
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|key
operator|->
name|field
operator|=
operator|(
name|uint8_t
operator|)
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|parse_section
parameter_list|(
name|struct
name|rcfile
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|int
name|sectno
parameter_list|)
block|{
name|struct
name|nandsim_key
modifier|*
name|key
decl_stmt|;
name|struct
name|nandsim_section
modifier|*
name|sect
init|=
operator|(
expr|struct
name|nandsim_section
operator|*
operator|)
operator|&
name|sections
decl_stmt|;
name|int
name|getres
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect
operator|->
name|name
argument_list|,
name|sect_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
name|sect
operator|++
expr_stmt|;
block|}
name|key
operator|=
name|sect
operator|->
name|keys
expr_stmt|;
do|do
block|{
name|debug
argument_list|(
literal|"->Section: %s, Key: %s, type: %d, size: %d"
argument_list|,
name|sect_name
argument_list|,
name|key
operator|->
name|keyname
argument_list|,
name|TYPE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
argument_list|,
name|SIZE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|key
operator|->
name|valuetype
argument_list|)
condition|)
block|{
case|case
name|VALUE_UINT
case|:
comment|/* Single int value */
name|getres
operator|=
name|get_argument_int
argument_list|(
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
return|return
operator|(
name|getres
operator|)
return|;
break|break;
case|case
name|VALUE_UINTARRAY
case|:
comment|/* Array of ints */
name|getres
operator|=
name|get_argument_intarray
argument_list|(
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
return|return
operator|(
name|getres
operator|)
return|;
break|break;
case|case
name|VALUE_STRING
case|:
comment|/* Array of chars */
name|getres
operator|=
name|get_argument_string
argument_list|(
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
return|return
operator|(
name|getres
operator|)
return|;
break|break;
case|case
name|VALUE_BOOL
case|:
comment|/* Boolean value (true/false/on/off/yes/no) */
name|getres
operator|=
name|get_argument_bool
argument_list|(
name|sect_name
argument_list|,
name|sectno
argument_list|,
name|key
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|getres
operator|!=
literal|0
condition|)
return|return
operator|(
name|getres
operator|)
return|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|++
name|key
operator|)
operator|->
name|keyname
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|validate_chips
parameter_list|(
name|struct
name|sim_chip
modifier|*
name|chips
parameter_list|,
name|int
name|chipcnt
parameter_list|,
name|struct
name|sim_ctrl
modifier|*
name|ctrls
parameter_list|,
name|int
name|ctrlcnt
parameter_list|)
block|{
name|int
name|cchipcnt
decl_stmt|,
name|i
decl_stmt|,
name|width
decl_stmt|,
name|j
decl_stmt|,
name|id
decl_stmt|,
name|max
decl_stmt|;
name|cchipcnt
operator|=
name|chipcnt
expr_stmt|;
for|for
control|(
name|chipcnt
operator|-=
literal|1
init|;
name|chipcnt
operator|>=
literal|0
condition|;
name|chipcnt
operator|--
control|)
block|{
if|if
condition|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
operator|>=
name|MAX_CTRL_CS
condition|)
block|{
name|error
argument_list|(
literal|"chip no. too high (%d)!!\n"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
operator|>=
name|MAX_SIM_DEV
condition|)
block|{
name|error
argument_list|(
literal|"controller no. too high (%d)!!\n"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|width
operator|!=
literal|8
operator|&&
name|chips
index|[
name|chipcnt
index|]
operator|.
name|width
operator|!=
literal|16
condition|)
block|{
name|error
argument_list|(
literal|"invalid width:%d for chip#%d"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|width
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check if page size is> 512 and if its power of 2 */
if|if
condition|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|page_size
operator|<
literal|512
operator|||
operator|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|page_size
operator|&
operator|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid page size:%d for chip#%d at ctrl#%d!!"
literal|"\n"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|page_size
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check if controller no. ctrl_num is configured */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|id
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|ctrlcnt
operator|&&
name|id
operator|==
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ctrls
index|[
name|i
index|]
operator|.
name|num
operator|==
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
condition|)
name|id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ctrlcnt
operator|&&
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Missing configuration for controller %d"
literal|" (at least one chip is connected to it)"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Controller is configured -> check oob_size 			 * validity 			 */
name|i
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|ctrls
index|[
name|id
index|]
operator|.
name|ecc_layout
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|MAX_ECC_BYTES
operator|&&
name|ctrls
index|[
name|id
index|]
operator|.
name|ecc_layout
index|[
name|i
index|]
operator|!=
literal|0xffff
condition|)
block|{
if|if
condition|(
name|ctrls
index|[
name|id
index|]
operator|.
name|ecc_layout
index|[
name|i
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|ctrls
index|[
name|id
index|]
operator|.
name|ecc_layout
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|oob_size
operator|<
operator|(
name|unsigned
operator|)
name|i
condition|)
block|{
name|error
argument_list|(
literal|"OOB size for chip#%d at ctrl#%d is "
literal|"smaller than ecc layout length!"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|oob_size
operator|<
operator|(
name|unsigned
operator|)
name|max
condition|)
block|{
name|error
argument_list|(
literal|"OOB size for chip#%d at ctrl#%d is "
literal|"smaller than maximal ecc position in "
literal|"defined layout!"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|erase_time
operator|<
name|DELAYTIME_MIN
operator|||
name|chips
index|[
name|chipcnt
index|]
operator|.
name|erase_time
operator|>
name|DELAYTIME_MAX
operator|)
operator|&&
name|chips
index|[
name|chipcnt
index|]
operator|.
name|erase_time
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid erase time value for chip#%d at "
literal|"ctrl#%d"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|prog_time
operator|<
name|DELAYTIME_MIN
operator|||
name|chips
index|[
name|chipcnt
index|]
operator|.
name|prog_time
operator|>
name|DELAYTIME_MAX
operator|)
operator|&&
name|chips
index|[
name|chipcnt
index|]
operator|.
name|prog_time
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid prog time value for chip#%d at "
literal|"ctr#%d!"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chips
index|[
name|chipcnt
index|]
operator|.
name|read_time
operator|<
name|DELAYTIME_MIN
operator|||
name|chips
index|[
name|chipcnt
index|]
operator|.
name|read_time
operator|>
name|DELAYTIME_MAX
operator|)
operator|&&
name|chips
index|[
name|chipcnt
index|]
operator|.
name|read_time
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid read time value for chip#%d at "
literal|"ctrl#%d!"
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|num
argument_list|,
name|chips
index|[
name|chipcnt
index|]
operator|.
name|ctrl_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* Check if chips attached to the same controller, have same width */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctrlcnt
condition|;
name|i
operator|++
control|)
block|{
name|width
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cchipcnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|chips
index|[
name|j
index|]
operator|.
name|ctrl_num
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|width
operator|==
operator|-
literal|1
condition|)
block|{
name|width
operator|=
name|chips
index|[
name|j
index|]
operator|.
name|width
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|width
operator|!=
name|chips
index|[
name|j
index|]
operator|.
name|width
condition|)
block|{
name|error
argument_list|(
literal|"Chips attached to "
literal|"ctrl#%d have different "
literal|"widths!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|validate_ctrls
parameter_list|(
name|struct
name|sim_ctrl
modifier|*
name|ctrl
parameter_list|,
name|int
name|ctrlcnt
parameter_list|)
block|{
for|for
control|(
name|ctrlcnt
operator|-=
literal|1
init|;
name|ctrlcnt
operator|>=
literal|0
condition|;
name|ctrlcnt
operator|--
control|)
block|{
if|if
condition|(
name|ctrl
index|[
name|ctrlcnt
index|]
operator|.
name|num
operator|>
name|MAX_SIM_DEV
condition|)
block|{
name|error
argument_list|(
literal|"Controller no. too high (%d)!!\n"
argument_list|,
name|ctrl
index|[
name|ctrlcnt
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ctrl
index|[
name|ctrlcnt
index|]
operator|.
name|num_cs
operator|>
name|MAX_CTRL_CS
condition|)
block|{
name|error
argument_list|(
literal|"Too many CS (%d)!!\n"
argument_list|,
name|ctrl
index|[
name|ctrlcnt
index|]
operator|.
name|num_cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ctrl
index|[
name|ctrlcnt
index|]
operator|.
name|ecc
operator|!=
literal|0
operator|&&
name|ctrl
index|[
name|ctrlcnt
index|]
operator|.
name|ecc
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"ECC is set to neither 0 nor 1 !\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_section_config
parameter_list|(
name|struct
name|rcfile
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|int
name|sectno
parameter_list|)
block|{
name|struct
name|nandsim_key
modifier|*
name|key
decl_stmt|;
name|struct
name|nandsim_section
modifier|*
name|sect
decl_stmt|;
name|char
modifier|*
modifier|*
name|keys_tbl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|match
decl_stmt|;
for|for
control|(
name|match
operator|=
literal|0
operator|,
name|sect
operator|=
operator|(
expr|struct
name|nandsim_section
operator|*
operator|)
operator|&
name|sections
init|;
name|sect
operator|!=
name|NULL
condition|;
name|sect
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sect
operator|->
name|name
argument_list|,
name|sect_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|keys_tbl
operator|=
name|rc_getkeys
argument_list|(
name|f
argument_list|,
name|sect_name
argument_list|,
name|sectno
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys_tbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keys_tbl
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|sect
operator|->
name|keys
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|keys_tbl
index|[
name|i
index|]
argument_list|,
name|key
operator|->
name|keyname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|++
name|key
operator|)
operator|->
name|keyname
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid key in config file: %s\n"
argument_list|,
name|keys_tbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keys_tbl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|keys_tbl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

