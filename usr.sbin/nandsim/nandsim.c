begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2009-2012 Semihalf  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Control application for the NAND simulator.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dev/nand/nandsim.h>
end_include

begin_include
include|#
directive|include
file|<dev/nand/nand_dev.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|"nandsim_cfgparse.h"
end_include

begin_define
define|#
directive|define
name|SIMDEVICE
value|"/dev/nandsim.ioctl"
end_define

begin_define
define|#
directive|define
name|error
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \     printf("ERROR: " fmt "\n", ##args); } while (0)
end_define

begin_define
define|#
directive|define
name|warn
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \     printf("WARNING: " fmt "\n", ##args); } while (0)
end_define

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \     printf("NANDSIM_CONF:" fmt "\n", ##args); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {} while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NANDSIM_RAM_LOG_SIZE
value|16384
end_define

begin_define
define|#
directive|define
name|MSG_NOTRUNNING
value|"Controller#%d is not running.Please start" \     " it first."
end_define

begin_define
define|#
directive|define
name|MSG_RUNNING
value|"Controller#%d is already running!"
end_define

begin_define
define|#
directive|define
name|MSG_CTRLCHIPNEEDED
value|"You have to specify ctrl_no:cs_no pair!"
end_define

begin_define
define|#
directive|define
name|MSG_STATUSACQCTRLCHIP
value|"Could not acquire status for ctrl#%d chip#%d"
end_define

begin_define
define|#
directive|define
name|MSG_STATUSACQCTRL
value|"Could not acquire status for ctrl#%d"
end_define

begin_define
define|#
directive|define
name|MSG_NOCHIP
value|"There is no such chip configured (chip#%d "\     "at ctrl#%d)!"
end_define

begin_define
define|#
directive|define
name|MSG_NOCTRL
value|"Controller#%d is not configured!"
end_define

begin_define
define|#
directive|define
name|MSG_NOTCONFIGDCTRLCHIP
value|"Chip connected to ctrl#%d at cs#%d " \     "is not configured."
end_define

begin_typedef
typedef|typedef
name|int
function_decl|(
name|commandfunc_t
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|struct
name|nandsim_command
modifier|*
name|getcommand
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_devstring
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printchip
parameter_list|(
name|struct
name|sim_chip
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printctrl
parameter_list|(
name|struct
name|sim_ctrl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opendev
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdstop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdmod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmderror
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdbb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdfreeze
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdlog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmddump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdrestore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmddestroy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|commandfunc_t
name|cmdhelp
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|checkusage
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_chip_created
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_ctrl_created
parameter_list|(
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_ctrl_running
parameter_list|(
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|assert_chip_connected
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|printstats
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|nandsim_command
block|{
specifier|const
name|char
modifier|*
name|cmd_name
decl_stmt|;
comment|/* Command name */
name|commandfunc_t
modifier|*
name|commandfunc
decl_stmt|;
comment|/* Ptr to command function */
name|uint8_t
name|req_argc
decl_stmt|;
comment|/* Mandatory arguments count */
specifier|const
name|char
modifier|*
name|usagestring
decl_stmt|;
comment|/* Usage string */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|nandsim_command
name|commands
index|[]
init|=
block|{
block|{
literal|"status"
block|,
name|cmdstatus
block|,
literal|1
block|,
literal|"status<ctl_no|--all|-a> [-v]\n"
block|}
block|,
block|{
literal|"conf"
block|,
name|cmdconf
block|,
literal|1
block|,
literal|"conf<filename>\n"
block|}
block|,
block|{
literal|"start"
block|,
name|cmdstart
block|,
literal|1
block|,
literal|"start<ctrl_no>\n"
block|}
block|,
block|{
literal|"mod"
block|,
name|cmdmod
block|,
literal|2
block|,
literal|"mod [-l<loglevel>] |<ctl_no:cs_no> [-p<prog_time>]\n"
literal|"\t[-e<erase_time>] [-r<read_time>]\n"
literal|"\t[-E<error_ratio>] | [-h]\n"
block|}
block|,
block|{
literal|"stop"
block|,
name|cmdstop
block|,
literal|1
block|,
literal|"stop<ctrl_no>\n"
block|}
block|,
block|{
literal|"error"
block|,
name|cmderror
block|,
literal|5
block|,
literal|"error<ctrl_no:cs_no><page_num><column><length><pattern>\n"
block|}
block|,
block|{
literal|"bb"
block|,
name|cmdbb
block|,
literal|2
block|,
literal|"bb<ctl_no:cs_no>  [blk_num1,blk_num2,..] [-U] [-L]\n"
block|}
block|,
block|{
literal|"freeze"
block|,
name|cmdfreeze
block|,
literal|1
block|,
literal|"freeze [ctrl_no]\n"
block|}
block|,
block|{
literal|"log"
block|,
name|cmdlog
block|,
literal|1
block|,
literal|"log<ctrl_no|--all|-a>\n"
block|}
block|,
block|{
literal|"stats"
block|,
name|cmdstats
block|,
literal|2
block|,
literal|"stats<ctrl_no:cs_no><pagenumber>\n"
block|}
block|,
block|{
literal|"dump"
block|,
name|cmddump
block|,
literal|2
block|,
literal|"dump<ctrl_no:cs_no><filename>\n"
block|}
block|,
block|{
literal|"restore"
block|,
name|cmdrestore
block|,
literal|2
block|,
literal|"restore<ctrl_no:chip_no><filename>\n"
block|}
block|,
block|{
literal|"destroy"
block|,
name|cmddestroy
block|,
literal|1
block|,
literal|"destroy<ctrl_no[:cs_no]|--all|-a>\n"
block|}
block|,
block|{
literal|"help"
block|,
name|cmdhelp
block|,
literal|0
block|,
literal|"help [-v]"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse command name, and start appropriate function */
end_comment

begin_function
specifier|static
name|struct
name|nandsim_command
modifier|*
name|getcommand
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nandsim_command
modifier|*
name|opts
decl_stmt|;
for|for
control|(
name|opts
operator|=
name|commands
init|;
operator|(
name|opts
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|opts
operator|->
name|cmd_name
operator|!=
name|NULL
operator|)
condition|;
name|opts
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|opts
operator|->
name|cmd_name
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|opts
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse given string in format<ctrl_no>:<cs_no>, if possible -- set  * ctrl and/or cs, and return 0 (success) or 1 (in case of error).  *  * ctrl == 0xff&& chip == 0xff  : '--all' flag specified  * ctrl != 0xff&& chip != 0xff  : both ctrl& chip were specified  * ctrl != 0xff&& chip == 0xff  : only ctrl was specified  */
end_comment

begin_function
specifier|static
name|int
name|parse_devstring
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|ctrl
parameter_list|,
name|int
modifier|*
name|cs
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|unsigned
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|/* Ignore white spaces at the beginning */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
operator|&&
operator|(
operator|*
name|str
operator|!=
literal|'\0'
operator|)
condition|)
name|str
operator|++
expr_stmt|;
operator|*
name|ctrl
operator|=
literal|0xff
expr_stmt|;
operator|*
name|cs
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"--all"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If --all or -a is specified, ctl==chip==0xff */
name|debug
argument_list|(
literal|"CTRL=%d CHIP=%d\n"
argument_list|,
operator|*
name|ctrl
argument_list|,
operator|*
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Separate token and try to convert it to int */
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|str
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|convert_arguint
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|num
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|num
operator|>
name|MAX_SIM_DEV
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Invalid ctrl_no supplied: %s. Valid ctrl_no "
literal|"value must lie between 0 and 3!"
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|ctrl
operator|=
name|num
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|convert_arguint
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|num
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Check if chip_no is valid */
if|if
condition|(
name|num
operator|>
name|MAX_CTRL_CS
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Invalid chip_no supplied: %s. Valid "
literal|"chip_no value must lie between 0 and 3!"
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|cs
operator|=
name|num
expr_stmt|;
block|}
block|}
else|else
comment|/* Empty devstring supplied */
return|return
operator|(
literal|1
operator|)
return|;
name|debug
argument_list|(
literal|"CTRL=%d CHIP=%d\n"
argument_list|,
operator|*
name|ctrl
argument_list|,
operator|*
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opendev
parameter_list|(
name|int
modifier|*
name|fd
parameter_list|)
block|{
operator|*
name|fd
operator|=
name|open
argument_list|(
name|SIMDEVICE
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not open simulator device file (%s)!"
argument_list|,
name|SIMDEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
block|}
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opencdev
parameter_list|(
name|int
modifier|*
name|cdevd
parameter_list|,
name|int
name|ctrl
parameter_list|,
name|int
name|chip
parameter_list|)
block|{
name|char
name|fname
index|[
literal|255
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"/dev/nandsim%d.%d"
argument_list|,
name|ctrl
argument_list|,
name|chip
argument_list|)
expr_stmt|;
operator|*
name|cdevd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cdevd
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EX_NOINPUT
operator|)
return|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if given arguments count match requirements. If no, or  * --help (-h) flag is specified -- return 1 (print usage)  */
end_comment

begin_function
specifier|static
name|int
name|checkusage
parameter_list|(
name|int
name|gargc
parameter_list|,
name|int
name|argsreqd
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
if|if
condition|(
name|gargc
operator|<
name|argsreqd
operator|+
literal|2
operator|||
operator|(
name|gargc
operator|>=
operator|(
name|argsreqd
operator|+
literal|2
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|gargv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdstatus
parameter_list|(
name|int
name|gargc
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|idx
decl_stmt|,
name|idx2
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|uint8_t
name|verbose
init|=
literal|0
decl_stmt|;
name|struct
name|sim_ctrl
name|ctrlconf
decl_stmt|;
name|struct
name|sim_chip
name|chipconf
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctl
operator|==
literal|0xff
condition|)
block|{
comment|/* Every controller */
name|start
operator|=
literal|0
expr_stmt|;
name|stop
operator|=
name|MAX_SIM_DEV
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Specified controller only */
name|start
operator|=
name|ctl
expr_stmt|;
name|stop
operator|=
name|ctl
expr_stmt|;
block|}
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|gargc
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|idx
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|idx
index|]
argument_list|,
literal|"--verbose"
argument_list|)
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<=
name|stop
condition|;
name|idx
operator|++
control|)
block|{
name|ctrlconf
operator|.
name|num
operator|=
name|idx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_STATUS_CTRL
argument_list|,
operator|&
name|ctrlconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
name|error
argument_list|(
name|MSG_STATUSACQCTRL
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printctrl
argument_list|(
operator|&
name|ctrlconf
argument_list|)
expr_stmt|;
for|for
control|(
name|idx2
operator|=
literal|0
init|;
name|idx2
operator|<
name|MAX_CTRL_CS
condition|;
name|idx2
operator|++
control|)
block|{
name|chipconf
operator|.
name|num
operator|=
name|idx2
expr_stmt|;
name|chipconf
operator|.
name|ctrl_num
operator|=
name|idx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_STATUS_CHIP
argument_list|,
operator|&
name|chipconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
name|error
argument_list|(
name|MSG_STATUSACQCTRL
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printchip
argument_list|(
operator|&
name|chipconf
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdconf
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|parse_config
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
name|SIMDEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_DATAERR
operator|)
return|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdstart
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|running
decl_stmt|,
name|state
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
name|err
operator|=
name|is_ctrl_created
argument_list|(
name|ctl
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_NOCTRL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|err
operator|=
name|is_ctrl_running
argument_list|(
name|ctl
argument_list|,
operator|&
name|running
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|running
condition|)
block|{
name|warn
argument_list|(
name|MSG_RUNNING
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_START_CTRL
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Cannot start controller#%d"
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdstop
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|running
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
name|err
operator|=
name|is_ctrl_running
argument_list|(
name|ctl
argument_list|,
operator|&
name|running
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
operator|!
name|running
condition|)
block|{
name|error
argument_list|(
name|MSG_NOTRUNNING
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_STOP_CTRL
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Cannot stop controller#%d"
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdmod
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|chip
decl_stmt|,
name|ctl
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sim_mod
name|mods
decl_stmt|;
if|if
condition|(
name|gargc
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
literal|"--loglevel"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Set loglevel (ctrl:chip pair independant) */
name|mods
operator|.
name|field
operator|=
name|SIM_MOD_LOG_LEVEL
expr_stmt|;
if|if
condition|(
name|convert_arguint
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
operator|&
name|mods
operator|.
name|new_value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_MODIFY
argument_list|,
operator|&
name|mods
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"simulator parameter %s could not be "
literal|"modified !"
argument_list|,
name|gargv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"request : loglevel = %d\n"
argument_list|,
name|mods
operator|.
name|new_value
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
block|}
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
elseif|else
if|if
condition|(
name|chip
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
name|MSG_CTRLCHIPNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|assert_chip_connected
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
comment|/* Find out which flags were passed */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|gargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|convert_arguint
argument_list|(
name|gargv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|mods
operator|.
name|new_value
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"--prog-time"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"-p"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mods
operator|.
name|field
operator|=
name|SIM_MOD_PROG_TIME
expr_stmt|;
name|debug
argument_list|(
literal|"request : progtime = %d\n"
argument_list|,
name|mods
operator|.
name|new_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"--erase-time"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"-e"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mods
operator|.
name|field
operator|=
name|SIM_MOD_ERASE_TIME
expr_stmt|;
name|debug
argument_list|(
literal|"request : eraseime = %d\n"
argument_list|,
name|mods
operator|.
name|new_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"--read-time"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mods
operator|.
name|field
operator|=
name|SIM_MOD_READ_TIME
expr_stmt|;
name|debug
argument_list|(
literal|"request : read_time = %d\n"
argument_list|,
name|mods
operator|.
name|new_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"--error-ratio"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|i
index|]
argument_list|,
literal|"-E"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mods
operator|.
name|field
operator|=
name|SIM_MOD_ERROR_RATIO
expr_stmt|;
name|debug
argument_list|(
literal|"request : error_ratio = %d\n"
argument_list|,
name|mods
operator|.
name|new_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Flag not recognized, or nothing specified. */
name|error
argument_list|(
literal|"Unrecognized flag:%s\n"
argument_list|,
name|gargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
name|mods
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
name|mods
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
comment|/* Call appropriate ioctl */
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_MODIFY
argument_list|,
operator|&
name|mods
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"simulator parameter %s could not be modified! "
argument_list|,
name|gargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmderror
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|uint32_t
name|page
decl_stmt|,
name|column
decl_stmt|,
name|len
decl_stmt|,
name|pattern
decl_stmt|;
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|sim_error
name|sim_err
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
if|if
condition|(
name|chip
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
name|MSG_CTRLCHIPNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|convert_arguint
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
operator|&
name|page
argument_list|)
operator|||
name|convert_arguint
argument_list|(
name|gargv
index|[
literal|4
index|]
argument_list|,
operator|&
name|column
argument_list|)
operator|||
name|convert_arguint
argument_list|(
name|gargv
index|[
literal|5
index|]
argument_list|,
operator|&
name|len
argument_list|)
operator|||
name|convert_arguint
argument_list|(
name|gargv
index|[
literal|6
index|]
argument_list|,
operator|&
name|pattern
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
operator|!
name|assert_chip_connected
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
name|sim_err
operator|.
name|page_num
operator|=
name|page
expr_stmt|;
name|sim_err
operator|.
name|column
operator|=
name|column
expr_stmt|;
name|sim_err
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|sim_err
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|sim_err
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|sim_err
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_INJECT_ERROR
argument_list|,
operator|&
name|sim_err
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not inject error !"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdbb
parameter_list|(
name|int
name|gargc
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|struct
name|sim_block_state
name|bs
decl_stmt|;
name|struct
name|chip_param_io
name|cparams
decl_stmt|;
name|uint32_t
name|blkidx
decl_stmt|;
name|int
name|c
decl_stmt|,
name|cdevd
decl_stmt|,
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|idx
decl_stmt|;
name|uint8_t
name|flagL
init|=
literal|0
decl_stmt|,
name|flagU
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|badblocks
init|=
name|NULL
decl_stmt|;
comment|/* Check for --list/-L or --unmark/-U flags */
for|for
control|(
name|idx
operator|=
literal|3
init|;
name|idx
operator|<
name|gargc
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|idx
index|]
argument_list|,
literal|"--list"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|idx
index|]
argument_list|,
literal|"-L"
argument_list|)
operator|==
literal|0
condition|)
name|flagL
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|gargv
index|[
name|idx
index|]
argument_list|,
literal|"--unmark"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|gargv
index|[
name|idx
index|]
argument_list|,
literal|"-U"
argument_list|)
operator|==
literal|0
condition|)
name|flagU
operator|=
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|flagL
operator|==
literal|2
operator|||
name|flagU
operator|==
literal|2
operator|||
name|flagU
operator|==
literal|3
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|chip
operator|==
literal|0xff
operator|||
name|ctl
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
name|MSG_CTRLCHIPNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
name|bs
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|bs
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
if|if
condition|(
operator|!
name|assert_chip_connected
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|opencdev
argument_list|(
operator|&
name|cdevd
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|cdevd
argument_list|,
name|NAND_IO_GET_CHIP_PARAM
argument_list|,
operator|&
name|cparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
name|close
argument_list|(
name|cdevd
argument_list|)
expr_stmt|;
name|bs
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|bs
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
if|if
condition|(
name|flagL
operator|!=
literal|3
condition|)
block|{
comment|/* 		 * Flag -L was specified either after blocklist or was not 		 * specified at all. 		 */
name|c
operator|=
name|parse_intarray
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
operator|&
name|badblocks
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|c
condition|;
name|idx
operator|++
control|)
block|{
name|bs
operator|.
name|block_num
operator|=
name|badblocks
index|[
name|idx
index|]
expr_stmt|;
comment|/* Do not change wearout */
name|bs
operator|.
name|wearout
operator|=
operator|-
literal|1
expr_stmt|;
name|bs
operator|.
name|state
operator|=
operator|(
name|flagU
operator|==
literal|0
operator|)
condition|?
name|NANDSIM_BAD_BLOCK
else|:
name|NANDSIM_GOOD_BLOCK
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_SET_BLOCK_STATE
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not set bad block(%d) for "
literal|"controller (%d)!"
argument_list|,
name|badblocks
index|[
name|idx
index|]
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|flagL
operator|!=
literal|0
condition|)
block|{
comment|/* If flag -L was specified (anywhere) */
for|for
control|(
name|blkidx
operator|=
literal|0
init|;
name|blkidx
operator|<
name|cparams
operator|.
name|blocks
condition|;
name|blkidx
operator|++
control|)
block|{
name|bs
operator|.
name|block_num
operator|=
name|blkidx
expr_stmt|;
comment|/* Do not change the wearout */
name|bs
operator|.
name|wearout
operator|=
operator|-
literal|1
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_GET_BLOCK_STATE
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire block state"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"Block#%d: wear count: %d %s\n"
argument_list|,
name|blkidx
argument_list|,
name|bs
operator|.
name|wearout
argument_list|,
operator|(
name|bs
operator|.
name|state
operator|==
name|NANDSIM_BAD_BLOCK
operator|)
condition|?
literal|"BAD"
else|:
literal|"GOOD"
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdfreeze
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|,
name|state
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
name|struct
name|sim_ctrl_chip
name|ctrlchip
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
if|if
condition|(
name|ctl
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
literal|"You have to specify at least controller number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|ctl
operator|!=
literal|0xff
operator|&&
name|chip
operator|==
literal|0xff
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|stop
operator|=
name|MAX_CTRL_CS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|chip
expr_stmt|;
name|stop
operator|=
name|chip
expr_stmt|;
block|}
name|ctrlchip
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|err
operator|=
name|is_ctrl_running
argument_list|(
name|ctl
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_NOTRUNNING
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|stop
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|is_chip_created
argument_list|(
name|ctl
argument_list|,
name|i
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
elseif|else
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|ctrlchip
operator|.
name|chip_num
operator|=
name|i
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_FREEZE
argument_list|,
operator|&
name|ctrlchip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not freeze ctrl#%d chip#%d"
argument_list|,
name|ctl
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdlog
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|struct
name|sim_log
name|log
decl_stmt|;
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|idx
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|logbuf
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
name|logbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|NANDSIM_RAM_LOG_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|logbuf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Not enough memory to create log buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|memset
argument_list|(
name|logbuf
argument_list|,
literal|0
argument_list|,
name|NANDSIM_RAM_LOG_SIZE
argument_list|)
expr_stmt|;
name|log
operator|.
name|log
operator|=
name|logbuf
expr_stmt|;
name|log
operator|.
name|len
operator|=
name|NANDSIM_RAM_LOG_SIZE
expr_stmt|;
if|if
condition|(
name|ctl
operator|==
literal|0xff
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|stop
operator|=
name|MAX_SIM_DEV
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|ctl
expr_stmt|;
name|stop
operator|=
name|ctl
expr_stmt|;
block|}
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
block|{
name|free
argument_list|(
name|logbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
block|}
comment|/* Print logs for selected controller(s) */
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<=
name|stop
condition|;
name|idx
operator|++
control|)
block|{
name|log
operator|.
name|ctrl_num
operator|=
name|idx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_PRINT_LOG
argument_list|,
operator|&
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not get log for controller %d!"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"Logs for controller#%d:\n%s\n"
argument_list|,
name|idx
argument_list|,
name|logbuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|logbuf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdstats
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|cdevd
decl_stmt|,
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pageno
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
if|if
condition|(
name|chip
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
name|MSG_CTRLCHIPNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
name|convert_arguint
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
operator|&
name|pageno
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
if|if
condition|(
operator|!
name|assert_chip_connected
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|opencdev
argument_list|(
operator|&
name|cdevd
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|printstats
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|,
name|pageno
argument_list|,
name|cdevd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|close
argument_list|(
name|cdevd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|close
argument_list|(
name|cdevd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmddump
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|struct
name|sim_dump
name|dump
decl_stmt|;
name|struct
name|sim_block_state
name|bs
decl_stmt|;
name|struct
name|chip_param_io
name|cparams
decl_stmt|;
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
name|EX_OK
decl_stmt|,
name|fd
decl_stmt|,
name|dumpfd
decl_stmt|;
name|uint32_t
name|blkidx
decl_stmt|,
name|bwritten
init|=
literal|0
decl_stmt|,
name|totalwritten
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
if|if
condition|(
name|chip
operator|==
literal|0xff
operator|||
name|ctl
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
name|MSG_CTRLCHIPNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|assert_chip_connected
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
if|if
condition|(
name|opencdev
argument_list|(
operator|&
name|fd
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NAND_IO_GET_CHIP_PARAM
argument_list|,
operator|&
name|cparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Cannot get parameters for chip %d:%d"
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|dump
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|dump
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
name|dump
operator|.
name|len
operator|=
name|cparams
operator|.
name|pages_per_block
operator|*
operator|(
name|cparams
operator|.
name|page_size
operator|+
name|cparams
operator|.
name|oob_size
operator|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|dump
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Could not allocate memory!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|dump
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|dumpfd
operator|=
name|open
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpfd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Cannot create dump file."
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|bs
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|bs
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
comment|/* First uint32_t in file shall contain block count */
if|if
condition|(
name|write
argument_list|(
name|dumpfd
argument_list|,
operator|&
name|cparams
argument_list|,
sizeof|sizeof
argument_list|(
name|cparams
argument_list|)
argument_list|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cparams
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Error writing to dumpfile!"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
comment|/* 	 * First loop acquires blocks states and writes them to 	 * the dump file. 	 */
for|for
control|(
name|blkidx
operator|=
literal|0
init|;
name|blkidx
operator|<
name|cparams
operator|.
name|blocks
condition|;
name|blkidx
operator|++
control|)
block|{
name|bs
operator|.
name|block_num
operator|=
name|blkidx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_GET_BLOCK_STATE
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not get bad block(%d) for "
literal|"controller (%d)!"
argument_list|,
name|blkidx
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|bwritten
operator|=
name|write
argument_list|(
name|dumpfd
argument_list|,
operator|&
name|bs
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bwritten
operator|!=
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Error writing to dumpfile"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
block|}
comment|/* Second loop dumps the data */
for|for
control|(
name|blkidx
operator|=
literal|0
init|;
name|blkidx
operator|<
name|cparams
operator|.
name|blocks
condition|;
name|blkidx
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"Block#%d..."
argument_list|,
name|blkidx
argument_list|)
expr_stmt|;
name|dump
operator|.
name|block_num
operator|=
name|blkidx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_DUMP
argument_list|,
operator|&
name|dump
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not dump ctrl#%d chip#%d "
literal|"block#%d"
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|,
name|blkidx
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
break|break;
block|}
name|bwritten
operator|=
name|write
argument_list|(
name|dumpfd
argument_list|,
name|dump
operator|.
name|data
argument_list|,
name|dump
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|bwritten
operator|!=
name|dump
operator|.
name|len
condition|)
block|{
name|error
argument_list|(
literal|"Error writing to dumpfile"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
break|break;
block|}
name|debug
argument_list|(
literal|"OK!\n"
argument_list|)
expr_stmt|;
name|totalwritten
operator|+=
name|bwritten
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d out of %d B written.\n"
argument_list|,
name|totalwritten
argument_list|,
name|dump
operator|.
name|len
operator|*
name|blkidx
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdrestore
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|struct
name|sim_dump
name|dump
decl_stmt|;
name|struct
name|sim_block_state
name|bs
decl_stmt|;
name|struct
name|stat
name|filestat
decl_stmt|;
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|dumpfd
init|=
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|blkidx
decl_stmt|,
name|blksz
decl_stmt|,
name|fsize
init|=
literal|0
decl_stmt|,
name|expfilesz
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|struct
name|chip_param_io
name|cparams
decl_stmt|,
name|dumpcparams
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
elseif|else
if|if
condition|(
name|ctl
operator|==
literal|0xff
condition|)
block|{
name|error
argument_list|(
name|MSG_CTRLCHIPNEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|assert_chip_connected
argument_list|(
name|ctl
argument_list|,
name|chip
argument_list|)
condition|)
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
comment|/* Get chip geometry */
if|if
condition|(
name|opencdev
argument_list|(
operator|&
name|fd
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NAND_IO_GET_CHIP_PARAM
argument_list|,
operator|&
name|cparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Cannot get parameters for chip %d:%d"
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Obtain dump file size */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
operator|&
name|filestat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire file size! : %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_IOERR
operator|)
return|;
block|}
name|fsize
operator|=
name|filestat
operator|.
name|st_size
expr_stmt|;
name|blksz
operator|=
name|cparams
operator|.
name|pages_per_block
operator|*
operator|(
name|cparams
operator|.
name|page_size
operator|+
name|cparams
operator|.
name|oob_size
operator|)
expr_stmt|;
comment|/* Expected dump file size for chip */
name|expfilesz
operator|=
name|cparams
operator|.
name|blocks
operator|*
operator|(
name|blksz
operator|+
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|cparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsize
operator|!=
name|expfilesz
condition|)
block|{
name|error
argument_list|(
literal|"File size does not match chip geometry (file size: %d"
literal|", dump size: %d)"
argument_list|,
name|fsize
argument_list|,
name|expfilesz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|dumpfd
operator|=
name|open
argument_list|(
name|gargv
index|[
literal|3
index|]
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpfd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not open dump file!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_IOERR
operator|)
return|;
block|}
comment|/* Read chip params saved in dumpfile */
name|read
argument_list|(
name|dumpfd
argument_list|,
operator|&
name|dumpcparams
argument_list|,
sizeof|sizeof
argument_list|(
name|dumpcparams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|dumpcparams
argument_list|,
operator|&
name|cparams
argument_list|,
sizeof|sizeof
argument_list|(
name|cparams
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Supplied dump is created for a chip with different "
literal|"chip configuration!"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
block|{
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Could not allocate memory for block buffer"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|dump
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|dump
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
name|dump
operator|.
name|data
operator|=
name|buf
expr_stmt|;
comment|/* Restore block states and wearouts */
for|for
control|(
name|blkidx
operator|=
literal|0
init|;
name|blkidx
operator|<
name|cparams
operator|.
name|blocks
condition|;
name|blkidx
operator|++
control|)
block|{
name|dump
operator|.
name|block_num
operator|=
name|blkidx
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|dumpfd
argument_list|,
operator|&
name|bs
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Error reading dumpfile"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|bs
operator|.
name|ctrl_num
operator|=
name|ctl
expr_stmt|;
name|bs
operator|.
name|chip_num
operator|=
name|chip
expr_stmt|;
name|debug
argument_list|(
literal|"BLKIDX=%d BLOCKS=%d CTRL=%d CHIP=%d STATE=%d\n"
literal|"WEAROUT=%d BS.CTRL_NUM=%d BS.CHIP_NUM=%d\n"
argument_list|,
name|blkidx
argument_list|,
name|cparams
operator|.
name|blocks
argument_list|,
name|dump
operator|.
name|ctrl_num
argument_list|,
name|dump
operator|.
name|chip_num
argument_list|,
name|bs
operator|.
name|state
argument_list|,
name|bs
operator|.
name|wearout
argument_list|,
name|bs
operator|.
name|ctrl_num
argument_list|,
name|bs
operator|.
name|chip_num
argument_list|)
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_SET_BLOCK_STATE
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not set bad block(%d) for "
literal|"controller: %d, chip: %d!"
argument_list|,
name|blkidx
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
block|}
comment|/* Restore data */
for|for
control|(
name|blkidx
operator|=
literal|0
init|;
name|blkidx
operator|<
name|cparams
operator|.
name|blocks
condition|;
name|blkidx
operator|++
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|dump
operator|.
name|len
operator|=
name|read
argument_list|(
name|dumpfd
argument_list|,
name|buf
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|error
argument_list|(
literal|"Failed to read block#%d from dumpfile."
argument_list|,
name|blkidx
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
break|break;
block|}
name|dump
operator|.
name|block_num
operator|=
name|blkidx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_RESTORE
argument_list|,
operator|&
name|dump
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not restore block#%d of ctrl#%d chip#%d"
literal|": %s"
argument_list|,
name|blkidx
argument_list|,
name|ctl
argument_list|,
name|chip
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EX_SOFTWARE
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dumpfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmddestroy
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
parameter_list|)
block|{
name|int
name|chip
init|=
literal|0
decl_stmt|,
name|ctl
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|,
name|idx
decl_stmt|,
name|idx2
decl_stmt|,
name|state
decl_stmt|;
name|int
name|chipstart
decl_stmt|,
name|chipstop
decl_stmt|,
name|ctrlstart
decl_stmt|,
name|ctrlstop
decl_stmt|;
name|struct
name|sim_chip_destroy
name|chip_destroy
decl_stmt|;
name|err
operator|=
name|parse_devstring
argument_list|(
name|gargv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EX_USAGE
operator|)
return|;
if|if
condition|(
name|ctl
operator|==
literal|0xff
condition|)
block|{
comment|/* Every chip at every controller */
name|ctrlstart
operator|=
name|chipstart
operator|=
literal|0
expr_stmt|;
name|ctrlstop
operator|=
name|MAX_SIM_DEV
operator|-
literal|1
expr_stmt|;
name|chipstop
operator|=
name|MAX_CTRL_CS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ctrlstart
operator|=
name|ctrlstop
operator|=
name|ctl
expr_stmt|;
if|if
condition|(
name|chip
operator|==
literal|0xff
condition|)
block|{
comment|/* Every chip at selected controller */
name|chipstart
operator|=
literal|0
expr_stmt|;
name|chipstop
operator|=
name|MAX_CTRL_CS
operator|-
literal|1
expr_stmt|;
block|}
else|else
comment|/* Selected chip at selected controller */
name|chipstart
operator|=
name|chipstop
operator|=
name|chip
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"CTRLSTART=%d CTRLSTOP=%d CHIPSTART=%d CHIPSTOP=%d\n"
argument_list|,
name|ctrlstart
argument_list|,
name|ctrlstop
argument_list|,
name|chipstart
argument_list|,
name|chipstop
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|ctrlstart
init|;
name|idx
operator|<=
name|ctrlstop
condition|;
name|idx
operator|++
control|)
block|{
name|err
operator|=
name|is_ctrl_created
argument_list|(
name|idx
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire ctrl#%d state. Cannot "
literal|"destroy controller."
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|err
operator|=
name|is_ctrl_running
argument_list|(
name|idx
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
name|MSG_STATUSACQCTRL
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|MSG_RUNNING
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
for|for
control|(
name|idx2
operator|=
name|chipstart
init|;
name|idx2
operator|<=
name|chipstop
condition|;
name|idx2
operator|++
control|)
block|{
name|err
operator|=
name|is_chip_created
argument_list|(
name|idx
argument_list|,
name|idx2
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
name|MSG_STATUSACQCTRLCHIP
argument_list|,
name|idx2
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|==
literal|0
condition|)
comment|/* There is no such chip running */
continue|continue;
name|chip_destroy
operator|.
name|ctrl_num
operator|=
name|idx
expr_stmt|;
name|chip_destroy
operator|.
name|chip_num
operator|=
name|idx2
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_DESTROY_CHIP
argument_list|,
operator|&
name|chip_destroy
argument_list|)
expr_stmt|;
block|}
comment|/* If chip isn't explicitly specified -- destroy ctrl */
if|if
condition|(
name|chip
operator|==
literal|0xff
condition|)
block|{
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_DESTROY_CTRL
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not destroy ctrl#%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|nandsim_command
modifier|*
name|cmdopts
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|cmdhelp
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|EX_USAGE
expr_stmt|;
block|}
else|else
block|{
name|cmdopts
operator|=
name|getcommand
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdopts
operator|!=
name|NULL
operator|&&
name|cmdopts
operator|->
name|commandfunc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|checkusage
argument_list|(
name|argc
argument_list|,
name|cmdopts
operator|->
name|req_argc
argument_list|,
name|argv
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Print command specific usage */
name|printf
argument_list|(
literal|"nandsim %s"
argument_list|,
name|cmdopts
operator|->
name|usagestring
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
name|retcode
operator|=
name|cmdopts
operator|->
name|commandfunc
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|EX_USAGE
condition|)
block|{
comment|/* Print command-specific usage */
name|printf
argument_list|(
literal|"nandsim %s"
argument_list|,
name|cmdopts
operator|->
name|usagestring
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
name|EX_OSFILE
condition|)
block|{
name|error
argument_list|(
literal|"Could not open device file"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"Unknown command!"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|EX_USAGE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmdhelp
parameter_list|(
name|int
name|gargc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|gargv
name|__unused
parameter_list|)
block|{
name|struct
name|nandsim_command
modifier|*
name|opts
decl_stmt|;
name|printf
argument_list|(
literal|"usage:  nandsim<command> [command params] [params]\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|opts
operator|=
name|commands
init|;
operator|(
name|opts
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|opts
operator|->
name|cmd_name
operator|!=
name|NULL
operator|)
condition|;
name|opts
operator|++
control|)
name|printf
argument_list|(
literal|"nandsim %s"
argument_list|,
name|opts
operator|->
name|usagestring
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|printchip
parameter_list|(
name|struct
name|sim_chip
modifier|*
name|chip
parameter_list|,
name|uint8_t
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|chip
operator|->
name|created
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n[Chip info]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num= %d\nctrl_num=%d\ndevice_id=%02x"
literal|"\tmanufacturer_id=%02x\ndevice_model=%s\nmanufacturer="
literal|"%s\ncol_addr_cycles=%d\nrow_addr_cycles=%d"
literal|"\npage_size=%d\noob_size=%d\npages_per_block=%d\n"
literal|"blocks_per_lun=%d\nluns=%d\n\nprog_time=%d\n"
literal|"erase_time=%d\nread_time=%d\n"
literal|"error_ratio=%d\nwear_level=%d\nwrite_protect=%c\n"
literal|"chip_width=%db\n"
argument_list|,
name|chip
operator|->
name|num
argument_list|,
name|chip
operator|->
name|ctrl_num
argument_list|,
name|chip
operator|->
name|device_id
argument_list|,
name|chip
operator|->
name|manufact_id
argument_list|,
name|chip
operator|->
name|device_model
argument_list|,
name|chip
operator|->
name|manufacturer
argument_list|,
name|chip
operator|->
name|col_addr_cycles
argument_list|,
name|chip
operator|->
name|row_addr_cycles
argument_list|,
name|chip
operator|->
name|page_size
argument_list|,
name|chip
operator|->
name|oob_size
argument_list|,
name|chip
operator|->
name|pgs_per_blk
argument_list|,
name|chip
operator|->
name|blks_per_lun
argument_list|,
name|chip
operator|->
name|luns
argument_list|,
name|chip
operator|->
name|prog_time
argument_list|,
name|chip
operator|->
name|erase_time
argument_list|,
name|chip
operator|->
name|read_time
argument_list|,
name|chip
operator|->
name|error_ratio
argument_list|,
name|chip
operator|->
name|wear_level
argument_list|,
operator|(
name|chip
operator|->
name|is_wp
operator|==
literal|0
operator|)
condition|?
literal|'N'
else|:
literal|'Y'
argument_list|,
name|chip
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[Chip info]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnum=%d\n\tdevice_model=%s\n\tmanufacturer=%s\n"
literal|"\tpage_size=%d\n\twrite_protect=%s\n"
argument_list|,
name|chip
operator|->
name|num
argument_list|,
name|chip
operator|->
name|device_model
argument_list|,
name|chip
operator|->
name|manufacturer
argument_list|,
name|chip
operator|->
name|page_size
argument_list|,
operator|(
name|chip
operator|->
name|is_wp
operator|==
literal|0
operator|)
condition|?
literal|"NO"
else|:
literal|"YES"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printctrl
parameter_list|(
name|struct
name|sim_ctrl
modifier|*
name|ctrl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|created
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|MSG_NOCTRL
literal|"\n"
argument_list|,
name|ctrl
operator|->
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n[Controller info]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trunning: %s\n"
argument_list|,
name|ctrl
operator|->
name|running
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnum cs: %d\n"
argument_list|,
name|ctrl
operator|->
name|num_cs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tecc: %d\n"
argument_list|,
name|ctrl
operator|->
name|ecc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlog_filename: %s\n"
argument_list|,
name|ctrl
operator|->
name|filename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tecc_layout:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ECC_BYTES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctrl
operator|->
name|ecc_layout
index|[
name|i
index|]
operator|==
literal|0xffff
condition|)
break|break;
else|else
name|printf
argument_list|(
literal|"%c%d"
argument_list|,
name|i
operator|%
literal|16
condition|?
literal|' '
else|:
literal|'\n'
argument_list|,
name|ctrl
operator|->
name|ecc_layout
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_ctrl_running
parameter_list|(
name|int
name|ctrl_no
parameter_list|,
name|int
modifier|*
name|running
parameter_list|)
block|{
name|struct
name|sim_ctrl
name|ctrl
decl_stmt|;
name|int
name|err
decl_stmt|,
name|fd
decl_stmt|;
name|ctrl
operator|.
name|num
operator|=
name|ctrl_no
expr_stmt|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_STATUS_CTRL
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
name|MSG_STATUSACQCTRL
argument_list|,
name|ctrl_no
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|running
operator|=
name|ctrl
operator|.
name|running
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_ctrl_created
parameter_list|(
name|int
name|ctrl_no
parameter_list|,
name|int
modifier|*
name|created
parameter_list|)
block|{
name|struct
name|sim_ctrl
name|ctrl
decl_stmt|;
name|int
name|err
decl_stmt|,
name|fd
decl_stmt|;
name|ctrl
operator|.
name|num
operator|=
name|ctrl_no
expr_stmt|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_STATUS_CTRL
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire conf for ctrl#%d"
argument_list|,
name|ctrl_no
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|created
operator|=
name|ctrl
operator|.
name|created
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_chip_created
parameter_list|(
name|int
name|ctrl_no
parameter_list|,
name|int
name|chip_no
parameter_list|,
name|int
modifier|*
name|created
parameter_list|)
block|{
name|struct
name|sim_chip
name|chip
decl_stmt|;
name|int
name|err
decl_stmt|,
name|fd
decl_stmt|;
name|chip
operator|.
name|ctrl_num
operator|=
name|ctrl_no
expr_stmt|;
name|chip
operator|.
name|num
operator|=
name|chip_no
expr_stmt|;
if|if
condition|(
name|opendev
argument_list|(
operator|&
name|fd
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
operator|(
name|EX_OSFILE
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NANDSIM_STATUS_CHIP
argument_list|,
operator|&
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire conf for chip#%d"
argument_list|,
name|chip_no
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|created
operator|=
name|chip
operator|.
name|created
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|assert_chip_connected
parameter_list|(
name|int
name|ctrl_no
parameter_list|,
name|int
name|chip_no
parameter_list|)
block|{
name|int
name|created
decl_stmt|,
name|running
decl_stmt|;
if|if
condition|(
name|is_ctrl_created
argument_list|(
name|ctrl_no
argument_list|,
operator|&
name|created
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|created
condition|)
block|{
name|error
argument_list|(
name|MSG_NOCTRL
argument_list|,
name|ctrl_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|is_chip_created
argument_list|(
name|ctrl_no
argument_list|,
name|chip_no
argument_list|,
operator|&
name|created
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|created
condition|)
block|{
name|error
argument_list|(
name|MSG_NOTCONFIGDCTRLCHIP
argument_list|,
name|ctrl_no
argument_list|,
name|chip_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|is_ctrl_running
argument_list|(
name|ctrl_no
argument_list|,
operator|&
name|running
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|running
condition|)
block|{
name|error
argument_list|(
name|MSG_NOTRUNNING
argument_list|,
name|ctrl_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|printstats
parameter_list|(
name|int
name|ctrlno
parameter_list|,
name|int
name|chipno
parameter_list|,
name|uint32_t
name|pageno
parameter_list|,
name|int
name|cdevd
parameter_list|)
block|{
name|struct
name|page_stat_io
name|pstats
decl_stmt|;
name|struct
name|block_stat_io
name|bstats
decl_stmt|;
name|struct
name|chip_param_io
name|cparams
decl_stmt|;
name|uint32_t
name|blkidx
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Gather information about chip */
name|err
operator|=
name|ioctl
argument_list|(
name|cdevd
argument_list|,
name|NAND_IO_GET_CHIP_PARAM
argument_list|,
operator|&
name|cparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire chip info for chip attached to cs#"
literal|"%d, ctrl#%d"
argument_list|,
name|chipno
argument_list|,
name|ctrlno
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|blkidx
operator|=
operator|(
name|pageno
operator|/
name|cparams
operator|.
name|pages_per_block
operator|)
expr_stmt|;
name|bstats
operator|.
name|block_num
operator|=
name|blkidx
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|cdevd
argument_list|,
name|NAND_IO_BLOCK_STAT
argument_list|,
operator|&
name|bstats
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire block#%d statistics!"
argument_list|,
name|blkidx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Block #%d erased: %d\n"
argument_list|,
name|blkidx
argument_list|,
name|bstats
operator|.
name|block_erased
argument_list|)
expr_stmt|;
name|pstats
operator|.
name|page_num
operator|=
name|pageno
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|cdevd
argument_list|,
name|NAND_IO_PAGE_STAT
argument_list|,
operator|&
name|pstats
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Could not acquire page statistics!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|debug
argument_list|(
literal|"BLOCKIDX = %d PAGENO (REL. TO BLK) = %d\n"
argument_list|,
name|blkidx
argument_list|,
name|pstats
operator|.
name|page_num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Page#%d : reads:%d writes:%d \n\traw reads:%d raw writes:%d "
literal|"\n\tecc_succeeded:%d ecc_corrected:%d ecc_failed:%d\n"
argument_list|,
name|pstats
operator|.
name|page_num
argument_list|,
name|pstats
operator|.
name|page_read
argument_list|,
name|pstats
operator|.
name|page_written
argument_list|,
name|pstats
operator|.
name|page_raw_read
argument_list|,
name|pstats
operator|.
name|page_raw_written
argument_list|,
name|pstats
operator|.
name|ecc_succeded
argument_list|,
name|pstats
operator|.
name|ecc_corrected
argument_list|,
name|pstats
operator|.
name|ecc_failed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

