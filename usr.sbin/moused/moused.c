begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  ** Copyright (c) 1995 Michael Smith, All rights reserved.  **  ** Redistribution and use in source and binary forms, with or without  ** modification, are permitted provided that the following conditions  ** are met:  ** 1. Redistributions of source code must retain the above copyright  **    notice, this list of conditions and the following disclaimer as  **    the first lines of this file unmodified.  ** 2. Redistributions in binary form must reproduce the above copyright  **    notice, this list of conditions and the following disclaimer in the  **    documentation and/or other materials provided with the distribution.  ** 3. All advertising materials mentioning features or use of this software  **    must display the following acknowledgment:  **      This product includes software developed by Michael Smith.  ** 4. The name of the author may not be used to endorse or promote products  **    derived from this software without specific prior written permission.  **  **  ** THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ANY  ** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  ** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Michael Smith BE LIABLE FOR  ** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  ** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  ** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  ** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  ** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  ** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  ** EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  **  **/
end_comment

begin_comment
comment|/**  ** MOUSED.C  **  ** Mouse daemon : listens to serial port for mouse data stream,  ** interprets same and passes ioctls off to the console driver.  **  ** The mouse interface functions are derived closely from the mouse  ** handler in the XFree86 X server.  Many thanks to the XFree86 people  ** for their great work!  **   **/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|if (debug&&nodaemon) warnx(fmt, ##args)
end_define

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodaemon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|R_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|R_MICROSOFT
value|1
end_define

begin_define
define|#
directive|define
name|R_MOUSESYS
value|2
end_define

begin_define
define|#
directive|define
name|R_MMSERIES
value|3
end_define

begin_define
define|#
directive|define
name|R_LOGITECH
value|4
end_define

begin_define
define|#
directive|define
name|R_BUSMOUSE
value|5
end_define

begin_define
define|#
directive|define
name|R_LOGIMAN
value|6
end_define

begin_define
define|#
directive|define
name|R_PS_2
value|7
end_define

begin_define
define|#
directive|define
name|R_MMHITAB
value|8
end_define

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
literal|"xxx"
block|,
literal|"microsoft"
block|,
literal|"mousesystems"
block|,
literal|"mmseries"
block|,
literal|"logitech"
block|,
literal|"busmouse"
block|,
literal|"mouseman"
block|,
literal|"ps/2"
block|,
literal|"mmhitab"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|rodentcflags
index|[]
init|=
block|{
literal|0
block|,
comment|/* nomouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MicroSoft */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseSystems */
operator|(
name|CS8
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MMSeries */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Logitech */
literal|0
block|,
comment|/* BusMouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseMan */
literal|0
block|,
comment|/* PS/2 */
operator|(
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MMHitTablet */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|buttons
decl_stmt|;
block|}
name|ACTIVITY
typedef|;
end_typedef

begin_struct
struct|struct
name|rodentparam
block|{
name|int
name|baudrate
decl_stmt|,
name|samplerate
decl_stmt|,
name|flags
decl_stmt|,
name|rtype
decl_stmt|,
name|lastbuttons
decl_stmt|,
name|buttons
decl_stmt|,
name|mfd
decl_stmt|,
name|cleardtr
decl_stmt|,
name|clearrts
decl_stmt|;
name|char
modifier|*
name|portname
decl_stmt|;
block|}
name|rodent
init|=
block|{
name|baudrate
operator|:
literal|1200
block|,
name|samplerate
operator|:
literal|0
block|,
name|flags
operator|:
literal|0
block|,
name|rtype
operator|:
name|R_UNKNOWN
block|,
name|lastbuttons
operator|:
literal|0
block|,
name|buttons
operator|:
literal|0
block|,
name|mfd
operator|:
operator|-
literal|1
block|,
name|portname
operator|:
name|NULL
block|,
name|cleardtr
operator|:
literal|0
block|,
name|clearrts
operator|:
literal|0
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ChordMiddle
value|1
end_define

begin_function_decl
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ACTIVITY
modifier|*
name|r_protocol
parameter_list|(
name|u_char
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setmousespeed
parameter_list|(
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|,
name|unsigned
name|cflag
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|cfd
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|ACTIVITY
modifier|*
name|act
decl_stmt|;
name|struct
name|mouse_info
name|mouse
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cdfsp:t:h?RDS:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ChordMiddle
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|nodaemon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|rodent
operator|.
name|portname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|rodent
operator|.
name|baudrate
operator|=
literal|9600
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|rodent
operator|.
name|clearrts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|rodent
operator|.
name|cleardtr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|rodent
operator|.
name|baudrate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"rodent baudrate %d"
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|rnames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"rodent is %s"
argument_list|,
name|rnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|rtype
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rnames
index|[
name|i
index|]
condition|)
break|break;
name|warnx
argument_list|(
literal|"no such mouse type `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|R_BUSMOUSE
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/mse0"
expr_stmt|;
break|break;
case|case
name|R_PS_2
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/psm0"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|rodent
operator|.
name|portname
condition|)
break|break;
name|warnx
argument_list|(
literal|"no port name specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rodent
operator|.
name|mfd
operator|=
name|open
argument_list|(
name|rodent
operator|.
name|portname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"can't open %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|r_init
argument_list|()
expr_stmt|;
comment|/* call init function */
if|if
condition|(
operator|(
name|cfd
operator|=
name|open
argument_list|(
literal|"/dev/consolectl"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"open(/dev/consolectl)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodaemon
condition|)
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"daemon() failed"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get a byte */
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
comment|/* read returned or error; goodbye */
block|{
name|debug
argument_list|(
literal|"read returned %d : %s exiting"
argument_list|,
name|i
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|act
operator|=
name|r_protocol
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* pass byte to handler */
if|if
condition|(
name|act
condition|)
comment|/* handler detected action */
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_ACTION
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|act
operator|->
name|dx
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|act
operator|->
name|dy
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|act
operator|->
name|buttons
expr_stmt|;
name|ioctl
argument_list|(
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"activity : buttons 0x%02x  dx %d  dy %d"
argument_list|,
name|act
operator|->
name|buttons
argument_list|,
name|act
operator|->
name|dx
argument_list|,
name|act
operator|->
name|dy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  ** usage  **  ** Complain, and free the CPU for more worthy tasks  **/
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: moused [-DRcdfs] [-r samplerate] [-S baudrate]"
argument_list|,
literal|"              -p<port> -t<mousetype>"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** Mouse interface code, courtesy of XFree86 3.1.2.  **  ** Note: Various bits have been trimmed, and in my shortsighted enthusiasm  ** to clean, reformat and rationalise naming, it's quite possible that  ** some things in here have been broken.  **  ** I hope not 8)  **  ** The following code is derived from a module marked :  **/
end_comment

begin_comment
comment|/* $XConsortium: xf86_Mouse.c,v 1.2 94/10/12 20:33:21 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.2 1995/01/28  17:03:40 dawes Exp $ */
end_comment

begin_comment
comment|/*  *  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of Thomas Roell and David Dawes not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  Thomas Roell  * and David Dawes makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * THOMAS ROELL AND DAVID DAWES DISCLAIM ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS, IN NO EVENT SHALL THOMAS ROELL OR DAVID DAWES BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_function
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/**      ** This comment is a little out of context here, but it contains       ** some useful information...      ********************************************************************      **      ** The following lines take care of the Logitech MouseMan protocols.      **      ** NOTE: There are different versions of both MouseMan and TrackMan!      **       Hence I add another protocol P_LOGIMAN, which the user can      **       specify as MouseMan in his XF86Config file. This entry was      **       formerly handled as a special case of P_MS. However, people      **       who don't have the middle button problem, can still specify      **       Microsoft and use P_MS.      **      ** By default, these mice should use a 3 byte Microsoft protocol      ** plus a 4th byte for the middle button. However, the mouse might      ** have switched to a different protocol before we use it, so I send      ** the proper sequence just in case.      **      ** NOTE: - all commands to (at least the European) MouseMan have to      **         be sent at 1200 Baud.      **       - each command starts with a '*'.      **       - whenever the MouseMan receives a '*', it will switch back      **	 to 1200 Baud. Hence I have to select the desired protocol      **	 first, then select the baud rate.      **      ** The protocols supported by the (European) MouseMan are:      **   -  5 byte packed binary protocol, as with the Mouse Systems      **      mouse. Selected by sequence "*U".      **   -  2 button 3 byte MicroSoft compatible protocol. Selected      **      by sequence "*V".      **   -  3 button 3+1 byte MicroSoft compatible protocol (default).      **      Selected by sequence "*X".      **      ** The following baud rates are supported:      **   -  1200 Baud (default). Selected by sequence "*n".      **   -  9600 Baud. Selected by sequence "*q".      **      ** Selecting a sample rate is no longer supported with the MouseMan!      ** Some additional lines in xf86Config.c take care of ill configured      ** baud rates and sample rates. (The user will get an error.)      */
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGIMAN
condition|)
block|{
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
literal|1200
argument_list|,
name|rodentcflags
index|[
name|R_LOGIMAN
index|]
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"*X"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|R_LOGIMAN
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rodent
operator|.
name|rtype
operator|!=
name|R_BUSMOUSE
operator|)
operator|&&
operator|(
name|rodent
operator|.
name|rtype
operator|!=
name|R_PS_2
operator|)
condition|)
block|{
comment|/* try all likely settings */
name|setmousespeed
argument_list|(
literal|9600
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|4800
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|2400
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGITECH
condition|)
block|{
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|R_MMSERIES
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_MMHITAB
condition|)
block|{
name|char
name|speedcmd
decl_stmt|;
comment|/* 	     * Initialize Hitachi PUMA Plus - Model 1212E to desired settings. 	     * The tablet must be configured to be in MM mode, NO parity, 	     * Binary Format.  xf86Info.sampleRate controls the sensativity 	     * of the tablet.  We only use this tablet for it's 4-button puck 	     * so we don't run in "Absolute Mode" 	     */
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"z8"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Parity = "NONE" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"zb"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Format = "Binary" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Report Mode = "Stream" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Output Rate = "45 rps" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"I\x20"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Incrememtal Mode "20" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"E"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Data Type = "Relative */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* These sample rates translate to 'lines per inch' on the 		   Hitachi tablet */
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|40
condition|)
name|speedcmd
operator|=
literal|'g'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|100
condition|)
name|speedcmd
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|200
condition|)
name|speedcmd
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|500
condition|)
name|speedcmd
operator|=
literal|'h'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|1000
condition|)
name|speedcmd
operator|=
literal|'j'
expr_stmt|;
else|else
name|speedcmd
operator|=
literal|'d'
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|speedcmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"\021"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Resume DATA output */
block|}
else|else
block|{
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|0
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"O"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|15
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"J"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|27
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"K"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|42
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"L"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|60
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|85
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"M"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|125
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"Q"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_MOUSESYS
operator|&&
operator|(
name|rodent
operator|.
name|cleardtr
operator|)
condition|)
block|{
name|int
name|val
init|=
name|TIOCM_DTR
decl_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_MOUSESYS
operator|&&
operator|(
name|rodent
operator|.
name|clearrts
operator|)
condition|)
block|{
name|int
name|val
init|=
name|TIOCM_RTS
decl_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ACTIVITY
modifier|*
name|r_protocol
parameter_list|(
name|u_char
name|rBuf
parameter_list|)
block|{
specifier|static
name|int
name|pBufP
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pBuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
name|ACTIVITY
name|act
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto
index|[
literal|10
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  hd_mask hd_id   dp_mask dp_id   nobytes */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* nomouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MicroSoft */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|}
block|,
comment|/* MouseSystems */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MMSeries */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* Logitech */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|}
block|,
comment|/* BusMouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MouseMan */
block|{
literal|0xc0
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* PS/2 mouse */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MM_HitTablet */
block|}
decl_stmt|;
name|debug
argument_list|(
literal|"received char 0x%x"
argument_list|,
operator|(
name|int
operator|)
name|rBuf
argument_list|)
expr_stmt|;
comment|/*      * Hack for resyncing: We check here for a package that is:      *  a) illegal (detected by wrong data-package header)      *  b) invalid (0x80 == -128 and that might be wrong for MouseSystems)      *  c) bad header-package      *      * NOTE: b) is a voilation of the MouseSystems-Protocol, since values of      *       -128 are allowed, but since they are very seldom we can easily      *       use them as package-header with no button pressed.      * NOTE/2: On a PS/2 mouse any byte is valid as a data byte. Furthermore,      *         0x80 is not valid as a header byte. For a PS/2 mouse we skip      *         checking data bytes.      *         For resyncing a PS/2 mouse we require the two most significant      *         bits in the header byte to be 0. These are the overflow bits,      *         and in case of an overflow we actually lose sync. Overflows      *         are very rare, however, and we quickly gain sync again after      *         an overflow condition. This is the best we can do. (Actually,      *         we could use bit 0x08 in the header byte for resyncing, since      *         that bit is supposed to be always on, but nobody told      *         Microsoft...)      */
if|if
condition|(
name|pBufP
operator|!=
literal|0
operator|&&
name|rodent
operator|.
name|rtype
operator|!=
name|R_PS_2
operator|&&
operator|(
operator|(
name|rBuf
operator|&
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|2
index|]
operator|)
operator|!=
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|3
index|]
operator|||
name|rBuf
operator|==
literal|0x80
operator|)
condition|)
block|{
name|pBufP
operator|=
literal|0
expr_stmt|;
comment|/* skip package */
block|}
if|if
condition|(
name|pBufP
operator|==
literal|0
operator|&&
operator|(
name|rBuf
operator|&
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|0
index|]
operator|)
operator|!=
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|1
index|]
condition|)
block|{
comment|/* 	 * Hack for Logitech MouseMan Mouse - Middle button 	 * 	 * Unfortunately this mouse has variable length packets: the standard 	 * Microsoft 3 byte packet plus an optional 4th byte whenever the 	 * middle button status changes. 	 * 	 * We have already processed the standard packet with the movement 	 * and button info.  Now post an event message with the old status 	 * of the left and right buttons and the updated middle button. 	 */
comment|/* 	 * Even worse, different MouseMen and TrackMen differ in the 4th 	 * byte: some will send 0x00/0x20, others 0x01/0x21, or even 	 * 0x02/0x22, so I have to strip off the lower bits. 	 */
if|if
condition|(
operator|(
name|rodent
operator|.
name|rtype
operator|==
name|R_MICROSOFT
operator|||
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGIMAN
operator|)
operator|&&
call|(
name|char
call|)
argument_list|(
name|rBuf
operator|&
operator|~
literal|0x23
argument_list|)
operator|==
literal|0
condition|)
block|{
name|act
operator|.
name|buttons
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|rBuf
operator|&
literal|0x20
argument_list|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|rodent
operator|.
name|lastbuttons
operator|&
literal|0x05
operator|)
expr_stmt|;
name|rodent
operator|.
name|lastbuttons
operator|=
name|act
operator|.
name|buttons
expr_stmt|;
comment|/* save new button state */
return|return
operator|(
operator|&
name|act
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* skip package */
block|}
name|pBuf
index|[
name|pBufP
operator|++
index|]
operator|=
name|rBuf
expr_stmt|;
if|if
condition|(
name|pBufP
operator|!=
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|4
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/*      * assembly full package      */
name|debug
argument_list|(
literal|"assembled full packet (len %d) %x,%x,%x,%x,%x"
argument_list|,
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|4
index|]
argument_list|,
name|pBuf
index|[
literal|0
index|]
argument_list|,
name|pBuf
index|[
literal|1
index|]
argument_list|,
name|pBuf
index|[
literal|2
index|]
argument_list|,
name|pBuf
index|[
literal|3
index|]
argument_list|,
name|pBuf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|R_LOGIMAN
case|:
comment|/* MouseMan / TrackMan */
case|case
name|R_MICROSOFT
case|:
comment|/* Microsoft */
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ChordMiddle
condition|)
name|act
operator|.
name|buttons
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x30
operator|)
operator|==
literal|0x30
operator|)
condition|?
literal|2
else|:
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x20
argument_list|)
operator|>>
literal|3
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
argument_list|)
operator|>>
literal|4
operator|)
expr_stmt|;
else|else
name|act
operator|.
name|buttons
operator|=
operator|(
name|rodent
operator|.
name|lastbuttons
operator|&
literal|2
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x20
argument_list|)
operator|>>
literal|3
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
argument_list|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|act
operator|.
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|dy
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x0C
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MOUSESYS
case|:
comment|/* Mouse Systems Corp */
name|act
operator|.
name|buttons
operator|=
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
literal|0x07
expr_stmt|;
name|act
operator|.
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|1
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|-
operator|(
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|2
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|4
index|]
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|R_MMHITAB
case|:
comment|/* MM_HitTablet */
name|act
operator|.
name|buttons
operator|=
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|act
operator|.
name|buttons
operator|!=
literal|0
condition|)
name|act
operator|.
name|buttons
operator|=
literal|1
operator|<<
operator|(
name|act
operator|.
name|buttons
operator|-
literal|1
operator|)
expr_stmt|;
name|act
operator|.
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x08
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|R_MMSERIES
case|:
comment|/* MM Series */
case|case
name|R_LOGITECH
case|:
comment|/* Logitech Mice */
name|act
operator|.
name|buttons
operator|=
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x07
expr_stmt|;
name|act
operator|.
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x08
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|R_BUSMOUSE
case|:
comment|/* BusMouse */
name|act
operator|.
name|buttons
operator|=
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
literal|0x07
expr_stmt|;
name|act
operator|.
name|dx
operator|=
operator|(
name|char
operator|)
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|-
operator|(
name|char
operator|)
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|R_PS_2
case|:
comment|/* PS/2 mouse */
name|act
operator|.
name|buttons
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x04
operator|)
operator|>>
literal|1
operator||
comment|/* Middle */
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|>>
literal|1
operator||
comment|/* Right */
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* Left */
name|act
operator|.
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
condition|?
operator|-
operator|(
name|pBuf
index|[
literal|2
index|]
operator|-
literal|256
operator|)
else|:
operator|-
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
name|pBufP
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|act
operator|)
return|;
block|}
end_function

begin_comment
comment|/* $XConsortium: posix_tty.c,v 1.3 95/01/05 20:42:55 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/shared/posix_tty.c,v 3.4 1995/01/28 17:05:03 dawes Exp $ */
end_comment

begin_comment
comment|/*  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of David Dawes   * not be used in advertising or publicity pertaining to distribution of   * the software without specific, written prior permission.  * David Dawes makes no representations about the suitability of this   * software for any purpose.  It is provided "as is" without express or   * implied warranty.  *  * DAVID DAWES DISCLAIMS ALL WARRANTIES WITH REGARD TO   * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND   * FITNESS, IN NO EVENT SHALL DAVID DAWES BE LIABLE FOR   * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF   * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_function
name|void
name|setmousespeed
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|cflag
parameter_list|)
name|int
name|old
decl_stmt|;
name|int
name|new
decl_stmt|;
name|unsigned
name|cflag
decl_stmt|;
block|{
name|struct
name|termios
name|tty
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"warning: unable to get status of mouse fd"
argument_list|)
expr_stmt|;
block|}
name|tty
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|tty
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_cflag
operator|=
operator|(
name|tcflag_t
operator|)
name|cflag
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|old
condition|)
block|{
case|case
literal|9600
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1200
case|:
default|default:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to set status of mouse fd"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|new
condition|)
block|{
case|case
literal|9600
case|:
name|c
operator|=
literal|"*q"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|c
operator|=
literal|"*p"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|c
operator|=
literal|"*o"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1200
case|:
default|default:
name|c
operator|=
literal|"*n"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGIMAN
operator|||
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGITECH
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|c
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to write to mouse fd"
argument_list|)
expr_stmt|;
block|}
block|}
name|usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to set status of mouse fd"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

