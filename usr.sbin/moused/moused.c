begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  ** Copyright (c) 1995 Michael Smith, All rights reserved.  **  ** Redistribution and use in source and binary forms, with or without  ** modification, are permitted provided that the following conditions  ** are met:  ** 1. Redistributions of source code must retain the above copyright  **    notice, this list of conditions and the following disclaimer as  **    the first lines of this file unmodified.  ** 2. Redistributions in binary form must reproduce the above copyright  **    notice, this list of conditions and the following disclaimer in the  **    documentation and/or other materials provided with the distribution.  ** 3. All advertising materials mentioning features or use of this software  **    must display the following acknowledgment:  **      This product includes software developed by Michael Smith.  ** 4. The name of the author may not be used to endorse or promote products  **    derived from this software without specific prior written permission.  **  **  ** THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ANY  ** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  ** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Michael Smith BE LIABLE FOR  ** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  ** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  ** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  ** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  ** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  ** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  ** EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  **  **/
end_comment

begin_comment
comment|/**  ** MOUSED.C  **  ** Mouse daemon : listens to a serial port, the bus mouse interface, or  ** the PS/2 mouse port for mouse data stream, interprets data and passes  ** ioctls off to the console driver.  **  ** The mouse interface functions are derived closely from the mouse  ** handler in the XFree86 X server.  Many thanks to the XFree86 people  ** for their great work!  **  **/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/mouse.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|MAX_CLICKTHRESHOLD
value|2000
end_define

begin_comment
comment|/* 2 seconds */
end_comment

begin_define
define|#
directive|define
name|MAX_BUTTON2TIMEOUT
value|2000
end_define

begin_comment
comment|/* 2 seconds */
end_comment

begin_define
define|#
directive|define
name|DFLT_CLICKTHRESHOLD
value|500
end_define

begin_comment
comment|/* 0.5 second */
end_comment

begin_define
define|#
directive|define
name|DFLT_BUTTON2TIMEOUT
value|100
end_define

begin_comment
comment|/* 0.1 second */
end_comment

begin_comment
comment|/* Abort 3-button emulation delay after this many movement events. */
end_comment

begin_define
define|#
directive|define
name|BUTTON2_MAXMOVE
value|3
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|MOUSE_XAXIS
value|(-1)
end_define

begin_define
define|#
directive|define
name|MOUSE_YAXIS
value|(-2)
end_define

begin_comment
comment|/* Logitech PS2++ protocol */
end_comment

begin_define
define|#
directive|define
name|MOUSE_PS2PLUS_CHECKBITS
parameter_list|(
name|b
parameter_list|)
define|\
value|((((b[2]& 0x03)<< 2) | 0x02) == (b[1]& 0x0f))
end_define

begin_define
define|#
directive|define
name|MOUSE_PS2PLUS_PACKET_TYPE
parameter_list|(
name|b
parameter_list|)
define|\
value|(((b[0]& 0x30)>> 2) | ((b[1]& 0x30)>> 4))
end_define

begin_define
define|#
directive|define
name|ChordMiddle
value|0x0001
end_define

begin_define
define|#
directive|define
name|Emulate3Button
value|0x0002
end_define

begin_define
define|#
directive|define
name|ClearDTR
value|0x0004
end_define

begin_define
define|#
directive|define
name|ClearRTS
value|0x0008
end_define

begin_define
define|#
directive|define
name|NoPnP
value|0x0010
end_define

begin_define
define|#
directive|define
name|ID_NONE
value|0
end_define

begin_define
define|#
directive|define
name|ID_PORT
value|1
end_define

begin_define
define|#
directive|define
name|ID_IF
value|2
end_define

begin_define
define|#
directive|define
name|ID_TYPE
value|4
end_define

begin_define
define|#
directive|define
name|ID_MODEL
value|8
end_define

begin_define
define|#
directive|define
name|ID_ALL
value|(ID_PORT | ID_IF | ID_TYPE | ID_MODEL)
end_define

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {				\ 	if (debug&& nodaemon)					\ 		warnx(fmt, ##args);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|logerr
parameter_list|(
name|e
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {				\ 	log_or_warn(LOG_DAEMON | LOG_ERR, errno, fmt, ##args);	\ 	exit(e);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|logerrx
parameter_list|(
name|e
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do {				\ 	log_or_warn(LOG_DAEMON | LOG_ERR, 0, fmt, ##args);	\ 	exit(e);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|logwarn
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|log_or_warn(LOG_DAEMON | LOG_WARNING, errno, fmt, ##args)
end_define

begin_define
define|#
directive|define
name|logwarnx
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|log_or_warn(LOG_DAEMON | LOG_WARNING, 0, fmt, ##args)
end_define

begin_comment
comment|/* structures */
end_comment

begin_comment
comment|/* symbol table entry */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|val2
decl_stmt|;
block|}
name|symtab_t
typedef|;
end_typedef

begin_comment
comment|/* serial PnP ID string */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|revision
decl_stmt|;
comment|/* PnP revision, 100 for 1.00 */
name|char
modifier|*
name|eisaid
decl_stmt|;
comment|/* EISA ID including mfr ID and product ID */
name|char
modifier|*
name|serial
decl_stmt|;
comment|/* serial No, optional */
name|char
modifier|*
name|class
decl_stmt|;
comment|/* device class, optional */
name|char
modifier|*
name|compat
decl_stmt|;
comment|/* list of compatible drivers, optional */
name|char
modifier|*
name|description
decl_stmt|;
comment|/* product description, optional */
name|int
name|neisaid
decl_stmt|;
comment|/* length of the above fields... */
name|int
name|nserial
decl_stmt|;
name|int
name|nclass
decl_stmt|;
name|int
name|ncompat
decl_stmt|;
name|int
name|ndescription
decl_stmt|;
block|}
name|pnpid_t
typedef|;
end_typedef

begin_comment
comment|/* global variables */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodaemon
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|background
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|identify
init|=
name|ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extioctl
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pidfile
init|=
literal|"/var/run/moused.pid"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local variables */
end_comment

begin_comment
comment|/* interface (the table must be ordered by MOUSE_IF_XXX in mouse.h) */
end_comment

begin_decl_stmt
specifier|static
name|symtab_t
name|rifs
index|[]
init|=
block|{
block|{
literal|"serial"
block|,
name|MOUSE_IF_SERIAL
block|}
block|,
block|{
literal|"bus"
block|,
name|MOUSE_IF_BUS
block|}
block|,
block|{
literal|"inport"
block|,
name|MOUSE_IF_INPORT
block|}
block|,
block|{
literal|"ps/2"
block|,
name|MOUSE_IF_PS2
block|}
block|,
block|{
literal|"sysmouse"
block|,
name|MOUSE_IF_SYSMOUSE
block|}
block|,
block|{
literal|"usb"
block|,
name|MOUSE_IF_USB
block|}
block|,
block|{
name|NULL
block|,
name|MOUSE_IF_UNKNOWN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* types (the table must be ordered by MOUSE_PROTO_XXX in mouse.h) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
literal|"microsoft"
block|,
literal|"mousesystems"
block|,
literal|"logitech"
block|,
literal|"mmseries"
block|,
literal|"mouseman"
block|,
literal|"busmouse"
block|,
literal|"inportmouse"
block|,
literal|"ps/2"
block|,
literal|"mmhitab"
block|,
literal|"glidepoint"
block|,
literal|"intellimouse"
block|,
literal|"thinkingmouse"
block|,
literal|"sysmouse"
block|,
literal|"x10mouseremote"
block|,
literal|"kidspad"
block|,
literal|"versapad"
block|,
literal|"jogdial"
block|,
if|#
directive|if
name|notyet
literal|"mariqua"
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* models */
end_comment

begin_decl_stmt
specifier|static
name|symtab_t
name|rmodels
index|[]
init|=
block|{
block|{
literal|"NetScroll"
block|,
name|MOUSE_MODEL_NETSCROLL
block|}
block|,
block|{
literal|"NetMouse/NetScroll Optical"
block|,
name|MOUSE_MODEL_NET
block|}
block|,
block|{
literal|"GlidePoint"
block|,
name|MOUSE_MODEL_GLIDEPOINT
block|}
block|,
block|{
literal|"ThinkingMouse"
block|,
name|MOUSE_MODEL_THINK
block|}
block|,
block|{
literal|"IntelliMouse"
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
block|{
literal|"EasyScroll/SmartScroll"
block|,
name|MOUSE_MODEL_EASYSCROLL
block|}
block|,
block|{
literal|"MouseMan+"
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
block|{
literal|"Kidspad"
block|,
name|MOUSE_MODEL_KIDSPAD
block|}
block|,
block|{
literal|"VersaPad"
block|,
name|MOUSE_MODEL_VERSAPAD
block|}
block|,
block|{
literal|"IntelliMouse Explorer"
block|,
name|MOUSE_MODEL_EXPLORER
block|}
block|,
block|{
literal|"4D Mouse"
block|,
name|MOUSE_MODEL_4D
block|}
block|,
block|{
literal|"4D+ Mouse"
block|,
name|MOUSE_MODEL_4DPLUS
block|}
block|,
block|{
literal|"generic"
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
block|{
name|NULL
block|,
name|MOUSE_MODEL_UNKNOWN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PnP EISA/product IDs */
end_comment

begin_decl_stmt
specifier|static
name|symtab_t
name|pnpprod
index|[]
init|=
block|{
comment|/* Kensignton ThinkingMouse */
block|{
literal|"KML0001"
block|,
name|MOUSE_PROTO_THINK
block|,
name|MOUSE_MODEL_THINK
block|}
block|,
comment|/* MS IntelliMouse */
block|{
literal|"MSH0001"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* MS IntelliMouse TrackBall */
block|{
literal|"MSH0004"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* Tremon Wheel Mouse MUSD */
block|{
literal|"HTK0001"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* Genius PnP Mouse */
block|{
literal|"KYE0001"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MouseSystems SmartScroll Mouse (OEM from Genius?) */
block|{
literal|"KYE0002"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_EASYSCROLL
block|}
block|,
comment|/* Genius NetMouse */
block|{
literal|"KYE0003"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_NET
block|}
block|,
comment|/* Genius Kidspad, Easypad and other tablets */
block|{
literal|"KYE0005"
block|,
name|MOUSE_PROTO_KIDSPAD
block|,
name|MOUSE_MODEL_KIDSPAD
block|}
block|,
comment|/* Genius EZScroll */
block|{
literal|"KYEEZ00"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_EASYSCROLL
block|}
block|,
comment|/* Logitech Cordless MouseMan Wheel */
block|{
literal|"LGI8033"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech MouseMan (new 4 button model) */
block|{
literal|"LGI800C"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech MouseMan+ */
block|{
literal|"LGI8050"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech FirstMouse+ */
block|{
literal|"LGI8051"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech serial */
block|{
literal|"LGI8001"
block|,
name|MOUSE_PROTO_LOGIMOUSEMAN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* A4 Tech 4D/4D+ Mouse */
block|{
literal|"A4W0005"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_4D
block|}
block|,
comment|/* 8D Scroll Mouse */
block|{
literal|"PEC9802"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* Mitsumi Wireless Scroll Mouse */
block|{
literal|"MTM6401"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* MS bus */
block|{
literal|"PNP0F00"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS serial */
block|{
literal|"PNP0F01"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS InPort */
block|{
literal|"PNP0F02"
block|,
name|MOUSE_PROTO_INPORT
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PS/2 */
block|{
literal|"PNP0F03"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/*      * EzScroll returns PNP0F04 in the compatible device field; but it      * doesn't look compatible... XXX      */
comment|/* MouseSystems */
block|{
literal|"PNP0F04"
block|,
name|MOUSE_PROTO_MSC
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MouseSystems */
block|{
literal|"PNP0F05"
block|,
name|MOUSE_PROTO_MSC
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* Genius Mouse */
block|{
literal|"PNP0F06"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Genius Mouse */
block|{
literal|"PNP0F07"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Logitech serial */
block|{
literal|"PNP0F08"
block|,
name|MOUSE_PROTO_LOGIMOUSEMAN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS BallPoint serial */
block|{
literal|"PNP0F09"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PnP serial */
block|{
literal|"PNP0F0A"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PnP BallPoint serial */
block|{
literal|"PNP0F0B"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS serial comatible */
block|{
literal|"PNP0F0C"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS InPort comatible */
block|{
literal|"PNP0F0D"
block|,
name|MOUSE_PROTO_INPORT
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PS/2 comatible */
block|{
literal|"PNP0F0E"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS BallPoint comatible */
block|{
literal|"PNP0F0F"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* TI QuickPort */
block|{
literal|"PNP0F10"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* MS bus comatible */
block|{
literal|"PNP0F11"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Logitech PS/2 */
block|{
literal|"PNP0F12"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* PS/2 */
block|{
literal|"PNP0F13"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* MS Kids Mouse */
block|{
literal|"PNP0F14"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Logitech bus */
block|{
literal|"PNP0F15"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* Logitech SWIFT */
block|{
literal|"PNP0F16"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Logitech serial compat */
block|{
literal|"PNP0F17"
block|,
name|MOUSE_PROTO_LOGIMOUSEMAN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Logitech bus compatible */
block|{
literal|"PNP0F18"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Logitech PS/2 compatible */
block|{
literal|"PNP0F19"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* Logitech SWIFT compatible */
block|{
literal|"PNP0F1A"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* HP Omnibook */
block|{
literal|"PNP0F1B"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Compaq LTE TrackBall PS/2 */
block|{
literal|"PNP0F1C"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Compaq LTE TrackBall serial */
block|{
literal|"PNP0F1D"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS Kidts Trackball */
block|{
literal|"PNP0F1E"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Interlink VersaPad */
block|{
literal|"LNK0001"
block|,
name|MOUSE_PROTO_VERSAPAD
block|,
name|MOUSE_MODEL_VERSAPAD
block|}
block|,
block|{
name|NULL
block|,
name|MOUSE_PROTO_UNKNOWN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the table must be ordered by MOUSE_PROTO_XXX in mouse.h */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|rodentcflags
index|[]
init|=
block|{
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MicroSoft */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseSystems */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Logitech */
operator|(
name|CS8
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MMSeries */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseMan */
literal|0
block|,
comment|/* Bus */
literal|0
block|,
comment|/* InPort */
literal|0
block|,
comment|/* PS/2 */
operator|(
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MM HitTablet */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* GlidePoint */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* IntelliMouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Thinking Mouse */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* sysmouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* X10 MouseRemote */
operator|(
name|CS8
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* kidspad etc. */
operator|(
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* VersaPad */
literal|0
block|,
comment|/* JogDial */
if|#
directive|if
name|notyet
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Mariqua */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|rodentparam
block|{
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|portname
decl_stmt|;
comment|/* /dev/XXX */
name|int
name|rtype
decl_stmt|;
comment|/* MOUSE_PROTO_XXX */
name|int
name|level
decl_stmt|;
comment|/* operation level: 0 or greater */
name|int
name|baudrate
decl_stmt|;
name|int
name|rate
decl_stmt|;
comment|/* report rate */
name|int
name|resolution
decl_stmt|;
comment|/* MOUSE_RES_XXX or a positive number */
name|int
name|zmap
index|[
literal|4
index|]
decl_stmt|;
comment|/* MOUSE_{X|Y}AXIS or a button number */
name|int
name|wmode
decl_stmt|;
comment|/* wheel mode button number */
name|int
name|mfd
decl_stmt|;
comment|/* mouse file descriptor */
name|int
name|cfd
decl_stmt|;
comment|/* /dev/consolectl file descriptor */
name|int
name|mremsfd
decl_stmt|;
comment|/* mouse remote server file descriptor */
name|int
name|mremcfd
decl_stmt|;
comment|/* mouse remote client file descriptor */
name|long
name|clickthreshold
decl_stmt|;
comment|/* double click speed in msec */
name|long
name|button2timeout
decl_stmt|;
comment|/* 3 button emulation timeout */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* mouse device hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* protocol information */
name|float
name|accelx
decl_stmt|;
comment|/* Acceleration in the X axis */
name|float
name|accely
decl_stmt|;
comment|/* Acceleration in the Y axis */
block|}
name|rodent
init|=
block|{
name|flags
operator|:
literal|0
block|,
name|portname
operator|:
name|NULL
block|,
name|rtype
operator|:
name|MOUSE_PROTO_UNKNOWN
block|,
name|level
operator|:
operator|-
literal|1
block|,
name|baudrate
operator|:
literal|1200
block|,
name|rate
operator|:
literal|0
block|,
name|resolution
operator|:
name|MOUSE_RES_UNKNOWN
block|,
name|zmap
operator|:
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|wmode
operator|:
literal|0
block|,
name|mfd
operator|:
operator|-
literal|1
block|,
name|cfd
operator|:
operator|-
literal|1
block|,
name|mremsfd
operator|:
operator|-
literal|1
block|,
name|mremcfd
operator|:
operator|-
literal|1
block|,
name|clickthreshold
operator|:
name|DFLT_CLICKTHRESHOLD
block|,
name|button2timeout
operator|:
name|DFLT_BUTTON2TIMEOUT
block|,
name|accelx
operator|:
literal|1.0
block|,
name|accely
operator|:
literal|1.0
block|, }
struct|;
end_struct

begin_comment
comment|/* button status */
end_comment

begin_struct
struct|struct
name|button_state
block|{
name|int
name|count
decl_stmt|;
comment|/* 0: up, 1: single click, 2: double click,... */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* timestamp on the last button event */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|button_state
name|bstate
index|[
name|MOUSE_MAXBUTTON
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* button state */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|button_state
modifier|*
name|mstate
index|[
name|MOUSE_MAXBUTTON
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mapped button st.*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|button_state
name|zstate
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Z/W axis state */
end_comment

begin_comment
comment|/* state machine for 3 button emulation */
end_comment

begin_define
define|#
directive|define
name|S0
value|0
end_define

begin_comment
comment|/* start */
end_comment

begin_define
define|#
directive|define
name|S1
value|1
end_define

begin_comment
comment|/* button 1 delayed down */
end_comment

begin_define
define|#
directive|define
name|S2
value|2
end_define

begin_comment
comment|/* button 3 delayed down */
end_comment

begin_define
define|#
directive|define
name|S3
value|3
end_define

begin_comment
comment|/* both buttons down -> button 2 down */
end_comment

begin_define
define|#
directive|define
name|S4
value|4
end_define

begin_comment
comment|/* button 1 delayed up */
end_comment

begin_define
define|#
directive|define
name|S5
value|5
end_define

begin_comment
comment|/* button 1 down */
end_comment

begin_define
define|#
directive|define
name|S6
value|6
end_define

begin_comment
comment|/* button 3 down */
end_comment

begin_define
define|#
directive|define
name|S7
value|7
end_define

begin_comment
comment|/* both buttons down */
end_comment

begin_define
define|#
directive|define
name|S8
value|8
end_define

begin_comment
comment|/* button 3 delayed up */
end_comment

begin_define
define|#
directive|define
name|S9
value|9
end_define

begin_comment
comment|/* button 1 or 3 up after S3 */
end_comment

begin_define
define|#
directive|define
name|A
parameter_list|(
name|b1
parameter_list|,
name|b3
parameter_list|)
value|(((b1) ? 2 : 0) | ((b3) ? 1 : 0))
end_define

begin_define
define|#
directive|define
name|A_TIMEOUT
value|4
end_define

begin_define
define|#
directive|define
name|S_DELAYED
parameter_list|(
name|st
parameter_list|)
value|(states[st].s[A_TIMEOUT] != (st))
end_define

begin_struct
specifier|static
struct|struct
block|{
name|int
name|s
index|[
name|A_TIMEOUT
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|buttons
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
name|states
index|[
literal|10
index|]
init|=
block|{
comment|/* S0 */
block|{
block|{
name|S0
block|,
name|S2
block|,
name|S1
block|,
name|S3
block|,
name|S0
block|}
block|,
literal|0
block|,
operator|~
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
block|,
name|FALSE
block|}
block|,
comment|/* S1 */
block|{
block|{
name|S4
block|,
name|S2
block|,
name|S1
block|,
name|S3
block|,
name|S5
block|}
block|,
literal|0
block|,
operator|~
name|MOUSE_BUTTON1DOWN
block|,
name|FALSE
block|}
block|,
comment|/* S2 */
block|{
block|{
name|S8
block|,
name|S2
block|,
name|S1
block|,
name|S3
block|,
name|S6
block|}
block|,
literal|0
block|,
operator|~
name|MOUSE_BUTTON3DOWN
block|,
name|FALSE
block|}
block|,
comment|/* S3 */
block|{
block|{
name|S0
block|,
name|S9
block|,
name|S9
block|,
name|S3
block|,
name|S3
block|}
block|,
name|MOUSE_BUTTON2DOWN
block|,
operator|~
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* S4 */
block|{
block|{
name|S0
block|,
name|S2
block|,
name|S1
block|,
name|S3
block|,
name|S0
block|}
block|,
name|MOUSE_BUTTON1DOWN
block|,
operator|~
literal|0
block|,
name|TRUE
block|}
block|,
comment|/* S5 */
block|{
block|{
name|S0
block|,
name|S2
block|,
name|S5
block|,
name|S7
block|,
name|S5
block|}
block|,
name|MOUSE_BUTTON1DOWN
block|,
operator|~
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* S6 */
block|{
block|{
name|S0
block|,
name|S6
block|,
name|S1
block|,
name|S7
block|,
name|S6
block|}
block|,
name|MOUSE_BUTTON3DOWN
block|,
operator|~
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* S7 */
block|{
block|{
name|S0
block|,
name|S6
block|,
name|S5
block|,
name|S7
block|,
name|S7
block|}
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
operator|~
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* S8 */
block|{
block|{
name|S0
block|,
name|S2
block|,
name|S1
block|,
name|S3
block|,
name|S0
block|}
block|,
name|MOUSE_BUTTON3DOWN
block|,
operator|~
literal|0
block|,
name|TRUE
block|}
block|,
comment|/* S9 */
block|{
block|{
name|S0
block|,
name|S9
block|,
name|S9
block|,
name|S3
block|,
name|S9
block|}
block|,
literal|0
block|,
operator|~
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
block|,
name|FALSE
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|mouse_button_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|mouse_button_state_tv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mouse_move_delayed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|moused
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hup
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_or_warn
parameter_list|(
name|int
name|log_pri
parameter_list|,
name|int
name|errnum
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|r_identify
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|r_if
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|r_name
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|r_model
parameter_list|(
name|int
name|model
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_protocol
parameter_list|(
name|u_char
name|b
parameter_list|,
name|mousestatus_t
modifier|*
name|act
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_statetrans
parameter_list|(
name|mousestatus_t
modifier|*
name|a1
parameter_list|,
name|mousestatus_t
modifier|*
name|a2
parameter_list|,
name|int
name|trans
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_installmap
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_map
parameter_list|(
name|mousestatus_t
modifier|*
name|act1
parameter_list|,
name|mousestatus_t
modifier|*
name|act2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_timestamp
parameter_list|(
name|mousestatus_t
modifier|*
name|act
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_timeout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_click
parameter_list|(
name|mousestatus_t
modifier|*
name|act
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setmousespeed
parameter_list|(
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|,
name|unsigned
name|cflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnpwakeup1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnpwakeup2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnpgets
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnpparse
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symtab_t
modifier|*
name|pnpproto
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symtab_t
modifier|*
name|gettoken
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gettokenname
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mremote_serversetup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mremote_clientchg
parameter_list|(
name|int
name|add
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kidspad
parameter_list|(
name|u_char
name|rxc
parameter_list|,
name|mousestatus_t
modifier|*
name|act
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbmodule
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|retry
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MOUSE_MAXBUTTON
condition|;
operator|++
name|i
control|)
name|mstate
index|[
name|i
index|]
operator|=
operator|&
name|bstate
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"3C:DE:F:I:PRS:a:cdfhi:l:m:p:r:st:w:z:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'3'
case|:
name|rodent
operator|.
name|flags
operator||=
name|Emulate3Button
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|rodent
operator|.
name|button2timeout
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|button2timeout
operator|<
literal|0
operator|)
operator|||
operator|(
name|rodent
operator|.
name|button2timeout
operator|>
name|MAX_BUTTON2TIMEOUT
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|i
operator|=
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%f,%f"
argument_list|,
operator|&
name|rodent
operator|.
name|accelx
argument_list|,
operator|&
name|rodent
operator|.
name|accely
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid acceleration argument '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|rodent
operator|.
name|accely
operator|=
name|rodent
operator|.
name|accelx
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ChordMiddle
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|nodaemon
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_PORT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"if"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_IF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"model"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_MODEL
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|nodaemon
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|rodent
operator|.
name|level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|rodent
operator|.
name|level
operator|>
literal|4
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|r_installmap
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|rodent
operator|.
name|portname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"high"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"medium-high"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"medium-low"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"low"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_DEFAULT
expr_stmt|;
else|else
block|{
name|rodent
operator|.
name|resolution
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
name|rodent
operator|.
name|baudrate
operator|=
literal|9600
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|i
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|MOUSE_MAXBUTTON
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|rodent
operator|.
name|wmode
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"x"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
operator|=
name|MOUSE_XAXIS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"y"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
operator|=
name|MOUSE_YAXIS
expr_stmt|;
else|else
block|{
name|i
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
comment|/* 		 * Use button i for negative Z axis movement and 		 * button (i + 1) for positive Z axis movement. 		 */
if|if
condition|(
operator|(
name|i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|MOUSE_MAXBUTTON
operator|-
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|rodent
operator|.
name|zmap
index|[
literal|1
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|debug
argument_list|(
literal|"optind: %d, optarg: '%s'"
argument_list|,
name|optind
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|optind
operator|>=
name|argc
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|argv
index|[
name|optind
index|]
argument_list|)
condition|)
break|break;
name|i
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|MOUSE_MAXBUTTON
operator|-
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|rodent
operator|.
name|zmap
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rodent
operator|.
name|zmap
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rodent
operator|.
name|zmap
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|)
name|rodent
operator|.
name|zmap
index|[
literal|3
index|]
operator|=
name|rodent
operator|.
name|zmap
index|[
literal|2
index|]
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
name|rodent
operator|.
name|clickthreshold
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|clickthreshold
operator|<
literal|0
operator|)
operator|||
operator|(
name|rodent
operator|.
name|clickthreshold
operator|>
name|MAX_CLICKTHRESHOLD
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ClearDTR
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|rodent
operator|.
name|rate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
name|pidfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|rodent
operator|.
name|flags
operator||=
name|NoPnP
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ClearRTS
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|rodent
operator|.
name|baudrate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|baudrate
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"rodent baudrate %d"
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rodent
operator|.
name|rtype
operator|=
name|MOUSE_PROTO_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|flags
operator|&=
operator|~
name|NoPnP
expr_stmt|;
name|rodent
operator|.
name|level
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|rnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rodent
operator|.
name|rtype
operator|=
name|i
expr_stmt|;
name|rodent
operator|.
name|flags
operator||=
name|NoPnP
expr_stmt|;
name|rodent
operator|.
name|level
operator|=
operator|(
name|i
operator|==
name|MOUSE_PROTO_SYSMOUSE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rnames
index|[
name|i
index|]
condition|)
break|break;
name|warnx
argument_list|(
literal|"no such mouse type `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* fix Z axis mapping */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rodent
operator|.
name|zmap
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MOUSE_MAXBUTTON
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|mstate
index|[
name|j
index|]
operator|==
operator|&
name|bstate
index|[
name|rodent
operator|.
name|zmap
index|[
name|i
index|]
operator|-
literal|1
index|]
condition|)
name|mstate
index|[
name|j
index|]
operator|=
operator|&
name|zstate
index|[
name|i
index|]
expr_stmt|;
block|}
name|rodent
operator|.
name|zmap
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|rodent
operator|.
name|zmap
index|[
name|i
index|]
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|/* the default port name */
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|MOUSE_PROTO_INPORT
case|:
comment|/* INPORT and BUS are the same... */
name|rodent
operator|.
name|rtype
operator|=
name|MOUSE_PROTO_BUS
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MOUSE_PROTO_BUS
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/mse0"
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_PS2
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/psm0"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|rodent
operator|.
name|portname
condition|)
break|break;
name|warnx
argument_list|(
literal|"no port name specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|retry
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|rodent
operator|.
name|portname
argument_list|,
literal|"/dev/ums"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|usbmodule
argument_list|()
expr_stmt|;
name|retry
operator|=
literal|5
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retry
condition|;
operator|++
name|i
control|)
block|{
name|rodent
operator|.
name|mfd
operator|=
name|open
argument_list|(
name|rodent
operator|.
name|portname
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|mfd
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
break|break;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mfd
operator|==
operator|-
literal|1
condition|)
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"unable to open %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_identify
argument_list|()
operator|==
name|MOUSE_PROTO_UNKNOWN
condition|)
block|{
name|logwarnx
argument_list|(
literal|"cannot determine mouse type on %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* print some information */
if|if
condition|(
name|identify
operator|!=
name|ID_NONE
condition|)
block|{
if|if
condition|(
name|identify
operator|==
name|ID_ALL
condition|)
name|printf
argument_list|(
literal|"%s %s %s %s\n"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|,
name|r_if
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_model
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_PORT
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_IF
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r_if
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_TYPE
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_MODEL
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r_model
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"port: %s  interface: %s  type: %s  model: %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|,
name|r_if
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_model
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mfd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We cannot continue because of error.  Exit if the 		 * program has not become a daemon.  Otherwise, block 		 * until the the user corrects the problem and issues SIGHUP. 		 */
if|if
condition|(
operator|!
name|background
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|r_init
argument_list|()
expr_stmt|;
comment|/* call init function */
name|moused
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|cfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mfd
operator|=
name|rodent
operator|.
name|cfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* NOT REACHED */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbmodule
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kld_file_stat
name|fstat
decl_stmt|;
name|struct
name|module_stat
name|mstat
decl_stmt|;
name|int
name|fileid
decl_stmt|,
name|modid
decl_stmt|;
name|int
name|loaded
decl_stmt|;
for|for
control|(
name|loaded
operator|=
literal|0
operator|,
name|fileid
operator|=
name|kldnext
argument_list|(
literal|0
argument_list|)
init|;
operator|!
name|loaded
operator|&&
name|fileid
operator|>
literal|0
condition|;
name|fileid
operator|=
name|kldnext
argument_list|(
name|fileid
argument_list|)
control|)
block|{
name|fstat
operator|.
name|version
operator|=
sizeof|sizeof
argument_list|(
name|fstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|kldstat
argument_list|(
name|fileid
argument_list|,
operator|&
name|fstat
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|fstat
operator|.
name|name
argument_list|,
literal|"uhub/ums"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|loaded
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|modid
operator|=
name|kldfirstmod
argument_list|(
name|fileid
argument_list|)
init|;
name|modid
operator|>
literal|0
condition|;
name|modid
operator|=
name|modfnext
argument_list|(
name|modid
argument_list|)
control|)
block|{
name|mstat
operator|.
name|version
operator|=
sizeof|sizeof
argument_list|(
name|mstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|modstat
argument_list|(
name|modid
argument_list|,
operator|&
name|mstat
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|mstat
operator|.
name|name
argument_list|,
literal|"uhub/ums"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|loaded
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|loaded
operator|&&
name|kldload
argument_list|(
literal|"ums"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"unable to load USB mouse driver"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moused
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mouse_info
name|mouse
decl_stmt|;
name|mousestatus_t
name|action0
decl_stmt|;
comment|/* original mouse action */
name|mousestatus_t
name|action
decl_stmt|;
comment|/* interrim buffer */
name|mousestatus_t
name|action2
decl_stmt|;
comment|/* mapped action */
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|cfd
operator|=
name|open
argument_list|(
literal|"/dev/consolectl"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"cannot open /dev/consolectl"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodaemon
operator|&&
operator|!
name|background
condition|)
block|{
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"failed to become a daemon"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|background
operator|=
name|TRUE
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|pidfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* clear mouse data */
name|bzero
argument_list|(
operator|&
name|action0
argument_list|,
sizeof|sizeof
argument_list|(
name|action0
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|action
argument_list|,
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|action2
argument_list|,
sizeof|sizeof
argument_list|(
name|action2
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mouse
argument_list|,
sizeof|sizeof
argument_list|(
name|mouse
argument_list|)
argument_list|)
expr_stmt|;
name|mouse_button_state
operator|=
name|S0
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|mouse_button_state_tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mouse_move_delayed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MOUSE_MAXBUTTON
condition|;
operator|++
name|i
control|)
block|{
name|bstate
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|bstate
index|[
name|i
index|]
operator|.
name|tv
operator|=
name|mouse_button_state_tv
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zstate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|zstate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|zstate
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|zstate
index|[
name|i
index|]
operator|.
name|tv
operator|=
name|mouse_button_state_tv
expr_stmt|;
block|}
comment|/* choose which ioctl command to use */
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_MOTION_EVENT
expr_stmt|;
name|extioctl
operator|=
operator|(
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* process mouse data */
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|20000
expr_stmt|;
comment|/* 20 msec */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|mremsfd
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mremsfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|mremcfd
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mremcfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|c
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|rodent
operator|.
name|flags
operator|&
name|Emulate3Button
operator|)
condition|?
operator|&
name|timeout
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|/* error */
name|logwarn
argument_list|(
literal|"failed to read from mouse"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* timeout */
comment|/* assert(rodent.flags& Emulate3Button) */
name|action0
operator|.
name|button
operator|=
name|action0
operator|.
name|obutton
expr_stmt|;
name|action0
operator|.
name|dx
operator|=
name|action0
operator|.
name|dy
operator|=
name|action0
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|action0
operator|.
name|flags
operator|=
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r_timeout
argument_list|()
operator|&&
name|r_statetrans
argument_list|(
operator|&
name|action0
argument_list|,
operator|&
name|action
argument_list|,
name|A_TIMEOUT
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|debug
argument_list|(
literal|"flags:%08x buttons:%08x obuttons:%08x"
argument_list|,
name|action
operator|.
name|flags
argument_list|,
name|action
operator|.
name|button
argument_list|,
name|action
operator|.
name|obutton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|action0
operator|.
name|obutton
operator|=
name|action0
operator|.
name|button
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/*  MouseRemote client connect/disconnect  */
if|if
condition|(
operator|(
name|rodent
operator|.
name|mremsfd
operator|>=
literal|0
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|rodent
operator|.
name|mremsfd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|mremote_clientchg
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|rodent
operator|.
name|mremcfd
operator|>=
literal|0
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|rodent
operator|.
name|mremcfd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|mremote_clientchg
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* mouse movement */
if|if
condition|(
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
continue|continue;
else|else
return|return;
block|}
if|if
condition|(
operator|(
name|flags
operator|=
name|r_protocol
argument_list|(
name|b
argument_list|,
operator|&
name|action0
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|r_timestamp
argument_list|(
operator|&
name|action0
argument_list|)
expr_stmt|;
name|r_statetrans
argument_list|(
operator|&
name|action0
argument_list|,
operator|&
name|action
argument_list|,
name|A
argument_list|(
name|action0
operator|.
name|button
operator|&
name|MOUSE_BUTTON1DOWN
argument_list|,
name|action0
operator|.
name|button
operator|&
name|MOUSE_BUTTON3DOWN
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"flags:%08x buttons:%08x obuttons:%08x"
argument_list|,
name|action
operator|.
name|flags
argument_list|,
name|action
operator|.
name|button
argument_list|,
name|action
operator|.
name|obutton
argument_list|)
expr_stmt|;
block|}
name|action0
operator|.
name|obutton
operator|=
name|action0
operator|.
name|button
expr_stmt|;
name|flags
operator|&=
name|MOUSE_POSCHANGED
expr_stmt|;
name|flags
operator||=
name|action
operator|.
name|obutton
operator|^
name|action
operator|.
name|button
expr_stmt|;
name|action
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
comment|/* handler detected action */
name|r_map
argument_list|(
operator|&
name|action
argument_list|,
operator|&
name|action2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"activity : buttons 0x%08x  dx %d  dy %d  dz %d"
argument_list|,
name|action2
operator|.
name|button
argument_list|,
name|action2
operator|.
name|dx
argument_list|,
name|action2
operator|.
name|dy
argument_list|,
name|action2
operator|.
name|dz
argument_list|)
expr_stmt|;
if|if
condition|(
name|extioctl
condition|)
block|{
name|r_click
argument_list|(
operator|&
name|action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
operator|.
name|flags
operator|&
name|MOUSE_POSCHANGED
condition|)
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_MOTION_EVENT
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|action2
operator|.
name|button
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|action2
operator|.
name|dx
operator|*
name|rodent
operator|.
name|accelx
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|action2
operator|.
name|dy
operator|*
name|rodent
operator|.
name|accely
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|z
operator|=
name|action2
operator|.
name|dz
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_ACTION
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|action2
operator|.
name|button
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|action2
operator|.
name|dx
operator|*
name|rodent
operator|.
name|accelx
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|action2
operator|.
name|dy
operator|*
name|rodent
operator|.
name|accely
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|z
operator|=
name|action2
operator|.
name|dz
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If the Z axis movement is mapped to an imaginary physical 	     * button, we need to cook up a corresponding button `up' event 	     * after sending a button `down' event. 	     */
if|if
condition|(
operator|(
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
operator|>
literal|0
operator|)
operator|&&
operator|(
name|action
operator|.
name|dz
operator|!=
literal|0
operator|)
condition|)
block|{
name|action
operator|.
name|obutton
operator|=
name|action
operator|.
name|button
expr_stmt|;
name|action
operator|.
name|dx
operator|=
name|action
operator|.
name|dy
operator|=
name|action
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|r_map
argument_list|(
operator|&
name|action
argument_list|,
operator|&
name|action2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"activity : buttons 0x%08x  dx %d  dy %d  dz %d"
argument_list|,
name|action2
operator|.
name|button
argument_list|,
name|action2
operator|.
name|dx
argument_list|,
name|action2
operator|.
name|dy
argument_list|,
name|action2
operator|.
name|dz
argument_list|)
expr_stmt|;
if|if
condition|(
name|extioctl
condition|)
block|{
name|r_click
argument_list|(
operator|&
name|action2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_ACTION
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|action2
operator|.
name|button
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* NOT REACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|hup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_X10MOUSEREM
condition|)
name|unlink
argument_list|(
name|_PATH_MOUSEREMOTE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** usage  **  ** Complain, and free the CPU for more worthy tasks  **/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n"
argument_list|,
literal|"usage: moused [-DRcdfs] [-I file] [-F rate] [-r resolution] [-S baudrate]"
argument_list|,
literal|"              [-a X [,Y]] [-C threshold] [-m N=M] [-w N] [-z N]"
argument_list|,
literal|"              [-t<mousetype>] [-3 [-E timeout]] -p<port>"
argument_list|,
literal|"       moused [-d] -i<port|if|type|model|all> -p<port>"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output an error message to syslog or stderr as appropriate. If  * `errnum' is non-zero, append its string form to the message.  */
end_comment

begin_function
specifier|static
name|void
name|log_or_warn
parameter_list|(
name|int
name|log_pri
parameter_list|,
name|int
name|errnum
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|errnum
condition|)
block|{
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|": "
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|strerror
argument_list|(
name|errnum
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|background
condition|)
name|syslog
argument_list|(
name|log_pri
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** Mouse interface code, courtesy of XFree86 3.1.2.  **  ** Note: Various bits have been trimmed, and in my shortsighted enthusiasm  ** to clean, reformat and rationalise naming, it's quite possible that  ** some things in here have been broken.  **  ** I hope not 8)  **  ** The following code is derived from a module marked :  **/
end_comment

begin_comment
comment|/* $XConsortium: xf86_Mouse.c,v 1.2 94/10/12 20:33:21 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.2 1995/01/28  17:03:40 dawes Exp $ */
end_comment

begin_comment
comment|/*  *  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of Thomas Roell and David Dawes not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  Thomas Roell  * and David Dawes makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * THOMAS ROELL AND DAVID DAWES DISCLAIM ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS, IN NO EVENT SHALL THOMAS ROELL OR DAVID DAWES BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_comment
comment|/**  ** GlidePoint support from XFree86 3.2.  ** Derived from the module:  **/
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.19 1996/10/16 14:40:51 dawes Exp $ */
end_comment

begin_comment
comment|/* $XConsortium: xf86_Mouse.c /main/10 1996/01/30 15:16:12 kaleb $ */
end_comment

begin_comment
comment|/* the following table must be ordered by MOUSE_PROTO_XXX in mouse.h */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|proto
index|[]
index|[
literal|7
index|]
init|=
block|{
comment|/*  hd_mask hd_id   dp_mask dp_id   bytes b4_mask b4_id */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x23
block|,
literal|0x00
block|}
block|,
comment|/* MicroSoft */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* MouseSystems */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* Logitech */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* MMSeries */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x33
block|,
literal|0x00
block|}
block|,
comment|/* MouseMan */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* Bus */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* InPort */
block|{
literal|0xc0
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* PS/2 mouse */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* MM HitTablet */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x33
block|,
literal|0x00
block|}
block|,
comment|/* GlidePoint */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x3f
block|,
literal|0x00
block|}
block|,
comment|/* IntelliMouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x33
block|,
literal|0x00
block|}
block|,
comment|/* ThinkingMouse */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* sysmouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x23
block|,
literal|0x00
block|}
block|,
comment|/* X10 MouseRem */
block|{
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* KIDSPAD */
block|{
literal|0xc3
block|,
literal|0xc0
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|6
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* VersaPad */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|1
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* JogDial */
if|#
directive|if
name|notyet
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
operator|~
literal|0x2f
block|,
literal|0x10
block|}
block|,
comment|/* Mariqua */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|cur_proto
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|r_identify
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|pnpbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* PnP identifier string may be up to 256 bytes long */
name|pnpid_t
name|pnpid
decl_stmt|;
name|symtab_t
modifier|*
name|t
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* set the driver operation level, if applicable */
if|if
condition|(
name|rodent
operator|.
name|level
operator|<
literal|0
condition|)
name|rodent
operator|.
name|level
operator|=
literal|1
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_SETLEVEL
argument_list|,
operator|&
name|rodent
operator|.
name|level
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|level
operator|=
operator|(
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_GETLEVEL
argument_list|,
operator|&
name|level
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|level
else|:
literal|0
expr_stmt|;
comment|/*      * Interrogate the driver and get some intelligence on the device...      * The following ioctl functions are not always supported by device      * drivers.  When the driver doesn't support them, we just trust the      * user to supply valid information.      */
name|rodent
operator|.
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_GETHWINFO
argument_list|,
operator|&
name|rodent
operator|.
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
name|bcopy
argument_list|(
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|,
name|cur_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_proto
argument_list|)
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_GETMODE
argument_list|,
operator|&
name|rodent
operator|.
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_UNKNOWN
operator|)
operator|||
operator|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|>=
sizeof|sizeof
argument_list|(
name|proto
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|proto
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|logwarnx
argument_list|(
literal|"unknown mouse protocol (%d)"
argument_list|,
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
expr_stmt|;
return|return
name|MOUSE_PROTO_UNKNOWN
return|;
block|}
else|else
block|{
comment|/* INPORT and BUS are the same... */
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_INPORT
condition|)
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_BUS
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|!=
name|rodent
operator|.
name|rtype
condition|)
block|{
comment|/* Hmm, the driver doesn't agree with the user... */
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
name|logwarnx
argument_list|(
literal|"mouse type mismatch (%s != %s), %s is assumed"
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|rtype
operator|=
name|rodent
operator|.
name|mode
operator|.
name|protocol
expr_stmt|;
name|bcopy
argument_list|(
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|,
name|cur_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_proto
index|[
literal|4
index|]
operator|=
name|rodent
operator|.
name|mode
operator|.
name|packetsize
expr_stmt|;
name|cur_proto
index|[
literal|0
index|]
operator|=
name|rodent
operator|.
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
expr_stmt|;
comment|/* header byte bit mask */
name|cur_proto
index|[
literal|1
index|]
operator|=
name|rodent
operator|.
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
expr_stmt|;
comment|/* header bit pattern */
block|}
comment|/* maybe this is a PnP mouse... */
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_UNKNOWN
condition|)
block|{
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|NoPnP
condition|)
return|return
name|rodent
operator|.
name|rtype
return|;
if|if
condition|(
operator|(
operator|(
name|len
operator|=
name|pnpgets
argument_list|(
name|pnpbuf
argument_list|)
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|!
name|pnpparse
argument_list|(
operator|&
name|pnpid
argument_list|,
name|pnpbuf
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|rodent
operator|.
name|rtype
return|;
name|debug
argument_list|(
literal|"PnP serial mouse: '%*.*s' '%*.*s' '%*.*s'"
argument_list|,
name|pnpid
operator|.
name|neisaid
argument_list|,
name|pnpid
operator|.
name|neisaid
argument_list|,
name|pnpid
operator|.
name|eisaid
argument_list|,
name|pnpid
operator|.
name|ncompat
argument_list|,
name|pnpid
operator|.
name|ncompat
argument_list|,
name|pnpid
operator|.
name|compat
argument_list|,
name|pnpid
operator|.
name|ndescription
argument_list|,
name|pnpid
operator|.
name|ndescription
argument_list|,
name|pnpid
operator|.
name|description
argument_list|)
expr_stmt|;
comment|/* we have a valid PnP serial device ID */
name|rodent
operator|.
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_SERIAL
expr_stmt|;
name|t
operator|=
name|pnpproto
argument_list|(
operator|&
name|pnpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|t
operator|->
name|val
expr_stmt|;
name|rodent
operator|.
name|hw
operator|.
name|model
operator|=
name|t
operator|->
name|val2
expr_stmt|;
block|}
else|else
block|{
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_INPORT
condition|)
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_BUS
expr_stmt|;
comment|/* make final adjustment */
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
block|{
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|!=
name|rodent
operator|.
name|rtype
condition|)
block|{
comment|/* Hmm, the device doesn't agree with the user... */
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
name|logwarnx
argument_list|(
literal|"mouse type mismatch (%s != %s), %s is assumed"
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|rtype
operator|=
name|rodent
operator|.
name|mode
operator|.
name|protocol
expr_stmt|;
name|bcopy
argument_list|(
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|,
name|cur_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|debug
argument_list|(
literal|"proto params: %02x %02x %02x %02x %d %02x %02x"
argument_list|,
name|cur_proto
index|[
literal|0
index|]
argument_list|,
name|cur_proto
index|[
literal|1
index|]
argument_list|,
name|cur_proto
index|[
literal|2
index|]
argument_list|,
name|cur_proto
index|[
literal|3
index|]
argument_list|,
name|cur_proto
index|[
literal|4
index|]
argument_list|,
name|cur_proto
index|[
literal|5
index|]
argument_list|,
name|cur_proto
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
return|return
name|rodent
operator|.
name|rtype
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|r_if
parameter_list|(
name|int
name|iftype
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|gettokenname
argument_list|(
name|rifs
argument_list|,
name|iftype
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"unknown"
else|:
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|r_name
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
operator|(
name|type
operator|==
name|MOUSE_PROTO_UNKNOWN
operator|)
operator|||
operator|(
name|type
operator|>
sizeof|sizeof
argument_list|(
name|rnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rnames
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|"unknown"
else|:
name|rnames
index|[
name|type
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|r_model
parameter_list|(
name|int
name|model
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|gettokenname
argument_list|(
name|rmodels
argument_list|,
name|model
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"unknown"
else|:
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* scrach buffer */
name|fd_set
name|fds
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/**      ** This comment is a little out of context here, but it contains      ** some useful information...      ********************************************************************      **      ** The following lines take care of the Logitech MouseMan protocols.      **      ** NOTE: There are different versions of both MouseMan and TrackMan!      **       Hence I add another protocol P_LOGIMAN, which the user can      **       specify as MouseMan in his XF86Config file. This entry was      **       formerly handled as a special case of P_MS. However, people      **       who don't have the middle button problem, can still specify      **       Microsoft and use P_MS.      **      ** By default, these mice should use a 3 byte Microsoft protocol      ** plus a 4th byte for the middle button. However, the mouse might      ** have switched to a different protocol before we use it, so I send      ** the proper sequence just in case.      **      ** NOTE: - all commands to (at least the European) MouseMan have to      **         be sent at 1200 Baud.      **       - each command starts with a '*'.      **       - whenever the MouseMan receives a '*', it will switch back      **	 to 1200 Baud. Hence I have to select the desired protocol      **	 first, then select the baud rate.      **      ** The protocols supported by the (European) MouseMan are:      **   -  5 byte packed binary protocol, as with the Mouse Systems      **      mouse. Selected by sequence "*U".      **   -  2 button 3 byte MicroSoft compatible protocol. Selected      **      by sequence "*V".      **   -  3 button 3+1 byte MicroSoft compatible protocol (default).      **      Selected by sequence "*X".      **      ** The following baud rates are supported:      **   -  1200 Baud (default). Selected by sequence "*n".      **   -  9600 Baud. Selected by sequence "*q".      **      ** Selecting a sample rate is no longer supported with the MouseMan!      ** Some additional lines in xf86Config.c take care of ill configured      ** baud rates and sample rates. (The user will get an error.)      */
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|MOUSE_PROTO_LOGI
case|:
comment|/* 	 * The baud rate selection command must be sent at the current 	 * baud rate; try all likely settings 	 */
name|setmousespeed
argument_list|(
literal|9600
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|4800
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|2400
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* select MM series data format */
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|MOUSE_PROTO_MM
index|]
argument_list|)
expr_stmt|;
comment|/* select report rate/frequency */
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|0
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"O"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|15
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"J"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|27
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"K"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|42
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"L"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|60
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|85
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"M"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|125
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"Q"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_LOGIMOUSEMAN
case|:
comment|/* The command must always be sent at 1200 baud */
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
literal|1200
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"*X"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_HITTAB
case|:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Hitachi PUMA Plus - Model 1212E to desired settings. 	 * The tablet must be configured to be in MM mode, NO parity, 	 * Binary Format.  xf86Info.sampleRate controls the sensativity 	 * of the tablet.  We only use this tablet for it's 4-button puck 	 * so we don't run in "Absolute Mode" 	 */
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"z8"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Parity = "NONE" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"zb"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Format = "Binary" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Report Mode = "Stream" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Output Rate = "45 rps" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"I\x20"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Incrememtal Mode "20" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"E"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Data Type = "Relative */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* Resolution is in 'lines per inch' on the Hitachi tablet */
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_LOW
condition|)
name|c
operator|=
literal|'g'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_MEDIUMLOW
condition|)
name|c
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_MEDIUMHIGH
condition|)
name|c
operator|=
literal|'h'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_HIGH
condition|)
name|c
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|40
condition|)
name|c
operator|=
literal|'g'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|100
condition|)
name|c
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|200
condition|)
name|c
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|500
condition|)
name|c
operator|=
literal|'h'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|1000
condition|)
name|c
operator|=
literal|'j'
expr_stmt|;
else|else
name|c
operator|=
literal|'d'
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"\021"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Resume DATA output */
break|break;
case|case
name|MOUSE_PROTO_THINK
case|:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* the PnP ID string may be sent again, discard it */
name|usleep
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* send the command to initialize the beast */
for|for
control|(
name|s
operator|=
literal|"E5E5"
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
block|{
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|*
name|s
condition|)
break|break;
block|}
break|break;
case|case
name|MOUSE_PROTO_JOGDIAL
case|:
break|break;
case|case
name|MOUSE_PROTO_MSC
case|:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ClearDTR
condition|)
block|{
name|i
operator|=
name|TIOCM_DTR
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ClearRTS
condition|)
block|{
name|i
operator|=
name|TIOCM_RTS
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_PROTO_SYSMOUSE
case|:
if|if
condition|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
operator|==
name|MOUSE_IF_SYSMOUSE
condition|)
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MOUSE_PROTO_BUS
case|:
case|case
name|MOUSE_PROTO_INPORT
case|:
case|case
name|MOUSE_PROTO_PS2
case|:
if|if
condition|(
name|rodent
operator|.
name|rate
operator|>=
literal|0
condition|)
name|rodent
operator|.
name|mode
operator|.
name|rate
operator|=
name|rodent
operator|.
name|rate
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|!=
name|MOUSE_RES_UNKNOWN
condition|)
name|rodent
operator|.
name|mode
operator|.
name|resolution
operator|=
name|rodent
operator|.
name|resolution
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_SETMODE
argument_list|,
operator|&
name|rodent
operator|.
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_X10MOUSEREM
case|:
name|mremote_serversetup
argument_list|()
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_VERSAPAD
case|:
name|tcsendbreak
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send break for 400 msec */
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
operator|++
name|i
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'V'
operator|)
operator|||
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|'P'
operator|)
operator|||
operator|(
name|buf
index|[
literal|7
index|]
operator|!=
literal|'\r'
operator|)
condition|)
break|break;
name|setmousespeed
argument_list|(
literal|9600
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|tcsendbreak
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send break for 400 msec again */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
operator|++
name|i
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|buf
index|[
name|i
index|]
condition|)
break|break;
block|}
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|r_protocol
parameter_list|(
name|u_char
name|rBuf
parameter_list|,
name|mousestatus_t
modifier|*
name|act
parameter_list|)
block|{
comment|/* MOUSE_MSS_BUTTON?DOWN -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapmss
index|[
literal|4
index|]
init|=
block|{
comment|/* Microsoft, MouseMan, GlidePoint, 				   IntelliMouse, Thinking Mouse */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,     }
decl_stmt|;
specifier|static
name|int
name|butmapmss2
index|[
literal|4
index|]
init|=
block|{
comment|/* Microsoft, MouseMan, GlidePoint, 				    Thinking Mouse */
literal|0
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON4DOWN
block|,     }
decl_stmt|;
comment|/* MOUSE_INTELLI_BUTTON?DOWN -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapintelli
index|[
literal|4
index|]
init|=
block|{
comment|/* IntelliMouse, NetMouse, Mie Mouse, 				       MouseMan+ */
literal|0
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON4DOWN
block|,     }
decl_stmt|;
comment|/* MOUSE_MSC_BUTTON?UP -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapmsc
index|[
literal|8
index|]
init|=
block|{
comment|/* MouseSystems, MMSeries, Logitech, 				   Bus, sysmouse */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
comment|/* MOUSE_PS2_BUTTON?DOWN -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapps2
index|[
literal|8
index|]
init|=
block|{
comment|/* PS/2 */
literal|0
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
comment|/* for Hitachi tablet */
specifier|static
name|int
name|butmaphit
index|[
literal|8
index|]
init|=
block|{
comment|/* MM HitTablet */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON5DOWN
block|,
name|MOUSE_BUTTON6DOWN
block|,
name|MOUSE_BUTTON7DOWN
block|,     }
decl_stmt|;
comment|/* for serial VersaPad */
specifier|static
name|int
name|butmapversa
index|[
literal|8
index|]
init|=
block|{
comment|/* VersaPad */
literal|0
block|,
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,     }
decl_stmt|;
comment|/* for PS/2 VersaPad */
specifier|static
name|int
name|butmapversaps2
index|[
literal|8
index|]
init|=
block|{
comment|/* VersaPad */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,     }
decl_stmt|;
specifier|static
name|int
name|pBufP
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pBuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
name|int
name|prev_x
decl_stmt|,
name|prev_y
decl_stmt|;
specifier|static
name|int
name|on
init|=
name|FALSE
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|debug
argument_list|(
literal|"received char 0x%x"
argument_list|,
operator|(
name|int
operator|)
name|rBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_KIDSPAD
condition|)
return|return
name|kidspad
argument_list|(
name|rBuf
argument_list|,
name|act
argument_list|)
return|;
comment|/*      * Hack for resyncing: We check here for a package that is:      *  a) illegal (detected by wrong data-package header)      *  b) invalid (0x80 == -128 and that might be wrong for MouseSystems)      *  c) bad header-package      *      * NOTE: b) is a voilation of the MouseSystems-Protocol, since values of      *       -128 are allowed, but since they are very seldom we can easily      *       use them as package-header with no button pressed.      * NOTE/2: On a PS/2 mouse any byte is valid as a data byte. Furthermore,      *         0x80 is not valid as a header byte. For a PS/2 mouse we skip      *         checking data bytes.      *         For resyncing a PS/2 mouse we require the two most significant      *         bits in the header byte to be 0. These are the overflow bits,      *         and in case of an overflow we actually lose sync. Overflows      *         are very rare, however, and we quickly gain sync again after      *         an overflow condition. This is the best we can do. (Actually,      *         we could use bit 0x08 in the header byte for resyncing, since      *         that bit is supposed to be always on, but nobody told      *         Microsoft...)      */
if|if
condition|(
name|pBufP
operator|!=
literal|0
operator|&&
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_PS2
operator|&&
operator|(
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|2
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|3
index|]
operator|||
name|rBuf
operator|==
literal|0x80
operator|)
condition|)
block|{
name|pBufP
operator|=
literal|0
expr_stmt|;
comment|/* skip package */
block|}
if|if
condition|(
name|pBufP
operator|==
literal|0
operator|&&
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|0
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* is there an extra data byte? */
if|if
condition|(
name|pBufP
operator|>=
name|cur_proto
index|[
literal|4
index|]
operator|&&
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|0
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|1
index|]
condition|)
block|{
comment|/* 	 * Hack for Logitech MouseMan Mouse - Middle button 	 * 	 * Unfortunately this mouse has variable length packets: the standard 	 * Microsoft 3 byte packet plus an optional 4th byte whenever the 	 * middle button status changes. 	 * 	 * We have already processed the standard packet with the movement 	 * and button info.  Now post an event message with the old status 	 * of the left and right buttons and the updated middle button. 	 */
comment|/* 	 * Even worse, different MouseMen and TrackMen differ in the 4th 	 * byte: some will send 0x00/0x20, others 0x01/0x21, or even 	 * 0x02/0x22, so I have to strip off the lower bits. 	 * 	 * [JCH-96/01/21] 	 * HACK for ALPS "fourth button". (It's bit 0x10 of the "fourth byte" 	 * and it is activated by tapping the glidepad with the finger! 8^) 	 * We map it to bit bit3, and the reverse map in xf86Events just has 	 * to be extended so that it is identified as Button 4. The lower 	 * half of the reverse-map may remain unchanged. 	 */
comment|/* 	 * [KY-97/08/03] 	 * Receive the fourth byte only when preceding three bytes have 	 * been detected (pBufP>= cur_proto[4]).  In the previous 	 * versions, the test was pBufP == 0; thus, we may have mistakingly 	 * received a byte even if we didn't see anything preceding 	 * the byte. 	 */
if|if
condition|(
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|5
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|6
index|]
condition|)
block|{
name|pBufP
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
if|#
directive|if
name|notyet
case|case
name|MOUSE_PROTO_MARIQUA
case|:
comment|/* 	     * This mouse has 16! buttons in addition to the standard 	     * three of them.  They return 0x10 though 0x1f in the 	     * so-called `ten key' mode and 0x30 though 0x3f in the 	     * `function key' mode.  As there are only 31 bits for 	     * button state (including the standard three), we ignore 	     * the bit 0x20 and don't distinguish the two modes. 	     */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|rBuf
operator|&=
literal|0x1f
expr_stmt|;
name|act
operator|->
name|button
operator|=
operator|(
literal|1
operator|<<
operator|(
name|rBuf
operator|-
literal|13
operator|)
operator|)
operator||
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
expr_stmt|;
comment|/* 	     * FIXME: this is a button "down" event. There needs to be 	     * a corresponding button "up" event... XXX 	     */
break|break;
endif|#
directive|endif
comment|/* notyet */
case|case
name|MOUSE_PROTO_JOGDIAL
case|:
break|break;
comment|/* 	 * IntelliMouse, NetMouse (including NetMouse Pro) and Mie Mouse 	 * always send the fourth byte, whereas the fourth byte is 	 * optional for GlidePoint and ThinkingMouse. The fourth byte 	 * is also optional for MouseMan+ and FirstMouse+ in their 	 * native mode. It is always sent if they are in the IntelliMouse 	 * compatible mode. 	 */
case|case
name|MOUSE_PROTO_INTELLI
case|:
comment|/* IntelliMouse, NetMouse, Mie Mouse, 					   MouseMan+ */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|dz
operator|=
operator|(
name|rBuf
operator|&
literal|0x08
operator|)
condition|?
operator|(
name|rBuf
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|rBuf
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|act
operator|->
name|dz
operator|>=
literal|7
operator|)
operator|||
operator|(
name|act
operator|->
name|dz
operator|<=
operator|-
literal|7
operator|)
condition|)
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|act
operator|->
name|button
operator|=
name|butmapintelli
index|[
operator|(
name|rBuf
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
operator||
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|act
operator|->
name|button
operator|=
name|butmapmss2
index|[
operator|(
name|rBuf
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
operator||
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|act
operator|->
name|flags
operator|=
operator|(
operator|(
name|act
operator|->
name|dx
operator|||
name|act
operator|->
name|dy
operator|||
name|act
operator|->
name|dz
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|act
operator|->
name|obutton
operator|^
name|act
operator|->
name|button
operator|)
expr_stmt|;
name|pBufP
operator|=
literal|0
expr_stmt|;
return|return
name|act
operator|->
name|flags
return|;
block|}
if|if
condition|(
name|pBufP
operator|>=
name|cur_proto
index|[
literal|4
index|]
condition|)
name|pBufP
operator|=
literal|0
expr_stmt|;
name|pBuf
index|[
name|pBufP
operator|++
index|]
operator|=
name|rBuf
expr_stmt|;
if|if
condition|(
name|pBufP
operator|!=
name|cur_proto
index|[
literal|4
index|]
condition|)
return|return
literal|0
return|;
comment|/*      * assembly full package      */
name|debug
argument_list|(
literal|"assembled full packet (len %d) %x,%x,%x,%x,%x,%x,%x,%x"
argument_list|,
name|cur_proto
index|[
literal|4
index|]
argument_list|,
name|pBuf
index|[
literal|0
index|]
argument_list|,
name|pBuf
index|[
literal|1
index|]
argument_list|,
name|pBuf
index|[
literal|2
index|]
argument_list|,
name|pBuf
index|[
literal|3
index|]
argument_list|,
name|pBuf
index|[
literal|4
index|]
argument_list|,
name|pBuf
index|[
literal|5
index|]
argument_list|,
name|pBuf
index|[
literal|6
index|]
argument_list|,
name|pBuf
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|MOUSE_PROTO_MS
case|:
comment|/* Microsoft */
case|case
name|MOUSE_PROTO_LOGIMOUSEMAN
case|:
comment|/* MouseMan/TrackMan */
case|case
name|MOUSE_PROTO_X10MOUSEREM
case|:
comment|/* X10 MouseRemote */
name|act
operator|->
name|button
operator|=
name|act
operator|->
name|obutton
operator|&
name|MOUSE_BUTTON4DOWN
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ChordMiddle
condition|)
name|act
operator|->
name|button
operator||=
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|==
name|MOUSE_MSS_BUTTONS
operator|)
condition|?
name|MOUSE_BUTTON2DOWN
else|:
name|butmapmss
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
else|else
name|act
operator|->
name|button
operator||=
operator|(
name|act
operator|->
name|obutton
operator|&
name|MOUSE_BUTTON2DOWN
operator|)
operator||
name|butmapmss
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* Send X10 btn events to remote client (ensure -128-+127 range) */
if|if
condition|(
operator|(
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_X10MOUSEREM
operator|)
operator|&&
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0xFC
operator|)
operator|==
literal|0x44
operator|)
operator|&&
operator|(
name|pBuf
index|[
literal|2
index|]
operator|==
literal|0x3F
operator|)
condition|)
block|{
if|if
condition|(
name|rodent
operator|.
name|mremcfd
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|char
name|key
init|=
call|(
name|signed
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mremcfd
argument_list|,
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|act
operator|->
name|dx
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x0C
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_GLIDEPOINT
case|:
comment|/* GlidePoint */
case|case
name|MOUSE_PROTO_THINK
case|:
comment|/* ThinkingMouse */
case|case
name|MOUSE_PROTO_INTELLI
case|:
comment|/* IntelliMouse, NetMouse, Mie Mouse, 					   MouseMan+ */
name|act
operator|->
name|button
operator|=
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON4DOWN
operator|)
operator|)
operator||
name|butmapmss
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x0C
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MSC
case|:
comment|/* MouseSystems Corp */
if|#
directive|if
name|notyet
case|case
name|MOUSE_PROTO_MARIQUA
case|:
comment|/* Mariqua */
endif|#
directive|endif
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
name|MOUSE_MSC_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|1
index|]
argument_list|)
operator|+
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|-
operator|(
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|2
index|]
argument_list|)
operator|+
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|4
index|]
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_JOGDIAL
case|:
comment|/* JogDial */
if|if
condition|(
name|rBuf
operator|==
literal|0x6c
condition|)
name|act
operator|->
name|dz
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rBuf
operator|==
literal|0x72
condition|)
name|act
operator|->
name|dz
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rBuf
operator|==
literal|0x64
condition|)
name|act
operator|->
name|button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
if|if
condition|(
name|rBuf
operator|==
literal|0x75
condition|)
name|act
operator|->
name|button
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_HITTAB
case|:
comment|/* MM HitTablet */
name|act
operator|->
name|button
operator|=
name|butmaphit
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x07
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_XPOSITIVE
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_YPOSITIVE
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MM
case|:
comment|/* MM Series */
case|case
name|MOUSE_PROTO_LOGI
case|:
comment|/* Logitech Mice */
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSC_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_XPOSITIVE
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_YPOSITIVE
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_VERSAPAD
case|:
comment|/* VersaPad */
name|act
operator|->
name|button
operator|=
name|butmapversa
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_VERSA_BUTTONS
operator|)
operator|>>
literal|3
index|]
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_VERSA_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_VERSA_IN_USE
operator|)
condition|)
block|{
name|on
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|x
operator|=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|<<
literal|6
operator|)
operator||
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x800
condition|)
name|x
operator|-=
literal|0x1000
expr_stmt|;
name|y
operator|=
operator|(
name|pBuf
index|[
literal|4
index|]
operator|<<
literal|6
operator|)
operator||
name|pBuf
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|y
operator|&
literal|0x800
condition|)
name|y
operator|-=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|act
operator|->
name|dx
operator|=
name|prev_x
operator|-
name|x
expr_stmt|;
name|act
operator|->
name|dy
operator|=
name|prev_y
operator|-
name|y
expr_stmt|;
block|}
else|else
block|{
name|on
operator|=
name|TRUE
expr_stmt|;
block|}
name|prev_x
operator|=
name|x
expr_stmt|;
name|prev_y
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_BUS
case|:
comment|/* Bus */
case|case
name|MOUSE_PROTO_INPORT
case|:
comment|/* InPort */
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
name|MOUSE_MSC_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|signed
name|char
operator|)
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|-
operator|(
name|signed
name|char
operator|)
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_PS2
case|:
comment|/* PS/2 */
name|act
operator|->
name|button
operator|=
name|butmapps2
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
operator|-
operator|(
name|pBuf
index|[
literal|2
index|]
operator|-
literal|256
operator|)
else|:
operator|-
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Moused usually operates the psm driver at the operation level 1 	 * which sends mouse data in MOUSE_PROTO_SYSMOUSE protocol. 	 * The following code takes effect only when the user explicitly 	 * requets the level 2 at which wheel movement and additional button 	 * actions are encoded in model-dependent formats. At the level 0 	 * the following code is no-op because the psm driver says the model 	 * is MOUSE_MODEL_GENERIC. 	 */
switch|switch
condition|(
name|rodent
operator|.
name|hw
operator|.
name|model
condition|)
block|{
case|case
name|MOUSE_MODEL_EXPLORER
case|:
comment|/* wheel and additional button data is in the fourth byte */
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_ZNEG
operator|)
condition|?
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_EXPLORER_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_INTELLI
case|:
case|case
name|MOUSE_MODEL_NET
case|:
comment|/* wheel data is in the fourth byte */
name|act
operator|->
name|dz
operator|=
operator|(
name|signed
name|char
operator|)
name|pBuf
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|act
operator|->
name|dz
operator|>=
literal|7
operator|)
operator|||
operator|(
name|act
operator|->
name|dz
operator|<=
operator|-
literal|7
operator|)
condition|)
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
comment|/* some compatible mice may have additional buttons */
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2INTELLI_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2INTELLI_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_MOUSEMANPLUS
case|:
if|if
condition|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2PLUS_SYNCMASK
operator|)
operator|==
name|MOUSE_PS2PLUS_SYNC
operator|)
operator|&&
operator|(
name|abs
argument_list|(
name|act
operator|->
name|dx
argument_list|)
operator|>
literal|191
operator|)
operator|&&
name|MOUSE_PS2PLUS_CHECKBITS
argument_list|(
name|pBuf
argument_list|)
condition|)
block|{
comment|/* the extended data packet encodes button and wheel events */
switch|switch
condition|(
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|pBuf
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* wheel data packet */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x80
condition|)
block|{
comment|/* horizontal roller count - ignore it XXX*/
block|}
else|else
block|{
comment|/* vertical roller count */
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_ZNEG
operator|)
condition|?
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON5DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* this packet type is reserved by Logitech */
comment|/* 		     * IBM ScrollPoint Mouse uses this packet type to 		     * encode both vertical and horizontal scroll movement. 		     */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
comment|/* horizontal roller count */
if|if
condition|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x0f
condition|)
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_SPOINT_WNEG
operator|)
condition|?
operator|-
literal|2
else|:
literal|2
expr_stmt|;
comment|/* vertical roller count */
if|if
condition|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0xf0
condition|)
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_SPOINT_ZNEG
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* vertical roller count */
block|act->dz = (pBuf[2]& MOUSE_SPOINT_ZNEG) 			? ((pBuf[2]>> 4)& 0x0f) - 16 			: ((pBuf[2]>> 4)& 0x0f);
comment|/* horizontal roller count */
block|act->dw = (pBuf[2]& MOUSE_SPOINT_WNEG) 			? (pBuf[2]& 0x0f) - 16 : (pBuf[2]& 0x0f);
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
comment|/* device type packet - shouldn't happen */
comment|/* FALLTHROUGH */
default|default:
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|button
operator|=
name|act
operator|->
name|obutton
expr_stmt|;
name|debug
argument_list|(
literal|"unknown PS2++ packet type %d: 0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|MOUSE_PS2PLUS_PACKET_TYPE
argument_list|(
name|pBuf
argument_list|)
argument_list|,
name|pBuf
index|[
literal|0
index|]
argument_list|,
name|pBuf
index|[
literal|1
index|]
argument_list|,
name|pBuf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* preserve button states */
name|act
operator|->
name|button
operator||=
name|act
operator|->
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_GLIDEPOINT
case|:
comment|/* `tapping' action */
name|act
operator|->
name|button
operator||=
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_NETSCROLL
case|:
comment|/* three addtional bytes encode buttons and wheel events */
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON3DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON1DOWN
operator|)
condition|?
name|MOUSE_BUTTON5DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pBuf
index|[
literal|4
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_THINK
case|:
comment|/* the fourth button state in the first byte */
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_VERSAPAD
case|:
name|act
operator|->
name|button
operator|=
name|butmapversaps2
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2VERSA_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2VERSA_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2VERSA_IN_USE
operator|)
condition|)
block|{
name|on
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|x
operator|=
operator|(
operator|(
name|pBuf
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xf00
operator|)
operator||
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x800
condition|)
name|x
operator|-=
literal|0x1000
expr_stmt|;
name|y
operator|=
operator|(
operator|(
name|pBuf
index|[
literal|4
index|]
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
operator||
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|y
operator|&
literal|0x800
condition|)
name|y
operator|-=
literal|0x1000
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|act
operator|->
name|dx
operator|=
name|prev_x
operator|-
name|x
expr_stmt|;
name|act
operator|->
name|dy
operator|=
name|prev_y
operator|-
name|y
expr_stmt|;
block|}
else|else
block|{
name|on
operator|=
name|TRUE
expr_stmt|;
block|}
name|prev_x
operator|=
name|x
expr_stmt|;
name|prev_y
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_4D
case|:
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x80
operator|)
condition|?
operator|-
operator|(
name|pBuf
index|[
literal|2
index|]
operator|-
literal|256
operator|)
else|:
operator|-
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_4D_WHEELBITS
condition|)
block|{
case|case
literal|0x10
case|:
name|act
operator|->
name|dz
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|act
operator|->
name|dz
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
comment|/* 2nd wheel rolling right XXX */
name|act
operator|->
name|dz
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
comment|/* 2nd wheel rolling left XXX */
name|act
operator|->
name|dz
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_MODEL_4DPLUS
case|:
if|if
condition|(
operator|(
name|act
operator|->
name|dx
operator|<
literal|16
operator|-
literal|256
operator|)
operator|&&
operator|(
name|act
operator|->
name|dy
operator|>
literal|256
operator|-
literal|16
operator|)
condition|)
block|{
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_4DPLUS_BUTTON4DOWN
condition|)
name|act
operator|->
name|button
operator||=
name|MOUSE_BUTTON4DOWN
expr_stmt|;
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_4DPLUS_ZNEG
operator|)
condition|?
operator|(
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x07
operator|)
operator|-
literal|8
operator|)
else|:
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* preserve previous button states */
name|act
operator|->
name|button
operator||=
name|act
operator|->
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_GENERIC
case|:
default|default:
break|break;
block|}
break|break;
case|case
name|MOUSE_PROTO_SYSMOUSE
case|:
comment|/* sysmouse */
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
name|MOUSE_SYS_STDBUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|1
index|]
argument_list|)
operator|+
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|-
operator|(
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|2
index|]
argument_list|)
operator|+
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|4
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|act
operator|->
name|dz
operator|=
operator|(
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|5
index|]
operator|<<
literal|1
argument_list|)
operator|+
call|(
name|signed
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|6
index|]
operator|<<
literal|1
argument_list|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
operator|(
operator|~
name|pBuf
index|[
literal|7
index|]
operator|&
name|MOUSE_SYS_EXTBUTTONS
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/*      * We don't reset pBufP here yet, as there may be an additional data      * byte in some protocols. See above.      */
comment|/* has something changed? */
name|act
operator|->
name|flags
operator|=
operator|(
operator|(
name|act
operator|->
name|dx
operator|||
name|act
operator|->
name|dy
operator|||
name|act
operator|->
name|dz
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|act
operator|->
name|obutton
operator|^
name|act
operator|->
name|button
operator|)
expr_stmt|;
return|return
name|act
operator|->
name|flags
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|r_statetrans
parameter_list|(
name|mousestatus_t
modifier|*
name|a1
parameter_list|,
name|mousestatus_t
modifier|*
name|a2
parameter_list|,
name|int
name|trans
parameter_list|)
block|{
name|int
name|changed
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|a2
operator|->
name|dx
operator|=
name|a1
operator|->
name|dx
expr_stmt|;
name|a2
operator|->
name|dy
operator|=
name|a1
operator|->
name|dy
expr_stmt|;
name|a2
operator|->
name|dz
operator|=
name|a1
operator|->
name|dz
expr_stmt|;
name|a2
operator|->
name|obutton
operator|=
name|a2
operator|->
name|button
expr_stmt|;
name|a2
operator|->
name|button
operator|=
name|a1
operator|->
name|button
expr_stmt|;
name|a2
operator|->
name|flags
operator|=
name|a1
operator|->
name|flags
expr_stmt|;
name|changed
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|Emulate3Button
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|debug
argument_list|(
literal|"state:%d, trans:%d -> state:%d"
argument_list|,
name|mouse_button_state
argument_list|,
name|trans
argument_list|,
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|s
index|[
name|trans
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Avoid re-ordering button and movement events. While a button 	 * event is deferred, throw away up to BUTTON2_MAXMOVE movement 	 * events to allow for mouse jitter. If more movement events 	 * occur, then complete the deferred button events immediately. 	 */
if|if
condition|(
operator|(
name|a2
operator|->
name|dx
operator|!=
literal|0
operator|||
name|a2
operator|->
name|dy
operator|!=
literal|0
operator|)
operator|&&
name|S_DELAYED
argument_list|(
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|s
index|[
name|trans
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|mouse_move_delayed
operator|>
name|BUTTON2_MAXMOVE
condition|)
block|{
name|mouse_move_delayed
operator|=
literal|0
expr_stmt|;
name|mouse_button_state
operator|=
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|s
index|[
name|A_TIMEOUT
index|]
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|a2
operator|->
name|dx
operator|=
name|a2
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|mouse_move_delayed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mouse_button_state
operator|!=
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|s
index|[
name|trans
index|]
condition|)
name|changed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|changed
condition|)
name|gettimeofday
argument_list|(
operator|&
name|mouse_button_state_tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mouse_button_state
operator|=
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|s
index|[
name|trans
index|]
expr_stmt|;
name|a2
operator|->
name|button
operator|&=
operator|~
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
expr_stmt|;
name|a2
operator|->
name|button
operator|&=
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|mask
expr_stmt|;
name|a2
operator|->
name|button
operator||=
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|buttons
expr_stmt|;
name|flags
operator|=
name|a2
operator|->
name|flags
operator|&
name|MOUSE_POSCHANGED
expr_stmt|;
name|flags
operator||=
name|a2
operator|->
name|obutton
operator|^
name|a2
operator|->
name|button
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MOUSE_BUTTON2DOWN
condition|)
block|{
name|a2
operator|->
name|flags
operator|=
name|flags
operator|&
name|MOUSE_BUTTON2DOWN
expr_stmt|;
name|r_timestamp
argument_list|(
name|a2
argument_list|)
expr_stmt|;
block|}
name|a2
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* phisical to logical button mapping */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p2l
index|[
name|MOUSE_MAXBUTTON
index|]
init|=
block|{
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON5DOWN
block|,
name|MOUSE_BUTTON6DOWN
block|,
name|MOUSE_BUTTON7DOWN
block|,
name|MOUSE_BUTTON8DOWN
block|,
literal|0x00000100
block|,
literal|0x00000200
block|,
literal|0x00000400
block|,
literal|0x00000800
block|,
literal|0x00001000
block|,
literal|0x00002000
block|,
literal|0x00004000
block|,
literal|0x00008000
block|,
literal|0x00010000
block|,
literal|0x00020000
block|,
literal|0x00040000
block|,
literal|0x00080000
block|,
literal|0x00100000
block|,
literal|0x00200000
block|,
literal|0x00400000
block|,
literal|0x00800000
block|,
literal|0x01000000
block|,
literal|0x02000000
block|,
literal|0x04000000
block|,
literal|0x08000000
block|,
literal|0x10000000
block|,
literal|0x20000000
block|,
literal|0x40000000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|skipspace
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|r_installmap
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pbutton
decl_stmt|;
name|int
name|lbutton
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|arg
operator|=
name|skipspace
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|s
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|++
name|arg
expr_stmt|;
name|arg
operator|=
name|skipspace
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|<=
name|s
operator|)
operator|||
operator|(
operator|*
name|arg
operator|!=
literal|'='
operator|)
condition|)
return|return
name|FALSE
return|;
name|lbutton
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|arg
operator|=
name|skipspace
argument_list|(
operator|++
name|arg
argument_list|)
expr_stmt|;
name|s
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|++
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|<=
name|s
operator|)
operator|||
operator|(
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
operator|&&
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|pbutton
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbutton
operator|<=
literal|0
operator|)
operator|||
operator|(
name|lbutton
operator|>
name|MOUSE_MAXBUTTON
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|pbutton
operator|<=
literal|0
operator|)
operator|||
operator|(
name|pbutton
operator|>
name|MOUSE_MAXBUTTON
operator|)
condition|)
return|return
name|FALSE
return|;
name|p2l
index|[
name|pbutton
operator|-
literal|1
index|]
operator|=
literal|1
operator|<<
operator|(
name|lbutton
operator|-
literal|1
operator|)
expr_stmt|;
name|mstate
index|[
name|lbutton
operator|-
literal|1
index|]
operator|=
operator|&
name|bstate
index|[
name|pbutton
operator|-
literal|1
index|]
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_map
parameter_list|(
name|mousestatus_t
modifier|*
name|act1
parameter_list|,
name|mousestatus_t
modifier|*
name|act2
parameter_list|)
block|{
specifier|register
name|int
name|pb
decl_stmt|;
specifier|register
name|int
name|pbuttons
decl_stmt|;
name|int
name|lbuttons
decl_stmt|;
name|pbuttons
operator|=
name|act1
operator|->
name|button
expr_stmt|;
name|lbuttons
operator|=
literal|0
expr_stmt|;
name|act2
operator|->
name|obutton
operator|=
name|act2
operator|->
name|button
expr_stmt|;
if|if
condition|(
name|pbuttons
operator|&
name|rodent
operator|.
name|wmode
condition|)
block|{
name|pbuttons
operator|&=
operator|~
name|rodent
operator|.
name|wmode
expr_stmt|;
name|act1
operator|->
name|dz
operator|=
name|act1
operator|->
name|dy
expr_stmt|;
name|act1
operator|->
name|dx
operator|=
literal|0
expr_stmt|;
name|act1
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
block|}
name|act2
operator|->
name|dx
operator|=
name|act1
operator|->
name|dx
expr_stmt|;
name|act2
operator|->
name|dy
operator|=
name|act1
operator|->
name|dy
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
name|act1
operator|->
name|dz
expr_stmt|;
switch|switch
condition|(
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* do nothing */
break|break;
case|case
name|MOUSE_XAXIS
case|:
if|if
condition|(
name|act1
operator|->
name|dz
operator|!=
literal|0
condition|)
block|{
name|act2
operator|->
name|dx
operator|=
name|act1
operator|->
name|dz
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_YAXIS
case|:
if|if
condition|(
name|act1
operator|->
name|dz
operator|!=
literal|0
condition|)
block|{
name|act2
operator|->
name|dy
operator|=
name|act1
operator|->
name|dz
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
comment|/* buttons */
name|pbuttons
operator|&=
operator|~
operator|(
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
operator||
name|rodent
operator|.
name|zmap
index|[
literal|1
index|]
operator||
name|rodent
operator|.
name|zmap
index|[
literal|2
index|]
operator||
name|rodent
operator|.
name|zmap
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|act1
operator|->
name|dz
operator|<
operator|-
literal|1
operator|)
operator|&&
name|rodent
operator|.
name|zmap
index|[
literal|2
index|]
condition|)
block|{
name|pbuttons
operator||=
name|rodent
operator|.
name|zmap
index|[
literal|2
index|]
expr_stmt|;
name|zstate
index|[
literal|2
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|act1
operator|->
name|dz
operator|<
literal|0
condition|)
block|{
name|pbuttons
operator||=
name|rodent
operator|.
name|zmap
index|[
literal|0
index|]
expr_stmt|;
name|zstate
index|[
literal|0
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|act1
operator|->
name|dz
operator|>
literal|1
operator|)
operator|&&
name|rodent
operator|.
name|zmap
index|[
literal|3
index|]
condition|)
block|{
name|pbuttons
operator||=
name|rodent
operator|.
name|zmap
index|[
literal|3
index|]
expr_stmt|;
name|zstate
index|[
literal|3
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|act1
operator|->
name|dz
operator|>
literal|0
condition|)
block|{
name|pbuttons
operator||=
name|rodent
operator|.
name|zmap
index|[
literal|1
index|]
expr_stmt|;
name|zstate
index|[
literal|1
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|act2
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
name|pb
operator|=
literal|0
init|;
operator|(
name|pb
operator|<
name|MOUSE_MAXBUTTON
operator|)
operator|&&
operator|(
name|pbuttons
operator|!=
literal|0
operator|)
condition|;
operator|++
name|pb
control|)
block|{
name|lbuttons
operator||=
operator|(
name|pbuttons
operator|&
literal|1
operator|)
condition|?
name|p2l
index|[
name|pb
index|]
else|:
literal|0
expr_stmt|;
name|pbuttons
operator|>>=
literal|1
expr_stmt|;
block|}
name|act2
operator|->
name|button
operator|=
name|lbuttons
expr_stmt|;
name|act2
operator|->
name|flags
operator|=
operator|(
operator|(
name|act2
operator|->
name|dx
operator|||
name|act2
operator|->
name|dy
operator|||
name|act2
operator|->
name|dz
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|act2
operator|->
name|obutton
operator|^
name|act2
operator|->
name|button
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_timestamp
parameter_list|(
name|mousestatus_t
modifier|*
name|act
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|;
name|struct
name|timeval
name|tv2
decl_stmt|;
name|struct
name|timeval
name|tv3
decl_stmt|;
name|int
name|button
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
name|act
operator|->
name|flags
operator|&
name|MOUSE_BUTTONS
expr_stmt|;
if|#
directive|if
literal|0
block|if (mask == 0) 	return;
endif|#
directive|endif
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* double click threshold */
name|tv2
operator|.
name|tv_sec
operator|=
name|rodent
operator|.
name|clickthreshold
operator|/
literal|1000
expr_stmt|;
name|tv2
operator|.
name|tv_usec
operator|=
operator|(
name|rodent
operator|.
name|clickthreshold
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"tv:  %ld %ld"
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|,
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* 3 button emulation timeout */
name|tv2
operator|.
name|tv_sec
operator|=
name|rodent
operator|.
name|button2timeout
operator|/
literal|1000
expr_stmt|;
name|tv2
operator|.
name|tv_usec
operator|=
operator|(
name|rodent
operator|.
name|button2timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|,
operator|&
name|tv3
argument_list|)
expr_stmt|;
name|button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MOUSE_MAXBUTTON
operator|)
operator|&&
operator|(
name|mask
operator|!=
literal|0
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|act
operator|->
name|button
operator|&
name|button
condition|)
block|{
comment|/* the button is down */
name|debug
argument_list|(
literal|"  :  %ld %ld"
argument_list|,
name|bstate
index|[
name|i
index|]
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
name|bstate
index|[
name|i
index|]
operator|.
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|bstate
index|[
name|i
index|]
operator|.
name|tv
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|bstate
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
name|bstate
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
name|bstate
index|[
name|i
index|]
operator|.
name|tv
operator|=
name|tv1
expr_stmt|;
block|}
else|else
block|{
comment|/* the button is up */
name|bstate
index|[
name|i
index|]
operator|.
name|tv
operator|=
name|tv1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|act
operator|->
name|button
operator|&
name|button
condition|)
block|{
comment|/* the button has been down */
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|tv3
argument_list|,
operator|&
name|bstate
index|[
name|i
index|]
operator|.
name|tv
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|bstate
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|bstate
index|[
name|i
index|]
operator|.
name|tv
operator|=
name|tv1
expr_stmt|;
name|act
operator|->
name|flags
operator||=
name|button
expr_stmt|;
name|debug
argument_list|(
literal|"button %d timeout"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* the button has been up */
block|}
block|}
name|button
operator|<<=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|r_timeout
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|;
name|struct
name|timeval
name|tv2
decl_stmt|;
if|if
condition|(
name|states
index|[
name|mouse_button_state
index|]
operator|.
name|timeout
condition|)
return|return
name|TRUE
return|;
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tv2
operator|.
name|tv_sec
operator|=
name|rodent
operator|.
name|button2timeout
operator|/
literal|1000
expr_stmt|;
name|tv2
operator|.
name|tv_usec
operator|=
operator|(
name|rodent
operator|.
name|button2timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
name|timercmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|mouse_button_state_tv
argument_list|,
operator|>
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_click
parameter_list|(
name|mousestatus_t
modifier|*
name|act
parameter_list|)
block|{
name|struct
name|mouse_info
name|mouse
decl_stmt|;
name|int
name|button
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
name|act
operator|->
name|flags
operator|&
name|MOUSE_BUTTONS
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return;
name|button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MOUSE_MAXBUTTON
operator|)
operator|&&
operator|(
name|mask
operator|!=
literal|0
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"mstate[%d]->count:%d"
argument_list|,
name|i
argument_list|,
name|mstate
index|[
name|i
index|]
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|button
operator|&
name|button
condition|)
block|{
comment|/* the button is down */
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|value
operator|=
name|mstate
index|[
name|i
index|]
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
comment|/* the button is up */
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_BUTTON_EVENT
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|id
operator|=
name|button
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"button %d  count %d"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|button
operator|<<=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* $XConsortium: posix_tty.c,v 1.3 95/01/05 20:42:55 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/shared/posix_tty.c,v 3.4 1995/01/28 17:05:03 dawes Exp $ */
end_comment

begin_comment
comment|/*  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of David Dawes  * not be used in advertising or publicity pertaining to distribution of  * the software without specific, written prior permission.  * David Dawes makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * DAVID DAWES DISCLAIMS ALL WARRANTIES WITH REGARD TO  * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS, IN NO EVENT SHALL DAVID DAWES BE LIABLE FOR  * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_function
specifier|static
name|void
name|setmousespeed
parameter_list|(
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|,
name|unsigned
name|cflag
parameter_list|)
block|{
name|struct
name|termios
name|tty
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logwarn
argument_list|(
literal|"unable to get status of mouse fd"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tty
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|tty
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_cflag
operator|=
operator|(
name|tcflag_t
operator|)
name|cflag
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|old
condition|)
block|{
case|case
literal|9600
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1200
case|:
default|default:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logwarn
argument_list|(
literal|"unable to set status of mouse fd"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|new
condition|)
block|{
case|case
literal|9600
case|:
name|c
operator|=
literal|"*q"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|c
operator|=
literal|"*p"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|c
operator|=
literal|"*o"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1200
case|:
default|default:
name|c
operator|=
literal|"*n"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_LOGIMOUSEMAN
operator|||
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_LOGI
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|c
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|logwarn
argument_list|(
literal|"unable to write to mouse fd"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
name|logwarn
argument_list|(
literal|"unable to set status of mouse fd"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PnP COM device support  *  * It's a simplistic implementation, but it works :-)  * KY, 31/7/97.  */
end_comment

begin_comment
comment|/*  * Try to elicit a PnP ID as described in  * Microsoft, Hayes: "Plug and Play External COM Device Specification,  * rev 1.00", 1995.  *  * The routine does not fully implement the COM Enumerator as par Section  * 2.1 of the document.  In particular, we don't have idle state in which  * the driver software monitors the com port for dynamic connection or  * removal of a device at the port, because `moused' simply quits if no  * device is found.  *  * In addition, as PnP COM device enumeration procedure slightly has  * changed since its first publication, devices which follow earlier  * revisions of the above spec. may fail to respond if the rev 1.0  * procedure is used. XXX  */
end_comment

begin_function
specifier|static
name|int
name|pnpwakeup1
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * This is the procedure described in rev 1.0 of PnP COM device spec.      * Unfortunately, some devices which comform to earlier revisions of      * the spec gets confused and do not return the ID string...      */
name|debug
argument_list|(
literal|"PnP COM device rev 1.0 probe..."
argument_list|)
expr_stmt|;
comment|/* port initialization (2.1.2) */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator||=
name|TIOCM_DTR
expr_stmt|;
comment|/* DTR = 1 */
name|i
operator|&=
operator|~
name|TIOCM_RTS
expr_stmt|;
comment|/* RTS = 0 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMSET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|240000
argument_list|)
expr_stmt|;
comment|/*      * The PnP COM device spec. dictates that the mouse must set DSR      * in response to DTR (by hardware or by software) and that if DSR is      * not asserted, the host computer should think that there is no device      * at this serial port.  But some mice just don't do that...      */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"modem status 0%o"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|TIOCM_DSR
operator|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* port setup, 1st phase (2.1.3) */
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
literal|1200
argument_list|,
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 0, RTS = 0 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|240000
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIOCM_DTR
expr_stmt|;
comment|/* DTR = 1, RTS = 0 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|240000
argument_list|)
expr_stmt|;
comment|/* wait for response, 1st phase (2.1.4) */
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 1, RTS = 1 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* try to read something */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|240000
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"pnpwakeup1(): valid response in first phase."
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* port setup, 2nd phase (2.1.5) */
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 0, RTS = 0 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|240000
argument_list|)
expr_stmt|;
comment|/* wait for respose, 2nd phase (2.1.6) */
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 1, RTS = 1 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* try to read something */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|240000
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"pnpwakeup1(): valid response in second phase."
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pnpwakeup2
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * This is a simplified procedure; it simply toggles RTS.      */
name|debug
argument_list|(
literal|"alternate probe..."
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator||=
name|TIOCM_DTR
expr_stmt|;
comment|/* DTR = 1 */
name|i
operator|&=
operator|~
name|TIOCM_RTS
expr_stmt|;
comment|/* RTS = 0 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMSET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|240000
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
literal|1200
argument_list|,
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
argument_list|)
expr_stmt|;
comment|/* wait for respose */
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 1, RTS = 1 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* try to read something */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|240000
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"pnpwakeup2(): valid response."
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pnpgets
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|begin
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|pnpwakeup1
argument_list|()
operator|&&
operator|!
name|pnpwakeup2
argument_list|()
condition|)
block|{
comment|/* 	 * According to PnP spec, we should set DTR = 1 and RTS = 0 while 	 * in idle state.  But, `moused' shall set DTR = RTS = 1 and proceed, 	 * assuming there is something at the port even if it didn't 	 * respond to the PnP enumeration procedure. 	 */
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 1, RTS = 1 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* collect PnP COM device ID (2.1.7) */
name|begin
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|usleep
argument_list|(
literal|240000
argument_list|)
expr_stmt|;
comment|/* the mouse must send `Begin ID' within 200msec */
while|while
condition|(
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* we may see "M", or "M3..." before `Begin ID' */
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|0x08
operator|)
operator|||
operator|(
name|c
operator|==
literal|0x28
operator|)
condition|)
block|{
comment|/* Begin ID */
name|debug
argument_list|(
literal|"begin-id %02x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|begin
operator|=
name|i
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|debug
argument_list|(
literal|"%c %02x"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
condition|)
break|break;
block|}
if|if
condition|(
name|begin
operator|<
literal|0
condition|)
block|{
comment|/* we haven't seen `Begin ID' in time... */
goto|goto
name|connect_idle
goto|;
block|}
operator|++
name|c
expr_stmt|;
comment|/* make it `End ID' */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|240000
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|++
index|]
operator|==
name|c
condition|)
comment|/* End ID */
break|break;
if|if
condition|(
name|i
operator|>=
literal|256
condition|)
break|break;
block|}
if|if
condition|(
name|begin
operator|>
literal|0
condition|)
block|{
name|i
operator|-=
name|begin
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|buf
index|[
name|begin
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* string may not be human readable... */
name|debug
argument_list|(
literal|"len:%d, '%-*.*s'"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|c
condition|)
return|return
name|i
return|;
comment|/* a valid PnP string */
comment|/*      * According to PnP spec, we should set DTR = 1 and RTS = 0 while      * in idle state.  But, `moused' shall leave the modem control lines      * as they are. See above.      */
name|connect_idle
label|:
comment|/* we may still have something in the buffer */
return|return
operator|(
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pnpparse
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|s
index|[
literal|3
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|id
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|eisaid
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|serial
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|class
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|compat
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|description
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|neisaid
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|nserial
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|nclass
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|ncompat
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|ndescription
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|0x28
operator|)
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|0x08
operator|)
condition|)
block|{
comment|/* non-PnP mice */
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|'M'
case|:
comment|/* Microsoft */
name|id
operator|->
name|eisaid
operator|=
literal|"PNP0F01"
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* MouseSystems */
name|id
operator|->
name|eisaid
operator|=
literal|"PNP0F04"
expr_stmt|;
break|break;
block|}
name|id
operator|->
name|neisaid
operator|=
name|strlen
argument_list|(
name|id
operator|->
name|eisaid
argument_list|)
expr_stmt|;
name|id
operator|->
name|class
operator|=
literal|"MOUSE"
expr_stmt|;
name|id
operator|->
name|nclass
operator|=
name|strlen
argument_list|(
name|id
operator|->
name|class
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"non-PnP mouse '%c'"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* PnP mice */
name|offset
operator|=
literal|0x28
operator|-
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* calculate checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|+=
name|offset
expr_stmt|;
block|}
name|sum
operator|+=
name|buf
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|+=
name|offset
expr_stmt|;
name|debug
argument_list|(
literal|"PnP ID string: '%*.*s'"
argument_list|,
name|len
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* revision */
name|buf
index|[
literal|1
index|]
operator|-=
name|offset
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|-=
name|offset
expr_stmt|;
name|id
operator|->
name|revision
operator|=
operator|(
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|"PnP rev %d.%02d"
argument_list|,
name|id
operator|->
name|revision
operator|/
literal|100
argument_list|,
name|id
operator|->
name|revision
operator|%
literal|100
argument_list|)
expr_stmt|;
comment|/* EISA vender and product ID */
name|id
operator|->
name|eisaid
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|id
operator|->
name|neisaid
operator|=
literal|7
expr_stmt|;
comment|/* option strings */
name|i
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* device serial # */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|-
name|j
operator|==
literal|8
condition|)
block|{
name|id
operator|->
name|serial
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|nserial
operator|=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* PnP class */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|id
operator|->
name|class
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|nclass
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* compatible driver */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
comment|/* 	 * PnP COM spec prior to v0.96 allowed '*' in this field, 	 * it's not allowed now; just igore it. 	 */
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|==
literal|'*'
condition|)
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|id
operator|->
name|compat
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|ncompat
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* product description */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|';'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|id
operator|->
name|description
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|ndescription
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
block|}
comment|/* checksum exists if there are any optional fields */
if|if
condition|(
operator|(
name|id
operator|->
name|nserial
operator|>
literal|0
operator|)
operator|||
operator|(
name|id
operator|->
name|nclass
operator|>
literal|0
operator|)
operator|||
operator|(
name|id
operator|->
name|ncompat
operator|>
literal|0
operator|)
operator|||
operator|(
name|id
operator|->
name|ndescription
operator|>
literal|0
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|"PnP checksum: 0x%X"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%02X"
argument_list|,
name|sum
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
operator|&
name|buf
index|[
name|len
operator|-
literal|3
index|]
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 	     * I found some mice do not comply with the PnP COM device 	     * spec regarding checksum... XXX 	     */
block|logwarnx("PnP checksum error", 0); 	    return FALSE;
endif|#
directive|endif
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|symtab_t
modifier|*
name|pnpproto
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|)
block|{
name|symtab_t
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|nclass
operator|>
literal|0
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|id
operator|->
name|class
argument_list|,
literal|"MOUSE"
argument_list|,
name|id
operator|->
name|nclass
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|id
operator|->
name|class
argument_list|,
literal|"TABLET"
argument_list|,
name|id
operator|->
name|nclass
argument_list|)
operator|!=
literal|0
condition|)
comment|/* this is not a mouse! */
return|return
name|NULL
return|;
if|if
condition|(
name|id
operator|->
name|neisaid
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|gettoken
argument_list|(
name|pnpprod
argument_list|,
name|id
operator|->
name|eisaid
argument_list|,
name|id
operator|->
name|neisaid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|val
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
return|return
name|t
return|;
block|}
comment|/*      * The 'Compatible drivers' field may contain more than one      * ID separated by ','.      */
if|if
condition|(
name|id
operator|->
name|ncompat
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|->
name|ncompat
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|id
operator|->
name|compat
index|[
name|i
index|]
operator|!=
literal|','
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|>=
name|id
operator|->
name|ncompat
condition|)
break|break;
if|if
condition|(
name|i
operator|>
name|j
condition|)
block|{
name|t
operator|=
name|gettoken
argument_list|(
name|pnpprod
argument_list|,
name|id
operator|->
name|compat
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|val
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* name/val mapping */
end_comment

begin_function
specifier|static
name|symtab_t
modifier|*
name|gettoken
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|&
name|tab
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gettokenname
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tab
index|[
name|i
index|]
operator|.
name|val
operator|==
name|val
condition|)
return|return
name|tab
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * code to read from the Genius Kidspad tablet.  The tablet responds to the COM PnP protocol 1.0 with EISA-ID KYE0005, and to pre-pnp probes (RTS toggle) with 'T' (tablet ?) 9600, 8 bit, parity odd.  The tablet puts out 5 bytes. b0 (mask 0xb8, value 0xb8) contains the proximity, tip and button info:    (byte0& 0x1)	true = tip pressed    (byte0& 0x2)	true = button pressed    (byte0& 0x40)	false = pen in proximity of tablet.  The next 4 bytes are used for coordinates xl, xh, yl, yh (7 bits valid).  Only absolute coordinates are returned, so we use the following approach: we store the last coordinates sent when the pen went out of the tablet,    *  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|S_IDLE
block|,
name|S_PROXY
block|,
name|S_FIRST
block|,
name|S_DOWN
block|,
name|S_UP
block|}
name|k_status
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|kidspad
parameter_list|(
name|u_char
name|rxc
parameter_list|,
name|mousestatus_t
modifier|*
name|act
parameter_list|)
block|{
specifier|static
name|int
name|buf
index|[
literal|5
index|]
decl_stmt|;
specifier|static
name|int
name|buflen
init|=
literal|0
decl_stmt|,
name|b_prev
init|=
literal|0
decl_stmt|,
name|x_prev
init|=
operator|-
literal|1
decl_stmt|,
name|y_prev
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|k_status
name|status
init|=
name|S_IDLE
decl_stmt|;
specifier|static
name|struct
name|timeval
name|old
decl_stmt|,
name|now
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|buflen
operator|>
literal|0
operator|&&
operator|(
name|rxc
operator|&
literal|0x80
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid code %d 0x%x\n"
argument_list|,
name|buflen
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|buflen
operator|==
literal|0
operator|&&
operator|(
name|rxc
operator|&
literal|0xb8
operator|)
operator|!=
literal|0xb8
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid code 0 0x%x\n"
argument_list|,
name|rxc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* invalid code, no action */
block|}
name|buf
index|[
name|buflen
operator|++
index|]
operator|=
name|rxc
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|5
condition|)
return|return
literal|0
return|;
name|buflen
operator|=
literal|0
expr_stmt|;
comment|/* for next time... */
name|x
operator|=
name|buf
index|[
literal|1
index|]
operator|+
literal|128
operator|*
operator|(
name|buf
index|[
literal|2
index|]
operator|-
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
name|y
operator|=
literal|28
operator|*
literal|128
operator|-
operator|(
name|buf
index|[
literal|3
index|]
operator|+
literal|128
operator|*
operator|(
name|buf
index|[
literal|4
index|]
operator|-
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
name|x
operator|/=
literal|8
expr_stmt|;
name|y
operator|/=
literal|8
expr_stmt|;
name|act
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
comment|/* pen went out of reach */
name|status
operator|=
name|S_IDLE
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|S_IDLE
condition|)
block|{
comment|/* pen is newly near the tablet */
name|act
operator|->
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
comment|/* force update */
name|status
operator|=
name|S_PROXY
expr_stmt|;
name|x_prev
operator|=
name|x
expr_stmt|;
name|y_prev
operator|=
name|y
expr_stmt|;
block|}
name|old
operator|=
name|now
expr_stmt|;
name|act
operator|->
name|dx
operator|=
name|x
operator|-
name|x_prev
expr_stmt|;
name|act
operator|->
name|dy
operator|=
name|y
operator|-
name|y_prev
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|dx
operator|||
name|act
operator|->
name|dy
condition|)
name|act
operator|->
name|flags
operator||=
name|MOUSE_POSCHANGED
expr_stmt|;
name|x_prev
operator|=
name|x
expr_stmt|;
name|y_prev
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|b_prev
operator|!=
literal|0
operator|&&
name|b_prev
operator|!=
name|buf
index|[
literal|0
index|]
condition|)
block|{
comment|/* possibly record button change */
name|act
operator|->
name|button
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
comment|/* tip pressed */
name|act
operator|->
name|button
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x02
condition|)
comment|/* button pressed */
name|act
operator|->
name|button
operator||=
name|MOUSE_BUTTON2DOWN
expr_stmt|;
name|act
operator|->
name|flags
operator||=
name|MOUSE_BUTTONSCHANGED
expr_stmt|;
block|}
name|b_prev
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
return|return
name|act
operator|->
name|flags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mremote_serversetup
parameter_list|()
block|{
name|struct
name|sockaddr_un
name|ad
decl_stmt|;
comment|/* Open a UNIX domain stream socket to listen for mouse remote clients */
name|unlink
argument_list|(
name|_PATH_MOUSEREMOTE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|mremsfd
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|logerrx
argument_list|(
literal|1
argument_list|,
literal|"unable to create unix domain socket %s"
argument_list|,
name|_PATH_MOUSEREMOTE
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|0111
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ad
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|ad
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strcpy
argument_list|(
name|ad
operator|.
name|sun_path
argument_list|,
name|_PATH_MOUSEREMOTE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SUN_LEN
define|#
directive|define
name|SUN_LEN
parameter_list|(
name|unp
parameter_list|)
value|( ((char *)(unp)->sun_path - (char *)(unp)) + \ 		       strlen((unp)->path) )
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|rodent
operator|.
name|mremsfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ad
argument_list|,
name|SUN_LEN
argument_list|(
operator|&
name|ad
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|logerrx
argument_list|(
literal|1
argument_list|,
literal|"unable to bind unix domain socket %s"
argument_list|,
name|_PATH_MOUSEREMOTE
argument_list|)
expr_stmt|;
name|listen
argument_list|(
name|rodent
operator|.
name|mremsfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mremote_clientchg
parameter_list|(
name|int
name|add
parameter_list|)
block|{
name|struct
name|sockaddr_un
name|ad
decl_stmt|;
name|int
name|ad_len
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_X10MOUSEREM
condition|)
return|return;
if|if
condition|(
name|add
condition|)
block|{
comment|/*  Accept client connection, if we don't already have one  */
name|ad_len
operator|=
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|fd
operator|=
name|accept
argument_list|(
name|rodent
operator|.
name|mremsfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ad
argument_list|,
operator|&
name|ad_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|logwarnx
argument_list|(
literal|"failed accept on mouse remote socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|mremcfd
operator|<
literal|0
condition|)
block|{
name|rodent
operator|.
name|mremcfd
operator|=
name|fd
expr_stmt|;
name|debug
argument_list|(
literal|"remote client connect...accepted"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"another remote client connect...disconnected"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Client disconnected */
name|debug
argument_list|(
literal|"remote client disconnected"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rodent
operator|.
name|mremcfd
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mremcfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

end_unit

