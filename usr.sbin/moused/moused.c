begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  ** Copyright (c) 1995 Michael Smith, All rights reserved.  **  ** Redistribution and use in source and binary forms, with or without  ** modification, are permitted provided that the following conditions  ** are met:  ** 1. Redistributions of source code must retain the above copyright  **    notice, this list of conditions and the following disclaimer as  **    the first lines of this file unmodified.  ** 2. Redistributions in binary form must reproduce the above copyright  **    notice, this list of conditions and the following disclaimer in the  **    documentation and/or other materials provided with the distribution.  ** 3. All advertising materials mentioning features or use of this software  **    must display the following acknowledgment:  **      This product includes software developed by Michael Smith.  ** 4. The name of the author may not be used to endorse or promote products  **    derived from this software without specific prior written permission.  **  **  ** THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ANY  ** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  ** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Michael Smith BE LIABLE FOR  ** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  ** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  ** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  ** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  ** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  ** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  ** EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  **  **  **      $Id$  **/
end_comment

begin_comment
comment|/**  ** MOUSED.C  **  ** Mouse daemon : listens to serial port for mouse data stream,  ** interprets same and passes ioctls off to the console driver.  **  ** The mouse interface functions are derived closely from the mouse  ** handler in the XFree86 X server.  Many thanks to the XFree86 people  ** for their great work!  **   **/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|if (debug&&nodaemon) fprintf(stderr,"%s: " fmt "\n", progname, ##args)
end_define

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodaemon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|R_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|R_MICROSOFT
value|1
end_define

begin_define
define|#
directive|define
name|R_MOUSESYS
value|2
end_define

begin_define
define|#
directive|define
name|R_MMSERIES
value|3
end_define

begin_define
define|#
directive|define
name|R_LOGITECH
value|4
end_define

begin_define
define|#
directive|define
name|R_BUSMOUSE
value|5
end_define

begin_define
define|#
directive|define
name|R_LOGIMAN
value|6
end_define

begin_define
define|#
directive|define
name|R_PS_2
value|7
end_define

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
literal|"xxx"
block|,
literal|"microsoft"
block|,
literal|"mousesystems"
block|,
literal|"mmseries"
block|,
literal|"logitech"
block|,
literal|"busmouse"
block|,
literal|"mouseman"
block|,
literal|"ps/2"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|rodentcflags
index|[]
init|=
block|{
literal|0
block|,
comment|/* nomouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MicroSoft */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseSystems */
operator|(
name|CS8
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MMSeries */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Logitech */
literal|0
block|,
comment|/* BusMouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseMan */
literal|0
comment|/* PS/2 */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|buttons
decl_stmt|;
block|}
name|ACTIVITY
typedef|;
end_typedef

begin_struct
struct|struct
name|rodentparam
block|{
name|int
name|baudrate
decl_stmt|,
name|samplerate
decl_stmt|,
name|flags
decl_stmt|,
name|rtype
decl_stmt|,
name|lastbuttons
decl_stmt|,
name|buttons
decl_stmt|,
name|mfd
decl_stmt|;
name|char
modifier|*
name|portname
decl_stmt|;
block|}
name|rodent
init|=
block|{
name|baudrate
operator|:
literal|1200
block|,
name|samplerate
operator|:
literal|0
block|,
name|flags
operator|:
literal|0
block|,
name|rtype
operator|:
name|R_UNKNOWN
block|,
name|lastbuttons
operator|:
literal|0
block|,
name|buttons
operator|:
literal|0
block|,
name|mfd
operator|:
operator|-
literal|1
block|,
name|portname
operator|:
name|NULL
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ChordMiddle
value|1
end_define

begin_function_decl
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ACTIVITY
modifier|*
name|r_protocol
parameter_list|(
name|u_char
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|cfd
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|ACTIVITY
modifier|*
name|act
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|;
name|struct
name|mouse_info
name|mouse
decl_stmt|;
name|int
name|saved_buttons
init|=
literal|0
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cdfsp:t:h?"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ChordMiddle
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|nodaemon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|rodent
operator|.
name|portname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|rodent
operator|.
name|baudrate
operator|=
literal|9600
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'t'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|rnames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"rodent is %s"
argument_list|,
name|rnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|rtype
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rnames
index|[
name|i
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no such mouse type `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|R_BUSMOUSE
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/mse0"
expr_stmt|;
break|break;
case|case
name|R_PS_2
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/psm0"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|rodent
operator|.
name|portname
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No port name specified\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rodent
operator|.
name|mfd
operator|=
name|open
argument_list|(
name|rodent
operator|.
name|portname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s : %s\n"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rodent
operator|.
name|rtype
operator|!=
name|R_PS_2
operator|)
operator|&&
operator|(
name|rodent
operator|.
name|rtype
operator|!=
name|R_BUSMOUSE
operator|)
condition|)
block|{
name|tcgetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|cfsetspeed
argument_list|(
operator|&
name|t
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|)
expr_stmt|;
name|t
operator|.
name|c_cflag
operator|=
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: tcsetattr() failed : %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|r_init
argument_list|()
expr_stmt|;
comment|/* call init function */
if|if
condition|(
operator|(
name|cfd
operator|=
name|open
argument_list|(
literal|"/dev/console"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error on /dev/console\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodaemon
condition|)
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: daemon() failed : %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get a byte */
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
comment|/* read returned or error; goodbye */
block|{
name|debug
argument_list|(
literal|"read returned %d : %s exiting"
argument_list|,
name|i
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|act
operator|=
name|r_protocol
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* pass byte to handler */
if|if
condition|(
name|act
condition|)
comment|/* handler detected action */
block|{
if|if
condition|(
name|act
operator|->
name|buttons
operator|!=
name|saved_buttons
condition|)
block|{
if|if
condition|(
name|act
operator|->
name|buttons
operator|==
literal|0x04
condition|)
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_CUT_START
expr_stmt|;
name|ioctl
argument_list|(
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|->
name|buttons
operator|==
literal|0x00
condition|)
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_CUT_END
expr_stmt|;
name|ioctl
argument_list|(
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|->
name|buttons
operator|==
literal|0x01
condition|)
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_RETURN_CUTBUFFER
expr_stmt|;
name|ioctl
argument_list|(
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
name|saved_buttons
operator|=
name|act
operator|->
name|buttons
expr_stmt|;
block|}
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_MOVEREL
expr_stmt|;
name|mouse
operator|.
name|x
operator|=
name|act
operator|->
name|dx
expr_stmt|;
name|mouse
operator|.
name|y
operator|=
name|act
operator|->
name|dy
expr_stmt|;
name|ioctl
argument_list|(
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Activity : buttons 0x%02x  dx %d  dy %d"
argument_list|,
name|act
operator|->
name|buttons
argument_list|,
name|act
operator|->
name|dx
argument_list|,
name|act
operator|->
name|dy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  ** usage  **  ** Complain, and free the CPU for more worthy tasks  **/
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" Usage is %s [options] -p<port> -t<mousetype>\n"
literal|"  Options are   -s   Select 9600 baud mouse.\n"
literal|"                -f   Don't become a daemon\n"
literal|"                -d   Enable debugging messages\n"
literal|"	             -c   Enable ChordMiddle option\n"
literal|"<mousetype> should be one of :\n"
literal|"                microsoft\n"
literal|"                mousesystems\n"
literal|"                mmseries\n"
literal|"                logitech\n"
literal|"                busmouse\n"
literal|"                mouseman\n"
literal|"                ps/2\n"
literal|"                mmhittab\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** Mouse interface code, courtesy of XFree86 3.1.2.  **  ** Note: Various bits have been trimmed, and in my shortsighted enthusiasm  ** to clean, reformat and rationalise naming, it's quite possible that  ** some things in here have been broken.  **  ** I hope not 8)  **  ** The following code is derived from a module marked :  **/
end_comment

begin_comment
comment|/* $XConsortium: xf86_Mouse.c,v 1.2 94/10/12 20:33:21 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.2 1995/01/28  17:03:40 dawes Exp $ */
end_comment

begin_comment
comment|/*  *  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of Thomas Roell and David Dawes not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  Thomas Roell  * and David Dawes makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * THOMAS ROELL AND DAVID DAWES DISCLAIM ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS, IN NO EVENT SHALL THOMAS ROELL OR DAVID DAWES BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_function
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/**      ** This comment is a little out of context here, but it contains       ** some useful information...      ********************************************************************      **      ** The following lines take care of the Logitech MouseMan protocols.      **      ** NOTE: There are different versions of both MouseMan and TrackMan!      **       Hence I add another protocol P_LOGIMAN, which the user can      **       specify as MouseMan in his XF86Config file. This entry was      **       formerly handled as a special case of P_MS. However, people      **       who don't have the middle button problem, can still specify      **       Microsoft and use P_MS.      **      ** By default, these mice should use a 3 byte Microsoft protocol      ** plus a 4th byte for the middle button. However, the mouse might      ** have switched to a different protocol before we use it, so I send      ** the proper sequence just in case.      **      ** NOTE: - all commands to (at least the European) MouseMan have to      **         be sent at 1200 Baud.      **       - each command starts with a '*'.      **       - whenever the MouseMan receives a '*', it will switch back      **	 to 1200 Baud. Hence I have to select the desired protocol      **	 first, then select the baud rate.      **      ** The protocols supported by the (European) MouseMan are:      **   -  5 byte packed binary protocol, as with the Mouse Systems      **      mouse. Selected by sequence "*U".      **   -  2 button 3 byte MicroSoft compatible protocol. Selected      **      by sequence "*V".      **   -  3 button 3+1 byte MicroSoft compatible protocol (default).      **      Selected by sequence "*X".      **      ** The following baud rates are supported:      **   -  1200 Baud (default). Selected by sequence "*n".      **   -  9600 Baud. Selected by sequence "*q".      **      ** Selecting a sample rate is no longer supported with the MouseMan!      ** Some additional lines in xf86Config.c take care of ill configured      ** baud rates and sample rates. (The user will get an error.)      */
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGIMAN
condition|)
block|{
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"*X"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rodent
operator|.
name|rtype
operator|!=
name|R_BUSMOUSE
operator|)
operator|&&
operator|(
name|rodent
operator|.
name|rtype
operator|!=
name|R_PS_2
operator|)
condition|)
block|{
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGITECH
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/** Support for the Hitachi PUMA Plus tablet not brought through */
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|0
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"O"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|15
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"J"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|27
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"K"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|42
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"L"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|60
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|85
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"M"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|samplerate
operator|<=
literal|125
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"Q"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLEARDTR_SUPPORT
comment|/* XXX find someone to tell me about this */
if|if
condition|(
name|xf86Info
operator|.
name|mseType
operator|==
name|P_MSC
operator|&&
operator|(
name|xf86Info
operator|.
name|mouseFlags
operator|&
name|MF_CLEAR_DTR
operator|)
condition|)
block|{
name|int
name|val
init|=
name|TIOCM_DTR
decl_stmt|;
name|ioctl
argument_list|(
name|xf86Info
operator|.
name|mseFd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xf86Info
operator|.
name|mseType
operator|==
name|P_MSC
operator|&&
operator|(
name|xf86Info
operator|.
name|mouseFlags
operator|&
name|MF_CLEAR_RTS
operator|)
condition|)
block|{
name|int
name|val
init|=
name|TIOCM_RTS
decl_stmt|;
name|ioctl
argument_list|(
name|xf86Info
operator|.
name|mseFd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|ACTIVITY
modifier|*
name|r_protocol
parameter_list|(
name|u_char
name|rBuf
parameter_list|)
block|{
specifier|static
name|int
name|pBufP
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pBuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
name|ACTIVITY
name|act
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto
index|[
literal|9
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*  hd_mask hd_id   dp_mask dp_id   nobytes */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* nomouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MicroSoft */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|}
block|,
comment|/* MouseSystems */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MMSeries */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* Logitech */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|}
block|,
comment|/* BusMouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* MouseMan */
block|{
literal|0xc0
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|3
block|}
block|,
comment|/* PS/2 mouse */
block|}
decl_stmt|;
name|debug
argument_list|(
literal|"received char 0x%x"
argument_list|,
operator|(
name|int
operator|)
name|rBuf
argument_list|)
expr_stmt|;
comment|/*      * Hack for resyncing: We check here for a package that is:      *  a) illegal (detected by wrong data-package header)      *  b) invalid (0x80 == -128 and that might be wrong for MouseSystems)      *  c) bad header-package      *      * NOTE: b) is a voilation of the MouseSystems-Protocol, since values of      *       -128 are allowed, but since they are very seldom we can easily      *       use them as package-header with no button pressed.      * NOTE/2: On a PS/2 mouse any byte is valid as a data byte. Furthermore,      *         0x80 is not valid as a header byte. For a PS/2 mouse we skip      *         checking data bytes.      *         For resyncing a PS/2 mouse we require the two most significant      *         bits in the header byte to be 0. These are the overflow bits,      *         and in case of an overflow we actually lose sync. Overflows      *         are very rare, however, and we quickly gain sync again after      *         an overflow condition. This is the best we can do. (Actually,      *         we could use bit 0x08 in the header byte for resyncing, since      *         that bit is supposed to be always on, but nobody told      *         Microsoft...)      */
if|if
condition|(
name|pBufP
operator|!=
literal|0
operator|&&
name|rodent
operator|.
name|rtype
operator|!=
name|R_PS_2
operator|&&
operator|(
operator|(
name|rBuf
operator|&
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|2
index|]
operator|)
operator|!=
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|3
index|]
operator|||
name|rBuf
operator|==
literal|0x80
operator|)
condition|)
block|{
name|pBufP
operator|=
literal|0
expr_stmt|;
comment|/* skip package */
block|}
if|if
condition|(
name|pBufP
operator|==
literal|0
operator|&&
operator|(
name|rBuf
operator|&
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|0
index|]
operator|)
operator|!=
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|1
index|]
condition|)
block|{
comment|/* 	 * Hack for Logitech MouseMan Mouse - Middle button 	 * 	 * Unfortunately this mouse has variable length packets: the standard 	 * Microsoft 3 byte packet plus an optional 4th byte whenever the 	 * middle button status changes. 	 * 	 * We have already processed the standard packet with the movement 	 * and button info.  Now post an event message with the old status 	 * of the left and right buttons and the updated middle button. 	 */
comment|/* 	 * Even worse, different MouseMen and TrackMen differ in the 4th 	 * byte: some will send 0x00/0x20, others 0x01/0x21, or even 	 * 0x02/0x22, so I have to strip off the lower bits. 	 */
if|if
condition|(
operator|(
name|rodent
operator|.
name|rtype
operator|==
name|R_MICROSOFT
operator|||
name|rodent
operator|.
name|rtype
operator|==
name|R_LOGIMAN
operator|)
operator|&&
call|(
name|char
call|)
argument_list|(
name|rBuf
operator|&
operator|~
literal|0x23
argument_list|)
operator|==
literal|0
condition|)
block|{
name|act
operator|.
name|buttons
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|rBuf
operator|&
literal|0x20
argument_list|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|rodent
operator|.
name|lastbuttons
operator|&
literal|0x05
operator|)
expr_stmt|;
name|rodent
operator|.
name|lastbuttons
operator|=
name|act
operator|.
name|buttons
expr_stmt|;
comment|/* save new button state */
return|return
operator|(
operator|&
name|act
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* skip package */
block|}
name|pBuf
index|[
name|pBufP
operator|++
index|]
operator|=
name|rBuf
expr_stmt|;
if|if
condition|(
name|pBufP
operator|!=
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|4
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/*      * assembly full package      */
name|debug
argument_list|(
literal|"Assembled full packet (len %d) %x,%x,%x,%x,%x"
argument_list|,
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
index|[
literal|4
index|]
argument_list|,
name|pBuf
index|[
literal|0
index|]
argument_list|,
name|pBuf
index|[
literal|1
index|]
argument_list|,
name|pBuf
index|[
literal|2
index|]
argument_list|,
name|pBuf
index|[
literal|3
index|]
argument_list|,
name|pBuf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|R_LOGIMAN
case|:
comment|/* MouseMan / TrackMan */
case|case
name|R_MICROSOFT
case|:
comment|/* Microsoft */
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ChordMiddle
condition|)
name|act
operator|.
name|buttons
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x30
operator|)
operator|==
literal|0x30
operator|)
condition|?
literal|2
else|:
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x20
argument_list|)
operator|>>
literal|3
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
argument_list|)
operator|>>
literal|4
operator|)
expr_stmt|;
else|else
name|act
operator|.
name|buttons
operator|=
operator|(
name|rodent
operator|.
name|lastbuttons
operator|&
literal|2
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x20
argument_list|)
operator|>>
literal|3
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
argument_list|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|act
operator|.
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|dy
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x0C
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MOUSESYS
case|:
comment|/* Mouse Systems Corp */
name|act
operator|.
name|buttons
operator|=
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
literal|0x07
expr_stmt|;
name|act
operator|.
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|1
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|-
operator|(
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|2
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|4
index|]
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|R_MMSERIES
case|:
comment|/* MM Series */
case|case
name|R_LOGITECH
case|:
comment|/* Logitech Mice */
name|act
operator|.
name|buttons
operator|=
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x07
expr_stmt|;
name|act
operator|.
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x08
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|R_BUSMOUSE
case|:
comment|/* BusMouse */
name|act
operator|.
name|buttons
operator|=
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
literal|0x07
expr_stmt|;
name|act
operator|.
name|dx
operator|=
operator|(
name|char
operator|)
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|-
operator|(
name|char
operator|)
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|R_PS_2
case|:
comment|/* PS/2 mouse */
name|act
operator|.
name|buttons
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x04
operator|)
operator|>>
literal|1
operator||
comment|/* Middle */
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|>>
literal|1
operator||
comment|/* Right */
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* Left */
name|act
operator|.
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|.
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
condition|?
operator|-
operator|(
name|pBuf
index|[
literal|2
index|]
operator|-
literal|256
operator|)
else|:
operator|-
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
name|pBufP
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|act
operator|)
return|;
block|}
end_function

end_unit

