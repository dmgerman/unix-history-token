begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  ** Copyright (c) 1995 Michael Smith, All rights reserved.  **  ** Redistribution and use in source and binary forms, with or without  ** modification, are permitted provided that the following conditions  ** are met:  ** 1. Redistributions of source code must retain the above copyright  **    notice, this list of conditions and the following disclaimer as  **    the first lines of this file unmodified.  ** 2. Redistributions in binary form must reproduce the above copyright  **    notice, this list of conditions and the following disclaimer in the  **    documentation and/or other materials provided with the distribution.  ** 3. All advertising materials mentioning features or use of this software  **    must display the following acknowledgment:  **      This product includes software developed by Michael Smith.  ** 4. The name of the author may not be used to endorse or promote products  **    derived from this software without specific prior written permission.  **  **  ** THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ANY  ** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  ** PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Michael Smith BE LIABLE FOR  ** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  ** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  ** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  ** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  ** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  ** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  ** EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  **  **/
end_comment

begin_comment
comment|/**  ** MOUSED.C  **  ** Mouse daemon : listens to a serial port, the bus mouse interface, or  ** the PS/2 mouse port for mouse data stream, interprets data and passes   ** ioctls off to the console driver.  **  ** The mouse interface functions are derived closely from the mouse  ** handler in the XFree86 X server.  Many thanks to the XFree86 people  ** for their great work!  **   **/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: moused.c,v 1.13 1997/12/23 08:04:38 yokota Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|MAX_CLICKTHRESHOLD
value|2000
end_define

begin_comment
comment|/* 2 seconds */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|MOUSE_XAXIS
value|(-1)
end_define

begin_define
define|#
directive|define
name|MOUSE_YAXIS
value|(-2)
end_define

begin_define
define|#
directive|define
name|ChordMiddle
value|0x0001
end_define

begin_define
define|#
directive|define
name|Emulate3Button
value|0x0002
end_define

begin_define
define|#
directive|define
name|ClearDTR
value|0x0004
end_define

begin_define
define|#
directive|define
name|ClearRTS
value|0x0008
end_define

begin_define
define|#
directive|define
name|NoPnP
value|0x0010
end_define

begin_define
define|#
directive|define
name|ID_NONE
value|0
end_define

begin_define
define|#
directive|define
name|ID_PORT
value|1
end_define

begin_define
define|#
directive|define
name|ID_IF
value|2
end_define

begin_define
define|#
directive|define
name|ID_TYPE
value|4
end_define

begin_define
define|#
directive|define
name|ID_MODEL
value|8
end_define

begin_define
define|#
directive|define
name|ID_ALL
value|(ID_PORT | ID_IF | ID_TYPE | ID_MODEL)
end_define

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|if (debug&&nodaemon) warnx(fmt, ##args)
end_define

begin_define
define|#
directive|define
name|logerr
parameter_list|(
name|e
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|{				\ 	if (background) {					\ 	    syslog(LOG_DAEMON | LOG_ERR, fmt ": %m", ##args);	\ 	    exit(e);						\ 	} else							\ 	    err(e, fmt, ##args);				\ }
end_define

begin_define
define|#
directive|define
name|logerrx
parameter_list|(
name|e
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|{				\ 	if (background) {					\ 	    syslog(LOG_DAEMON | LOG_ERR, fmt, ##args);		\ 	    exit(e);						\ 	} else							\ 	    errx(e, fmt, ##args);				\ }
end_define

begin_define
define|#
directive|define
name|logwarn
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|{					\ 	if (background)						\ 	    syslog(LOG_DAEMON | LOG_WARNING, fmt ": %m", ##args); \ 	else							\ 	    warn(fmt, ##args);					\ }
end_define

begin_define
define|#
directive|define
name|logwarnx
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|{				\ 	if (background)						\ 	    syslog(LOG_DAEMON | LOG_WARNING, fmt, ##args);	\ 	else							\ 	    warnx(fmt, ##args);					\ }
end_define

begin_comment
comment|/* structures */
end_comment

begin_comment
comment|/* symbol table entry */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|val2
decl_stmt|;
block|}
name|symtab_t
typedef|;
end_typedef

begin_comment
comment|/* serial PnP ID string */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|revision
decl_stmt|;
comment|/* PnP revision, 100 for 1.00 */
name|char
modifier|*
name|eisaid
decl_stmt|;
comment|/* EISA ID including mfr ID and product ID */
name|char
modifier|*
name|serial
decl_stmt|;
comment|/* serial No, optional */
name|char
modifier|*
name|class
decl_stmt|;
comment|/* device class, optional */
name|char
modifier|*
name|compat
decl_stmt|;
comment|/* list of compatible drivers, optional */
name|char
modifier|*
name|description
decl_stmt|;
comment|/* product description, optional */
name|int
name|neisaid
decl_stmt|;
comment|/* length of the above fields... */
name|int
name|nserial
decl_stmt|;
name|int
name|nclass
decl_stmt|;
name|int
name|ncompat
decl_stmt|;
name|int
name|ndescription
decl_stmt|;
block|}
name|pnpid_t
typedef|;
end_typedef

begin_comment
comment|/* global variables */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodaemon
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|background
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|identify
init|=
name|ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extioctl
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local variables */
end_comment

begin_comment
comment|/* interface (the table must be ordered by MOUSE_IF_XXX in mouse.h) */
end_comment

begin_decl_stmt
specifier|static
name|symtab_t
name|rifs
index|[]
init|=
block|{
block|{
literal|"serial"
block|,
name|MOUSE_IF_SERIAL
block|}
block|,
block|{
literal|"bus"
block|,
name|MOUSE_IF_BUS
block|}
block|,
block|{
literal|"inport"
block|,
name|MOUSE_IF_INPORT
block|}
block|,
block|{
literal|"ps/2"
block|,
name|MOUSE_IF_PS2
block|}
block|,
block|{
literal|"sysmouse"
block|,
name|MOUSE_IF_SYSMOUSE
block|}
block|,
block|{
name|NULL
block|,
name|MOUSE_IF_UNKNOWN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* types (the table must be ordered by MOUSE_PROTO_XXX in mouse.h) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
literal|"microsoft"
block|,
literal|"mousesystems"
block|,
literal|"logitech"
block|,
literal|"mmseries"
block|,
literal|"mouseman"
block|,
literal|"busmouse"
block|,
literal|"inportmouse"
block|,
literal|"ps/2"
block|,
literal|"mmhitab"
block|,
literal|"glidepoint"
block|,
literal|"intellimouse"
block|,
literal|"thinkingmouse"
block|,
literal|"sysmouse"
block|,
if|#
directive|if
name|notyet
literal|"mariqua"
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* models */
end_comment

begin_decl_stmt
specifier|static
name|symtab_t
name|rmodels
index|[]
init|=
block|{
block|{
literal|"NetScroll"
block|,
name|MOUSE_MODEL_NETSCROLL
block|}
block|,
block|{
literal|"NetMouse"
block|,
name|MOUSE_MODEL_NET
block|}
block|,
block|{
literal|"GlidePoint"
block|,
name|MOUSE_MODEL_GLIDEPOINT
block|}
block|,
block|{
literal|"ThinkingMouse"
block|,
name|MOUSE_MODEL_THINK
block|}
block|,
block|{
literal|"IntelliMouse"
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
block|{
literal|"EasyScroll"
block|,
name|MOUSE_MODEL_EASYSCROLL
block|}
block|,
block|{
literal|"MouseMan+"
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
block|{
literal|"generic"
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
block|{
name|NULL
block|,
name|MOUSE_MODEL_UNKNOWN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PnP EISA/product IDs */
end_comment

begin_decl_stmt
specifier|static
name|symtab_t
name|pnpprod
index|[]
init|=
block|{
comment|/* Kensignton ThinkingMouse */
block|{
literal|"KML0001"
block|,
name|MOUSE_PROTO_THINK
block|,
name|MOUSE_MODEL_THINK
block|}
block|,
comment|/* MS IntelliMouse */
block|{
literal|"MSH0001"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* MS IntelliMouse TrackBall */
block|{
literal|"MSH0004"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_INTELLI
block|}
block|,
comment|/* Genius EZScroll */
block|{
literal|"KYEEZ00"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_EASYSCROLL
block|}
block|,
comment|/* Genius NetMouse */
block|{
literal|"KYE0003"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_NET
block|}
block|,
comment|/* Logitech MouseMan (new 4 button model) */
block|{
literal|"LGI800C"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech MouseMan+ */
block|{
literal|"LGI8050"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech FirstMouse+ */
block|{
literal|"LGI8051"
block|,
name|MOUSE_PROTO_INTELLI
block|,
name|MOUSE_MODEL_MOUSEMANPLUS
block|}
block|,
comment|/* Logitech serial */
block|{
literal|"LGI8001"
block|,
name|MOUSE_PROTO_LOGIMOUSEMAN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS bus */
block|{
literal|"PNP0F00"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS serial */
block|{
literal|"PNP0F01"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS InPort */
block|{
literal|"PNP0F02"
block|,
name|MOUSE_PROTO_INPORT
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PS/2 */
block|{
literal|"PNP0F03"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/*      * EzScroll returns PNP0F04 in the compatible device field; but it      * doesn't look compatible... XXX      */
comment|/* MouseSystems */
block|{
literal|"PNP0F04"
block|,
name|MOUSE_PROTO_MSC
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MouseSystems */
block|{
literal|"PNP0F05"
block|,
name|MOUSE_PROTO_MSC
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* Genius Mouse */
block|{
literal|"PNP0F06"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Genius Mouse */
block|{
literal|"PNP0F07"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Logitech serial */
block|{
literal|"PNP0F08"
block|,
name|MOUSE_PROTO_LOGIMOUSEMAN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS BallPoint serial */
block|{
literal|"PNP0F09"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PnP serial */
block|{
literal|"PNP0F0A"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PnP BallPoint serial */
block|{
literal|"PNP0F0B"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS serial comatible */
block|{
literal|"PNP0F0C"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS InPort comatible */
block|{
literal|"PNP0F0D"
block|,
name|MOUSE_PROTO_INPORT
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS PS/2 comatible */
block|{
literal|"PNP0F0E"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS BallPoint comatible */
block|{
literal|"PNP0F0F"
block|,
name|MOUSE_PROTO_MS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* TI QuickPort */
block|{
literal|"PNP0F10"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* MS bus comatible */
block|{
literal|"PNP0F11"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Logitech PS/2 */
block|{
literal|"PNP0F12"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* PS/2 */
block|{
literal|"PNP0F13"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* MS Kids Mouse */
block|{
literal|"PNP0F14"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Logitech bus */
block|{
literal|"PNP0F15"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* Logitech SWIFT */
block|{
literal|"PNP0F16"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
comment|/* Logitech serial compat */
block|{
literal|"PNP0F17"
block|,
name|MOUSE_PROTO_LOGIMOUSEMAN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Logitech bus compatible */
block|{
literal|"PNP0F18"
block|,
name|MOUSE_PROTO_BUS
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Logitech PS/2 compatible */
block|{
literal|"PNP0F19"
block|,
name|MOUSE_PROTO_PS2
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
if|#
directive|if
name|notyet
comment|/* Logitech SWIFT compatible */
block|{
literal|"PNP0F1A"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* HP Omnibook */
block|{
literal|"PNP0F1B"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Compaq LTE TrackBall PS/2 */
block|{
literal|"PNP0F1C"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* Compaq LTE TrackBall serial */
block|{
literal|"PNP0F1D"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
comment|/* MS Kidts Trackball */
block|{
literal|"PNP0F1E"
block|,
name|MOUSE_PROTO_
operator|???
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|MOUSE_PROTO_UNKNOWN
block|,
name|MOUSE_MODEL_GENERIC
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the table must be ordered by MOUSE_PROTO_XXX in mouse.h */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|rodentcflags
index|[]
init|=
block|{
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MicroSoft */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseSystems */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Logitech */
operator|(
name|CS8
operator||
name|PARENB
operator||
name|PARODD
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MMSeries */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MouseMan */
literal|0
block|,
comment|/* Bus */
literal|0
block|,
comment|/* InPort */
literal|0
block|,
comment|/* PS/2 */
operator|(
name|CS8
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* MM HitTablet */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* GlidePoint */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* IntelliMouse */
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Thinking Mouse */
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* sysmouse */
if|#
directive|if
name|notyet
operator|(
name|CS8
operator||
name|CSTOPB
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
block|,
comment|/* Mariqua */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|rodentparam
block|{
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|portname
decl_stmt|;
comment|/* /dev/XXX */
name|int
name|rtype
decl_stmt|;
comment|/* MOUSE_PROTO_XXX */
name|int
name|level
decl_stmt|;
comment|/* operation level: 0 or greater */
name|int
name|baudrate
decl_stmt|;
name|int
name|rate
decl_stmt|;
comment|/* report rate */
name|int
name|resolution
decl_stmt|;
comment|/* MOUSE_RES_XXX or a positive number */
name|int
name|zmap
decl_stmt|;
comment|/* MOUSE_{X|Y}AXIS or a button number */
name|int
name|mfd
decl_stmt|;
comment|/* mouse file descriptor */
name|int
name|cfd
decl_stmt|;
comment|/* /dev/consolectl file descriptor */
name|long
name|clickthreshold
decl_stmt|;
comment|/* double click speed in msec */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* mouse device hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* protocol information */
block|}
name|rodent
init|=
block|{
name|flags
operator|:
literal|0
block|,
name|portname
operator|:
name|NULL
block|,
name|rtype
operator|:
name|MOUSE_PROTO_UNKNOWN
block|,
name|level
operator|:
operator|-
literal|1
block|,
name|baudrate
operator|:
literal|1200
block|,
name|rate
operator|:
literal|0
block|,
name|resolution
operator|:
name|MOUSE_RES_UNKNOWN
block|,
name|zmap
operator|:
literal|0
block|,
name|mfd
operator|:
operator|-
literal|1
block|,
name|cfd
operator|:
operator|-
literal|1
block|,
name|clickthreshold
operator|:
literal|500
block|,
comment|/* 0.5 sec */
block|}
struct|;
end_struct

begin_comment
comment|/* button status */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|count
decl_stmt|;
comment|/* 0: up, 1: single click, 2: double click,... */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* timestamp on the last `up' event */
block|}
name|buttonstate
index|[
name|MOUSE_MAXBUTTON
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|moused
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hup
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_identify
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|r_if
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|r_name
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|r_model
parameter_list|(
name|int
name|model
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_protocol
parameter_list|(
name|u_char
name|b
parameter_list|,
name|mousestatus_t
modifier|*
name|act
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|r_installmap
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_map
parameter_list|(
name|mousestatus_t
modifier|*
name|act1
parameter_list|,
name|mousestatus_t
modifier|*
name|act2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|r_click
parameter_list|(
name|mousestatus_t
modifier|*
name|act
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setmousespeed
parameter_list|(
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|,
name|unsigned
name|cflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnpgets
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pnpparse
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symtab_t
modifier|*
name|pnpproto
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symtab_t
modifier|*
name|gettoken
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gettokenname
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"3C:DF:PRS:cdfhi:l:m:p:r:st:z:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'3'
case|:
name|rodent
operator|.
name|flags
operator||=
name|Emulate3Button
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ChordMiddle
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|nodaemon
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_PORT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"if"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_IF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"model"
argument_list|)
operator|==
literal|0
condition|)
name|identify
operator|=
name|ID_MODEL
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|nodaemon
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|rodent
operator|.
name|level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|rodent
operator|.
name|level
operator|>
literal|4
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|r_installmap
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|rodent
operator|.
name|portname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"high"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"medium-high"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"medium-low"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"low"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|resolution
operator|=
name|MOUSE_RES_DEFAULT
expr_stmt|;
else|else
block|{
name|rodent
operator|.
name|resolution
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
name|rodent
operator|.
name|baudrate
operator|=
literal|9600
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"x"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|zmap
operator|=
name|MOUSE_XAXIS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"y"
argument_list|)
operator|==
literal|0
condition|)
name|rodent
operator|.
name|zmap
operator|=
name|MOUSE_YAXIS
expr_stmt|;
else|else
block|{
name|i
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
comment|/*  		 * Use button i for negative Z axis movement and  		 * button (i + 1) for positive Z axis movement. 		 */
if|if
condition|(
operator|(
name|i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|MOUSE_MAXBUTTON
operator|-
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|rodent
operator|.
name|zmap
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
name|rodent
operator|.
name|clickthreshold
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|clickthreshold
operator|<
literal|0
operator|)
operator|||
operator|(
name|rodent
operator|.
name|clickthreshold
operator|>
name|MAX_CLICKTHRESHOLD
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ClearDTR
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|rodent
operator|.
name|rate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
name|rodent
operator|.
name|flags
operator||=
name|NoPnP
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|rodent
operator|.
name|flags
operator||=
name|ClearRTS
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|rodent
operator|.
name|baudrate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|baudrate
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid argument `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"rodent baudrate %d"
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rodent
operator|.
name|rtype
operator|=
name|MOUSE_PROTO_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|flags
operator|&=
operator|~
name|NoPnP
expr_stmt|;
name|rodent
operator|.
name|level
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|rnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rodent
operator|.
name|rtype
operator|=
name|i
expr_stmt|;
name|rodent
operator|.
name|flags
operator||=
name|NoPnP
expr_stmt|;
name|rodent
operator|.
name|level
operator|=
operator|(
name|i
operator|==
name|MOUSE_PROTO_SYSMOUSE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rnames
index|[
name|i
index|]
condition|)
break|break;
name|warnx
argument_list|(
literal|"no such mouse type `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* the default port name */
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|MOUSE_PROTO_INPORT
case|:
comment|/* INPORT and BUS are the same... */
name|rodent
operator|.
name|rtype
operator|=
name|MOUSE_PROTO_BUS
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|MOUSE_PROTO_BUS
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/mse0"
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_PS2
case|:
if|if
condition|(
operator|!
name|rodent
operator|.
name|portname
condition|)
name|rodent
operator|.
name|portname
operator|=
literal|"/dev/psm0"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|rodent
operator|.
name|portname
condition|)
break|break;
name|warnx
argument_list|(
literal|"no port name specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|mfd
operator|=
name|open
argument_list|(
name|rodent
operator|.
name|portname
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"unable to open %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_identify
argument_list|()
operator|==
name|MOUSE_PROTO_UNKNOWN
condition|)
block|{
name|logwarnx
argument_list|(
literal|"cannot determine mouse type on %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* print some information */
if|if
condition|(
name|identify
operator|!=
name|ID_NONE
condition|)
block|{
if|if
condition|(
name|identify
operator|==
name|ID_ALL
condition|)
name|printf
argument_list|(
literal|"%s %s %s %s\n"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|,
name|r_if
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_model
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_PORT
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_IF
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r_if
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_TYPE
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|identify
operator|&
name|ID_MODEL
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r_model
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"port: %s  interface: %s  type: %s  model: %s"
argument_list|,
name|rodent
operator|.
name|portname
argument_list|,
name|r_if
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_model
argument_list|(
name|rodent
operator|.
name|hw
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mfd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 	         * We cannot continue because of error.  Exit if the  		 * program has not become a daemon.  Otherwise, block  		 * until the the user corrects the problem and issues SIGHUP.  	         */
if|if
condition|(
operator|!
name|background
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|r_init
argument_list|()
expr_stmt|;
comment|/* call init function */
name|moused
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|cfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mfd
operator|=
name|rodent
operator|.
name|cfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* NOT REACHED */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|moused
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mouse_info
name|mouse
decl_stmt|;
name|mousestatus_t
name|action
decl_stmt|;
comment|/* original mouse action */
name|mousestatus_t
name|action2
decl_stmt|;
comment|/* mapped action */
name|fd_set
name|fds
decl_stmt|;
name|u_char
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|rodent
operator|.
name|cfd
operator|=
name|open
argument_list|(
literal|"/dev/consolectl"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"cannot open /dev/consolectl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodaemon
operator|&&
operator|!
name|background
condition|)
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|1
argument_list|,
literal|"failed to become a daemon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|background
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* clear mouse data */
name|bzero
argument_list|(
operator|&
name|action
argument_list|,
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|action2
argument_list|,
sizeof|sizeof
argument_list|(
name|action2
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|buttonstate
argument_list|,
sizeof|sizeof
argument_list|(
name|buttonstate
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mouse
argument_list|,
sizeof|sizeof
argument_list|(
name|mouse
argument_list|)
argument_list|)
expr_stmt|;
comment|/* choose which ioctl command to use */
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_MOTION_EVENT
expr_stmt|;
name|extioctl
operator|=
operator|(
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* process mouse data */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
name|logwarn
argument_list|(
literal|"failed to read from mouse"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_protocol
argument_list|(
name|b
argument_list|,
operator|&
name|action
argument_list|)
condition|)
block|{
comment|/* handler detected action */
name|r_map
argument_list|(
operator|&
name|action
argument_list|,
operator|&
name|action2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"activity : buttons 0x%08x  dx %d  dy %d  dz %d"
argument_list|,
name|action2
operator|.
name|button
argument_list|,
name|action2
operator|.
name|dx
argument_list|,
name|action2
operator|.
name|dy
argument_list|,
name|action2
operator|.
name|dz
argument_list|)
expr_stmt|;
if|if
condition|(
name|extioctl
condition|)
block|{
name|r_click
argument_list|(
operator|&
name|action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
operator|.
name|flags
operator|&
name|MOUSE_POSCHANGED
condition|)
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_MOTION_EVENT
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|action2
operator|.
name|button
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|action2
operator|.
name|dx
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|action2
operator|.
name|dy
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|z
operator|=
name|action2
operator|.
name|dz
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_ACTION
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|action2
operator|.
name|button
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|action2
operator|.
name|dx
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|action2
operator|.
name|dy
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|z
operator|=
name|action2
operator|.
name|dz
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If the Z axis movement is mapped to a imaginary physical  	     * button, we need to cook up a corresponding button `up' event 	     * after sending a button `down' event. 	     */
if|if
condition|(
operator|(
name|rodent
operator|.
name|zmap
operator|>
literal|0
operator|)
operator|&&
operator|(
name|action
operator|.
name|dz
operator|!=
literal|0
operator|)
condition|)
block|{
name|action
operator|.
name|obutton
operator|=
name|action
operator|.
name|button
expr_stmt|;
name|action
operator|.
name|dx
operator|=
name|action
operator|.
name|dy
operator|=
name|action
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|r_map
argument_list|(
operator|&
name|action
argument_list|,
operator|&
name|action2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"activity : buttons 0x%08x  dx %d  dy %d  dz %d"
argument_list|,
name|action2
operator|.
name|button
argument_list|,
name|action2
operator|.
name|dx
argument_list|,
name|action2
operator|.
name|dy
argument_list|,
name|action2
operator|.
name|dz
argument_list|)
expr_stmt|;
if|if
condition|(
name|extioctl
condition|)
block|{
name|r_click
argument_list|(
operator|&
name|action2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_ACTION
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|action2
operator|.
name|button
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|mouse
operator|.
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* NOT REACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|hup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** usage  **  ** Complain, and free the CPU for more worthy tasks  **/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n"
argument_list|,
literal|"usage: moused [-3DRcdfs] [-F rate] [-r resolution] [-S baudrate] [-C threshold]"
argument_list|,
literal|"              [-m N=M] [-z N] [-t<mousetype>] -p<port>"
argument_list|,
literal|"       moused [-d] -i -p<port>"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** Mouse interface code, courtesy of XFree86 3.1.2.  **  ** Note: Various bits have been trimmed, and in my shortsighted enthusiasm  ** to clean, reformat and rationalise naming, it's quite possible that  ** some things in here have been broken.  **  ** I hope not 8)  **  ** The following code is derived from a module marked :  **/
end_comment

begin_comment
comment|/* $XConsortium: xf86_Mouse.c,v 1.2 94/10/12 20:33:21 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.2 1995/01/28  17:03:40 dawes Exp $ */
end_comment

begin_comment
comment|/*  *  * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of Thomas Roell and David Dawes not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  Thomas Roell  * and David Dawes makes no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * THOMAS ROELL AND DAVID DAWES DISCLAIM ALL WARRANTIES WITH REGARD TO THIS  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS, IN NO EVENT SHALL THOMAS ROELL OR DAVID DAWES BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_comment
comment|/**  ** GlidePoint support from XFree86 3.2.  ** Derived from the module:  **/
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86_Mouse.c,v 3.19 1996/10/16 14:40:51 dawes Exp $ */
end_comment

begin_comment
comment|/* $XConsortium: xf86_Mouse.c /main/10 1996/01/30 15:16:12 kaleb $ */
end_comment

begin_comment
comment|/* the following table must be ordered by MOUSE_PROTO_XXX in mouse.h */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|proto
index|[]
index|[
literal|7
index|]
init|=
block|{
comment|/*  hd_mask hd_id   dp_mask dp_id   bytes b4_mask b4_id */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x23
block|,
literal|0x00
block|}
block|,
comment|/* MicroSoft */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* MouseSystems */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* Logitech */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* MMSeries */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x23
block|,
literal|0x00
block|}
block|,
comment|/* MouseMan */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* Bus */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* InPort */
block|{
literal|0xc0
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* PS/2 mouse */
block|{
literal|0xe0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|3
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* MM HitTablet */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x33
block|,
literal|0x00
block|}
block|,
comment|/* GlidePoint */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x3f
block|,
literal|0x00
block|}
block|,
comment|/* IntelliMouse */
block|{
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x00
block|,
literal|3
block|,
operator|~
literal|0x33
block|,
literal|0x00
block|}
block|,
comment|/* ThinkingMouse */
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* sysmouse */
if|#
directive|if
name|notyet
block|{
literal|0xf8
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|5
block|,
operator|~
literal|0x2f
block|,
literal|0x10
block|}
block|,
comment|/* Mariqua */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|cur_proto
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|r_identify
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|pnpbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* PnP identifier string may be up to 256 bytes long */
name|pnpid_t
name|pnpid
decl_stmt|;
name|symtab_t
modifier|*
name|t
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* set the driver operation level, if applicable */
if|if
condition|(
name|rodent
operator|.
name|level
operator|<
literal|0
condition|)
name|rodent
operator|.
name|level
operator|=
literal|1
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_SETLEVEL
argument_list|,
operator|&
name|rodent
operator|.
name|level
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|level
operator|=
operator|(
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_GETLEVEL
argument_list|,
operator|&
name|level
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|level
else|:
literal|0
expr_stmt|;
comment|/*      * Interrogate the driver and get some intelligence on the device...       * The following ioctl functions are not always supported by device      * drivers.  When the driver doesn't support them, we just trust the      * user to supply valid information.      */
name|rodent
operator|.
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|hw
operator|.
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_GETHWINFO
argument_list|,
operator|&
name|rodent
operator|.
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
name|bcopy
argument_list|(
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|,
name|cur_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_proto
argument_list|)
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_UNKNOWN
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|rodent
operator|.
name|mode
operator|.
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_GETMODE
argument_list|,
operator|&
name|rodent
operator|.
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_UNKNOWN
operator|)
operator|||
operator|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|>=
sizeof|sizeof
argument_list|(
name|proto
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|proto
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|logwarnx
argument_list|(
literal|"unknown mouse protocol (%d)"
argument_list|,
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
expr_stmt|;
return|return
name|MOUSE_PROTO_UNKNOWN
return|;
block|}
else|else
block|{
comment|/* INPORT and BUS are the same... */
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_INPORT
condition|)
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_BUS
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|!=
name|rodent
operator|.
name|rtype
condition|)
block|{
comment|/* Hmm, the driver doesn't agree with the user... */
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
name|logwarnx
argument_list|(
literal|"mouse type mismatch (%s != %s), %s is assumed"
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|rtype
operator|=
name|rodent
operator|.
name|mode
operator|.
name|protocol
expr_stmt|;
name|bcopy
argument_list|(
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|,
name|cur_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_proto
index|[
literal|4
index|]
operator|=
name|rodent
operator|.
name|mode
operator|.
name|packetsize
expr_stmt|;
name|cur_proto
index|[
literal|0
index|]
operator|=
name|rodent
operator|.
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
expr_stmt|;
comment|/* header byte bit mask */
name|cur_proto
index|[
literal|1
index|]
operator|=
name|rodent
operator|.
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
expr_stmt|;
comment|/* header bit pattern */
block|}
comment|/* maybe this is an PnP mouse... */
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_UNKNOWN
condition|)
block|{
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|NoPnP
condition|)
return|return
name|rodent
operator|.
name|rtype
return|;
if|if
condition|(
operator|(
operator|(
name|len
operator|=
name|pnpgets
argument_list|(
name|pnpbuf
argument_list|)
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|!
name|pnpparse
argument_list|(
operator|&
name|pnpid
argument_list|,
name|pnpbuf
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|rodent
operator|.
name|rtype
return|;
name|debug
argument_list|(
literal|"PnP serial mouse: '%*.*s' '%*.*s' '%*.*s'"
argument_list|,
name|pnpid
operator|.
name|neisaid
argument_list|,
name|pnpid
operator|.
name|neisaid
argument_list|,
name|pnpid
operator|.
name|eisaid
argument_list|,
name|pnpid
operator|.
name|ncompat
argument_list|,
name|pnpid
operator|.
name|ncompat
argument_list|,
name|pnpid
operator|.
name|compat
argument_list|,
name|pnpid
operator|.
name|ndescription
argument_list|,
name|pnpid
operator|.
name|ndescription
argument_list|,
name|pnpid
operator|.
name|description
argument_list|)
expr_stmt|;
comment|/* we have a valid PnP serial device ID */
name|rodent
operator|.
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_SERIAL
expr_stmt|;
name|t
operator|=
name|pnpproto
argument_list|(
operator|&
name|pnpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|t
operator|->
name|val
expr_stmt|;
name|rodent
operator|.
name|hw
operator|.
name|model
operator|=
name|t
operator|->
name|val2
expr_stmt|;
block|}
else|else
block|{
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|==
name|MOUSE_PROTO_INPORT
condition|)
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_BUS
expr_stmt|;
comment|/* make final adjustment */
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
block|{
if|if
condition|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
operator|!=
name|rodent
operator|.
name|rtype
condition|)
block|{
comment|/* Hmm, the device doesn't agree with the user... */
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
name|logwarnx
argument_list|(
literal|"mouse type mismatch (%s != %s), %s is assumed"
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|rtype
argument_list|)
argument_list|,
name|r_name
argument_list|(
name|rodent
operator|.
name|mode
operator|.
name|protocol
argument_list|)
argument_list|)
expr_stmt|;
name|rodent
operator|.
name|rtype
operator|=
name|rodent
operator|.
name|mode
operator|.
name|protocol
expr_stmt|;
name|bcopy
argument_list|(
name|proto
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|,
name|cur_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|debug
argument_list|(
literal|"proto params: %02x %02x %02x %02x %d %02x %02x"
argument_list|,
name|cur_proto
index|[
literal|0
index|]
argument_list|,
name|cur_proto
index|[
literal|1
index|]
argument_list|,
name|cur_proto
index|[
literal|2
index|]
argument_list|,
name|cur_proto
index|[
literal|3
index|]
argument_list|,
name|cur_proto
index|[
literal|4
index|]
argument_list|,
name|cur_proto
index|[
literal|5
index|]
argument_list|,
name|cur_proto
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
return|return
name|rodent
operator|.
name|rtype
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|r_if
parameter_list|(
name|int
name|iftype
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|gettokenname
argument_list|(
name|rifs
argument_list|,
name|iftype
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"unknown"
else|:
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|r_name
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
operator|(
name|type
operator|==
name|MOUSE_PROTO_UNKNOWN
operator|)
operator|||
operator|(
name|type
operator|>
sizeof|sizeof
argument_list|(
name|rnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rnames
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|"unknown"
else|:
name|rnames
index|[
name|type
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|r_model
parameter_list|(
name|int
name|model
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|gettokenname
argument_list|(
name|rmodels
argument_list|,
name|model
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"unknown"
else|:
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_init
parameter_list|(
name|void
parameter_list|)
block|{
name|fd_set
name|fds
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/**      ** This comment is a little out of context here, but it contains       ** some useful information...      ********************************************************************      **      ** The following lines take care of the Logitech MouseMan protocols.      **      ** NOTE: There are different versions of both MouseMan and TrackMan!      **       Hence I add another protocol P_LOGIMAN, which the user can      **       specify as MouseMan in his XF86Config file. This entry was      **       formerly handled as a special case of P_MS. However, people      **       who don't have the middle button problem, can still specify      **       Microsoft and use P_MS.      **      ** By default, these mice should use a 3 byte Microsoft protocol      ** plus a 4th byte for the middle button. However, the mouse might      ** have switched to a different protocol before we use it, so I send      ** the proper sequence just in case.      **      ** NOTE: - all commands to (at least the European) MouseMan have to      **         be sent at 1200 Baud.      **       - each command starts with a '*'.      **       - whenever the MouseMan receives a '*', it will switch back      **	 to 1200 Baud. Hence I have to select the desired protocol      **	 first, then select the baud rate.      **      ** The protocols supported by the (European) MouseMan are:      **   -  5 byte packed binary protocol, as with the Mouse Systems      **      mouse. Selected by sequence "*U".      **   -  2 button 3 byte MicroSoft compatible protocol. Selected      **      by sequence "*V".      **   -  3 button 3+1 byte MicroSoft compatible protocol (default).      **      Selected by sequence "*X".      **      ** The following baud rates are supported:      **   -  1200 Baud (default). Selected by sequence "*n".      **   -  9600 Baud. Selected by sequence "*q".      **      ** Selecting a sample rate is no longer supported with the MouseMan!      ** Some additional lines in xf86Config.c take care of ill configured      ** baud rates and sample rates. (The user will get an error.)      */
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|MOUSE_PROTO_LOGI
case|:
comment|/*  	 * The baud rate selection command must be sent at the current 	 * baud rate; try all likely settings  	 */
name|setmousespeed
argument_list|(
literal|9600
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|4800
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|2400
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* select MM series data format */
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|MOUSE_PROTO_MM
index|]
argument_list|)
expr_stmt|;
comment|/* select report rate/frequency */
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|0
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"O"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|15
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"J"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|27
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"K"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|42
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"L"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|60
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|85
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"M"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|rate
operator|<=
literal|125
condition|)
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"Q"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_LOGIMOUSEMAN
case|:
comment|/* The command must always be sent at 1200 baud */
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
literal|1200
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"*X"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_HITTAB
case|:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Hitachi PUMA Plus - Model 1212E to desired settings. 	 * The tablet must be configured to be in MM mode, NO parity, 	 * Binary Format.  xf86Info.sampleRate controls the sensativity 	 * of the tablet.  We only use this tablet for it's 4-button puck 	 * so we don't run in "Absolute Mode" 	 */
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"z8"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Parity = "NONE" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"zb"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Format = "Binary" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Report Mode = "Stream" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Output Rate = "45 rps" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"I\x20"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Incrememtal Mode "20" */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"E"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Data Type = "Relative */
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* Resolution is in 'lines per inch' on the Hitachi tablet */
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_LOW
condition|)
name|c
operator|=
literal|'g'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_MEDIUMLOW
condition|)
name|c
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_MEDIUMHIGH
condition|)
name|c
operator|=
literal|'h'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|==
name|MOUSE_RES_HIGH
condition|)
name|c
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|40
condition|)
name|c
operator|=
literal|'g'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|100
condition|)
name|c
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|200
condition|)
name|c
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|500
condition|)
name|c
operator|=
literal|'h'
expr_stmt|;
elseif|else
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|<=
literal|1000
condition|)
name|c
operator|=
literal|'j'
expr_stmt|;
else|else
name|c
operator|=
literal|'d'
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
literal|"\021"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Resume DATA output */
break|break;
case|case
name|MOUSE_PROTO_THINK
case|:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* the PnP ID string may be sent again, discard it */
name|usleep
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* send the command to initialize the beast */
for|for
control|(
name|s
operator|=
literal|"E5E5"
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
block|{
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|*
name|s
condition|)
break|break;
block|}
break|break;
case|case
name|MOUSE_PROTO_MSC
case|:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ClearDTR
condition|)
block|{
name|i
operator|=
name|TIOCM_DTR
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ClearRTS
condition|)
block|{
name|i
operator|=
name|TIOCM_RTS
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIC
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_PROTO_SYSMOUSE
case|:
if|if
condition|(
name|rodent
operator|.
name|hw
operator|.
name|iftype
operator|==
name|MOUSE_IF_SYSMOUSE
condition|)
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|MOUSE_PROTO_BUS
case|:
case|case
name|MOUSE_PROTO_INPORT
case|:
case|case
name|MOUSE_PROTO_PS2
case|:
if|if
condition|(
name|rodent
operator|.
name|rate
operator|>=
literal|0
condition|)
name|rodent
operator|.
name|mode
operator|.
name|rate
operator|=
name|rodent
operator|.
name|rate
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|resolution
operator|!=
name|MOUSE_RES_UNKNOWN
condition|)
name|rodent
operator|.
name|mode
operator|.
name|resolution
operator|=
name|rodent
operator|.
name|resolution
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|MOUSE_SETMODE
argument_list|,
operator|&
name|rodent
operator|.
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
name|rodent
operator|.
name|baudrate
argument_list|,
name|rodentcflags
index|[
name|rodent
operator|.
name|rtype
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|r_protocol
parameter_list|(
name|u_char
name|rBuf
parameter_list|,
name|mousestatus_t
modifier|*
name|act
parameter_list|)
block|{
comment|/* MOUSE_MSS_BUTTON?DOWN -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapmss
index|[
literal|4
index|]
init|=
block|{
comment|/* Microsoft, MouseMan, GlidePoint,  				   IntelliMouse, Thinking Mouse */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,      }
decl_stmt|;
specifier|static
name|int
name|butmapmss2
index|[
literal|4
index|]
init|=
block|{
comment|/* Microsoft, MouseMan, GlidePoint,  				    Thinking Mouse */
literal|0
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON4DOWN
block|,      }
decl_stmt|;
comment|/* MOUSE_INTELLI_BUTTON?DOWN -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapintelli
index|[
literal|4
index|]
init|=
block|{
comment|/* IntelliMouse, NetMouse, Mie Mouse, 				       MouseMan+ */
literal|0
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON4DOWN
block|,      }
decl_stmt|;
comment|/* MOUSE_MSC_BUTTON?UP -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapmsc
index|[
literal|8
index|]
init|=
block|{
comment|/* MouseSystems, MMSeries, Logitech,  				   Bus, sysmouse */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
comment|/* MOUSE_PS2_BUTTON?DOWN -> MOUSE_BUTTON?DOWN */
specifier|static
name|int
name|butmapps2
index|[
literal|8
index|]
init|=
block|{
comment|/* PS/2 */
literal|0
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
comment|/* for Hitachi tablet */
specifier|static
name|int
name|butmaphit
index|[
literal|8
index|]
init|=
block|{
comment|/* MM HitTablet */
literal|0
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON5DOWN
block|,
name|MOUSE_BUTTON6DOWN
block|,
name|MOUSE_BUTTON7DOWN
block|,      }
decl_stmt|;
specifier|static
name|int
name|pBufP
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pBuf
index|[
literal|8
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"received char 0x%x"
argument_list|,
operator|(
name|int
operator|)
name|rBuf
argument_list|)
expr_stmt|;
comment|/*      * Hack for resyncing: We check here for a package that is:      *  a) illegal (detected by wrong data-package header)      *  b) invalid (0x80 == -128 and that might be wrong for MouseSystems)      *  c) bad header-package      *      * NOTE: b) is a voilation of the MouseSystems-Protocol, since values of      *       -128 are allowed, but since they are very seldom we can easily      *       use them as package-header with no button pressed.      * NOTE/2: On a PS/2 mouse any byte is valid as a data byte. Furthermore,      *         0x80 is not valid as a header byte. For a PS/2 mouse we skip      *         checking data bytes.      *         For resyncing a PS/2 mouse we require the two most significant      *         bits in the header byte to be 0. These are the overflow bits,      *         and in case of an overflow we actually lose sync. Overflows      *         are very rare, however, and we quickly gain sync again after      *         an overflow condition. This is the best we can do. (Actually,      *         we could use bit 0x08 in the header byte for resyncing, since      *         that bit is supposed to be always on, but nobody told      *         Microsoft...)      */
if|if
condition|(
name|pBufP
operator|!=
literal|0
operator|&&
name|rodent
operator|.
name|rtype
operator|!=
name|MOUSE_PROTO_PS2
operator|&&
operator|(
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|2
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|3
index|]
operator|||
name|rBuf
operator|==
literal|0x80
operator|)
condition|)
block|{
name|pBufP
operator|=
literal|0
expr_stmt|;
comment|/* skip package */
block|}
if|if
condition|(
name|pBufP
operator|==
literal|0
operator|&&
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|0
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* is there an extra data byte? */
if|if
condition|(
name|pBufP
operator|>=
name|cur_proto
index|[
literal|4
index|]
operator|&&
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|0
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|1
index|]
condition|)
block|{
comment|/* 	 * Hack for Logitech MouseMan Mouse - Middle button 	 * 	 * Unfortunately this mouse has variable length packets: the standard 	 * Microsoft 3 byte packet plus an optional 4th byte whenever the 	 * middle button status changes. 	 * 	 * We have already processed the standard packet with the movement 	 * and button info.  Now post an event message with the old status 	 * of the left and right buttons and the updated middle button. 	 */
comment|/* 	 * Even worse, different MouseMen and TrackMen differ in the 4th 	 * byte: some will send 0x00/0x20, others 0x01/0x21, or even 	 * 0x02/0x22, so I have to strip off the lower bits.          *          * [JCH-96/01/21]          * HACK for ALPS "fourth button". (It's bit 0x10 of the "fourth byte"          * and it is activated by tapping the glidepad with the finger! 8^)          * We map it to bit bit3, and the reverse map in xf86Events just has          * to be extended so that it is identified as Button 4. The lower          * half of the reverse-map may remain unchanged. 	 */
comment|/* 	 * [KY-97/08/03] 	 * Receive the fourth byte only when preceeding three bytes have 	 * been detected (pBufP>= cur_proto[4]).  In the previous 	 * versions, the test was pBufP == 0; thus, we may have mistakingly 	 * received a byte even if we didn't see anything preceeding  	 * the byte. 	 */
if|if
condition|(
operator|(
name|rBuf
operator|&
name|cur_proto
index|[
literal|5
index|]
operator|)
operator|!=
name|cur_proto
index|[
literal|6
index|]
condition|)
block|{
name|pBufP
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
if|#
directive|if
name|notyet
case|case
name|MOUSE_PROTO_MARIQUA
case|:
comment|/*  	     * This mouse has 16! buttons in addition to the standard 	     * three of them.  They return 0x10 though 0x1f in the 	     * so-called `ten key' mode and 0x30 though 0x3f in the 	     * `function key' mode.  As there are only 31 bits for  	     * button state (including the standard three), we ignore 	     * the bit 0x20 and don't distinguish the two modes. 	     */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|rBuf
operator|&=
literal|0x1f
expr_stmt|;
name|act
operator|->
name|button
operator|=
operator|(
literal|1
operator|<<
operator|(
name|rBuf
operator|-
literal|13
operator|)
operator|)
operator||
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
expr_stmt|;
comment|/*  	     * FIXME: this is a button "down" event. There needs to be  	     * a corresponding button "up" event... XXX 	     */
break|break;
endif|#
directive|endif
comment|/* notyet */
comment|/* 	 * IntelliMouse, NetMouse (including NetMouse Pro) and Mie Mouse 	 * always send the fourth byte, whereas the fourth byte is 	 * optional for GlidePoint and ThinkingMouse. The fourth byte  	 * is also optional for MouseMan+ and FirstMouse+ in their  	 * native mode. It is always sent if they are in the IntelliMouse  	 * compatible mode. 	 */
case|case
name|MOUSE_PROTO_INTELLI
case|:
comment|/* IntelliMouse, NetMouse, Mie Mouse, 					   MouseMan+ */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|dz
operator|=
operator|(
name|rBuf
operator|&
literal|0x08
operator|)
condition|?
operator|(
name|rBuf
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|rBuf
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|act
operator|->
name|button
operator|=
name|butmapintelli
index|[
operator|(
name|rBuf
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
operator||
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
name|act
operator|->
name|button
operator|=
name|butmapmss2
index|[
operator|(
name|rBuf
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
operator||
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|act
operator|->
name|flags
operator|=
operator|(
operator|(
name|act
operator|->
name|dx
operator|||
name|act
operator|->
name|dy
operator|||
name|act
operator|->
name|dz
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|act
operator|->
name|obutton
operator|^
name|act
operator|->
name|button
operator|)
expr_stmt|;
name|pBufP
operator|=
literal|0
expr_stmt|;
return|return
name|act
operator|->
name|flags
return|;
block|}
if|if
condition|(
name|pBufP
operator|>=
name|cur_proto
index|[
literal|4
index|]
condition|)
name|pBufP
operator|=
literal|0
expr_stmt|;
name|pBuf
index|[
name|pBufP
operator|++
index|]
operator|=
name|rBuf
expr_stmt|;
if|if
condition|(
name|pBufP
operator|!=
name|cur_proto
index|[
literal|4
index|]
condition|)
return|return
literal|0
return|;
comment|/*      * assembly full package      */
name|debug
argument_list|(
literal|"assembled full packet (len %d) %x,%x,%x,%x,%x,%x,%x,%x"
argument_list|,
name|cur_proto
index|[
literal|4
index|]
argument_list|,
name|pBuf
index|[
literal|0
index|]
argument_list|,
name|pBuf
index|[
literal|1
index|]
argument_list|,
name|pBuf
index|[
literal|2
index|]
argument_list|,
name|pBuf
index|[
literal|3
index|]
argument_list|,
name|pBuf
index|[
literal|4
index|]
argument_list|,
name|pBuf
index|[
literal|5
index|]
argument_list|,
name|pBuf
index|[
literal|6
index|]
argument_list|,
name|pBuf
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|act
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|obutton
operator|=
name|act
operator|->
name|button
expr_stmt|;
switch|switch
condition|(
name|rodent
operator|.
name|rtype
condition|)
block|{
case|case
name|MOUSE_PROTO_MS
case|:
comment|/* Microsoft */
case|case
name|MOUSE_PROTO_LOGIMOUSEMAN
case|:
comment|/* MouseMan/TrackMan */
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|ChordMiddle
condition|)
name|act
operator|->
name|button
operator|=
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|==
name|MOUSE_MSS_BUTTONS
operator|)
condition|?
name|MOUSE_BUTTON2DOWN
else|:
name|butmapmss
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
else|else
name|act
operator|->
name|button
operator|=
operator|(
name|act
operator|->
name|obutton
operator|&
name|MOUSE_BUTTON2DOWN
operator|)
operator||
name|butmapmss
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x0C
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_GLIDEPOINT
case|:
comment|/* GlidePoint */
case|case
name|MOUSE_PROTO_THINK
case|:
comment|/* ThinkingMouse */
case|case
name|MOUSE_PROTO_INTELLI
case|:
comment|/* IntelliMouse, NetMouse, Mie Mouse, 					   MouseMan+ */
name|act
operator|->
name|button
operator|=
operator|(
name|act
operator|->
name|obutton
operator|&
operator|(
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON4DOWN
operator|)
operator|)
operator||
name|butmapmss
index|[
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSS_BUTTONS
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x0C
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MSC
case|:
comment|/* MouseSystems Corp */
if|#
directive|if
name|notyet
case|case
name|MOUSE_PROTO_MARIQUA
case|:
comment|/* Mariqua */
endif|#
directive|endif
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
name|MOUSE_MSC_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|1
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|-
operator|(
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|2
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|4
index|]
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_HITTAB
case|:
comment|/* MM HitTablet */
name|act
operator|->
name|button
operator|=
name|butmaphit
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
literal|0x07
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_XPOSITIVE
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_YPOSITIVE
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MM
case|:
comment|/* MM Series */
case|case
name|MOUSE_PROTO_LOGI
case|:
comment|/* Logitech Mice */
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MSC_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_XPOSITIVE
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
else|:
operator|-
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_MM_YPOSITIVE
operator|)
condition|?
operator|-
name|pBuf
index|[
literal|2
index|]
else|:
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_BUS
case|:
comment|/* Bus */
case|case
name|MOUSE_PROTO_INPORT
case|:
comment|/* InPort */
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
name|MOUSE_MSC_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|char
operator|)
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|-
operator|(
name|char
operator|)
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_PS2
case|:
comment|/* PS/2 */
name|act
operator|->
name|button
operator|=
name|butmapps2
index|[
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_BUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pBuf
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|1
index|]
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
operator|-
operator|(
name|pBuf
index|[
literal|2
index|]
operator|-
literal|256
operator|)
else|:
operator|-
name|pBuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Moused usually operates the psm driver at the operation level 1 	 * which sends mouse data in MOUSE_PROTO_SYSMOUSE protocol. 	 * The following code takes effect only when the user explicitly  	 * requets the level 2 at which wheel movement and additional button  	 * actions are encoded in model-dependent formats. At the level 0 	 * the following code is no-op because the psm driver says the model 	 * is MOUSE_MODEL_GENERIC. 	 */
switch|switch
condition|(
name|rodent
operator|.
name|hw
operator|.
name|model
condition|)
block|{
case|case
name|MOUSE_MODEL_INTELLI
case|:
case|case
name|MOUSE_MODEL_NET
case|:
comment|/* wheel data is in the fourth byte */
name|act
operator|->
name|dz
operator|=
operator|(
name|char
operator|)
name|pBuf
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_MOUSEMANPLUS
case|:
if|if
condition|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
operator|~
name|MOUSE_PS2_BUTTONS
operator|)
operator|==
literal|0xc8
condition|)
block|{
comment|/* the extended data packet encodes button and wheel events */
name|act
operator|->
name|dx
operator|=
name|act
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|1
index|]
operator|&
name|MOUSE_PS2PLUS_ZNEG
operator|)
condition|?
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
operator|(
name|pBuf
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* preserve button states */
name|act
operator|->
name|button
operator||=
name|act
operator|->
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_GLIDEPOINT
case|:
comment|/* `tapping' action */
name|act
operator|->
name|button
operator||=
operator|(
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_NETSCROLL
case|:
comment|/* three addtional bytes encode button and wheel events */
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON3DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|act
operator|->
name|dz
operator|=
operator|(
name|pBuf
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|pBuf
index|[
literal|4
index|]
operator|-
literal|256
else|:
name|pBuf
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_THINK
case|:
comment|/* the fourth button state in the first byte */
name|act
operator|->
name|button
operator||=
operator|(
name|pBuf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_GENERIC
case|:
default|default:
break|break;
block|}
break|break;
case|case
name|MOUSE_PROTO_SYSMOUSE
case|:
comment|/* sysmouse */
name|act
operator|->
name|button
operator|=
name|butmapmsc
index|[
operator|(
operator|~
name|pBuf
index|[
literal|0
index|]
operator|)
operator|&
name|MOUSE_SYS_STDBUTTONS
index|]
expr_stmt|;
name|act
operator|->
name|dx
operator|=
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|1
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|act
operator|->
name|dy
operator|=
operator|-
operator|(
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|2
index|]
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|4
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|level
operator|==
literal|1
condition|)
block|{
name|act
operator|->
name|dz
operator|=
operator|(
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|5
index|]
operator|<<
literal|1
argument_list|)
operator|+
call|(
name|char
call|)
argument_list|(
name|pBuf
index|[
literal|6
index|]
operator|<<
literal|1
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|act
operator|->
name|button
operator||=
operator|(
operator|(
operator|~
name|pBuf
index|[
literal|7
index|]
operator|&
name|MOUSE_SYS_EXTBUTTONS
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/*       * We don't reset pBufP here yet, as there may be an additional data      * byte in some protocols. See above.      */
comment|/* has something changed? */
name|act
operator|->
name|flags
operator|=
operator|(
operator|(
name|act
operator|->
name|dx
operator|||
name|act
operator|->
name|dy
operator|||
name|act
operator|->
name|dz
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|act
operator|->
name|obutton
operator|^
name|act
operator|->
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|rodent
operator|.
name|flags
operator|&
name|Emulate3Button
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|act
operator|->
name|flags
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
operator|==
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
operator|&&
operator|(
operator|(
name|act
operator|->
name|button
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
operator|==
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
condition|)
block|{
name|act
operator|->
name|button
operator|&=
operator|~
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
expr_stmt|;
name|act
operator|->
name|button
operator||=
name|MOUSE_BUTTON2DOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|act
operator|->
name|obutton
operator|&
name|MOUSE_BUTTON2DOWN
operator|)
operator|&&
operator|(
operator|(
name|act
operator|->
name|button
operator|&
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
operator|!=
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
operator|)
condition|)
block|{
name|act
operator|->
name|button
operator|&=
operator|~
operator|(
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
operator|)
expr_stmt|;
block|}
name|act
operator|->
name|flags
operator|&=
name|MOUSE_POSCHANGED
expr_stmt|;
name|act
operator|->
name|flags
operator||=
name|act
operator|->
name|obutton
operator|^
name|act
operator|->
name|button
expr_stmt|;
block|}
return|return
name|act
operator|->
name|flags
return|;
block|}
end_function

begin_comment
comment|/* phisical to logical button mapping */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p2l
index|[
name|MOUSE_MAXBUTTON
index|]
init|=
block|{
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON4DOWN
block|,
name|MOUSE_BUTTON5DOWN
block|,
name|MOUSE_BUTTON6DOWN
block|,
name|MOUSE_BUTTON7DOWN
block|,
name|MOUSE_BUTTON8DOWN
block|,
literal|0x00000100
block|,
literal|0x00000200
block|,
literal|0x00000400
block|,
literal|0x00000800
block|,
literal|0x00001000
block|,
literal|0x00002000
block|,
literal|0x00004000
block|,
literal|0x00008000
block|,
literal|0x00010000
block|,
literal|0x00020000
block|,
literal|0x00040000
block|,
literal|0x00080000
block|,
literal|0x00100000
block|,
literal|0x00200000
block|,
literal|0x00400000
block|,
literal|0x00800000
block|,
literal|0x01000000
block|,
literal|0x02000000
block|,
literal|0x04000000
block|,
literal|0x08000000
block|,
literal|0x10000000
block|,
literal|0x20000000
block|,
literal|0x40000000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|skipspace
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|r_installmap
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pbutton
decl_stmt|;
name|int
name|lbutton
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|arg
operator|=
name|skipspace
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|s
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|++
name|arg
expr_stmt|;
name|arg
operator|=
name|skipspace
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|<=
name|s
operator|)
operator|||
operator|(
operator|*
name|arg
operator|!=
literal|'='
operator|)
condition|)
return|return
name|FALSE
return|;
name|lbutton
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|arg
operator|=
name|skipspace
argument_list|(
operator|++
name|arg
argument_list|)
expr_stmt|;
name|s
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|++
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|<=
name|s
operator|)
operator|||
operator|(
operator|!
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
operator|&&
operator|(
operator|*
name|arg
operator|!=
literal|'\0'
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|pbutton
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbutton
operator|<=
literal|0
operator|)
operator|||
operator|(
name|lbutton
operator|>
name|MOUSE_MAXBUTTON
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|pbutton
operator|<=
literal|0
operator|)
operator|||
operator|(
name|pbutton
operator|>
name|MOUSE_MAXBUTTON
operator|)
condition|)
return|return
name|FALSE
return|;
name|p2l
index|[
name|pbutton
operator|-
literal|1
index|]
operator|=
literal|1
operator|<<
operator|(
name|lbutton
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_map
parameter_list|(
name|mousestatus_t
modifier|*
name|act1
parameter_list|,
name|mousestatus_t
modifier|*
name|act2
parameter_list|)
block|{
specifier|register
name|int
name|pb
decl_stmt|;
specifier|register
name|int
name|pbuttons
decl_stmt|;
name|int
name|lbuttons
decl_stmt|;
name|pbuttons
operator|=
name|act1
operator|->
name|button
expr_stmt|;
name|lbuttons
operator|=
literal|0
expr_stmt|;
name|act2
operator|->
name|obutton
operator|=
name|act2
operator|->
name|button
expr_stmt|;
name|act2
operator|->
name|dx
operator|=
name|act1
operator|->
name|dx
expr_stmt|;
name|act2
operator|->
name|dy
operator|=
name|act1
operator|->
name|dy
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
name|act1
operator|->
name|dz
expr_stmt|;
switch|switch
condition|(
name|rodent
operator|.
name|zmap
condition|)
block|{
case|case
literal|0
case|:
comment|/* do nothing */
break|break;
case|case
name|MOUSE_XAXIS
case|:
if|if
condition|(
name|act1
operator|->
name|dz
operator|!=
literal|0
condition|)
block|{
name|act2
operator|->
name|dx
operator|=
name|act1
operator|->
name|dz
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_YAXIS
case|:
if|if
condition|(
name|act1
operator|->
name|dz
operator|!=
literal|0
condition|)
block|{
name|act2
operator|->
name|dy
operator|=
name|act1
operator|->
name|dz
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
comment|/* buttons */
name|pbuttons
operator|&=
operator|~
operator|(
name|rodent
operator|.
name|zmap
operator||
operator|(
name|rodent
operator|.
name|zmap
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|act1
operator|->
name|dz
operator|<
literal|0
condition|)
name|pbuttons
operator||=
name|rodent
operator|.
name|zmap
expr_stmt|;
elseif|else
if|if
condition|(
name|act1
operator|->
name|dz
operator|>
literal|0
condition|)
name|pbuttons
operator||=
operator|(
name|rodent
operator|.
name|zmap
operator|<<
literal|1
operator|)
expr_stmt|;
name|act2
operator|->
name|dz
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
name|pb
operator|=
literal|0
init|;
operator|(
name|pb
operator|<
name|MOUSE_MAXBUTTON
operator|)
operator|&&
operator|(
name|pbuttons
operator|!=
literal|0
operator|)
condition|;
operator|++
name|pb
control|)
block|{
name|lbuttons
operator||=
operator|(
name|pbuttons
operator|&
literal|1
operator|)
condition|?
name|p2l
index|[
name|pb
index|]
else|:
literal|0
expr_stmt|;
name|pbuttons
operator|>>=
literal|1
expr_stmt|;
block|}
name|act2
operator|->
name|button
operator|=
name|lbuttons
expr_stmt|;
name|act2
operator|->
name|flags
operator|=
operator|(
operator|(
name|act2
operator|->
name|dx
operator|||
name|act2
operator|->
name|dy
operator|||
name|act2
operator|->
name|dz
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|act2
operator|->
name|obutton
operator|^
name|act2
operator|->
name|button
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_click
parameter_list|(
name|mousestatus_t
modifier|*
name|act
parameter_list|)
block|{
name|struct
name|mouse_info
name|mouse
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|;
name|struct
name|timeval
name|tv2
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|int
name|button
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
name|act
operator|->
name|flags
operator|&
name|MOUSE_BUTTONS
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return;
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|tv2
operator|.
name|tv_sec
operator|=
name|rodent
operator|.
name|clickthreshold
operator|/
literal|1000
expr_stmt|;
name|tv2
operator|.
name|tv_usec
operator|=
operator|(
name|rodent
operator|.
name|clickthreshold
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"tv:  %ld %ld"
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|,
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|button
operator|=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MOUSE_MAXBUTTON
operator|)
operator|&&
operator|(
name|mask
operator|!=
literal|0
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|act
operator|->
name|button
operator|&
name|button
condition|)
block|{
comment|/* the button is down */
name|debug
argument_list|(
literal|"  :  %ld %ld"
argument_list|,
name|buttonstate
index|[
name|i
index|]
operator|.
name|tv
operator|.
name|tv_sec
argument_list|,
name|buttonstate
index|[
name|i
index|]
operator|.
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|buttonstate
index|[
name|i
index|]
operator|.
name|tv
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|buttonstate
index|[
name|i
index|]
operator|.
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|buttonstate
index|[
name|i
index|]
operator|.
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|buttonstate
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
name|buttonstate
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|value
operator|=
name|buttonstate
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
else|else
block|{
comment|/* the button is up */
name|buttonstate
index|[
name|i
index|]
operator|.
name|tv
operator|=
name|tv1
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|mouse
operator|.
name|operation
operator|=
name|MOUSE_BUTTON_EVENT
expr_stmt|;
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|id
operator|=
name|button
expr_stmt|;
if|if
condition|(
name|debug
operator|<
literal|2
condition|)
name|ioctl
argument_list|(
name|rodent
operator|.
name|cfd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|mouse
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"button %d  count %d"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|mouse
operator|.
name|u
operator|.
name|event
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|button
operator|<<=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* $XConsortium: posix_tty.c,v 1.3 95/01/05 20:42:55 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/shared/posix_tty.c,v 3.4 1995/01/28 17:05:03 dawes Exp $ */
end_comment

begin_comment
comment|/*  * Copyright 1993 by David Dawes<dawes@physics.su.oz.au>  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of David Dawes   * not be used in advertising or publicity pertaining to distribution of   * the software without specific, written prior permission.  * David Dawes makes no representations about the suitability of this   * software for any purpose.  It is provided "as is" without express or   * implied warranty.  *  * DAVID DAWES DISCLAIMS ALL WARRANTIES WITH REGARD TO   * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND   * FITNESS, IN NO EVENT SHALL DAVID DAWES BE LIABLE FOR   * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF   * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_function
specifier|static
name|void
name|setmousespeed
parameter_list|(
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|,
name|unsigned
name|cflag
parameter_list|)
block|{
name|struct
name|termios
name|tty
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logwarn
argument_list|(
literal|"unable to get status of mouse fd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|tty
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|tty
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_cflag
operator|=
operator|(
name|tcflag_t
operator|)
name|cflag
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|old
condition|)
block|{
case|case
literal|9600
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1200
case|:
default|default:
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logwarn
argument_list|(
literal|"unable to set status of mouse fd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|new
condition|)
block|{
case|case
literal|9600
case|:
name|c
operator|=
literal|"*q"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|c
operator|=
literal|"*p"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B4800
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|c
operator|=
literal|"*o"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B2400
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1200
case|:
default|default:
name|c
operator|=
literal|"*n"
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|tty
argument_list|,
name|B1200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_LOGIMOUSEMAN
operator|||
name|rodent
operator|.
name|rtype
operator|==
name|MOUSE_PROTO_LOGI
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|c
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|logwarn
argument_list|(
literal|"unable to write to mouse fd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
name|logwarn
argument_list|(
literal|"unable to set status of mouse fd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * PnP COM device support   *   * It's a simplistic implementation, but it works :-)  * KY, 31/7/97.  */
end_comment

begin_comment
comment|/*  * Try to elicit a PnP ID as described in   * Microsoft, Hayes: "Plug and Play External COM Device Specification,   * rev 1.00", 1995.  *  * The routine does not fully implement the COM Enumerator as par Section  * 2.1 of the document.  In particular, we don't have idle state in which  * the driver software monitors the com port for dynamic connection or   * removal of a device at the port, because `moused' simply quits if no   * device is found.  *  * In addition, as PnP COM device enumeration procedure slightly has   * changed since its first publication, devices which follow earlier  * revisions of the above spec. may fail to respond if the rev 1.0   * procedure is used. XXX  */
end_comment

begin_function
specifier|static
name|int
name|pnpgets
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
if|#
directive|if
literal|0
comment|/*       * This is the procedure described in rev 1.0 of PnP COM device spec.      * Unfortunately, some devices which comform to earlier revisions of      * the spec gets confused and do not return the ID string...      */
comment|/* port initialization (2.1.2) */
block|ioctl(rodent.mfd, TIOCMGET,&i);     i |= TIOCM_DTR;
comment|/* DTR = 1 */
block|i&= ~TIOCM_RTS;
comment|/* RTS = 0 */
block|ioctl(rodent.mfd, TIOCMSET,&i);     usleep(200000);     if ((ioctl(rodent.mfd, TIOCMGET,&i) == -1) || ((i& TIOCM_DSR) == 0)) 	goto disconnect_idle;
comment|/* port setup, 1st phase (2.1.3) */
block|setmousespeed(1200, 1200, (CS7 | CREAD | CLOCAL | HUPCL));     i = TIOCM_DTR | TIOCM_RTS;
comment|/* DTR = 0, RTS = 0 */
block|ioctl(rodent.mfd, TIOCMBIC,&i);     usleep(200000);     i = TIOCM_DTR;
comment|/* DTR = 1, RTS = 0 */
block|ioctl(rodent.mfd, TIOCMBIS,&i);     usleep(200000);
comment|/* wait for response, 1st phase (2.1.4) */
block|i = FREAD;     ioctl(rodent.mfd, TIOCFLUSH,&i);     i = TIOCM_RTS;
comment|/* DTR = 1, RTS = 1 */
block|ioctl(rodent.mfd, TIOCMBIS,&i);
comment|/* try to read something */
block|FD_ZERO(&fds);     FD_SET(rodent.mfd,&fds);     timeout.tv_sec = 0;     timeout.tv_usec = 200000;     if (select(FD_SETSIZE,&fds, NULL, NULL,&timeout)<= 0) {
comment|/* port setup, 2nd phase (2.1.5) */
block|i = TIOCM_DTR | TIOCM_RTS;
comment|/* DTR = 0, RTS = 0 */
block|ioctl(rodent.mfd, TIOCMBIC,&i);         usleep(200000);
comment|/* wait for respose, 2nd phase (2.1.6) */
block|i = FREAD;         ioctl(rodent.mfd, TIOCFLUSH,&i);         i = TIOCM_DTR | TIOCM_RTS;
comment|/* DTR = 1, RTS = 1 */
block|ioctl(rodent.mfd, TIOCMBIS,&i);
comment|/* try to read something */
block|FD_ZERO(&fds);         FD_SET(rodent.mfd,&fds);         timeout.tv_sec = 0;         timeout.tv_usec = 200000;         if (select(FD_SETSIZE,&fds, NULL, NULL,&timeout)<= 0) 	    goto connect_idle;     }
else|#
directive|else
comment|/*      * This is a simplified procedure; it simply toggles RTS.      */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMGET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator||=
name|TIOCM_DTR
expr_stmt|;
comment|/* DTR = 1 */
name|i
operator|&=
operator|~
name|TIOCM_RTS
expr_stmt|;
comment|/* RTS = 0 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMSET
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
name|setmousespeed
argument_list|(
literal|1200
argument_list|,
literal|1200
argument_list|,
operator|(
name|CS7
operator||
name|CREAD
operator||
name|CLOCAL
operator||
name|HUPCL
operator|)
argument_list|)
expr_stmt|;
comment|/* wait for respose */
name|i
operator|=
name|FREAD
expr_stmt|;
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 1, RTS = 1 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* try to read something */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|200000
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|connect_idle
goto|;
endif|#
directive|endif
comment|/* collect PnP COM device ID (2.1.7) */
name|i
operator|=
literal|0
expr_stmt|;
name|usleep
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
comment|/* the mouse must send `Begin ID' within 200msec */
while|while
condition|(
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* we may see "M", or "M3..." before `Begin ID' */
if|if
condition|(
operator|(
name|c
operator|==
literal|0x08
operator|)
operator|||
operator|(
name|c
operator|==
literal|0x28
operator|)
condition|)
block|{
comment|/* Begin ID */
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|debug
argument_list|(
literal|"%c %02x"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
comment|/* we haven't seen `Begin ID' in time... */
goto|goto
name|connect_idle
goto|;
block|}
operator|++
name|c
expr_stmt|;
comment|/* make it `End ID' */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|200000
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|read
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|++
index|]
operator|==
name|c
condition|)
comment|/* End ID */
break|break;
if|if
condition|(
name|i
operator|>=
literal|256
condition|)
break|break;
block|}
comment|/* string may not be human readable... */
name|debug
argument_list|(
literal|"'%-*.*s'"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|c
condition|)
goto|goto
name|connect_idle
goto|;
return|return
name|i
return|;
comment|/*      * According to PnP spec, we should set DTR = 1 and RTS = 0 while       * in idle state.  But, `moused' shall set DTR = RTS = 1 and proceed,       * assuming there is something at the port even if it didn't       * respond to the PnP enumeration procedure.      */
name|disconnect_idle
label|:
name|i
operator|=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
comment|/* DTR = 1, RTS = 1 */
name|ioctl
argument_list|(
name|rodent
operator|.
name|mfd
argument_list|,
name|TIOCMBIS
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|connect_idle
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pnpparse
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|s
index|[
literal|3
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|id
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|eisaid
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|serial
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|class
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|compat
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|description
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|neisaid
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|nserial
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|nclass
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|ncompat
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|ndescription
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0x28
operator|-
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* calculate checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|+=
name|offset
expr_stmt|;
block|}
name|sum
operator|+=
name|buf
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|+=
name|offset
expr_stmt|;
name|debug
argument_list|(
literal|"PnP ID string: '%*.*s'"
argument_list|,
name|len
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* revision */
name|buf
index|[
literal|1
index|]
operator|-=
name|offset
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|-=
name|offset
expr_stmt|;
name|id
operator|->
name|revision
operator|=
operator|(
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|"PnP rev %d.%02d"
argument_list|,
name|id
operator|->
name|revision
operator|/
literal|100
argument_list|,
name|id
operator|->
name|revision
operator|%
literal|100
argument_list|)
expr_stmt|;
comment|/* EISA vender and product ID */
name|id
operator|->
name|eisaid
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|id
operator|->
name|neisaid
operator|=
literal|7
expr_stmt|;
comment|/* option strings */
name|i
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* device serial # */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|-
name|j
operator|==
literal|8
condition|)
block|{
name|id
operator|->
name|serial
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|nserial
operator|=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* PnP class */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|id
operator|->
name|class
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|nclass
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* compatible driver */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
comment|/* 	 * PnP COM spec prior to v0.96 allowed '*' in this field,  	 * it's not allowed now; just igore it. 	 */
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|==
literal|'*'
condition|)
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|id
operator|->
name|compat
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|ncompat
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* product description */
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|';'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|len
condition|)
name|i
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|+
literal|1
condition|)
block|{
name|id
operator|->
name|description
operator|=
operator|&
name|buf
index|[
name|j
index|]
expr_stmt|;
name|id
operator|->
name|ndescription
operator|=
name|i
operator|-
name|j
expr_stmt|;
block|}
block|}
comment|/* checksum exists if there are any optional fields */
if|if
condition|(
operator|(
name|id
operator|->
name|nserial
operator|>
literal|0
operator|)
operator|||
operator|(
name|id
operator|->
name|nclass
operator|>
literal|0
operator|)
operator|||
operator|(
name|id
operator|->
name|ncompat
operator|>
literal|0
operator|)
operator|||
operator|(
name|id
operator|->
name|ndescription
operator|>
literal|0
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|"PnP checksum: 0x%X"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%02X"
argument_list|,
name|sum
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
operator|&
name|buf
index|[
name|len
operator|-
literal|3
index|]
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 	     * I found some mice do not comply with the PnP COM device  	     * spec regarding checksum... XXX 	     */
block|logwarnx("PnP checksum error", 0); 	    return FALSE;
endif|#
directive|endif
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|symtab_t
modifier|*
name|pnpproto
parameter_list|(
name|pnpid_t
modifier|*
name|id
parameter_list|)
block|{
name|symtab_t
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|nclass
operator|>
literal|0
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|id
operator|->
name|class
argument_list|,
literal|"MOUSE"
argument_list|,
name|id
operator|->
name|nclass
argument_list|)
operator|!=
literal|0
condition|)
comment|/* this is not a mouse! */
return|return
name|NULL
return|;
if|if
condition|(
name|id
operator|->
name|neisaid
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|gettoken
argument_list|(
name|pnpprod
argument_list|,
name|id
operator|->
name|eisaid
argument_list|,
name|id
operator|->
name|neisaid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|val
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
return|return
name|t
return|;
block|}
comment|/*      * The 'Compatible drivers' field may contain more than one      * ID separated by ','.      */
if|if
condition|(
name|id
operator|->
name|ncompat
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|->
name|ncompat
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|id
operator|->
name|compat
index|[
name|i
index|]
operator|!=
literal|','
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|>=
name|id
operator|->
name|ncompat
condition|)
break|break;
if|if
condition|(
name|i
operator|>
name|j
condition|)
block|{
name|t
operator|=
name|gettoken
argument_list|(
name|pnpprod
argument_list|,
name|id
operator|->
name|compat
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|val
operator|!=
name|MOUSE_PROTO_UNKNOWN
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* name/val mapping */
end_comment

begin_function
specifier|static
name|symtab_t
modifier|*
name|gettoken
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|&
name|tab
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gettokenname
parameter_list|(
name|symtab_t
modifier|*
name|tab
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tab
index|[
name|i
index|]
operator|.
name|val
operator|==
name|val
condition|)
return|return
name|tab
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

