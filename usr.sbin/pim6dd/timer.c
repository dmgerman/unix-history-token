begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Oregon.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Oregon.  *  The name of the University of Oregon may not be used to endorse or   *  promote products derived from this software without specific prior   *  written permission.  *  *  THE UNIVERSITY OF OREGON DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND   *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL UO, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to   *  Kurt Windisch (kurtw@antc.uoregon.edu)  *  *  $Id: timer.c,v 1.5 2000/05/18 16:09:39 itojun Exp $  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from PIM sparse-mode pimd.  * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *    * The pimd program is COPYRIGHT 1998 by University of Southern California.  *  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *   * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Global variables  */
end_comment

begin_comment
comment|/*  * Local functions definitions.  */
end_comment

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
name|u_int16
name|unicast_routing_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to check periodically for any 				   * change in the unicast routing. 				   */
end_comment

begin_decl_stmt
name|u_int16
name|unicast_routing_check_interval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|ucast_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to indicate there was a timeout */
end_comment

begin_comment
comment|/* to request and compare any route changes */
end_comment

begin_decl_stmt
name|srcentry_t
name|srcentry_save
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Init some timers  */
end_comment

begin_function
name|void
name|init_timers
parameter_list|()
block|{
name|unicast_routing_check_interval
operator|=
name|UCAST_ROUTING_CHECK_INTERVAL
expr_stmt|;
name|unicast_routing_timer
operator|=
name|unicast_routing_check_interval
expr_stmt|;
comment|/* Initialize the srcentry used to save the old routes      * during unicast routing change discovery process.      */
name|srcentry_save
operator|.
name|prev
operator|=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|srcentry_save
operator|.
name|next
operator|=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|srcentry_save
operator|.
name|address
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|srcentry_save
operator|.
name|address
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|srcentry_save
operator|.
name|address
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|srcentry_save
operator|.
name|mrtlink
operator|=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|srcentry_save
operator|.
name|incoming
operator|=
name|NO_VIF
expr_stmt|;
name|srcentry_save
operator|.
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|srcentry_save
operator|.
name|metric
operator|=
operator|~
literal|0
expr_stmt|;
name|srcentry_save
operator|.
name|preference
operator|=
operator|~
literal|0
expr_stmt|;
name|srcentry_save
operator|.
name|timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance (i.e. decrease) the timer for each  * neighbor and group entry for each vif.  */
end_comment

begin_function
name|void
name|age_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|next_nbr
decl_stmt|,
modifier|*
name|curr_nbr
decl_stmt|;
comment|/* XXX: TODO: currently, sending to qe* interface which is DOWN  * doesn't return error (ENETDOWN) on my Solaris machine,  * so have to check periodically the   * interfaces status. If this is fixed, just remove the defs around  * the "if (vifs_down)" line.  */
if|#
directive|if
operator|(
operator|!
operator|(
operator|(
name|defined
name|SunOS
operator|)
operator|&&
operator|(
name|SunOS
operator|>=
literal|50
operator|)
operator|)
operator|)
if|if
condition|(
name|vifs_down
condition|)
endif|#
directive|endif
comment|/* Solaris */
name|check_vif_state
argument_list|()
expr_stmt|;
comment|/* Age many things */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator|)
condition|)
continue|continue;
comment|/* Timeout the MLD querier (unless we re the querier) */
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
operator|)
operator|==
literal|0
operator|&&
name|v
operator|->
name|uv_querier
condition|)
block|{
comment|/* this must be non-NULL, but check for safety. */
name|IF_TIMEOUT
argument_list|(
argument|v->uv_querier->al_timer
argument_list|)
block|{
comment|/* act as a querier by myself */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
operator|=
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
operator|=
name|MLD6_OTHER_QUERIER_PRESENT_INTERVAL
expr_stmt|;
name|time
argument_list|(
operator|&
name|v
operator|->
name|uv_querier
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
comment|/* reset timestamp */
name|query_groups
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Timeout neighbors */
for|for
control|(
name|curr_nbr
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|curr_nbr
operator|!=
name|NULL
condition|;
name|curr_nbr
operator|=
name|next_nbr
control|)
block|{
name|next_nbr
operator|=
name|curr_nbr
operator|->
name|next
expr_stmt|;
comment|/* 	     * Never timeout neighbors with holdtime = 0xffff. 	     * This may be used with ISDN lines to avoid keeping the 	     * link up with periodic Hello messages. 	     */
if|if
condition|(
name|PIM_MESSAGE_HELLO_HOLDTIME_FOREVER
operator|==
name|curr_nbr
operator|->
name|timer
condition|)
continue|continue;
name|IF_NOT_TIMEOUT
argument_list|(
argument|curr_nbr->timer
argument_list|)
continue|continue;
name|delete_pim6_nbr
argument_list|(
name|curr_nbr
argument_list|)
expr_stmt|;
block|}
comment|/* PIM_HELLO periodic */
name|IF_TIMEOUT
argument_list|(
argument|v->uv_pim_hello_timer
argument_list|)
name|send_pim6_hello
argument_list|(
name|v
argument_list|,
name|PIM_TIMER_HELLO_HOLDTIME
argument_list|)
expr_stmt|;
comment|/* MLD query periodic */
name|IF_TIMEOUT
argument_list|(
argument|v->uv_gq_timer
argument_list|)
name|query_groups
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
block|{
name|dump_vifs
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|dump_lcl_grp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Scan the whole routing table and timeout a bunch of timers:  *  - prune timers  *  - Join/Prune delay timer  *  - routing entry  *  - Assert timer  */
end_comment

begin_function
name|void
name|age_routes
parameter_list|()
block|{
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|,
modifier|*
name|mrtentry_next
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|,
modifier|*
name|grpentry_next
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|change_flag
decl_stmt|,
name|state_change
decl_stmt|;
name|int
name|update_src_iif
decl_stmt|;
name|u_long
name|curr_bytecnt
decl_stmt|;
comment|/*      * Timing out of the global `unicast_routing_timer` and data rate timer      */
name|IF_TIMEOUT
argument_list|(
argument|unicast_routing_timer
argument_list|)
block|{
name|ucast_flag
operator|=
name|TRUE
expr_stmt|;
name|unicast_routing_timer
operator|=
name|unicast_routing_check_interval
expr_stmt|;
block|}
name|ELSE
block|{
name|ucast_flag
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Walk the (S,G) entries */
if|if
condition|(
name|grplist
operator|==
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
for|for
control|(
name|grpentry_ptr
operator|=
name|grplist
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_next
control|)
block|{
name|grpentry_next
operator|=
name|grpentry_ptr
operator|->
name|next
expr_stmt|;
for|for
control|(
name|mrtentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_next
control|)
block|{
name|mrtentry_next
operator|=
name|mrtentry_ptr
operator|->
name|grpnext
expr_stmt|;
comment|/* Refresh entry timer if data forwarded */
name|curr_bytecnt
operator|=
name|mrtentry_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
expr_stmt|;
if|if
condition|(
name|k_get_sg_cnt
argument_list|(
name|udp_socket
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|sg_count
argument_list|)
condition|)
block|{
comment|/* No such routing entry in kernel */
name|delete_mrtentry
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
operator|)
operator|&&
name|curr_bytecnt
operator|!=
name|mrtentry_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
condition|)
block|{
comment|/* Packets have been forwarded - refresh timer 		 * Note that these counters count packets received,  		 * not packets forwarded.  So only refresh if packets 		 * received and non-null oiflist. 		 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_MFC
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Refreshing src %s, dst %s after %d bytes forwarded"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mrtentry_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|PIM_DATA_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Time out the entry */
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_ptr->timer
argument_list|)
block|{
name|delete_mrtentry
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Time out asserts */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_ASSERTED
condition|)
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_ptr->assert_timer
argument_list|)
block|{
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_ASSERTED
expr_stmt|;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|preference
expr_stmt|;
block|}
comment|/* Time out Pruned interfaces */
name|change_flag
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
condition|)
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_ptr->prune_timers[vifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|vifi
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Unicast Route changes */
name|update_src_iif
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ucast_flag
operator|==
name|TRUE
condition|)
block|{
comment|/* iif toward the source */
name|srcentry_save
operator|.
name|incoming
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|incoming
expr_stmt|;
name|srcentry_save
operator|.
name|upstream
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
name|srcentry_save
operator|.
name|preference
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|preference
expr_stmt|;
name|srcentry_save
operator|.
name|metric
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|metric
expr_stmt|;
if|if
condition|(
name|set_incoming
argument_list|(
name|mrtentry_ptr
operator|->
name|source
argument_list|,
name|PIM_IIF_SOURCE
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
comment|/* 		     * XXX: not in the spec! 		     * Cannot find route toward that source. 		     * This is bad. Delete the entry. 		     */
name|delete_mrtentry
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* iif info found */
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_ASSERTED
operator|)
operator|&&
operator|(
operator|(
name|srcentry_save
operator|.
name|incoming
operator|!=
name|mrtentry_ptr
operator|->
name|incoming
operator|)
operator|||
operator|(
name|srcentry_save
operator|.
name|upstream
operator|!=
name|mrtentry_ptr
operator|->
name|upstream
operator|)
operator|)
condition|)
block|{
comment|/* Route change has occur */
name|update_src_iif
operator|=
name|TRUE
expr_stmt|;
name|mrtentry_ptr
operator|->
name|incoming
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|incoming
expr_stmt|;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
comment|/* mrtentry should have pref/metric of upstream 			 * assert winner, but we dont have that info, 			 * so use the source pref/metric, which will be 			 * larger and thus the correct assert winner 			 * from upstream will be chosen. 			 */
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|preference
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|metric
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|change_flag
operator|==
name|TRUE
operator|)
operator|||
operator|(
name|update_src_iif
operator|==
name|TRUE
operator|)
condition|)
block|{
comment|/* Flush the changes */
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_change
operator|==
operator|-
literal|1
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_MRT
argument_list|)
name|dump_pim_mrt
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

