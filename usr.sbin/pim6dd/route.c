begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Oregon.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Oregon.  *  The name of the University of Oregon may not be used to endorse or  *  promote products derived from this software without specific prior  *  written permission.  *  *  THE UNIVERSITY OF OREGON DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL UO, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Kurt Windisch (kurtw@antc.uoregon.edu)  *  *  $Id: route.c,v 1.3 1999/10/27 11:40:30 jinmei Exp $  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from PIM sparse-mode pimd.  * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  * The pimd program is COPYRIGHT 1998 by University of Southern California.  *  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|static
name|u_int16
name|max_prune_timeout
name|__P
argument_list|(
operator|(
name|mrtentry_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_cache_miss
name|__P
argument_list|(
operator|(
expr|struct
name|mrt6msg
operator|*
name|im
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_wrong_iif
name|__P
argument_list|(
operator|(
expr|struct
name|mrt6msg
operator|*
name|im
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|default_source_preference
init|=
name|DEFAULT_LOCAL_PREF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|default_source_metric
init|=
name|DEFAULT_LOCAL_METRIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the iif for given address */
end_comment

begin_function
name|vifi_t
name|get_iif
parameter_list|(
name|address
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|address
decl_stmt|;
block|{
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|k_req_incoming
argument_list|(
name|address
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|NO_VIF
operator|)
return|;
return|return
operator|(
name|rpfc
operator|.
name|iif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the PIM neighbor toward a source */
end_comment

begin_comment
comment|/* If route not found or if a local source or if a directly connected source,  * but is not PIM router, or if the first hop router is not a PIM router,  * then return NULL.  */
end_comment

begin_function
name|pim_nbr_entry_t
modifier|*
name|find_pim6_nbr
parameter_list|(
name|source
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
block|{
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|next_hop_router_addr
decl_stmt|;
if|if
condition|(
name|local_address
argument_list|(
name|source
argument_list|)
operator|!=
name|NO_VIF
condition|)
return|return
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
return|;
name|k_req_incoming
argument_list|(
name|source
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
operator|)
operator|||
operator|(
name|rpfc
operator|.
name|iif
operator|==
name|NO_VIF
operator|)
condition|)
return|return
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
return|;
name|next_hop_router_addr
operator|=
operator|&
name|rpfc
operator|.
name|rpfneighbor
expr_stmt|;
for|for
control|(
name|pim_nbr
operator|=
name|uvifs
index|[
name|rpfc
operator|.
name|iif
index|]
operator|.
name|uv_pim_neighbors
init|;
name|pim_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|;
name|pim_nbr
operator|=
name|pim_nbr
operator|->
name|next
control|)
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|pim_nbr
operator|->
name|address
argument_list|,
name|next_hop_router_addr
argument_list|)
condition|)
return|return
operator|(
name|pim_nbr
operator|)
return|;
return|return
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* TODO: check again the exact setup if the source is local or directly  * connected!!!  */
end_comment

begin_comment
comment|/* TODO: XXX: change the metric and preference for all (S,G) entries per  * source?  */
end_comment

begin_comment
comment|/* PIMDM TODO - If possible, this would be the place to correct set the  * source's preference and metric to that obtained from the kernel  * and/or unicast routing protocol.  For now, set it to the configured  * default for local pref/metric.  */
end_comment

begin_comment
comment|/*  * Set the iif, upstream router, preference and metric for the route  * toward the source. Return TRUE is the route was found, othewise FALSE.  * If srctype==PIM_IIF_SOURCE and if the source is directly connected  * then the "upstream" is set to NULL.  * Note that srctype is a hold-over from the PIM-SM daemon and is unused.  */
end_comment

begin_function
name|int
name|set_incoming
parameter_list|(
name|srcentry_ptr
parameter_list|,
name|srctype
parameter_list|)
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
name|int
name|srctype
decl_stmt|;
block|{
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|source
init|=
operator|&
name|srcentry_ptr
operator|->
name|address
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|neighbor_addr
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|n
decl_stmt|;
comment|/* Preference will be 0 if directly connected */
name|srcentry_ptr
operator|->
name|preference
operator|=
literal|0
expr_stmt|;
name|srcentry_ptr
operator|->
name|metric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srcentry_ptr
operator|->
name|incoming
operator|=
name|local_address
argument_list|(
name|source
argument_list|)
operator|)
operator|!=
name|NO_VIF
condition|)
block|{
comment|/* The source is a local address */
comment|/* TODO: set the upstream to myself? */
name|srcentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|srcentry_ptr
operator|->
name|incoming
operator|=
name|find_vif_direct
argument_list|(
name|source
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* TODO: probably need to check the case if the iif is disabled */
comment|/* Use the lastest resource: the kernel unicast routing table */
name|k_req_incoming
argument_list|(
name|source
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rpfc
operator|.
name|iif
operator|==
name|NO_VIF
operator|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* couldn't find a route */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_MRT | DEBUG_RPF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"NO ROUTE found for %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|srcentry_ptr
operator|->
name|incoming
operator|=
name|rpfc
operator|.
name|iif
expr_stmt|;
name|neighbor_addr
operator|=
operator|&
name|rpfc
operator|.
name|rpfneighbor
expr_stmt|;
block|}
else|else
block|{
comment|/* The source is directly connected. 	 */
name|srcentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* set the preference for sources that aren't directly connected. */
name|v
operator|=
operator|&
name|uvifs
index|[
name|srcentry_ptr
operator|->
name|incoming
index|]
expr_stmt|;
name|srcentry_ptr
operator|->
name|preference
operator|=
name|v
operator|->
name|uv_local_pref
expr_stmt|;
name|srcentry_ptr
operator|->
name|metric
operator|=
name|v
operator|->
name|uv_local_metric
expr_stmt|;
comment|/*      * The upstream router must be a (PIM router) neighbor, otherwise we      * are in big trouble ;-)      */
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|inet6_lessthan
argument_list|(
name|neighbor_addr
argument_list|,
operator|&
name|n
operator|->
name|address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
name|neighbor_addr
argument_list|,
operator|&
name|n
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* 	     *The upstream router is found in the list of neighbors. 	     * We are safe! 	     */
name|srcentry_ptr
operator|->
name|upstream
operator|=
name|n
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_RPF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"For src %s, iif is %d, next hop router is %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|neighbor_addr
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
break|break;
block|}
comment|/* TODO: control the number of messages! */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"For src %s, iif is %d, next hop router is %s: NOT A PIM ROUTER"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|neighbor_addr
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|srcentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the leaves in a new mrtentry */
end_comment

begin_function
name|void
name|set_leaves
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
comment|/* Check for a group report on each vif */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
if|if
condition|(
name|check_multicast_listener
argument_list|(
name|v
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
argument_list|)
condition|)
name|IF_SET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle new receiver  *  * TODO: XXX: currently `source` is not used. Will be used with IGMPv3 where  * we have source-specific Join/Prune.  */
end_comment

begin_function
name|void
name|add_leaf
parameter_list|(
name|vifi
parameter_list|,
name|source
parameter_list|,
name|group
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|if_set
name|new_leaves
decl_stmt|;
name|int
name|state_change
decl_stmt|;
name|grpentry_ptr
operator|=
name|find_group
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|grpentry_ptr
operator|==
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* walk the source list for the group and add vif to oiflist */
for|for
control|(
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
comment|/* if applicable, add the vif to the leaves */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|incoming
operator|==
name|vifi
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|)
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_MRT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Adding leaf vif %d for src %s group %s"
argument_list|,
name|vifi
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|vifi
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
comment|/* Add the leaf */
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* Handle transition from negative cache */
if|if
condition|(
name|state_change
operator|==
literal|1
condition|)
name|trigger_join_alert
argument_list|(
name|mrtentry_srcs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * TODO: XXX: currently `source` is not used. To be used with IGMPv3 where  * we have source-specific joins/prunes.  */
end_comment

begin_function
name|void
name|delete_leaf
parameter_list|(
name|vifi
parameter_list|,
name|source
parameter_list|,
name|group
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|if_set
name|new_leaves
decl_stmt|;
name|int
name|state_change
decl_stmt|;
comment|/* mrtentry_t *mrtentry_ptr;      * mrtentry_t *mrtentry_srcs;      * vifbitmap_t new_oifs;      * vifbitmap_t old_oifs;      * vifbitmap_t new_leaves;      */
name|grpentry_ptr
operator|=
name|find_group
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|grpentry_ptr
operator|==
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* walk the source list for the group and delete vif to leaves */
for|for
control|(
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
comment|/* if applicable, delete the vif from the leaves */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|incoming
operator|==
name|vifi
condition|)
continue|continue;
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_MRT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Deleting leaf vif %d for src %s, group %s"
argument_list|,
name|vifi
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
comment|/* Remove the leaf */
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* Handle transition to negative cache */
if|if
condition|(
name|state_change
operator|==
operator|-
literal|1
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_srcs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|calc_oifs
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|oifs_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|if_set
modifier|*
name|oifs_ptr
decl_stmt|;
block|{
name|if_set
name|oifs
decl_stmt|;
comment|/*      * oifs =      * ((nbr_ifs - my_prune) + my_leaves) - my_filters - incoming_interface,      * i.e.`leaves` have higher priority than `prunes`, but lower than `filters'.      * Asserted oifs (those that lost assert) are handled as pruned oifs.      * The incoming interface is always deleted from the oifs      */
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|IF_ZERO
argument_list|(
name|oifs_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_COPY
argument_list|(
operator|&
name|nbr_mifs
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|filter_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|oifs
argument_list|,
name|oifs_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the iif, join/prune/leaves/asserted interfaces. Calculate and  * set the oifs.  * Return 1 if oifs change from NULL to not-NULL.  * Return -1 if oifs change from non-NULL to NULL  *  else return 0  * If the iif change or if the oifs change from NULL to non-NULL  * or vice-versa, then schedule that mrtentry join/prune timer to  * timeout immediately.  */
end_comment

begin_function
name|int
name|change_interfaces
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|new_iif
parameter_list|,
name|new_pruned_oifs
parameter_list|,
name|new_leaves_
parameter_list|,
name|new_asserted_oifs
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|vifi_t
name|new_iif
decl_stmt|;
name|if_set
modifier|*
name|new_pruned_oifs
decl_stmt|;
name|if_set
modifier|*
name|new_leaves_
decl_stmt|;
name|if_set
modifier|*
name|new_asserted_oifs
decl_stmt|;
block|{
name|if_set
name|old_pruned_oifs
decl_stmt|;
comment|/* unnecessary? */
name|if_set
name|old_leaves
decl_stmt|;
comment|/* unnecessary? */
name|if_set
name|new_leaves
decl_stmt|;
name|if_set
name|new_real_oifs
decl_stmt|;
comment|/* The result oifs */
name|if_set
name|old_real_oifs
decl_stmt|;
name|if_set
name|old_asserted_oifs
decl_stmt|;
comment|/* unnecessary? */
name|vifi_t
name|old_iif
decl_stmt|;
name|int
name|return_value
decl_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IF_COPY
argument_list|(
name|new_leaves_
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|old_iif
operator|=
name|mrtentry_ptr
operator|->
name|incoming
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|old_leaves
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|old_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
operator|&
name|old_asserted_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|,
operator|&
name|old_real_oifs
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|incoming
operator|=
name|new_iif
expr_stmt|;
name|IF_COPY
argument_list|(
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
name|new_asserted_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|new_real_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|old_real_oifs
argument_list|)
condition|)
block|{
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
name|return_value
operator|=
literal|0
expr_stmt|;
else|else
name|return_value
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
name|return_value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|return_value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IF_SAME
argument_list|(
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|old_real_oifs
argument_list|)
operator|)
operator|&&
operator|(
name|new_iif
operator|==
name|old_iif
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Nothing to change */
name|IF_COPY
argument_list|(
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
expr_stmt|;
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
argument_list|,
name|new_iif
argument_list|,
operator|&
name|new_real_oifs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TODO: implement it. Required to allow changing of the physical interfaces  * configuration without need to restart pimd.  */
end_comment

begin_function
name|int
name|delete_vif_from_mrt
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16
name|max_prune_timeout
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: I don't understand how the variable works...(jinmei@kame.net) */
block|u_int16 time_left = 0;
endif|#
directive|endif
name|u_int16
name|max_holdtime
init|=
literal|0
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
control|)
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
operator|&&
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|vifi
index|]
condition|)
comment|/* XXX - too expensive ? */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|vifi
index|]
operator|>
name|max_holdtime
condition|)
name|max_holdtime
operator|=
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|vifi
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: This is original. But does it have any meaning? */
block|max_holdtime = time_left;
endif|#
directive|endif
if|if
condition|(
name|max_holdtime
operator|==
literal|0
condition|)
name|max_holdtime
operator|=
operator|(
name|u_int16
operator|)
name|PIM_JOIN_PRUNE_HOLDTIME
expr_stmt|;
return|return
operator|(
name|max_holdtime
operator|)
return|;
block|}
end_function

begin_function
name|void
name|process_kernel_call
parameter_list|()
block|{
specifier|register
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
comment|/* igmpmsg control struct */
name|im
operator|=
operator|(
expr|struct
name|mrt6msg
operator|*
operator|)
name|mld6_recv_buf
expr_stmt|;
switch|switch
condition|(
name|im
operator|->
name|im6_msgtype
condition|)
block|{
case|case
name|MRT6MSG_NOCACHE
case|:
name|process_cache_miss
argument_list|(
name|im
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6MSG_WRONGMIF
case|:
name|process_wrong_iif
argument_list|(
name|im
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IF_DEBUG
argument_list|(
argument|DEBUG_KERN
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Unknown kernel_call code, %d"
argument_list|,
name|im
operator|->
name|im6_msgtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Protocol actions:  *   1. Create (S,G) entry (find_route(CREATE))  *      a. set iif and oifs  */
end_comment

begin_function
specifier|static
name|void
name|process_cache_miss
parameter_list|(
name|im
parameter_list|)
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
block|{
specifier|static
name|struct
name|sockaddr_in6
name|source
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|group
init|=
block|{
sizeof|sizeof
argument_list|(
name|group
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
comment|/*      * When there is a cache miss, we check only the header of the packet      * (and only it should be sent up by the kernel.      */
name|group
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_dst
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_src
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|uvifs
index|[
name|im
operator|->
name|im6_mif
index|]
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|uvifs
index|[
name|im
operator|->
name|im6_mif
index|]
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_MFC
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Cache miss, src %s, dst %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't create routing entries for the LAN scoped addresses */
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
operator|||
comment|/* sanity? */
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return;
comment|/* Create the (S,G) entry */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
comment|/* Set oifs */
name|set_leaves
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
operator|(
name|mrtentry_ptr
operator|->
name|oifs
operator|)
argument_list|)
expr_stmt|;
comment|/* Add it to the kernel */
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
comment|/* No need to call change_interfaces, but check for NULL oiflist */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A multicast packet has been received on wrong iif by the kernel.  * If the packet was received on a point-to-point interface, rate-limit  * prunes.  if the packet was received on a LAN interface, rate-limit  * asserts.  */
end_comment

begin_function
specifier|static
name|void
name|process_wrong_iif
parameter_list|(
name|im
parameter_list|)
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
block|{
specifier|static
name|struct
name|sockaddr_in6
name|source
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|group
init|=
block|{
sizeof|sizeof
argument_list|(
name|group
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_dst
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_src
expr_stmt|;
name|mifi
operator|=
operator|(
name|mifi_t
operator|)
name|im
operator|->
name|im6_mif
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
comment|/* PIMDM TODO Don't create routing entries for the LAN scoped addresses */
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
operator|||
comment|/* sanity? */
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Ratelimit prunes or asserts */
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
block|{
comment|/* Wrong vif on P2P interface - rate-limit prunes */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|last_prune
index|[
name|mifi
index|]
operator|==
name|virtual_time
condition|)
comment|/* Skip due to rate-limiting */
return|return;
name|mrtentry_ptr
operator|->
name|last_prune
index|[
name|mifi
index|]
operator|=
name|virtual_time
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_rmt_addr
condition|)
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|,
name|mifi
argument_list|,
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_rmt_addr
argument_list|,
name|max_prune_timeout
argument_list|(
name|mrtentry_ptr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Can't send wrongvif prune on p2p %s: no remote address"
argument_list|,
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_lcl_addr
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Wrong vif on LAN interface - rate-limit asserts */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|last_assert
index|[
name|mifi
index|]
operator|==
name|virtual_time
condition|)
comment|/* Skip due to rate-limiting */
return|return;
name|mrtentry_ptr
operator|->
name|last_assert
index|[
name|mifi
index|]
operator|=
name|virtual_time
expr_stmt|;
comment|/* Send the assert */
name|send_pim6_assert
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|mifi
argument_list|,
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|trigger_prune_alert
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_MRT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Now negative cache for src %s, grp %s - pruning"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the entry timer to the max of the prune timers */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|max_prune_timeout
argument_list|(
name|mrtentry_ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send a prune */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|upstream
condition|)
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
name|max_prune_timeout
argument_list|(
name|mrtentry_ptr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|trigger_join_alert
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_MRT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Now forwarding state for src %s, grp %s - grafting"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Refresh the entry timer */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|PIM_DATA_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Send graft */
name|send_pim6_graft
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

