begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND   *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to   *  Pavlin Ivanov Radoslavov (pavlin@catarina.usc.edu)  *  *  $Id: vif.c,v 1.5 2000/05/18 15:29:40 itojun Exp $  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Exported variables.  */
end_comment

begin_decl_stmt
name|struct
name|uvif
name|uvifs
index|[
name|MAXMIFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of all virtual interfaces          */
end_comment

begin_decl_stmt
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of vifs in use                    */
end_comment

begin_decl_stmt
name|int
name|vifs_down
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>some interfaces are down              */
end_comment

begin_decl_stmt
name|int
name|phys_vif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An enabled vif                           */
end_comment

begin_decl_stmt
name|int
name|udp_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since the honkin' kernel doesn't support */
end_comment

begin_comment
comment|/* ioctls on raw IP sockets, we need a UDP  */
end_comment

begin_comment
comment|/* socket as well as our IGMP (raw) socket. */
end_comment

begin_comment
comment|/* How dumb.                                */
end_comment

begin_decl_stmt
name|int
name|total_interfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of all interfaces: including the 				   * non-configured, but excluding the 				   * loopback interface and the non-multicast 				   * capable interfaces. 				   */
end_comment

begin_decl_stmt
name|if_set
name|if_nullset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* an interface face that has all-0 bit 				 * (for comparison) 				 */
end_comment

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|start_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stop_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_all_vifs
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|enabled_vifs
decl_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Configure the vifs based on the interface configuration of      * the kernel and the contents of the configuration file.      * (Open a UDP socket for ioctl use in the config procedures if      * the kernel can't handle IOCTL's on the MLD socket.)      */
ifdef|#
directive|ifdef
name|IOCTL_OK_ON_RAW_SOCKET
name|udp_socket
operator|=
name|mld6_socket
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|udp_socket
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"UDP6 socket"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Clean up all vifs      */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|MAXMIFS
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_metric
operator|=
name|DEFAULT_METRIC
expr_stmt|;
name|v
operator|->
name|uv_admetric
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_rate_limit
operator|=
name|DEFAULT_PHY_RATE_LIMIT
expr_stmt|;
name|strncpy
argument_list|(
name|v
operator|->
name|uv_name
argument_list|,
literal|""
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_dvmrp_neighbors
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|NULL
expr_stmt|;
name|NBRM_CLRALL
argument_list|(
name|v
operator|->
name|uv_nbrmap
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_prune_lifetime
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_acl
operator|=
operator|(
expr|struct
name|vif_acl
operator|*
operator|)
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_leaf_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_addrs
operator|=
operator|(
expr|struct
name|phaddr
operator|*
operator|)
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_filter
operator|=
operator|(
expr|struct
name|vif_filter
operator|*
operator|)
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_pim_hello_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_gq_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_pim_neighbors
operator|=
operator|(
expr|struct
name|pim_nbr_entry
operator|*
operator|)
name|NULL
expr_stmt|;
name|v
operator|->
name|uv_local_pref
operator|=
name|default_source_preference
expr_stmt|;
name|v
operator|->
name|uv_local_metric
operator|=
name|default_source_metric
expr_stmt|;
block|}
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Getting ifs from kernel"
argument_list|)
expr_stmt|;
name|config_vifs_from_kernel
argument_list|()
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Getting ifs from %s"
argument_list|,
name|configfilename
argument_list|)
expr_stmt|;
name|config_vifs_from_file
argument_list|()
expr_stmt|;
comment|/*      * Quit if there are fewer than two enabled vifs or there is a vif      * which has no link local address.      */
name|enabled_vifs
operator|=
literal|0
expr_stmt|;
name|phys_vif
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator|)
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|uv_linklocal
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"there is no link-local address on vif#%d"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys_vif
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
comment|/* 	     * If this vif has a global address, set its id 	     * to phys_vif. 	     */
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|phys_vif
operator|=
name|vifi
expr_stmt|;
break|break;
block|}
block|}
block|}
name|enabled_vifs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|enabled_vifs
operator|<
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"can't forward: %s"
argument_list|,
name|enabled_vifs
operator|==
literal|0
condition|?
literal|"no enabled ifs"
else|:
literal|"only one enabled if"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|if_nullset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|if_nullset
argument_list|)
argument_list|)
expr_stmt|;
name|k_init_pim
argument_list|(
name|mld6_socket
argument_list|)
expr_stmt|;
comment|/* Call to kernel to initiliaze structures */
name|start_all_vifs
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_all_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
comment|/* Start vif if not DISABLED or DOWN */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is DISABLED; if #%u out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s is DOWN; if #%u out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * stop all vifs  */
end_comment

begin_function
name|void
name|stop_all_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
block|{
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the vif and add to the kernel. The vif can be either  * physical, tunnel (tunnels will be used in the future  * when this code becomes PIM multicast boarder router.)  */
end_comment

begin_function
specifier|static
name|void
name|start_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_long
name|random_delay
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/* Initialy no router on any vif */
name|v
operator|->
name|uv_flags
operator|=
operator|(
name|v
operator|->
name|uv_flags
operator||
name|VIFF_DR
operator||
name|VIFF_NONBRS
operator|)
operator|&
operator|~
name|VIFF_DOWN
expr_stmt|;
name|v
operator|->
name|uv_pim_hello_timer
operator|=
literal|1
operator|+
name|RANDOM
argument_list|()
operator|%
name|PIM_TIMER_HELLO_PERIOD
expr_stmt|;
comment|/* TODO: CHECK THE TIMERS!!!!! Set or reset? */
name|v
operator|->
name|uv_gq_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_pim_neighbors
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Tell kernel to add, i.e. start this vif */
name|k_add_vif
argument_list|(
name|mld6_socket
argument_list|,
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s comes up; if #%u now in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Join the PIM multicast group on the interface.      */
name|k_join
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allpim6routers_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
comment|/*      * Join the ALL-ROUTERS multicast group on the interface.      * This allows mtrace requests to loop back if they are run      * on the multicast router.      */
name|k_join
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allrouters_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
comment|/*      * Until neighbors are discovered, assume responsibility for sending      * periodic group membership queries to the subnet.  Send the first      * query.      */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|uv_querier
condition|)
block|{
name|v
operator|->
name|uv_querier
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|v
operator|->
name|uv_querier
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
operator|->
name|uv_querier
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
operator|->
name|uv_querier
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
operator|=
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
operator|=
name|MLD6_OTHER_QUERIER_PRESENT_INTERVAL
expr_stmt|;
name|time
argument_list|(
operator|&
name|v
operator|->
name|uv_querier
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
comment|/* reset timestamp */
name|query_groups
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/*      * To avoid synchronization among routers booting simultaneously, set      * the hello timer to a random value between 1 to PIM_TIMER_HELLO_PERIOD.      */
name|random_delay
operator|=
literal|1
operator|+
operator|(
name|random
argument_list|()
operator|%
call|(
name|long
call|)
argument_list|(
name|PIM_TIMER_HELLO_PERIOD
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|v
operator|->
name|uv_pim_hello_timer
operator|=
name|random_delay
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop a vif (either physical interface or tunnel).  * If we are running only PIM we don't have tunnels.  */
end_comment

begin_function
specifier|static
name|void
name|stop_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
comment|/*      * TODO: make sure that the kernel viftable is       * consistent with the daemon table      */
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
name|k_leave
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allpim6routers_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
name|k_leave
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allrouters_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
comment|/*      * Discard all group addresses.  (No need to tell kernel;      * the k_del_vif() call will clean up kernel state.)      */
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
comment|/*      * TODO: inform (eventually) the neighbors I am going down by sending      * PIM_HELLO with holdtime=0 so someone else should become a DR.      */
comment|/* TODO: dummy! Implement it!! Any problems if don't use it? */
name|delete_vif_from_mrt
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Delete the interface from the kernel's vif structure.      */
name|k_del_vif
argument_list|(
name|mld6_socket
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|=
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|~
name|VIFF_DR
operator|&
operator|~
name|VIFF_QUERIER
operator|&
operator|~
name|VIFF_NONBRS
operator|)
operator||
name|VIFF_DOWN
expr_stmt|;
name|v
operator|->
name|uv_pim_hello_timer
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|uv_gq_timer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|next
control|)
block|{
name|next
operator|=
name|n
operator|->
name|next
expr_stmt|;
comment|/* Free the space for each neighbour */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_pim_neighbors
operator|=
name|NULL
expr_stmt|;
comment|/* TODO: currently not used */
comment|/* The Access Control List (list with the scoped addresses) */
while|while
condition|(
name|v
operator|->
name|uv_acl
operator|!=
name|NULL
condition|)
block|{
name|acl
operator|=
name|v
operator|->
name|uv_acl
expr_stmt|;
name|v
operator|->
name|uv_acl
operator|=
name|acl
operator|->
name|acl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|acl
argument_list|)
expr_stmt|;
block|}
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s goes down; if #%u out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return the max global Ipv6 address of an UP and ENABLED interface  * other than the MIFF_REGISTER interface. */
end_comment

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|max_global_address
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|pmax
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
comment|/* 		 * take first the max global address of the interface 		 * (without link local) => aliasing 		 */
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
comment|/* 			 * If this is the first global address, take it anyway. 			 */
if|if
condition|(
name|pmax
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
name|pmax
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|pmax
operator|->
name|pa_addr
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
name|pmax
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|pmax
condition|?
operator|&
name|pmax
operator|->
name|pa_addr
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|uv_global
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|vifi
index|]
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|p
operator|->
name|pa_addr
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See if any interfaces have changed from up state to down, or vice versa,  * including any non-multicast-capable interfaces that are in use as local  * tunnel end-points.  Ignore interfaces that have been administratively  * disabled.  */
end_comment

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
specifier|static
name|int
name|checking_vifs
init|=
literal|0
decl_stmt|;
comment|/*      * XXX: TODO: True only for DVMRP?? Check.      * If we get an error while checking, (e.g. two interfaces go down      * at once, and we decide to send a prune out one of the failed ones)      * then don't go into an infinite loop!      */
if|if
condition|(
name|checking_vifs
condition|)
return|return;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
name|checking_vifs
operator|=
literal|1
expr_stmt|;
comment|/* TODO: Check all potential interfaces!!! */
comment|/* Check the physical interfaces only */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
continue|continue;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
comment|/* get the interface flags */
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"check_vif_state: ioctl SIOCGIFFLAGS for %s"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has gone down; if #%u taken out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|checking_vifs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the source is directly connected to us, find the vif number for  * the corresponding physical interface (tunnels excluded).  * Local addresses are excluded.  * Return the vif number or NO_VIF if not found.  */
end_comment

begin_function
name|vifi_t
name|find_vif_direct
parameter_list|(
name|src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|VIFF_TUNNEL
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
condition|)
return|return
operator|(
name|NO_VIF
operator|)
return|;
if|if
condition|(
name|inet6_match_prefix
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_prefix
argument_list|,
operator|&
name|p
operator|->
name|pa_subnetmask
argument_list|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if src is local address. If "yes" return the vif index,  * otherwise return value is NO_VIF.  */
end_comment

begin_function
name|vifi_t
name|local_address
parameter_list|(
name|src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
comment|/* Returning NO_VIF means not a local address */
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the source is directly connected, or is local address,  * find the vif number for the corresponding physical interface  * (tunnels excluded).  * Return the vif number or NO_VIF if not found.  */
end_comment

begin_function
name|vifi_t
name|find_vif_direct_local
parameter_list|(
name|src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|VIFF_TUNNEL
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
operator|||
name|inet6_match_prefix
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_prefix
argument_list|,
operator|&
name|p
operator|->
name|pa_subnetmask
argument_list|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

end_unit

