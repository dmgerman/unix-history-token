begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1998 WIDE Project.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Oregon.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Oregon.  *  The name of the University of Oregon may not be used to endorse or   *  promote products derived from this software without specific prior   *  written permission.  *  *  THE UNIVERSITY OF OREGON DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND   *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL UO, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to   *  Kurt Windisch (kurtw@antc.uoregon.edu)  *  *  $Id: pim6_proto.c,v 1.5 2000/04/30 10:50:31 jinmei Exp $  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from PIM sparse-mode pimd.  * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *    * The pimd program is COPYRIGHT 1998 by University of Southern California.  *  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *   * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  * Local functions definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parse_pim6_hello
name|__P
argument_list|(
operator|(
name|char
operator|*
name|pktPtr
operator|,
name|int
name|datalen
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|src
operator|,
name|u_int16
operator|*
name|holdtime
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delayed_join_job
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_delayed_join
name|__P
argument_list|(
operator|(
name|mrtentry_t
operator|*
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delayed_prune_job
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_delayed_prune
name|__P
argument_list|(
operator|(
name|mrtentry_t
operator|*
operator|,
name|mifi_t
operator|,
name|u_int16
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_metrics
name|__P
argument_list|(
operator|(
name|u_int32
name|local_preference
operator|,
name|u_int32
name|local_metric
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|local_address
operator|,
name|u_int32
name|remote_preference
operator|,
name|u_int32
name|remote_metric
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|remote_address
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|retransmit_pim6_graft
name|__P
argument_list|(
operator|(
name|mrtentry_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|retransmit_all_pim6_grafts
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|if_set
name|nbr_mifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mifs that have one or more neighbors attached */
end_comment

begin_comment
comment|/************************************************************************  *                        PIM_HELLO  ************************************************************************/
end_comment

begin_function
name|int
name|receive_pim6_hello
parameter_list|(
name|src
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|pim_message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|nbr
decl_stmt|,
modifier|*
name|prev_nbr
decl_stmt|,
modifier|*
name|new_nbr
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|int
name|state_change
decl_stmt|;
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
name|srcentry_t
modifier|*
name|srcentry_ptr_next
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|u_long
name|random_delay
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* Either a local vif or somehow received PIM_HELLO from 		 * non-directly connected router. Ignore it. 		 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_HELLO from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the Holdtime (in seconds) from the message. Return if error. */
if|if
condition|(
name|parse_pim6_hello
argument_list|(
name|pim_message
argument_list|,
name|datalen
argument_list|,
name|src
argument_list|,
operator|&
name|holdtime
argument_list|)
operator|==
name|FALSE
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO | DEBUG_PIM_TIMER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM HELLO holdtime from %s is %u"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_nbr
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|,
name|nbr
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|;
name|prev_nbr
operator|=
name|nbr
operator|,
name|nbr
operator|=
name|nbr
operator|->
name|next
control|)
block|{
comment|/* The PIM neighbors are sorted in decreasing order of the 		 * network addresses (note that to be able to compare them 		 * correctly we must translate the addresses in host order. 		 */
if|if
condition|(
name|inet6_lessthan
argument_list|(
name|src
argument_list|,
operator|&
name|nbr
operator|->
name|address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|nbr
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* We already have an entry for this host */
if|if
condition|(
literal|0
operator|==
name|holdtime
condition|)
block|{
comment|/* 				 * Looks like we have a nice neighbor who is 				 * going down and wants to inform us by sending 				 * "holdtime=0". Thanks buddy and see you again! 				 */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"PIM HELLO received: neighbor %s going down"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|delete_pim6_nbr
argument_list|(
name|nbr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* Set the timer */
name|nbr
operator|->
name|timer
operator|=
name|holdtime
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
comment|/* 			 * No entry for this neighbor. Exit the loop and create an 			 * entry for it. 			 */
break|break;
block|}
comment|/* 	 * This is a new neighbor. Create a new entry for it. 	 * It must be added right after `prev_nbr` 	 */
name|new_nbr
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pim_nbr_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|new_nbr
operator|->
name|address
operator|=
operator|*
name|src
expr_stmt|;
name|new_nbr
operator|->
name|vifi
operator|=
name|mifi
expr_stmt|;
name|new_nbr
operator|->
name|timer
operator|=
name|holdtime
expr_stmt|;
name|new_nbr
operator|->
name|next
operator|=
name|nbr
expr_stmt|;
name|new_nbr
operator|->
name|prev
operator|=
name|prev_nbr
expr_stmt|;
if|if
condition|(
name|prev_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|prev_nbr
operator|->
name|next
operator|=
name|new_nbr
expr_stmt|;
else|else
name|v
operator|->
name|uv_pim_neighbors
operator|=
name|new_nbr
expr_stmt|;
if|if
condition|(
name|new_nbr
operator|->
name|next
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|new_nbr
operator|->
name|next
operator|->
name|prev
operator|=
name|new_nbr
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_NONBRS
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_PIM_NBR
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|nbr_mifs
argument_list|)
expr_stmt|;
comment|/* Elect a new DR */
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|v
operator|->
name|uv_pim_neighbors
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* The first address is the new potential remote 		 * DR address and it wins (is>) over the local address. 		 */
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_DR
expr_stmt|;
block|}
comment|/* 	 * Since a new neighbour has come up, let it know your existence ASAP; 	 * compute a random value, and reset the value to the hello timer 	 * if it's smaller than the rest of the timer. 	 * XXX: not in the spec... 	 */
name|random_delay
operator|=
literal|1
operator|+
operator|(
name|random
argument_list|()
operator|%
call|(
name|long
call|)
argument_list|(
name|PIM_TIMER_HELLO_PERIOD
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|random_delay
operator|<
name|v
operator|->
name|uv_pim_hello_timer
condition|)
name|v
operator|->
name|uv_pim_hello_timer
operator|=
name|random_delay
expr_stmt|;
comment|/* Update the source entries */
for|for
control|(
name|srcentry_ptr
operator|=
name|srclist
init|;
name|srcentry_ptr
operator|!=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
condition|;
name|srcentry_ptr
operator|=
name|srcentry_ptr_next
control|)
block|{
name|srcentry_ptr_next
operator|=
name|srcentry_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|srcentry_ptr
operator|->
name|incoming
operator|==
name|mifi
condition|)
continue|continue;
for|for
control|(
name|mrtentry_ptr
operator|=
name|srcentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|srcnext
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
operator|)
condition|)
block|{
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_change
operator|==
literal|1
condition|)
name|trigger_join_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO
argument_list|)
name|dump_vifs
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Show we got a new neighbor */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|delete_pim6_nbr
parameter_list|(
name|nbr_delete
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|nbr_delete
decl_stmt|;
block|{
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
name|srcentry_t
modifier|*
name|srcentry_ptr_next
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|state_change
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|nbr_delete
operator|->
name|vifi
index|]
expr_stmt|;
comment|/* Delete the entry from the pim_nbrs chain */
if|if
condition|(
name|nbr_delete
operator|->
name|prev
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|nbr_delete
operator|->
name|prev
operator|->
name|next
operator|=
name|nbr_delete
operator|->
name|next
expr_stmt|;
else|else
name|v
operator|->
name|uv_pim_neighbors
operator|=
name|nbr_delete
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|nbr_delete
operator|->
name|next
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|nbr_delete
operator|->
name|next
operator|->
name|prev
operator|=
name|nbr_delete
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_pim_neighbors
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* This was our last neighbor. */
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_PIM_NBR
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
operator|(
name|VIFF_NONBRS
operator||
name|VIFF_DR
operator||
name|VIFF_QUERIER
operator|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|nbr_delete
operator|->
name|vifi
argument_list|,
operator|&
name|nbr_mifs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|v
operator|->
name|uv_pim_neighbors
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* The first address is the new potential remote 			 * DR address, but the local address is the winner. 			 */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_DR
expr_stmt|;
block|}
block|}
comment|/* Update the source entries: 	 * If the deleted nbr was my upstream, then reset incoming and 	 * update all (S,G) entries for sources reachable through it. 	 * If the deleted nbr was the last on a non-iif vif, then recalcuate 	 * outgoing interfaces. 	 */
for|for
control|(
name|srcentry_ptr
operator|=
name|srclist
init|;
name|srcentry_ptr
operator|!=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
condition|;
name|srcentry_ptr
operator|=
name|srcentry_ptr_next
control|)
block|{
name|srcentry_ptr_next
operator|=
name|srcentry_ptr
operator|->
name|next
expr_stmt|;
comment|/* The only time we don't need to scan all mrtentries is 		 * when the nbr was on the iif, but not the upstream nbr!  		 */
if|if
condition|(
name|nbr_delete
operator|->
name|vifi
operator|==
name|srcentry_ptr
operator|->
name|incoming
operator|&&
name|srcentry_ptr
operator|->
name|upstream
operator|!=
name|nbr_delete
condition|)
continue|continue;
comment|/* Reset the next hop (PIM) router */
if|if
condition|(
name|srcentry_ptr
operator|->
name|upstream
operator|==
name|nbr_delete
condition|)
if|if
condition|(
name|set_incoming
argument_list|(
name|srcentry_ptr
argument_list|,
name|PIM_IIF_SOURCE
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* 				 * Couldn't reset it. Sorry, the next hop router 				 * toward that source is probably not 				 * a PIM router, or cannot find route at all, 				 * hence I cannot handle this source and have to 				 * delete it. 				 */
name|delete_srcentry
argument_list|(
name|srcentry_ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nbr_delete
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|mrtentry_ptr
operator|=
name|srcentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|srcnext
control|)
block|{
name|mrtentry_ptr
operator|->
name|incoming
operator|=
name|srcentry_ptr
operator|->
name|incoming
expr_stmt|;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|srcentry_ptr
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|srcentry_ptr
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|srcentry_ptr
operator|->
name|preference
expr_stmt|;
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_change
operator|==
operator|-
literal|1
condition|)
block|{
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state_change
operator|==
literal|1
condition|)
block|{
name|trigger_join_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nbr_delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: simplify it! */
end_comment

begin_function
specifier|static
name|int
name|parse_pim6_hello
parameter_list|(
name|pim_message
parameter_list|,
name|datalen
parameter_list|,
name|src
parameter_list|,
name|holdtime
parameter_list|)
name|char
modifier|*
name|pim_message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
name|u_int16
modifier|*
name|holdtime
decl_stmt|;
block|{
name|u_int8
modifier|*
name|pim_hello_message
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int16
name|option_type
decl_stmt|;
name|u_int16
name|option_length
decl_stmt|;
name|int
name|holdtime_received_ok
init|=
name|FALSE
decl_stmt|;
name|int
name|option_total_length
decl_stmt|;
name|pim_hello_message
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|datalen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|datalen
operator|>=
sizeof|sizeof
argument_list|(
name|pim_hello_t
argument_list|)
condition|;
control|)
block|{
comment|/* Ignore any data if shorter than (pim_hello header) */
name|data_ptr
operator|=
name|pim_hello_message
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|option_type
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|option_length
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|option_type
condition|)
block|{
case|case
name|PIM_MESSAGE_HELLO_HOLDTIME
case|:
if|if
condition|(
name|PIM_MESSAGE_HELLO_HOLDTIME_LENGTH
operator|!=
name|option_length
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM HELLO Holdtime from %s: "
literal|"invalid OptionLength = %u"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|GET_HOSTSHORT
argument_list|(
operator|*
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|holdtime_received_ok
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* Ignore any unknown options */
break|break;
block|}
comment|/* Move to the next option */
comment|/* XXX: TODO: If we are padding to the end of the 32 bit boundary, 		 * use the first method to move to the next option, otherwise 		 * simply (sizeof(pim_hello_t) + option_length). 		 */
ifdef|#
directive|ifdef
name|BOUNDARY_32_BIT
name|option_total_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pim_hello_t
argument_list|)
operator|+
operator|(
name|option_length
operator|&
operator|~
literal|0x3
operator|)
operator|+
operator|(
operator|(
name|option_length
operator|&
literal|0x3
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|option_total_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pim_hello_t
argument_list|)
operator|+
name|option_length
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* BOUNDARY_32_BIT */
name|datalen
operator|-=
name|option_total_length
expr_stmt|;
name|pim_hello_message
operator|+=
name|option_total_length
expr_stmt|;
block|}
return|return
operator|(
name|holdtime_received_ok
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_pim6_hello
parameter_list|(
name|v
parameter_list|,
name|holdtime
parameter_list|)
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|buf
operator|=
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|buf
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|PIM_MESSAGE_HELLO_HOLDTIME
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|PIM_MESSAGE_HELLO_HOLDTIME_LENGTH
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|data_ptr
operator|-
operator|(
name|u_int8
operator|*
operator|)
name|buf
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_HELLO
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_pim_hello_timer
operator|=
name|PIM_TIMER_HELLO_PERIOD
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_JOIN_PRUNE  ************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|sockaddr_in6
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
name|group
decl_stmt|;
name|struct
name|sockaddr_in6
name|target
decl_stmt|;
block|}
name|join_delay_cbk_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
name|group
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
block|}
name|prune_delay_cbk_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|delayed_join_job
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|join_delay_cbk_t
modifier|*
name|cbk
init|=
operator|(
name|join_delay_cbk_t
operator|*
operator|)
name|arg
decl_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|cbk
operator|->
name|source
argument_list|,
operator|&
name|cbk
operator|->
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|join_delay_timerid
condition|)
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|join_delay_timerid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|upstream
condition|)
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_JOIN
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|schedule_delayed_join
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|target
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|target
decl_stmt|;
block|{
name|u_long
name|random_delay
decl_stmt|;
name|join_delay_cbk_t
modifier|*
name|cbk
decl_stmt|;
comment|/* Delete existing timer */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|join_delay_timerid
condition|)
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|join_delay_timerid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|random_delay
operator|=
name|lrand48
argument_list|()
operator|%
operator|(
name|long
operator|)
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
expr_stmt|;
else|#
directive|else
name|random_delay
operator|=
name|random
argument_list|()
operator|%
operator|(
name|long
operator|)
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
expr_stmt|;
endif|#
directive|endif
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Scheduling join for src %s, grp %s, delay %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|random_delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|random_delay
operator|==
literal|0
operator|&&
name|mrtentry_ptr
operator|->
name|upstream
condition|)
block|{
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_JOIN
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbk
operator|=
operator|(
name|join_delay_cbk_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|join_delay_cbk_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|source
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
expr_stmt|;
name|cbk
operator|->
name|group
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
expr_stmt|;
name|cbk
operator|->
name|target
operator|=
operator|*
name|target
expr_stmt|;
name|mrtentry_ptr
operator|->
name|join_delay_timerid
operator|=
name|timer_setTimer
argument_list|(
name|random_delay
argument_list|,
name|delayed_join_job
argument_list|,
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delayed_prune_job
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|if_set
name|new_pruned_oifs
decl_stmt|;
name|int
name|state_change
decl_stmt|;
name|prune_delay_cbk_t
modifier|*
name|cbk
init|=
operator|(
name|prune_delay_cbk_t
operator|*
operator|)
name|arg
decl_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|cbk
operator|->
name|source
argument_list|,
operator|&
name|cbk
operator|->
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|cbk
operator|->
name|mifi
index|]
condition|)
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|cbk
operator|->
name|mifi
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISSET
argument_list|(
name|cbk
operator|->
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Deleting pruned mif %d for src %s, grp %s"
argument_list|,
name|cbk
operator|->
name|mifi
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|cbk
operator|->
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|cbk
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|cbk
operator|->
name|mifi
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|cbk
operator|->
name|mifi
index|]
argument_list|,
name|cbk
operator|->
name|holdtime
argument_list|)
expr_stmt|;
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* Handle transition to negative cache */
if|if
condition|(
name|state_change
operator|==
operator|-
literal|1
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|schedule_delayed_prune
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|mifi
parameter_list|,
name|holdtime
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
block|{
name|prune_delay_cbk_t
modifier|*
name|cbk
decl_stmt|;
comment|/* Delete existing timer */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
condition|)
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
name|cbk
operator|=
operator|(
name|prune_delay_cbk_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|prune_delay_cbk_t
argument_list|)
argument_list|)
expr_stmt|;
name|cbk
operator|->
name|mifi
operator|=
name|mifi
expr_stmt|;
name|cbk
operator|->
name|source
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
expr_stmt|;
name|cbk
operator|->
name|group
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
expr_stmt|;
name|cbk
operator|->
name|holdtime
operator|=
name|holdtime
expr_stmt|;
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
operator|=
name|timer_setTimer
argument_list|(
operator|(
name|u_int16
operator|)
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
argument_list|,
name|delayed_prune_job
argument_list|,
name|cbk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: when parsing, check if we go beyong message size */
end_comment

begin_function
name|int
name|receive_pim6_join_prune
parameter_list|(
name|src
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|pim_message
decl_stmt|;
specifier|register
name|int
name|datalen
decl_stmt|;
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|pim6_encod_uni_addr_t
name|uni_target_addr
decl_stmt|;
name|pim6_encod_grp_addr_t
name|encod_group
decl_stmt|;
name|pim6_encod_src_addr_t
name|encod_src
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
name|num_groups
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|u_int16
name|num_j_srcs
decl_stmt|,
name|num_p_srcs
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|,
name|group
decl_stmt|,
name|target
decl_stmt|;
name|struct
name|in6_addr
name|s_mask
decl_stmt|,
name|g_mask
decl_stmt|;
name|u_int8
name|s_flags
decl_stmt|;
name|u_int8
name|reserved
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|upstream_router
decl_stmt|;
name|if_set
name|new_pruned_oifs
decl_stmt|;
name|int
name|state_change
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* 		 * Either a local vif or somehow received PIM_JOIN_PRUNE from 		 * non-directly connected router. Ignore it. 		 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_JOIN_PRUNE from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|VIFF_NONBRS
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the target address */
name|GET_EUADDR6
argument_list|(
operator|&
name|uni_target_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|reserved
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|num_groups
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_groups
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* No indication for groups in the message */
name|GET_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|target
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|target
operator|.
name|sin6_addr
operator|=
name|uni_target_addr
operator|.
name|unicast_addr
expr_stmt|;
name|target
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|target
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM Join/Prune received from %s : target %s, holdtime %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|target
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_localif_address
argument_list|(
operator|&
name|target
argument_list|,
name|v
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|uni_target_addr
operator|.
name|unicast_addr
argument_list|)
condition|)
block|{
comment|/* if I am not the target of the join or prune message */
comment|/* 		 * Join Suppression: when receiving a join not addressed to me, 		 * if I am delaying a join for this (S,G) then cancel the delayed  		 * join. 		 * Prune Soliticiting Joins: when receiving a prune not 		 * addressed to me on a LAN, schedule delayed join if I have 		 * downstream receivers. 		 */
name|upstream_router
operator|=
name|find_pim6_nbr
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|upstream_router
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* I have no such neighbor */
name|group
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|source
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
while|while
condition|(
name|num_groups
operator|--
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|encod_group
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_group
operator|.
name|masklen
argument_list|,
name|g_mask
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Ignore this group and jump to the next */
block|}
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
comment|/* (S,G) Join suppresion */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tJOIN src %s, group %s - canceling "
literal|"delayed join"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cancel the delayed join */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|join_delay_timerid
condition|)
block|{
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|join_delay_timerid
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|join_delay_timerid
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|num_p_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
comment|/* if P2P link (not addressed to me) ignore  				 */
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
continue|continue;
comment|/* 				 * if non-null oiflist then schedule delayed join. 				 */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tPRUNE src %s, group %s "
literal|"- scheduling delayed join"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|schedule_delayed_join
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* while groups */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* if not unicast target */
comment|/* I am the target of this join/prune: 	 * For joins, cancel delayed prunes that I have scheduled. 	 * For prunes, echo the prune and schedule delayed prunes on LAN or  	 * prune immediately on point-to-point links. 	 */
else|else
block|{
while|while
condition|(
name|num_groups
operator|--
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM Join/Prune received: grp: %s plen: %d, "
literal|"%d jsrc, %d psrc"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_group
operator|.
name|mcast_addr
argument_list|)
argument_list|,
name|encod_group
operator|.
name|masklen
argument_list|,
name|num_j_srcs
argument_list|,
name|num_p_srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|encod_group
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
comment|/* Ignore this group */
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_group
operator|.
name|masklen
argument_list|,
name|g_mask
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Ignore this group and jump to the next */
block|}
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tJOIN src %s, group %s - canceling "
literal|"delayed prune"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cancel the delayed prune */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
condition|)
block|{
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|num_p_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* if P2P link (addressed to me) prune immediately 				 */
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
block|{
if|if
condition|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tPRUNE(P2P) src %s,"
literal|"group %s - pruning "
literal|"mif"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_MRT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Deleting pruned mif %d for src %s, grp %s"
argument_list|,
name|mifi
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|mifi
index|]
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* Handle transition to negative cache */
if|if
condition|(
name|state_change
operator|==
operator|-
literal|1
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* if is pruned */
block|}
comment|/* if p2p */
comment|/* if LAN link, echo the prune and schedule delayed 				 * oif deletion 				 */
else|else
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tPRUNE(LAN) src %s, group "
literal|"%s - scheduling delayed prune"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|,
name|mifi
argument_list|,
operator|&
name|target
argument_list|,
name|holdtime
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|schedule_delayed_prune
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mifi
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* while groups */
block|}
comment|/* else I am unicast target */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_pim6_jp
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|action
parameter_list|,
name|mifi
parameter_list|,
name|target_addr
parameter_list|,
name|holdtime
parameter_list|,
name|echo
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|int
name|action
decl_stmt|;
comment|/* PIM_ACTION_JOIN or PIM_ACTION_PRUNE */
name|mifi_t
name|mifi
decl_stmt|;
comment|/* vif to send join/prune on */
name|struct
name|sockaddr_in6
modifier|*
name|target_addr
decl_stmt|;
comment|/* encoded unicast target neighbor */
name|u_int16
name|holdtime
decl_stmt|;
comment|/* holdtime */
name|int
name|echo
decl_stmt|;
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|,
modifier|*
name|data_start_ptr
decl_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|data_start_ptr
operator|=
name|data_ptr
expr_stmt|;
if|if
condition|(
name|echo
operator|==
literal|0
operator|&&
name|mrtentry_ptr
operator|->
name|upstream
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No upstream neighbor - don't send */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending %s:  vif %s, src %s, group %s, "
literal|"target %s, holdtime %d"
argument_list|,
name|action
operator|==
name|PIM_ACTION_JOIN
condition|?
literal|"JOIN"
else|:
literal|"PRUNE"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|target_addr
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|PUT_EUADDR6
argument_list|(
name|target_addr
operator|->
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* encoded unicast target addr */
name|PUT_BYTE
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* Reserved */
operator|*
name|data_ptr
operator|++
operator|=
operator|(
name|u_int8
operator|)
literal|1
expr_stmt|;
comment|/* number of groups */
name|PUT_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* holdtime */
comment|/* data_ptr points at the first, and only encoded mcast group */
name|PUT_EGADDR6
argument_list|(
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* set the number of join and prune sources */
if|if
condition|(
name|action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
name|PUT_HOSTSHORT
argument_list|(
literal|1
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|PIM_ACTION_PRUNE
condition|)
block|{
name|PUT_HOSTSHORT
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
literal|1
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
block|}
name|PUT_ESADDR6
argument_list|(
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* Cancel active graft */
if|if
condition|(
name|echo
operator|==
literal|0
condition|)
name|delete_pim6_graft_entry
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_JOIN_PRUNE
argument_list|,
name|data_ptr
operator|-
name|data_start_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_ASSERT  ************************************************************************/
end_comment

begin_comment
comment|/* Notes on assert prefs/metrics  *   - For downstream routers, compare pref/metric previously received from  *     winner against those in message.  *     ==> store assert winner's pref/metric in mrtentry  *   - For upstream router compare my actualy pref/metric for the source  *     against those received in message.  *     ==> store my actual pref/metric in srcentry  */
end_comment

begin_function
name|int
name|receive_pim6_assert
parameter_list|(
name|src
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|pim_message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|pim6_encod_uni_addr_t
name|eusaddr
decl_stmt|;
name|pim6_encod_grp_addr_t
name|egaddr
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|,
name|group
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int32
name|assert_preference
decl_stmt|;
name|u_int32
name|assert_metric
decl_stmt|;
name|u_int32
name|local_metric
decl_stmt|;
name|u_int32
name|local_preference
decl_stmt|;
name|u_int8
name|local_wins
decl_stmt|;
name|if_set
name|new_pruned_oifs
decl_stmt|,
name|new_leaves
decl_stmt|;
name|int
name|state_change
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* Either a local vif or somehow received PIM_ASSERT from 		 * non-directly connected router. Ignore it. 		 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_ASSERT from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|VIFF_NONBRS
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the group and source addresses */
name|GET_EGADDR6
argument_list|(
operator|&
name|egaddr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_EUADDR6
argument_list|(
operator|&
name|eusaddr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* Get the metric related info */
name|GET_HOSTLONG
argument_list|(
name|assert_preference
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTLONG
argument_list|(
name|assert_metric
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|eusaddr
operator|.
name|unicast_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|egaddr
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM Assert received from %s: src %s, grp %s, "
literal|"pref %d, metric %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|assert_preference
argument_list|,
name|assert_metric
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"\tFailed to create a mrtentry src:%s grp:%s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_NEW
condition|)
block|{
comment|/* For some reason, it's possible for asserts to be processed 		 * before the data alerts a cache miss.  Therefore, when an 		 * assert is received, create (S,G) state and continue, since 		 * we know by the assert that there are upstream forwarders.  		 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tNo MRT entry - creating..."
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
comment|/* Set oifs */
name|set_leaves
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
operator|(
name|mrtentry_ptr
operator|->
name|oifs
operator|)
argument_list|)
expr_stmt|;
comment|/* Add it to the kernel */
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
comment|/* No need to call change_interfaces, but check for NULL oiflist */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* If arrived on iif, I'm downstream of the asserted LAN. 	 * If arrived on oif, I'm upstream of the asserted LAN. 	 */
if|if
condition|(
name|mifi
operator|==
name|mrtentry_ptr
operator|->
name|incoming
condition|)
block|{
comment|/* assert arrived on iif ==> I'm a downstream router */
comment|/* Determine local (really that of upstream nbr!) pref/metric */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|upstream
operator|&&
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
name|src
argument_list|)
operator|&&
name|assert_preference
operator|==
name|local_preference
operator|&&
name|assert_metric
operator|==
name|local_metric
condition|)
comment|/* if assert from previous winner w/ same pref/metric,  			 * then assert sender wins again */
name|local_wins
operator|=
name|FALSE
expr_stmt|;
else|else
comment|/* assert from someone else or something changed */
name|local_wins
operator|=
name|compare_metrics
argument_list|(
name|local_preference
argument_list|,
name|local_metric
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
name|assert_preference
argument_list|,
name|assert_metric
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 		 * This is between the assert sender and previous winner or rpf  		 * (who is the "local" in this case). 		 */
if|if
condition|(
name|local_wins
operator|==
name|TRUE
condition|)
block|{
comment|/* the assert-sender loses, so discard the assert */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tAssert sender %s loses"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* The assert sender wins: upstream must be changed to the winner */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tAssert sender %s wins"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tChanging upstream nbr to %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|assert_preference
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|assert_metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|find_pim6_nbr
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|assert_timer
argument_list|,
name|PIM_ASSERT_TIMEOUT
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator||=
name|MRTF_ASSERTED
expr_stmt|;
comment|/* Send a join for the S,G if oiflist is non-empty */
if|if
condition|(
operator|!
operator|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
operator|)
condition|)
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_JOIN
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* if assert on iif */
comment|/* If the assert arrived on an oif: */
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* assert arrived on oif ==> I'm a upstream router */
comment|/* Determine local pref/metric */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|preference
expr_stmt|;
name|local_wins
operator|=
name|compare_metrics
argument_list|(
name|local_preference
argument_list|,
name|local_metric
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|assert_preference
argument_list|,
name|assert_metric
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_wins
operator|==
name|FALSE
condition|)
block|{
comment|/* Assert sender wins - prune the interface */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tAssert sender %s wins - pruning..."
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|mifi
index|]
argument_list|,
name|PIM_JOIN_PRUNE_HOLDTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
condition|)
block|{
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
block|}
comment|/* Handle transition to negative cache */
if|if
condition|(
name|state_change
operator|==
operator|-
literal|1
condition|)
name|trigger_prune_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
comment|/* assert sender wins */
else|else
block|{
comment|/* Local wins (assert sender loses): 			 * send assert and schedule prune 			 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tAssert sender %s loses - "
literal|"sending assert and scheuling prune"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * No directly connected receivers - delay prune 				 */
name|send_pim6_jp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|,
name|mifi
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|PIM_JOIN_PRUNE_HOLDTIME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|schedule_delayed_prune
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mifi
argument_list|,
name|PIM_JOIN_PRUNE_HOLDTIME
argument_list|)
expr_stmt|;
block|}
name|send_pim6_assert
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|mifi
argument_list|,
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if assert on oif */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_pim6_assert
parameter_list|(
name|source
parameter_list|,
name|group
parameter_list|,
name|mifi
parameter_list|,
name|mrtentry_ptr
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
modifier|*
name|data_start_ptr
decl_stmt|;
name|u_int32
name|local_preference
decl_stmt|;
name|u_int32
name|local_metric
decl_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|data_start_ptr
operator|=
name|data_ptr
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|group
operator|->
name|sin6_addr
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_EUADDR6
argument_list|(
name|source
operator|->
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|preference
expr_stmt|;
name|PUT_HOSTLONG
argument_list|(
name|local_preference
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTLONG
argument_list|(
name|local_metric
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_ASSERT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM Assert sending: src %s, grp %s, "
literal|"pref %d, metric %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|local_metric
argument_list|,
name|local_preference
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_ASSERT
argument_list|,
name|data_ptr
operator|-
name|data_start_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the local win, otherwise FALSE */
end_comment

begin_function
specifier|static
name|int
name|compare_metrics
parameter_list|(
name|local_preference
parameter_list|,
name|local_metric
parameter_list|,
name|local_address
parameter_list|,
name|remote_preference
parameter_list|,
name|remote_metric
parameter_list|,
name|remote_address
parameter_list|)
name|u_int32
name|local_preference
decl_stmt|;
name|u_int32
name|local_metric
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|local_address
decl_stmt|;
name|u_int32
name|remote_preference
decl_stmt|;
name|u_int32
name|remote_metric
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|remote_address
decl_stmt|;
block|{
comment|/* Now lets see who has a smaller gun (aka "asserts war") */
comment|/* FYI, the smaller gun...err metric wins, but if the same 	 * caliber, then the bigger network address wins. The order of 	 * treatment is: preference, metric, address. 	 */
comment|/* The RPT bits are already included as the most significant bits 	 * of the preferences. 	 */
if|if
condition|(
name|remote_preference
operator|>
name|local_preference
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|remote_preference
operator|<
name|local_preference
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|remote_metric
operator|>
name|local_metric
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|remote_metric
operator|<
name|local_metric
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|inet6_greaterthan
argument_list|(
name|local_address
argument_list|,
name|remote_address
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_GRAFT  ************************************************************************/
end_comment

begin_decl_stmt
name|u_long
name|graft_retrans_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Graft retransmission timer */
end_comment

begin_decl_stmt
name|pim_graft_entry_t
modifier|*
name|graft_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Active grafting entries */
end_comment

begin_function
name|void
name|delete_pim6_graft_entry
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|pim_graft_entry_t
modifier|*
name|graft_entry
decl_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|graft
operator|==
operator|(
name|pim_graft_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
name|graft_entry
operator|=
name|mrtentry_ptr
operator|->
name|graft
expr_stmt|;
if|if
condition|(
name|graft_entry
operator|->
name|prev
condition|)
name|graft_entry
operator|->
name|prev
operator|->
name|next
operator|=
name|graft_entry
operator|->
name|next
expr_stmt|;
else|else
name|graft_list
operator|=
name|graft_entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|graft_entry
operator|->
name|next
condition|)
name|graft_entry
operator|->
name|next
operator|->
name|prev
operator|=
name|graft_entry
operator|->
name|prev
expr_stmt|;
name|mrtentry_ptr
operator|->
name|graft
operator|=
operator|(
name|pim_graft_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|graft_entry
argument_list|)
expr_stmt|;
comment|/* Stop the timer if there are no more entries */
if|if
condition|(
operator|!
name|graft_list
condition|)
block|{
name|timer_clearTimer
argument_list|(
name|graft_retrans_timer
argument_list|)
expr_stmt|;
name|graft_retrans_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|retransmit_pim6_graft
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|,
modifier|*
name|data_start_ptr
decl_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|data_start_ptr
operator|=
name|data_ptr
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|upstream
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No upstream neighbor - don't send */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending GRAFT:  vif %s, src %s, grp %s, dst %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|uvifs
index|[
name|mrtentry_ptr
operator|->
name|incoming
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* unicast target */
name|PUT_EUADDR6
argument_list|(
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
operator|.
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* Reserved */
operator|*
name|data_ptr
operator|++
operator|=
operator|(
name|u_int8
operator|)
literal|1
expr_stmt|;
comment|/* number of groups */
name|PUT_HOSTSHORT
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* no holdtime */
comment|/* data_ptr points at the first, and only encoded mcast group */
name|PUT_EGADDR6
argument_list|(
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* set the number of join(graft) and prune sources */
name|PUT_HOSTSHORT
argument_list|(
literal|1
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_ESADDR6
argument_list|(
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mrtentry_ptr
operator|->
name|incoming
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
name|PIM_GRAFT
argument_list|,
name|data_ptr
operator|-
name|data_start_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|retransmit_all_pim6_grafts
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* UNUSED */
block|{
name|pim_graft_entry_t
modifier|*
name|graft_ptr
decl_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Retransmitting all pending PIM-Grafts"
argument_list|)
expr_stmt|;
for|for
control|(
name|graft_ptr
operator|=
name|graft_list
init|;
name|graft_ptr
operator|!=
name|NULL
condition|;
name|graft_ptr
operator|=
name|graft_ptr
operator|->
name|next
control|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tGRAFT src %s, grp %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|graft_ptr
operator|->
name|mrtlink
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|graft_ptr
operator|->
name|mrtlink
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|retransmit_pim6_graft
argument_list|(
name|graft_ptr
operator|->
name|mrtlink
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|graft_list
condition|)
name|timer_setTimer
argument_list|(
name|PIM_GRAFT_RETRANS_PERIOD
argument_list|,
name|retransmit_all_pim6_grafts
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|receive_pim6_graft
parameter_list|(
name|src
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|,
name|pimtype
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|pim_message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|pimtype
decl_stmt|;
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|pim6_encod_uni_addr_t
name|uni_target_addr
decl_stmt|;
name|pim6_encod_grp_addr_t
name|encod_group
decl_stmt|;
name|pim6_encod_src_addr_t
name|encod_src
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
name|num_groups
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|u_int16
name|num_j_srcs
decl_stmt|;
name|u_int16
name|num_p_srcs
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|,
name|group
decl_stmt|;
name|struct
name|in6_addr
name|s_mask
decl_stmt|,
name|g_mask
decl_stmt|;
name|u_int8
name|s_flags
decl_stmt|;
name|u_int8
name|reserved
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|int
name|state_change
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* Either a local vif or somehow received PIM_GRAFT from 		 * non-directly connected router. Ignore it. 		 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_GRAFT from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|VIFF_NONBRS
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the target address */
name|GET_EUADDR6
argument_list|(
operator|&
name|uni_target_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|reserved
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|num_groups
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_groups
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* No indication for groups in the message */
name|GET_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM %s received from %s on mif %d, grps: %d"
argument_list|,
name|pimtype
operator|==
name|PIM_GRAFT
condition|?
literal|"GRAFT"
else|:
literal|"GRAFT-ACK"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|mifi
argument_list|,
name|num_groups
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|source
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
while|while
condition|(
name|num_groups
operator|--
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"  PIM graft: grp: %s, plen: %d, %d jsrcs, %d psrcs"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_group
operator|.
name|mcast_addr
argument_list|)
argument_list|,
name|encod_group
operator|.
name|masklen
argument_list|,
name|num_j_srcs
argument_list|,
name|num_p_srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|encod_group
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_group
operator|.
name|masklen
argument_list|,
name|g_mask
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Ignore this group and jump to the next */
block|}
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|pimtype
operator|==
name|PIM_GRAFT
condition|)
block|{
comment|/* Graft */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tGRAFT src %s, group %s - "
literal|"forward data on mif %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mifi
argument_list|)
expr_stmt|;
comment|/* Cancel any delayed prune */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
condition|)
block|{
name|timer_clearTimer
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|prune_delay_timerids
index|[
name|mifi
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Add to oiflist (unprune) */
if|if
condition|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
condition|)
block|{
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|prune_timers
index|[
name|mifi
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state_change
operator|=
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_change
operator|==
literal|1
condition|)
name|trigger_join_alert
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Graft */
else|else
block|{
comment|/* Graft-Ack */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\tGRAFT-ACK src %s, group %s - "
literal|"forward data on mif %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|mifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|graft
condition|)
name|delete_pim6_graft_entry
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ignore anything in the prune portion of the message! */
block|}
comment|/* Respond to graft with a graft-ack */
if|if
condition|(
name|pimtype
operator|==
name|PIM_GRAFT
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_GRAFT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending GRAFT-ACK: mif %s, dst %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pim_message
argument_list|,
name|pim6_send_buf
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|src
argument_list|,
name|PIM_GRAFT_ACK
argument_list|,
name|datalen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_pim6_graft
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|pim_graft_entry_t
modifier|*
name|new_graft
decl_stmt|;
name|int
name|was_sent
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|graft
operator|!=
operator|(
name|pim_graft_entry_t
operator|*
operator|)
name|NULL
condition|)
comment|/* Already sending grafts */
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Send the first graft */
name|was_sent
operator|=
name|retransmit_pim6_graft
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|was_sent
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Set up retransmission */
name|new_graft
operator|=
operator|(
name|pim_graft_entry_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pim_graft_entry_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_graft
operator|==
operator|(
name|pim_graft_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Memory allocation error for graft entry src %s, grp %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|new_graft
operator|->
name|next
operator|=
name|graft_list
expr_stmt|;
name|new_graft
operator|->
name|prev
operator|=
operator|(
name|pim_graft_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|new_graft
operator|->
name|mrtlink
operator|=
name|mrtentry_ptr
expr_stmt|;
if|if
condition|(
name|graft_list
condition|)
name|graft_list
operator|->
name|prev
operator|=
name|new_graft
expr_stmt|;
name|graft_list
operator|=
name|new_graft
expr_stmt|;
name|mrtentry_ptr
operator|->
name|graft
operator|=
name|new_graft
expr_stmt|;
comment|/* Set up timer if not running */
if|if
condition|(
operator|!
name|graft_retrans_timer
condition|)
name|graft_retrans_timer
operator|=
name|timer_setTimer
argument_list|(
name|PIM_GRAFT_RETRANS_PERIOD
argument_list|,
name|retransmit_all_pim6_grafts
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

end_unit

