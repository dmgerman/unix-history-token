begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Nokia Corporation  * All rights reserved.  *  * This software was developed by Attilio Rao for the IPSO project under  * contract to Nokia Corporation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* NB: Make sure FNBUFF is as large as LNBUFF, otherwise it could overflow */
end_comment

begin_define
define|#
directive|define
name|FNBUFF
value|512
end_define

begin_define
define|#
directive|define
name|LNBUFF
value|512
end_define

begin_define
define|#
directive|define
name|TMPPATH
value|"/tmp/pmcannotate.XXXXXX"
end_define

begin_define
define|#
directive|define
name|FATAL
parameter_list|(
name|ptr
parameter_list|,
name|x
modifier|...
parameter_list|)
value|do {						\ 	fqueue_deleteall();						\ 	general_deleteall();						\ 	if ((ptr) != NULL)						\ 		perror(ptr);						\ 	fprintf(stderr, ##x);						\ 	remove(tbfl);							\ 	remove(tofl);							\ 	exit(EXIT_FAILURE);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|PERCSAMP
parameter_list|(
name|x
parameter_list|)
value|((x) * 100 / totalsamples)
end_define

begin_struct
struct|struct
name|entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|entry
argument_list|)
name|en_iter
expr_stmt|;
name|char
modifier|*
name|en_name
decl_stmt|;
name|uintptr_t
name|en_pc
decl_stmt|;
name|uintptr_t
name|en_ostart
decl_stmt|;
name|uintptr_t
name|en_oend
decl_stmt|;
name|u_int
name|en_nsamples
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aggent
block|{
name|TAILQ_ENTRY
argument_list|(
argument|aggent
argument_list|)
name|ag_fiter
expr_stmt|;
name|long
name|ag_offset
decl_stmt|;
name|uintptr_t
name|ag_ostart
decl_stmt|;
name|uintptr_t
name|ag_oend
decl_stmt|;
name|char
modifier|*
name|ag_name
decl_stmt|;
name|u_int
name|ag_nsamples
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|aggent
modifier|*
name|agg_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int
name|nsamples
parameter_list|,
name|uintptr_t
name|start
parameter_list|,
name|uintptr_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|agg_destroy
argument_list|(
expr|struct
name|aggent
operator|*
name|agg
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|asmparse
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cparse
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|entry_acqref
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|entry
modifier|*
name|entry_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|uintptr_t
name|start
parameter_list|,
name|uintptr_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|entry_destroy
argument_list|(
expr|struct
name|entry
operator|*
name|entry
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fqueue_compact
parameter_list|(
name|float
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fqueue_deleteall
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|aggent
modifier|*
name|fqueue_findent_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fqueue_getall
parameter_list|(
specifier|const
name|char
modifier|*
name|bin
parameter_list|,
name|char
modifier|*
name|temp
parameter_list|,
name|int
name|asmf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fqueue_insertent
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fqueue_insertgen
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|general_deleteall
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|entry
modifier|*
name|general_findent
parameter_list|(
name|uintptr_t
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|general_insertent
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|general_printasm
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|general_printc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|printblock
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
specifier|const
name|char
operator|*
name|progname
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|entry
argument_list|)
name|mainlst
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|mainlst
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|aggent
argument_list|)
name|fqueue
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|fqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Use a float value in order to automatically promote operations  * to return a float value rather than use casts.  */
end_comment

begin_decl_stmt
specifier|static
name|float
name|totalsamples
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Identifies a string cointaining objdump's assembly printout.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|isasminline
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|" %p%n"
argument_list|,
operator|&
name|ptr
argument_list|,
operator|&
name|nbytes
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|str
index|[
name|nbytes
index|]
operator|!=
literal|':'
operator|||
name|isspace
argument_list|(
name|str
index|[
name|nbytes
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Identifies a string containing objdump's assembly printout  * for a new function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|newfunction
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|fname
index|[
name|FNBUFF
index|]
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|str
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%p<%[^>:]>:%n"
argument_list|,
operator|&
name|ptr
argument_list|,
name|fname
argument_list|,
operator|&
name|nbytes
argument_list|)
operator|!=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new first-level aggregation object for a specified  * function.  */
end_comment

begin_function
specifier|static
name|struct
name|aggent
modifier|*
name|agg_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int
name|nsamples
parameter_list|,
name|uintptr_t
name|start
parameter_list|,
name|uintptr_t
name|end
parameter_list|)
block|{
name|struct
name|aggent
modifier|*
name|agg
decl_stmt|;
name|agg
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aggent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|agg
operator|->
name|ag_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg
operator|->
name|ag_name
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|agg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|agg
operator|->
name|ag_nsamples
operator|=
name|nsamples
expr_stmt|;
name|agg
operator|->
name|ag_ostart
operator|=
name|start
expr_stmt|;
name|agg
operator|->
name|ag_oend
operator|=
name|end
expr_stmt|;
return|return
operator|(
name|agg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a first-level aggregation object for a specified  * function.  */
end_comment

begin_function
specifier|static
name|void
name|agg_destroy
parameter_list|(
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
block|{
name|free
argument_list|(
name|agg
operator|->
name|ag_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|agg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Analyze the "objdump -d" output, locate functions and start  * printing out the assembly functions content.  * We do not use newfunction() because we actually need the  * function name in available form, but the heurstic used is  * the same.  */
end_comment

begin_function
specifier|static
name|void
name|asmparse
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LNBUFF
index|]
decl_stmt|,
name|fname
index|[
name|FNBUFF
index|]
decl_stmt|;
name|struct
name|aggent
modifier|*
name|agg
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%p<%[^>:]>:"
argument_list|,
operator|&
name|ptr
argument_list|,
name|fname
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
name|agg
operator|=
name|fqueue_findent_by_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg
operator|==
name|NULL
condition|)
continue|continue;
name|agg
operator|->
name|ag_offset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|agg
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|agg
operator|->
name|ag_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"Profile trace for function: %s() [%.2f%%]\n"
argument_list|,
name|agg
operator|->
name|ag_name
argument_list|,
name|PERCSAMP
argument_list|(
name|agg
operator|->
name|ag_nsamples
argument_list|)
argument_list|)
expr_stmt|;
name|general_printasm
argument_list|(
name|fp
argument_list|,
name|agg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Analyze the "objdump -S" output, locate functions and start  * printing out the C functions content.  * We do not use newfunction() because we actually need the  * function name in available form, but the heurstic used is  * the same.  * In order to maintain the printout sorted, on the first pass it  * simply stores the file offsets in order to fastly moved later  * (when the file is hot-cached also) when the real printout will  * happen.  */
end_comment

begin_function
specifier|static
name|int
name|cparse
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LNBUFF
index|]
decl_stmt|,
name|fname
index|[
name|FNBUFF
index|]
decl_stmt|;
name|struct
name|aggent
modifier|*
name|agg
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%p<%[^>:]>:"
argument_list|,
operator|&
name|ptr
argument_list|,
name|fname
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
name|agg
operator|=
name|fqueue_findent_by_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg
operator|==
name|NULL
condition|)
continue|continue;
name|agg
operator|->
name|ag_offset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|agg
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|agg
operator|->
name|ag_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|printf
argument_list|(
literal|"Profile trace for function: %s() [%.2f%%]\n"
argument_list|,
name|agg
operator|->
name|ag_name
argument_list|,
name|PERCSAMP
argument_list|(
name|agg
operator|->
name|ag_nsamples
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|general_printc
argument_list|(
name|fp
argument_list|,
name|agg
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bump the number of samples for any raw entry.  */
end_comment

begin_function
specifier|static
name|void
name|entry_acqref
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|en_nsamples
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new raw entry object for a specified function.  */
end_comment

begin_function
specifier|static
name|struct
name|entry
modifier|*
name|entry_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|uintptr_t
name|start
parameter_list|,
name|uintptr_t
name|end
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|obj
operator|->
name|en_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|en_name
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|obj
operator|->
name|en_pc
operator|=
name|pc
expr_stmt|;
name|obj
operator|->
name|en_ostart
operator|=
name|start
expr_stmt|;
name|obj
operator|->
name|en_oend
operator|=
name|end
expr_stmt|;
name|obj
operator|->
name|en_nsamples
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a raw entry object for a specified function.  */
end_comment

begin_function
specifier|static
name|void
name|entry_destroy
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
block|{
name|free
argument_list|(
name|entry
operator|->
name|en_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Specify a lower bound in percentage and drop from the  * first-level aggregation queue all the objects with a  * smaller impact.  */
end_comment

begin_function
specifier|static
name|void
name|fqueue_compact
parameter_list|(
name|float
name|th
parameter_list|)
block|{
name|u_int
name|thi
decl_stmt|;
name|struct
name|aggent
modifier|*
name|agg
decl_stmt|,
modifier|*
name|tmpagg
decl_stmt|;
if|if
condition|(
name|totalsamples
operator|==
literal|0
condition|)
return|return;
comment|/* Revert the percentage calculation. */
name|thi
operator|=
name|th
operator|*
name|totalsamples
operator|/
literal|100
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|agg
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|,
argument|tmpagg
argument_list|)
if|if
condition|(
name|agg
operator|->
name|ag_nsamples
operator|<
name|thi
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|fqueue
argument_list|,
name|agg
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the first-level aggregates queue.  */
end_comment

begin_function
specifier|static
name|void
name|fqueue_deleteall
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|aggent
modifier|*
name|agg
decl_stmt|;
while|while
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|fqueue
argument_list|)
operator|==
literal|0
condition|)
block|{
name|agg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|fqueue
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|fqueue
argument_list|,
name|agg
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Insert a raw entry into the aggregations queue.  * If the respective first-level aggregation object  * does not exist create it and maintain it sorted  * in respect of the number of samples.  */
end_comment

begin_function
specifier|static
name|int
name|fqueue_insertent
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|aggent
modifier|*
name|obj
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|obj
operator|->
name|ag_name
argument_list|,
name|entry
operator|->
name|en_name
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|obj
operator|->
name|ag_nsamples
operator|+=
name|entry
operator|->
name|en_nsamples
expr_stmt|;
break|break;
block|}
comment|/* 	 * If the first-level aggregation object already exists, 	 * just aggregate the samples and, if needed, resort 	 * it. 	 */
if|if
condition|(
name|found
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|fqueue
argument_list|,
name|obj
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
if|if
condition|(
name|obj
operator|->
name|ag_nsamples
operator|>
name|tmp
operator|->
name|ag_nsamples
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tmp
argument_list|,
name|obj
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fqueue
argument_list|,
name|obj
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the first-level aggregation object does not 	 * exist, create it and put in the sorted queue. 	 * If this is the first object, we need to set the 	 * head of the queue. 	 */
name|obj
operator|=
name|agg_create
argument_list|(
name|entry
operator|->
name|en_name
argument_list|,
name|entry
operator|->
name|en_nsamples
argument_list|,
name|entry
operator|->
name|en_ostart
argument_list|,
name|entry
operator|->
name|en_oend
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|fqueue
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|fqueue
argument_list|,
name|obj
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
if|if
condition|(
name|obj
operator|->
name|ag_nsamples
operator|>
name|tmp
operator|->
name|ag_nsamples
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tmp
argument_list|,
name|obj
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|fqueue
argument_list|,
name|obj
argument_list|,
name|ag_fiter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a first-level aggregation object by name.  */
end_comment

begin_function
specifier|static
name|struct
name|aggent
modifier|*
name|fqueue_findent_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|aggent
modifier|*
name|obj
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|obj
operator|->
name|ag_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|obj
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of object in the first-level aggregations queue.  */
end_comment

begin_function
specifier|static
name|int
name|fqueue_getall
parameter_list|(
specifier|const
name|char
modifier|*
name|bin
parameter_list|,
name|char
modifier|*
name|temp
parameter_list|,
name|int
name|asmf
parameter_list|)
block|{
name|char
name|tmpf
index|[
name|MAXPATHLEN
operator|*
literal|2
operator|+
literal|50
index|]
decl_stmt|;
name|struct
name|aggent
modifier|*
name|agg
decl_stmt|;
name|uintptr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|mkstemp
argument_list|(
name|temp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|agg
argument_list|,
argument|&fqueue
argument_list|,
argument|ag_fiter
argument_list|)
block|{
name|bzero
argument_list|(
name|tmpf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpf
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|agg
operator|->
name|ag_ostart
expr_stmt|;
name|end
operator|=
name|agg
operator|->
name|ag_oend
expr_stmt|;
comment|/* 		 * Fix-up the end address in order to show it in the objdump's 		 * trace. 		 */
name|end
operator|++
expr_stmt|;
if|if
condition|(
name|asmf
condition|)
name|snprintf
argument_list|(
name|tmpf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpf
argument_list|)
argument_list|,
literal|"objdump --start-address=%p "
literal|"--stop-address=%p -d %s>> %s"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|end
argument_list|,
name|bin
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tmpf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpf
argument_list|)
argument_list|,
literal|"objdump --start-address=%p "
literal|"--stop-address=%p -S %s>> %s"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|end
argument_list|,
name|bin
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|tmpf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert all the raw entries present in the general queue  * into the first-level aggregations queue.  */
end_comment

begin_function
specifier|static
name|int
name|fqueue_insertgen
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&mainlst
argument_list|,
argument|en_iter
argument_list|)
if|if
condition|(
name|fqueue_insertent
argument_list|(
name|obj
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the raw entries general queue.  */
end_comment

begin_function
specifier|static
name|void
name|general_deleteall
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
while|while
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mainlst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obj
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mainlst
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mainlst
argument_list|,
name|obj
argument_list|,
name|en_iter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a raw entry by the PC.  */
end_comment

begin_function
specifier|static
name|struct
name|entry
modifier|*
name|general_findent
parameter_list|(
name|uintptr_t
name|pc
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|&mainlst
argument_list|,
argument|en_iter
argument_list|)
if|if
condition|(
name|obj
operator|->
name|en_pc
operator|==
name|pc
condition|)
return|return
operator|(
name|obj
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a new raw entry in the general queue.  */
end_comment

begin_function
specifier|static
name|void
name|general_insertent
parameter_list|(
name|struct
name|entry
modifier|*
name|entry
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mainlst
argument_list|,
name|entry
argument_list|,
name|en_iter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Printout the body of an "objdump -d" assembly function.  * It does simply stops when a new function is encountered,  * bringing back the file position in order to not mess up  * subsequent analysis.  * C lines and others not recognized are simply skipped.  */
end_comment

begin_function
specifier|static
name|void
name|general_printasm
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LNBUFF
index|]
decl_stmt|;
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|nbytes
operator|=
name|newfunction
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
name|nbytes
operator|*
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isasminline
argument_list|(
name|buffer
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|" %p:"
argument_list|,
operator|&
name|ptr
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
name|obj
operator|=
name|general_findent
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"\t| %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%.2f%%\t| %s"
argument_list|,
operator|(
name|float
operator|)
name|obj
operator|->
name|en_nsamples
operator|*
literal|100
operator|/
name|agg
operator|->
name|ag_nsamples
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Printout the body of an "objdump -S" function.  * It does simply stops when a new function is encountered,  * bringing back the file position in order to not mess up  * subsequent analysis.  * It expect from the starting to the end to find, always, valid blocks  * (see below for an explanation of the "block" concept).  */
end_comment

begin_function
specifier|static
name|int
name|general_printc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LNBUFF
index|]
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fseek
argument_list|(
name|fp
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|*
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfunction
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|printblock
argument_list|(
name|fp
argument_list|,
name|agg
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Printout a single block inside an "objdump -S" function.  * The block is composed of a first part in C and subsequent translation  * in assembly.  * This code also operates a second-level aggregation packing together  * samples relative to PCs into a (lower bottom) block with their  * C (higher half) counterpart.  */
end_comment

begin_function
specifier|static
name|int
name|printblock
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|aggent
modifier|*
name|agg
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LNBUFF
index|]
decl_stmt|;
name|long
name|lstart
decl_stmt|;
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
name|u_int
name|tnsamples
decl_stmt|;
name|int
name|done
decl_stmt|,
name|nbytes
decl_stmt|,
name|sentinel
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * We expect the first thing of the block is C code, so simply give 	 * up if asm line is found. 	 */
name|lstart
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sentinel
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isasminline
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|sentinel
operator|=
literal|1
expr_stmt|;
name|nbytes
operator|=
name|newfunction
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|nbytes
operator|*
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * If the sentinel is not set, it means it did not match any 	 * "high half" for this code so simply give up. 	 * Operates the second-level aggregation. 	 */
name|tnsamples
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sentinel
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|" %p:"
argument_list|,
operator|&
name|ptr
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|obj
operator|=
name|general_findent
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|tnsamples
operator|+=
name|obj
operator|->
name|en_nsamples
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
name|isasminline
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
do|;
comment|/* Rewind to the start of the block in order to start the printout. */
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|lstart
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Again the high half of the block rappresenting the C part. */
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
name|isasminline
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tnsamples
operator|==
literal|0
operator|||
name|done
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\t| %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|else
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%.2f%%\t| %s"
argument_list|,
operator|(
name|float
operator|)
name|tnsamples
operator|*
literal|100
operator|/
name|agg
operator|->
name|ag_nsamples
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Again the low half of the block rappresenting the asm 	 * translation part. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isasminline
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|nbytes
operator|=
name|newfunction
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|nbytes
operator|*
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|*
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper printout functions.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-a] [-h] [-k kfile] [-l lb] pmcraw.out binary\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LNBUFF
index|]
decl_stmt|,
name|fname
index|[
name|FNBUFF
index|]
decl_stmt|,
name|tbfl
index|[]
init|=
name|TMPPATH
decl_stmt|,
name|tofl
index|[]
init|=
name|TMPPATH
decl_stmt|;
name|char
name|tmpf
index|[
name|MAXPATHLEN
operator|*
literal|2
operator|+
literal|50
index|]
decl_stmt|;
name|float
name|limit
decl_stmt|;
name|char
modifier|*
name|bin
decl_stmt|,
modifier|*
name|exec
decl_stmt|,
modifier|*
name|kfile
decl_stmt|,
modifier|*
name|ofile
decl_stmt|;
name|struct
name|entry
modifier|*
name|obj
decl_stmt|;
name|FILE
modifier|*
name|gfp
decl_stmt|,
modifier|*
name|bfp
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|hstart
decl_stmt|,
modifier|*
name|hend
decl_stmt|;
name|uintptr_t
name|tmppc
decl_stmt|,
name|ostart
decl_stmt|,
name|oend
decl_stmt|;
name|int
name|cget
decl_stmt|,
name|asmsrc
decl_stmt|;
name|exec
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|ofile
operator|=
name|NULL
expr_stmt|;
name|bin
operator|=
name|NULL
expr_stmt|;
name|kfile
operator|=
name|NULL
expr_stmt|;
name|asmsrc
operator|=
literal|0
expr_stmt|;
name|limit
operator|=
literal|0.5
expr_stmt|;
while|while
condition|(
operator|(
name|cget
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ahl:k:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|cget
condition|)
block|{
case|case
literal|'a'
case|:
name|asmsrc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|kfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|limit
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|exec
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|usage
argument_list|(
name|exec
argument_list|)
expr_stmt|;
name|ofile
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|bin
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|bin
argument_list|,
name|R_OK
operator||
name|F_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to locate the binary file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|ofile
argument_list|,
name|R_OK
operator||
name|F_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to locate the pmcstat file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfile
operator|!=
name|NULL
operator|&&
name|access
argument_list|(
name|kfile
argument_list|,
name|R_OK
operator||
name|F_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to locate the kernel file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tmpf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkstemp
argument_list|(
name|tofl
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to create the tmp file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfile
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|tmpf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpf
argument_list|)
argument_list|,
literal|"pmcstat -k %s -R %s -m %s"
argument_list|,
name|kfile
argument_list|,
name|ofile
argument_list|,
name|tofl
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tmpf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpf
argument_list|)
argument_list|,
literal|"pmcstat -R %s -m %s"
argument_list|,
name|ofile
argument_list|,
name|tofl
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|tmpf
argument_list|)
operator|!=
literal|0
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to create the tmp file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|gfp
operator|=
name|fopen
argument_list|(
name|tofl
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfp
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to open the map file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
comment|/* 	 * Make the collection of raw entries from a pmcstat mapped file. 	 * The heuristic here wants strings in the form: 	 * "addr funcname startfaddr endfaddr". 	 */
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LNBUFF
argument_list|,
name|gfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%p %s %p %p\n"
argument_list|,
operator|&
name|ptr
argument_list|,
name|fname
argument_list|,
operator|&
name|hstart
argument_list|,
operator|&
name|hend
argument_list|)
operator|!=
literal|4
condition|)
name|FATAL
argument_list|(
name|NULL
argument_list|,
literal|"%s: Invalid scan of function in the map file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|ostart
operator|=
operator|(
name|uintptr_t
operator|)
name|hstart
expr_stmt|;
name|oend
operator|=
operator|(
name|uintptr_t
operator|)
name|hend
expr_stmt|;
name|tmppc
operator|=
operator|(
name|uintptr_t
operator|)
name|ptr
expr_stmt|;
name|totalsamples
operator|++
expr_stmt|;
name|obj
operator|=
name|general_findent
argument_list|(
name|tmppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|entry_acqref
argument_list|(
name|obj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|obj
operator|=
name|entry_create
argument_list|(
name|fname
argument_list|,
name|tmppc
argument_list|,
name|ostart
argument_list|,
name|oend
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to create a new object\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|general_insertent
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|gfp
argument_list|)
operator|==
name|EOF
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to close the filedesc\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|tofl
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to remove the tmpfile\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the loose end objects and feed the first-level aggregation 	 * queue. 	 */
if|if
condition|(
name|fqueue_insertgen
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to generate an analysis\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|fqueue_compact
argument_list|(
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fqueue_getall
argument_list|(
name|bin
argument_list|,
name|tbfl
argument_list|,
name|asmsrc
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to create the tmp file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
name|bfp
operator|=
name|fopen
argument_list|(
name|tbfl
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfp
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to open the binary file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmsrc
operator|!=
literal|0
condition|)
name|asmparse
argument_list|(
name|bfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cparse
argument_list|(
name|bfp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|NULL
argument_list|,
literal|"%s: Invalid format for the C file\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|bfp
argument_list|)
operator|==
name|EOF
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to close the filedesc\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|tbfl
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
name|exec
argument_list|,
literal|"%s: Impossible to remove the tmpfile\n"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

