begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013  Chris Torek<torek @ torek net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"bhyverun.h"
end_include

begin_include
include|#
directive|include
file|"pci_emul.h"
end_include

begin_include
include|#
directive|include
file|"virtio.h"
end_include

begin_comment
comment|/*  * Functions for dealing with generalized "virtual devices" as  * defined by<https://www.google.com/#output=search&q=virtio+spec>  */
end_comment

begin_comment
comment|/*  * In case we decide to relax the "virtio softc comes at the  * front of virtio-based device softc" constraint, let's use  * this to convert.  */
end_comment

begin_define
define|#
directive|define
name|DEV_SOFTC
parameter_list|(
name|vs
parameter_list|)
value|((void *)(vs))
end_define

begin_comment
comment|/*  * Link a virtio_softc to its constants, the device softc, and  * the PCI emulation.  */
end_comment

begin_function
name|void
name|vi_softc_linkup
parameter_list|(
name|struct
name|virtio_softc
modifier|*
name|vs
parameter_list|,
name|struct
name|virtio_consts
modifier|*
name|vc
parameter_list|,
name|void
modifier|*
name|dev_softc
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|struct
name|vqueue_info
modifier|*
name|queues
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* vs and dev_softc addresses must match */
name|assert
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vs
operator|==
name|dev_softc
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_vc
operator|=
name|vc
expr_stmt|;
name|vs
operator|->
name|vs_pi
operator|=
name|pi
expr_stmt|;
name|pi
operator|->
name|pi_arg
operator|=
name|vs
expr_stmt|;
name|vs
operator|->
name|vs_queues
operator|=
name|queues
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vc
operator|->
name|vc_nvq
condition|;
name|i
operator|++
control|)
block|{
name|queues
index|[
name|i
index|]
operator|.
name|vq_vs
operator|=
name|vs
expr_stmt|;
name|queues
index|[
name|i
index|]
operator|.
name|vq_num
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reset device (device-wide).  This erases all queues, i.e.,  * all the queues become invalid (though we don't wipe out the  * internal pointers, we just clear the VQ_ALLOC flag).  *  * It resets negotiated features to "none".  *  * If MSI-X is enabled, this also resets all the vectors to NO_VECTOR.  */
end_comment

begin_function
name|void
name|vi_reset_dev
parameter_list|(
name|struct
name|virtio_softc
modifier|*
name|vs
parameter_list|)
block|{
name|struct
name|vqueue_info
modifier|*
name|vq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nvq
decl_stmt|;
name|nvq
operator|=
name|vs
operator|->
name|vs_vc
operator|->
name|vc_nvq
expr_stmt|;
for|for
control|(
name|vq
operator|=
name|vs
operator|->
name|vs_queues
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvq
condition|;
name|vq
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|vq
operator|->
name|vq_flags
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|vq_last_avail
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|vq_pfn
operator|=
literal|0
expr_stmt|;
name|vq
operator|->
name|vq_msix_idx
operator|=
name|VIRTIO_MSI_NO_VECTOR
expr_stmt|;
block|}
name|vs
operator|->
name|vs_negotiated_caps
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_curq
operator|=
literal|0
expr_stmt|;
comment|/* vs->vs_status = 0; -- redundant */
name|VS_LOCK
argument_list|(
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_isr
condition|)
name|pci_lintr_deassert
argument_list|(
name|vs
operator|->
name|vs_pi
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_isr
operator|=
literal|0
expr_stmt|;
name|VS_UNLOCK
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_msix_cfg_idx
operator|=
name|VIRTIO_MSI_NO_VECTOR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set I/O BAR (usually 0) to map PCI config registers.  */
end_comment

begin_function
name|void
name|vi_set_io_bar
parameter_list|(
name|struct
name|virtio_softc
modifier|*
name|vs
parameter_list|,
name|int
name|barnum
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
comment|/* 	 * ??? should we use CFG0 if MSI-X is disabled? 	 * Existing code did not... 	 */
name|size
operator|=
name|VTCFG_R_CFG1
operator|+
name|vs
operator|->
name|vs_vc
operator|->
name|vc_cfgsize
expr_stmt|;
name|pci_emul_alloc_bar
argument_list|(
name|vs
operator|->
name|vs_pi
argument_list|,
name|barnum
argument_list|,
name|PCIBAR_IO
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize MSI-X vector capabilities if we're to use MSI-X,  * or MSI capabilities if not.  *  * We assume we want one MSI-X vector per queue, here, plus one  * for the config vec.  */
end_comment

begin_function
name|int
name|vi_intr_init
parameter_list|(
name|struct
name|virtio_softc
modifier|*
name|vs
parameter_list|,
name|int
name|barnum
parameter_list|,
name|int
name|use_msix
parameter_list|)
block|{
name|int
name|nvec
decl_stmt|;
if|if
condition|(
name|use_msix
condition|)
block|{
name|vs
operator|->
name|vs_flags
operator||=
name|VIRTIO_USE_MSIX
expr_stmt|;
name|vi_reset_dev
argument_list|(
name|vs
argument_list|)
expr_stmt|;
comment|/* set all vectors to NO_VECTOR */
name|nvec
operator|=
name|vs
operator|->
name|vs_vc
operator|->
name|vc_nvq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pci_emul_add_msixcap
argument_list|(
name|vs
operator|->
name|vs_pi
argument_list|,
name|nvec
argument_list|,
name|barnum
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|vs
operator|->
name|vs_flags
operator|&=
operator|~
name|VIRTIO_USE_MSIX
expr_stmt|;
comment|/* Only 1 MSI vector for bhyve */
name|pci_emul_add_msicap
argument_list|(
name|vs
operator|->
name|vs_pi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the currently-selected virtio queue (vs->vs_curq).  * The guest just gave us a page frame number, from which we can  * calculate the addresses of the queue.  */
end_comment

begin_function
name|void
name|vi_vq_init
parameter_list|(
name|struct
name|virtio_softc
modifier|*
name|vs
parameter_list|,
name|uint32_t
name|pfn
parameter_list|)
block|{
name|struct
name|vqueue_info
modifier|*
name|vq
decl_stmt|;
name|uint64_t
name|phys
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|vq
operator|=
operator|&
name|vs
operator|->
name|vs_queues
index|[
name|vs
operator|->
name|vs_curq
index|]
expr_stmt|;
name|vq
operator|->
name|vq_pfn
operator|=
name|pfn
expr_stmt|;
name|phys
operator|=
operator|(
name|uint64_t
operator|)
name|pfn
operator|<<
name|VRING_PFN
expr_stmt|;
name|size
operator|=
name|vring_size
argument_list|(
name|vq
operator|->
name|vq_qsize
argument_list|)
expr_stmt|;
name|base
operator|=
name|paddr_guest2host
argument_list|(
name|vs
operator|->
name|vs_pi
operator|->
name|pi_vmctx
argument_list|,
name|phys
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* First page(s) are descriptors... */
name|vq
operator|->
name|vq_desc
operator|=
operator|(
expr|struct
name|virtio_desc
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
name|vq
operator|->
name|vq_qsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_desc
argument_list|)
expr_stmt|;
comment|/* ... immediately followed by "avail" ring (entirely uint16_t's) */
name|vq
operator|->
name|vq_avail
operator|=
operator|(
expr|struct
name|vring_avail
operator|*
operator|)
name|base
expr_stmt|;
name|base
operator|+=
operator|(
literal|2
operator|+
name|vq
operator|->
name|vq_qsize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
comment|/* Then it's rounded up to the next page... */
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|roundup2
argument_list|(
operator|(
name|uintptr_t
operator|)
name|base
argument_list|,
name|VRING_ALIGN
argument_list|)
expr_stmt|;
comment|/* ... and the last page(s) are the used ring. */
name|vq
operator|->
name|vq_used
operator|=
operator|(
expr|struct
name|vring_used
operator|*
operator|)
name|base
expr_stmt|;
comment|/* Mark queue as allocated, and start at 0 when we use it. */
name|vq
operator|->
name|vq_flags
operator|=
name|VQ_ALLOC
expr_stmt|;
name|vq
operator|->
name|vq_last_avail
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper inline for vq_getchain(): record the i'th "real"  * descriptor.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_vq_record
parameter_list|(
name|int
name|i
parameter_list|,
specifier|volatile
name|struct
name|virtio_desc
modifier|*
name|vd
parameter_list|,
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
name|n_iov
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
name|n_iov
condition|)
return|return;
name|iov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|paddr_guest2host
argument_list|(
name|ctx
argument_list|,
name|vd
operator|->
name|vd_addr
argument_list|,
name|vd
operator|->
name|vd_len
argument_list|)
expr_stmt|;
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|vd
operator|->
name|vd_len
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|NULL
condition|)
name|flags
index|[
name|i
index|]
operator|=
name|vd
operator|->
name|vd_flags
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|VQ_MAX_DESCRIPTORS
value|512
end_define

begin_comment
comment|/* see below */
end_comment

begin_comment
comment|/*  * Examine the chain of descriptors starting at the "next one" to  * make sure that they describe a sensible request.  If so, return  * the number of "real" descriptors that would be needed/used in  * acting on this request.  This may be smaller than the number of  * available descriptors, e.g., if there are two available but  * they are two separate requests, this just returns 1.  Or, it  * may be larger: if there are indirect descriptors involved,  * there may only be one descriptor available but it may be an  * indirect pointing to eight more.  We return 8 in this case,  * i.e., we do not count the indirect descriptors, only the "real"  * ones.  *  * Basically, this vets the vd_flags and vd_next field of each  * descriptor and tells you how many are involved.  Since some may  * be indirect, this also needs the vmctx (in the pci_devinst  * at vs->vs_pi) so that it can find indirect descriptors.  *  * As we process each descriptor, we copy and adjust it (guest to  * host address wise, also using the vmtctx) into the given iov[]  * array (of the given size).  If the array overflows, we stop  * placing values into the array but keep processing descriptors,  * up to VQ_MAX_DESCRIPTORS, before giving up and returning -1.  * So you, the caller, must not assume that iov[] is as big as the  * return value (you can process the same thing twice to allocate  * a larger iov array if needed, or supply a zero length to find  * out how much space is needed).  *  * If you want to verify the WRITE flag on each descriptor, pass a  * non-NULL "flags" pointer to an array of "uint16_t" of the same size  * as n_iov and we'll copy each vd_flags field after unwinding any  * indirects.  *  * If some descriptor(s) are invalid, this prints a diagnostic message  * and returns -1.  If no descriptors are ready now it simply returns 0.  *  * You are assumed to have done a vq_ring_ready() if needed (note  * that vq_has_descs() does one).  */
end_comment

begin_function
name|int
name|vq_getchain
parameter_list|(
name|struct
name|vqueue_info
modifier|*
name|vq
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
name|n_iov
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|ndesc
decl_stmt|,
name|n_indir
decl_stmt|;
name|u_int
name|idx
decl_stmt|,
name|head
decl_stmt|,
name|next
decl_stmt|;
specifier|volatile
name|struct
name|virtio_desc
modifier|*
name|vdir
decl_stmt|,
modifier|*
name|vindir
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|struct
name|vmctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|virtio_softc
modifier|*
name|vs
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|vs
operator|=
name|vq
operator|->
name|vq_vs
expr_stmt|;
name|name
operator|=
name|vs
operator|->
name|vs_vc
operator|->
name|vc_name
expr_stmt|;
comment|/* 	 * Note: it's the responsibility of the guest not to 	 * update vq->vq_avail->va_idx until all of the descriptors          * the guest has written are valid (including all their          * vd_next fields and vd_flags). 	 * 	 * Compute (last_avail - va_idx) in integers mod 2**16.  This is 	 * the number of descriptors the device has made available 	 * since the last time we updated vq->vq_last_avail. 	 * 	 * We just need to do the subtraction as an unsigned int, 	 * then trim off excess bits. 	 */
name|idx
operator|=
name|vq
operator|->
name|vq_last_avail
expr_stmt|;
name|ndesc
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|u_int
operator|)
name|vq
operator|->
name|vq_avail
operator|->
name|va_idx
operator|-
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndesc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ndesc
operator|>
name|vq
operator|->
name|vq_qsize
condition|)
block|{
comment|/* XXX need better way to diagnose issues */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ndesc (%u) out of range, driver confused?\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|ndesc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Now count/parse "involved" descriptors starting from 	 * the head of the chain. 	 * 	 * To prevent loops, we could be more complicated and 	 * check whether we're re-visiting a previously visited 	 * index, but we just abort if the count gets excessive. 	 */
name|ctx
operator|=
name|vs
operator|->
name|vs_pi
operator|->
name|pi_vmctx
expr_stmt|;
name|head
operator|=
name|vq
operator|->
name|vq_avail
operator|->
name|va_ring
index|[
name|idx
operator|&
operator|(
name|vq
operator|->
name|vq_qsize
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|next
operator|=
name|head
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VQ_MAX_DESCRIPTORS
condition|;
name|next
operator|=
name|vdir
operator|->
name|vd_next
control|)
block|{
if|if
condition|(
name|next
operator|>=
name|vq
operator|->
name|vq_qsize
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: descriptor index %u out of range, "
literal|"driver confused?\r\n"
argument_list|,
name|name
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|vdir
operator|=
operator|&
name|vq
operator|->
name|vq_desc
index|[
name|next
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vdir
operator|->
name|vd_flags
operator|&
name|VRING_DESC_F_INDIRECT
operator|)
operator|==
literal|0
condition|)
block|{
name|_vq_record
argument_list|(
name|i
argument_list|,
name|vdir
argument_list|,
name|ctx
argument_list|,
name|iov
argument_list|,
name|n_iov
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vs
operator|->
name|vs_negotiated_caps
operator|&
name|VIRTIO_RING_F_INDIRECT_DESC
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: descriptor has forbidden INDIRECT flag, "
literal|"driver confused?\r\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|n_indir
operator|=
name|vdir
operator|->
name|vd_len
operator|/
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|vdir
operator|->
name|vd_len
operator|&
literal|0xf
operator|)
operator|||
name|n_indir
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid indir len 0x%x, "
literal|"driver confused?\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|vdir
operator|->
name|vd_len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|vindir
operator|=
name|paddr_guest2host
argument_list|(
name|ctx
argument_list|,
name|vdir
operator|->
name|vd_addr
argument_list|,
name|vdir
operator|->
name|vd_len
argument_list|)
expr_stmt|;
comment|/* 			 * Indirects start at the 0th, then follow 			 * their own embedded "next"s until those run 			 * out.  Each one's indirect flag must be off 			 * (we don't really have to check, could just 			 * ignore errors...). 			 */
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|vp
operator|=
operator|&
name|vindir
index|[
name|next
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|vd_flags
operator|&
name|VRING_DESC_F_INDIRECT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: indirect desc has INDIR flag,"
literal|" driver confused?\r\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_vq_record
argument_list|(
name|i
argument_list|,
name|vp
argument_list|,
name|ctx
argument_list|,
name|iov
argument_list|,
name|n_iov
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
name|VQ_MAX_DESCRIPTORS
condition|)
goto|goto
name|loopy
goto|;
if|if
condition|(
operator|(
name|vp
operator|->
name|vd_flags
operator|&
name|VRING_DESC_F_NEXT
operator|)
operator|==
literal|0
condition|)
break|break;
name|next
operator|=
name|vp
operator|->
name|vd_next
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|n_indir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid next %u> %u, "
literal|"driver confused?\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|u_int
operator|)
name|next
argument_list|,
name|n_indir
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|vdir
operator|->
name|vd_flags
operator|&
name|VRING_DESC_F_NEXT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
name|loopy
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: descriptor loop? count> %d - driver confused?\r\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the currently-first request chain to the guest, setting  * its I/O length to the provided value.  *  * (This chain is the one you handled when you called vq_getchain()  * and used its positive return value.)  */
end_comment

begin_function
name|void
name|vq_relchain
parameter_list|(
name|struct
name|vqueue_info
modifier|*
name|vq
parameter_list|,
name|uint32_t
name|iolen
parameter_list|)
block|{
name|uint16_t
name|head
decl_stmt|,
name|uidx
decl_stmt|,
name|mask
decl_stmt|;
specifier|volatile
name|struct
name|vring_used
modifier|*
name|vuh
decl_stmt|;
specifier|volatile
name|struct
name|virtio_used
modifier|*
name|vue
decl_stmt|;
comment|/* 	 * Notes: 	 *  - mask is N-1 where N is a power of 2 so computes x % N 	 *  - vuh points to the "used" data shared with guest 	 *  - vue points to the "used" ring entry we want to update 	 *  - head is the same value we compute in vq_iovecs(). 	 * 	 * (I apologize for the two fields named vu_idx; the 	 * virtio spec calls the one that vue points to, "id"...) 	 */
name|mask
operator|=
name|vq
operator|->
name|vq_qsize
operator|-
literal|1
expr_stmt|;
name|vuh
operator|=
name|vq
operator|->
name|vq_used
expr_stmt|;
name|head
operator|=
name|vq
operator|->
name|vq_avail
operator|->
name|va_ring
index|[
name|vq
operator|->
name|vq_last_avail
operator|++
operator|&
name|mask
index|]
expr_stmt|;
name|uidx
operator|=
name|vuh
operator|->
name|vu_idx
expr_stmt|;
name|vue
operator|=
operator|&
name|vuh
operator|->
name|vu_ring
index|[
name|uidx
operator|++
operator|&
name|mask
index|]
expr_stmt|;
name|vue
operator|->
name|vu_idx
operator|=
name|head
expr_stmt|;
comment|/* ie, vue->id = head */
name|vue
operator|->
name|vu_tlen
operator|=
name|iolen
expr_stmt|;
name|vuh
operator|->
name|vu_idx
operator|=
name|uidx
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Driver has finished processing "available" chains and calling  * vq_relchain on each one.  If driver used all the available  * chains, used_all should be set.  *  * If the "used" index moved we may need to inform the guest, i.e.,  * deliver an interrupt.  Even if the used index did NOT move we  * may need to deliver an interrupt, if the avail ring is empty and  * we are supposed to interrupt on empty.  *  * Note that used_all_avail is provided by the caller because it's  * a snapshot of the ring state when he decided to finish interrupt  * processing -- it's possible that descriptors became available after  * that point.  (It's also typically a constant 1/True as well.)  */
end_comment

begin_function
name|void
name|vq_endchains
parameter_list|(
name|struct
name|vqueue_info
modifier|*
name|vq
parameter_list|,
name|int
name|used_all_avail
parameter_list|)
block|{
name|struct
name|virtio_softc
modifier|*
name|vs
decl_stmt|;
name|uint16_t
name|event_idx
decl_stmt|,
name|new_idx
decl_stmt|,
name|old_idx
decl_stmt|;
name|int
name|intr
decl_stmt|;
comment|/* 	 * Interrupt generation: if we're using EVENT_IDX, 	 * interrupt if we've crossed the event threshold. 	 * Otherwise interrupt is generated if we added "used" entries, 	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT. 	 * 	 * In any case, though, if NOTIFY_ON_EMPTY is set and the 	 * entire avail was processed, we need to interrupt always. 	 */
name|vs
operator|=
name|vq
operator|->
name|vq_vs
expr_stmt|;
name|new_idx
operator|=
name|vq
operator|->
name|vq_used
operator|->
name|vu_idx
expr_stmt|;
name|old_idx
operator|=
name|vq
operator|->
name|vq_save_used
expr_stmt|;
if|if
condition|(
name|used_all_avail
operator|&&
operator|(
name|vs
operator|->
name|vs_negotiated_caps
operator|&
name|VIRTIO_F_NOTIFY_ON_EMPTY
operator|)
condition|)
name|intr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|->
name|vs_negotiated_caps
operator|&
name|VIRTIO_RING_F_EVENT_IDX
condition|)
block|{
name|event_idx
operator|=
name|VQ_USED_EVENT_IDX
argument_list|(
name|vq
argument_list|)
expr_stmt|;
comment|/* 		 * This calculation is per docs and the kernel 		 * (see src/sys/dev/virtio/virtio_ring.h). 		 */
name|intr
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|new_idx
operator|-
name|event_idx
operator|-
literal|1
argument_list|)
operator|<
call|(
name|uint16_t
call|)
argument_list|(
name|new_idx
operator|-
name|old_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intr
operator|=
name|new_idx
operator|!=
name|old_idx
operator|&&
operator|!
operator|(
name|vq
operator|->
name|vq_avail
operator|->
name|va_flags
operator|&
name|VRING_AVAIL_F_NO_INTERRUPT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|intr
condition|)
name|vq_interrupt
argument_list|(
name|vs
argument_list|,
name|vq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note: these are in sorted order to make for a fast search */
end_comment

begin_struct
specifier|static
struct|struct
name|config_reg
block|{
name|uint16_t
name|cr_offset
decl_stmt|;
comment|/* register offset */
name|uint8_t
name|cr_size
decl_stmt|;
comment|/* size (bytes) */
name|uint8_t
name|cr_ro
decl_stmt|;
comment|/* true => reg is read only */
specifier|const
name|char
modifier|*
name|cr_name
decl_stmt|;
comment|/* name of reg */
block|}
name|config_regs
index|[]
init|=
block|{
block|{
name|VTCFG_R_HOSTCAP
block|,
literal|4
block|,
literal|1
block|,
literal|"HOSTCAP"
block|}
block|,
block|{
name|VTCFG_R_GUESTCAP
block|,
literal|4
block|,
literal|0
block|,
literal|"GUESTCAP"
block|}
block|,
block|{
name|VTCFG_R_PFN
block|,
literal|4
block|,
literal|0
block|,
literal|"PFN"
block|}
block|,
block|{
name|VTCFG_R_QNUM
block|,
literal|2
block|,
literal|1
block|,
literal|"QNUM"
block|}
block|,
block|{
name|VTCFG_R_QSEL
block|,
literal|2
block|,
literal|0
block|,
literal|"QSEL"
block|}
block|,
block|{
name|VTCFG_R_QNOTIFY
block|,
literal|2
block|,
literal|0
block|,
literal|"QNOTIFY"
block|}
block|,
block|{
name|VTCFG_R_STATUS
block|,
literal|1
block|,
literal|0
block|,
literal|"STATUS"
block|}
block|,
block|{
name|VTCFG_R_ISR
block|,
literal|1
block|,
literal|0
block|,
literal|"ISR"
block|}
block|,
block|{
name|VTCFG_R_CFGVEC
block|,
literal|2
block|,
literal|0
block|,
literal|"CFGVEC"
block|}
block|,
block|{
name|VTCFG_R_QVEC
block|,
literal|2
block|,
literal|0
block|,
literal|"QVEC"
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|config_reg
modifier|*
name|vi_find_cr
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|u_int
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|mid
decl_stmt|;
name|struct
name|config_reg
modifier|*
name|cr
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
sizeof|sizeof
argument_list|(
name|config_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|config_regs
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|hi
operator|>=
name|lo
condition|)
block|{
name|mid
operator|=
operator|(
name|hi
operator|+
name|lo
operator|)
operator|>>
literal|1
expr_stmt|;
name|cr
operator|=
operator|&
name|config_regs
index|[
name|mid
index|]
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_offset
operator|==
name|offset
condition|)
return|return
operator|(
name|cr
operator|)
return|;
if|if
condition|(
name|cr
operator|->
name|cr_offset
operator|<
name|offset
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|hi
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle pci config space reads.  * If it's to the MSI-X info, do that.  * If it's part of the virtio standard stuff, do that.  * Otherwise dispatch to the actual driver.  */
end_comment

begin_function
name|uint64_t
name|vi_pci_read
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|virtio_softc
modifier|*
name|vs
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
name|struct
name|virtio_consts
modifier|*
name|vc
decl_stmt|;
name|struct
name|config_reg
modifier|*
name|cr
decl_stmt|;
name|uint64_t
name|virtio_config_size
decl_stmt|,
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|newoff
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_flags
operator|&
name|VIRTIO_USE_MSIX
condition|)
block|{
if|if
condition|(
name|baridx
operator|==
name|pci_msix_table_bar
argument_list|(
name|pi
argument_list|)
operator|||
name|baridx
operator|==
name|pci_msix_pba_bar
argument_list|(
name|pi
argument_list|)
condition|)
block|{
return|return
operator|(
name|pci_emul_msix_tread
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* XXX probably should do something better than just assert() */
name|assert
argument_list|(
name|baridx
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_mtx
condition|)
name|pthread_mutex_lock
argument_list|(
name|vs
operator|->
name|vs_mtx
argument_list|)
expr_stmt|;
name|vc
operator|=
name|vs
operator|->
name|vs_vc
expr_stmt|;
name|name
operator|=
name|vc
operator|->
name|vc_name
expr_stmt|;
name|value
operator|=
name|size
operator|==
literal|1
condition|?
literal|0xff
else|:
name|size
operator|==
literal|2
condition|?
literal|0xffff
else|:
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|1
operator|&&
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|pci_msix_enabled
argument_list|(
name|pi
argument_list|)
condition|)
name|virtio_config_size
operator|=
name|VTCFG_R_CFG1
expr_stmt|;
else|else
name|virtio_config_size
operator|=
name|VTCFG_R_CFG0
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|virtio_config_size
condition|)
block|{
comment|/* 		 * Subtract off the standard size (including MSI-X 		 * registers if enabled) and dispatch to underlying driver. 		 * If that fails, fall into general code. 		 */
name|newoff
operator|=
name|offset
operator|-
name|virtio_config_size
expr_stmt|;
name|max
operator|=
name|vc
operator|->
name|vc_cfgsize
condition|?
name|vc
operator|->
name|vc_cfgsize
else|:
literal|0x100000000
expr_stmt|;
if|if
condition|(
name|newoff
operator|+
name|size
operator|>
name|max
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
call|(
modifier|*
name|vc
operator|->
name|vc_cfgread
call|)
argument_list|(
name|DEV_SOFTC
argument_list|(
name|vs
argument_list|)
argument_list|,
name|newoff
argument_list|,
name|size
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|bad
label|:
name|cr
operator|=
name|vi_find_cr
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
operator|||
name|cr
operator|->
name|cr_size
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
block|{
comment|/* offset must be OK, so size must be bad */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read from %s: bad size %d\r\n"
argument_list|,
name|name
argument_list|,
name|cr
operator|->
name|cr_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read from bad offset/size %jd/%d\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|VTCFG_R_HOSTCAP
case|:
name|value
operator|=
name|vc
operator|->
name|vc_hv_caps
expr_stmt|;
break|break;
case|case
name|VTCFG_R_GUESTCAP
case|:
name|value
operator|=
name|vs
operator|->
name|vs_negotiated_caps
expr_stmt|;
break|break;
case|case
name|VTCFG_R_PFN
case|:
if|if
condition|(
name|vs
operator|->
name|vs_curq
operator|<
name|vc
operator|->
name|vc_nvq
condition|)
name|value
operator|=
name|vs
operator|->
name|vs_queues
index|[
name|vs
operator|->
name|vs_curq
index|]
operator|.
name|vq_pfn
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QNUM
case|:
name|value
operator|=
name|vs
operator|->
name|vs_curq
operator|<
name|vc
operator|->
name|vc_nvq
condition|?
name|vs
operator|->
name|vs_queues
index|[
name|vs
operator|->
name|vs_curq
index|]
operator|.
name|vq_qsize
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QSEL
case|:
name|value
operator|=
name|vs
operator|->
name|vs_curq
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QNOTIFY
case|:
name|value
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|VTCFG_R_STATUS
case|:
name|value
operator|=
name|vs
operator|->
name|vs_status
expr_stmt|;
break|break;
case|case
name|VTCFG_R_ISR
case|:
name|value
operator|=
name|vs
operator|->
name|vs_isr
expr_stmt|;
name|vs
operator|->
name|vs_isr
operator|=
literal|0
expr_stmt|;
comment|/* a read clears this flag */
if|if
condition|(
name|value
condition|)
name|pci_lintr_deassert
argument_list|(
name|pi
argument_list|)
expr_stmt|;
break|break;
case|case
name|VTCFG_R_CFGVEC
case|:
name|value
operator|=
name|vs
operator|->
name|vs_msix_cfg_idx
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QVEC
case|:
name|value
operator|=
name|vs
operator|->
name|vs_curq
operator|<
name|vc
operator|->
name|vc_nvq
condition|?
name|vs
operator|->
name|vs_queues
index|[
name|vs
operator|->
name|vs_curq
index|]
operator|.
name|vq_msix_idx
else|:
name|VIRTIO_MSI_NO_VECTOR
expr_stmt|;
break|break;
block|}
name|done
label|:
if|if
condition|(
name|vs
operator|->
name|vs_mtx
condition|)
name|pthread_mutex_unlock
argument_list|(
name|vs
operator|->
name|vs_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle pci config space writes.  * If it's to the MSI-X info, do that.  * If it's part of the virtio standard stuff, do that.  * Otherwise dispatch to the actual driver.  */
end_comment

begin_function
name|void
name|vi_pci_write
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|struct
name|virtio_softc
modifier|*
name|vs
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
name|struct
name|vqueue_info
modifier|*
name|vq
decl_stmt|;
name|struct
name|virtio_consts
modifier|*
name|vc
decl_stmt|;
name|struct
name|config_reg
modifier|*
name|cr
decl_stmt|;
name|uint64_t
name|virtio_config_size
decl_stmt|,
name|max
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|newoff
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_flags
operator|&
name|VIRTIO_USE_MSIX
condition|)
block|{
if|if
condition|(
name|baridx
operator|==
name|pci_msix_table_bar
argument_list|(
name|pi
argument_list|)
operator|||
name|baridx
operator|==
name|pci_msix_pba_bar
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pci_emul_msix_twrite
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* XXX probably should do something better than just assert() */
name|assert
argument_list|(
name|baridx
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_mtx
condition|)
name|pthread_mutex_lock
argument_list|(
name|vs
operator|->
name|vs_mtx
argument_list|)
expr_stmt|;
name|vc
operator|=
name|vs
operator|->
name|vs_vc
expr_stmt|;
name|name
operator|=
name|vc
operator|->
name|vc_name
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|1
operator|&&
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|pci_msix_enabled
argument_list|(
name|pi
argument_list|)
condition|)
name|virtio_config_size
operator|=
name|VTCFG_R_CFG1
expr_stmt|;
else|else
name|virtio_config_size
operator|=
name|VTCFG_R_CFG0
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|virtio_config_size
condition|)
block|{
comment|/* 		 * Subtract off the standard size (including MSI-X 		 * registers if enabled) and dispatch to underlying driver. 		 */
name|newoff
operator|=
name|offset
operator|-
name|virtio_config_size
expr_stmt|;
name|max
operator|=
name|vc
operator|->
name|vc_cfgsize
condition|?
name|vc
operator|->
name|vc_cfgsize
else|:
literal|0x100000000
expr_stmt|;
if|if
condition|(
name|newoff
operator|+
name|size
operator|>
name|max
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
call|(
modifier|*
name|vc
operator|->
name|vc_cfgwrite
call|)
argument_list|(
name|DEV_SOFTC
argument_list|(
name|vs
argument_list|)
argument_list|,
name|newoff
argument_list|,
name|size
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|bad
label|:
name|cr
operator|=
name|vi_find_cr
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
name|NULL
operator|||
name|cr
operator|->
name|cr_size
operator|!=
name|size
operator|||
name|cr
operator|->
name|cr_ro
condition|)
block|{
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
block|{
comment|/* offset must be OK, wrong size and/or reg is R/O */
if|if
condition|(
name|cr
operator|->
name|cr_size
operator|!=
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write to %s: bad size %d\r\n"
argument_list|,
name|name
argument_list|,
name|cr
operator|->
name|cr_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_ro
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write to read-only reg %s\r\n"
argument_list|,
name|name
argument_list|,
name|cr
operator|->
name|cr_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write to bad offset/size %jd/%d\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|VTCFG_R_GUESTCAP
case|:
name|vs
operator|->
name|vs_negotiated_caps
operator|=
name|value
operator|&
name|vc
operator|->
name|vc_hv_caps
expr_stmt|;
if|if
condition|(
name|vc
operator|->
name|vc_apply_features
condition|)
call|(
modifier|*
name|vc
operator|->
name|vc_apply_features
call|)
argument_list|(
name|DEV_SOFTC
argument_list|(
name|vs
argument_list|)
argument_list|,
name|vs
operator|->
name|vs_negotiated_caps
argument_list|)
expr_stmt|;
break|break;
case|case
name|VTCFG_R_PFN
case|:
if|if
condition|(
name|vs
operator|->
name|vs_curq
operator|>=
name|vc
operator|->
name|vc_nvq
condition|)
goto|goto
name|bad_qindex
goto|;
name|vi_vq_init
argument_list|(
name|vs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QSEL
case|:
comment|/* 		 * Note that the guest is allowed to select an 		 * invalid queue; we just need to return a QNUM 		 * of 0 while the bad queue is selected. 		 */
name|vs
operator|->
name|vs_curq
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QNOTIFY
case|:
if|if
condition|(
name|value
operator|>=
name|vc
operator|->
name|vc_nvq
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: queue %d notify out of range\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vq
operator|=
operator|&
name|vs
operator|->
name|vs_queues
index|[
name|value
index|]
expr_stmt|;
if|if
condition|(
name|vq
operator|->
name|vq_notify
condition|)
call|(
modifier|*
name|vq
operator|->
name|vq_notify
call|)
argument_list|(
name|DEV_SOFTC
argument_list|(
name|vs
argument_list|)
argument_list|,
name|vq
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vc
operator|->
name|vc_qnotify
condition|)
call|(
modifier|*
name|vc
operator|->
name|vc_qnotify
call|)
argument_list|(
name|DEV_SOFTC
argument_list|(
name|vs
argument_list|)
argument_list|,
name|vq
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: qnotify queue %d: missing vq/vc notify\r\n"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|VTCFG_R_STATUS
case|:
name|vs
operator|->
name|vs_status
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
call|(
modifier|*
name|vc
operator|->
name|vc_reset
call|)
argument_list|(
name|DEV_SOFTC
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VTCFG_R_CFGVEC
case|:
name|vs
operator|->
name|vs_msix_cfg_idx
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|VTCFG_R_QVEC
case|:
if|if
condition|(
name|vs
operator|->
name|vs_curq
operator|>=
name|vc
operator|->
name|vc_nvq
condition|)
goto|goto
name|bad_qindex
goto|;
name|vq
operator|=
operator|&
name|vs
operator|->
name|vs_queues
index|[
name|vs
operator|->
name|vs_curq
index|]
expr_stmt|;
name|vq
operator|->
name|vq_msix_idx
operator|=
name|value
expr_stmt|;
break|break;
block|}
goto|goto
name|done
goto|;
name|bad_qindex
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write config reg %s: curq %d>= max %d\r\n"
argument_list|,
name|name
argument_list|,
name|cr
operator|->
name|cr_name
argument_list|,
name|vs
operator|->
name|vs_curq
argument_list|,
name|vc
operator|->
name|vc_nvq
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|vs
operator|->
name|vs_mtx
condition|)
name|pthread_mutex_unlock
argument_list|(
name|vs
operator|->
name|vs_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

