begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Advanced Computing Technologies LLC  * Written by: John H. Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|"inout.h"
end_include

begin_include
include|#
directive|include
file|"pci_emul.h"
end_include

begin_include
include|#
directive|include
file|"pci_irq.h"
end_include

begin_include
include|#
directive|include
file|"pci_lpc.h"
end_include

begin_comment
comment|/*  * Implement an 8 pin PCI interrupt router compatible with the router  * present on Intel's ICH10 chip.  */
end_comment

begin_comment
comment|/* Fields in each PIRQ register. */
end_comment

begin_define
define|#
directive|define
name|PIRQ_DIS
value|0x80
end_define

begin_define
define|#
directive|define
name|PIRQ_IRQ
value|0x0f
end_define

begin_comment
comment|/* Only IRQs 3-7, 9-12, and 14-15 are permitted. */
end_comment

begin_define
define|#
directive|define
name|PERMITTED_IRQS
value|0xdef8
end_define

begin_define
define|#
directive|define
name|IRQ_PERMITTED
parameter_list|(
name|irq
parameter_list|)
value|(((1U<< (irq))& PERMITTED_IRQS) != 0)
end_define

begin_comment
comment|/* IRQ count to disable an IRQ. */
end_comment

begin_define
define|#
directive|define
name|IRQ_DISABLED
value|0xff
end_define

begin_struct
specifier|static
struct|struct
name|pirq
block|{
name|uint8_t
name|reg
decl_stmt|;
name|int
name|use_count
decl_stmt|;
name|int
name|active_count
decl_stmt|;
name|pthread_mutex_t
name|lock
decl_stmt|;
block|}
name|pirqs
index|[
literal|8
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_char
name|irq_counts
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pirq_cold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Returns true if this pin is enabled with a valid IRQ.  Setting the  * register to a reserved IRQ causes interrupts to not be asserted as  * if the pin was disabled.  */
end_comment

begin_function
specifier|static
name|bool
name|pirq_valid_irq
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|&
name|PIRQ_DIS
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|IRQ_PERMITTED
argument_list|(
name|reg
operator|&
name|PIRQ_IRQ
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|pirq_read
parameter_list|(
name|int
name|pin
parameter_list|)
block|{
name|assert
argument_list|(
name|pin
operator|>
literal|0
operator|&&
name|pin
operator|<=
name|nitems
argument_list|(
name|pirqs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pirqs
index|[
name|pin
operator|-
literal|1
index|]
operator|.
name|reg
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pirq_write
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|pin
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|struct
name|pirq
modifier|*
name|pirq
decl_stmt|;
name|assert
argument_list|(
name|pin
operator|>
literal|0
operator|&&
name|pin
operator|<=
name|nitems
argument_list|(
name|pirqs
argument_list|)
argument_list|)
expr_stmt|;
name|pirq
operator|=
operator|&
name|pirqs
index|[
name|pin
operator|-
literal|1
index|]
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pirq
operator|->
name|reg
operator|!=
operator|(
name|val
operator|&
operator|(
name|PIRQ_DIS
operator||
name|PIRQ_IRQ
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pirq
operator|->
name|active_count
operator|!=
literal|0
operator|&&
name|pirq_valid_irq
argument_list|(
name|pirq
operator|->
name|reg
argument_list|)
condition|)
name|vm_isa_deassert_irq
argument_list|(
name|ctx
argument_list|,
name|pirq
operator|->
name|reg
operator|&
name|PIRQ_IRQ
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pirq
operator|->
name|reg
operator|=
name|val
operator|&
operator|(
name|PIRQ_DIS
operator||
name|PIRQ_IRQ
operator|)
expr_stmt|;
if|if
condition|(
name|pirq
operator|->
name|active_count
operator|!=
literal|0
operator|&&
name|pirq_valid_irq
argument_list|(
name|pirq
operator|->
name|reg
argument_list|)
condition|)
name|vm_isa_assert_irq
argument_list|(
name|ctx
argument_list|,
name|pirq
operator|->
name|reg
operator|&
name|PIRQ_IRQ
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_irq_reserve
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|assert
argument_list|(
name|irq
operator|<
name|nitems
argument_list|(
name|irq_counts
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pirq_cold
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|irq_counts
index|[
name|irq
index|]
operator|==
literal|0
operator|||
name|irq_counts
index|[
name|irq
index|]
operator|==
name|IRQ_DISABLED
argument_list|)
expr_stmt|;
name|irq_counts
index|[
name|irq
index|]
operator|=
name|IRQ_DISABLED
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_irq_use
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|assert
argument_list|(
name|irq
operator|<
name|nitems
argument_list|(
name|irq_counts
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pirq_cold
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq_counts
index|[
name|irq
index|]
operator|!=
name|IRQ_DISABLED
condition|)
name|irq_counts
index|[
name|irq
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_irq_init
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|pirqs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|pirqs
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|PIRQ_DIS
expr_stmt|;
name|pirqs
index|[
name|i
index|]
operator|.
name|use_count
operator|=
literal|0
expr_stmt|;
name|pirqs
index|[
name|i
index|]
operator|.
name|active_count
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|pirqs
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|irq_counts
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IRQ_PERMITTED
argument_list|(
name|i
argument_list|)
condition|)
name|irq_counts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|irq_counts
index|[
name|i
index|]
operator|=
name|IRQ_DISABLED
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_irq_assert
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|pirq
modifier|*
name|pirq
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|<=
name|nitems
argument_list|(
name|pirqs
argument_list|)
argument_list|)
expr_stmt|;
name|pirq
operator|=
operator|&
name|pirqs
index|[
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|-
literal|1
index|]
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pirq
operator|->
name|active_count
operator|++
expr_stmt|;
if|if
condition|(
name|pirq
operator|->
name|active_count
operator|==
literal|1
operator|&&
name|pirq_valid_irq
argument_list|(
name|pirq
operator|->
name|reg
argument_list|)
condition|)
block|{
name|vm_isa_assert_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pirq
operator|->
name|reg
operator|&
name|PIRQ_IRQ
argument_list|,
name|pi
operator|->
name|pi_lintr
operator|.
name|ioapic_irq
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|vm_ioapic_assert_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_lintr
operator|.
name|ioapic_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_irq_deassert
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|pirq
modifier|*
name|pirq
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|<=
name|nitems
argument_list|(
name|pirqs
argument_list|)
argument_list|)
expr_stmt|;
name|pirq
operator|=
operator|&
name|pirqs
index|[
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|-
literal|1
index|]
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pirq
operator|->
name|active_count
operator|--
expr_stmt|;
if|if
condition|(
name|pirq
operator|->
name|active_count
operator|==
literal|0
operator|&&
name|pirq_valid_irq
argument_list|(
name|pirq
operator|->
name|reg
argument_list|)
condition|)
block|{
name|vm_isa_deassert_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pirq
operator|->
name|reg
operator|&
name|PIRQ_IRQ
argument_list|,
name|pi
operator|->
name|pi_lintr
operator|.
name|ioapic_irq
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pirq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|vm_ioapic_deassert_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_lintr
operator|.
name|ioapic_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pirq_alloc_pin
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|best_count
decl_stmt|,
name|best_irq
decl_stmt|,
name|best_pin
decl_stmt|,
name|irq
decl_stmt|,
name|pin
decl_stmt|;
name|pirq_cold
operator|=
literal|1
expr_stmt|;
comment|/* First, find the least-used PIRQ pin. */
name|best_pin
operator|=
literal|0
expr_stmt|;
name|best_count
operator|=
name|pirqs
index|[
literal|0
index|]
operator|.
name|use_count
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|1
init|;
name|pin
operator|<
name|nitems
argument_list|(
name|pirqs
argument_list|)
condition|;
name|pin
operator|++
control|)
block|{
if|if
condition|(
name|pirqs
index|[
name|pin
index|]
operator|.
name|use_count
operator|<
name|best_count
condition|)
block|{
name|best_pin
operator|=
name|pin
expr_stmt|;
name|best_count
operator|=
name|pirqs
index|[
name|pin
index|]
operator|.
name|use_count
expr_stmt|;
block|}
block|}
name|pirqs
index|[
name|best_pin
index|]
operator|.
name|use_count
operator|++
expr_stmt|;
comment|/* Second, route this pin to an IRQ. */
if|if
condition|(
name|pirqs
index|[
name|best_pin
index|]
operator|.
name|reg
operator|==
name|PIRQ_DIS
condition|)
block|{
name|best_irq
operator|=
operator|-
literal|1
expr_stmt|;
name|best_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nitems
argument_list|(
name|irq_counts
argument_list|)
condition|;
name|irq
operator|++
control|)
block|{
if|if
condition|(
name|irq_counts
index|[
name|irq
index|]
operator|==
name|IRQ_DISABLED
condition|)
continue|continue;
if|if
condition|(
name|best_irq
operator|==
operator|-
literal|1
operator|||
name|irq_counts
index|[
name|irq
index|]
operator|<
name|best_count
condition|)
block|{
name|best_irq
operator|=
name|irq
expr_stmt|;
name|best_count
operator|=
name|irq_counts
index|[
name|irq
index|]
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|best_irq
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|irq_counts
index|[
name|best_irq
index|]
operator|++
expr_stmt|;
name|pirqs
index|[
name|best_pin
index|]
operator|.
name|reg
operator|=
name|best_irq
expr_stmt|;
name|vm_isa_set_irq_trigger
argument_list|(
name|ctx
argument_list|,
name|best_irq
argument_list|,
name|LEVEL_TRIGGER
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|best_pin
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pirq_irq
parameter_list|(
name|int
name|pin
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|255
operator|)
return|;
name|assert
argument_list|(
name|pin
operator|>
literal|0
operator|&&
name|pin
operator|<=
name|nitems
argument_list|(
name|pirqs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pirqs
index|[
name|pin
operator|-
literal|1
index|]
operator|.
name|reg
operator|&
name|PIRQ_IRQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: Generate $PIR table. */
end_comment

begin_function
specifier|static
name|void
name|pirq_dsdt
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|irq_prs
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|int
name|irq
decl_stmt|,
name|pin
decl_stmt|;
name|irq_prs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|nitems
argument_list|(
name|irq_counts
argument_list|)
condition|;
name|irq
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IRQ_PERMITTED
argument_list|(
name|irq
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|irq_prs
operator|==
name|NULL
condition|)
name|asprintf
argument_list|(
operator|&
name|irq_prs
argument_list|,
literal|"%d"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
block|{
name|old
operator|=
name|irq_prs
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|irq_prs
argument_list|,
literal|"%s,%d"
argument_list|,
name|old
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * A helper method to validate a link register's value.  This 	 * duplicates pirq_valid_irq(). 	 */
name|dsdt_line
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Method (PIRV, 1, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  If (And (Arg0, 0x%02X))"
argument_list|,
name|PIRQ_DIS
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (0x00)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  And (Arg0, 0x%02X, Local0)"
argument_list|,
name|PIRQ_IRQ
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  If (LLess (Local0, 0x03))"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (0x00)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  If (LEqual (Local0, 0x08))"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (0x00)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  If (LEqual (Local0, 0x0D))"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (0x00)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Return (0x01)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
name|nitems
argument_list|(
name|pirqs
argument_list|)
condition|;
name|pin
operator|++
control|)
block|{
name|dsdt_line
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Device (LNK%c)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Name (_HID, EisaId (\"PNP0C0F\"))"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Name (_UID, 0x%02X)"
argument_list|,
name|pin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Method (_STA, 0, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    If (PIRV (PIR%c))"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"       Return (0x0B)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Else"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"       Return (0x09)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Name (_PRS, ResourceTemplate ()"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    IRQ (Level, ActiveLow, Shared, )"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      {%s}"
argument_list|,
name|irq_prs
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  })"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Name (CB%02X, ResourceTemplate ()"
argument_list|,
name|pin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    IRQ (Level, ActiveLow, Shared, )"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      {}"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  })"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  CreateWordField (CB%02X, 0x01, CIR%c)"
argument_list|,
name|pin
operator|+
literal|1
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Method (_CRS, 0, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    And (PIR%c, 0x%02X, Local0)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|,
name|PIRQ_DIS
operator||
name|PIRQ_IRQ
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    If (PIRV (Local0))"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      ShiftLeft (0x01, Local0, CIR%c)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Else"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      Store (0x00, CIR%c)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (CB%02X)"
argument_list|,
name|pin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Method (_DIS, 0, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Store (0x80, PIR%c)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Method (_SRS, 1, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    CreateWordField (Arg0, 0x01, SIR%c)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    FindSetRightBit (SIR%c, Local0)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Store (Decrement (Local0), PIR%c)"
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|irq_prs
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|LPC_DSDT
argument_list|(
name|pirq_dsdt
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

