begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Neel Natu<neel@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/_iovec.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<x86/psl.h>
end_include

begin_include
include|#
directive|include
file|<x86/segments.h>
end_include

begin_include
include|#
directive|include
file|<x86/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm_instruction_emul.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_include
include|#
directive|include
file|"bhyverun.h"
end_include

begin_comment
comment|/*  * Using 'struct i386tss' is tempting but causes myriad sign extension  * issues because all of its fields are defined as signed integers.  */
end_comment

begin_struct
struct|struct
name|tss32
block|{
name|uint16_t
name|tss_link
decl_stmt|;
name|uint16_t
name|rsvd1
decl_stmt|;
name|uint32_t
name|tss_esp0
decl_stmt|;
name|uint16_t
name|tss_ss0
decl_stmt|;
name|uint16_t
name|rsvd2
decl_stmt|;
name|uint32_t
name|tss_esp1
decl_stmt|;
name|uint16_t
name|tss_ss1
decl_stmt|;
name|uint16_t
name|rsvd3
decl_stmt|;
name|uint32_t
name|tss_esp2
decl_stmt|;
name|uint16_t
name|tss_ss2
decl_stmt|;
name|uint16_t
name|rsvd4
decl_stmt|;
name|uint32_t
name|tss_cr3
decl_stmt|;
name|uint32_t
name|tss_eip
decl_stmt|;
name|uint32_t
name|tss_eflags
decl_stmt|;
name|uint32_t
name|tss_eax
decl_stmt|;
name|uint32_t
name|tss_ecx
decl_stmt|;
name|uint32_t
name|tss_edx
decl_stmt|;
name|uint32_t
name|tss_ebx
decl_stmt|;
name|uint32_t
name|tss_esp
decl_stmt|;
name|uint32_t
name|tss_ebp
decl_stmt|;
name|uint32_t
name|tss_esi
decl_stmt|;
name|uint32_t
name|tss_edi
decl_stmt|;
name|uint16_t
name|tss_es
decl_stmt|;
name|uint16_t
name|rsvd5
decl_stmt|;
name|uint16_t
name|tss_cs
decl_stmt|;
name|uint16_t
name|rsvd6
decl_stmt|;
name|uint16_t
name|tss_ss
decl_stmt|;
name|uint16_t
name|rsvd7
decl_stmt|;
name|uint16_t
name|tss_ds
decl_stmt|;
name|uint16_t
name|rsvd8
decl_stmt|;
name|uint16_t
name|tss_fs
decl_stmt|;
name|uint16_t
name|rsvd9
decl_stmt|;
name|uint16_t
name|tss_gs
decl_stmt|;
name|uint16_t
name|rsvd10
decl_stmt|;
name|uint16_t
name|tss_ldt
decl_stmt|;
name|uint16_t
name|rsvd11
decl_stmt|;
name|uint16_t
name|tss_trap
decl_stmt|;
name|uint16_t
name|tss_iomap
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tss32
argument_list|)
operator|==
literal|104
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SEL_START
parameter_list|(
name|sel
parameter_list|)
value|(((sel)& ~0x7))
end_define

begin_define
define|#
directive|define
name|SEL_LIMIT
parameter_list|(
name|sel
parameter_list|)
value|(((sel) | 0x7))
end_define

begin_define
define|#
directive|define
name|TSS_BUSY
parameter_list|(
name|type
parameter_list|)
value|(((type)& 0x2) != 0)
end_define

begin_function
specifier|static
name|uint64_t
name|GETREG
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SETREG
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vm_set_register
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|seg_desc
name|usd_to_seg_desc
parameter_list|(
name|struct
name|user_segment_descriptor
modifier|*
name|usd
parameter_list|)
block|{
name|struct
name|seg_desc
name|seg_desc
decl_stmt|;
name|seg_desc
operator|.
name|base
operator|=
operator|(
name|u_int
operator|)
name|USD_GETBASE
argument_list|(
name|usd
argument_list|)
expr_stmt|;
if|if
condition|(
name|usd
operator|->
name|sd_gran
condition|)
name|seg_desc
operator|.
name|limit
operator|=
call|(
name|u_int
call|)
argument_list|(
name|USD_GETLIMIT
argument_list|(
name|usd
argument_list|)
operator|<<
literal|12
argument_list|)
operator||
literal|0xfff
expr_stmt|;
else|else
name|seg_desc
operator|.
name|limit
operator|=
operator|(
name|u_int
operator|)
name|USD_GETLIMIT
argument_list|(
name|usd
argument_list|)
expr_stmt|;
name|seg_desc
operator|.
name|access
operator|=
name|usd
operator|->
name|sd_type
operator||
name|usd
operator|->
name|sd_dpl
operator|<<
literal|5
operator||
name|usd
operator|->
name|sd_p
operator|<<
literal|7
expr_stmt|;
name|seg_desc
operator|.
name|access
operator||=
name|usd
operator|->
name|sd_xx
operator|<<
literal|12
expr_stmt|;
name|seg_desc
operator|.
name|access
operator||=
name|usd
operator|->
name|sd_def32
operator|<<
literal|14
expr_stmt|;
name|seg_desc
operator|.
name|access
operator||=
name|usd
operator|->
name|sd_gran
operator|<<
literal|15
expr_stmt|;
return|return
operator|(
name|seg_desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inject an exception with an error code that is a segment selector.  * The format of the error code is described in section 6.13, "Error Code",  * Intel SDM volume 3.  *  * Bit 0 (EXT) denotes whether the exception occurred during delivery  * of an external event like an interrupt.  *  * Bit 1 (IDT) indicates whether the selector points to a gate descriptor  * in the IDT.  *  * Bit 2(GDT/LDT) has the usual interpretation of Table Indicator (TI).  */
end_comment

begin_function
specifier|static
name|void
name|sel_exception
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|vector
parameter_list|,
name|uint16_t
name|sel
parameter_list|,
name|int
name|ext
parameter_list|)
block|{
comment|/* 	 * Bit 2 from the selector is retained as-is in the error code. 	 * 	 * Bit 1 can be safely cleared because none of the selectors 	 * encountered during task switch emulation refer to a task 	 * gate in the IDT. 	 * 	 * Bit 0 is set depending on the value of 'ext'. 	 */
name|sel
operator|&=
operator|~
literal|0x3
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|sel
operator||=
literal|0x1
expr_stmt|;
name|vm_inject_fault
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|vector
argument_list|,
literal|1
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 0 if the selector 'sel' in within the limits of the GDT/LDT  * and non-zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|desc_table_limit_check
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint16_t
name|sel
parameter_list|)
block|{
name|uint64_t
name|base
decl_stmt|;
name|uint32_t
name|limit
decl_stmt|,
name|access
decl_stmt|;
name|int
name|error
decl_stmt|,
name|reg
decl_stmt|;
name|reg
operator|=
name|ISLDT
argument_list|(
name|sel
argument_list|)
condition|?
name|VM_REG_GUEST_LDTR
else|:
name|VM_REG_GUEST_GDTR
expr_stmt|;
name|error
operator|=
name|vm_get_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|reg
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|access
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|VM_REG_GUEST_LDTR
condition|)
block|{
if|if
condition|(
name|SEG_DESC_UNUSABLE
argument_list|(
name|access
argument_list|)
operator|||
operator|!
name|SEG_DESC_PRESENT
argument_list|(
name|access
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|limit
operator|<
name|SEL_LIMIT
argument_list|(
name|sel
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read/write the segment descriptor 'desc' into the GDT/LDT slot referenced  * by the selector 'sel'.  *  * Returns 0 on success.  * Returns 1 if an exception was injected into the guest.  * Returns -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|desc_table_rw
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|uint16_t
name|sel
parameter_list|,
name|struct
name|user_segment_descriptor
modifier|*
name|desc
parameter_list|,
name|bool
name|doread
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|base
decl_stmt|;
name|uint32_t
name|limit
decl_stmt|,
name|access
decl_stmt|;
name|int
name|error
decl_stmt|,
name|reg
decl_stmt|;
name|reg
operator|=
name|ISLDT
argument_list|(
name|sel
argument_list|)
condition|?
name|VM_REG_GUEST_LDTR
else|:
name|VM_REG_GUEST_GDTR
expr_stmt|;
name|error
operator|=
name|vm_get_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|reg
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|access
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|limit
operator|>=
name|SEL_LIMIT
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|paging
argument_list|,
name|base
operator|+
name|SEL_START
argument_list|(
name|sel
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|,
name|doread
condition|?
name|PROT_READ
else|:
name|PROT_WRITE
argument_list|,
name|iov
argument_list|,
name|nitems
argument_list|(
name|iov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|doread
condition|)
name|vm_copyin
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|iov
argument_list|,
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vm_copyout
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|desc
argument_list|,
name|iov
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|desc_table_read
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|uint16_t
name|sel
parameter_list|,
name|struct
name|user_segment_descriptor
modifier|*
name|desc
parameter_list|)
block|{
return|return
operator|(
name|desc_table_rw
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|paging
argument_list|,
name|sel
argument_list|,
name|desc
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|desc_table_write
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|uint16_t
name|sel
parameter_list|,
name|struct
name|user_segment_descriptor
modifier|*
name|desc
parameter_list|)
block|{
return|return
operator|(
name|desc_table_rw
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|paging
argument_list|,
name|sel
argument_list|,
name|desc
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the TSS descriptor referenced by 'sel' into 'desc'.  *  * Returns 0 on success.  * Returns 1 if an exception was injected into the guest.  * Returns -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|read_tss_descriptor
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_task_switch
modifier|*
name|ts
parameter_list|,
name|uint16_t
name|sel
parameter_list|,
name|struct
name|user_segment_descriptor
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|vm_guest_paging
name|sup_paging
decl_stmt|;
name|int
name|error
decl_stmt|;
name|assert
argument_list|(
operator|!
name|ISLDT
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|IDXSEL
argument_list|(
name|sel
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Fetch the new TSS descriptor */
if|if
condition|(
name|desc_table_limit_check
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|sel
argument_list|)
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|reason
operator|==
name|TSR_IRET
condition|)
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
else|else
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_GP
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sup_paging
operator|=
name|ts
operator|->
name|paging
expr_stmt|;
name|sup_paging
operator|.
name|cpl
operator|=
literal|0
expr_stmt|;
comment|/* implicit supervisor mode */
name|error
operator|=
name|desc_table_read
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|sup_paging
argument_list|,
name|sel
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|code_desc
parameter_list|(
name|int
name|sd_type
parameter_list|)
block|{
comment|/* code descriptor */
return|return
operator|(
operator|(
name|sd_type
operator|&
literal|0x18
operator|)
operator|==
literal|0x18
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|stack_desc
parameter_list|(
name|int
name|sd_type
parameter_list|)
block|{
comment|/* writable data descriptor */
return|return
operator|(
operator|(
name|sd_type
operator|&
literal|0x1A
operator|)
operator|==
literal|0x12
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|data_desc
parameter_list|(
name|int
name|sd_type
parameter_list|)
block|{
comment|/* data descriptor or a readable code descriptor */
return|return
operator|(
operator|(
name|sd_type
operator|&
literal|0x18
operator|)
operator|==
literal|0x10
operator|||
operator|(
name|sd_type
operator|&
literal|0x1A
operator|)
operator|==
literal|0x1A
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ldt_desc
parameter_list|(
name|int
name|sd_type
parameter_list|)
block|{
return|return
operator|(
name|sd_type
operator|==
name|SDT_SYSLDT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate the descriptor 'seg_desc' associated with 'segment'.  *  * Returns 0 on success.  * Returns 1 if an exception was injected into the guest.  * Returns -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|validate_seg_desc
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_task_switch
modifier|*
name|ts
parameter_list|,
name|int
name|segment
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|seg_desc
parameter_list|)
block|{
name|struct
name|vm_guest_paging
name|sup_paging
decl_stmt|;
name|struct
name|user_segment_descriptor
name|usd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|idtvec
decl_stmt|;
name|int
name|cpl
decl_stmt|,
name|dpl
decl_stmt|,
name|rpl
decl_stmt|;
name|uint16_t
name|sel
decl_stmt|,
name|cs
decl_stmt|;
name|bool
name|ldtseg
decl_stmt|,
name|codeseg
decl_stmt|,
name|stackseg
decl_stmt|,
name|dataseg
decl_stmt|,
name|conforming
decl_stmt|;
name|ldtseg
operator|=
name|codeseg
operator|=
name|stackseg
operator|=
name|dataseg
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|segment
condition|)
block|{
case|case
name|VM_REG_GUEST_LDTR
case|:
name|ldtseg
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|VM_REG_GUEST_CS
case|:
name|codeseg
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|VM_REG_GUEST_SS
case|:
name|stackseg
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|VM_REG_GUEST_DS
case|:
case|case
name|VM_REG_GUEST_ES
case|:
case|case
name|VM_REG_GUEST_FS
case|:
case|case
name|VM_REG_GUEST_GS
case|:
name|dataseg
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get the segment selector */
name|sel
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|segment
argument_list|)
expr_stmt|;
comment|/* LDT selector must point into the GDT */
if|if
condition|(
name|ldtseg
operator|&&
name|ISLDT
argument_list|(
name|sel
argument_list|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Descriptor table limit check */
if|if
condition|(
name|desc_table_limit_check
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|sel
argument_list|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* NULL selector */
if|if
condition|(
name|IDXSEL
argument_list|(
name|sel
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Code and stack segment selectors cannot be NULL */
if|if
condition|(
name|codeseg
operator|||
name|stackseg
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|seg_desc
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|seg_desc
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|seg_desc
operator|->
name|access
operator|=
literal|0x10000
expr_stmt|;
comment|/* unusable */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Read the descriptor from the GDT/LDT */
name|sup_paging
operator|=
name|ts
operator|->
name|paging
expr_stmt|;
name|sup_paging
operator|.
name|cpl
operator|=
literal|0
expr_stmt|;
comment|/* implicit supervisor mode */
name|error
operator|=
name|desc_table_read
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|sup_paging
argument_list|,
name|sel
argument_list|,
operator|&
name|usd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Verify that the descriptor type is compatible with the segment */
if|if
condition|(
operator|(
name|ldtseg
operator|&&
operator|!
name|ldt_desc
argument_list|(
name|usd
operator|.
name|sd_type
argument_list|)
operator|)
operator|||
operator|(
name|codeseg
operator|&&
operator|!
name|code_desc
argument_list|(
name|usd
operator|.
name|sd_type
argument_list|)
operator|)
operator|||
operator|(
name|dataseg
operator|&&
operator|!
name|data_desc
argument_list|(
name|usd
operator|.
name|sd_type
argument_list|)
operator|)
operator|||
operator|(
name|stackseg
operator|&&
operator|!
name|stack_desc
argument_list|(
name|usd
operator|.
name|sd_type
argument_list|)
operator|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Segment must be marked present */
if|if
condition|(
operator|!
name|usd
operator|.
name|sd_p
condition|)
block|{
if|if
condition|(
name|ldtseg
condition|)
name|idtvec
operator|=
name|IDT_TS
expr_stmt|;
elseif|else
if|if
condition|(
name|stackseg
condition|)
name|idtvec
operator|=
name|IDT_SS
expr_stmt|;
else|else
name|idtvec
operator|=
name|IDT_NP
expr_stmt|;
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|idtvec
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cs
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CS
argument_list|)
expr_stmt|;
name|cpl
operator|=
name|cs
operator|&
name|SEL_RPL_MASK
expr_stmt|;
name|rpl
operator|=
name|sel
operator|&
name|SEL_RPL_MASK
expr_stmt|;
name|dpl
operator|=
name|usd
operator|.
name|sd_dpl
expr_stmt|;
if|if
condition|(
name|stackseg
operator|&&
operator|(
name|rpl
operator|!=
name|cpl
operator|||
name|dpl
operator|!=
name|cpl
operator|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|codeseg
condition|)
block|{
name|conforming
operator|=
operator|(
name|usd
operator|.
name|sd_type
operator|&
literal|0x4
operator|)
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|conforming
operator|&&
operator|(
name|cpl
operator|<
name|dpl
operator|)
operator|)
operator|||
operator|(
operator|!
name|conforming
operator|&&
operator|(
name|cpl
operator|!=
name|dpl
operator|)
operator|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dataseg
condition|)
block|{
comment|/* 		 * A data segment is always non-conforming except when it's 		 * descriptor is a readable, conforming code segment. 		 */
if|if
condition|(
name|code_desc
argument_list|(
name|usd
operator|.
name|sd_type
argument_list|)
operator|&&
operator|(
name|usd
operator|.
name|sd_type
operator|&
literal|0x4
operator|)
operator|!=
literal|0
condition|)
name|conforming
operator|=
name|true
expr_stmt|;
else|else
name|conforming
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|conforming
operator|&&
operator|(
name|rpl
operator|>
name|dpl
operator|||
name|cpl
operator|>
name|dpl
operator|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|sel
argument_list|,
name|ts
operator|->
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|seg_desc
operator|=
name|usd_to_seg_desc
argument_list|(
operator|&
name|usd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tss32_save
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_task_switch
modifier|*
name|task_switch
parameter_list|,
name|uint32_t
name|eip
parameter_list|,
name|struct
name|tss32
modifier|*
name|tss
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|)
block|{
comment|/* General purpose registers */
name|tss
operator|->
name|tss_eax
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RAX
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_ecx
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RCX
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_edx
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RDX
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_ebx
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RBX
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_esp
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RSP
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_ebp
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RBP
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_esi
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RSI
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_edi
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|)
expr_stmt|;
comment|/* Segment selectors */
name|tss
operator|->
name|tss_es
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_ES
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_cs
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CS
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_ss
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_SS
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_ds
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_DS
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_fs
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_FS
argument_list|)
expr_stmt|;
name|tss
operator|->
name|tss_gs
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_GS
argument_list|)
expr_stmt|;
comment|/* eflags and eip */
name|tss
operator|->
name|tss_eflags
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|task_switch
operator|->
name|reason
operator|==
name|TSR_IRET
condition|)
name|tss
operator|->
name|tss_eflags
operator|&=
operator|~
name|PSL_NT
expr_stmt|;
name|tss
operator|->
name|tss_eip
operator|=
name|eip
expr_stmt|;
comment|/* Copy updated old TSS into guest memory */
name|vm_copyout
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|tss
argument_list|,
name|iov
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tss32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_seg_desc
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|reg
parameter_list|,
name|struct
name|seg_desc
modifier|*
name|sd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vm_set_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|reg
argument_list|,
name|sd
operator|->
name|base
argument_list|,
name|sd
operator|->
name|limit
argument_list|,
name|sd
operator|->
name|access
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the vcpu registers to reflect the state of the new task.  *  * Returns 0 on success.  * Returns 1 if an exception was injected into the guest.  * Returns -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|tss32_restore
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_task_switch
modifier|*
name|ts
parameter_list|,
name|uint16_t
name|ot_sel
parameter_list|,
name|struct
name|tss32
modifier|*
name|tss
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|)
block|{
name|struct
name|seg_desc
name|seg_desc
decl_stmt|,
name|seg_desc2
decl_stmt|;
name|uint64_t
modifier|*
name|pdpte
decl_stmt|,
name|maxphyaddr
decl_stmt|,
name|reserved
decl_stmt|;
name|uint32_t
name|eflags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|nested
decl_stmt|;
name|nested
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|reason
operator|!=
name|TSR_IRET
operator|&&
name|ts
operator|->
name|reason
operator|!=
name|TSR_JMP
condition|)
block|{
name|tss
operator|->
name|tss_link
operator|=
name|ot_sel
expr_stmt|;
name|nested
operator|=
name|true
expr_stmt|;
block|}
name|eflags
operator|=
name|tss
operator|->
name|tss_eflags
expr_stmt|;
if|if
condition|(
name|nested
condition|)
name|eflags
operator||=
name|PSL_NT
expr_stmt|;
comment|/* LDTR */
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_LDTR
argument_list|,
name|tss
operator|->
name|tss_ldt
argument_list|)
expr_stmt|;
comment|/* PBDR */
if|if
condition|(
name|ts
operator|->
name|paging
operator|.
name|paging_mode
operator|!=
name|PAGING_MODE_FLAT
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|paging
operator|.
name|paging_mode
operator|==
name|PAGING_MODE_PAE
condition|)
block|{
comment|/* 			 * XXX Assuming 36-bit MAXPHYADDR. 			 */
name|maxphyaddr
operator|=
operator|(
literal|1UL
operator|<<
literal|36
operator|)
operator|-
literal|1
expr_stmt|;
name|pdpte
operator|=
name|paddr_guest2host
argument_list|(
name|ctx
argument_list|,
name|tss
operator|->
name|tss_cr3
operator|&
operator|~
literal|0x1f
argument_list|,
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check reserved bits if the PDPTE is valid */
if|if
condition|(
operator|!
operator|(
name|pdpte
index|[
name|i
index|]
operator|&
literal|0x1
operator|)
condition|)
continue|continue;
comment|/* 				 * Bits 2:1, 8:5 and bits above the processor's 				 * maximum physical address are reserved. 				 */
name|reserved
operator|=
operator|~
name|maxphyaddr
operator||
literal|0x1E6
expr_stmt|;
if|if
condition|(
name|pdpte
index|[
name|i
index|]
operator|&
name|reserved
condition|)
block|{
name|vm_inject_gp
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_PDPTE0
argument_list|,
name|pdpte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_PDPTE1
argument_list|,
name|pdpte
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_PDPTE2
argument_list|,
name|pdpte
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_PDPTE3
argument_list|,
name|pdpte
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CR3
argument_list|,
name|tss
operator|->
name|tss_cr3
argument_list|)
expr_stmt|;
name|ts
operator|->
name|paging
operator|.
name|cr3
operator|=
name|tss
operator|->
name|tss_cr3
expr_stmt|;
block|}
comment|/* eflags and eip */
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RIP
argument_list|,
name|tss
operator|->
name|tss_eip
argument_list|)
expr_stmt|;
comment|/* General purpose registers */
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RAX
argument_list|,
name|tss
operator|->
name|tss_eax
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RCX
argument_list|,
name|tss
operator|->
name|tss_ecx
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RDX
argument_list|,
name|tss
operator|->
name|tss_edx
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RBX
argument_list|,
name|tss
operator|->
name|tss_ebx
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RSP
argument_list|,
name|tss
operator|->
name|tss_esp
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RBP
argument_list|,
name|tss
operator|->
name|tss_ebp
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RSI
argument_list|,
name|tss
operator|->
name|tss_esi
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RDI
argument_list|,
name|tss
operator|->
name|tss_edi
argument_list|)
expr_stmt|;
comment|/* Segment selectors */
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_ES
argument_list|,
name|tss
operator|->
name|tss_es
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CS
argument_list|,
name|tss
operator|->
name|tss_cs
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
name|tss
operator|->
name|tss_ss
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_DS
argument_list|,
name|tss
operator|->
name|tss_ds
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_FS
argument_list|,
name|tss
operator|->
name|tss_fs
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_GS
argument_list|,
name|tss
operator|->
name|tss_gs
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a nested task then write out the new TSS to update 	 * the previous link field. 	 */
if|if
condition|(
name|nested
condition|)
name|vm_copyout
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|tss
argument_list|,
name|iov
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tss
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Validate segment descriptors */
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_LDTR
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_LDTR
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
comment|/* 	 * Section "Checks on Guest Segment Registers", Intel SDM, Vol 3. 	 * 	 * The SS and CS attribute checks on VM-entry are inter-dependent so 	 * we need to make sure that both segments are valid before updating 	 * either of them. This ensures that the VMCS state can pass the 	 * VM-entry checks so the guest can handle any exception injected 	 * during task switch emulation. 	 */
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_CS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
operator|&
name|seg_desc2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
operator|&
name|seg_desc2
argument_list|)
expr_stmt|;
name|ts
operator|->
name|paging
operator|.
name|cpl
operator|=
name|tss
operator|->
name|tss_cs
operator|&
name|SEL_RPL_MASK
expr_stmt|;
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_DS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_DS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_ES
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_ES
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_FS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_FS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|validate_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ts
argument_list|,
name|VM_REG_GUEST_GS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_GS
argument_list|,
operator|&
name|seg_desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Push an error code on the stack of the new task. This is needed if the  * task switch was triggered by a hardware exception that causes an error  * code to be saved (e.g. #PF).  *  * Returns 0 on success.  * Returns 1 if an exception was injected into the guest.  * Returns -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|push_errcode
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|vm_guest_paging
modifier|*
name|paging
parameter_list|,
name|int
name|task_type
parameter_list|,
name|uint32_t
name|errcode
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|seg_desc
name|seg_desc
decl_stmt|;
name|int
name|stacksize
decl_stmt|,
name|bytes
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
name|gla
decl_stmt|,
name|cr0
decl_stmt|,
name|rflags
decl_stmt|;
name|uint32_t
name|esp
decl_stmt|;
name|uint16_t
name|stacksel
decl_stmt|;
name|cr0
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CR0
argument_list|)
expr_stmt|;
name|rflags
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RFLAGS
argument_list|)
expr_stmt|;
name|stacksel
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_SS
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
operator|&
name|seg_desc
operator|.
name|base
argument_list|,
operator|&
name|seg_desc
operator|.
name|limit
argument_list|,
operator|&
name|seg_desc
operator|.
name|access
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Section "Error Code" in the Intel SDM vol 3: the error code is 	 * pushed on the stack as a doubleword or word (depending on the 	 * default interrupt, trap or task gate size). 	 */
if|if
condition|(
name|task_type
operator|==
name|SDT_SYS386BSY
operator|||
name|task_type
operator|==
name|SDT_SYS386TSS
condition|)
name|bytes
operator|=
literal|4
expr_stmt|;
else|else
name|bytes
operator|=
literal|2
expr_stmt|;
comment|/* 	 * PUSH instruction from Intel SDM vol 2: the 'B' flag in the 	 * stack-segment descriptor determines the size of the stack 	 * pointer outside of 64-bit mode. 	 */
if|if
condition|(
name|SEG_DESC_DEF32
argument_list|(
name|seg_desc
operator|.
name|access
argument_list|)
condition|)
name|stacksize
operator|=
literal|4
expr_stmt|;
else|else
name|stacksize
operator|=
literal|2
expr_stmt|;
name|esp
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RSP
argument_list|)
expr_stmt|;
name|esp
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|vie_calculate_gla
argument_list|(
name|paging
operator|->
name|cpu_mode
argument_list|,
name|VM_REG_GUEST_SS
argument_list|,
operator|&
name|seg_desc
argument_list|,
name|esp
argument_list|,
name|bytes
argument_list|,
name|stacksize
argument_list|,
name|PROT_WRITE
argument_list|,
operator|&
name|gla
argument_list|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_SS
argument_list|,
name|stacksel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vie_alignment_check
argument_list|(
name|paging
operator|->
name|cpl
argument_list|,
name|bytes
argument_list|,
name|cr0
argument_list|,
name|rflags
argument_list|,
name|gla
argument_list|)
condition|)
block|{
name|vm_inject_ac
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|paging
argument_list|,
name|gla
argument_list|,
name|bytes
argument_list|,
name|PROT_WRITE
argument_list|,
name|iov
argument_list|,
name|nitems
argument_list|(
name|iov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vm_copyout
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|errcode
argument_list|,
name|iov
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_RSP
argument_list|,
name|esp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate return value from helper functions and potentially return to  * the VM run loop.  *  0: success  * +1: an exception was injected into the guest vcpu  * -1: unrecoverable/programming error  */
end_comment

begin_define
define|#
directive|define
name|CHKERR
parameter_list|(
name|x
parameter_list|)
define|\
value|do {								\ 		assert(((x) == 0) || ((x) == 1) || ((x) == -1));	\ 		if ((x) == -1)						\ 			return (VMEXIT_ABORT);				\ 		else if ((x) == 1)					\ 			return (VMEXIT_CONTINUE);			\ 	} while (0)
end_define

begin_function
name|int
name|vmexit_task_switch
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|vm_exit
modifier|*
name|vmexit
parameter_list|,
name|int
modifier|*
name|pvcpu
parameter_list|)
block|{
name|struct
name|seg_desc
name|nt
decl_stmt|;
name|struct
name|tss32
name|oldtss
decl_stmt|,
name|newtss
decl_stmt|;
name|struct
name|vm_task_switch
modifier|*
name|task_switch
decl_stmt|;
name|struct
name|vm_guest_paging
modifier|*
name|paging
decl_stmt|,
name|sup_paging
decl_stmt|;
name|struct
name|user_segment_descriptor
name|nt_desc
decl_stmt|,
name|ot_desc
decl_stmt|;
name|struct
name|iovec
name|nt_iov
index|[
literal|2
index|]
decl_stmt|,
name|ot_iov
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|cr0
decl_stmt|,
name|ot_base
decl_stmt|;
name|uint32_t
name|eip
decl_stmt|,
name|ot_lim
decl_stmt|,
name|access
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ext
decl_stmt|,
name|minlimit
decl_stmt|,
name|nt_type
decl_stmt|,
name|ot_type
decl_stmt|,
name|vcpu
decl_stmt|;
name|enum
name|task_switch_reason
name|reason
decl_stmt|;
name|uint16_t
name|nt_sel
decl_stmt|,
name|ot_sel
decl_stmt|;
name|task_switch
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|task_switch
expr_stmt|;
name|nt_sel
operator|=
name|task_switch
operator|->
name|tsssel
expr_stmt|;
name|ext
operator|=
name|vmexit
operator|->
name|u
operator|.
name|task_switch
operator|.
name|ext
expr_stmt|;
name|reason
operator|=
name|vmexit
operator|->
name|u
operator|.
name|task_switch
operator|.
name|reason
expr_stmt|;
name|paging
operator|=
operator|&
name|vmexit
operator|->
name|u
operator|.
name|task_switch
operator|.
name|paging
expr_stmt|;
name|vcpu
operator|=
operator|*
name|pvcpu
expr_stmt|;
name|assert
argument_list|(
name|paging
operator|->
name|cpu_mode
operator|==
name|CPU_MODE_PROTECTED
argument_list|)
expr_stmt|;
comment|/* 	 * Section 4.6, "Access Rights" in Intel SDM Vol 3. 	 * The following page table accesses are implicitly supervisor mode: 	 * - accesses to GDT or LDT to load segment descriptors 	 * - accesses to the task state segment during task switch 	 */
name|sup_paging
operator|=
operator|*
name|paging
expr_stmt|;
name|sup_paging
operator|.
name|cpl
operator|=
literal|0
expr_stmt|;
comment|/* implicit supervisor mode */
comment|/* Fetch the new TSS descriptor */
name|error
operator|=
name|read_tss_descriptor
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|task_switch
argument_list|,
name|nt_sel
argument_list|,
operator|&
name|nt_desc
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|nt
operator|=
name|usd_to_seg_desc
argument_list|(
operator|&
name|nt_desc
argument_list|)
expr_stmt|;
comment|/* Verify the type of the new TSS */
name|nt_type
operator|=
name|SEG_DESC_TYPE
argument_list|(
name|nt
operator|.
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt_type
operator|!=
name|SDT_SYS386BSY
operator|&&
name|nt_type
operator|!=
name|SDT_SYS386TSS
operator|&&
name|nt_type
operator|!=
name|SDT_SYS286BSY
operator|&&
name|nt_type
operator|!=
name|SDT_SYS286TSS
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|nt_sel
argument_list|,
name|ext
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* TSS descriptor must have present bit set */
if|if
condition|(
operator|!
name|SEG_DESC_PRESENT
argument_list|(
name|nt
operator|.
name|access
argument_list|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_NP
argument_list|,
name|nt_sel
argument_list|,
name|ext
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * TSS must have a minimum length of 104 bytes for a 32-bit TSS and 	 * 44 bytes for a 16-bit TSS. 	 */
if|if
condition|(
name|nt_type
operator|==
name|SDT_SYS386BSY
operator|||
name|nt_type
operator|==
name|SDT_SYS386TSS
condition|)
name|minlimit
operator|=
literal|104
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nt_type
operator|==
name|SDT_SYS286BSY
operator|||
name|nt_type
operator|==
name|SDT_SYS286TSS
condition|)
name|minlimit
operator|=
literal|44
operator|-
literal|1
expr_stmt|;
else|else
name|minlimit
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|minlimit
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|.
name|limit
operator|<
name|minlimit
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|nt_sel
argument_list|,
name|ext
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* TSS must be busy if task switch is due to IRET */
if|if
condition|(
name|reason
operator|==
name|TSR_IRET
operator|&&
operator|!
name|TSS_BUSY
argument_list|(
name|nt_type
argument_list|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|nt_sel
argument_list|,
name|ext
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * TSS must be available (not busy) if task switch reason is 	 * CALL, JMP, exception or interrupt. 	 */
if|if
condition|(
name|reason
operator|!=
name|TSR_IRET
operator|&&
name|TSS_BUSY
argument_list|(
name|nt_type
argument_list|)
condition|)
block|{
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_GP
argument_list|,
name|nt_sel
argument_list|,
name|ext
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Fetch the new TSS */
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|sup_paging
argument_list|,
name|nt
operator|.
name|base
argument_list|,
name|minlimit
operator|+
literal|1
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|nt_iov
argument_list|,
name|nitems
argument_list|(
name|nt_iov
argument_list|)
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|vm_copyin
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|nt_iov
argument_list|,
operator|&
name|newtss
argument_list|,
name|minlimit
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Get the old TSS selector from the guest's task register */
name|ot_sel
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_TR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISLDT
argument_list|(
name|ot_sel
argument_list|)
operator|||
name|IDXSEL
argument_list|(
name|ot_sel
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This might happen if a task switch was attempted without 		 * ever loading the task register with LTR. In this case the 		 * TR would contain the values from power-on: 		 * (sel = 0, base = 0, limit = 0xffff). 		 */
name|sel_exception
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|IDT_TS
argument_list|,
name|ot_sel
argument_list|,
name|task_switch
operator|->
name|ext
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Get the old TSS base and limit from the guest's task register */
name|error
operator|=
name|vm_get_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_TR
argument_list|,
operator|&
name|ot_base
argument_list|,
operator|&
name|ot_lim
argument_list|,
operator|&
name|access
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|SEG_DESC_UNUSABLE
argument_list|(
name|access
argument_list|)
operator|&&
name|SEG_DESC_PRESENT
argument_list|(
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|ot_type
operator|=
name|SEG_DESC_TYPE
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ot_type
operator|==
name|SDT_SYS386BSY
operator|||
name|ot_type
operator|==
name|SDT_SYS286BSY
argument_list|)
expr_stmt|;
comment|/* Fetch the old TSS descriptor */
name|error
operator|=
name|read_tss_descriptor
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|task_switch
argument_list|,
name|ot_sel
argument_list|,
operator|&
name|ot_desc
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|/* Get the old TSS */
name|error
operator|=
name|vm_copy_setup
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|sup_paging
argument_list|,
name|ot_base
argument_list|,
name|minlimit
operator|+
literal|1
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|ot_iov
argument_list|,
name|nitems
argument_list|(
name|ot_iov
argument_list|)
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|vm_copyin
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|ot_iov
argument_list|,
operator|&
name|oldtss
argument_list|,
name|minlimit
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the busy bit in the old TSS descriptor if the task switch 	 * due to an IRET or JMP instruction. 	 */
if|if
condition|(
name|reason
operator|==
name|TSR_IRET
operator|||
name|reason
operator|==
name|TSR_JMP
condition|)
block|{
name|ot_desc
operator|.
name|sd_type
operator|&=
operator|~
literal|0x2
expr_stmt|;
name|error
operator|=
name|desc_table_write
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|sup_paging
argument_list|,
name|ot_sel
argument_list|,
operator|&
name|ot_desc
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nt_type
operator|==
name|SDT_SYS286BSY
operator|||
name|nt_type
operator|==
name|SDT_SYS286TSS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Task switch to 16-bit TSS not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VMEXIT_ABORT
operator|)
return|;
block|}
comment|/* Save processor state in old TSS */
name|eip
operator|=
name|vmexit
operator|->
name|rip
operator|+
name|vmexit
operator|->
name|inst_length
expr_stmt|;
name|tss32_save
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|task_switch
argument_list|,
name|eip
argument_list|,
operator|&
name|oldtss
argument_list|,
name|ot_iov
argument_list|)
expr_stmt|;
comment|/* 	 * If the task switch was triggered for any reason other than IRET 	 * then set the busy bit in the new TSS descriptor. 	 */
if|if
condition|(
name|reason
operator|!=
name|TSR_IRET
condition|)
block|{
name|nt_desc
operator|.
name|sd_type
operator||=
literal|0x2
expr_stmt|;
name|error
operator|=
name|desc_table_write
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|sup_paging
argument_list|,
name|nt_sel
argument_list|,
operator|&
name|nt_desc
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Update task register to point at the new TSS */
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_TR
argument_list|,
name|nt_sel
argument_list|)
expr_stmt|;
comment|/* Update the hidden descriptor state of the task register */
name|nt
operator|=
name|usd_to_seg_desc
argument_list|(
operator|&
name|nt_desc
argument_list|)
expr_stmt|;
name|update_seg_desc
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_TR
argument_list|,
operator|&
name|nt
argument_list|)
expr_stmt|;
comment|/* Set CR0.TS */
name|cr0
operator|=
name|GETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CR0
argument_list|)
expr_stmt|;
name|SETREG
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|VM_REG_GUEST_CR0
argument_list|,
name|cr0
operator||
name|CR0_TS
argument_list|)
expr_stmt|;
comment|/* 	 * We are now committed to the task switch. Any exceptions encountered 	 * after this point will be handled in the context of the new task and 	 * the saved instruction pointer will belong to the new task. 	 */
name|vmexit
operator|->
name|rip
operator|=
name|newtss
operator|.
name|tss_eip
expr_stmt|;
name|vmexit
operator|->
name|inst_length
operator|=
literal|0
expr_stmt|;
comment|/* Load processor state from new TSS */
name|error
operator|=
name|tss32_restore
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|task_switch
argument_list|,
name|ot_sel
argument_list|,
operator|&
name|newtss
argument_list|,
name|nt_iov
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Section "Interrupt Tasks" in Intel SDM, Vol 3: if an exception 	 * caused an error code to be generated, this error code is copied 	 * to the stack of the new task. 	 */
if|if
condition|(
name|task_switch
operator|->
name|errcode_valid
condition|)
block|{
name|assert
argument_list|(
name|task_switch
operator|->
name|ext
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|task_switch
operator|->
name|reason
operator|==
name|TSR_IDT_GATE
argument_list|)
expr_stmt|;
name|error
operator|=
name|push_errcode
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
operator|&
name|task_switch
operator|->
name|paging
argument_list|,
name|nt_type
argument_list|,
name|task_switch
operator|->
name|errcode
argument_list|)
expr_stmt|;
name|CHKERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Treatment of virtual-NMI blocking if NMI is delivered through 	 * a task gate. 	 * 	 * Section "Architectural State Before A VM Exit", Intel SDM, Vol3: 	 * If the virtual NMIs VM-execution control is 1, VM entry injects 	 * an NMI, and delivery of the NMI causes a task switch that causes 	 * a VM exit, virtual-NMI blocking is in effect before the VM exit 	 * commences. 	 * 	 * Thus, virtual-NMI blocking is in effect at the time of the task 	 * switch VM exit. 	 */
comment|/* 	 * Treatment of virtual-NMI unblocking on IRET from NMI handler task. 	 * 	 * Section "Changes to Instruction Behavior in VMX Non-Root Operation" 	 * If "virtual NMIs" control is 1 IRET removes any virtual-NMI blocking. 	 * This unblocking of virtual-NMI occurs even if IRET causes a fault. 	 * 	 * Thus, virtual-NMI blocking is cleared at the time of the task switch 	 * VM exit. 	 */
comment|/* 	 * If the task switch was triggered by an event delivered through 	 * the IDT then extinguish the pending event from the vcpu's 	 * exitintinfo. 	 */
if|if
condition|(
name|task_switch
operator|->
name|reason
operator|==
name|TSR_IDT_GATE
condition|)
block|{
name|error
operator|=
name|vm_set_intinfo
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX should inject debug exception if 'T' bit is 1 	 */
name|done
label|:
return|return
operator|(
name|VMEXIT_CONTINUE
operator|)
return|;
block|}
end_function

end_unit

