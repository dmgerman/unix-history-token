begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 NetApp, Inc.  * Copyright (c) 2013 Neel Natu<neel@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/ns16550.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"mevent.h"
end_include

begin_include
include|#
directive|include
file|"uart_emul.h"
end_include

begin_define
define|#
directive|define
name|COM1_BASE
value|0x3F8
end_define

begin_define
define|#
directive|define
name|COM1_IRQ
value|4
end_define

begin_define
define|#
directive|define
name|COM2_BASE
value|0x2F8
end_define

begin_define
define|#
directive|define
name|COM2_IRQ
value|3
end_define

begin_define
define|#
directive|define
name|DEFAULT_RCLK
value|1843200
end_define

begin_define
define|#
directive|define
name|DEFAULT_BAUD
value|9600
end_define

begin_define
define|#
directive|define
name|FCR_RX_MASK
value|0xC0
end_define

begin_define
define|#
directive|define
name|MCR_OUT1
value|0x04
end_define

begin_define
define|#
directive|define
name|MCR_OUT2
value|0x08
end_define

begin_define
define|#
directive|define
name|MSR_DELTA_MASK
value|0x0f
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|REG_SCR
end_ifndef

begin_define
define|#
directive|define
name|REG_SCR
value|com_scr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FIFOSZ
value|16
end_define

begin_decl_stmt
specifier|static
name|bool
name|uart_stdio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdio in use for i/o */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termios
name|tio_stdio_orig
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|baseaddr
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|bool
name|inuse
decl_stmt|;
block|}
name|uart_lres
index|[]
init|=
block|{
block|{
name|COM1_BASE
block|,
name|COM1_IRQ
block|,
name|false
block|}
block|,
block|{
name|COM2_BASE
block|,
name|COM2_IRQ
block|,
name|false
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|UART_NLDEVS
value|(sizeof(uart_lres) / sizeof(uart_lres[0]))
end_define

begin_struct
struct|struct
name|fifo
block|{
name|uint8_t
name|buf
index|[
name|FIFOSZ
index|]
decl_stmt|;
name|int
name|rindex
decl_stmt|;
comment|/* index to read from */
name|int
name|windex
decl_stmt|;
comment|/* index to write to */
name|int
name|num
decl_stmt|;
comment|/* number of characters in the fifo */
name|int
name|size
decl_stmt|;
comment|/* size of the fifo */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ttyfd
block|{
name|bool
name|opened
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* tty device file descriptor */
name|struct
name|termios
name|tio_orig
decl_stmt|,
name|tio_new
decl_stmt|;
comment|/* I/O Terminals */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uart_softc
block|{
name|pthread_mutex_t
name|mtx
decl_stmt|;
comment|/* protects all softc elements */
name|uint8_t
name|data
decl_stmt|;
comment|/* Data register (R/W) */
name|uint8_t
name|ier
decl_stmt|;
comment|/* Interrupt enable register (R/W) */
name|uint8_t
name|lcr
decl_stmt|;
comment|/* Line control register (R/W) */
name|uint8_t
name|mcr
decl_stmt|;
comment|/* Modem control register (R/W) */
name|uint8_t
name|lsr
decl_stmt|;
comment|/* Line status register (R/W) */
name|uint8_t
name|msr
decl_stmt|;
comment|/* Modem status register (R/W) */
name|uint8_t
name|fcr
decl_stmt|;
comment|/* FIFO control register (W) */
name|uint8_t
name|scr
decl_stmt|;
comment|/* Scratch register (R/W) */
name|uint8_t
name|dll
decl_stmt|;
comment|/* Baudrate divisor latch LSB */
name|uint8_t
name|dlh
decl_stmt|;
comment|/* Baudrate divisor latch MSB */
name|struct
name|fifo
name|rxfifo
decl_stmt|;
name|struct
name|mevent
modifier|*
name|mev
decl_stmt|;
name|struct
name|ttyfd
name|tty
decl_stmt|;
name|bool
name|thre_int_pending
decl_stmt|;
comment|/* THRE interrupt pending */
name|void
modifier|*
name|arg
decl_stmt|;
name|uart_intr_func_t
name|intr_assert
decl_stmt|;
name|uart_intr_func_t
name|intr_deassert
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|uart_drain
parameter_list|(
name|int
name|fd
parameter_list|,
name|enum
name|ev_type
name|ev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ttyclose
parameter_list|(
name|void
parameter_list|)
block|{
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|tio_stdio_orig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttyopen
parameter_list|(
name|struct
name|ttyfd
modifier|*
name|tf
parameter_list|)
block|{
name|tcgetattr
argument_list|(
name|tf
operator|->
name|fd
argument_list|,
operator|&
name|tf
operator|->
name|tio_orig
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tio_new
operator|=
name|tf
operator|->
name|tio_orig
expr_stmt|;
name|cfmakeraw
argument_list|(
operator|&
name|tf
operator|->
name|tio_new
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tio_new
operator|.
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
name|tcsetattr
argument_list|(
name|tf
operator|->
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|tf
operator|->
name|tio_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|fd
operator|==
name|STDIN_FILENO
condition|)
block|{
name|tio_stdio_orig
operator|=
name|tf
operator|->
name|tio_orig
expr_stmt|;
name|atexit
argument_list|(
name|ttyclose
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ttyread
parameter_list|(
name|struct
name|ttyfd
modifier|*
name|tf
parameter_list|)
block|{
name|unsigned
name|char
name|rb
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|tf
operator|->
name|fd
argument_list|,
operator|&
name|rb
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|rb
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttywrite
parameter_list|(
name|struct
name|ttyfd
modifier|*
name|tf
parameter_list|,
name|unsigned
name|char
name|wb
parameter_list|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|tf
operator|->
name|fd
argument_list|,
operator|&
name|wb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rxfifo_reset
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
name|flushbuf
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|fifo
modifier|*
name|fifo
decl_stmt|;
name|ssize_t
name|nread
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fifo
operator|=
operator|&
name|sc
operator|->
name|rxfifo
expr_stmt|;
name|bzero
argument_list|(
name|fifo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fifo
argument_list|)
argument_list|)
expr_stmt|;
name|fifo
operator|->
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tty
operator|.
name|opened
condition|)
block|{
comment|/* 		 * Flush any unread input from the tty buffer. 		 */
while|while
condition|(
literal|1
condition|)
block|{
name|nread
operator|=
name|read
argument_list|(
name|sc
operator|->
name|tty
operator|.
name|fd
argument_list|,
name|flushbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|flushbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
sizeof|sizeof
argument_list|(
name|flushbuf
argument_list|)
condition|)
break|break;
block|}
comment|/* 		 * Enable mevent to trigger when new characters are available 		 * on the tty fd. 		 */
name|error
operator|=
name|mevent_enable
argument_list|(
name|sc
operator|->
name|mev
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rxfifo_available
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fifo
modifier|*
name|fifo
decl_stmt|;
name|fifo
operator|=
operator|&
name|sc
operator|->
name|rxfifo
expr_stmt|;
return|return
operator|(
name|fifo
operator|->
name|num
operator|<
name|fifo
operator|->
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rxfifo_putchar
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|ch
parameter_list|)
block|{
name|struct
name|fifo
modifier|*
name|fifo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fifo
operator|=
operator|&
name|sc
operator|->
name|rxfifo
expr_stmt|;
if|if
condition|(
name|fifo
operator|->
name|num
operator|<
name|fifo
operator|->
name|size
condition|)
block|{
name|fifo
operator|->
name|buf
index|[
name|fifo
operator|->
name|windex
index|]
operator|=
name|ch
expr_stmt|;
name|fifo
operator|->
name|windex
operator|=
operator|(
name|fifo
operator|->
name|windex
operator|+
literal|1
operator|)
operator|%
name|fifo
operator|->
name|size
expr_stmt|;
name|fifo
operator|->
name|num
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rxfifo_available
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tty
operator|.
name|opened
condition|)
block|{
comment|/* 				 * Disable mevent callback if the FIFO is full. 				 */
name|error
operator|=
name|mevent_disable
argument_list|(
name|sc
operator|->
name|mev
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rxfifo_getchar
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fifo
modifier|*
name|fifo
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
decl_stmt|,
name|wasfull
decl_stmt|;
name|wasfull
operator|=
literal|0
expr_stmt|;
name|fifo
operator|=
operator|&
name|sc
operator|->
name|rxfifo
expr_stmt|;
if|if
condition|(
name|fifo
operator|->
name|num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|rxfifo_available
argument_list|(
name|sc
argument_list|)
condition|)
name|wasfull
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|fifo
operator|->
name|buf
index|[
name|fifo
operator|->
name|rindex
index|]
expr_stmt|;
name|fifo
operator|->
name|rindex
operator|=
operator|(
name|fifo
operator|->
name|rindex
operator|+
literal|1
operator|)
operator|%
name|fifo
operator|->
name|size
expr_stmt|;
name|fifo
operator|->
name|num
operator|--
expr_stmt|;
if|if
condition|(
name|wasfull
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tty
operator|.
name|opened
condition|)
block|{
name|error
operator|=
name|mevent_enable
argument_list|(
name|sc
operator|->
name|mev
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rxfifo_numchars
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|fifo
modifier|*
name|fifo
init|=
operator|&
name|sc
operator|->
name|rxfifo
decl_stmt|;
return|return
operator|(
name|fifo
operator|->
name|num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uart_opentty
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ttyopen
argument_list|(
operator|&
name|sc
operator|->
name|tty
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mev
operator|=
name|mevent_add
argument_list|(
name|sc
operator|->
name|tty
operator|.
name|fd
argument_list|,
name|EVF_READ
argument_list|,
name|uart_drain
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sc
operator|->
name|mev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The IIR returns a prioritized interrupt reason:  * - receive data available  * - transmit holding register empty  * - modem status change  *  * Return an interrupt reason if one is available.  */
end_comment

begin_function
specifier|static
name|int
name|uart_intr_reason
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|lsr
operator|&
name|LSR_OE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|ier
operator|&
name|IER_ERLS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|IIR_RLS
operator|)
return|;
elseif|else
if|if
condition|(
name|rxfifo_numchars
argument_list|(
name|sc
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|sc
operator|->
name|ier
operator|&
name|IER_ERXRDY
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|IIR_RXTOUT
operator|)
return|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|thre_int_pending
operator|&&
operator|(
name|sc
operator|->
name|ier
operator|&
name|IER_ETXRDY
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|IIR_TXRDY
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|msr
operator|&
name|MSR_DELTA_MASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|ier
operator|&
name|IER_EMSC
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|IIR_MLSC
operator|)
return|;
else|else
return|return
operator|(
name|IIR_NOPEND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uart_reset
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|divisor
decl_stmt|;
name|divisor
operator|=
name|DEFAULT_RCLK
operator|/
name|DEFAULT_BAUD
operator|/
literal|16
expr_stmt|;
name|sc
operator|->
name|dll
operator|=
name|divisor
expr_stmt|;
name|sc
operator|->
name|dlh
operator|=
name|divisor
operator|>>
literal|16
expr_stmt|;
name|rxfifo_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* no fifo until enabled by software */
block|}
end_function

begin_comment
comment|/*  * Toggle the COM port's intr pin depending on whether or not we have an  * interrupt condition to report to the processor.  */
end_comment

begin_function
specifier|static
name|void
name|uart_toggle_intr
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|intr_reason
decl_stmt|;
name|intr_reason
operator|=
name|uart_intr_reason
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_reason
operator|==
name|IIR_NOPEND
condition|)
call|(
modifier|*
name|sc
operator|->
name|intr_deassert
call|)
argument_list|(
name|sc
operator|->
name|arg
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|sc
operator|->
name|intr_assert
call|)
argument_list|(
name|sc
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uart_drain
parameter_list|(
name|int
name|fd
parameter_list|,
name|enum
name|ev_type
name|ev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|uart_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|assert
argument_list|(
name|fd
operator|==
name|sc
operator|->
name|tty
operator|.
name|fd
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ev
operator|==
name|EVF_READ
argument_list|)
expr_stmt|;
comment|/* 	 * This routine is called in the context of the mevent thread 	 * to take out the softc lock to protect against concurrent 	 * access from a vCPU i/o exit 	 */
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ttyread
argument_list|(
operator|&
name|sc
operator|->
name|tty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|rxfifo_available
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
operator|(
name|ch
operator|=
name|ttyread
argument_list|(
operator|&
name|sc
operator|->
name|tty
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|rxfifo_putchar
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|uart_toggle_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uart_write
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint8_t
name|value
parameter_list|)
block|{
name|int
name|fifosz
decl_stmt|;
name|uint8_t
name|msr
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take care of the special case DLAB accesses first 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|lcr
operator|&
name|LCR_DLAB
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|==
name|REG_DLL
condition|)
block|{
name|sc
operator|->
name|dll
operator|=
name|value
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|REG_DLH
condition|)
block|{
name|sc
operator|->
name|dlh
operator|=
name|value
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|REG_DATA
case|:
if|if
condition|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_LOOPBACK
condition|)
block|{
if|if
condition|(
name|rxfifo_putchar
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|lsr
operator||=
name|LSR_OE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|tty
operator|.
name|opened
condition|)
block|{
name|ttywrite
argument_list|(
operator|&
name|sc
operator|->
name|tty
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* else drop on floor */
name|sc
operator|->
name|thre_int_pending
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|REG_IER
case|:
comment|/* 		 * Apply mask so that bits 4-7 are 0 		 * Also enables bits 0-3 only if they're 1 		 */
name|sc
operator|->
name|ier
operator|=
name|value
operator|&
literal|0x0F
expr_stmt|;
break|break;
case|case
name|REG_FCR
case|:
comment|/* 			 * When moving from FIFO and 16450 mode and vice versa, 			 * the FIFO contents are reset. 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|fcr
operator|&
name|FCR_ENABLE
operator|)
operator|^
operator|(
name|value
operator|&
name|FCR_ENABLE
operator|)
condition|)
block|{
name|fifosz
operator|=
operator|(
name|value
operator|&
name|FCR_ENABLE
operator|)
condition|?
name|FIFOSZ
else|:
literal|1
expr_stmt|;
name|rxfifo_reset
argument_list|(
name|sc
argument_list|,
name|fifosz
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * The FCR_ENABLE bit must be '1' for the programming 			 * of other FCR bits to be effective. 			 */
if|if
condition|(
operator|(
name|value
operator|&
name|FCR_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|fcr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|value
operator|&
name|FCR_RCV_RST
operator|)
operator|!=
literal|0
condition|)
name|rxfifo_reset
argument_list|(
name|sc
argument_list|,
name|FIFOSZ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fcr
operator|=
name|value
operator|&
operator|(
name|FCR_ENABLE
operator||
name|FCR_DMA
operator||
name|FCR_RX_MASK
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_LCR
case|:
name|sc
operator|->
name|lcr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|REG_MCR
case|:
comment|/* Apply mask so that bits 5-7 are 0 */
name|sc
operator|->
name|mcr
operator|=
name|value
operator|&
literal|0x1F
expr_stmt|;
name|msr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_LOOPBACK
condition|)
block|{
comment|/* 				 * In the loopback mode certain bits from the 				 * MCR are reflected back into MSR 				 */
if|if
condition|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_RTS
condition|)
name|msr
operator||=
name|MSR_CTS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_DTR
condition|)
name|msr
operator||=
name|MSR_DSR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_OUT1
condition|)
name|msr
operator||=
name|MSR_RI
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mcr
operator|&
name|MCR_OUT2
condition|)
name|msr
operator||=
name|MSR_DCD
expr_stmt|;
block|}
comment|/* 			 * Detect if there has been any change between the 			 * previous and the new value of MSR. If there is 			 * then assert the appropriate MSR delta bit. 			 */
if|if
condition|(
operator|(
name|msr
operator|&
name|MSR_CTS
operator|)
operator|^
operator|(
name|sc
operator|->
name|msr
operator|&
name|MSR_CTS
operator|)
condition|)
name|sc
operator|->
name|msr
operator||=
name|MSR_DCTS
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
name|MSR_DSR
operator|)
operator|^
operator|(
name|sc
operator|->
name|msr
operator|&
name|MSR_DSR
operator|)
condition|)
name|sc
operator|->
name|msr
operator||=
name|MSR_DDSR
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
name|MSR_DCD
operator|)
operator|^
operator|(
name|sc
operator|->
name|msr
operator|&
name|MSR_DCD
operator|)
condition|)
name|sc
operator|->
name|msr
operator||=
name|MSR_DDCD
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|msr
operator|&
name|MSR_RI
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|msr
operator|&
name|MSR_RI
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|msr
operator||=
name|MSR_TERI
expr_stmt|;
comment|/* 			 * Update the value of MSR while retaining the delta 			 * bits. 			 */
name|sc
operator|->
name|msr
operator|&=
name|MSR_DELTA_MASK
expr_stmt|;
name|sc
operator|->
name|msr
operator||=
name|msr
expr_stmt|;
break|break;
case|case
name|REG_LSR
case|:
comment|/* 			 * Line status register is not meant to be written to 			 * during normal operation. 			 */
break|break;
case|case
name|REG_MSR
case|:
comment|/* 			 * As far as I can tell MSR is a read-only register. 			 */
break|break;
case|case
name|REG_SCR
case|:
name|sc
operator|->
name|scr
operator|=
name|value
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|done
label|:
name|uart_toggle_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|uart_read
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|uint8_t
name|iir
decl_stmt|,
name|intr_reason
decl_stmt|,
name|reg
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take care of the special case DLAB accesses first 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|lcr
operator|&
name|LCR_DLAB
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|==
name|REG_DLL
condition|)
block|{
name|reg
operator|=
name|sc
operator|->
name|dll
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|offset
operator|==
name|REG_DLH
condition|)
block|{
name|reg
operator|=
name|sc
operator|->
name|dlh
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|REG_DATA
case|:
name|reg
operator|=
name|rxfifo_getchar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_IER
case|:
name|reg
operator|=
name|sc
operator|->
name|ier
expr_stmt|;
break|break;
case|case
name|REG_IIR
case|:
name|iir
operator|=
operator|(
name|sc
operator|->
name|fcr
operator|&
name|FCR_ENABLE
operator|)
condition|?
name|IIR_FIFO_MASK
else|:
literal|0
expr_stmt|;
name|intr_reason
operator|=
name|uart_intr_reason
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Deal with side effects of reading the IIR register 		 */
if|if
condition|(
name|intr_reason
operator|==
name|IIR_TXRDY
condition|)
name|sc
operator|->
name|thre_int_pending
operator|=
name|false
expr_stmt|;
name|iir
operator||=
name|intr_reason
expr_stmt|;
name|reg
operator|=
name|iir
expr_stmt|;
break|break;
case|case
name|REG_LCR
case|:
name|reg
operator|=
name|sc
operator|->
name|lcr
expr_stmt|;
break|break;
case|case
name|REG_MCR
case|:
name|reg
operator|=
name|sc
operator|->
name|mcr
expr_stmt|;
break|break;
case|case
name|REG_LSR
case|:
comment|/* Transmitter is always ready for more data */
name|sc
operator|->
name|lsr
operator||=
name|LSR_TEMT
operator||
name|LSR_THRE
expr_stmt|;
comment|/* Check for new receive data */
if|if
condition|(
name|rxfifo_numchars
argument_list|(
name|sc
argument_list|)
operator|>
literal|0
condition|)
name|sc
operator|->
name|lsr
operator||=
name|LSR_RXRDY
expr_stmt|;
else|else
name|sc
operator|->
name|lsr
operator|&=
operator|~
name|LSR_RXRDY
expr_stmt|;
name|reg
operator|=
name|sc
operator|->
name|lsr
expr_stmt|;
comment|/* The LSR_OE bit is cleared on LSR read */
name|sc
operator|->
name|lsr
operator|&=
operator|~
name|LSR_OE
expr_stmt|;
break|break;
case|case
name|REG_MSR
case|:
comment|/* 		 * MSR delta bits are cleared on read 		 */
name|reg
operator|=
name|sc
operator|->
name|msr
expr_stmt|;
name|sc
operator|->
name|msr
operator|&=
operator|~
name|MSR_DELTA_MASK
expr_stmt|;
break|break;
case|case
name|REG_SCR
case|:
name|reg
operator|=
name|sc
operator|->
name|scr
expr_stmt|;
break|break;
default|default:
name|reg
operator|=
literal|0xFF
expr_stmt|;
break|break;
block|}
name|done
label|:
name|uart_toggle_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uart_legacy_alloc
parameter_list|(
name|int
name|which
parameter_list|,
name|int
modifier|*
name|baseaddr
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|)
block|{
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|UART_NLDEVS
operator|||
name|uart_lres
index|[
name|which
index|]
operator|.
name|inuse
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|uart_lres
index|[
name|which
index|]
operator|.
name|inuse
operator|=
name|true
expr_stmt|;
operator|*
name|baseaddr
operator|=
name|uart_lres
index|[
name|which
index|]
operator|.
name|baseaddr
expr_stmt|;
operator|*
name|irq
operator|=
name|uart_lres
index|[
name|which
index|]
operator|.
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|uart_softc
modifier|*
name|uart_init
parameter_list|(
name|uart_intr_func_t
name|intr_assert
parameter_list|,
name|uart_intr_func_t
name|intr_deassert
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|uart_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uart_softc
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uart_softc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|sc
operator|->
name|intr_assert
operator|=
name|intr_assert
expr_stmt|;
name|sc
operator|->
name|intr_deassert
operator|=
name|intr_deassert
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uart_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uart_tty_backend
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|opts
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
operator|&&
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|sc
operator|->
name|tty
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|sc
operator|->
name|tty
operator|.
name|opened
operator|=
name|true
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uart_set_backend
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|opts
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"stdio"
argument_list|,
name|opts
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uart_stdio
condition|)
block|{
name|sc
operator|->
name|tty
operator|.
name|fd
operator|=
name|STDIN_FILENO
expr_stmt|;
name|sc
operator|->
name|tty
operator|.
name|opened
operator|=
name|true
expr_stmt|;
name|uart_stdio
operator|=
name|true
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uart_tty_backend
argument_list|(
name|sc
argument_list|,
name|opts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make the backend file descriptor non-blocking */
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
name|fcntl
argument_list|(
name|sc
operator|->
name|tty
operator|.
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|uart_opentty
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

