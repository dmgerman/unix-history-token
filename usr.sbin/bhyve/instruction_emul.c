begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Sandvine, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_include
include|#
directive|include
file|"fbsdrun.h"
end_include

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"instruction_emul.h"
end_include

begin_define
define|#
directive|define
name|PREFIX_LOCK
value|0xF0
end_define

begin_define
define|#
directive|define
name|PREFIX_REPNE
value|0xF2
end_define

begin_define
define|#
directive|define
name|PREFIX_REPE
value|0xF3
end_define

begin_define
define|#
directive|define
name|PREFIX_CS_OVERRIDE
value|0x2E
end_define

begin_define
define|#
directive|define
name|PREFIX_SS_OVERRIDE
value|0x36
end_define

begin_define
define|#
directive|define
name|PREFIX_DS_OVERRIDE
value|0x3E
end_define

begin_define
define|#
directive|define
name|PREFIX_ES_OVERRIDE
value|0x26
end_define

begin_define
define|#
directive|define
name|PREFIX_FS_OVERRIDE
value|0x64
end_define

begin_define
define|#
directive|define
name|PREFIX_GS_OVERRIDE
value|0x65
end_define

begin_define
define|#
directive|define
name|PREFIX_BRANCH_NOT_TAKEN
value|0x2E
end_define

begin_define
define|#
directive|define
name|PREFIX_BRANCH_TAKEN
value|0x3E
end_define

begin_define
define|#
directive|define
name|PREFIX_OPSIZE
value|0x66
end_define

begin_define
define|#
directive|define
name|is_opsz_prefix
parameter_list|(
name|x
parameter_list|)
value|((x) == PREFIX_OPSIZE)
end_define

begin_define
define|#
directive|define
name|PREFIX_ADDRSIZE
value|0x67
end_define

begin_define
define|#
directive|define
name|OPCODE_2BYTE_ESCAPE
value|0x0F
end_define

begin_define
define|#
directive|define
name|OPCODE_3BYTE_ESCAPE
value|0x38
end_define

begin_define
define|#
directive|define
name|MODRM_MOD_MASK
value|0xC0
end_define

begin_define
define|#
directive|define
name|MODRM_MOD_SHIFT
value|6
end_define

begin_define
define|#
directive|define
name|MODRM_RM_MASK
value|0x07
end_define

begin_define
define|#
directive|define
name|MODRM_RM_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|MODRM_REG_MASK
value|0x38
end_define

begin_define
define|#
directive|define
name|MODRM_REG_SHIFT
value|3
end_define

begin_define
define|#
directive|define
name|MOD_INDIRECT
value|0x0
end_define

begin_define
define|#
directive|define
name|MOD_INDIRECT_DISP8
value|0x1
end_define

begin_define
define|#
directive|define
name|MOD_INDIRECT_DISP32
value|0x2
end_define

begin_define
define|#
directive|define
name|MOD_DIRECT
value|0x3
end_define

begin_define
define|#
directive|define
name|RM_EAX
value|0x0
end_define

begin_define
define|#
directive|define
name|RM_ECX
value|0x1
end_define

begin_define
define|#
directive|define
name|RM_EDX
value|0x2
end_define

begin_define
define|#
directive|define
name|RM_EBX
value|0x3
end_define

begin_define
define|#
directive|define
name|RM_SIB
value|0x4
end_define

begin_define
define|#
directive|define
name|RM_DISP32
value|0x5
end_define

begin_define
define|#
directive|define
name|RM_EBP
value|RM_DISP32
end_define

begin_define
define|#
directive|define
name|RM_ESI
value|0x6
end_define

begin_define
define|#
directive|define
name|RM_EDI
value|0x7
end_define

begin_define
define|#
directive|define
name|REG_EAX
value|0x0
end_define

begin_define
define|#
directive|define
name|REG_ECX
value|0x1
end_define

begin_define
define|#
directive|define
name|REG_EDX
value|0x2
end_define

begin_define
define|#
directive|define
name|REG_EBX
value|0x3
end_define

begin_define
define|#
directive|define
name|REG_ESP
value|0x4
end_define

begin_define
define|#
directive|define
name|REG_EBP
value|0x5
end_define

begin_define
define|#
directive|define
name|REG_ESI
value|0x6
end_define

begin_define
define|#
directive|define
name|REG_EDI
value|0x7
end_define

begin_define
define|#
directive|define
name|REG_R8
value|0x8
end_define

begin_define
define|#
directive|define
name|REG_R9
value|0x9
end_define

begin_define
define|#
directive|define
name|REG_R10
value|0xA
end_define

begin_define
define|#
directive|define
name|REG_R11
value|0xB
end_define

begin_define
define|#
directive|define
name|REG_R12
value|0xC
end_define

begin_define
define|#
directive|define
name|REG_R13
value|0xD
end_define

begin_define
define|#
directive|define
name|REG_R14
value|0xE
end_define

begin_define
define|#
directive|define
name|REG_R15
value|0xF
end_define

begin_define
define|#
directive|define
name|HAS_MODRM
value|1
end_define

begin_define
define|#
directive|define
name|FROM_RM
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|FROM_REG
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|TO_RM
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|TO_REG
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|ZEXT
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|FROM_8
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|FROM_16
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|TO_8
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|TO_16
value|(1<<9)
end_define

begin_define
define|#
directive|define
name|REX_MASK
value|0xF0
end_define

begin_define
define|#
directive|define
name|REX_PREFIX
value|0x40
end_define

begin_define
define|#
directive|define
name|is_rex_prefix
parameter_list|(
name|x
parameter_list|)
value|( ((x)& REX_MASK) == REX_PREFIX )
end_define

begin_define
define|#
directive|define
name|REX_W_MASK
value|0x8
end_define

begin_define
define|#
directive|define
name|REX_R_MASK
value|0x4
end_define

begin_define
define|#
directive|define
name|REX_X_MASK
value|0x2
end_define

begin_define
define|#
directive|define
name|REX_B_MASK
value|0x1
end_define

begin_define
define|#
directive|define
name|is_prefix
parameter_list|(
name|x
parameter_list|)
value|((x) == PREFIX_LOCK || (x) == PREFIX_REPNE || \ 		      (x) == PREFIX_REPE || (x) == PREFIX_CS_OVERRIDE || \ 		      (x) == PREFIX_SS_OVERRIDE || (x) == PREFIX_DS_OVERRIDE || \ 		      (x) == PREFIX_ES_OVERRIDE || (x) == PREFIX_FS_OVERRIDE || \ 		      (x) == PREFIX_GS_OVERRIDE || (x) == PREFIX_BRANCH_NOT_TAKEN || \ 		      (x) == PREFIX_BRANCH_TAKEN || (x) == PREFIX_OPSIZE || \ 		      (x) == PREFIX_ADDRSIZE || is_rex_prefix((x)))
end_define

begin_define
define|#
directive|define
name|PAGE_FRAME_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|PAGE_OFFSET_MASK
value|0xFFF
end_define

begin_define
define|#
directive|define
name|PAGE_TABLE_ENTRY_MASK
value|(~PAGE_OFFSET_MASK)
end_define

begin_define
define|#
directive|define
name|PML4E_OFFSET_MASK
value|0x0000FF8000000000
end_define

begin_define
define|#
directive|define
name|PML4E_SHIFT
value|39
end_define

begin_define
define|#
directive|define
name|INSTR_VERIFY
end_define

begin_struct
struct|struct
name|decoded_instruction
block|{
name|void
modifier|*
name|instruction
decl_stmt|;
name|uint8_t
modifier|*
name|opcode
decl_stmt|;
name|uint8_t
modifier|*
name|modrm
decl_stmt|;
name|uint8_t
modifier|*
name|sib
decl_stmt|;
name|uint8_t
modifier|*
name|displacement
decl_stmt|;
name|uint8_t
modifier|*
name|immediate
decl_stmt|;
name|uint16_t
name|opcode_flags
decl_stmt|;
name|uint8_t
name|addressing_mode
decl_stmt|;
name|uint8_t
name|rm
decl_stmt|;
name|uint8_t
name|reg
decl_stmt|;
name|uint8_t
name|opsz
decl_stmt|;
name|uint8_t
name|rex_r
decl_stmt|;
name|uint8_t
name|rex_w
decl_stmt|;
name|uint8_t
name|rex_b
decl_stmt|;
name|uint8_t
name|rex_x
decl_stmt|;
name|int32_t
name|disp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|enum
name|vm_reg_name
name|vm_reg_name_mappings
index|[]
init|=
block|{
index|[
name|REG_EAX
index|]
operator|=
name|VM_REG_GUEST_RAX
block|,
index|[
name|REG_EBX
index|]
operator|=
name|VM_REG_GUEST_RBX
block|,
index|[
name|REG_ECX
index|]
operator|=
name|VM_REG_GUEST_RCX
block|,
index|[
name|REG_EDX
index|]
operator|=
name|VM_REG_GUEST_RDX
block|,
index|[
name|REG_ESP
index|]
operator|=
name|VM_REG_GUEST_RSP
block|,
index|[
name|REG_EBP
index|]
operator|=
name|VM_REG_GUEST_RBP
block|,
index|[
name|REG_ESI
index|]
operator|=
name|VM_REG_GUEST_RSI
block|,
index|[
name|REG_EDI
index|]
operator|=
name|VM_REG_GUEST_RDI
block|,
index|[
name|REG_R8
index|]
operator|=
name|VM_REG_GUEST_R8
block|,
index|[
name|REG_R9
index|]
operator|=
name|VM_REG_GUEST_R9
block|,
index|[
name|REG_R10
index|]
operator|=
name|VM_REG_GUEST_R10
block|,
index|[
name|REG_R11
index|]
operator|=
name|VM_REG_GUEST_R11
block|,
index|[
name|REG_R12
index|]
operator|=
name|VM_REG_GUEST_R12
block|,
index|[
name|REG_R13
index|]
operator|=
name|VM_REG_GUEST_R13
block|,
index|[
name|REG_R14
index|]
operator|=
name|VM_REG_GUEST_R14
block|,
index|[
name|REG_R15
index|]
operator|=
name|VM_REG_GUEST_R15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint16_t
name|one_byte_opcodes
index|[
literal|256
index|]
init|=
block|{
index|[
literal|0x88
index|]
operator|=
name|HAS_MODRM
operator||
name|FROM_REG
operator||
name|TO_RM
operator||
name|TO_8
operator||
name|FROM_8
block|,
index|[
literal|0x89
index|]
operator|=
name|HAS_MODRM
operator||
name|FROM_REG
operator||
name|TO_RM
block|,
index|[
literal|0x8B
index|]
operator|=
name|HAS_MODRM
operator||
name|FROM_RM
operator||
name|TO_REG
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint16_t
name|two_byte_opcodes
index|[
literal|256
index|]
init|=
block|{
index|[
literal|0xB6
index|]
operator|=
name|HAS_MODRM
operator||
name|FROM_RM
operator||
name|TO_REG
operator||
name|ZEXT
operator||
name|FROM_8
block|,
index|[
literal|0xB7
index|]
operator|=
name|HAS_MODRM
operator||
name|FROM_RM
operator||
name|TO_REG
operator||
name|ZEXT
operator||
name|FROM_16
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uintptr_t
name|gla2gpa
parameter_list|(
name|uint64_t
name|gla
parameter_list|,
name|uint64_t
name|guest_cr3
parameter_list|)
block|{
name|uint64_t
modifier|*
name|table
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|,
name|entry
decl_stmt|;
name|int
name|level
decl_stmt|,
name|shift
decl_stmt|;
name|uintptr_t
name|page_frame
decl_stmt|;
name|table
operator|=
name|paddr_guest2host
argument_list|(
name|guest_cr3
operator|&
name|PAGE_TABLE_ENTRY_MASK
argument_list|)
expr_stmt|;
name|mask
operator|=
name|PML4E_OFFSET_MASK
expr_stmt|;
name|shift
operator|=
name|PML4E_SHIFT
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<
literal|4
condition|;
operator|++
name|level
control|)
block|{
name|entry
operator|=
name|table
index|[
operator|(
name|gla
operator|&
name|mask
operator|)
operator|>>
name|shift
index|]
expr_stmt|;
name|table
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|entry
operator|&
name|PAGE_TABLE_ENTRY_MASK
operator|)
expr_stmt|;
comment|/* This entry does not point to another page table */
if|if
condition|(
name|entry
operator|&
name|PAGE_FRAME_MASK
operator|||
name|level
operator|>=
literal|3
condition|)
break|break;
name|table
operator|=
name|paddr_guest2host
argument_list|(
operator|(
name|uintptr_t
operator|)
name|table
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|9
expr_stmt|;
name|shift
operator|-=
literal|9
expr_stmt|;
block|}
name|mask
operator|=
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
expr_stmt|;
name|page_frame
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|table
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
return|return
operator|(
name|page_frame
operator||
operator|(
name|gla
operator|&
name|mask
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|gla2hla
parameter_list|(
name|uint64_t
name|gla
parameter_list|,
name|uint64_t
name|guest_cr3
parameter_list|)
block|{
name|uintptr_t
name|gpa
decl_stmt|;
name|gpa
operator|=
name|gla2gpa
argument_list|(
name|gla
argument_list|,
name|guest_cr3
argument_list|)
expr_stmt|;
return|return
operator|(
name|paddr_guest2host
argument_list|(
name|gpa
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decodes all of the prefixes of the instruction. Only a subset of REX   * prefixes are currently supported. If any unsupported prefix is   * encountered, returns -1.  */
end_comment

begin_function
specifier|static
name|int
name|decode_prefixes
parameter_list|(
name|struct
name|decoded_instruction
modifier|*
name|decoded
parameter_list|)
block|{
name|uint8_t
modifier|*
name|current_prefix
decl_stmt|;
name|current_prefix
operator|=
name|decoded
operator|->
name|instruction
expr_stmt|;
if|if
condition|(
name|is_rex_prefix
argument_list|(
operator|*
name|current_prefix
argument_list|)
condition|)
block|{
name|decoded
operator|->
name|rex_w
operator|=
operator|*
name|current_prefix
operator|&
name|REX_W_MASK
expr_stmt|;
name|decoded
operator|->
name|rex_r
operator|=
operator|*
name|current_prefix
operator|&
name|REX_R_MASK
expr_stmt|;
name|decoded
operator|->
name|rex_x
operator|=
operator|*
name|current_prefix
operator|&
name|REX_X_MASK
expr_stmt|;
name|decoded
operator|->
name|rex_b
operator|=
operator|*
name|current_prefix
operator|&
name|REX_B_MASK
expr_stmt|;
name|current_prefix
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_opsz_prefix
argument_list|(
operator|*
name|current_prefix
argument_list|)
condition|)
block|{
name|decoded
operator|->
name|opsz
operator|=
literal|1
expr_stmt|;
name|current_prefix
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_prefix
argument_list|(
operator|*
name|current_prefix
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|decoded
operator|->
name|opcode
operator|=
name|current_prefix
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decodes the instruction's opcode. If the opcode is not understood, returns  * -1 indicating an error. Sets the instruction's mod_rm pointer to the   * location of the ModR/M field.  */
end_comment

begin_function
specifier|static
name|int
name|decode_opcode
parameter_list|(
name|struct
name|decoded_instruction
modifier|*
name|decoded
parameter_list|)
block|{
name|uint8_t
name|opcode
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|opcode
operator|=
operator|*
name|decoded
operator|->
name|opcode
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
literal|0xf
condition|)
name|flags
operator|=
name|one_byte_opcodes
index|[
name|opcode
index|]
expr_stmt|;
else|else
block|{
name|opcode
operator|=
operator|*
operator|(
name|decoded
operator|->
name|opcode
operator|+
literal|1
operator|)
expr_stmt|;
name|flags
operator|=
name|two_byte_opcodes
index|[
name|opcode
index|]
expr_stmt|;
name|extra
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flags
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|HAS_MODRM
condition|)
block|{
name|decoded
operator|->
name|modrm
operator|=
name|decoded
operator|->
name|opcode
operator|+
literal|1
operator|+
name|extra
expr_stmt|;
block|}
name|decoded
operator|->
name|opcode_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decodes the instruction's ModR/M field. Sets the instruction's sib pointer  * to the location of the SIB if one is expected to be present, or 0 if not.  */
end_comment

begin_function
specifier|static
name|int
name|decode_mod_rm
parameter_list|(
name|struct
name|decoded_instruction
modifier|*
name|decoded
parameter_list|)
block|{
name|uint8_t
name|modrm
decl_stmt|;
name|uint8_t
modifier|*
name|extension_operands
decl_stmt|;
if|if
condition|(
name|decoded
operator|->
name|modrm
condition|)
block|{
name|modrm
operator|=
operator|*
name|decoded
operator|->
name|modrm
expr_stmt|;
name|decoded
operator|->
name|addressing_mode
operator|=
operator|(
name|modrm
operator|&
name|MODRM_MOD_MASK
operator|)
operator|>>
name|MODRM_MOD_SHIFT
expr_stmt|;
name|decoded
operator|->
name|rm
operator|=
operator|(
name|modrm
operator|&
name|MODRM_RM_MASK
operator|)
operator|>>
name|MODRM_RM_SHIFT
expr_stmt|;
name|decoded
operator|->
name|reg
operator|=
operator|(
name|modrm
operator|&
name|MODRM_REG_MASK
operator|)
operator|>>
name|MODRM_REG_SHIFT
expr_stmt|;
if|if
condition|(
name|decoded
operator|->
name|rex_b
condition|)
name|decoded
operator|->
name|rm
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|decoded
operator|->
name|rex_r
condition|)
name|decoded
operator|->
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
name|extension_operands
operator|=
name|decoded
operator|->
name|modrm
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|decoded
operator|->
name|rm
operator|==
name|RM_SIB
condition|)
block|{
name|decoded
operator|->
name|sib
operator|=
name|decoded
operator|->
name|modrm
operator|+
literal|1
expr_stmt|;
name|extension_operands
operator|=
name|decoded
operator|->
name|sib
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|decoded
operator|->
name|addressing_mode
condition|)
block|{
case|case
name|MOD_INDIRECT
case|:
case|case
name|MOD_DIRECT
case|:
name|decoded
operator|->
name|displacement
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MOD_INDIRECT_DISP8
case|:
name|decoded
operator|->
name|displacement
operator|=
name|extension_operands
expr_stmt|;
break|break;
case|case
name|MOD_INDIRECT_DISP32
case|:
name|decoded
operator|->
name|displacement
operator|=
name|extension_operands
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decodes the instruction's SIB field. No such instructions are currently  * supported, so do nothing and return -1 if there is a SIB field, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|decode_sib
parameter_list|(
name|struct
name|decoded_instruction
modifier|*
name|decoded
parameter_list|)
block|{
if|if
condition|(
name|decoded
operator|->
name|sib
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grabs and saves the instruction's immediate operand and displacement if  * they are present. Immediates are not currently supported, so if an   * immediate is present it will return -1 indicating an error.  */
end_comment

begin_function
specifier|static
name|int
name|decode_extension_operands
parameter_list|(
name|struct
name|decoded_instruction
modifier|*
name|decoded
parameter_list|)
block|{
if|if
condition|(
name|decoded
operator|->
name|displacement
condition|)
block|{
if|if
condition|(
name|decoded
operator|->
name|addressing_mode
operator|==
name|MOD_INDIRECT_DISP8
condition|)
block|{
name|decoded
operator|->
name|disp
operator|=
operator|*
operator|(
operator|(
name|int8_t
operator|*
operator|)
name|decoded
operator|->
name|displacement
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decoded
operator|->
name|addressing_mode
operator|==
name|MOD_INDIRECT_DISP32
condition|)
block|{
name|decoded
operator|->
name|disp
operator|=
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|decoded
operator|->
name|displacement
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decoded
operator|->
name|immediate
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_instruction
parameter_list|(
name|void
modifier|*
name|instr
parameter_list|,
name|struct
name|decoded_instruction
modifier|*
name|decoded
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|decoded
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|decoded
argument_list|)
argument_list|)
expr_stmt|;
name|decoded
operator|->
name|instruction
operator|=
name|instr
expr_stmt|;
name|error
operator|=
name|decode_prefixes
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|decode_opcode
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|decode_mod_rm
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|decode_sib
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|decode_extension_operands
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|vm_reg_name
name|get_vm_reg_name
parameter_list|(
name|uint8_t
name|reg
parameter_list|)
block|{
return|return
operator|(
name|vm_reg_name_mappings
index|[
name|reg
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|adjust_operand
parameter_list|(
specifier|const
name|struct
name|decoded_instruction
modifier|*
name|instruction
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|ZEXT
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|ret
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret
operator|=
name|val
operator|&
literal|0xffffffff
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ret
operator|=
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * Extend the sign 		 */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|ret
operator|=
call|(
name|int8_t
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|val
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|val
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ret
operator|=
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_operand
parameter_list|(
name|struct
name|vmctx
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
name|guest_cr3
parameter_list|,
specifier|const
name|struct
name|decoded_instruction
modifier|*
name|instruction
parameter_list|,
name|uint64_t
modifier|*
name|operand
parameter_list|,
name|struct
name|mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|enum
name|vm_reg_name
name|regname
decl_stmt|;
name|uint64_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|rm
decl_stmt|,
name|addressing_mode
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|FROM_RM
condition|)
block|{
name|rm
operator|=
name|instruction
operator|->
name|rm
expr_stmt|;
name|addressing_mode
operator|=
name|instruction
operator|->
name|addressing_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|FROM_REG
condition|)
block|{
name|rm
operator|=
name|instruction
operator|->
name|reg
expr_stmt|;
name|addressing_mode
operator|=
name|MOD_DIRECT
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Determine size of operand 	 */
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|FROM_8
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|FROM_16
operator|||
name|instruction
operator|->
name|opsz
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
block|}
name|regname
operator|=
name|get_vm_reg_name
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|regname
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|addressing_mode
condition|)
block|{
case|case
name|MOD_DIRECT
case|:
operator|*
name|operand
operator|=
name|reg
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MOD_INDIRECT
case|:
case|case
name|MOD_INDIRECT_DISP8
case|:
case|case
name|MOD_INDIRECT_DISP32
case|:
ifdef|#
directive|ifdef
name|INSTR_VERIFY
block|{
name|uintptr_t
name|target
decl_stmt|;
name|target
operator|=
name|gla2gpa
argument_list|(
name|reg
argument_list|,
name|guest_cr3
argument_list|)
expr_stmt|;
name|target
operator|+=
name|instruction
operator|->
name|disp
expr_stmt|;
name|assert
argument_list|(
name|gpa
operator|==
name|target
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
call|(
modifier|*
name|mr
operator|->
name|handler
call|)
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|MEM_F_READ
argument_list|,
name|gpa
argument_list|,
name|size
argument_list|,
name|operand
argument_list|,
name|mr
operator|->
name|arg1
argument_list|,
name|mr
operator|->
name|arg2
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|operand
operator|=
name|adjust_operand
argument_list|(
name|instruction
argument_list|,
operator|*
name|operand
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|adjust_write
parameter_list|(
name|uint64_t
name|reg
parameter_list|,
name|uint64_t
name|operand
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
operator|(
name|reg
operator|&
operator|~
literal|0xff
operator|)
operator||
operator|(
name|operand
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
operator|(
name|reg
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|operand
operator|&
literal|0xffff
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|val
operator|=
operator|(
name|reg
operator|&
operator|~
literal|0xffffffff
operator|)
operator||
operator|(
name|operand
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|val
operator|=
name|operand
expr_stmt|;
default|default:
break|break;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|perform_write
parameter_list|(
name|struct
name|vmctx
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
name|guest_cr3
parameter_list|,
specifier|const
name|struct
name|decoded_instruction
modifier|*
name|instruction
parameter_list|,
name|uint64_t
name|operand
parameter_list|,
name|struct
name|mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|enum
name|vm_reg_name
name|regname
decl_stmt|;
name|uintptr_t
name|target
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|size
decl_stmt|;
name|uint64_t
name|reg
decl_stmt|;
name|uint8_t
name|addressing_mode
decl_stmt|;
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|TO_RM
condition|)
block|{
name|reg
operator|=
name|instruction
operator|->
name|rm
expr_stmt|;
name|addressing_mode
operator|=
name|instruction
operator|->
name|addressing_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|TO_REG
condition|)
block|{
name|reg
operator|=
name|instruction
operator|->
name|reg
expr_stmt|;
name|addressing_mode
operator|=
name|MOD_DIRECT
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Determine the operand size. rex.w has priority 	 */
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|instruction
operator|->
name|rex_w
condition|)
block|{
name|size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|opcode_flags
operator|&
name|TO_8
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|opsz
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
block|}
empty_stmt|;
switch|switch
condition|(
name|addressing_mode
condition|)
block|{
case|case
name|MOD_DIRECT
case|:
name|regname
operator|=
name|get_vm_reg_name
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|regname
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|operand
operator|=
name|adjust_write
argument_list|(
name|reg
argument_list|,
name|operand
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|vm_set_register
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|regname
argument_list|,
name|operand
argument_list|)
operator|)
return|;
case|case
name|MOD_INDIRECT
case|:
case|case
name|MOD_INDIRECT_DISP8
case|:
case|case
name|MOD_INDIRECT_DISP32
case|:
ifdef|#
directive|ifdef
name|INSTR_VERIFY
name|regname
operator|=
name|get_vm_reg_name
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_get_register
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|regname
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
name|target
operator|=
name|gla2gpa
argument_list|(
name|reg
argument_list|,
name|guest_cr3
argument_list|)
expr_stmt|;
name|target
operator|+=
name|instruction
operator|->
name|disp
expr_stmt|;
name|assert
argument_list|(
name|gpa
operator|==
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
call|(
modifier|*
name|mr
operator|->
name|handler
call|)
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|MEM_F_WRITE
argument_list|,
name|gpa
argument_list|,
name|size
argument_list|,
operator|&
name|operand
argument_list|,
name|mr
operator|->
name|arg1
argument_list|,
name|mr
operator|->
name|arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|emulate_decoded_instruction
parameter_list|(
name|struct
name|vmctx
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
name|cr3
parameter_list|,
specifier|const
name|struct
name|decoded_instruction
modifier|*
name|instruction
parameter_list|,
name|struct
name|mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|uint64_t
name|operand
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|get_operand
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|gpa
argument_list|,
name|cr3
argument_list|,
name|instruction
argument_list|,
operator|&
name|operand
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|perform_write
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|gpa
argument_list|,
name|cr3
argument_list|,
name|instruction
argument_list|,
name|operand
argument_list|,
name|mr
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|emulate_instruction
parameter_list|(
name|struct
name|vmctx
modifier|*
name|vm
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|uint64_t
name|rip
parameter_list|,
name|uint64_t
name|cr3
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mem_range
modifier|*
name|mr
parameter_list|)
block|{
name|struct
name|decoded_instruction
name|instr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|instruction
decl_stmt|;
name|instruction
operator|=
name|gla2hla
argument_list|(
name|rip
argument_list|,
name|cr3
argument_list|)
expr_stmt|;
name|error
operator|=
name|decode_instruction
argument_list|(
name|instruction
argument_list|,
operator|&
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|emulate_decoded_instruction
argument_list|(
name|vm
argument_list|,
name|vcpu
argument_list|,
name|gpa
argument_list|,
name|cr3
argument_list|,
operator|&
name|instr
argument_list|,
name|mr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

