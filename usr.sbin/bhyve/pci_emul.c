begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_include
include|#
directive|include
file|"acpi.h"
end_include

begin_include
include|#
directive|include
file|"bhyverun.h"
end_include

begin_include
include|#
directive|include
file|"inout.h"
end_include

begin_include
include|#
directive|include
file|"ioapic.h"
end_include

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"pci_emul.h"
end_include

begin_include
include|#
directive|include
file|"pci_irq.h"
end_include

begin_include
include|#
directive|include
file|"pci_lpc.h"
end_include

begin_define
define|#
directive|define
name|CONF1_ADDR_PORT
value|0x0cf8
end_define

begin_define
define|#
directive|define
name|CONF1_DATA_PORT
value|0x0cfc
end_define

begin_define
define|#
directive|define
name|CONF1_ENABLE
value|0x80000000ul
end_define

begin_define
define|#
directive|define
name|MAXBUSES
value|(PCI_BUSMAX + 1)
end_define

begin_define
define|#
directive|define
name|MAXSLOTS
value|(PCI_SLOTMAX + 1)
end_define

begin_define
define|#
directive|define
name|MAXFUNCS
value|(PCI_FUNCMAX + 1)
end_define

begin_struct
struct|struct
name|funcinfo
block|{
name|char
modifier|*
name|fi_name
decl_stmt|;
name|char
modifier|*
name|fi_param
decl_stmt|;
name|struct
name|pci_devinst
modifier|*
name|fi_devi
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|intxinfo
block|{
name|int
name|ii_count
decl_stmt|;
name|int
name|ii_pirq_pin
decl_stmt|;
name|int
name|ii_ioapic_irq
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|slotinfo
block|{
name|struct
name|intxinfo
name|si_intpins
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|funcinfo
name|si_funcs
index|[
name|MAXFUNCS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|businfo
block|{
name|uint16_t
name|iobase
decl_stmt|,
name|iolimit
decl_stmt|;
comment|/* I/O window */
name|uint32_t
name|membase32
decl_stmt|,
name|memlimit32
decl_stmt|;
comment|/* mmio window below 4GB */
name|uint64_t
name|membase64
decl_stmt|,
name|memlimit64
decl_stmt|;
comment|/* mmio window above 4GB */
name|struct
name|slotinfo
name|slotinfo
index|[
name|MAXSLOTS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|businfo
modifier|*
name|pci_businfo
index|[
name|MAXBUSES
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|pci_devemu_set
argument_list|,
expr|struct
name|pci_devemu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_iobase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_membase32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_membase64
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_IOBASE
value|0x2000
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_IOLIMIT
value|0x10000
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_ECFG_BASE
value|0xE0000000
end_define

begin_comment
comment|/* 3.5GB */
end_comment

begin_define
define|#
directive|define
name|PCI_EMUL_ECFG_SIZE
value|(MAXBUSES * 1024 * 1024)
end_define

begin_comment
comment|/* 1MB per bus */
end_comment

begin_expr_stmt
name|SYSRES_MEM
argument_list|(
name|PCI_EMUL_ECFG_BASE
argument_list|,
name|PCI_EMUL_ECFG_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_MEMLIMIT32
value|PCI_EMUL_ECFG_BASE
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMBASE64
value|0xD000000000UL
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMLIMIT64
value|0xFD00000000UL
end_define

begin_function_decl
specifier|static
name|struct
name|pci_devemu
modifier|*
name|pci_emul_finddev
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_lintr_route
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_lintr_update
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_cfgrw
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|coff
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|CFGWRITE
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|coff
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|1
condition|)
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|2
condition|)
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|pci_set_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|CFGREAD
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|coff
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|1
condition|)
return|return
operator|(
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|2
condition|)
return|return
operator|(
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|pci_get_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * I/O access  */
end_comment

begin_comment
comment|/*  * Slot options are in the form:  *  *<bus>:<slot>:<func>,<emul>[,<config>]  *<slot>[:<func>],<emul>[,<config>]  *  *  slot is 0..31  *  func is 0..7  *  emul is a string describing the type of PCI device e.g. virtio-net  *  config is an optional string, depending on the device, that can be  *  used for configuration.  *   Examples are:  *     1,virtio-net,tap0  *     3:0,dummy  */
end_comment

begin_function
specifier|static
name|void
name|pci_parse_slot_usage
parameter_list|(
name|char
modifier|*
name|aopt
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid PCI slot info field \"%s\"\n"
argument_list|,
name|aopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_parse_slot
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|char
modifier|*
name|emul
decl_stmt|,
modifier|*
name|config
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|bnum
decl_stmt|,
name|snum
decl_stmt|,
name|fnum
decl_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|str
operator|=
name|strdup
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|emul
operator|=
name|config
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|emul
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|emul
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|config
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|pci_parse_slot_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*<bus>:<slot>:<func> */
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%d:%d:%d"
argument_list|,
operator|&
name|bnum
argument_list|,
operator|&
name|snum
argument_list|,
operator|&
name|fnum
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|bnum
operator|=
literal|0
expr_stmt|;
comment|/*<slot>:<func> */
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%d:%d"
argument_list|,
operator|&
name|snum
argument_list|,
operator|&
name|fnum
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fnum
operator|=
literal|0
expr_stmt|;
comment|/*<slot> */
if|if
condition|(
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|snum
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|snum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bnum
operator|<
literal|0
operator|||
name|bnum
operator|>=
name|MAXBUSES
operator|||
name|snum
operator|<
literal|0
operator|||
name|snum
operator|>=
name|MAXSLOTS
operator|||
name|fnum
operator|<
literal|0
operator|||
name|fnum
operator|>=
name|MAXFUNCS
condition|)
block|{
name|pci_parse_slot_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|pci_businfo
index|[
name|bnum
index|]
operator|==
name|NULL
condition|)
name|pci_businfo
index|[
name|bnum
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|businfo
argument_list|)
argument_list|)
expr_stmt|;
name|bi
operator|=
name|pci_businfo
index|[
name|bnum
index|]
expr_stmt|;
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|snum
index|]
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_funcs
index|[
name|fnum
index|]
operator|.
name|fi_name
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pci slot %d:%d already occupied!\n"
argument_list|,
name|snum
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|pci_emul_finddev
argument_list|(
name|emul
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pci slot %d:%d: unknown device \"%s\"\n"
argument_list|,
name|snum
argument_list|,
name|fnum
argument_list|,
name|emul
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|si_funcs
index|[
name|fnum
index|]
operator|.
name|fi_name
operator|=
name|emul
expr_stmt|;
name|si
operator|->
name|si_funcs
index|[
name|fnum
index|]
operator|.
name|fi_param
operator|=
name|config
expr_stmt|;
name|done
label|:
if|if
condition|(
name|error
condition|)
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_valid_pba_offset
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|<
name|pi
operator|->
name|pi_msix
operator|.
name|pba_offset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|pi
operator|->
name|pi_msix
operator|.
name|pba_offset
operator|+
name|pi
operator|->
name|pi_msix
operator|.
name|pba_size
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_emul_msix_twrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|msix_entry_offset
decl_stmt|;
name|int
name|tab_index
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* support only 4 or 8 byte writes */
if|if
condition|(
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Return if table index is beyond what device supports 	 */
name|tab_index
operator|=
name|offset
operator|/
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|tab_index
operator|>=
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|msix_entry_offset
operator|=
name|offset
operator|%
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
comment|/* support only aligned writes */
if|if
condition|(
operator|(
name|msix_entry_offset
operator|%
name|size
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|+
name|tab_index
operator|)
expr_stmt|;
name|dest
operator|+=
name|msix_entry_offset
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dest
operator|)
operator|=
name|value
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dest
operator|)
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|pci_emul_msix_tread
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|msix_entry_offset
decl_stmt|;
name|int
name|tab_index
decl_stmt|;
name|uint64_t
name|retval
init|=
operator|~
literal|0
decl_stmt|;
comment|/* 	 * The PCI standard only allows 4 and 8 byte accesses to the MSI-X 	 * table but we also allow 1 byte access to accommodate reads from 	 * ddb. 	 */
if|if
condition|(
name|size
operator|!=
literal|1
operator|&&
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|msix_entry_offset
operator|=
name|offset
operator|%
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
comment|/* support only aligned reads */
if|if
condition|(
operator|(
name|msix_entry_offset
operator|%
name|size
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|tab_index
operator|=
name|offset
operator|/
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|tab_index
operator|<
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
condition|)
block|{
comment|/* valid MSI-X Table access */
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|+
name|tab_index
operator|)
expr_stmt|;
name|dest
operator|+=
name|msix_entry_offset
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|retval
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|dest
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|retval
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dest
operator|)
expr_stmt|;
else|else
name|retval
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dest
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_valid_pba_offset
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
condition|)
block|{
comment|/* return 0 for PBA access */
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_table_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|table_bar
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_pba_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|pba_bar
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_io_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
init|=
name|arg
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
init|=
name|pdi
operator|->
name|pi_d
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PCI_BARMAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PCIBAR_IO
operator|&&
name|port
operator|>=
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
operator|&&
name|port
operator|+
name|bytes
operator|<=
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
name|offset
operator|=
name|port
operator|-
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
call|(
modifier|*
name|pe
operator|->
name|pe_barread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|pe
operator|->
name|pe_barwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_mem_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|dir
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|long
name|arg2
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
init|=
name|arg1
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
init|=
name|pdi
operator|->
name|pi_d
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|bidx
init|=
operator|(
name|int
operator|)
name|arg2
decl_stmt|;
name|assert
argument_list|(
name|bidx
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|type
operator|==
name|PCIBAR_MEM32
operator|||
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|type
operator|==
name|PCIBAR_MEM64
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|addr
operator|>=
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|addr
operator|&&
name|addr
operator|+
name|size
operator|<=
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|addr
operator|+
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|offset
operator|=
name|addr
operator|-
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|MEM_F_WRITE
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
call|(
modifier|*
name|pe
operator|->
name|pe_barwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|,
operator|*
name|val
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pe
operator|->
name|pe_barwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
operator|*
name|val
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|pe
operator|->
name|pe_barwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
operator|*
name|val
operator|=
call|(
modifier|*
name|pe
operator|->
name|pe_barread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|val
operator||=
call|(
modifier|*
name|pe
operator|->
name|pe_barread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|<<
literal|32
expr_stmt|;
block|}
else|else
block|{
operator|*
name|val
operator|=
call|(
modifier|*
name|pe
operator|->
name|pe_barread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_alloc_resource
parameter_list|(
name|uint64_t
modifier|*
name|baseptr
parameter_list|,
name|uint64_t
name|limit
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint64_t
name|base
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* must be a power of 2 */
name|base
operator|=
name|roundup2
argument_list|(
operator|*
name|baseptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|size
operator|<=
name|limit
condition|)
block|{
operator|*
name|addr
operator|=
name|base
expr_stmt|;
operator|*
name|baseptr
operator|=
name|base
operator|+
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_emul_alloc_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pdi
parameter_list|,
name|int
name|idx
parameter_list|,
name|enum
name|pcibar_type
name|type
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|pci_emul_alloc_pbar
argument_list|(
name|pdi
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register (or unregister) the MMIO or I/O region associated with the BAR  * register 'idx' of an emulated pci device.  */
end_comment

begin_function
specifier|static
name|void
name|modify_bar_registration
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|registration
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|inout_port
name|iop
decl_stmt|;
name|struct
name|mem_range
name|mr
decl_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_IO
case|:
name|bzero
argument_list|(
operator|&
name|iop
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inout_port
argument_list|)
argument_list|)
expr_stmt|;
name|iop
operator|.
name|name
operator|=
name|pi
operator|->
name|pi_name
expr_stmt|;
name|iop
operator|.
name|port
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
expr_stmt|;
name|iop
operator|.
name|size
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|registration
condition|)
block|{
name|iop
operator|.
name|flags
operator|=
name|IOPORT_F_INOUT
expr_stmt|;
name|iop
operator|.
name|handler
operator|=
name|pci_emul_io_handler
expr_stmt|;
name|iop
operator|.
name|arg
operator|=
name|pi
expr_stmt|;
name|error
operator|=
name|register_inout
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|unregister_inout
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM32
case|:
case|case
name|PCIBAR_MEM64
case|:
name|bzero
argument_list|(
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_range
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|name
operator|=
name|pi
operator|->
name|pi_name
expr_stmt|;
name|mr
operator|.
name|base
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
expr_stmt|;
name|mr
operator|.
name|size
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|registration
condition|)
block|{
name|mr
operator|.
name|flags
operator|=
name|MEM_F_RW
expr_stmt|;
name|mr
operator|.
name|handler
operator|=
name|pci_emul_mem_handler
expr_stmt|;
name|mr
operator|.
name|arg1
operator|=
name|pi
expr_stmt|;
name|mr
operator|.
name|arg2
operator|=
name|idx
expr_stmt|;
name|error
operator|=
name|register_mem
argument_list|(
operator|&
name|mr
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|unregister_mem
argument_list|(
operator|&
name|mr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unregister_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|modify_bar_registration
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|register_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|modify_bar_registration
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Are we decoding i/o port accesses for the emulated pci device? */
end_comment

begin_function
specifier|static
name|int
name|porten
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|uint16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|&
name|PCIM_CMD_PORTEN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Are we decoding memory accesses for the emulated pci device? */
end_comment

begin_function
specifier|static
name|int
name|memen
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|uint16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the MMIO or I/O address that is decoded by the BAR register.  *  * If the pci device has enabled the address space decoding then intercept  * the address range decoded by the BAR register.  */
end_comment

begin_function
specifier|static
name|void
name|update_bar_address
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|decode
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
operator|==
name|PCIBAR_IO
condition|)
name|decode
operator|=
name|porten
argument_list|(
name|pi
argument_list|)
expr_stmt|;
else|else
name|decode
operator|=
name|memen
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
condition|)
name|unregister_bar
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCIBAR_IO
case|:
case|case
name|PCIBAR_MEM32
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM64
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|&=
operator|~
literal|0xffffffffUL
expr_stmt|;
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator||=
name|addr
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEMHI64
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|&=
literal|0xffffffff
expr_stmt|;
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator||=
name|addr
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decode
condition|)
name|register_bar
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_alloc_pbar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pdi
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint64_t
name|hostbase
parameter_list|,
name|enum
name|pcibar_type
name|type
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
modifier|*
name|baseptr
decl_stmt|,
name|limit
decl_stmt|,
name|addr
decl_stmt|,
name|mask
decl_stmt|,
name|lobits
decl_stmt|,
name|bar
decl_stmt|;
name|assert
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
literal|1UL
operator|<<
name|flsl
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* round up to a power of 2 */
comment|/* Enforce minimum BAR sizes required by the PCI standard */
if|if
condition|(
name|type
operator|==
name|PCIBAR_IO
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|4
condition|)
name|size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
literal|16
condition|)
name|size
operator|=
literal|16
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
name|baseptr
operator|=
name|NULL
expr_stmt|;
name|addr
operator|=
name|mask
operator|=
name|lobits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCIBAR_IO
case|:
name|baseptr
operator|=
operator|&
name|pci_emul_iobase
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_IOLIMIT
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_IO_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_IO_SPACE
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM64
case|:
comment|/* 		 * XXX 		 * Some drivers do not work well if the 64-bit BAR is allocated 		 * above 4GB. Allow for this by allocating small requests under 		 * 4GB unless then allocation size is larger than some arbitrary 		 * number (32MB currently). 		 */
if|if
condition|(
name|size
operator|>
literal|32
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
comment|/* 			 * XXX special case for device requiring peer-peer DMA 			 */
if|if
condition|(
name|size
operator|==
literal|0x100000000UL
condition|)
name|baseptr
operator|=
operator|&
name|hostbase
expr_stmt|;
else|else
name|baseptr
operator|=
operator|&
name|pci_emul_membase64
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT64
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
operator||
name|PCIM_BAR_MEM_PREFETCH
expr_stmt|;
break|break;
block|}
else|else
block|{
name|baseptr
operator|=
operator|&
name|pci_emul_membase32
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT32
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM32
case|:
name|baseptr
operator|=
operator|&
name|pci_emul_membase32
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT32
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_32
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"pci_emul_alloc_base: invalid bar type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseptr
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|pci_emul_alloc_resource
argument_list|(
name|baseptr
argument_list|,
name|limit
argument_list|,
name|size
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
comment|/* Initialize the BAR register in config space */
name|bar
operator|=
operator|(
name|addr
operator|&
name|mask
operator|)
operator||
name|lobits
expr_stmt|;
name|pci_set_cfgdata32
argument_list|(
name|pdi
argument_list|,
name|PCIR_BAR
argument_list|(
name|idx
argument_list|)
argument_list|,
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PCIBAR_MEM64
condition|)
block|{
name|assert
argument_list|(
name|idx
operator|+
literal|1
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|type
operator|=
name|PCIBAR_MEMHI64
expr_stmt|;
name|pci_set_cfgdata32
argument_list|(
name|pdi
argument_list|,
name|PCIR_BAR
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
name|bar
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|register_bar
argument_list|(
name|pdi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CAP_START_OFFSET
value|0x40
end_define

begin_function
specifier|static
name|int
name|pci_emul_add_capability
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|u_char
modifier|*
name|capdata
parameter_list|,
name|int
name|caplen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|capoff
decl_stmt|,
name|reallen
decl_stmt|;
name|uint16_t
name|sts
decl_stmt|;
name|assert
argument_list|(
name|caplen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reallen
operator|=
name|roundup2
argument_list|(
name|caplen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* dword aligned */
name|sts
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|==
literal|0
condition|)
name|capoff
operator|=
name|CAP_START_OFFSET
expr_stmt|;
else|else
name|capoff
operator|=
name|pi
operator|->
name|pi_capend
operator|+
literal|1
expr_stmt|;
comment|/* Check if we have enough space */
if|if
condition|(
name|capoff
operator|+
name|reallen
operator|>
name|PCI_REGMAX
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Set the previous capability pointer */
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|==
literal|0
condition|)
block|{
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|,
name|sts
operator||
name|PCIM_STATUS_CAPPRESENT
argument_list|)
expr_stmt|;
block|}
else|else
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|pi_prevcap
operator|+
literal|1
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
comment|/* Copy the capability */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|caplen
condition|;
name|i
operator|++
control|)
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
name|i
argument_list|,
name|capdata
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set the next capability pointer */
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_prevcap
operator|=
name|capoff
expr_stmt|;
name|pi
operator|->
name|pi_capend
operator|=
name|capoff
operator|+
name|reallen
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_devemu
modifier|*
name|pci_emul_finddev
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|pci_devemu
modifier|*
modifier|*
name|pdpp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|pdpp
argument_list|,
argument|pci_devemu_set
argument_list|)
block|{
name|pdp
operator|=
operator|*
name|pdpp
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pdp
operator|->
name|pe_emu
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|pdp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_init
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devemu
modifier|*
name|pde
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|struct
name|funcinfo
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|pdi
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinst
argument_list|)
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_vmctx
operator|=
name|ctx
expr_stmt|;
name|pdi
operator|->
name|pi_bus
operator|=
name|bus
expr_stmt|;
name|pdi
operator|->
name|pi_slot
operator|=
name|slot
expr_stmt|;
name|pdi
operator|->
name|pi_func
operator|=
name|func
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|pdi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_lintr
operator|.
name|pin
operator|=
literal|0
expr_stmt|;
name|pdi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|IDLE
expr_stmt|;
name|pdi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|=
literal|0
expr_stmt|;
name|pdi
operator|->
name|pi_lintr
operator|.
name|ioapic_irq
operator|=
literal|0
expr_stmt|;
name|pdi
operator|->
name|pi_d
operator|=
name|pde
expr_stmt|;
name|snprintf
argument_list|(
name|pdi
operator|->
name|pi_name
argument_list|,
name|PI_NAMESZ
argument_list|,
literal|"%s-pci-%d"
argument_list|,
name|pde
operator|->
name|pe_emu
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Disable legacy interrupts */
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|pde
operator|->
name|pe_init
call|)
argument_list|(
name|ctx
argument_list|,
name|pdi
argument_list|,
name|fi
operator|->
name|fi_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|fi
operator|->
name|fi_devi
operator|=
name|pdi
expr_stmt|;
else|else
name|free
argument_list|(
name|pdi
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_populate_msicap
parameter_list|(
name|struct
name|msicap
modifier|*
name|msicap
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|nextptr
parameter_list|)
block|{
name|int
name|mmc
decl_stmt|;
comment|/* Number of msi messages must be a power of 2 between 1 and 32 */
name|assert
argument_list|(
operator|(
name|msgnum
operator|&
operator|(
name|msgnum
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|msgnum
operator|>=
literal|1
operator|&&
name|msgnum
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|mmc
operator|=
name|ffs
argument_list|(
name|msgnum
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|msicap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msicap
argument_list|)
argument_list|)
expr_stmt|;
name|msicap
operator|->
name|capid
operator|=
name|PCIY_MSI
expr_stmt|;
name|msicap
operator|->
name|nextptr
operator|=
name|nextptr
expr_stmt|;
name|msicap
operator|->
name|msgctrl
operator|=
name|PCIM_MSICTRL_64BIT
operator||
operator|(
name|mmc
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_add_msicap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msgnum
parameter_list|)
block|{
name|struct
name|msicap
name|msicap
decl_stmt|;
name|pci_populate_msicap
argument_list|(
operator|&
name|msicap
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msicap
argument_list|,
sizeof|sizeof
argument_list|(
name|msicap
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_populate_msixcap
parameter_list|(
name|struct
name|msixcap
modifier|*
name|msixcap
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|barnum
parameter_list|,
name|uint32_t
name|msix_tab_size
parameter_list|)
block|{
name|assert
argument_list|(
name|msix_tab_size
operator|%
literal|4096
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|msixcap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msixcap
argument_list|)
argument_list|)
expr_stmt|;
name|msixcap
operator|->
name|capid
operator|=
name|PCIY_MSIX
expr_stmt|;
comment|/* 	 * Message Control Register, all fields set to 	 * zero except for the Table Size. 	 * Note: Table size N is encoded as N-1 	 */
name|msixcap
operator|->
name|msgctrl
operator|=
name|msgnum
operator|-
literal|1
expr_stmt|;
comment|/* 	 * MSI-X BAR setup: 	 * - MSI-X table start at offset 0 	 * - PBA table starts at a 4K aligned offset after the MSI-X table 	 */
name|msixcap
operator|->
name|table_info
operator|=
name|barnum
operator|&
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
name|msixcap
operator|->
name|pba_info
operator|=
name|msix_tab_size
operator||
operator|(
name|barnum
operator|&
name|PCIM_MSIX_BIR_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_msix_table_init
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|table_entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|table_size
decl_stmt|;
name|assert
argument_list|(
name|table_entries
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|table_entries
operator|<=
name|MAX_MSIX_TABLE_ENTRIES
argument_list|)
expr_stmt|;
name|table_size
operator|=
name|table_entries
operator|*
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
comment|/* set mask bit of vector control register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_entries
condition|;
name|i
operator|++
control|)
name|pi
operator|->
name|pi_msix
operator|.
name|table
index|[
name|i
index|]
operator|.
name|vector_control
operator||=
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_add_msixcap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|barnum
parameter_list|)
block|{
name|uint32_t
name|tab_size
decl_stmt|;
name|struct
name|msixcap
name|msixcap
decl_stmt|;
name|assert
argument_list|(
name|msgnum
operator|>=
literal|1
operator|&&
name|msgnum
operator|<=
name|MAX_MSIX_TABLE_ENTRIES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|barnum
operator|>=
literal|0
operator|&&
name|barnum
operator|<=
name|PCIR_MAX_BAR_0
argument_list|)
expr_stmt|;
name|tab_size
operator|=
name|msgnum
operator|*
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
comment|/* Align table size to nearest 4K */
name|tab_size
operator|=
name|roundup2
argument_list|(
name|tab_size
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table_bar
operator|=
name|barnum
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|pba_bar
operator|=
name|barnum
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table_offset
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
operator|=
name|msgnum
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|pba_offset
operator|=
name|tab_size
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|pba_size
operator|=
name|PBA_SIZE
argument_list|(
name|msgnum
argument_list|)
expr_stmt|;
name|pci_msix_table_init
argument_list|(
name|pi
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
name|pci_populate_msixcap
argument_list|(
operator|&
name|msixcap
argument_list|,
name|msgnum
argument_list|,
name|barnum
argument_list|,
name|tab_size
argument_list|)
expr_stmt|;
comment|/* allocate memory for MSI-X Table and PBA */
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
name|barnum
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|tab_size
operator|+
name|pi
operator|->
name|pi_msix
operator|.
name|pba_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msixcap
argument_list|,
sizeof|sizeof
argument_list|(
name|msixcap
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|msixcap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint16_t
name|msgctrl
decl_stmt|,
name|rwmask
decl_stmt|;
name|int
name|off
decl_stmt|;
name|off
operator|=
name|offset
operator|-
name|capoff
expr_stmt|;
comment|/* Message Control Register */
if|if
condition|(
name|off
operator|==
literal|2
operator|&&
name|bytes
operator|==
literal|2
condition|)
block|{
name|rwmask
operator|=
name|PCIM_MSIXCTRL_MSIX_ENABLE
operator||
name|PCIM_MSIXCTRL_FUNCTION_MASK
expr_stmt|;
name|msgctrl
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|msgctrl
operator|&=
operator|~
name|rwmask
expr_stmt|;
name|msgctrl
operator||=
name|val
operator|&
name|rwmask
expr_stmt|;
name|val
operator|=
name|msgctrl
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|enabled
operator|=
name|val
operator|&
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|function_mask
operator|=
name|val
operator|&
name|PCIM_MSIXCTRL_FUNCTION_MASK
expr_stmt|;
name|pci_lintr_update
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msicap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint16_t
name|msgctrl
decl_stmt|,
name|rwmask
decl_stmt|,
name|msgdata
decl_stmt|,
name|mme
decl_stmt|;
name|uint32_t
name|addrlo
decl_stmt|;
comment|/* 	 * If guest is writing to the message control register make sure 	 * we do not overwrite read-only fields. 	 */
if|if
condition|(
operator|(
name|offset
operator|-
name|capoff
operator|)
operator|==
literal|2
operator|&&
name|bytes
operator|==
literal|2
condition|)
block|{
name|rwmask
operator|=
name|PCIM_MSICTRL_MME_MASK
operator||
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|msgctrl
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|msgctrl
operator|&=
operator|~
name|rwmask
expr_stmt|;
name|msgctrl
operator||=
name|val
operator|&
name|rwmask
expr_stmt|;
name|val
operator|=
name|msgctrl
expr_stmt|;
name|addrlo
operator|=
name|pci_get_cfgdata32
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
name|msgdata
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|12
argument_list|)
expr_stmt|;
else|else
name|msgdata
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|8
argument_list|)
expr_stmt|;
name|mme
operator|=
name|msgctrl
operator|&
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|=
name|msgctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
condition|)
block|{
name|pi
operator|->
name|pi_msi
operator|.
name|addr
operator|=
name|addrlo
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|msg_data
operator|=
name|msgdata
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|maxmsgnum
operator|=
literal|1
operator|<<
operator|(
name|mme
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|pi_msi
operator|.
name|maxmsgnum
operator|=
literal|0
expr_stmt|;
block|}
name|pci_lintr_update
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pciecap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
comment|/* XXX don't write to the readonly parts */
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PCIECAP_VERSION
value|0x2
end_define

begin_function
name|int
name|pci_emul_add_pciecap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|pciecap
name|pciecap
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|PCIEM_TYPE_ROOT_PORT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|pciecap
argument_list|,
sizeof|sizeof
argument_list|(
name|pciecap
argument_list|)
argument_list|)
expr_stmt|;
name|pciecap
operator|.
name|capid
operator|=
name|PCIY_EXPRESS
expr_stmt|;
name|pciecap
operator|.
name|pcie_capabilities
operator|=
name|PCIECAP_VERSION
operator||
name|PCIEM_TYPE_ROOT_PORT
expr_stmt|;
name|pciecap
operator|.
name|link_capabilities
operator|=
literal|0x411
expr_stmt|;
comment|/* gen1, x1 */
name|pciecap
operator|.
name|link_status
operator|=
literal|0x11
expr_stmt|;
comment|/* gen1, x1 */
name|err
operator|=
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pciecap
argument_list|,
sizeof|sizeof
argument_list|(
name|pciecap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function assumes that 'coff' is in the capabilities region of the  * config space.  */
end_comment

begin_function
specifier|static
name|void
name|pci_emul_capwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|capid
decl_stmt|;
name|uint8_t
name|capoff
decl_stmt|,
name|nextoff
decl_stmt|;
comment|/* Do not allow un-aligned writes */
if|if
condition|(
operator|(
name|offset
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Find the capability that we want to update */
name|capoff
operator|=
name|CAP_START_OFFSET
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|nextoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextoff
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|offset
operator|>=
name|capoff
operator|&&
name|offset
operator|<
name|nextoff
condition|)
break|break;
name|capoff
operator|=
name|nextoff
expr_stmt|;
block|}
name|assert
argument_list|(
name|offset
operator|>=
name|capoff
argument_list|)
expr_stmt|;
comment|/* 	 * Capability ID and Next Capability Pointer are readonly. 	 * However, some o/s's do 4-byte writes that include these. 	 * For this case, trim the write back to 2 bytes and adjust 	 * the data. 	 */
if|if
condition|(
name|offset
operator|==
name|capoff
operator|||
name|offset
operator|==
name|capoff
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|offset
operator|==
name|capoff
operator|&&
name|bytes
operator|==
literal|4
condition|)
block|{
name|bytes
operator|=
literal|2
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|val
operator|>>=
literal|16
expr_stmt|;
block|}
else|else
return|return;
block|}
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|capid
condition|)
block|{
case|case
name|PCIY_MSI
case|:
name|msicap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIY_MSIX
case|:
name|msixcap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIY_EXPRESS
case|:
name|pciecap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_iscap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|uint16_t
name|sts
decl_stmt|;
name|sts
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|>=
name|CAP_START_OFFSET
operator|&&
name|offset
operator|<=
name|pi
operator|->
name|pi_capend
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_fallback_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|dir
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|long
name|arg2
parameter_list|)
block|{
comment|/* 	 * Ignore writes; return 0xff's for reads. The mem read code 	 * will take care of truncating to the correct size. 	 */
if|if
condition|(
name|dir
operator|==
name|MEM_F_READ
condition|)
block|{
operator|*
name|val
operator|=
literal|0xffffffffffffffff
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_ecfg_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|dir
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|long
name|arg2
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|,
name|coff
decl_stmt|,
name|in
decl_stmt|;
name|coff
operator|=
name|addr
operator|&
literal|0xfff
expr_stmt|;
name|func
operator|=
operator|(
name|addr
operator|>>
literal|12
operator|)
operator|&
literal|0x7
expr_stmt|;
name|slot
operator|=
operator|(
name|addr
operator|>>
literal|15
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bus
operator|=
operator|(
name|addr
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
name|in
operator|=
operator|(
name|dir
operator|==
name|MEM_F_READ
operator|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
operator|*
name|val
operator|=
operator|~
literal|0UL
expr_stmt|;
name|pci_cfgrw
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|in
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|pci_ecfg_base
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|PCI_EMUL_ECFG_BASE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUSIO_ROUNDUP
value|32
end_define

begin_define
define|#
directive|define
name|BUSMEM_ROUNDUP
value|(1024 * 1024)
end_define

begin_function
name|int
name|init_pci
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|mem_range
name|mr
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pde
decl_stmt|;
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|fi
decl_stmt|;
name|size_t
name|lowmem
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pci_emul_iobase
operator|=
name|PCI_EMUL_IOBASE
expr_stmt|;
name|pci_emul_membase32
operator|=
name|vm_get_lowmem_limit
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|pci_emul_membase64
operator|=
name|PCI_EMUL_MEMBASE64
expr_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|MAXBUSES
condition|;
name|bus
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bi
operator|=
name|pci_businfo
index|[
name|bus
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/*  		 * Keep track of the i/o and memory resources allocated to 		 * this bus. 		 */
name|bi
operator|->
name|iobase
operator|=
name|pci_emul_iobase
expr_stmt|;
name|bi
operator|->
name|membase32
operator|=
name|pci_emul_membase32
expr_stmt|;
name|bi
operator|->
name|membase64
operator|=
name|pci_emul_membase64
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXSLOTS
condition|;
name|slot
operator|++
control|)
block|{
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<
name|MAXFUNCS
condition|;
name|func
operator|++
control|)
block|{
name|fi
operator|=
operator|&
name|si
operator|->
name|si_funcs
index|[
name|func
index|]
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_name
operator|==
name|NULL
condition|)
continue|continue;
name|pde
operator|=
name|pci_emul_finddev
argument_list|(
name|fi
operator|->
name|fi_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_init
argument_list|(
name|ctx
argument_list|,
name|pde
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 		 * Add some slop to the I/O and memory resources decoded by 		 * this bus to give a guest some flexibility if it wants to 		 * reprogram the BARs. 		 */
name|pci_emul_iobase
operator|+=
name|BUSIO_ROUNDUP
expr_stmt|;
name|pci_emul_iobase
operator|=
name|roundup2
argument_list|(
name|pci_emul_iobase
argument_list|,
name|BUSIO_ROUNDUP
argument_list|)
expr_stmt|;
name|bi
operator|->
name|iolimit
operator|=
name|pci_emul_iobase
expr_stmt|;
name|pci_emul_membase32
operator|+=
name|BUSMEM_ROUNDUP
expr_stmt|;
name|pci_emul_membase32
operator|=
name|roundup2
argument_list|(
name|pci_emul_membase32
argument_list|,
name|BUSMEM_ROUNDUP
argument_list|)
expr_stmt|;
name|bi
operator|->
name|memlimit32
operator|=
name|pci_emul_membase32
expr_stmt|;
name|pci_emul_membase64
operator|+=
name|BUSMEM_ROUNDUP
expr_stmt|;
name|pci_emul_membase64
operator|=
name|roundup2
argument_list|(
name|pci_emul_membase64
argument_list|,
name|BUSMEM_ROUNDUP
argument_list|)
expr_stmt|;
name|bi
operator|->
name|memlimit64
operator|=
name|pci_emul_membase64
expr_stmt|;
block|}
comment|/* 	 * PCI backends are initialized before routing INTx interrupts 	 * so that LPC devices are able to reserve ISA IRQs before 	 * routing PIRQ pins. 	 */
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|MAXBUSES
condition|;
name|bus
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bi
operator|=
name|pci_businfo
index|[
name|bus
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXSLOTS
condition|;
name|slot
operator|++
control|)
block|{
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<
name|MAXFUNCS
condition|;
name|func
operator|++
control|)
block|{
name|fi
operator|=
operator|&
name|si
operator|->
name|si_funcs
index|[
name|func
index|]
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_devi
operator|==
name|NULL
condition|)
continue|continue;
name|pci_lintr_route
argument_list|(
name|fi
operator|->
name|fi_devi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lpc_pirq_routed
argument_list|()
expr_stmt|;
comment|/* 	 * The guest physical memory map looks like the following: 	 * [0,		    lowmem)		guest system memory 	 * [lowmem,	    lowmem_limit)	memory hole (may be absent) 	 * [lowmem_limit,   0xE0000000)		PCI hole (32-bit BAR allocation) 	 * [0xE0000000,	    0xF0000000)		PCI extended config window 	 * [0xF0000000,	    4GB)		LAPIC, IOAPIC, HPET, firmware 	 * [4GB,	    4GB + highmem) 	 */
comment|/* 	 * Accesses to memory addresses that are not allocated to system 	 * memory or PCI devices return 0xff's. 	 */
name|lowmem
operator|=
name|vm_get_lowmem_size
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_range
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|name
operator|=
literal|"PCI hole"
expr_stmt|;
name|mr
operator|.
name|flags
operator|=
name|MEM_F_RW
operator||
name|MEM_F_IMMUTABLE
expr_stmt|;
name|mr
operator|.
name|base
operator|=
name|lowmem
expr_stmt|;
name|mr
operator|.
name|size
operator|=
operator|(
literal|4ULL
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|)
operator|-
name|lowmem
expr_stmt|;
name|mr
operator|.
name|handler
operator|=
name|pci_emul_fallback_handler
expr_stmt|;
name|error
operator|=
name|register_mem_fallback
argument_list|(
operator|&
name|mr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* PCI extended config space */
name|bzero
argument_list|(
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_range
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|name
operator|=
literal|"PCI ECFG"
expr_stmt|;
name|mr
operator|.
name|flags
operator|=
name|MEM_F_RW
operator||
name|MEM_F_IMMUTABLE
expr_stmt|;
name|mr
operator|.
name|base
operator|=
name|PCI_EMUL_ECFG_BASE
expr_stmt|;
name|mr
operator|.
name|size
operator|=
name|PCI_EMUL_ECFG_SIZE
expr_stmt|;
name|mr
operator|.
name|handler
operator|=
name|pci_emul_ecfg_handler
expr_stmt|;
name|error
operator|=
name|register_mem
argument_list|(
operator|&
name|mr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_apic_prt_entry
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|pin
parameter_list|,
name|int
name|pirq_pin
parameter_list|,
name|int
name|ioapic_irq
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsdt_line
argument_list|(
literal|"  Package ()"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    0x%X,"
argument_list|,
name|slot
operator|<<
literal|16
operator||
literal|0xffff
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    0x%02X,"
argument_list|,
name|pin
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Zero,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    0x%X"
argument_list|,
name|ioapic_irq
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  },"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_pirq_prt_entry
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|pin
parameter_list|,
name|int
name|pirq_pin
parameter_list|,
name|int
name|ioapic_irq
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|lpc_pirq_name
argument_list|(
name|pirq_pin
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return;
name|dsdt_line
argument_list|(
literal|"  Package ()"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    0x%X,"
argument_list|,
name|slot
operator|<<
literal|16
operator||
literal|0xffff
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    0x%02X,"
argument_list|,
name|pin
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    %s,"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    0x00"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  },"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A bhyve virtual machine has a flat PCI hierarchy with a root port  * corresponding to each PCI bus.  */
end_comment

begin_function
specifier|static
name|void
name|pci_bus_write_dsdt
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|struct
name|pci_devinst
modifier|*
name|pi
decl_stmt|;
name|int
name|count
decl_stmt|,
name|func
decl_stmt|,
name|slot
decl_stmt|;
comment|/* 	 * If there are no devices on this 'bus' then just return. 	 */
if|if
condition|(
operator|(
name|bi
operator|=
name|pci_businfo
index|[
name|bus
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Bus 0 is special because it decodes the I/O ports used 		 * for PCI config space access even if there are no devices 		 * on it. 		 */
if|if
condition|(
name|bus
operator|!=
literal|0
condition|)
return|return;
block|}
name|dsdt_line
argument_list|(
literal|"  Device (PC%02X)"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Name (_HID, EisaId (\"PNP0A03\"))"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Name (_ADR, Zero)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Method (_BBN, 0, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        Return (0x%08X)"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Name (_CRS, ResourceTemplate ()"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      WordBusNumber (ResourceProducer, MinFixed, "
literal|"MaxFixed, PosDecode,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Granularity"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Range Minimum"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Range Maximum"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Translation Offset"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0001,             // Length"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        ,, )"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|==
literal|0
condition|)
block|{
name|dsdt_indent
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|dsdt_fixed_ioport
argument_list|(
literal|0xCF8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|dsdt_unindent
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      WordIO (ResourceProducer, MinFixed, MaxFixed, "
literal|"PosDecode, EntireRange,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Granularity"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Range Minimum"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0CF7,             // Range Maximum"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Translation Offset"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0CF8,             // Length"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        ,, , TypeStatic)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"      WordIO (ResourceProducer, MinFixed, MaxFixed, "
literal|"PosDecode, EntireRange,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Granularity"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0D00,             // Range Minimum"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Range Maximum"
argument_list|,
name|PCI_EMUL_IOBASE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Translation Offset"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Length"
argument_list|,
name|PCI_EMUL_IOBASE
operator|-
literal|0x0D00
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        ,, , TypeStatic)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bi
operator|==
name|NULL
condition|)
block|{
name|dsdt_line
argument_list|(
literal|"    })"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|assert
argument_list|(
name|bi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* i/o window */
name|dsdt_line
argument_list|(
literal|"      WordIO (ResourceProducer, MinFixed, MaxFixed, "
literal|"PosDecode, EntireRange,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Granularity"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Range Minimum"
argument_list|,
name|bi
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Range Maximum"
argument_list|,
name|bi
operator|->
name|iolimit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000,             // Translation Offset"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%04X,             // Length"
argument_list|,
name|bi
operator|->
name|iolimit
operator|-
name|bi
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        ,, , TypeStatic)"
argument_list|)
expr_stmt|;
comment|/* mmio window (32-bit) */
name|dsdt_line
argument_list|(
literal|"      DWordMemory (ResourceProducer, PosDecode, "
literal|"MinFixed, MaxFixed, NonCacheable, ReadWrite,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x00000000,         // Granularity"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%08X,         // Range Minimum\n"
argument_list|,
name|bi
operator|->
name|membase32
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%08X,         // Range Maximum\n"
argument_list|,
name|bi
operator|->
name|memlimit32
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x00000000,         // Translation Offset"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%08X,         // Length\n"
argument_list|,
name|bi
operator|->
name|memlimit32
operator|-
name|bi
operator|->
name|membase32
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        ,, , AddressRangeMemory, TypeStatic)"
argument_list|)
expr_stmt|;
comment|/* mmio window (64-bit) */
name|dsdt_line
argument_list|(
literal|"      QWordMemory (ResourceProducer, PosDecode, "
literal|"MinFixed, MaxFixed, NonCacheable, ReadWrite,"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000000000000000, // Granularity"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%016lX, // Range Minimum\n"
argument_list|,
name|bi
operator|->
name|membase64
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%016lX, // Range Maximum\n"
argument_list|,
name|bi
operator|->
name|memlimit64
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x0000000000000000, // Translation Offset"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        0x%016lX, // Length\n"
argument_list|,
name|bi
operator|->
name|memlimit64
operator|-
name|bi
operator|->
name|membase64
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"        ,, , AddressRangeMemory, TypeStatic)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    })"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pci_count_lintr
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|dsdt_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Name (PPRT, Package ()"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|pci_walk_lintr
argument_list|(
name|bus
argument_list|,
name|pci_pirq_prt_entry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"})"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Name (APRT, Package ()"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|pci_walk_lintr
argument_list|(
name|bus
argument_list|,
name|pci_apic_prt_entry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"})"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Method (_PRT, 0, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  If (PICM)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (APRT)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Else"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  {"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"    Return (PPRT)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|dsdt_unindent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|dsdt_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXSLOTS
condition|;
name|slot
operator|++
control|)
block|{
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<
name|MAXFUNCS
condition|;
name|func
operator|++
control|)
block|{
name|pi
operator|=
name|si
operator|->
name|si_funcs
index|[
name|func
index|]
operator|.
name|fi_devi
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|pi_d
operator|->
name|pe_write_dsdt
operator|!=
name|NULL
condition|)
name|pi
operator|->
name|pi_d
operator|->
name|pe_write_dsdt
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
name|dsdt_unindent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|done
label|:
name|dsdt_line
argument_list|(
literal|"  }"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_write_dsdt
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|bus
decl_stmt|;
name|dsdt_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Name (PICM, 0x00)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Method (_PIC, 1, NotSerialized)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"  Store (Arg0, PICM)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"Scope (_SB)"
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|MAXBUSES
condition|;
name|bus
operator|++
control|)
name|pci_bus_write_dsdt
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|dsdt_line
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|dsdt_unindent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_bus_configured
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|assert
argument_list|(
name|bus
operator|>=
literal|0
operator|&&
name|bus
operator|<
name|MAXBUSES
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_businfo
index|[
name|bus
index|]
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msi_enabled
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msi_maxmsgnum
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|maxmsgnum
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_enabled
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|enabled
operator|&&
operator|!
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_generate_msix
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
if|if
condition|(
operator|!
name|pci_msix_enabled
argument_list|(
name|pi
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pi
operator|->
name|pi_msix
operator|.
name|function_mask
condition|)
return|return;
if|if
condition|(
name|index
operator|>=
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
condition|)
return|return;
name|mte
operator|=
operator|&
name|pi
operator|->
name|pi_msix
operator|.
name|table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|mte
operator|->
name|vector_control
operator|&
name|PCIM_MSIX_VCTRL_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX Set PBA bit if interrupt is disabled */
name|vm_lapic_msi
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|mte
operator|->
name|addr
argument_list|,
name|mte
operator|->
name|msg_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_generate_msi
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|pci_msi_enabled
argument_list|(
name|pi
argument_list|)
operator|&&
name|index
operator|<
name|pci_msi_maxmsgnum
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|vm_lapic_msi
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_msi
operator|.
name|addr
argument_list|,
name|pi
operator|->
name|pi_msi
operator|.
name|msg_data
operator|+
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|pci_lintr_permitted
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|uint16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|||
name|pi
operator|->
name|pi_msix
operator|.
name|enabled
operator|||
operator|(
name|cmd
operator|&
name|PCIM_CMD_INTxDIS
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_lintr_request
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|int
name|bestpin
decl_stmt|,
name|bestcount
decl_stmt|,
name|pin
decl_stmt|;
name|bi
operator|=
name|pci_businfo
index|[
name|pi
operator|->
name|pi_bus
index|]
expr_stmt|;
name|assert
argument_list|(
name|bi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Just allocate a pin from our slot.  The pin will be 	 * assigned IRQs later when interrupts are routed. 	 */
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|pi
operator|->
name|pi_slot
index|]
expr_stmt|;
name|bestpin
operator|=
literal|0
expr_stmt|;
name|bestcount
operator|=
name|si
operator|->
name|si_intpins
index|[
literal|0
index|]
operator|.
name|ii_count
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|1
init|;
name|pin
operator|<
literal|4
condition|;
name|pin
operator|++
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_intpins
index|[
name|pin
index|]
operator|.
name|ii_count
operator|<
name|bestcount
condition|)
block|{
name|bestpin
operator|=
name|pin
expr_stmt|;
name|bestcount
operator|=
name|si
operator|->
name|si_intpins
index|[
name|pin
index|]
operator|.
name|ii_count
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_intpins
index|[
name|bestpin
index|]
operator|.
name|ii_count
operator|++
expr_stmt|;
name|pi
operator|->
name|pi_lintr
operator|.
name|pin
operator|=
name|bestpin
operator|+
literal|1
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_INTPIN
argument_list|,
name|bestpin
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_lintr_route
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|intxinfo
modifier|*
name|ii
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pin
operator|==
literal|0
condition|)
return|return;
name|bi
operator|=
name|pci_businfo
index|[
name|pi
operator|->
name|pi_bus
index|]
expr_stmt|;
name|assert
argument_list|(
name|bi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ii
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|pi
operator|->
name|pi_slot
index|]
operator|.
name|si_intpins
index|[
name|pi
operator|->
name|pi_lintr
operator|.
name|pin
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 	 * Attempt to allocate an I/O APIC pin for this intpin if one 	 * is not yet assigned. 	 */
if|if
condition|(
name|ii
operator|->
name|ii_ioapic_irq
operator|==
literal|0
condition|)
name|ii
operator|->
name|ii_ioapic_irq
operator|=
name|ioapic_pci_alloc_irq
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ii
operator|->
name|ii_ioapic_irq
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to allocate a PIRQ pin for this intpin if one is 	 * not yet assigned. 	 */
if|if
condition|(
name|ii
operator|->
name|ii_pirq_pin
operator|==
literal|0
condition|)
name|ii
operator|->
name|ii_pirq_pin
operator|=
name|pirq_alloc_pin
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ii
operator|->
name|ii_pirq_pin
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_lintr
operator|.
name|ioapic_irq
operator|=
name|ii
operator|->
name|ii_ioapic_irq
expr_stmt|;
name|pi
operator|->
name|pi_lintr
operator|.
name|pirq_pin
operator|=
name|ii
operator|->
name|ii_pirq_pin
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|pirq_irq
argument_list|(
name|ii
operator|->
name|ii_pirq_pin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_lintr_assert
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|assert
argument_list|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pin
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|pi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|==
name|IDLE
condition|)
block|{
if|if
condition|(
name|pci_lintr_permitted
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|ASSERTED
expr_stmt|;
name|pci_irq_assert
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|PENDING
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_lintr_deassert
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|assert
argument_list|(
name|pi
operator|->
name|pi_lintr
operator|.
name|pin
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|pi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|==
name|ASSERTED
condition|)
block|{
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|IDLE
expr_stmt|;
name|pci_irq_deassert
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|==
name|PENDING
condition|)
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|IDLE
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_lintr_update
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|pi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|==
name|ASSERTED
operator|&&
operator|!
name|pci_lintr_permitted
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pci_irq_deassert
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|PENDING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|==
name|PENDING
operator|&&
name|pci_lintr_permitted
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|pi
operator|->
name|pi_lintr
operator|.
name|state
operator|=
name|ASSERTED
expr_stmt|;
name|pci_irq_assert
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|pi
operator|->
name|pi_lintr
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_count_lintr
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|slot
decl_stmt|,
name|pin
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|slotinfo
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_businfo
index|[
name|bus
index|]
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXSLOTS
condition|;
name|slot
operator|++
control|)
block|{
name|slotinfo
operator|=
operator|&
name|pci_businfo
index|[
name|bus
index|]
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|4
condition|;
name|pin
operator|++
control|)
block|{
if|if
condition|(
name|slotinfo
operator|->
name|si_intpins
index|[
name|pin
index|]
operator|.
name|ii_count
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_walk_lintr
parameter_list|(
name|int
name|bus
parameter_list|,
name|pci_lintr_cb
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|struct
name|intxinfo
modifier|*
name|ii
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|pin
decl_stmt|;
if|if
condition|(
operator|(
name|bi
operator|=
name|pci_businfo
index|[
name|bus
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXSLOTS
condition|;
name|slot
operator|++
control|)
block|{
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|4
condition|;
name|pin
operator|++
control|)
block|{
name|ii
operator|=
operator|&
name|si
operator|->
name|si_intpins
index|[
name|pin
index|]
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_count
operator|!=
literal|0
condition|)
name|cb
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|pin
operator|+
literal|1
argument_list|,
name|ii
operator|->
name|ii_pirq_pin
argument_list|,
name|ii
operator|->
name|ii_ioapic_irq
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return 1 if the emulated device in 'slot' is a multi-function device.  * Return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pci_emul_is_mfdev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|int
name|f
decl_stmt|,
name|numfuncs
decl_stmt|;
name|numfuncs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bi
operator|=
name|pci_businfo
index|[
name|bus
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|MAXFUNCS
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_funcs
index|[
name|f
index|]
operator|.
name|fi_devi
operator|!=
name|NULL
condition|)
block|{
name|numfuncs
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|numfuncs
operator|>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the PCIM_MFDEV bit is properly set (or unset) depending on  * whether or not is a multi-function being emulated in the pci 'slot'.  */
end_comment

begin_function
specifier|static
name|void
name|pci_emul_hdrtype_fixup
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|rv
parameter_list|)
block|{
name|int
name|mfdev
decl_stmt|;
if|if
condition|(
name|off
operator|<=
name|PCIR_HDRTYPE
operator|&&
name|off
operator|+
name|bytes
operator|>
name|PCIR_HDRTYPE
condition|)
block|{
name|mfdev
operator|=
name|pci_emul_is_mfdev
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
operator|*
name|rv
operator|&=
operator|~
name|PCIM_MFDEV
expr_stmt|;
if|if
condition|(
name|mfdev
condition|)
block|{
operator|*
name|rv
operator||=
name|PCIM_MFDEV
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
operator|*
name|rv
operator|&=
operator|~
operator|(
name|PCIM_MFDEV
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|mfdev
condition|)
block|{
operator|*
name|rv
operator||=
operator|(
name|PCIM_MFDEV
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pci_emul_cmdsts_write
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|coff
parameter_list|,
name|uint32_t
name|new
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rshift
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|,
name|cmd2
decl_stmt|,
name|changed
decl_stmt|,
name|old
decl_stmt|,
name|readonly
decl_stmt|;
name|cmd
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
comment|/* stash old value */
comment|/* 	 * From PCI Local Bus Specification 3.0 sections 6.2.2 and 6.2.3. 	 * 	 * XXX Bits 8, 11, 12, 13, 14 and 15 in the status register are 	 * 'write 1 to clear'. However these bits are not set to '1' by 	 * any device emulation so it is simpler to treat them as readonly. 	 */
name|rshift
operator|=
operator|(
name|coff
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
name|readonly
operator|=
literal|0xFFFFF880
operator|>>
name|rshift
expr_stmt|;
name|old
operator|=
name|CFGREAD
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|new
operator|&=
operator|~
name|readonly
expr_stmt|;
name|new
operator||=
operator|(
name|old
operator|&
name|readonly
operator|)
expr_stmt|;
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|new
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* update config */
name|cmd2
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
comment|/* get updated value */
name|changed
operator|=
name|cmd
operator|^
name|cmd2
expr_stmt|;
comment|/* 	 * If the MMIO or I/O address space decoding has changed then 	 * register/unregister all BARs that decode that address space. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PCI_BARMAX
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
case|case
name|PCIBAR_MEMHI64
case|:
break|break;
case|case
name|PCIBAR_IO
case|:
comment|/* I/O address space decoding changed? */
if|if
condition|(
name|changed
operator|&
name|PCIM_CMD_PORTEN
condition|)
block|{
if|if
condition|(
name|porten
argument_list|(
name|pi
argument_list|)
condition|)
name|register_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|unregister_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM32
case|:
case|case
name|PCIBAR_MEM64
case|:
comment|/* MMIO address space decoding changed? */
if|if
condition|(
name|changed
operator|&
name|PCIM_CMD_MEMEN
condition|)
block|{
if|if
condition|(
name|memen
argument_list|(
name|pi
argument_list|)
condition|)
name|register_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|unregister_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If INTx has been unmasked and is pending, assert the 	 * interrupt. 	 */
name|pci_lintr_update
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_cfgrw
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|coff
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|)
block|{
name|struct
name|businfo
modifier|*
name|bi
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|struct
name|pci_devinst
modifier|*
name|pi
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|needcfg
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|,
name|bar
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|bi
operator|=
name|pci_businfo
index|[
name|bus
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|si
operator|=
operator|&
name|bi
operator|->
name|slotinfo
index|[
name|slot
index|]
expr_stmt|;
name|pi
operator|=
name|si
operator|->
name|si_funcs
index|[
name|func
index|]
operator|.
name|fi_devi
expr_stmt|;
block|}
else|else
name|pi
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Just return if there is no device at this slot:func or if the 	 * the guest is doing an un-aligned access. 	 */
if|if
condition|(
name|pi
operator|==
name|NULL
operator|||
operator|(
name|bytes
operator|!=
literal|1
operator|&&
name|bytes
operator|!=
literal|2
operator|&&
name|bytes
operator|!=
literal|4
operator|)
operator|||
operator|(
name|coff
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
literal|0xffffffff
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ignore all writes beyond the standard config space and return all 	 * ones on reads. 	 */
if|if
condition|(
name|coff
operator|>=
name|PCI_REGMAX
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|in
condition|)
block|{
operator|*
name|eax
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* 			 * Extended capabilities begin at offset 256 in config 			 * space. Absence of extended capabilities is signaled 			 * with all 0s in the extended capability header at 			 * offset 256. 			 */
if|if
condition|(
name|coff
operator|<=
name|PCI_REGMAX
operator|+
literal|4
condition|)
operator|*
name|eax
operator|=
literal|0x00000000
expr_stmt|;
block|}
return|return;
block|}
name|pe
operator|=
name|pi
operator|->
name|pi_d
expr_stmt|;
comment|/* 	 * Config read 	 */
if|if
condition|(
name|in
condition|)
block|{
comment|/* Let the device emulation override the default handler */
if|if
condition|(
name|pe
operator|->
name|pe_cfgread
operator|!=
name|NULL
condition|)
block|{
name|needcfg
operator|=
name|pe
operator|->
name|pe_cfgread
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|needcfg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|needcfg
condition|)
operator|*
name|eax
operator|=
name|CFGREAD
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|pci_emul_hdrtype_fixup
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Let the device emulation override the default handler */
if|if
condition|(
name|pe
operator|->
name|pe_cfgwrite
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|pe
operator|->
name|pe_cfgwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 		 * Special handling for write to BAR registers 		 */
if|if
condition|(
name|coff
operator|>=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|&&
name|coff
operator|<
name|PCIR_BAR
argument_list|(
name|PCI_BARMAX
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* 			 * Ignore writes to BAR registers that are not 			 * 4-byte aligned. 			 */
if|if
condition|(
name|bytes
operator|!=
literal|4
operator|||
operator|(
name|coff
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
return|return;
name|idx
operator|=
operator|(
name|coff
operator|-
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|bar
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCIBAR_IO
case|:
name|addr
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|addr
operator|&=
literal|0xffff
expr_stmt|;
name|bar
operator|=
name|addr
operator||
name|PCIM_BAR_IO_SPACE
expr_stmt|;
comment|/* 				 * Register the new BAR value for interception 				 */
if|if
condition|(
name|addr
operator|!=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
argument_list|,
name|PCIBAR_IO
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM32
case|:
name|addr
operator|=
name|bar
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|bar
operator||=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_32
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
argument_list|,
name|PCIBAR_MEM32
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM64
case|:
name|addr
operator|=
name|bar
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|bar
operator||=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
operator||
name|PCIM_BAR_MEM_PREFETCH
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|uint32_t
operator|)
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
argument_list|,
name|PCIBAR_MEM64
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEMHI64
case|:
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|addr
operator|=
operator|(
operator|(
name|uint64_t
operator|)
operator|*
name|eax
operator|<<
literal|32
operator|)
operator|&
name|mask
expr_stmt|;
name|bar
operator|=
name|addr
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|bar
operator|!=
name|pi
operator|->
name|pi_bar
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|addr
operator|>>
literal|32
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|PCIBAR_MEMHI64
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|pci_set_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_emul_iscap
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
condition|)
block|{
name|pci_emul_capwrite
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff
operator|>=
name|PCIR_COMMAND
operator|&&
name|coff
operator|<
name|PCIR_REVID
condition|)
block|{
name|pci_emul_cmdsts_write
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
operator|*
name|eax
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
operator|*
name|eax
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|cfgenable
decl_stmt|,
name|cfgbus
decl_stmt|,
name|cfgslot
decl_stmt|,
name|cfgfunc
decl_stmt|,
name|cfgoff
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pci_emul_cfgaddr
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
operator|(
name|bytes
operator|==
literal|2
operator|)
condition|?
literal|0xffff
else|:
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|in
condition|)
block|{
name|x
operator|=
operator|(
name|cfgbus
operator|<<
literal|16
operator|)
operator||
operator|(
name|cfgslot
operator|<<
literal|11
operator|)
operator||
operator|(
name|cfgfunc
operator|<<
literal|8
operator|)
operator||
name|cfgoff
expr_stmt|;
if|if
condition|(
name|cfgenable
condition|)
name|x
operator||=
name|CONF1_ENABLE
expr_stmt|;
operator|*
name|eax
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|*
name|eax
expr_stmt|;
name|cfgenable
operator|=
operator|(
name|x
operator|&
name|CONF1_ENABLE
operator|)
operator|==
name|CONF1_ENABLE
expr_stmt|;
name|cfgoff
operator|=
name|x
operator|&
name|PCI_REGMAX
expr_stmt|;
name|cfgfunc
operator|=
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
name|PCI_FUNCMAX
expr_stmt|;
name|cfgslot
operator|=
operator|(
name|x
operator|>>
literal|11
operator|)
operator|&
name|PCI_SLOTMAX
expr_stmt|;
name|cfgbus
operator|=
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
name|PCI_BUSMAX
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgaddr
argument_list|,
name|CONF1_ADDR_PORT
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pci_emul_cfgdata
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|coff
decl_stmt|;
name|assert
argument_list|(
name|bytes
operator|==
literal|1
operator|||
name|bytes
operator|==
literal|2
operator|||
name|bytes
operator|==
literal|4
argument_list|)
expr_stmt|;
name|coff
operator|=
name|cfgoff
operator|+
operator|(
name|port
operator|-
name|CONF1_DATA_PORT
operator|)
expr_stmt|;
if|if
condition|(
name|cfgenable
condition|)
block|{
name|pci_cfgrw
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|in
argument_list|,
name|cfgbus
argument_list|,
name|cfgslot
argument_list|,
name|cfgfunc
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ignore accesses to cfgdata if not enabled by cfgaddr */
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
literal|0xffffffff
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|0
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|1
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|2
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|3
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_TEST
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_EMUL_TEST
end_ifdef

begin_comment
comment|/*  * Define a dummy test device  */
end_comment

begin_define
define|#
directive|define
name|DIOSZ
value|8
end_define

begin_define
define|#
directive|define
name|DMEMSZ
value|4096
end_define

begin_struct
struct|struct
name|pci_emul_dsoftc
block|{
name|uint8_t
name|ioregs
index|[
name|DIOSZ
index|]
decl_stmt|;
name|uint8_t
name|memregs
index|[
literal|2
index|]
index|[
name|DMEMSZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCI_EMUL_MSI_MSGS
value|4
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MSIX_MSGS
value|16
end_define

begin_function
specifier|static
name|int
name|pci_emul_dinit
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_emul_dsoftc
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_arg
operator|=
name|sc
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|0x10DD
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_add_msicap
argument_list|(
name|pi
argument_list|,
name|PCI_EMUL_MSI_MSGS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
name|PCIBAR_IO
argument_list|,
name|DIOSZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
literal|1
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|DMEMSZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
literal|2
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|DMEMSZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_emul_diow
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
if|if
condition|(
name|baridx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DIOSZ
condition|)
block|{
name|printf
argument_list|(
literal|"diow: iow too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
operator|=
name|value
operator|&
literal|0xffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"diow: iow unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Special magic value to generate an interrupt 		 */
if|if
condition|(
name|offset
operator|==
literal|4
operator|&&
name|size
operator|==
literal|4
operator|&&
name|pci_msi_enabled
argument_list|(
name|pi
argument_list|)
condition|)
name|pci_generate_msi
argument_list|(
name|pi
argument_list|,
name|value
operator|%
name|pci_msi_maxmsgnum
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xabcdef
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pci_msi_maxmsgnum
argument_list|(
name|pi
argument_list|)
condition|;
name|i
operator|++
control|)
name|pci_generate_msi
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baridx
operator|==
literal|1
operator|||
name|baridx
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DMEMSZ
condition|)
block|{
name|printf
argument_list|(
literal|"diow: memw too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|baridx
operator|-
literal|1
expr_stmt|;
comment|/* 'memregs' index */
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"diow: memw unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * magic interrupt ?? 		 */
block|}
if|if
condition|(
name|baridx
operator|>
literal|2
operator|||
name|baridx
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"diow: unknown bar idx %d\n"
argument_list|,
name|baridx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|pci_emul_dior
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|baridx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DIOSZ
condition|)
block|{
name|printf
argument_list|(
literal|"dior: ior too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dior: ior unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baridx
operator|==
literal|1
operator|||
name|baridx
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DMEMSZ
condition|)
block|{
name|printf
argument_list|(
literal|"dior: memr too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|=
name|baridx
operator|-
literal|1
expr_stmt|;
comment|/* 'memregs' index */
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|i
index|]
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dior: ior unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baridx
operator|>
literal|2
operator|||
name|baridx
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dior: unknown bar idx %d\n"
argument_list|,
name|baridx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pci_devemu
name|pci_dummy
init|=
block|{
operator|.
name|pe_emu
operator|=
literal|"dummy"
block|,
operator|.
name|pe_init
operator|=
name|pci_emul_dinit
block|,
operator|.
name|pe_barwrite
operator|=
name|pci_emul_diow
block|,
operator|.
name|pe_barread
operator|=
name|pci_emul_dior
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCI_EMUL_SET
argument_list|(
name|pci_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_EMUL_TEST */
end_comment

end_unit

