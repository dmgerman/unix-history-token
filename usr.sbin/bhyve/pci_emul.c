begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_include
include|#
directive|include
file|"fbsdrun.h"
end_include

begin_include
include|#
directive|include
file|"inout.h"
end_include

begin_include
include|#
directive|include
file|"pci_emul.h"
end_include

begin_define
define|#
directive|define
name|CONF1_ADDR_PORT
value|0x0cf8
end_define

begin_define
define|#
directive|define
name|CONF1_DATA_PORT
value|0x0cfc
end_define

begin_define
define|#
directive|define
name|CFGWRITE
parameter_list|(
name|pi
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|,
name|b
parameter_list|)
define|\
value|do {									\ 	if ((b) == 1) {							\ 		pci_set_cfgdata8((pi),(off),(val));			\ 	} else if ((b) == 2) {						\ 		pci_set_cfgdata16((pi),(off),(val));			\ 	} else {							\ 		pci_set_cfgdata32((pi),(off),(val));			\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|MAXSLOTS
value|32
end_define

begin_struct
specifier|static
struct|struct
name|slotinfo
block|{
name|char
modifier|*
name|si_name
decl_stmt|;
name|char
modifier|*
name|si_param
decl_stmt|;
name|struct
name|pci_devinst
modifier|*
name|si_devi
decl_stmt|;
name|int
name|si_titled
decl_stmt|;
name|int
name|si_pslot
decl_stmt|;
name|char
name|si_prefix
decl_stmt|;
name|char
name|si_suffix
decl_stmt|;
block|}
name|pci_slotinfo
index|[
name|MAXSLOTS
index|]
struct|;
end_struct

begin_comment
comment|/*  * NetApp specific:  * struct used to build an in-core OEM table to supply device names  * to driver instances  */
end_comment

begin_struct
specifier|static
struct|struct
name|mptable_pci_devnames
block|{
define|#
directive|define
name|MPT_HDR_BASE
value|0
define|#
directive|define
name|MPT_HDR_NAME
value|2
name|uint16_t
name|md_hdrtype
decl_stmt|;
name|uint16_t
name|md_entries
decl_stmt|;
name|uint16_t
name|md_cksum
decl_stmt|;
name|uint16_t
name|md_pad
decl_stmt|;
define|#
directive|define
name|MPT_NTAP_SIG
define|\
value|((uint32_t)(('P'<< 24) | ('A'<< 16) | ('T'<< 8) | 'N'))
name|uint32_t
name|md_sig
decl_stmt|;
name|uint32_t
name|md_rsvd
decl_stmt|;
struct|struct
name|mptable_pci_slotinfo
block|{
name|uint16_t
name|mds_type
decl_stmt|;
name|uint16_t
name|mds_phys_slot
decl_stmt|;
name|uint8_t
name|mds_bus
decl_stmt|;
name|uint8_t
name|mds_slot
decl_stmt|;
name|uint8_t
name|mds_func
decl_stmt|;
name|uint8_t
name|mds_pad
decl_stmt|;
name|uint16_t
name|mds_vid
decl_stmt|;
name|uint16_t
name|mds_did
decl_stmt|;
name|uint8_t
name|mds_suffix
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|mds_prefix
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|mds_rsvd
index|[
literal|3
index|]
decl_stmt|;
block|}
name|md_slotinfo
index|[
name|MAXSLOTS
index|]
struct|;
block|}
name|pci_devnames
struct|;
end_struct

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|pci_devemu_set
argument_list|,
expr|struct
name|pci_devemu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_iobase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_membase32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_membase64
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_IOBASE
value|0x2000
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_IOLIMIT
value|0x10000
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMBASE32
value|(lomem_sz)
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMLIMIT32
value|0xE0000000
end_define

begin_comment
comment|/* 3.5GB */
end_comment

begin_define
define|#
directive|define
name|PCI_EMUL_MEMBASE64
value|0xD000000000UL
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMLIMIT64
value|0xFD00000000UL
end_define

begin_decl_stmt
specifier|static
name|int
name|pci_emul_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devname_elems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * I/O access  */
end_comment

begin_comment
comment|/*  * Slot options are in the form:  *  *<slot>,<emul>[,<config>]  *  *  slot is 0..31  *  emul is a string describing the type of PCI device e.g. virtio-net  *  config is an optional string, depending on the device, that can be  *  used for configuration.  *   Examples are:  *     1,virtio-net,tap0  *     3,dummy  */
end_comment

begin_function
specifier|static
name|void
name|pci_parse_slot_usage
parameter_list|(
name|char
modifier|*
name|aopt
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Invalid PCI slot info field \"%s\"\n"
argument_list|,
name|aopt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_parse_slot
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|)
block|{
name|char
modifier|*
name|slot
decl_stmt|,
modifier|*
name|emul
decl_stmt|,
modifier|*
name|config
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|cpy
decl_stmt|;
name|int
name|snum
decl_stmt|;
name|str
operator|=
name|cpy
operator|=
name|strdup
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|emul
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|config
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emul
operator|==
name|NULL
condition|)
block|{
name|pci_parse_slot_usage
argument_list|(
name|cpy
argument_list|)
expr_stmt|;
return|return;
block|}
name|snum
operator|=
literal|255
expr_stmt|;
name|snum
operator|=
name|atoi
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|snum
operator|<
literal|0
operator|||
name|snum
operator|>=
name|MAXSLOTS
condition|)
block|{
name|pci_parse_slot_usage
argument_list|(
name|cpy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_slotinfo
index|[
name|snum
index|]
operator|.
name|si_name
operator|=
name|emul
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
operator|.
name|si_param
operator|=
name|config
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  * PCI MPTable names are of the form:  *  *<slot>,[prefix]<digit><suffix>  *  *  .. with<prefix> an alphabetic char,<digit> a 1 or 2-digit string,  * and<suffix> a single char.  *  *  Examples:  *    1,e0c  *    4,e0P  *    6,43a  *    7,0f  *    10,1  *    12,e0M  *    2,12a  *  *  Note that this is NetApp-specific, but is ignored on other o/s's.  */
end_comment

begin_function
specifier|static
name|void
name|pci_parse_name_usage
parameter_list|(
name|char
modifier|*
name|aopt
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Invalid PCI slot name field \"%s\"\n"
argument_list|,
name|aopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_parse_name
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|)
block|{
name|char
name|csnum
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|namestr
decl_stmt|;
name|char
modifier|*
name|slotend
decl_stmt|;
name|char
name|prefix
decl_stmt|,
name|suffix
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|pslot
decl_stmt|;
name|int
name|snum
decl_stmt|;
name|pslot
operator|=
operator|-
literal|1
expr_stmt|;
name|prefix
operator|=
name|suffix
operator|=
literal|0
expr_stmt|;
name|slotend
operator|=
name|strchr
argument_list|(
name|opt
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* 	 * A comma must be present, and can't be the first character 	 * or no slot would be present. Also, the slot number can't be 	 * more than 2 characters. 	 */
if|if
condition|(
name|slotend
operator|==
name|NULL
operator|||
name|slotend
operator|==
name|opt
operator|||
operator|(
name|slotend
operator|-
name|opt
operator|>
literal|2
operator|)
condition|)
block|{
name|pci_parse_name_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|slotend
operator|-
name|opt
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|csnum
index|[
name|i
index|]
operator|=
name|opt
index|[
name|i
index|]
expr_stmt|;
block|}
name|csnum
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|snum
operator|=
literal|255
expr_stmt|;
name|snum
operator|=
name|atoi
argument_list|(
name|csnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|snum
operator|<
literal|0
operator|||
name|snum
operator|>=
name|MAXSLOTS
condition|)
block|{
name|pci_parse_name_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return;
block|}
name|namestr
operator|=
name|slotend
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|namestr
argument_list|)
operator|>
literal|3
condition|)
block|{
name|pci_parse_name_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|namestr
argument_list|)
condition|)
block|{
name|prefix
operator|=
operator|*
name|namestr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|namestr
argument_list|)
condition|)
block|{
name|pci_parse_name_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pslot
operator|=
operator|*
name|namestr
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
operator|*
name|namestr
argument_list|)
condition|)
block|{
name|pslot
operator|=
literal|10
operator|*
name|pslot
operator|+
operator|*
name|namestr
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|namestr
argument_list|)
operator|&&
operator|*
operator|(
name|namestr
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|suffix
operator|=
operator|*
name|namestr
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
operator|.
name|si_titled
operator|=
literal|1
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
operator|.
name|si_pslot
operator|=
name|pslot
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
operator|.
name|si_prefix
operator|=
name|prefix
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
operator|.
name|si_suffix
operator|=
name|suffix
expr_stmt|;
block|}
else|else
block|{
name|pci_parse_name_usage
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pci_add_mptable_name
parameter_list|(
name|struct
name|slotinfo
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|mptable_pci_slotinfo
modifier|*
name|ms
decl_stmt|;
comment|/* 	 * If naming information has been supplied for this slot, populate 	 * the next available mptable OEM entry 	 */
if|if
condition|(
name|si
operator|->
name|si_titled
condition|)
block|{
name|ms
operator|=
operator|&
name|pci_devnames
operator|.
name|md_slotinfo
index|[
name|devname_elems
index|]
expr_stmt|;
name|ms
operator|->
name|mds_type
operator|=
name|MPT_HDR_NAME
expr_stmt|;
name|ms
operator|->
name|mds_phys_slot
operator|=
name|si
operator|->
name|si_pslot
expr_stmt|;
name|ms
operator|->
name|mds_bus
operator|=
name|si
operator|->
name|si_devi
operator|->
name|pi_bus
expr_stmt|;
name|ms
operator|->
name|mds_slot
operator|=
name|si
operator|->
name|si_devi
operator|->
name|pi_slot
expr_stmt|;
name|ms
operator|->
name|mds_func
operator|=
name|si
operator|->
name|si_devi
operator|->
name|pi_func
expr_stmt|;
name|ms
operator|->
name|mds_vid
operator|=
name|pci_get_cfgdata16
argument_list|(
name|si
operator|->
name|si_devi
argument_list|,
name|PCIR_VENDOR
argument_list|)
expr_stmt|;
name|ms
operator|->
name|mds_did
operator|=
name|pci_get_cfgdata16
argument_list|(
name|si
operator|->
name|si_devi
argument_list|,
name|PCIR_DEVICE
argument_list|)
expr_stmt|;
name|ms
operator|->
name|mds_suffix
index|[
literal|0
index|]
operator|=
name|si
operator|->
name|si_suffix
expr_stmt|;
name|ms
operator|->
name|mds_prefix
index|[
literal|0
index|]
operator|=
name|si
operator|->
name|si_prefix
expr_stmt|;
name|devname_elems
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pci_finish_mptable_names
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|devname_elems
condition|)
block|{
name|pci_devnames
operator|.
name|md_hdrtype
operator|=
name|MPT_HDR_BASE
expr_stmt|;
name|pci_devnames
operator|.
name|md_entries
operator|=
name|devname_elems
expr_stmt|;
name|pci_devnames
operator|.
name|md_cksum
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|pci_devnames
operator|.
name|md_sig
operator|=
name|MPT_NTAP_SIG
expr_stmt|;
name|size
operator|=
operator|(
name|uintptr_t
operator|)
operator|&
name|pci_devnames
operator|.
name|md_slotinfo
index|[
name|devname_elems
index|]
operator|-
operator|(
name|uintptr_t
operator|)
operator|&
name|pci_devnames
expr_stmt|;
name|fbsdrun_add_oemtbl
argument_list|(
operator|&
name|pci_devnames
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
init|=
name|arg
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
init|=
name|pdi
operator|->
name|pi_d
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PCI_BARMAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PCIBAR_IO
operator|&&
name|port
operator|>=
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
operator|&&
name|port
operator|+
name|bytes
operator|<=
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
name|offset
operator|=
name|port
operator|-
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
call|(
modifier|*
name|pe
operator|->
name|pe_ior
call|)
argument_list|(
name|pdi
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|pe
operator|->
name|pe_iow
call|)
argument_list|(
name|pdi
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_alloc_resource
parameter_list|(
name|uint64_t
modifier|*
name|baseptr
parameter_list|,
name|uint64_t
name|limit
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint64_t
name|base
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* must be a power of 2 */
name|base
operator|=
name|roundup2
argument_list|(
operator|*
name|baseptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|size
operator|<=
name|limit
condition|)
block|{
operator|*
name|addr
operator|=
name|base
expr_stmt|;
operator|*
name|baseptr
operator|=
name|base
operator|+
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_emul_alloc_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pdi
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint64_t
name|hostbase
parameter_list|,
name|enum
name|pcibar_type
name|type
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|uint64_t
modifier|*
name|baseptr
decl_stmt|,
name|limit
decl_stmt|,
name|addr
decl_stmt|,
name|mask
decl_stmt|,
name|lobits
decl_stmt|,
name|bar
decl_stmt|;
name|struct
name|inout_port
name|iop
decl_stmt|;
name|assert
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
literal|1UL
operator|<<
name|flsl
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* round up to a power of 2 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
name|baseptr
operator|=
name|NULL
expr_stmt|;
name|addr
operator|=
name|mask
operator|=
name|lobits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCIBAR_IO
case|:
name|baseptr
operator|=
operator|&
name|pci_emul_iobase
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_IOLIMIT
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_IO_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_IO_SPACE
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM64
case|:
comment|/* 		 * XXX 		 * Some drivers do not work well if the 64-bit BAR is allocated 		 * above 4GB. Allow for this by allocating small requests under 		 * 4GB unless then allocation size is larger than some arbitrary 		 * number (32MB currently). 		 */
if|if
condition|(
name|size
operator|>
literal|32
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
comment|/* 			 * XXX special case for device requiring peer-peer DMA 			 */
if|if
condition|(
name|size
operator|==
literal|0x100000000UL
condition|)
name|baseptr
operator|=
operator|&
name|hostbase
expr_stmt|;
else|else
name|baseptr
operator|=
operator|&
name|pci_emul_membase64
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT64
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
operator||
name|PCIM_BAR_MEM_PREFETCH
expr_stmt|;
break|break;
block|}
comment|/* fallthrough */
case|case
name|PCIBAR_MEM32
case|:
name|baseptr
operator|=
operator|&
name|pci_emul_membase32
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT32
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_32
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"pci_emul_alloc_base: invalid bar type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseptr
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|pci_emul_alloc_resource
argument_list|(
name|baseptr
argument_list|,
name|limit
argument_list|,
name|size
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
comment|/* Initialize the BAR register in config space */
name|bar
operator|=
operator|(
name|addr
operator|&
name|mask
operator|)
operator||
name|lobits
expr_stmt|;
name|pci_set_cfgdata32
argument_list|(
name|pdi
argument_list|,
name|PCIR_BAR
argument_list|(
name|idx
argument_list|)
argument_list|,
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PCIBAR_MEM64
condition|)
block|{
name|assert
argument_list|(
name|idx
operator|+
literal|1
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|type
operator|=
name|PCIBAR_MEMHI64
expr_stmt|;
name|pci_set_cfgdata32
argument_list|(
name|pdi
argument_list|,
name|PCIR_BAR
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
name|bar
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
comment|/* add a handler to intercept accesses to the I/O bar */
if|if
condition|(
name|type
operator|==
name|PCIBAR_IO
condition|)
block|{
name|iop
operator|.
name|name
operator|=
name|pdi
operator|->
name|pi_name
expr_stmt|;
name|iop
operator|.
name|flags
operator|=
name|IOPORT_F_INOUT
expr_stmt|;
name|iop
operator|.
name|handler
operator|=
name|pci_emul_handler
expr_stmt|;
name|iop
operator|.
name|arg
operator|=
name|pdi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|iop
operator|.
name|port
operator|=
name|addr
operator|+
name|i
expr_stmt|;
name|register_inout
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CAP_START_OFFSET
value|0x40
end_define

begin_function
specifier|static
name|int
name|pci_emul_add_capability
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|u_char
modifier|*
name|capdata
parameter_list|,
name|int
name|caplen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|capoff
decl_stmt|,
name|capid
decl_stmt|,
name|reallen
decl_stmt|;
name|uint16_t
name|sts
decl_stmt|;
specifier|static
name|u_char
name|endofcap
index|[
literal|4
index|]
init|=
block|{
name|PCIY_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|caplen
operator|>
literal|0
operator|&&
name|capdata
index|[
literal|0
index|]
operator|!=
name|PCIY_RESERVED
argument_list|)
expr_stmt|;
name|reallen
operator|=
name|roundup2
argument_list|(
name|caplen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* dword aligned */
name|sts
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|==
literal|0
condition|)
block|{
name|capoff
operator|=
name|CAP_START_OFFSET
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|,
name|sts
operator||
name|PCIM_STATUS_CAPPRESENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|capoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|assert
argument_list|(
operator|(
name|capoff
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|capid
operator|==
name|PCIY_RESERVED
condition|)
break|break;
name|capoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if we have enough space */
if|if
condition|(
name|capoff
operator|+
name|reallen
operator|+
sizeof|sizeof
argument_list|(
name|endofcap
argument_list|)
operator|>
name|PCI_REGMAX
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Copy the capability */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|caplen
condition|;
name|i
operator|++
control|)
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
name|i
argument_list|,
name|capdata
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set the next capability pointer */
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|,
name|capoff
operator|+
name|reallen
argument_list|)
expr_stmt|;
comment|/* Copy of the reserved capability which serves as the end marker */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|endofcap
argument_list|)
condition|;
name|i
operator|++
control|)
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
name|reallen
operator|+
name|i
argument_list|,
name|endofcap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_devemu
modifier|*
name|pci_emul_finddev
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|pci_devemu
modifier|*
modifier|*
name|pdpp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|pdpp
argument_list|,
argument|pci_devemu_set
argument_list|)
block|{
name|pdp
operator|=
operator|*
name|pdpp
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pdp
operator|->
name|pe_emu
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|pdp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_emul_init
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devemu
modifier|*
name|pde
parameter_list|,
name|int
name|slot
parameter_list|,
name|char
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
decl_stmt|;
name|pdi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinst
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pdi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pdi
argument_list|)
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_vmctx
operator|=
name|ctx
expr_stmt|;
name|pdi
operator|->
name|pi_bus
operator|=
literal|0
expr_stmt|;
name|pdi
operator|->
name|pi_slot
operator|=
name|slot
expr_stmt|;
name|pdi
operator|->
name|pi_func
operator|=
literal|0
expr_stmt|;
name|pdi
operator|->
name|pi_d
operator|=
name|pde
expr_stmt|;
name|snprintf
argument_list|(
name|pdi
operator|->
name|pi_name
argument_list|,
name|PI_NAMESZ
argument_list|,
literal|"%s-pci-%d"
argument_list|,
name|pde
operator|->
name|pe_emu
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Disable legacy interrupts */
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|pde
operator|->
name|pe_init
call|)
argument_list|(
name|ctx
argument_list|,
name|pdi
argument_list|,
name|params
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pdi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_emul_devices
operator|++
expr_stmt|;
name|pci_slotinfo
index|[
name|slot
index|]
operator|.
name|si_devi
operator|=
name|pdi
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_populate_msicap
parameter_list|(
name|struct
name|msicap
modifier|*
name|msicap
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|nextptr
parameter_list|)
block|{
name|int
name|mmc
decl_stmt|;
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msicap
argument_list|)
operator|==
literal|14
argument_list|)
expr_stmt|;
comment|/* Number of msi messages must be a power of 2 between 1 and 32 */
name|assert
argument_list|(
operator|(
name|msgnum
operator|&
operator|(
name|msgnum
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|msgnum
operator|>=
literal|1
operator|&&
name|msgnum
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|mmc
operator|=
name|ffs
argument_list|(
name|msgnum
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|msicap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msicap
argument_list|)
argument_list|)
expr_stmt|;
name|msicap
operator|->
name|capid
operator|=
name|PCIY_MSI
expr_stmt|;
name|msicap
operator|->
name|nextptr
operator|=
name|nextptr
expr_stmt|;
name|msicap
operator|->
name|msgctrl
operator|=
name|PCIM_MSICTRL_64BIT
operator||
operator|(
name|mmc
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_add_msicap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msgnum
parameter_list|)
block|{
name|struct
name|msicap
name|msicap
decl_stmt|;
name|pci_populate_msicap
argument_list|(
operator|&
name|msicap
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msicap
argument_list|,
sizeof|sizeof
argument_list|(
name|msicap
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|msicap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint16_t
name|msgctrl
decl_stmt|,
name|rwmask
decl_stmt|,
name|msgdata
decl_stmt|,
name|mme
decl_stmt|;
name|uint32_t
name|addrlo
decl_stmt|;
comment|/* 	 * If guest is writing to the message control register make sure 	 * we do not overwrite read-only fields. 	 */
if|if
condition|(
operator|(
name|offset
operator|-
name|capoff
operator|)
operator|==
literal|2
operator|&&
name|bytes
operator|==
literal|2
condition|)
block|{
name|rwmask
operator|=
name|PCIM_MSICTRL_MME_MASK
operator||
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|msgctrl
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|msgctrl
operator|&=
operator|~
name|rwmask
expr_stmt|;
name|msgctrl
operator||=
name|val
operator|&
name|rwmask
expr_stmt|;
name|val
operator|=
name|msgctrl
expr_stmt|;
name|addrlo
operator|=
name|pci_get_cfgdata32
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
name|msgdata
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|12
argument_list|)
expr_stmt|;
else|else
name|msgdata
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* 		 * XXX check delivery mode, destination mode etc 		 */
name|mme
operator|=
name|msgctrl
operator|&
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|=
name|msgctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
condition|)
block|{
name|pi
operator|->
name|pi_msi
operator|.
name|cpu
operator|=
operator|(
name|addrlo
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|vector
operator|=
name|msgdata
operator|&
literal|0xff
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|msgnum
operator|=
literal|1
operator|<<
operator|(
name|mme
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|pi_msi
operator|.
name|cpu
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|vector
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|msgnum
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function assumes that 'coff' is in the capabilities region of the  * config space.  */
end_comment

begin_function
specifier|static
name|void
name|pci_emul_capwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|capid
decl_stmt|;
name|uint8_t
name|capoff
decl_stmt|,
name|nextoff
decl_stmt|;
comment|/* Do not allow un-aligned writes */
if|if
condition|(
operator|(
name|offset
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Find the capability that we want to update */
name|capoff
operator|=
name|CAP_START_OFFSET
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|capid
operator|==
name|PCIY_RESERVED
condition|)
break|break;
name|nextoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|capoff
operator|&&
name|offset
operator|<
name|nextoff
condition|)
break|break;
name|capoff
operator|=
name|nextoff
expr_stmt|;
block|}
name|assert
argument_list|(
name|offset
operator|>=
name|capoff
argument_list|)
expr_stmt|;
comment|/* 	 * Capability ID and Next Capability Pointer are readonly 	 */
if|if
condition|(
name|offset
operator|==
name|capoff
operator|||
name|offset
operator|==
name|capoff
operator|+
literal|1
condition|)
return|return;
switch|switch
condition|(
name|capid
condition|)
block|{
case|case
name|PCIY_MSI
case|:
name|msicap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_iscap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|uint16_t
name|sts
decl_stmt|;
name|uint8_t
name|capid
decl_stmt|,
name|lastoff
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|sts
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|lastoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|assert
argument_list|(
operator|(
name|lastoff
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|lastoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|capid
operator|==
name|PCIY_RESERVED
condition|)
break|break;
name|lastoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|lastoff
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>=
name|CAP_START_OFFSET
operator|&&
name|offset
operator|<=
name|lastoff
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_pci
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|pci_devemu
modifier|*
name|pde
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pci_emul_iobase
operator|=
name|PCI_EMUL_IOBASE
expr_stmt|;
name|pci_emul_membase32
operator|=
name|PCI_EMUL_MEMBASE32
expr_stmt|;
name|pci_emul_membase64
operator|=
name|PCI_EMUL_MEMBASE64
expr_stmt|;
name|si
operator|=
name|pci_slotinfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSLOTS
condition|;
name|i
operator|++
operator|,
name|si
operator|++
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_name
operator|!=
name|NULL
condition|)
block|{
name|pde
operator|=
name|pci_emul_finddev
argument_list|(
name|si
operator|->
name|si_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
name|NULL
condition|)
block|{
name|pci_emul_init
argument_list|(
name|ctx
argument_list|,
name|pde
argument_list|,
name|i
argument_list|,
name|si
operator|->
name|si_param
argument_list|)
expr_stmt|;
name|pci_add_mptable_name
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pci_finish_mptable_names
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_msi_enabled
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msi_msgnum
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|msgnum
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_generate_msi
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|pci_msi_enabled
argument_list|(
name|pi
argument_list|)
operator|&&
name|msg
operator|<
name|pci_msi_msgnum
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|vm_lapic_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_msi
operator|.
name|cpu
argument_list|,
name|pi
operator|->
name|pi_msi
operator|.
name|vector
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|cfgbus
decl_stmt|,
name|cfgslot
decl_stmt|,
name|cfgfunc
decl_stmt|,
name|cfgoff
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pci_emul_cfgaddr
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
name|assert
argument_list|(
operator|!
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|x
operator|=
operator|*
name|eax
expr_stmt|;
name|cfgoff
operator|=
name|x
operator|&
name|PCI_REGMAX
expr_stmt|;
name|cfgfunc
operator|=
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
name|PCI_FUNCMAX
expr_stmt|;
name|cfgslot
operator|=
operator|(
name|x
operator|>>
literal|11
operator|)
operator|&
name|PCI_SLOTMAX
expr_stmt|;
name|cfgbus
operator|=
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
name|PCI_BUSMAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgaddr
argument_list|,
name|CONF1_ADDR_PORT
argument_list|,
name|IOPORT_F_OUT
argument_list|,
name|pci_emul_cfgaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pci_emul_cfgdata
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pi
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
decl_stmt|;
name|int
name|coff
decl_stmt|,
name|idx
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|,
name|bar
decl_stmt|;
name|assert
argument_list|(
name|bytes
operator|==
literal|1
operator|||
name|bytes
operator|==
literal|2
operator|||
name|bytes
operator|==
literal|4
argument_list|)
expr_stmt|;
name|pi
operator|=
name|pci_slotinfo
index|[
name|cfgslot
index|]
operator|.
name|si_devi
expr_stmt|;
name|coff
operator|=
name|cfgoff
operator|+
operator|(
name|port
operator|-
name|CONF1_DATA_PORT
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("pcicfg-%s from 0x%0x of %d bytes (%d/%d/%d)\n\r", 		in ? "read" : "write", coff, bytes, cfgbus, cfgslot, cfgfunc);
endif|#
directive|endif
if|if
condition|(
name|pi
operator|==
name|NULL
operator|||
name|cfgfunc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
literal|0xffffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pe
operator|=
name|pi
operator|->
name|pi_d
expr_stmt|;
comment|/* 	 * Config read 	 */
if|if
condition|(
name|in
condition|)
block|{
comment|/* Let the device emulation override the default handler */
if|if
condition|(
name|pe
operator|->
name|pe_cfgread
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|pe
operator|->
name|pe_cfgread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bytes
operator|==
literal|1
condition|)
operator|*
name|eax
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|2
condition|)
operator|*
name|eax
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
expr_stmt|;
else|else
operator|*
name|eax
operator|=
name|pci_get_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Let the device emulation override the default handler */
if|if
condition|(
name|pe
operator|->
name|pe_cfgwrite
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|pe
operator|->
name|pe_cfgwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Special handling for write to BAR registers 		 */
if|if
condition|(
name|coff
operator|>=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|&&
name|coff
operator|<
name|PCIR_BAR
argument_list|(
name|PCI_BARMAX
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* 			 * Ignore writes to BAR registers that are not 			 * 4-byte aligned. 			 */
if|if
condition|(
name|bytes
operator|!=
literal|4
operator|||
operator|(
name|coff
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|idx
operator|=
operator|(
name|coff
operator|-
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
name|bar
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCIBAR_IO
case|:
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator|&=
name|PCIM_BAR_IO_BASE
expr_stmt|;
name|bar
operator|=
operator|(
operator|*
name|eax
operator|&
name|mask
operator|)
operator||
name|PCIM_BAR_IO_SPACE
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM32
case|:
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator|&=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|bar
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|bar
operator||=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_32
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM64
case|:
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator|&=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|bar
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|bar
operator||=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
operator||
name|PCIM_BAR_MEM_PREFETCH
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEMHI64
case|:
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator|&=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|bar
operator|=
operator|(
operator|(
name|uint64_t
operator|)
operator|*
name|eax
operator|<<
literal|32
operator|)
operator|&
name|mask
expr_stmt|;
name|bar
operator|=
name|bar
operator|>>
literal|32
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|pci_set_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_emul_iscap
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
condition|)
block|{
name|pci_emul_capwrite
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
operator|*
name|eax
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|0
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|1
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|2
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|3
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * I/O ports to configure PCI IRQ routing. We ignore all writes to it.  */
end_comment

begin_function
specifier|static
name|int
name|pci_irq_port_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|assert
argument_list|(
name|in
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_irq
argument_list|,
literal|0xC00
argument_list|,
name|IOPORT_F_OUT
argument_list|,
name|pci_irq_port_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_irq
argument_list|,
literal|0xC01
argument_list|,
name|IOPORT_F_OUT
argument_list|,
name|pci_irq_port_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_TEST
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_EMUL_TEST
end_ifdef

begin_comment
comment|/*  * Define a dummy test device  */
end_comment

begin_define
define|#
directive|define
name|DREGSZ
value|20
end_define

begin_struct
struct|struct
name|pci_emul_dsoftc
block|{
name|uint8_t
name|regs
index|[
name|DREGSZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCI_EMUL_MSGS
value|4
end_define

begin_function
name|int
name|pci_emul_dinit
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_emul_dsoftc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_emul_dsoftc
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_arg
operator|=
name|sc
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|0x10DD
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PCIBAR_IO
argument_list|,
name|DREGSZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_add_msicap
argument_list|(
name|pi
argument_list|,
name|PCI_EMUL_MSGS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_emul_diow
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DREGSZ
condition|)
block|{
name|printf
argument_list|(
literal|"diow: too large, offset %d size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|regs
index|[
name|offset
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|regs
index|[
name|offset
index|]
operator|=
name|value
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|regs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
comment|/* 	 * Special magic value to generate an interrupt 	 */
if|if
condition|(
name|offset
operator|==
literal|4
operator|&&
name|size
operator|==
literal|4
operator|&&
name|pci_msi_enabled
argument_list|(
name|pi
argument_list|)
condition|)
name|pci_generate_msi
argument_list|(
name|pi
argument_list|,
name|value
operator|%
name|pci_msi_msgnum
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xabcdef
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pci_msi_msgnum
argument_list|(
name|pi
argument_list|)
condition|;
name|i
operator|++
control|)
name|pci_generate_msi
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint32_t
name|pci_emul_dior
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DREGSZ
condition|)
block|{
name|printf
argument_list|(
literal|"dior: too large, offset %d size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|sc
operator|->
name|regs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|regs
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|regs
index|[
name|offset
index|]
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pci_devemu
name|pci_dummy
init|=
block|{
operator|.
name|pe_emu
operator|=
literal|"dummy"
block|,
operator|.
name|pe_init
operator|=
name|pci_emul_dinit
block|,
operator|.
name|pe_iow
operator|=
name|pci_emul_diow
block|,
operator|.
name|pe_ior
operator|=
name|pci_emul_dior
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCI_EMUL_SET
argument_list|(
name|pci_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_EMUL_TEST */
end_comment

end_unit

