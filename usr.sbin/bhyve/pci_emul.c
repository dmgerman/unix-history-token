begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 NetApp, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|<vmmapi.h>
end_include

begin_include
include|#
directive|include
file|"bhyverun.h"
end_include

begin_include
include|#
directive|include
file|"inout.h"
end_include

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"mptbl.h"
end_include

begin_include
include|#
directive|include
file|"pci_emul.h"
end_include

begin_include
include|#
directive|include
file|"ioapic.h"
end_include

begin_define
define|#
directive|define
name|CONF1_ADDR_PORT
value|0x0cf8
end_define

begin_define
define|#
directive|define
name|CONF1_DATA_PORT
value|0x0cfc
end_define

begin_define
define|#
directive|define
name|CFGWRITE
parameter_list|(
name|pi
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|,
name|b
parameter_list|)
define|\
value|do {									\ 	if ((b) == 1) {							\ 		pci_set_cfgdata8((pi),(off),(val));			\ 	} else if ((b) == 2) {						\ 		pci_set_cfgdata16((pi),(off),(val));			\ 	} else {							\ 		pci_set_cfgdata32((pi),(off),(val));			\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|MAXSLOTS
value|(PCI_SLOTMAX + 1)
end_define

begin_define
define|#
directive|define
name|MAXFUNCS
value|(PCI_FUNCMAX + 1)
end_define

begin_struct
specifier|static
struct|struct
name|slotinfo
block|{
name|char
modifier|*
name|si_name
decl_stmt|;
name|char
modifier|*
name|si_param
decl_stmt|;
name|struct
name|pci_devinst
modifier|*
name|si_devi
decl_stmt|;
name|int
name|si_legacy
decl_stmt|;
block|}
name|pci_slotinfo
index|[
name|MAXSLOTS
index|]
index|[
name|MAXFUNCS
index|]
struct|;
end_struct

begin_comment
comment|/*  * Used to keep track of legacy interrupt owners/requestors  */
end_comment

begin_define
define|#
directive|define
name|NLIRQ
value|16
end_define

begin_struct
specifier|static
struct|struct
name|lirqinfo
block|{
name|int
name|li_generic
decl_stmt|;
name|int
name|li_acount
decl_stmt|;
name|struct
name|pci_devinst
modifier|*
name|li_owner
decl_stmt|;
comment|/* XXX should be a list */
block|}
name|lirq
index|[
name|NLIRQ
index|]
struct|;
end_struct

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|pci_devemu_set
argument_list|,
expr|struct
name|pci_devemu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_iobase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_membase32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_emul_membase64
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_IOBASE
value|0x2000
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_IOLIMIT
value|0x10000
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMLIMIT32
value|0xE0000000
end_define

begin_comment
comment|/* 3.5GB */
end_comment

begin_define
define|#
directive|define
name|PCI_EMUL_MEMBASE64
value|0xD000000000UL
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MEMLIMIT64
value|0xFD00000000UL
end_define

begin_decl_stmt
specifier|static
name|int
name|pci_emul_devices
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * I/O access  */
end_comment

begin_comment
comment|/*  * Slot options are in the form:  *  *<slot>[:<func>],<emul>[,<config>]  *  *  slot is 0..31  *  func is 0..7  *  emul is a string describing the type of PCI device e.g. virtio-net  *  config is an optional string, depending on the device, that can be  *  used for configuration.  *   Examples are:  *     1,virtio-net,tap0  *     3:0,dummy  */
end_comment

begin_function
specifier|static
name|void
name|pci_parse_slot_usage
parameter_list|(
name|char
modifier|*
name|aopt
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Invalid PCI slot info field \"%s\"\n"
argument_list|,
name|aopt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_parse_slot
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|,
name|int
name|legacy
parameter_list|)
block|{
name|char
modifier|*
name|slot
decl_stmt|,
modifier|*
name|func
decl_stmt|,
modifier|*
name|emul
decl_stmt|,
modifier|*
name|config
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|cpy
decl_stmt|;
name|int
name|snum
decl_stmt|,
name|fnum
decl_stmt|;
name|str
operator|=
name|cpy
operator|=
name|strdup
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|slot
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|func
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|func
operator|=
name|NULL
expr_stmt|;
block|}
name|emul
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|config
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emul
operator|==
name|NULL
condition|)
block|{
name|pci_parse_slot_usage
argument_list|(
name|cpy
argument_list|)
expr_stmt|;
return|return;
block|}
name|snum
operator|=
name|atoi
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|fnum
operator|=
name|func
condition|?
name|atoi
argument_list|(
name|func
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|snum
operator|<
literal|0
operator|||
name|snum
operator|>=
name|MAXSLOTS
operator|||
name|fnum
operator|<
literal|0
operator|||
name|fnum
operator|>=
name|MAXFUNCS
condition|)
block|{
name|pci_parse_slot_usage
argument_list|(
name|cpy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_slotinfo
index|[
name|snum
index|]
index|[
name|fnum
index|]
operator|.
name|si_name
operator|=
name|emul
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
index|[
name|fnum
index|]
operator|.
name|si_param
operator|=
name|config
expr_stmt|;
name|pci_slotinfo
index|[
name|snum
index|]
index|[
name|fnum
index|]
operator|.
name|si_legacy
operator|=
name|legacy
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_valid_pba_offset
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|<
name|pi
operator|->
name|pi_msix
operator|.
name|pba_offset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|pi
operator|->
name|pi_msix
operator|.
name|pba_offset
operator|+
name|pi
operator|->
name|pi_msix
operator|.
name|pba_size
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_emul_msix_twrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|msix_entry_offset
decl_stmt|;
name|int
name|tab_index
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* support only 4 or 8 byte writes */
if|if
condition|(
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Return if table index is beyond what device supports 	 */
name|tab_index
operator|=
name|offset
operator|/
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|tab_index
operator|>=
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|msix_entry_offset
operator|=
name|offset
operator|%
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
comment|/* support only aligned writes */
if|if
condition|(
operator|(
name|msix_entry_offset
operator|%
name|size
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|+
name|tab_index
operator|)
expr_stmt|;
name|dest
operator|+=
name|msix_entry_offset
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dest
operator|)
operator|=
name|value
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dest
operator|)
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|pci_emul_msix_tread
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|msix_entry_offset
decl_stmt|;
name|int
name|tab_index
decl_stmt|;
name|uint64_t
name|retval
init|=
operator|~
literal|0
decl_stmt|;
comment|/* support only 4 or 8 byte reads */
if|if
condition|(
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|msix_entry_offset
operator|=
name|offset
operator|%
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
comment|/* support only aligned reads */
if|if
condition|(
operator|(
name|msix_entry_offset
operator|%
name|size
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|tab_index
operator|=
name|offset
operator|/
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|tab_index
operator|<
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
condition|)
block|{
comment|/* valid MSI-X Table access */
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|+
name|tab_index
operator|)
expr_stmt|;
name|dest
operator|+=
name|msix_entry_offset
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|retval
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dest
operator|)
expr_stmt|;
else|else
name|retval
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dest
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_valid_pba_offset
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
condition|)
block|{
comment|/* return 0 for PBA access */
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_table_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|table_bar
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_pba_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|pba_bar
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_io_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
init|=
name|arg
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
init|=
name|pdi
operator|->
name|pi_d
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PCI_BARMAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PCIBAR_IO
operator|&&
name|port
operator|>=
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
operator|&&
name|port
operator|+
name|bytes
operator|<=
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
name|offset
operator|=
name|port
operator|-
name|pdi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
call|(
modifier|*
name|pe
operator|->
name|pe_barread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|pe
operator|->
name|pe_barwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_mem_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|dir
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|long
name|arg2
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
init|=
name|arg1
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
init|=
name|pdi
operator|->
name|pi_d
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|bidx
init|=
operator|(
name|int
operator|)
name|arg2
decl_stmt|;
name|assert
argument_list|(
name|bidx
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|type
operator|==
name|PCIBAR_MEM32
operator|||
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|type
operator|==
name|PCIBAR_MEM64
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|addr
operator|>=
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|addr
operator|&&
name|addr
operator|+
name|size
operator|<=
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|addr
operator|+
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|offset
operator|=
name|addr
operator|-
name|pdi
operator|->
name|pi_bar
index|[
name|bidx
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|MEM_F_WRITE
condition|)
call|(
modifier|*
name|pe
operator|->
name|pe_barwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
else|else
operator|*
name|val
operator|=
call|(
modifier|*
name|pe
operator|->
name|pe_barread
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pdi
argument_list|,
name|bidx
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_alloc_resource
parameter_list|(
name|uint64_t
modifier|*
name|baseptr
parameter_list|,
name|uint64_t
name|limit
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint64_t
name|base
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* must be a power of 2 */
name|base
operator|=
name|roundup2
argument_list|(
operator|*
name|baseptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|+
name|size
operator|<=
name|limit
condition|)
block|{
operator|*
name|addr
operator|=
name|base
expr_stmt|;
operator|*
name|baseptr
operator|=
name|base
operator|+
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_emul_alloc_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pdi
parameter_list|,
name|int
name|idx
parameter_list|,
name|enum
name|pcibar_type
name|type
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|pci_emul_alloc_pbar
argument_list|(
name|pdi
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register (or unregister) the MMIO or I/O region associated with the BAR  * register 'idx' of an emulated pci device.  */
end_comment

begin_function
specifier|static
name|void
name|modify_bar_registration
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|registration
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|inout_port
name|iop
decl_stmt|;
name|struct
name|mem_range
name|mr
decl_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_IO
case|:
name|bzero
argument_list|(
operator|&
name|iop
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inout_port
argument_list|)
argument_list|)
expr_stmt|;
name|iop
operator|.
name|name
operator|=
name|pi
operator|->
name|pi_name
expr_stmt|;
name|iop
operator|.
name|port
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
expr_stmt|;
name|iop
operator|.
name|size
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|registration
condition|)
block|{
name|iop
operator|.
name|flags
operator|=
name|IOPORT_F_INOUT
expr_stmt|;
name|iop
operator|.
name|handler
operator|=
name|pci_emul_io_handler
expr_stmt|;
name|iop
operator|.
name|arg
operator|=
name|pi
expr_stmt|;
name|error
operator|=
name|register_inout
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|unregister_inout
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM32
case|:
case|case
name|PCIBAR_MEM64
case|:
name|bzero
argument_list|(
operator|&
name|mr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_range
argument_list|)
argument_list|)
expr_stmt|;
name|mr
operator|.
name|name
operator|=
name|pi
operator|->
name|pi_name
expr_stmt|;
name|mr
operator|.
name|base
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
expr_stmt|;
name|mr
operator|.
name|size
operator|=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|registration
condition|)
block|{
name|mr
operator|.
name|flags
operator|=
name|MEM_F_RW
expr_stmt|;
name|mr
operator|.
name|handler
operator|=
name|pci_emul_mem_handler
expr_stmt|;
name|mr
operator|.
name|arg1
operator|=
name|pi
expr_stmt|;
name|mr
operator|.
name|arg2
operator|=
name|idx
expr_stmt|;
name|error
operator|=
name|register_mem
argument_list|(
operator|&
name|mr
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|unregister_mem
argument_list|(
operator|&
name|mr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unregister_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|modify_bar_registration
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|register_bar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|modify_bar_registration
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Are we decoding i/o port accesses for the emulated pci device? */
end_comment

begin_function
specifier|static
name|int
name|porten
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|uint16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|&
name|PCIM_CMD_PORTEN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Are we decoding memory accesses for the emulated pci device? */
end_comment

begin_function
specifier|static
name|int
name|memen
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|uint16_t
name|cmd
decl_stmt|;
name|cmd
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the MMIO or I/O address that is decoded by the BAR register.  *  * If the pci device has enabled the address space decoding then intercept  * the address range decoded by the BAR register.  */
end_comment

begin_function
specifier|static
name|void
name|update_bar_address
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|decode
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
operator|==
name|PCIBAR_IO
condition|)
name|decode
operator|=
name|porten
argument_list|(
name|pi
argument_list|)
expr_stmt|;
else|else
name|decode
operator|=
name|memen
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
condition|)
name|unregister_bar
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCIBAR_IO
case|:
case|case
name|PCIBAR_MEM32
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM64
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|&=
operator|~
literal|0xffffffffUL
expr_stmt|;
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator||=
name|addr
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEMHI64
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|&=
literal|0xffffffff
expr_stmt|;
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator||=
name|addr
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decode
condition|)
name|register_bar
argument_list|(
name|pi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_alloc_pbar
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pdi
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint64_t
name|hostbase
parameter_list|,
name|enum
name|pcibar_type
name|type
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
modifier|*
name|baseptr
decl_stmt|,
name|limit
decl_stmt|,
name|addr
decl_stmt|,
name|mask
decl_stmt|,
name|lobits
decl_stmt|,
name|bar
decl_stmt|;
name|assert
argument_list|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
literal|1UL
operator|<<
name|flsl
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* round up to a power of 2 */
comment|/* Enforce minimum BAR sizes required by the PCI standard */
if|if
condition|(
name|type
operator|==
name|PCIBAR_IO
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|4
condition|)
name|size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
literal|16
condition|)
name|size
operator|=
literal|16
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
name|baseptr
operator|=
name|NULL
expr_stmt|;
name|addr
operator|=
name|mask
operator|=
name|lobits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCIBAR_IO
case|:
if|if
condition|(
name|hostbase
operator|&&
name|pci_slotinfo
index|[
name|pdi
operator|->
name|pi_slot
index|]
index|[
name|pdi
operator|->
name|pi_func
index|]
operator|.
name|si_legacy
condition|)
block|{
name|assert
argument_list|(
name|hostbase
operator|<
name|PCI_EMUL_IOBASE
argument_list|)
expr_stmt|;
name|baseptr
operator|=
operator|&
name|hostbase
expr_stmt|;
block|}
else|else
block|{
name|baseptr
operator|=
operator|&
name|pci_emul_iobase
expr_stmt|;
block|}
name|limit
operator|=
name|PCI_EMUL_IOLIMIT
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_IO_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_IO_SPACE
expr_stmt|;
break|break;
case|case
name|PCIBAR_MEM64
case|:
comment|/* 		 * XXX 		 * Some drivers do not work well if the 64-bit BAR is allocated 		 * above 4GB. Allow for this by allocating small requests under 		 * 4GB unless then allocation size is larger than some arbitrary 		 * number (32MB currently). 		 */
if|if
condition|(
name|size
operator|>
literal|32
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
comment|/* 			 * XXX special case for device requiring peer-peer DMA 			 */
if|if
condition|(
name|size
operator|==
literal|0x100000000UL
condition|)
name|baseptr
operator|=
operator|&
name|hostbase
expr_stmt|;
else|else
name|baseptr
operator|=
operator|&
name|pci_emul_membase64
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT64
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
operator||
name|PCIM_BAR_MEM_PREFETCH
expr_stmt|;
break|break;
block|}
else|else
block|{
name|baseptr
operator|=
operator|&
name|pci_emul_membase32
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT32
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM32
case|:
name|baseptr
operator|=
operator|&
name|pci_emul_membase32
expr_stmt|;
name|limit
operator|=
name|PCI_EMUL_MEMLIMIT32
expr_stmt|;
name|mask
operator|=
name|PCIM_BAR_MEM_BASE
expr_stmt|;
name|lobits
operator|=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_32
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"pci_emul_alloc_base: invalid bar type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseptr
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|pci_emul_alloc_resource
argument_list|(
name|baseptr
argument_list|,
name|limit
argument_list|,
name|size
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
comment|/* Initialize the BAR register in config space */
name|bar
operator|=
operator|(
name|addr
operator|&
name|mask
operator|)
operator||
name|lobits
expr_stmt|;
name|pci_set_cfgdata32
argument_list|(
name|pdi
argument_list|,
name|PCIR_BAR
argument_list|(
name|idx
argument_list|)
argument_list|,
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PCIBAR_MEM64
condition|)
block|{
name|assert
argument_list|(
name|idx
operator|+
literal|1
operator|<=
name|PCI_BARMAX
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_bar
index|[
name|idx
operator|+
literal|1
index|]
operator|.
name|type
operator|=
name|PCIBAR_MEMHI64
expr_stmt|;
name|pci_set_cfgdata32
argument_list|(
name|pdi
argument_list|,
name|PCIR_BAR
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
name|bar
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|register_bar
argument_list|(
name|pdi
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CAP_START_OFFSET
value|0x40
end_define

begin_function
specifier|static
name|int
name|pci_emul_add_capability
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|u_char
modifier|*
name|capdata
parameter_list|,
name|int
name|caplen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|capoff
decl_stmt|,
name|capid
decl_stmt|,
name|reallen
decl_stmt|;
name|uint16_t
name|sts
decl_stmt|;
specifier|static
name|u_char
name|endofcap
index|[
literal|4
index|]
init|=
block|{
name|PCIY_RESERVED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|caplen
operator|>
literal|0
operator|&&
name|capdata
index|[
literal|0
index|]
operator|!=
name|PCIY_RESERVED
argument_list|)
expr_stmt|;
name|reallen
operator|=
name|roundup2
argument_list|(
name|caplen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* dword aligned */
name|sts
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|==
literal|0
condition|)
block|{
name|capoff
operator|=
name|CAP_START_OFFSET
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|,
name|sts
operator||
name|PCIM_STATUS_CAPPRESENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|capoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|assert
argument_list|(
operator|(
name|capoff
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|capid
operator|==
name|PCIY_RESERVED
condition|)
break|break;
name|capoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if we have enough space */
if|if
condition|(
name|capoff
operator|+
name|reallen
operator|+
sizeof|sizeof
argument_list|(
name|endofcap
argument_list|)
operator|>
name|PCI_REGMAX
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Copy the capability */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|caplen
condition|;
name|i
operator|++
control|)
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
name|i
argument_list|,
name|capdata
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set the next capability pointer */
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|,
name|capoff
operator|+
name|reallen
argument_list|)
expr_stmt|;
comment|/* Copy of the reserved capability which serves as the end marker */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|endofcap
argument_list|)
condition|;
name|i
operator|++
control|)
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
name|reallen
operator|+
name|i
argument_list|,
name|endofcap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_devemu
modifier|*
name|pci_emul_finddev
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|pci_devemu
modifier|*
modifier|*
name|pdpp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|SET_FOREACH
argument_list|(
argument|pdpp
argument_list|,
argument|pci_devemu_set
argument_list|)
block|{
name|pdp
operator|=
operator|*
name|pdpp
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pdp
operator|->
name|pe_emu
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|pdp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_emul_init
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devemu
modifier|*
name|pde
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|char
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pdi
decl_stmt|;
name|pdi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_devinst
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pdi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pdi
argument_list|)
argument_list|)
expr_stmt|;
name|pdi
operator|->
name|pi_vmctx
operator|=
name|ctx
expr_stmt|;
name|pdi
operator|->
name|pi_bus
operator|=
literal|0
expr_stmt|;
name|pdi
operator|->
name|pi_slot
operator|=
name|slot
expr_stmt|;
name|pdi
operator|->
name|pi_func
operator|=
name|func
expr_stmt|;
name|pdi
operator|->
name|pi_d
operator|=
name|pde
expr_stmt|;
name|snprintf
argument_list|(
name|pdi
operator|->
name|pi_name
argument_list|,
name|PI_NAMESZ
argument_list|,
literal|"%s-pci-%d"
argument_list|,
name|pde
operator|->
name|pe_emu
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Disable legacy interrupts */
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pdi
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|pde
operator|->
name|pe_init
call|)
argument_list|(
name|ctx
argument_list|,
name|pdi
argument_list|,
name|params
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pdi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_emul_devices
operator|++
expr_stmt|;
name|pci_slotinfo
index|[
name|slot
index|]
index|[
name|func
index|]
operator|.
name|si_devi
operator|=
name|pdi
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_populate_msicap
parameter_list|(
name|struct
name|msicap
modifier|*
name|msicap
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|nextptr
parameter_list|)
block|{
name|int
name|mmc
decl_stmt|;
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msicap
argument_list|)
operator|==
literal|14
argument_list|)
expr_stmt|;
comment|/* Number of msi messages must be a power of 2 between 1 and 32 */
name|assert
argument_list|(
operator|(
name|msgnum
operator|&
operator|(
name|msgnum
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|msgnum
operator|>=
literal|1
operator|&&
name|msgnum
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|mmc
operator|=
name|ffs
argument_list|(
name|msgnum
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|msicap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msicap
argument_list|)
argument_list|)
expr_stmt|;
name|msicap
operator|->
name|capid
operator|=
name|PCIY_MSI
expr_stmt|;
name|msicap
operator|->
name|nextptr
operator|=
name|nextptr
expr_stmt|;
name|msicap
operator|->
name|msgctrl
operator|=
name|PCIM_MSICTRL_64BIT
operator||
operator|(
name|mmc
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_add_msicap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msgnum
parameter_list|)
block|{
name|struct
name|msicap
name|msicap
decl_stmt|;
name|pci_populate_msicap
argument_list|(
operator|&
name|msicap
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msicap
argument_list|,
sizeof|sizeof
argument_list|(
name|msicap
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_populate_msixcap
parameter_list|(
name|struct
name|msixcap
modifier|*
name|msixcap
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|barnum
parameter_list|,
name|uint32_t
name|msix_tab_size
parameter_list|,
name|int
name|nextptr
parameter_list|)
block|{
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msixcap
argument_list|)
operator|==
literal|12
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|msix_tab_size
operator|%
literal|4096
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|msixcap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msixcap
argument_list|)
argument_list|)
expr_stmt|;
name|msixcap
operator|->
name|capid
operator|=
name|PCIY_MSIX
expr_stmt|;
name|msixcap
operator|->
name|nextptr
operator|=
name|nextptr
expr_stmt|;
comment|/* 	 * Message Control Register, all fields set to 	 * zero except for the Table Size. 	 * Note: Table size N is encoded as N-1 	 */
name|msixcap
operator|->
name|msgctrl
operator|=
name|msgnum
operator|-
literal|1
expr_stmt|;
comment|/* 	 * MSI-X BAR setup: 	 * - MSI-X table start at offset 0 	 * - PBA table starts at a 4K aligned offset after the MSI-X table 	 */
name|msixcap
operator|->
name|table_info
operator|=
name|barnum
operator|&
name|PCIM_MSIX_BIR_MASK
expr_stmt|;
name|msixcap
operator|->
name|pba_info
operator|=
name|msix_tab_size
operator||
operator|(
name|barnum
operator|&
name|PCIM_MSIX_BIR_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_msix_table_init
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|table_entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|table_size
decl_stmt|;
name|assert
argument_list|(
name|table_entries
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|table_entries
operator|<=
name|MAX_MSIX_TABLE_ENTRIES
argument_list|)
expr_stmt|;
name|table_size
operator|=
name|table_entries
operator|*
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table
operator|=
name|malloc
argument_list|(
name|table_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pi
operator|->
name|pi_msix
operator|.
name|table
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
comment|/* set mask bit of vector control register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_entries
condition|;
name|i
operator|++
control|)
name|pi
operator|->
name|pi_msix
operator|.
name|table
index|[
name|i
index|]
operator|.
name|vector_control
operator||=
name|PCIM_MSIX_VCTRL_MASK
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_emul_add_msixcap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msgnum
parameter_list|,
name|int
name|barnum
parameter_list|)
block|{
name|uint16_t
name|pba_index
decl_stmt|;
name|uint32_t
name|tab_size
decl_stmt|;
name|struct
name|msixcap
name|msixcap
decl_stmt|;
name|assert
argument_list|(
name|msgnum
operator|>=
literal|1
operator|&&
name|msgnum
operator|<=
name|MAX_MSIX_TABLE_ENTRIES
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|barnum
operator|>=
literal|0
operator|&&
name|barnum
operator|<=
name|PCIR_MAX_BAR_0
argument_list|)
expr_stmt|;
name|tab_size
operator|=
name|msgnum
operator|*
name|MSIX_TABLE_ENTRY_SIZE
expr_stmt|;
comment|/* Align table size to nearest 4K */
name|tab_size
operator|=
name|roundup2
argument_list|(
name|tab_size
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table_bar
operator|=
name|barnum
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|pba_bar
operator|=
name|barnum
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table_offset
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
operator|=
name|msgnum
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|pba_offset
operator|=
name|tab_size
expr_stmt|;
comment|/* calculate the MMIO size required for MSI-X PBA */
name|pba_index
operator|=
operator|(
name|msgnum
operator|-
literal|1
operator|)
operator|/
operator|(
name|PBA_TABLE_ENTRY_SIZE
operator|*
literal|8
operator|)
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|pba_size
operator|=
operator|(
name|pba_index
operator|+
literal|1
operator|)
operator|*
name|PBA_TABLE_ENTRY_SIZE
expr_stmt|;
name|pci_msix_table_init
argument_list|(
name|pi
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
name|pci_populate_msixcap
argument_list|(
operator|&
name|msixcap
argument_list|,
name|msgnum
argument_list|,
name|barnum
argument_list|,
name|tab_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* allocate memory for MSI-X Table and PBA */
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
name|barnum
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|tab_size
operator|+
name|pi
operator|->
name|pi_msix
operator|.
name|pba_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msixcap
argument_list|,
sizeof|sizeof
argument_list|(
name|msixcap
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|msixcap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint16_t
name|msgctrl
decl_stmt|,
name|rwmask
decl_stmt|;
name|int
name|off
decl_stmt|,
name|table_bar
decl_stmt|;
name|off
operator|=
name|offset
operator|-
name|capoff
expr_stmt|;
name|table_bar
operator|=
name|pi
operator|->
name|pi_msix
operator|.
name|table_bar
expr_stmt|;
comment|/* Message Control Register */
if|if
condition|(
name|off
operator|==
literal|2
operator|&&
name|bytes
operator|==
literal|2
condition|)
block|{
name|rwmask
operator|=
name|PCIM_MSIXCTRL_MSIX_ENABLE
operator||
name|PCIM_MSIXCTRL_FUNCTION_MASK
expr_stmt|;
name|msgctrl
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|msgctrl
operator|&=
operator|~
name|rwmask
expr_stmt|;
name|msgctrl
operator||=
name|val
operator|&
name|rwmask
expr_stmt|;
name|val
operator|=
name|msgctrl
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|enabled
operator|=
name|val
operator|&
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pi
operator|->
name|pi_msix
operator|.
name|function_mask
operator|=
name|val
operator|&
name|PCIM_MSIXCTRL_FUNCTION_MASK
expr_stmt|;
block|}
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msicap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint16_t
name|msgctrl
decl_stmt|,
name|rwmask
decl_stmt|,
name|msgdata
decl_stmt|,
name|mme
decl_stmt|;
name|uint32_t
name|addrlo
decl_stmt|;
comment|/* 	 * If guest is writing to the message control register make sure 	 * we do not overwrite read-only fields. 	 */
if|if
condition|(
operator|(
name|offset
operator|-
name|capoff
operator|)
operator|==
literal|2
operator|&&
name|bytes
operator|==
literal|2
condition|)
block|{
name|rwmask
operator|=
name|PCIM_MSICTRL_MME_MASK
operator||
name|PCIM_MSICTRL_MSI_ENABLE
expr_stmt|;
name|msgctrl
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|msgctrl
operator|&=
operator|~
name|rwmask
expr_stmt|;
name|msgctrl
operator||=
name|val
operator|&
name|rwmask
expr_stmt|;
name|val
operator|=
name|msgctrl
expr_stmt|;
name|addrlo
operator|=
name|pci_get_cfgdata32
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgctrl
operator|&
name|PCIM_MSICTRL_64BIT
condition|)
name|msgdata
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|12
argument_list|)
expr_stmt|;
else|else
name|msgdata
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* 		 * XXX check delivery mode, destination mode etc 		 */
name|mme
operator|=
name|msgctrl
operator|&
name|PCIM_MSICTRL_MME_MASK
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|=
name|msgctrl
operator|&
name|PCIM_MSICTRL_MSI_ENABLE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
condition|)
block|{
name|pi
operator|->
name|pi_msi
operator|.
name|cpu
operator|=
operator|(
name|addrlo
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|vector
operator|=
name|msgdata
operator|&
literal|0xff
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|msgnum
operator|=
literal|1
operator|<<
operator|(
name|mme
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|pi_msi
operator|.
name|cpu
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|vector
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_msi
operator|.
name|msgnum
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pciecap_cfgwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|capoff
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
comment|/* XXX don't write to the readonly parts */
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PCIECAP_VERSION
value|0x2
end_define

begin_function
name|int
name|pci_emul_add_pciecap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|pciecap
name|pciecap
decl_stmt|;
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pciecap
argument_list|)
operator|==
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|PCIEM_TYPE_ROOT_PORT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|pciecap
argument_list|,
sizeof|sizeof
argument_list|(
name|pciecap
argument_list|)
argument_list|)
expr_stmt|;
name|pciecap
operator|.
name|capid
operator|=
name|PCIY_EXPRESS
expr_stmt|;
name|pciecap
operator|.
name|pcie_capabilities
operator|=
name|PCIECAP_VERSION
operator||
name|PCIEM_TYPE_ROOT_PORT
expr_stmt|;
name|pciecap
operator|.
name|link_capabilities
operator|=
literal|0x411
expr_stmt|;
comment|/* gen1, x1 */
name|pciecap
operator|.
name|link_status
operator|=
literal|0x11
expr_stmt|;
comment|/* gen1, x1 */
name|err
operator|=
name|pci_emul_add_capability
argument_list|(
name|pi
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pciecap
argument_list|,
sizeof|sizeof
argument_list|(
name|pciecap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function assumes that 'coff' is in the capabilities region of the  * config space.  */
end_comment

begin_function
specifier|static
name|void
name|pci_emul_capwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|capid
decl_stmt|;
name|uint8_t
name|capoff
decl_stmt|,
name|nextoff
decl_stmt|;
comment|/* Do not allow un-aligned writes */
if|if
condition|(
operator|(
name|offset
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Find the capability that we want to update */
name|capoff
operator|=
name|CAP_START_OFFSET
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|capid
operator|==
name|PCIY_RESERVED
condition|)
break|break;
name|nextoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|capoff
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|capoff
operator|&&
name|offset
operator|<
name|nextoff
condition|)
break|break;
name|capoff
operator|=
name|nextoff
expr_stmt|;
block|}
name|assert
argument_list|(
name|offset
operator|>=
name|capoff
argument_list|)
expr_stmt|;
comment|/* 	 * Capability ID and Next Capability Pointer are readonly 	 */
if|if
condition|(
name|offset
operator|==
name|capoff
operator|||
name|offset
operator|==
name|capoff
operator|+
literal|1
condition|)
return|return;
switch|switch
condition|(
name|capid
condition|)
block|{
case|case
name|PCIY_MSI
case|:
name|msicap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIY_MSIX
case|:
name|msixcap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIY_EXPRESS
case|:
name|pciecap_cfgwrite
argument_list|(
name|pi
argument_list|,
name|capoff
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_iscap
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|uint16_t
name|sts
decl_stmt|;
name|uint8_t
name|capid
decl_stmt|,
name|lastoff
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|sts
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sts
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|lastoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CAP_PTR
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|assert
argument_list|(
operator|(
name|lastoff
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|capid
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|lastoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|capid
operator|==
name|PCIY_RESERVED
condition|)
break|break;
name|lastoff
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|lastoff
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>=
name|CAP_START_OFFSET
operator|&&
name|offset
operator|<=
name|lastoff
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_fallback_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|dir
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|long
name|arg2
parameter_list|)
block|{
comment|/* 	 * Ignore writes; return 0xff's for reads. The mem read code 	 * will take care of truncating to the correct size. 	 */
if|if
condition|(
name|dir
operator|==
name|MEM_F_READ
condition|)
block|{
operator|*
name|val
operator|=
literal|0xffffffffffffffff
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_pci
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|mem_range
name|memp
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pde
decl_stmt|;
name|struct
name|slotinfo
modifier|*
name|si
decl_stmt|;
name|size_t
name|lowmem
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|func
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pci_emul_iobase
operator|=
name|PCI_EMUL_IOBASE
expr_stmt|;
name|pci_emul_membase32
operator|=
name|vm_get_lowmem_limit
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|pci_emul_membase64
operator|=
name|PCI_EMUL_MEMBASE64
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXSLOTS
condition|;
name|slot
operator|++
control|)
block|{
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<
name|MAXFUNCS
condition|;
name|func
operator|++
control|)
block|{
name|si
operator|=
operator|&
name|pci_slotinfo
index|[
name|slot
index|]
index|[
name|func
index|]
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_name
operator|!=
name|NULL
condition|)
block|{
name|pde
operator|=
name|pci_emul_finddev
argument_list|(
name|si
operator|->
name|si_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
name|NULL
condition|)
block|{
name|pci_emul_init
argument_list|(
name|ctx
argument_list|,
name|pde
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|si
operator|->
name|si_param
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Allow ISA IRQs 5,10,11,12, and 15 to be available for 	 * generic use 	 */
name|lirq
index|[
literal|5
index|]
operator|.
name|li_generic
operator|=
literal|1
expr_stmt|;
name|lirq
index|[
literal|10
index|]
operator|.
name|li_generic
operator|=
literal|1
expr_stmt|;
name|lirq
index|[
literal|11
index|]
operator|.
name|li_generic
operator|=
literal|1
expr_stmt|;
name|lirq
index|[
literal|12
index|]
operator|.
name|li_generic
operator|=
literal|1
expr_stmt|;
name|lirq
index|[
literal|15
index|]
operator|.
name|li_generic
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The guest physical memory map looks like the following: 	 * [0,		    lowmem)		guest system memory 	 * [lowmem,	    lowmem_limit)	memory hole (may be absent) 	 * [lowmem_limit,   4GB)		PCI hole (32-bit BAR allocation) 	 * [4GB,	    4GB + highmem) 	 * 	 * Accesses to memory addresses that are not allocated to system 	 * memory or PCI devices return 0xff's. 	 */
name|error
operator|=
name|vm_get_memory_seg
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
operator|&
name|lowmem
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|memp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mem_range
argument_list|)
argument_list|)
expr_stmt|;
name|memp
operator|.
name|name
operator|=
literal|"PCI hole"
expr_stmt|;
name|memp
operator|.
name|flags
operator|=
name|MEM_F_RW
expr_stmt|;
name|memp
operator|.
name|base
operator|=
name|lowmem
expr_stmt|;
name|memp
operator|.
name|size
operator|=
operator|(
literal|4ULL
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|)
operator|-
name|lowmem
expr_stmt|;
name|memp
operator|.
name|handler
operator|=
name|pci_emul_fallback_handler
expr_stmt|;
name|error
operator|=
name|register_mem_fallback
argument_list|(
operator|&
name|memp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pci_msi_enabled
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msi_msgnum
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
condition|)
return|return
operator|(
name|pi
operator|->
name|pi_msi
operator|.
name|msgnum
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_msix_enabled
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
name|pi
operator|->
name|pi_msix
operator|.
name|enabled
operator|&&
operator|!
name|pi
operator|->
name|pi_msi
operator|.
name|enabled
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_generate_msix
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|msix_table_entry
modifier|*
name|mte
decl_stmt|;
if|if
condition|(
operator|!
name|pci_msix_enabled
argument_list|(
name|pi
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pi
operator|->
name|pi_msix
operator|.
name|function_mask
condition|)
return|return;
if|if
condition|(
name|index
operator|>=
name|pi
operator|->
name|pi_msix
operator|.
name|table_count
condition|)
return|return;
name|mte
operator|=
operator|&
name|pi
operator|->
name|pi_msix
operator|.
name|table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|mte
operator|->
name|vector_control
operator|&
name|PCIM_MSIX_VCTRL_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX Set PBA bit if interrupt is disabled */
name|vm_lapic_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
operator|(
name|mte
operator|->
name|addr
operator|>>
literal|12
operator|)
operator|&
literal|0xff
argument_list|,
name|mte
operator|->
name|msg_data
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pci_generate_msi
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|pci_msi_enabled
argument_list|(
name|pi
argument_list|)
operator|&&
name|msg
operator|<
name|pci_msi_msgnum
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|vm_lapic_irq
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_msi
operator|.
name|cpu
argument_list|,
name|pi
operator|->
name|pi_msi
operator|.
name|vector
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pci_is_legacy
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
return|return
operator|(
name|pci_slotinfo
index|[
name|pi
operator|->
name|pi_slot
index|]
index|[
name|pi
operator|->
name|pi_func
index|]
operator|.
name|si_legacy
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pci_lintr_alloc
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|vec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|vec
operator|<
name|NLIRQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLIRQ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lirq
index|[
name|i
index|]
operator|.
name|li_generic
operator|&&
name|lirq
index|[
name|i
index|]
operator|.
name|li_owner
operator|==
name|NULL
condition|)
block|{
name|vec
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|lirq
index|[
name|vec
index|]
operator|.
name|li_owner
operator|!=
name|NULL
condition|)
block|{
name|vec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|vec
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lirq
index|[
name|vec
index|]
operator|.
name|li_owner
operator|=
name|pi
expr_stmt|;
name|pi
operator|->
name|pi_lintr_pin
operator|=
name|vec
expr_stmt|;
return|return
operator|(
name|vec
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_lintr_request
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|vec
parameter_list|)
block|{
name|vec
operator|=
name|pci_lintr_alloc
argument_list|(
name|pi
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_INTLINE
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pci_lintr_assert
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|assert
argument_list|(
name|pi
operator|->
name|pi_lintr_pin
argument_list|)
expr_stmt|;
name|ioapic_assert_pin
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_lintr_pin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pci_lintr_deassert
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|)
block|{
name|assert
argument_list|(
name|pi
operator|->
name|pi_lintr_pin
argument_list|)
expr_stmt|;
name|ioapic_deassert_pin
argument_list|(
name|pi
operator|->
name|pi_vmctx
argument_list|,
name|pi
operator|->
name|pi_lintr_pin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if the emulated device in 'slot' is a multi-function device.  * Return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pci_emul_is_mfdev
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
name|int
name|f
decl_stmt|,
name|numfuncs
decl_stmt|;
name|numfuncs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|MAXFUNCS
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|pci_slotinfo
index|[
name|slot
index|]
index|[
name|f
index|]
operator|.
name|si_devi
operator|!=
name|NULL
condition|)
block|{
name|numfuncs
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|numfuncs
operator|>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the PCIM_MFDEV bit is properly set (or unset) depending on  * whether or not is a multi-function being emulated in the pci 'slot'.  */
end_comment

begin_function
specifier|static
name|void
name|pci_emul_hdrtype_fixup
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|rv
parameter_list|)
block|{
name|int
name|mfdev
decl_stmt|;
if|if
condition|(
name|off
operator|<=
name|PCIR_HDRTYPE
operator|&&
name|off
operator|+
name|bytes
operator|>
name|PCIR_HDRTYPE
condition|)
block|{
name|mfdev
operator|=
name|pci_emul_is_mfdev
argument_list|(
name|slot
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
operator|*
name|rv
operator|&=
operator|~
name|PCIM_MFDEV
expr_stmt|;
if|if
condition|(
name|mfdev
condition|)
block|{
operator|*
name|rv
operator||=
name|PCIM_MFDEV
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
operator|*
name|rv
operator|&=
operator|~
operator|(
name|PCIM_MFDEV
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|mfdev
condition|)
block|{
operator|*
name|rv
operator||=
operator|(
name|PCIM_MFDEV
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|cfgbus
decl_stmt|,
name|cfgslot
decl_stmt|,
name|cfgfunc
decl_stmt|,
name|cfgoff
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pci_emul_cfgaddr
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
name|assert
argument_list|(
operator|!
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|x
operator|=
operator|*
name|eax
expr_stmt|;
name|cfgoff
operator|=
name|x
operator|&
name|PCI_REGMAX
expr_stmt|;
name|cfgfunc
operator|=
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
name|PCI_FUNCMAX
expr_stmt|;
name|cfgslot
operator|=
operator|(
name|x
operator|>>
literal|11
operator|)
operator|&
name|PCI_SLOTMAX
expr_stmt|;
name|cfgbus
operator|=
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
name|PCI_BUSMAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgaddr
argument_list|,
name|CONF1_ADDR_PORT
argument_list|,
name|IOPORT_F_OUT
argument_list|,
name|pci_emul_cfgaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint32_t
name|bits_changed
parameter_list|(
name|uint32_t
name|old
parameter_list|,
name|uint32_t
name|new
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
return|return
operator|(
operator|(
name|old
operator|^
name|new
operator|)
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_emul_cmdwrite
parameter_list|(
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|uint32_t
name|new
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|old
decl_stmt|;
comment|/* 	 * The command register is at an offset of 4 bytes and thus the 	 * guest could write 1, 2 or 4 bytes starting at this offset. 	 */
name|old
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
comment|/* stash old value */
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|new
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* update config */
name|new
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
comment|/* get updated value */
comment|/* 	 * If the MMIO or I/O address space decoding has changed then 	 * register/unregister all BARs that decode that address space. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCI_BARMAX
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
case|case
name|PCIBAR_MEMHI64
case|:
break|break;
case|case
name|PCIBAR_IO
case|:
comment|/* I/O address space decoding changed? */
if|if
condition|(
name|bits_changed
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|PCIM_CMD_PORTEN
argument_list|)
condition|)
block|{
if|if
condition|(
name|porten
argument_list|(
name|pi
argument_list|)
condition|)
name|register_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|unregister_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM32
case|:
case|case
name|PCIBAR_MEM64
case|:
comment|/* MMIO address space decoding changed? */
if|if
condition|(
name|bits_changed
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|PCIM_CMD_MEMEN
argument_list|)
condition|)
block|{
if|if
condition|(
name|memen
argument_list|(
name|pi
argument_list|)
condition|)
name|register_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|unregister_bar
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pci_emul_cfgdata
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_devinst
modifier|*
name|pi
decl_stmt|;
name|struct
name|pci_devemu
modifier|*
name|pe
decl_stmt|;
name|int
name|coff
decl_stmt|,
name|idx
decl_stmt|,
name|needcfg
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|,
name|bar
decl_stmt|,
name|mask
decl_stmt|;
name|assert
argument_list|(
name|bytes
operator|==
literal|1
operator|||
name|bytes
operator|==
literal|2
operator|||
name|bytes
operator|==
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfgbus
operator|==
literal|0
condition|)
name|pi
operator|=
name|pci_slotinfo
index|[
name|cfgslot
index|]
index|[
name|cfgfunc
index|]
operator|.
name|si_devi
expr_stmt|;
else|else
name|pi
operator|=
name|NULL
expr_stmt|;
name|coff
operator|=
name|cfgoff
operator|+
operator|(
name|port
operator|-
name|CONF1_DATA_PORT
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("pcicfg-%s from 0x%0x of %d bytes (%d/%d/%d)\n\r", 		in ? "read" : "write", coff, bytes, cfgbus, cfgslot, cfgfunc);
endif|#
directive|endif
comment|/* 	 * Just return if there is no device at this cfgslot:cfgfunc or 	 * if the guest is doing an un-aligned access 	 */
if|if
condition|(
name|pi
operator|==
name|NULL
operator|||
operator|(
name|coff
operator|&
operator|(
name|bytes
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
condition|)
operator|*
name|eax
operator|=
literal|0xffffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pe
operator|=
name|pi
operator|->
name|pi_d
expr_stmt|;
comment|/* 	 * Config read 	 */
if|if
condition|(
name|in
condition|)
block|{
comment|/* Let the device emulation override the default handler */
if|if
condition|(
name|pe
operator|->
name|pe_cfgread
operator|!=
name|NULL
condition|)
block|{
name|needcfg
operator|=
name|pe
operator|->
name|pe_cfgread
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|needcfg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|needcfg
condition|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|1
condition|)
operator|*
name|eax
operator|=
name|pci_get_cfgdata8
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|2
condition|)
operator|*
name|eax
operator|=
name|pci_get_cfgdata16
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
expr_stmt|;
else|else
operator|*
name|eax
operator|=
name|pci_get_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
expr_stmt|;
block|}
name|pci_emul_hdrtype_fixup
argument_list|(
name|cfgslot
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
name|eax
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Let the device emulation override the default handler */
if|if
condition|(
name|pe
operator|->
name|pe_cfgwrite
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|pe
operator|->
name|pe_cfgwrite
call|)
argument_list|(
name|ctx
argument_list|,
name|vcpu
argument_list|,
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Special handling for write to BAR registers 		 */
if|if
condition|(
name|coff
operator|>=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|&&
name|coff
operator|<
name|PCIR_BAR
argument_list|(
name|PCI_BARMAX
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* 			 * Ignore writes to BAR registers that are not 			 * 4-byte aligned. 			 */
if|if
condition|(
name|bytes
operator|!=
literal|4
operator|||
operator|(
name|coff
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|idx
operator|=
operator|(
name|coff
operator|-
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PCIBAR_NONE
case|:
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
operator|=
name|bar
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCIBAR_IO
case|:
name|addr
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|addr
operator|&=
literal|0xffff
expr_stmt|;
name|bar
operator|=
name|addr
operator||
name|PCIM_BAR_IO_SPACE
expr_stmt|;
comment|/* 				 * Register the new BAR value for interception 				 */
if|if
condition|(
name|addr
operator|!=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
argument_list|,
name|PCIBAR_IO
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM32
case|:
name|addr
operator|=
name|bar
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|bar
operator||=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_32
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
argument_list|,
name|PCIBAR_MEM32
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEM64
case|:
name|addr
operator|=
name|bar
operator|=
operator|*
name|eax
operator|&
name|mask
expr_stmt|;
name|bar
operator||=
name|PCIM_BAR_MEM_SPACE
operator||
name|PCIM_BAR_MEM_64
operator||
name|PCIM_BAR_MEM_PREFETCH
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|uint32_t
operator|)
name|pi
operator|->
name|pi_bar
index|[
name|idx
index|]
operator|.
name|addr
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
argument_list|,
name|PCIBAR_MEM64
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCIBAR_MEMHI64
case|:
name|mask
operator|=
operator|~
operator|(
name|pi
operator|->
name|pi_bar
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|addr
operator|=
operator|(
operator|(
name|uint64_t
operator|)
operator|*
name|eax
operator|<<
literal|32
operator|)
operator|&
name|mask
expr_stmt|;
name|bar
operator|=
name|addr
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
name|bar
operator|!=
name|pi
operator|->
name|pi_bar
index|[
name|idx
operator|-
literal|1
index|]
operator|.
name|addr
operator|>>
literal|32
condition|)
block|{
name|update_bar_address
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|PCIBAR_MEMHI64
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|pci_set_cfgdata32
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pci_emul_iscap
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|)
condition|)
block|{
name|pci_emul_capwrite
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
name|bytes
argument_list|,
operator|*
name|eax
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff
operator|==
name|PCIR_COMMAND
condition|)
block|{
name|pci_emul_cmdwrite
argument_list|(
name|pi
argument_list|,
operator|*
name|eax
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CFGWRITE
argument_list|(
name|pi
argument_list|,
name|coff
argument_list|,
operator|*
name|eax
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|0
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|1
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|2
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_cfgdata
argument_list|,
name|CONF1_DATA_PORT
operator|+
literal|3
argument_list|,
name|IOPORT_F_INOUT
argument_list|,
name|pci_emul_cfgdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * I/O ports to configure PCI IRQ routing. We ignore all writes to it.  */
end_comment

begin_function
specifier|static
name|int
name|pci_irq_port_handler
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|int
name|in
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|bytes
parameter_list|,
name|uint32_t
modifier|*
name|eax
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|assert
argument_list|(
name|in
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_irq
argument_list|,
literal|0xC00
argument_list|,
name|IOPORT_F_OUT
argument_list|,
name|pci_irq_port_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INOUT_PORT
argument_list|(
name|pci_irq
argument_list|,
literal|0xC01
argument_list|,
name|IOPORT_F_OUT
argument_list|,
name|pci_irq_port_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PCI_EMUL_TEST
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_EMUL_TEST
end_ifdef

begin_comment
comment|/*  * Define a dummy test device  */
end_comment

begin_define
define|#
directive|define
name|DIOSZ
value|20
end_define

begin_define
define|#
directive|define
name|DMEMSZ
value|4096
end_define

begin_struct
struct|struct
name|pci_emul_dsoftc
block|{
name|uint8_t
name|ioregs
index|[
name|DIOSZ
index|]
decl_stmt|;
name|uint8_t
name|memregs
index|[
name|DMEMSZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCI_EMUL_MSI_MSGS
value|4
end_define

begin_define
define|#
directive|define
name|PCI_EMUL_MSIX_MSGS
value|16
end_define

begin_function
specifier|static
name|int
name|pci_emul_dinit
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_emul_dsoftc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pci_emul_dsoftc
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_arg
operator|=
name|sc
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|0x10DD
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CLASS
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_add_msicap
argument_list|(
name|pi
argument_list|,
name|PCI_EMUL_MSI_MSGS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
name|PCIBAR_IO
argument_list|,
name|DIOSZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
literal|1
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|DMEMSZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_emul_diow
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
if|if
condition|(
name|baridx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DIOSZ
condition|)
block|{
name|printf
argument_list|(
literal|"diow: iow too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
operator|=
name|value
operator|&
literal|0xffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"diow: iow unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Special magic value to generate an interrupt 		 */
if|if
condition|(
name|offset
operator|==
literal|4
operator|&&
name|size
operator|==
literal|4
operator|&&
name|pci_msi_enabled
argument_list|(
name|pi
argument_list|)
condition|)
name|pci_generate_msi
argument_list|(
name|pi
argument_list|,
name|value
operator|%
name|pci_msi_msgnum
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xabcdef
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pci_msi_msgnum
argument_list|(
name|pi
argument_list|)
condition|;
name|i
operator|++
control|)
name|pci_generate_msi
argument_list|(
name|pi
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baridx
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DMEMSZ
condition|)
block|{
name|printf
argument_list|(
literal|"diow: memw too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"diow: memw unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * magic interrupt ?? 		 */
block|}
if|if
condition|(
name|baridx
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"diow: unknown bar idx %d\n"
argument_list|,
name|baridx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|pci_emul_dior
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|pci_emul_dsoftc
modifier|*
name|sc
init|=
name|pi
operator|->
name|pi_arg
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
if|if
condition|(
name|baridx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DIOSZ
condition|)
block|{
name|printf
argument_list|(
literal|"dior: ior too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioregs
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dior: ior unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baridx
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|DMEMSZ
condition|)
block|{
name|printf
argument_list|(
literal|"dior: memr too large, offset %ld size %d\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
name|value
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|memregs
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dior: ior unknown size %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baridx
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"dior: unknown bar idx %d\n"
argument_list|,
name|baridx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pci_devemu
name|pci_dummy
init|=
block|{
operator|.
name|pe_emu
operator|=
literal|"dummy"
block|,
operator|.
name|pe_init
operator|=
name|pci_emul_dinit
block|,
operator|.
name|pe_barwrite
operator|=
name|pci_emul_diow
block|,
operator|.
name|pe_barread
operator|=
name|pci_emul_dior
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCI_EMUL_SET
argument_list|(
name|pci_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_EMUL_TEST */
end_comment

end_unit

