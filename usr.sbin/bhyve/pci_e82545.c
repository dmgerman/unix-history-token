begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016 Alexander Motin<mav@FreeBSD.org>  * Copyright (c) 2015 Peter Grehan<grehan@freebsd.org>  * Copyright (c) 2013 Jeremiah Lott, Avere Systems  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WITHOUT_CAPSICUM
end_ifndef

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<md5.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<pthread_np.h>
end_include

begin_include
include|#
directive|include
file|"e1000_regs.h"
end_include

begin_include
include|#
directive|include
file|"e1000_defines.h"
end_include

begin_include
include|#
directive|include
file|"mii.h"
end_include

begin_include
include|#
directive|include
file|"bhyverun.h"
end_include

begin_include
include|#
directive|include
file|"pci_emul.h"
end_include

begin_include
include|#
directive|include
file|"mevent.h"
end_include

begin_comment
comment|/* Hardware/register definitions XXX: move some to common code. */
end_comment

begin_define
define|#
directive|define
name|E82545_VENDOR_ID_INTEL
value|0x8086
end_define

begin_define
define|#
directive|define
name|E82545_DEV_ID_82545EM_COPPER
value|0x100F
end_define

begin_define
define|#
directive|define
name|E82545_SUBDEV_ID
value|0x1008
end_define

begin_define
define|#
directive|define
name|E82545_REVISION_4
value|4
end_define

begin_define
define|#
directive|define
name|E82545_MDIC_DATA_MASK
value|0x0000FFFF
end_define

begin_define
define|#
directive|define
name|E82545_MDIC_OP_MASK
value|0x0c000000
end_define

begin_define
define|#
directive|define
name|E82545_MDIC_IE
value|0x20000000
end_define

begin_define
define|#
directive|define
name|E82545_EECD_FWE_DIS
value|0x00000010
end_define

begin_comment
comment|/* Flash writes disabled */
end_comment

begin_define
define|#
directive|define
name|E82545_EECD_FWE_EN
value|0x00000020
end_define

begin_comment
comment|/* Flash writes enabled */
end_comment

begin_define
define|#
directive|define
name|E82545_EECD_FWE_MASK
value|0x00000030
end_define

begin_comment
comment|/* Flash writes mask */
end_comment

begin_define
define|#
directive|define
name|E82545_BAR_REGISTER
value|0
end_define

begin_define
define|#
directive|define
name|E82545_BAR_REGISTER_LEN
value|(128*1024)
end_define

begin_define
define|#
directive|define
name|E82545_BAR_FLASH
value|1
end_define

begin_define
define|#
directive|define
name|E82545_BAR_FLASH_LEN
value|(64*1024)
end_define

begin_define
define|#
directive|define
name|E82545_BAR_IO
value|2
end_define

begin_define
define|#
directive|define
name|E82545_BAR_IO_LEN
value|8
end_define

begin_define
define|#
directive|define
name|E82545_IOADDR
value|0x00000000
end_define

begin_define
define|#
directive|define
name|E82545_IODATA
value|0x00000004
end_define

begin_define
define|#
directive|define
name|E82545_IO_REGISTER_MAX
value|0x0001FFFF
end_define

begin_define
define|#
directive|define
name|E82545_IO_FLASH_BASE
value|0x00080000
end_define

begin_define
define|#
directive|define
name|E82545_IO_FLASH_MAX
value|0x000FFFFF
end_define

begin_define
define|#
directive|define
name|E82545_ARRAY_ENTRY
parameter_list|(
name|reg
parameter_list|,
name|offset
parameter_list|)
value|(reg + (offset<<2))
end_define

begin_define
define|#
directive|define
name|E82545_RAR_MAX
value|15
end_define

begin_define
define|#
directive|define
name|E82545_MTA_MAX
value|127
end_define

begin_define
define|#
directive|define
name|E82545_VFTA_MAX
value|127
end_define

begin_comment
comment|/* Slightly modified from the driver versions, hardcoded for 3 opcode bits,  * followed by 6 address bits.  * TODO: make opcode bits and addr bits configurable?  * NVM Commands - Microwire */
end_comment

begin_define
define|#
directive|define
name|E82545_NVM_OPCODE_BITS
value|3
end_define

begin_define
define|#
directive|define
name|E82545_NVM_ADDR_BITS
value|6
end_define

begin_define
define|#
directive|define
name|E82545_NVM_DATA_BITS
value|16
end_define

begin_define
define|#
directive|define
name|E82545_NVM_OPADDR_BITS
value|(E82545_NVM_OPCODE_BITS + E82545_NVM_ADDR_BITS)
end_define

begin_define
define|#
directive|define
name|E82545_NVM_ADDR_MASK
value|((1<< E82545_NVM_ADDR_BITS)-1)
end_define

begin_define
define|#
directive|define
name|E82545_NVM_OPCODE_MASK
define|\
value|(((1<< E82545_NVM_OPCODE_BITS) - 1)<< E82545_NVM_ADDR_BITS)
end_define

begin_define
define|#
directive|define
name|E82545_NVM_OPCODE_READ
value|(0x6<< E82545_NVM_ADDR_BITS)
end_define

begin_comment
comment|/* read */
end_comment

begin_define
define|#
directive|define
name|E82545_NVM_OPCODE_WRITE
value|(0x5<< E82545_NVM_ADDR_BITS)
end_define

begin_comment
comment|/* write */
end_comment

begin_define
define|#
directive|define
name|E82545_NVM_OPCODE_ERASE
value|(0x7<< E82545_NVM_ADDR_BITS)
end_define

begin_comment
comment|/* erase */
end_comment

begin_define
define|#
directive|define
name|E82545_NVM_OPCODE_EWEN
value|(0x4<< E82545_NVM_ADDR_BITS)
end_define

begin_comment
comment|/* wr-enable */
end_comment

begin_define
define|#
directive|define
name|E82545_NVM_EEPROM_SIZE
value|64
end_define

begin_comment
comment|/* 64 * 16-bit values == 128K */
end_comment

begin_define
define|#
directive|define
name|E1000_ICR_SRPD
value|0x00010000
end_define

begin_comment
comment|/* This is an arbitrary number.  There is no hard limit on the chip. */
end_comment

begin_define
define|#
directive|define
name|I82545_MAX_TXSEGS
value|64
end_define

begin_comment
comment|/* Legacy receive descriptor */
end_comment

begin_struct
struct|struct
name|e1000_rx_desc
block|{
name|uint64_t
name|buffer_addr
decl_stmt|;
comment|/* Address of the descriptor's data buffer */
name|uint16_t
name|length
decl_stmt|;
comment|/* Length of data DMAed into data buffer */
name|uint16_t
name|csum
decl_stmt|;
comment|/* Packet checksum */
name|uint8_t
name|status
decl_stmt|;
comment|/* Descriptor status */
name|uint8_t
name|errors
decl_stmt|;
comment|/* Descriptor Errors */
name|uint16_t
name|special
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Transmit descriptor types */
end_comment

begin_define
define|#
directive|define
name|E1000_TXD_MASK
value|(E1000_TXD_CMD_DEXT | 0x00F00000)
end_define

begin_define
define|#
directive|define
name|E1000_TXD_TYP_L
value|(0)
end_define

begin_define
define|#
directive|define
name|E1000_TXD_TYP_C
value|(E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_C)
end_define

begin_define
define|#
directive|define
name|E1000_TXD_TYP_D
value|(E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)
end_define

begin_comment
comment|/* Legacy transmit descriptor */
end_comment

begin_struct
struct|struct
name|e1000_tx_desc
block|{
name|uint64_t
name|buffer_addr
decl_stmt|;
comment|/* Address of the descriptor's data buffer */
union|union
block|{
name|uint32_t
name|data
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|length
decl_stmt|;
comment|/* Data buffer length */
name|uint8_t
name|cso
decl_stmt|;
comment|/* Checksum offset */
name|uint8_t
name|cmd
decl_stmt|;
comment|/* Descriptor control */
block|}
name|flags
struct|;
block|}
name|lower
union|;
union|union
block|{
name|uint32_t
name|data
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|status
decl_stmt|;
comment|/* Descriptor status */
name|uint8_t
name|css
decl_stmt|;
comment|/* Checksum start */
name|uint16_t
name|special
decl_stmt|;
block|}
name|fields
struct|;
block|}
name|upper
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Context descriptor */
end_comment

begin_struct
struct|struct
name|e1000_context_desc
block|{
union|union
block|{
name|uint32_t
name|ip_config
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|ipcss
decl_stmt|;
comment|/* IP checksum start */
name|uint8_t
name|ipcso
decl_stmt|;
comment|/* IP checksum offset */
name|uint16_t
name|ipcse
decl_stmt|;
comment|/* IP checksum end */
block|}
name|ip_fields
struct|;
block|}
name|lower_setup
union|;
union|union
block|{
name|uint32_t
name|tcp_config
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|tucss
decl_stmt|;
comment|/* TCP checksum start */
name|uint8_t
name|tucso
decl_stmt|;
comment|/* TCP checksum offset */
name|uint16_t
name|tucse
decl_stmt|;
comment|/* TCP checksum end */
block|}
name|tcp_fields
struct|;
block|}
name|upper_setup
union|;
name|uint32_t
name|cmd_and_length
decl_stmt|;
union|union
block|{
name|uint32_t
name|data
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|status
decl_stmt|;
comment|/* Descriptor status */
name|uint8_t
name|hdr_len
decl_stmt|;
comment|/* Header length */
name|uint16_t
name|mss
decl_stmt|;
comment|/* Maximum segment size */
block|}
name|fields
struct|;
block|}
name|tcp_seg_setup
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data descriptor */
end_comment

begin_struct
struct|struct
name|e1000_data_desc
block|{
name|uint64_t
name|buffer_addr
decl_stmt|;
comment|/* Address of the descriptor's buffer address */
union|union
block|{
name|uint32_t
name|data
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|length
decl_stmt|;
comment|/* Data buffer length */
name|uint8_t
name|typ_len_ext
decl_stmt|;
name|uint8_t
name|cmd
decl_stmt|;
block|}
name|flags
struct|;
block|}
name|lower
union|;
union|union
block|{
name|uint32_t
name|data
decl_stmt|;
struct|struct
block|{
name|uint8_t
name|status
decl_stmt|;
comment|/* Descriptor status */
name|uint8_t
name|popts
decl_stmt|;
comment|/* Packet Options */
name|uint16_t
name|special
decl_stmt|;
block|}
name|fields
struct|;
block|}
name|upper
union|;
block|}
struct|;
end_struct

begin_union
union|union
name|e1000_tx_udesc
block|{
name|struct
name|e1000_tx_desc
name|td
decl_stmt|;
name|struct
name|e1000_context_desc
name|cd
decl_stmt|;
name|struct
name|e1000_data_desc
name|dd
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* Tx checksum info for a packet. */
end_comment

begin_struct
struct|struct
name|ck_info
block|{
name|int
name|ck_valid
decl_stmt|;
comment|/* ck_info is valid */
name|uint8_t
name|ck_start
decl_stmt|;
comment|/* start byte of cksum calcuation */
name|uint8_t
name|ck_off
decl_stmt|;
comment|/* offset of cksum insertion */
name|uint16_t
name|ck_len
decl_stmt|;
comment|/* length of cksum calc: 0 is to packet-end */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Debug printf  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|e82545_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|msg
parameter_list|,
name|params
modifier|...
parameter_list|)
value|if (e82545_debug) fprintf(stderr, "e82545: " msg, params)
end_define

begin_define
define|#
directive|define
name|WPRINTF
parameter_list|(
name|msg
parameter_list|,
name|params
modifier|...
parameter_list|)
value|fprintf(stderr, "e82545: " msg, params)
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
end_define

begin_comment
comment|/* s/w representation of the RAL/RAH regs */
end_comment

begin_struct
struct|struct
name|eth_uni
block|{
name|int
name|eu_valid
decl_stmt|;
name|int
name|eu_addrsel
decl_stmt|;
name|struct
name|ether_addr
name|eu_eth
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|e82545_softc
block|{
name|struct
name|pci_devinst
modifier|*
name|esc_pi
decl_stmt|;
name|struct
name|vmctx
modifier|*
name|esc_ctx
decl_stmt|;
name|struct
name|mevent
modifier|*
name|esc_mevp
decl_stmt|;
name|struct
name|mevent
modifier|*
name|esc_mevpitr
decl_stmt|;
name|pthread_mutex_t
name|esc_mtx
decl_stmt|;
name|struct
name|ether_addr
name|esc_mac
decl_stmt|;
name|int
name|esc_tapfd
decl_stmt|;
comment|/* General */
name|uint32_t
name|esc_CTRL
decl_stmt|;
comment|/* x0000 device ctl */
name|uint32_t
name|esc_FCAL
decl_stmt|;
comment|/* x0028 flow ctl addr lo */
name|uint32_t
name|esc_FCAH
decl_stmt|;
comment|/* x002C flow ctl addr hi */
name|uint32_t
name|esc_FCT
decl_stmt|;
comment|/* x0030 flow ctl type */
name|uint32_t
name|esc_VET
decl_stmt|;
comment|/* x0038 VLAN eth type */
name|uint32_t
name|esc_FCTTV
decl_stmt|;
comment|/* x0170 flow ctl tx timer */
name|uint32_t
name|esc_LEDCTL
decl_stmt|;
comment|/* x0E00 LED control */
name|uint32_t
name|esc_PBA
decl_stmt|;
comment|/* x1000 pkt buffer allocation */
comment|/* Interrupt control */
name|int
name|esc_irq_asserted
decl_stmt|;
name|uint32_t
name|esc_ICR
decl_stmt|;
comment|/* x00C0 cause read/clear */
name|uint32_t
name|esc_ITR
decl_stmt|;
comment|/* x00C4 intr throttling */
name|uint32_t
name|esc_ICS
decl_stmt|;
comment|/* x00C8 cause set */
name|uint32_t
name|esc_IMS
decl_stmt|;
comment|/* x00D0 mask set/read */
name|uint32_t
name|esc_IMC
decl_stmt|;
comment|/* x00D8 mask clear */
comment|/* Transmit */
name|union
name|e1000_tx_udesc
modifier|*
name|esc_txdesc
decl_stmt|;
name|struct
name|e1000_context_desc
name|esc_txctx
decl_stmt|;
name|pthread_t
name|esc_tx_tid
decl_stmt|;
name|pthread_cond_t
name|esc_tx_cond
decl_stmt|;
name|int
name|esc_tx_enabled
decl_stmt|;
name|int
name|esc_tx_active
decl_stmt|;
name|uint32_t
name|esc_TXCW
decl_stmt|;
comment|/* x0178 transmit config */
name|uint32_t
name|esc_TCTL
decl_stmt|;
comment|/* x0400 transmit ctl */
name|uint32_t
name|esc_TIPG
decl_stmt|;
comment|/* x0410 inter-packet gap */
name|uint16_t
name|esc_AIT
decl_stmt|;
comment|/* x0458 Adaptive Interframe Throttle */
name|uint64_t
name|esc_tdba
decl_stmt|;
comment|/* verified 64-bit desc table addr */
name|uint32_t
name|esc_TDBAL
decl_stmt|;
comment|/* x3800 desc table addr, low bits */
name|uint32_t
name|esc_TDBAH
decl_stmt|;
comment|/* x3804 desc table addr, hi 32-bits */
name|uint32_t
name|esc_TDLEN
decl_stmt|;
comment|/* x3808 # descriptors in bytes */
name|uint16_t
name|esc_TDH
decl_stmt|;
comment|/* x3810 desc table head idx */
name|uint16_t
name|esc_TDHr
decl_stmt|;
comment|/* internal read version of TDH */
name|uint16_t
name|esc_TDT
decl_stmt|;
comment|/* x3818 desc table tail idx */
name|uint32_t
name|esc_TIDV
decl_stmt|;
comment|/* x3820 intr delay */
name|uint32_t
name|esc_TXDCTL
decl_stmt|;
comment|/* x3828 desc control */
name|uint32_t
name|esc_TADV
decl_stmt|;
comment|/* x382C intr absolute delay */
comment|/* L2 frame acceptance */
name|struct
name|eth_uni
name|esc_uni
index|[
literal|16
index|]
decl_stmt|;
comment|/* 16 x unicast MAC addresses */
name|uint32_t
name|esc_fmcast
index|[
literal|128
index|]
decl_stmt|;
comment|/* Multicast filter bit-match */
name|uint32_t
name|esc_fvlan
index|[
literal|128
index|]
decl_stmt|;
comment|/* VLAN 4096-bit filter */
comment|/* Receive */
name|struct
name|e1000_rx_desc
modifier|*
name|esc_rxdesc
decl_stmt|;
name|pthread_cond_t
name|esc_rx_cond
decl_stmt|;
name|int
name|esc_rx_enabled
decl_stmt|;
name|int
name|esc_rx_active
decl_stmt|;
name|int
name|esc_rx_loopback
decl_stmt|;
name|uint32_t
name|esc_RCTL
decl_stmt|;
comment|/* x0100 receive ctl */
name|uint32_t
name|esc_FCRTL
decl_stmt|;
comment|/* x2160 flow cntl thresh, low */
name|uint32_t
name|esc_FCRTH
decl_stmt|;
comment|/* x2168 flow cntl thresh, hi */
name|uint64_t
name|esc_rdba
decl_stmt|;
comment|/* verified 64-bit desc table addr */
name|uint32_t
name|esc_RDBAL
decl_stmt|;
comment|/* x2800 desc table addr, low bits */
name|uint32_t
name|esc_RDBAH
decl_stmt|;
comment|/* x2804 desc table addr, hi 32-bits*/
name|uint32_t
name|esc_RDLEN
decl_stmt|;
comment|/* x2808 #descriptors */
name|uint16_t
name|esc_RDH
decl_stmt|;
comment|/* x2810 desc table head idx */
name|uint16_t
name|esc_RDT
decl_stmt|;
comment|/* x2818 desc table tail idx */
name|uint32_t
name|esc_RDTR
decl_stmt|;
comment|/* x2820 intr delay */
name|uint32_t
name|esc_RXDCTL
decl_stmt|;
comment|/* x2828 desc control */
name|uint32_t
name|esc_RADV
decl_stmt|;
comment|/* x282C intr absolute delay */
name|uint32_t
name|esc_RSRPD
decl_stmt|;
comment|/* x2C00 recv small packet detect */
name|uint32_t
name|esc_RXCSUM
decl_stmt|;
comment|/* x5000 receive cksum ctl */
comment|/* IO Port register access */
name|uint32_t
name|io_addr
decl_stmt|;
comment|/* Shadow copy of MDIC */
name|uint32_t
name|mdi_control
decl_stmt|;
comment|/* Shadow copy of EECD */
name|uint32_t
name|eeprom_control
decl_stmt|;
comment|/* Latest NVM in/out */
name|uint16_t
name|nvm_data
decl_stmt|;
name|uint16_t
name|nvm_opaddr
decl_stmt|;
comment|/* stats */
name|uint32_t
name|missed_pkt_count
decl_stmt|;
comment|/* dropped for no room in rx queue */
name|uint32_t
name|pkt_rx_by_size
index|[
literal|6
index|]
decl_stmt|;
name|uint32_t
name|pkt_tx_by_size
index|[
literal|6
index|]
decl_stmt|;
name|uint32_t
name|good_pkt_rx_count
decl_stmt|;
name|uint32_t
name|bcast_pkt_rx_count
decl_stmt|;
name|uint32_t
name|mcast_pkt_rx_count
decl_stmt|;
name|uint32_t
name|good_pkt_tx_count
decl_stmt|;
name|uint32_t
name|bcast_pkt_tx_count
decl_stmt|;
name|uint32_t
name|mcast_pkt_tx_count
decl_stmt|;
name|uint32_t
name|oversize_rx_count
decl_stmt|;
name|uint32_t
name|tso_tx_count
decl_stmt|;
name|uint64_t
name|good_octets_rx
decl_stmt|;
name|uint64_t
name|good_octets_tx
decl_stmt|;
name|uint64_t
name|missed_octets
decl_stmt|;
comment|/* counts missed and oversized */
name|uint8_t
name|nvm_bits
range|:
literal|6
decl_stmt|;
comment|/* number of bits remaining in/out */
name|uint8_t
name|nvm_mode
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|E82545_NVM_MODE_OPADDR
value|0x0
define|#
directive|define
name|E82545_NVM_MODE_DATAIN
value|0x1
define|#
directive|define
name|E82545_NVM_MODE_DATAOUT
value|0x2
comment|/* EEPROM data */
name|uint16_t
name|eeprom_data
index|[
name|E82545_NVM_EEPROM_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|e82545_reset
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e82545_rx_enable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e82545_rx_disable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e82545_tap_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|enum
name|ev_type
name|type
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e82545_tx_start
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e82545_tx_enable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e82545_tx_disable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|e82545_size_stat_index
parameter_list|(
name|uint32_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
literal|64
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>=
literal|1024
condition|)
block|{
return|return
literal|5
return|;
block|}
else|else
block|{
comment|/* should be 1-4 */
return|return
operator|(
name|ffs
argument_list|(
name|size
argument_list|)
operator|-
literal|6
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_init_eeprom
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|checksum
decl_stmt|,
name|i
decl_stmt|;
comment|/* mac addr */
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_MAC_ADDR
index|]
operator|=
operator|(
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|0
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_MAC_ADDR
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|2
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|3
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_MAC_ADDR
operator|+
literal|2
index|]
operator|=
operator|(
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* pci ids */
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_SUB_DEV_ID
index|]
operator|=
name|E82545_SUBDEV_ID
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_SUB_VEN_ID
index|]
operator|=
name|E82545_VENDOR_ID_INTEL
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_DEV_ID
index|]
operator|=
name|E82545_DEV_ID_82545EM_COPPER
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_VEN_ID
index|]
operator|=
name|E82545_VENDOR_ID_INTEL
expr_stmt|;
comment|/* fill in the checksum */
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
block|{
name|checksum
operator|+=
name|sc
operator|->
name|eeprom_data
index|[
name|i
index|]
expr_stmt|;
block|}
name|checksum
operator|=
name|NVM_SUM
operator|-
name|checksum
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|NVM_CHECKSUM_REG
index|]
operator|=
name|checksum
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"eeprom checksum: 0x%x\r\n"
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_write_mdi
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg_addr
parameter_list|,
name|uint8_t
name|phy_addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"Write mdi reg:0x%x phy:0x%x data: 0x%x\r\n"
argument_list|,
name|reg_addr
argument_list|,
name|phy_addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|e82545_read_mdi
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg_addr
parameter_list|,
name|uint8_t
name|phy_addr
parameter_list|)
block|{
comment|//DPRINTF("Read mdi reg:0x%x phy:0x%x\r\n", reg_addr, phy_addr);
switch|switch
condition|(
name|reg_addr
condition|)
block|{
case|case
name|PHY_STATUS
case|:
return|return
operator|(
name|MII_SR_LINK_STATUS
operator||
name|MII_SR_AUTONEG_CAPS
operator||
name|MII_SR_AUTONEG_COMPLETE
operator|)
return|;
case|case
name|PHY_AUTONEG_ADV
case|:
return|return
name|NWAY_AR_SELECTOR_FIELD
return|;
case|case
name|PHY_LP_ABILITY
case|:
return|return
literal|0
return|;
case|case
name|PHY_1000T_STATUS
case|:
return|return
operator|(
name|SR_1000T_LP_FD_CAPS
operator||
name|SR_1000T_REMOTE_RX_STATUS
operator||
name|SR_1000T_LOCAL_RX_STATUS
operator|)
return|;
case|case
name|PHY_ID1
case|:
return|return
operator|(
name|M88E1011_I_PHY_ID
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
return|;
case|case
name|PHY_ID2
case|:
return|return
operator|(
name|M88E1011_I_PHY_ID
operator||
name|E82545_REVISION_4
operator|)
operator|&
literal|0xFFFF
return|;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown mdi read reg:0x%x phy:0x%x\r\n"
argument_list|,
name|reg_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* not reached */
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_eecd_strobe
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Microwire state machine */
comment|/* 	DPRINTF("eeprom state machine srtobe " 		"0x%x 0x%x 0x%x 0x%x\r\n", 		sc->nvm_mode, sc->nvm_bits, 		sc->nvm_opaddr, sc->nvm_data);*/
if|if
condition|(
name|sc
operator|->
name|nvm_bits
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"eeprom state machine not expecting data! "
literal|"0x%x 0x%x 0x%x 0x%x\r\n"
argument_list|,
name|sc
operator|->
name|nvm_mode
argument_list|,
name|sc
operator|->
name|nvm_bits
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|,
name|sc
operator|->
name|nvm_data
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|nvm_bits
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nvm_mode
operator|==
name|E82545_NVM_MODE_DATAOUT
condition|)
block|{
comment|/* shifting out */
if|if
condition|(
name|sc
operator|->
name|nvm_data
operator|&
literal|0x8000
condition|)
block|{
name|sc
operator|->
name|eeprom_control
operator||=
name|E1000_EECD_DO
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|eeprom_control
operator|&=
operator|~
name|E1000_EECD_DO
expr_stmt|;
block|}
name|sc
operator|->
name|nvm_data
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nvm_bits
operator|==
literal|0
condition|)
block|{
comment|/* read done, back to opcode mode. */
name|sc
operator|->
name|nvm_opaddr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_OPADDR
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_OPADDR_BITS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|nvm_mode
operator|==
name|E82545_NVM_MODE_DATAIN
condition|)
block|{
comment|/* shifting in */
name|sc
operator|->
name|nvm_data
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eeprom_control
operator|&
name|E1000_EECD_DI
condition|)
block|{
name|sc
operator|->
name|nvm_data
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nvm_bits
operator|==
literal|0
condition|)
block|{
comment|/* eeprom write */
name|uint16_t
name|op
init|=
name|sc
operator|->
name|nvm_opaddr
operator|&
name|E82545_NVM_OPCODE_MASK
decl_stmt|;
name|uint16_t
name|addr
init|=
name|sc
operator|->
name|nvm_opaddr
operator|&
name|E82545_NVM_ADDR_MASK
decl_stmt|;
if|if
condition|(
name|op
operator|!=
name|E82545_NVM_OPCODE_WRITE
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Illegal eeprom write op 0x%x\r\n"
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|>=
name|E82545_NVM_EEPROM_SIZE
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Illegal eeprom write addr 0x%x\r\n"
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"eeprom write eeprom[0x%x] = 0x%x\r\n"
argument_list|,
name|addr
argument_list|,
name|sc
operator|->
name|nvm_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_data
index|[
name|addr
index|]
operator|=
name|sc
operator|->
name|nvm_data
expr_stmt|;
block|}
comment|/* back to opcode mode */
name|sc
operator|->
name|nvm_opaddr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_OPADDR
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_OPADDR_BITS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|nvm_mode
operator|==
name|E82545_NVM_MODE_OPADDR
condition|)
block|{
name|sc
operator|->
name|nvm_opaddr
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eeprom_control
operator|&
name|E1000_EECD_DI
condition|)
block|{
name|sc
operator|->
name|nvm_opaddr
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nvm_bits
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|op
init|=
name|sc
operator|->
name|nvm_opaddr
operator|&
name|E82545_NVM_OPCODE_MASK
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|E82545_NVM_OPCODE_EWEN
case|:
name|DPRINTF
argument_list|(
literal|"eeprom write enable: 0x%x\r\n"
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|)
expr_stmt|;
comment|/* back to opcode mode */
name|sc
operator|->
name|nvm_opaddr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_OPADDR
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_OPADDR_BITS
expr_stmt|;
break|break;
case|case
name|E82545_NVM_OPCODE_READ
case|:
block|{
name|uint16_t
name|addr
init|=
name|sc
operator|->
name|nvm_opaddr
operator|&
name|E82545_NVM_ADDR_MASK
decl_stmt|;
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_DATAOUT
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_DATA_BITS
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|E82545_NVM_EEPROM_SIZE
condition|)
block|{
name|sc
operator|->
name|nvm_data
operator|=
name|sc
operator|->
name|eeprom_data
index|[
name|addr
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"eeprom read: eeprom[0x%x] = 0x%x\r\n"
argument_list|,
name|addr
argument_list|,
name|sc
operator|->
name|nvm_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"eeprom illegal read: 0x%x\r\n"
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nvm_data
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|E82545_NVM_OPCODE_WRITE
case|:
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_DATAIN
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_DATA_BITS
expr_stmt|;
name|sc
operator|->
name|nvm_data
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"eeprom unknown op: 0x%x\r\r"
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|)
expr_stmt|;
comment|/* back to opcode mode */
name|sc
operator|->
name|nvm_opaddr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_OPADDR
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_OPADDR_BITS
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"eeprom state machine wrong state! "
literal|"0x%x 0x%x 0x%x 0x%x\r\n"
argument_list|,
name|sc
operator|->
name|nvm_mode
argument_list|,
name|sc
operator|->
name|nvm_bits
argument_list|,
name|sc
operator|->
name|nvm_opaddr
argument_list|,
name|sc
operator|->
name|nvm_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_itr_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|enum
name|ev_type
name|type
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|;
name|struct
name|e82545_softc
modifier|*
name|sc
init|=
name|param
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
name|new
operator|=
name|sc
operator|->
name|esc_ICR
operator|&
name|sc
operator|->
name|esc_IMS
expr_stmt|;
if|if
condition|(
name|new
operator|&&
operator|!
name|sc
operator|->
name|esc_irq_asserted
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"itr callback: lintr assert %x\r\n"
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_irq_asserted
operator|=
literal|1
expr_stmt|;
name|pci_lintr_assert
argument_list|(
name|sc
operator|->
name|esc_pi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mevent_delete
argument_list|(
name|sc
operator|->
name|esc_mevpitr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_mevpitr
operator|=
name|NULL
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_icr_assert
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"icr assert: 0x%x\r\n"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* 	 * An interrupt is only generated if bits are set that 	 * aren't already in the ICR, these bits are unmasked, 	 * and there isn't an interrupt already pending. 	 */
name|new
operator|=
name|bits
operator|&
operator|~
name|sc
operator|->
name|esc_ICR
operator|&
name|sc
operator|->
name|esc_IMS
expr_stmt|;
name|sc
operator|->
name|esc_ICR
operator||=
name|bits
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"icr assert: masked %x, ims %x\r\n"
argument_list|,
name|new
argument_list|,
name|sc
operator|->
name|esc_IMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|esc_mevpitr
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"icr assert: throttled %x, ims %x\r\n"
argument_list|,
name|new
argument_list|,
name|sc
operator|->
name|esc_IMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|esc_irq_asserted
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"icr assert: lintr assert %x\r\n"
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_irq_asserted
operator|=
literal|1
expr_stmt|;
name|pci_lintr_assert
argument_list|(
name|sc
operator|->
name|esc_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_ITR
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|esc_mevpitr
operator|=
name|mevent_add
argument_list|(
operator|(
name|sc
operator|->
name|esc_ITR
operator|+
literal|3905
operator|)
operator|/
literal|3906
argument_list|,
comment|/* 256ns -> 1ms */
name|EVF_TIMER
argument_list|,
name|e82545_itr_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_ims_change
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|;
comment|/* 	 * Changing the mask may allow previously asserted 	 * but masked interrupt requests to generate an interrupt. 	 */
name|new
operator|=
name|bits
operator|&
name|sc
operator|->
name|esc_ICR
operator|&
operator|~
name|sc
operator|->
name|esc_IMS
expr_stmt|;
name|sc
operator|->
name|esc_IMS
operator||=
name|bits
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"ims change: masked %x, ims %x\r\n"
argument_list|,
name|new
argument_list|,
name|sc
operator|->
name|esc_IMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|esc_mevpitr
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"ims change: throttled %x, ims %x\r\n"
argument_list|,
name|new
argument_list|,
name|sc
operator|->
name|esc_IMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|esc_irq_asserted
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"ims change: lintr assert %x\n\r"
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_irq_asserted
operator|=
literal|1
expr_stmt|;
name|pci_lintr_assert
argument_list|(
name|sc
operator|->
name|esc_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_ITR
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|esc_mevpitr
operator|=
name|mevent_add
argument_list|(
operator|(
name|sc
operator|->
name|esc_ITR
operator|+
literal|3905
operator|)
operator|/
literal|3906
argument_list|,
comment|/* 256ns -> 1ms */
name|EVF_TIMER
argument_list|,
name|e82545_itr_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_icr_deassert
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"icr deassert: 0x%x\r\n"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_ICR
operator|&=
operator|~
name|bits
expr_stmt|;
comment|/* 	 * If there are no longer any interrupt sources and there 	 * was an asserted interrupt, clear it 	 */
if|if
condition|(
name|sc
operator|->
name|esc_irq_asserted
operator|&&
operator|!
operator|(
name|sc
operator|->
name|esc_ICR
operator|&
name|sc
operator|->
name|esc_IMS
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"icr deassert: lintr deassert %x\r\n"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|pci_lintr_deassert
argument_list|(
name|sc
operator|->
name|esc_pi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_irq_asserted
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_intr_write
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"intr_write: off %x, val %x\n\r"
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|E1000_ICR
case|:
name|e82545_icr_deassert
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_ITR
case|:
name|sc
operator|->
name|esc_ITR
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_ICS
case|:
name|sc
operator|->
name|esc_ICS
operator|=
name|value
expr_stmt|;
comment|/* not used: store for debug */
name|e82545_icr_assert
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_IMS
case|:
name|e82545_ims_change
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_IMC
case|:
name|sc
operator|->
name|esc_IMC
operator|=
name|value
expr_stmt|;
comment|/* for debug */
name|sc
operator|->
name|esc_IMS
operator|&=
operator|~
name|value
expr_stmt|;
comment|// XXX clear interrupts if all ICR bits now masked
comment|// and interrupt was pending ?
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|e82545_intr_read
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint32_t
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"intr_read: off %x\n\r"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|E1000_ICR
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_ICR
expr_stmt|;
name|sc
operator|->
name|esc_ICR
operator|=
literal|0
expr_stmt|;
name|e82545_icr_deassert
argument_list|(
name|sc
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_ITR
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_ITR
expr_stmt|;
break|break;
case|case
name|E1000_ICS
case|:
comment|/* write-only register */
break|break;
case|case
name|E1000_IMS
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_IMS
expr_stmt|;
break|break;
case|case
name|E1000_IMC
case|:
comment|/* write-only register */
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_devctl
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|sc
operator|->
name|esc_CTRL
operator|=
name|val
operator|&
operator|~
name|E1000_CTRL_RST
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|E1000_CTRL_RST
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"e1k: s/w reset, ctl %x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|e82545_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* XXX check for phy reset ? */
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_rx_update_rdba
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX verify desc base/len within phys mem range */
name|sc
operator|->
name|esc_rdba
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|esc_RDBAH
operator|<<
literal|32
operator||
name|sc
operator|->
name|esc_RDBAL
expr_stmt|;
comment|/* Cache host mapping of guest descriptor array */
name|sc
operator|->
name|esc_rxdesc
operator|=
name|paddr_guest2host
argument_list|(
name|sc
operator|->
name|esc_ctx
argument_list|,
name|sc
operator|->
name|esc_rdba
argument_list|,
name|sc
operator|->
name|esc_RDLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_rx_ctl
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|on
decl_stmt|;
name|on
operator|=
operator|(
operator|(
name|val
operator|&
name|E1000_RCTL_EN
operator|)
operator|==
name|E1000_RCTL_EN
operator|)
expr_stmt|;
comment|/* Save RCTL after stripping reserved bits 31:27,24,21,14,11:10,0 */
name|sc
operator|->
name|esc_RCTL
operator|=
name|val
operator|&
operator|~
literal|0xF9204c01
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"rx_ctl - %s RCTL %x, val %x\n"
argument_list|,
name|on
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|sc
operator|->
name|esc_RCTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* state change requested */
if|if
condition|(
name|on
operator|!=
name|sc
operator|->
name|esc_rx_enabled
condition|)
block|{
if|if
condition|(
name|on
condition|)
block|{
comment|/* Catch disallowed/unimplemented settings */
comment|//assert(!(val& E1000_RCTL_LBM_TCVR));
if|if
condition|(
name|sc
operator|->
name|esc_RCTL
operator|&
name|E1000_RCTL_LBM_TCVR
condition|)
block|{
name|sc
operator|->
name|esc_rx_loopback
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|esc_rx_loopback
operator|=
literal|0
expr_stmt|;
block|}
name|e82545_rx_update_rdba
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|e82545_rx_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e82545_rx_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_rx_loopback
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_rdba
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_rxdesc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_tx_update_tdba
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX verify desc base/len within phys mem range */
name|sc
operator|->
name|esc_tdba
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|esc_TDBAH
operator|<<
literal|32
operator||
name|sc
operator|->
name|esc_TDBAL
expr_stmt|;
comment|/* Cache host mapping of guest descriptor array */
name|sc
operator|->
name|esc_txdesc
operator|=
name|paddr_guest2host
argument_list|(
name|sc
operator|->
name|esc_ctx
argument_list|,
name|sc
operator|->
name|esc_tdba
argument_list|,
name|sc
operator|->
name|esc_TDLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_tx_ctl
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|on
decl_stmt|;
name|on
operator|=
operator|(
operator|(
name|val
operator|&
name|E1000_TCTL_EN
operator|)
operator|==
name|E1000_TCTL_EN
operator|)
expr_stmt|;
comment|/* ignore TCTL_EN settings that don't change state */
if|if
condition|(
name|on
operator|==
name|sc
operator|->
name|esc_tx_enabled
condition|)
return|return;
if|if
condition|(
name|on
condition|)
block|{
name|e82545_tx_update_tdba
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|e82545_tx_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e82545_tx_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_tdba
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_txdesc
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Save TCTL value after stripping reserved bits 31:25,23,2,0 */
name|sc
operator|->
name|esc_TCTL
operator|=
name|val
operator|&
operator|~
literal|0xFE800005
expr_stmt|;
block|}
end_function

begin_function
name|int
name|e82545_bufsz
parameter_list|(
name|uint32_t
name|rctl
parameter_list|)
block|{
switch|switch
condition|(
name|rctl
operator|&
operator|(
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_SZ_256
operator|)
condition|)
block|{
case|case
operator|(
name|E1000_RCTL_SZ_2048
operator|)
case|:
return|return
operator|(
literal|2048
operator|)
return|;
case|case
operator|(
name|E1000_RCTL_SZ_1024
operator|)
case|:
return|return
operator|(
literal|1024
operator|)
return|;
case|case
operator|(
name|E1000_RCTL_SZ_512
operator|)
case|:
return|return
operator|(
literal|512
operator|)
return|;
case|case
operator|(
name|E1000_RCTL_SZ_256
operator|)
case|:
return|return
operator|(
literal|256
operator|)
return|;
case|case
operator|(
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_SZ_16384
operator|)
case|:
return|return
operator|(
literal|16384
operator|)
return|;
case|case
operator|(
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_SZ_8192
operator|)
case|:
return|return
operator|(
literal|8192
operator|)
return|;
case|case
operator|(
name|E1000_RCTL_BSEX
operator||
name|E1000_RCTL_SZ_4096
operator|)
case|:
return|return
operator|(
literal|4096
operator|)
return|;
block|}
return|return
operator|(
literal|256
operator|)
return|;
comment|/* Forbidden value. */
block|}
end_function

begin_decl_stmt
specifier|static
name|uint8_t
name|dummybuf
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX one packet at a time until this is debugged */
end_comment

begin_function
specifier|static
name|void
name|e82545_tap_callback
parameter_list|(
name|int
name|fd
parameter_list|,
name|enum
name|ev_type
name|type
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|e82545_softc
modifier|*
name|sc
init|=
name|param
decl_stmt|;
name|struct
name|e1000_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|iovec
name|vec
index|[
literal|64
index|]
decl_stmt|;
name|int
name|left
decl_stmt|,
name|len
decl_stmt|,
name|lim
decl_stmt|,
name|maxpktsz
decl_stmt|,
name|maxpktdesc
decl_stmt|,
name|bufsz
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|size
decl_stmt|;
name|uint32_t
name|cause
init|=
literal|0
decl_stmt|;
name|uint16_t
modifier|*
name|tp
decl_stmt|,
name|tag
decl_stmt|,
name|head
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"rx_run: head %x, tail %x\r\n"
argument_list|,
name|sc
operator|->
name|esc_RDH
argument_list|,
name|sc
operator|->
name|esc_RDT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|esc_rx_enabled
operator|||
name|sc
operator|->
name|esc_rx_loopback
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"rx disabled (!%d || %d) -- packet(s) dropped\r\n"
argument_list|,
name|sc
operator|->
name|esc_rx_enabled
argument_list|,
name|sc
operator|->
name|esc_rx_loopback
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
name|dummybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dummybuf
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{ 		}
goto|goto
name|done1
goto|;
block|}
name|bufsz
operator|=
name|e82545_bufsz
argument_list|(
name|sc
operator|->
name|esc_RCTL
argument_list|)
expr_stmt|;
name|maxpktsz
operator|=
operator|(
name|sc
operator|->
name|esc_RCTL
operator|&
name|E1000_RCTL_LPE
operator|)
condition|?
literal|16384
else|:
literal|1522
expr_stmt|;
name|maxpktdesc
operator|=
operator|(
name|maxpktsz
operator|+
name|bufsz
operator|-
literal|1
operator|)
operator|/
name|bufsz
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|esc_RDLEN
operator|/
literal|16
expr_stmt|;
name|head
operator|=
name|sc
operator|->
name|esc_RDH
expr_stmt|;
name|left
operator|=
operator|(
name|size
operator|+
name|sc
operator|->
name|esc_RDT
operator|-
name|head
operator|)
operator|%
name|size
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|maxpktdesc
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"rx overflow (%d< %d) -- packet(s) dropped\r\n"
argument_list|,
name|left
argument_list|,
name|maxpktdesc
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
name|dummybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dummybuf
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{ 		}
goto|goto
name|done1
goto|;
block|}
name|sc
operator|->
name|esc_rx_active
operator|=
literal|1
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|lim
operator|=
name|size
operator|/
literal|4
init|;
name|lim
operator|>
literal|0
operator|&&
name|left
operator|>=
name|maxpktdesc
condition|;
name|lim
operator|-=
name|n
control|)
block|{
comment|/* Grab rx descriptor pointed to by the head pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxpktdesc
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|esc_rxdesc
index|[
operator|(
name|head
operator|+
name|i
operator|)
operator|%
name|size
index|]
expr_stmt|;
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|paddr_guest2host
argument_list|(
name|sc
operator|->
name|esc_ctx
argument_list|,
name|rxd
operator|->
name|buffer_addr
argument_list|,
name|bufsz
argument_list|)
expr_stmt|;
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|bufsz
expr_stmt|;
block|}
name|len
operator|=
name|readv
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
name|vec
argument_list|,
name|maxpktdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"tap: readv() returned %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Adjust the packet length based on whether the CRC needs 		 * to be stripped or if the packet is less than the minimum 		 * eth packet size. 		 */
if|if
condition|(
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
name|len
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|esc_RCTL
operator|&
name|E1000_RCTL_SECRC
operator|)
condition|)
name|len
operator|+=
name|ETHER_CRC_LEN
expr_stmt|;
name|n
operator|=
operator|(
name|len
operator|+
name|bufsz
operator|-
literal|1
operator|)
operator|/
name|bufsz
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"packet read %d bytes, %d segs, head %d\r\n"
argument_list|,
name|len
argument_list|,
name|n
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* Apply VLAN filter. */
name|tp
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|+
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|esc_RCTL
operator|&
name|E1000_RCTL_VFE
operator|)
operator|&&
operator|(
name|ntohs
argument_list|(
name|tp
index|[
literal|0
index|]
argument_list|)
operator|==
name|sc
operator|->
name|esc_VET
operator|)
condition|)
block|{
name|tag
operator|=
name|ntohs
argument_list|(
name|tp
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0x0fff
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|esc_fvlan
index|[
name|tag
operator|>>
literal|5
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|tag
operator|&
literal|0x1f
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"known VLAN %d\r\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"unknown VLAN %d\r\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Update all consumed descriptors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|esc_rxdesc
index|[
operator|(
name|head
operator|+
name|i
operator|)
operator|%
name|size
index|]
expr_stmt|;
name|rxd
operator|->
name|length
operator|=
name|bufsz
expr_stmt|;
name|rxd
operator|->
name|csum
operator|=
literal|0
expr_stmt|;
name|rxd
operator|->
name|errors
operator|=
literal|0
expr_stmt|;
name|rxd
operator|->
name|special
operator|=
literal|0
expr_stmt|;
name|rxd
operator|->
name|status
operator|=
name|E1000_RXD_STAT_DD
expr_stmt|;
block|}
name|rxd
operator|=
operator|&
name|sc
operator|->
name|esc_rxdesc
index|[
operator|(
name|head
operator|+
name|i
operator|)
operator|%
name|size
index|]
expr_stmt|;
name|rxd
operator|->
name|length
operator|=
name|len
operator|%
name|bufsz
expr_stmt|;
name|rxd
operator|->
name|csum
operator|=
literal|0
expr_stmt|;
name|rxd
operator|->
name|errors
operator|=
literal|0
expr_stmt|;
name|rxd
operator|->
name|special
operator|=
literal|0
expr_stmt|;
comment|/* XXX signal no checksum for now */
name|rxd
operator|->
name|status
operator|=
name|E1000_RXD_STAT_PIF
operator||
name|E1000_RXD_STAT_IXSM
operator||
name|E1000_RXD_STAT_EOP
operator||
name|E1000_RXD_STAT_DD
expr_stmt|;
comment|/* Schedule receive interrupts. */
if|if
condition|(
name|len
operator|<=
name|sc
operator|->
name|esc_RSRPD
condition|)
block|{
name|cause
operator||=
name|E1000_ICR_SRPD
operator||
name|E1000_ICR_RXT0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: RDRT and RADV timers should be here. */
name|cause
operator||=
name|E1000_ICR_RXT0
expr_stmt|;
block|}
name|head
operator|=
operator|(
name|head
operator|+
name|n
operator|)
operator|%
name|size
expr_stmt|;
name|left
operator|-=
name|n
expr_stmt|;
block|}
name|done
label|:
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_rx_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_rx_enabled
operator|==
literal|0
condition|)
name|pthread_cond_signal
argument_list|(
operator|&
name|sc
operator|->
name|esc_rx_cond
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_RDH
operator|=
name|head
expr_stmt|;
comment|/* Respect E1000_RCTL_RDMTS */
name|left
operator|=
operator|(
name|size
operator|+
name|sc
operator|->
name|esc_RDT
operator|-
name|head
operator|)
operator|%
name|size
expr_stmt|;
if|if
condition|(
name|left
operator|<
operator|(
name|size
operator|>>
operator|(
operator|(
operator|(
name|sc
operator|->
name|esc_RCTL
operator|>>
literal|8
operator|)
operator|&
literal|3
operator|)
operator|+
literal|1
operator|)
operator|)
condition|)
name|cause
operator||=
name|E1000_ICR_RXDMT0
expr_stmt|;
comment|/* Assert all accumulated interrupts. */
if|if
condition|(
name|cause
operator|!=
literal|0
condition|)
name|e82545_icr_assert
argument_list|(
name|sc
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|done1
label|:
name|DPRINTF
argument_list|(
literal|"rx_run done: head %x, tail %x\r\n"
argument_list|,
name|sc
operator|->
name|esc_RDH
argument_list|,
name|sc
operator|->
name|esc_RDT
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|e82545_carry
parameter_list|(
name|uint32_t
name|sum
parameter_list|)
block|{
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xFFFF
operator|)
operator|+
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|sum
operator|>
literal|0xFFFF
condition|)
name|sum
operator|-=
literal|0xFFFF
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|e82545_buf_checksum
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|sum
init|=
literal|0
decl_stmt|;
comment|/* Checksum all the pairs of bytes first... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|&
operator|~
literal|1U
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
name|sum
operator|+=
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|i
operator|)
operator|)
expr_stmt|;
comment|/* 	 * If there's a single byte left over, checksum it, too. 	 * Network byte order is big-endian, so the remaining byte is 	 * the high byte. 	 */
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|sum
operator|+=
name|htons
argument_list|(
name|buf
index|[
name|i
index|]
operator|<<
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|e82545_carry
argument_list|(
name|sum
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|e82545_iov_checksum
parameter_list|(
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
name|iovcnt
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|now
decl_stmt|,
name|odd
decl_stmt|;
name|uint32_t
name|sum
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|;
comment|/* Skip completely unneeded vectors. */
while|while
condition|(
name|iovcnt
operator|>
literal|0
operator|&&
name|iov
operator|->
name|iov_len
operator|<=
name|off
operator|&&
name|off
operator|>
literal|0
condition|)
block|{
name|off
operator|-=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|iov
operator|++
expr_stmt|;
name|iovcnt
operator|--
expr_stmt|;
block|}
comment|/* Calculate checksum of requested range. */
name|odd
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|iovcnt
operator|>
literal|0
condition|)
block|{
name|now
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|iov
operator|->
name|iov_len
operator|-
name|off
argument_list|)
expr_stmt|;
name|s
operator|=
name|e82545_buf_checksum
argument_list|(
name|iov
operator|->
name|iov_base
operator|+
name|off
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|odd
condition|?
operator|(
name|s
operator|<<
literal|8
operator|)
else|:
name|s
expr_stmt|;
name|odd
operator|^=
operator|(
name|now
operator|&
literal|1
operator|)
expr_stmt|;
name|len
operator|-=
name|now
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|iov
operator|++
expr_stmt|;
name|iovcnt
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|e82545_carry
argument_list|(
name|sum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the transmit descriptor type.  */
end_comment

begin_function
name|int
name|e82545_txdesc_type
parameter_list|(
name|uint32_t
name|lower
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lower
operator|&
name|E1000_TXD_CMD_DEXT
condition|)
name|type
operator|=
name|lower
operator|&
name|E1000_TXD_MASK
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_transmit_checksum
parameter_list|(
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
name|iovcnt
parameter_list|,
name|struct
name|ck_info
modifier|*
name|ck
parameter_list|)
block|{
name|uint16_t
name|cksum
decl_stmt|;
name|int
name|cklen
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"tx cksum: iovcnt/s/off/len %d/%d/%d/%d\r\n"
argument_list|,
name|iovcnt
argument_list|,
name|ck
operator|->
name|ck_start
argument_list|,
name|ck
operator|->
name|ck_off
argument_list|,
name|ck
operator|->
name|ck_len
argument_list|)
expr_stmt|;
name|cklen
operator|=
name|ck
operator|->
name|ck_len
condition|?
name|ck
operator|->
name|ck_len
operator|-
name|ck
operator|->
name|ck_start
operator|+
literal|1
else|:
name|INT_MAX
expr_stmt|;
name|cksum
operator|=
name|e82545_iov_checksum
argument_list|(
name|iov
argument_list|,
name|iovcnt
argument_list|,
name|ck
operator|->
name|ck_start
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|+
name|ck
operator|->
name|ck_off
operator|)
operator|=
operator|~
name|cksum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_transmit_backend
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
name|iovcnt
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|esc_tapfd
operator|==
operator|-
literal|1
condition|)
return|return;
operator|(
name|void
operator|)
name|writev
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
name|iov
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_transmit_done
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|head
parameter_list|,
name|uint16_t
name|tail
parameter_list|,
name|uint16_t
name|dsize
parameter_list|,
name|int
modifier|*
name|tdwb
parameter_list|)
block|{
name|union
name|e1000_tx_udesc
modifier|*
name|dsc
decl_stmt|;
for|for
control|(
init|;
name|head
operator|!=
name|tail
condition|;
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|dsize
control|)
block|{
name|dsc
operator|=
operator|&
name|sc
operator|->
name|esc_txdesc
index|[
name|head
index|]
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_RS
condition|)
block|{
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|data
operator||=
name|E1000_TXD_STAT_DD
expr_stmt|;
operator|*
name|tdwb
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|e82545_transmit
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|head
parameter_list|,
name|uint16_t
name|tail
parameter_list|,
name|uint16_t
name|dsize
parameter_list|,
name|uint16_t
modifier|*
name|rhead
parameter_list|,
name|int
modifier|*
name|tdwb
parameter_list|)
block|{
name|uint8_t
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|hdrp
decl_stmt|;
name|struct
name|iovec
name|iovb
index|[
name|I82545_MAX_TXSEGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|iovec
name|tiov
index|[
name|I82545_MAX_TXSEGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|e1000_context_desc
modifier|*
name|cd
decl_stmt|;
name|struct
name|ck_info
name|ckinfo
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|union
name|e1000_tx_udesc
modifier|*
name|dsc
decl_stmt|;
name|int
name|desc
decl_stmt|,
name|dtype
decl_stmt|,
name|len
decl_stmt|,
name|ntype
decl_stmt|,
name|iovcnt
decl_stmt|,
name|tlen
decl_stmt|,
name|hdrlen
decl_stmt|,
name|vlen
decl_stmt|,
name|tcp
decl_stmt|,
name|tso
decl_stmt|;
name|int
name|mss
decl_stmt|,
name|paylen
decl_stmt|,
name|seg
decl_stmt|,
name|tiovcnt
decl_stmt|,
name|left
decl_stmt|,
name|now
decl_stmt|,
name|nleft
decl_stmt|,
name|nnow
decl_stmt|,
name|pv
decl_stmt|,
name|pvoff
decl_stmt|;
name|uint32_t
name|tcpsum
decl_stmt|,
name|tcpseq
decl_stmt|;
name|uint16_t
name|ipcs
decl_stmt|,
name|tcpcs
decl_stmt|,
name|ipid
decl_stmt|,
name|ohead
decl_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_valid
operator|=
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_valid
operator|=
literal|0
expr_stmt|;
name|iovcnt
operator|=
literal|0
expr_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
name|ntype
operator|=
literal|0
expr_stmt|;
name|tso
operator|=
literal|0
expr_stmt|;
name|ohead
operator|=
name|head
expr_stmt|;
comment|/* iovb[0/1] may be used for writable copy of headers. */
name|iov
operator|=
operator|&
name|iovb
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|desc
operator|=
literal|0
init|;
condition|;
name|desc
operator|++
operator|,
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|dsize
control|)
block|{
if|if
condition|(
name|head
operator|==
name|tail
condition|)
block|{
operator|*
name|rhead
operator|=
name|head
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dsc
operator|=
operator|&
name|sc
operator|->
name|esc_txdesc
index|[
name|head
index|]
expr_stmt|;
name|dtype
operator|=
name|e82545_txdesc_type
argument_list|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|E1000_TXD_TYP_C
case|:
name|DPRINTF
argument_list|(
literal|"tx ctxt desc idx %d: %016jx "
literal|"%08x%08x\r\n"
argument_list|,
name|head
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|buffer_addr
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|data
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* Save context and return */
name|sc
operator|->
name|esc_txctx
operator|=
name|dsc
operator|->
name|cd
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|E1000_TXD_TYP_L
case|:
name|DPRINTF
argument_list|(
literal|"tx legacy desc idx %d: %08x%08x\r\n"
argument_list|,
name|head
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|data
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* 				 * legacy cksum start valid in first descriptor 				 */
name|ntype
operator|=
name|dtype
expr_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|=
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|fields
operator|.
name|css
expr_stmt|;
break|break;
case|case
name|E1000_TXD_TYP_D
case|:
name|DPRINTF
argument_list|(
literal|"tx data desc idx %d: %08x%08x\r\n"
argument_list|,
name|head
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|data
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
argument_list|)
expr_stmt|;
name|ntype
operator|=
name|dtype
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* Descriptor type must be consistent */
name|assert
argument_list|(
name|dtype
operator|==
name|ntype
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"tx next desc idx %d: %08x%08x\r\n"
argument_list|,
name|head
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|data
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|dtype
operator|==
name|E1000_TXD_TYP_L
operator|)
condition|?
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|flags
operator|.
name|length
else|:
name|dsc
operator|->
name|dd
operator|.
name|lower
operator|.
name|data
operator|&
literal|0xFFFFF
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Strip checksum supplied by guest. */
if|if
condition|(
operator|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_EOP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_IFCS
operator|)
operator|==
literal|0
condition|)
name|len
operator|-=
literal|2
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|iovcnt
operator|<
name|I82545_MAX_TXSEGS
condition|)
block|{
name|iov
index|[
name|iovcnt
index|]
operator|.
name|iov_base
operator|=
name|paddr_guest2host
argument_list|(
name|sc
operator|->
name|esc_ctx
argument_list|,
name|dsc
operator|->
name|td
operator|.
name|buffer_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|iov
index|[
name|iovcnt
index|]
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
block|}
name|iovcnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Pull out info that is valid in the final descriptor 		 * and exit descriptor loop. 		 */
if|if
condition|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_EOP
condition|)
block|{
if|if
condition|(
name|dtype
operator|==
name|E1000_TXD_TYP_L
condition|)
block|{
if|if
condition|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_IC
condition|)
block|{
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_valid
operator|=
literal|1
expr_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_off
operator|=
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|flags
operator|.
name|cso
expr_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|cd
operator|=
operator|&
name|sc
operator|->
name|esc_txctx
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|dd
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_TSE
condition|)
name|tso
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|dd
operator|.
name|upper
operator|.
name|fields
operator|.
name|popts
operator|&
name|E1000_TXD_POPTS_IXSM
condition|)
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_valid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|dd
operator|.
name|upper
operator|.
name|fields
operator|.
name|popts
operator|&
name|E1000_TXD_POPTS_IXSM
operator|||
name|tso
condition|)
block|{
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|=
name|cd
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcss
expr_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_off
operator|=
name|cd
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcso
expr_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_len
operator|=
name|cd
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcse
expr_stmt|;
block|}
if|if
condition|(
name|dsc
operator|->
name|dd
operator|.
name|upper
operator|.
name|fields
operator|.
name|popts
operator|&
name|E1000_TXD_POPTS_TXSM
condition|)
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_valid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dsc
operator|->
name|dd
operator|.
name|upper
operator|.
name|fields
operator|.
name|popts
operator|&
name|E1000_TXD_POPTS_TXSM
operator|||
name|tso
condition|)
block|{
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|=
name|cd
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucss
expr_stmt|;
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_off
operator|=
name|cd
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucso
expr_stmt|;
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_len
operator|=
name|cd
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucse
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|iovcnt
operator|>
name|I82545_MAX_TXSEGS
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"tx too many descriptors (%d> %d) -- dropped\r\n"
argument_list|,
name|iovcnt
argument_list|,
name|I82545_MAX_TXSEGS
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|hdrlen
operator|=
name|vlen
operator|=
literal|0
expr_stmt|;
comment|/* Estimate writable space for VLAN header insertion. */
if|if
condition|(
operator|(
name|sc
operator|->
name|esc_CTRL
operator|&
name|E1000_CTRL_VME
operator|)
operator|&&
operator|(
name|dsc
operator|->
name|td
operator|.
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_VLE
operator|)
condition|)
block|{
name|hdrlen
operator|=
name|ETHER_ADDR_LEN
operator|*
literal|2
expr_stmt|;
name|vlen
operator|=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tso
condition|)
block|{
comment|/* Estimate required writable space for checksums. */
if|if
condition|(
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_valid
condition|)
name|hdrlen
operator|=
name|MAX
argument_list|(
name|hdrlen
argument_list|,
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_off
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_valid
condition|)
name|hdrlen
operator|=
name|MAX
argument_list|(
name|hdrlen
argument_list|,
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_off
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Round up writable space to the first vector. */
if|if
condition|(
name|hdrlen
operator|!=
literal|0
operator|&&
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>
name|hdrlen
operator|&&
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|<
name|hdrlen
operator|+
literal|100
condition|)
name|hdrlen
operator|=
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
else|else
block|{
comment|/* In case of TSO header length provided by software. */
name|hdrlen
operator|=
name|sc
operator|->
name|esc_txctx
operator|.
name|tcp_seg_setup
operator|.
name|fields
operator|.
name|hdr_len
expr_stmt|;
block|}
comment|/* Allocate, fill and prepend writable header vector. */
if|if
condition|(
name|hdrlen
operator|!=
literal|0
condition|)
block|{
name|hdr
operator|=
name|__builtin_alloca
argument_list|(
name|hdrlen
operator|+
name|vlen
argument_list|)
expr_stmt|;
name|hdr
operator|+=
name|vlen
expr_stmt|;
for|for
control|(
name|left
operator|=
name|hdrlen
operator|,
name|hdrp
operator|=
name|hdr
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|now
operator|,
name|hdrp
operator|+=
name|now
control|)
block|{
name|now
operator|=
name|MIN
argument_list|(
name|left
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdrp
argument_list|,
name|iov
operator|->
name|iov_base
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|+=
name|now
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|-=
name|now
expr_stmt|;
if|if
condition|(
name|iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
name|iov
operator|++
expr_stmt|;
name|iovcnt
operator|--
expr_stmt|;
block|}
block|}
name|iov
operator|--
expr_stmt|;
name|iovcnt
operator|++
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
name|hdr
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
name|hdrlen
expr_stmt|;
block|}
comment|/* Insert VLAN tag. */
if|if
condition|(
name|vlen
operator|!=
literal|0
condition|)
block|{
name|hdr
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|memmove
argument_list|(
name|hdr
argument_list|,
name|hdr
operator|+
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|ETHER_ADDR_LEN
operator|*
literal|2
argument_list|)
expr_stmt|;
name|hdrlen
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|hdr
index|[
name|ETHER_ADDR_LEN
operator|*
literal|2
operator|+
literal|0
index|]
operator|=
name|sc
operator|->
name|esc_VET
operator|>>
literal|8
expr_stmt|;
name|hdr
index|[
name|ETHER_ADDR_LEN
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|sc
operator|->
name|esc_VET
operator|&
literal|0xff
expr_stmt|;
name|hdr
index|[
name|ETHER_ADDR_LEN
operator|*
literal|2
operator|+
literal|2
index|]
operator|=
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|fields
operator|.
name|special
operator|>>
literal|8
expr_stmt|;
name|hdr
index|[
name|ETHER_ADDR_LEN
operator|*
literal|2
operator|+
literal|3
index|]
operator|=
name|dsc
operator|->
name|td
operator|.
name|upper
operator|.
name|fields
operator|.
name|special
operator|&
literal|0xff
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
name|hdr
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* Correct checksum offsets after VLAN tag insertion. */
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_off
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_len
operator|!=
literal|0
condition|)
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_len
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_off
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_len
operator|!=
literal|0
condition|)
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_len
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
comment|/* Simple non-TSO case. */
if|if
condition|(
operator|!
name|tso
condition|)
block|{
comment|/* Calculate checksums and transmit. */
if|if
condition|(
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_valid
condition|)
name|e82545_transmit_checksum
argument_list|(
name|iov
argument_list|,
name|iovcnt
argument_list|,
operator|&
name|ckinfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_valid
condition|)
name|e82545_transmit_checksum
argument_list|(
name|iov
argument_list|,
name|iovcnt
argument_list|,
operator|&
name|ckinfo
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|e82545_transmit_backend
argument_list|(
name|sc
argument_list|,
name|iov
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Doing TSO. */
name|tcp
operator|=
operator|(
name|sc
operator|->
name|esc_txctx
operator|.
name|cmd_and_length
operator|&
name|E1000_TXD_CMD_TCP
operator|)
operator|!=
literal|0
expr_stmt|;
name|mss
operator|=
name|sc
operator|->
name|esc_txctx
operator|.
name|tcp_seg_setup
operator|.
name|fields
operator|.
name|mss
expr_stmt|;
name|paylen
operator|=
operator|(
name|sc
operator|->
name|esc_txctx
operator|.
name|cmd_and_length
operator|&
literal|0x000fffff
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"tx %s segmentation offload %d+%d/%d bytes %d iovs\r\n"
argument_list|,
name|tcp
condition|?
literal|"TCP"
else|:
literal|"UDP"
argument_list|,
name|hdrlen
argument_list|,
name|paylen
argument_list|,
name|mss
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
name|ipid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|tcpseq
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|ipcs
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_off
index|]
expr_stmt|;
name|tcpcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_valid
condition|)
comment|/* Save partial pseudo-header checksum. */
name|tcpcs
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_off
index|]
expr_stmt|;
name|pv
operator|=
literal|1
expr_stmt|;
name|pvoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
operator|,
name|left
operator|=
name|paylen
init|;
name|left
operator|>
literal|0
condition|;
name|seg
operator|++
operator|,
name|left
operator|-=
name|now
control|)
block|{
name|now
operator|=
name|MIN
argument_list|(
name|left
argument_list|,
name|mss
argument_list|)
expr_stmt|;
comment|/* Construct IOVs for the segment. */
comment|/* Include whole original header. */
name|tiov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|hdr
expr_stmt|;
name|tiov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|hdrlen
expr_stmt|;
name|tiovcnt
operator|=
literal|1
expr_stmt|;
comment|/* Include respective part of payload IOV. */
for|for
control|(
name|nleft
operator|=
name|now
init|;
name|pv
operator|<
name|iovcnt
operator|&&
name|nleft
operator|>
literal|0
condition|;
name|nleft
operator|-=
name|nnow
control|)
block|{
name|nnow
operator|=
name|MIN
argument_list|(
name|nleft
argument_list|,
name|iov
index|[
name|pv
index|]
operator|.
name|iov_len
operator|-
name|pvoff
argument_list|)
expr_stmt|;
name|tiov
index|[
name|tiovcnt
index|]
operator|.
name|iov_base
operator|=
name|iov
index|[
name|pv
index|]
operator|.
name|iov_base
operator|+
name|pvoff
expr_stmt|;
name|tiov
index|[
name|tiovcnt
operator|++
index|]
operator|.
name|iov_len
operator|=
name|nnow
expr_stmt|;
if|if
condition|(
name|pvoff
operator|+
name|nnow
operator|==
name|iov
index|[
name|pv
index|]
operator|.
name|iov_len
condition|)
block|{
name|pv
operator|++
expr_stmt|;
name|pvoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pvoff
operator|+=
name|nnow
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"tx segment %d %d+%d bytes %d iovs\r\n"
argument_list|,
name|seg
argument_list|,
name|hdrlen
argument_list|,
name|now
argument_list|,
name|tiovcnt
argument_list|)
expr_stmt|;
comment|/* Update IP header. */
if|if
condition|(
name|sc
operator|->
name|esc_txctx
operator|.
name|cmd_and_length
operator|&
name|E1000_TXD_CMD_IP
condition|)
block|{
comment|/* IPv4 -- set length and ID */
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|+
literal|2
index|]
operator|=
name|htons
argument_list|(
name|hdrlen
operator|-
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|+
name|now
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|+
literal|4
index|]
operator|=
name|htons
argument_list|(
name|ipid
operator|+
name|seg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* IPv6 -- set length */
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|+
literal|4
index|]
operator|=
name|htons
argument_list|(
name|hdrlen
operator|-
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_start
operator|-
literal|40
operator|+
name|now
argument_list|)
expr_stmt|;
block|}
comment|/* Update pseudo-header checksum. */
name|tcpsum
operator|=
name|tcpcs
expr_stmt|;
name|tcpsum
operator|+=
name|htons
argument_list|(
name|hdrlen
operator|-
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+
name|now
argument_list|)
expr_stmt|;
comment|/* Update TCP/UDP headers. */
if|if
condition|(
name|tcp
condition|)
block|{
comment|/* Update sequence number and FIN/PUSH flags. */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+
literal|4
index|]
operator|=
name|htonl
argument_list|(
name|tcpseq
operator|+
name|paylen
operator|-
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|<
name|left
condition|)
block|{
name|hdr
index|[
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+
literal|13
index|]
operator|&=
operator|~
operator|(
name|TH_FIN
operator||
name|TH_PUSH
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Update payload length. */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+
literal|4
index|]
operator|=
name|hdrlen
operator|-
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_start
operator|+
name|now
expr_stmt|;
block|}
comment|/* Calculate checksums and transmit. */
if|if
condition|(
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_valid
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|0
index|]
operator|.
name|ck_off
index|]
operator|=
name|ipcs
expr_stmt|;
name|e82545_transmit_checksum
argument_list|(
name|tiov
argument_list|,
name|tiovcnt
argument_list|,
operator|&
name|ckinfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_valid
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|hdr
index|[
name|ckinfo
index|[
literal|1
index|]
operator|.
name|ck_off
index|]
operator|=
name|e82545_carry
argument_list|(
name|tcpsum
argument_list|)
expr_stmt|;
name|e82545_transmit_checksum
argument_list|(
name|tiov
argument_list|,
name|tiovcnt
argument_list|,
operator|&
name|ckinfo
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|e82545_transmit_backend
argument_list|(
name|sc
argument_list|,
name|tiov
argument_list|,
name|tiovcnt
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|dsize
expr_stmt|;
name|e82545_transmit_done
argument_list|(
name|sc
argument_list|,
name|ohead
argument_list|,
name|head
argument_list|,
name|dsize
argument_list|,
name|tdwb
argument_list|)
expr_stmt|;
operator|*
name|rhead
operator|=
name|head
expr_stmt|;
return|return
operator|(
name|desc
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_tx_run
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|cause
decl_stmt|;
name|uint16_t
name|head
decl_stmt|,
name|rhead
decl_stmt|,
name|tail
decl_stmt|,
name|size
decl_stmt|;
name|int
name|lim
decl_stmt|,
name|tdwb
decl_stmt|,
name|sent
decl_stmt|;
name|head
operator|=
name|sc
operator|->
name|esc_TDH
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|esc_TDT
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|esc_TDLEN
operator|/
literal|16
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"tx_run: head %x, rhead %x, tail %x\r\n"
argument_list|,
name|sc
operator|->
name|esc_TDH
argument_list|,
name|sc
operator|->
name|esc_TDHr
argument_list|,
name|sc
operator|->
name|esc_TDT
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
name|rhead
operator|=
name|head
expr_stmt|;
name|tdwb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lim
operator|=
name|size
operator|/
literal|4
init|;
name|sc
operator|->
name|esc_tx_enabled
operator|&&
name|lim
operator|>
literal|0
condition|;
name|lim
operator|-=
name|sent
control|)
block|{
name|sent
operator|=
name|e82545_transmit
argument_list|(
name|sc
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|size
argument_list|,
operator|&
name|rhead
argument_list|,
operator|&
name|tdwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
operator|==
literal|0
condition|)
break|break;
name|head
operator|=
name|rhead
expr_stmt|;
block|}
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_TDH
operator|=
name|head
expr_stmt|;
name|sc
operator|->
name|esc_TDHr
operator|=
name|rhead
expr_stmt|;
name|cause
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tdwb
condition|)
name|cause
operator||=
name|E1000_ICR_TXDW
expr_stmt|;
if|if
condition|(
name|lim
operator|!=
name|size
operator|/
literal|4
operator|&&
name|sc
operator|->
name|esc_TDH
operator|==
name|sc
operator|->
name|esc_TDT
condition|)
name|cause
operator||=
name|E1000_ICR_TXQE
expr_stmt|;
if|if
condition|(
name|cause
condition|)
name|e82545_icr_assert
argument_list|(
name|sc
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"tx_run done: head %x, rhead %x, tail %x\r\n"
argument_list|,
name|sc
operator|->
name|esc_TDH
argument_list|,
name|sc
operator|->
name|esc_TDHr
argument_list|,
name|sc
operator|->
name|esc_TDT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|e82545_tx_thread
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|e82545_softc
modifier|*
name|sc
init|=
name|param
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|sc
operator|->
name|esc_tx_enabled
operator|||
name|sc
operator|->
name|esc_TDHr
operator|==
name|sc
operator|->
name|esc_TDT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|esc_tx_enabled
operator|&&
name|sc
operator|->
name|esc_TDHr
operator|!=
name|sc
operator|->
name|esc_TDT
condition|)
break|break;
name|sc
operator|->
name|esc_tx_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_tx_enabled
operator|==
literal|0
condition|)
name|pthread_cond_signal
argument_list|(
operator|&
name|sc
operator|->
name|esc_tx_cond
argument_list|)
expr_stmt|;
name|pthread_cond_wait
argument_list|(
operator|&
name|sc
operator|->
name|esc_tx_cond
argument_list|,
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|esc_tx_active
operator|=
literal|1
expr_stmt|;
comment|/* Process some tx descriptors.  Lock dropped inside. */
name|e82545_tx_run
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_tx_start
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|esc_tx_active
operator|==
literal|0
condition|)
name|pthread_cond_signal
argument_list|(
operator|&
name|sc
operator|->
name|esc_tx_cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_tx_enable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|esc_tx_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_tx_disable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|esc_tx_enabled
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|esc_tx_active
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|sc
operator|->
name|esc_tx_cond
argument_list|,
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_rx_enable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|esc_rx_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_rx_disable
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|esc_rx_enabled
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|esc_rx_active
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|sc
operator|->
name|esc_rx_cond
argument_list|,
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_write_ra
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|wval
parameter_list|)
block|{
name|struct
name|eth_uni
modifier|*
name|eu
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|reg
operator|>>
literal|1
expr_stmt|;
name|assert
argument_list|(
name|idx
operator|<
literal|15
argument_list|)
expr_stmt|;
name|eu
operator|=
operator|&
name|sc
operator|->
name|esc_uni
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|reg
operator|&
literal|0x1
condition|)
block|{
comment|/* RAH */
name|eu
operator|->
name|eu_valid
operator|=
operator|(
operator|(
name|wval
operator|&
name|E1000_RAH_AV
operator|)
operator|==
name|E1000_RAH_AV
operator|)
expr_stmt|;
name|eu
operator|->
name|eu_addrsel
operator|=
operator|(
name|wval
operator|>>
literal|16
operator|)
operator|&
literal|0x3
expr_stmt|;
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|5
index|]
operator|=
name|wval
operator|>>
literal|8
expr_stmt|;
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|4
index|]
operator|=
name|wval
expr_stmt|;
block|}
else|else
block|{
comment|/* RAL */
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|3
index|]
operator|=
name|wval
operator|>>
literal|24
expr_stmt|;
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|2
index|]
operator|=
name|wval
operator|>>
literal|16
expr_stmt|;
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|1
index|]
operator|=
name|wval
operator|>>
literal|8
expr_stmt|;
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|0
index|]
operator|=
name|wval
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|e82545_read_ra
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|eth_uni
modifier|*
name|eu
decl_stmt|;
name|uint32_t
name|retval
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|reg
operator|>>
literal|1
expr_stmt|;
name|assert
argument_list|(
name|idx
operator|<
literal|15
argument_list|)
expr_stmt|;
name|eu
operator|=
operator|&
name|sc
operator|->
name|esc_uni
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|reg
operator|&
literal|0x1
condition|)
block|{
comment|/* RAH */
name|retval
operator|=
operator|(
name|eu
operator|->
name|eu_valid
operator|<<
literal|31
operator|)
operator||
operator|(
name|eu
operator|->
name|eu_addrsel
operator|<<
literal|16
operator|)
operator||
operator|(
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* RAL */
name|retval
operator|=
operator|(
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|eu
operator|->
name|eu_eth
operator|.
name|octet
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_write_register
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|int
name|ridx
decl_stmt|;
if|if
condition|(
name|offset
operator|&
literal|0x3
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Unaligned register write offset:0x%x value:0x%x\r\n"
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
literal|"Register write: 0x%x value: 0x%x\r\n"
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|E1000_CTRL
case|:
case|case
name|E1000_CTRL_DUP
case|:
name|e82545_devctl
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_FCAL
case|:
name|sc
operator|->
name|esc_FCAL
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_FCAH
case|:
name|sc
operator|->
name|esc_FCAH
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_FCT
case|:
name|sc
operator|->
name|esc_FCT
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_VET
case|:
name|sc
operator|->
name|esc_VET
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_FCTTV
case|:
name|sc
operator|->
name|esc_FCTTV
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_LEDCTL
case|:
name|sc
operator|->
name|esc_LEDCTL
operator|=
name|value
operator|&
operator|~
literal|0x30303000
expr_stmt|;
break|break;
case|case
name|E1000_PBA
case|:
name|sc
operator|->
name|esc_PBA
operator|=
name|value
operator|&
literal|0x0000FF80
expr_stmt|;
break|break;
case|case
name|E1000_ICR
case|:
case|case
name|E1000_ITR
case|:
case|case
name|E1000_ICS
case|:
case|case
name|E1000_IMS
case|:
case|case
name|E1000_IMC
case|:
name|e82545_intr_write
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RCTL
case|:
name|e82545_rx_ctl
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_FCRTL
case|:
name|sc
operator|->
name|esc_FCRTL
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0007
expr_stmt|;
break|break;
case|case
name|E1000_FCRTH
case|:
name|sc
operator|->
name|esc_FCRTH
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0007
expr_stmt|;
break|break;
case|case
name|E1000_RDBAL
argument_list|(
literal|0
argument_list|)
case|:
name|sc
operator|->
name|esc_RDBAL
operator|=
name|value
operator|&
operator|~
literal|0xF
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_rx_enabled
condition|)
block|{
comment|/* Apparently legal: update cached address */
name|e82545_rx_update_rdba
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|E1000_RDBAH
argument_list|(
literal|0
argument_list|)
case|:
name|assert
argument_list|(
operator|!
name|sc
operator|->
name|esc_rx_enabled
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_RDBAH
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_RDLEN
argument_list|(
literal|0
argument_list|)
case|:
name|assert
argument_list|(
operator|!
name|sc
operator|->
name|esc_rx_enabled
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_RDLEN
operator|=
name|value
operator|&
operator|~
literal|0xFFF0007F
expr_stmt|;
break|break;
case|case
name|E1000_RDH
argument_list|(
literal|0
argument_list|)
case|:
comment|/* XXX should only ever be zero ? Range check ? */
name|sc
operator|->
name|esc_RDH
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_RDT
argument_list|(
literal|0
argument_list|)
case|:
comment|/* XXX if this opens up the rx ring, do something ? */
name|sc
operator|->
name|esc_RDT
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_RDTR
case|:
comment|/* ignore FPD bit 31 */
name|sc
operator|->
name|esc_RDTR
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
case|:
name|sc
operator|->
name|esc_RXDCTL
operator|=
name|value
operator|&
operator|~
literal|0xFEC0C0C0
expr_stmt|;
break|break;
case|case
name|E1000_RADV
case|:
name|sc
operator|->
name|esc_RADV
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_RSRPD
case|:
name|sc
operator|->
name|esc_RSRPD
operator|=
name|value
operator|&
operator|~
literal|0xFFFFF000
expr_stmt|;
break|break;
case|case
name|E1000_RXCSUM
case|:
name|sc
operator|->
name|esc_RXCSUM
operator|=
name|value
operator|&
operator|~
literal|0xFFFFF800
expr_stmt|;
break|break;
case|case
name|E1000_TXCW
case|:
name|sc
operator|->
name|esc_TXCW
operator|=
name|value
operator|&
operator|~
literal|0x3FFF0000
expr_stmt|;
break|break;
case|case
name|E1000_TCTL
case|:
name|e82545_tx_ctl
argument_list|(
name|sc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_TIPG
case|:
name|sc
operator|->
name|esc_TIPG
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_AIT
case|:
name|sc
operator|->
name|esc_AIT
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_TDBAL
argument_list|(
literal|0
argument_list|)
case|:
name|sc
operator|->
name|esc_TDBAL
operator|=
name|value
operator|&
operator|~
literal|0xF
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_tx_enabled
condition|)
block|{
comment|/* Apparently legal */
name|e82545_tx_update_tdba
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|E1000_TDBAH
argument_list|(
literal|0
argument_list|)
case|:
comment|//assert(!sc->esc_tx_enabled);
name|sc
operator|->
name|esc_TDBAH
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_TDLEN
argument_list|(
literal|0
argument_list|)
case|:
comment|//assert(!sc->esc_tx_enabled);
name|sc
operator|->
name|esc_TDLEN
operator|=
name|value
operator|&
operator|~
literal|0xFFF0007F
expr_stmt|;
break|break;
case|case
name|E1000_TDH
argument_list|(
literal|0
argument_list|)
case|:
comment|//assert(!sc->esc_tx_enabled);
comment|/* XXX should only ever be zero ? Range check ? */
name|sc
operator|->
name|esc_TDHr
operator|=
name|sc
operator|->
name|esc_TDH
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
case|:
comment|/* XXX range check ? */
name|sc
operator|->
name|esc_TDT
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_tx_enabled
condition|)
name|e82545_tx_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_TIDV
case|:
name|sc
operator|->
name|esc_TIDV
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
case|:
comment|//assert(!sc->esc_tx_enabled);
name|sc
operator|->
name|esc_TXDCTL
operator|=
name|value
operator|&
operator|~
literal|0xC0C0C0
expr_stmt|;
break|break;
case|case
name|E1000_TADV
case|:
name|sc
operator|->
name|esc_TADV
operator|=
name|value
operator|&
operator|~
literal|0xFFFF0000
expr_stmt|;
break|break;
case|case
name|E1000_RAL
argument_list|(
literal|0
argument_list|)
operator|...
name|E1000_RAH
argument_list|(
literal|15
argument_list|)
case|:
comment|/* convert to u32 offset */
name|ridx
operator|=
operator|(
name|offset
operator|-
name|E1000_RAL
argument_list|(
literal|0
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
name|e82545_write_ra
argument_list|(
name|sc
argument_list|,
name|ridx
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_MTA
operator|...
operator|(
name|E1000_MTA
operator|+
operator|(
literal|127
operator|*
literal|4
operator|)
operator|)
case|:
name|sc
operator|->
name|esc_fmcast
index|[
operator|(
name|offset
operator|-
name|E1000_MTA
operator|)
operator|>>
literal|2
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_VFTA
operator|...
operator|(
name|E1000_VFTA
operator|+
operator|(
literal|127
operator|*
literal|4
operator|)
operator|)
case|:
name|sc
operator|->
name|esc_fvlan
index|[
operator|(
name|offset
operator|-
name|E1000_VFTA
operator|)
operator|>>
literal|2
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|E1000_EECD
case|:
block|{
comment|//DPRINTF("EECD write 0x%x -> 0x%x\r\n", sc->eeprom_control, value);
comment|/* edge triggered low->high */
name|uint32_t
name|eecd_strobe
init|=
operator|(
operator|(
name|sc
operator|->
name|eeprom_control
operator|&
name|E1000_EECD_SK
operator|)
condition|?
literal|0
else|:
operator|(
name|value
operator|&
name|E1000_EECD_SK
operator|)
operator|)
decl_stmt|;
name|uint32_t
name|eecd_mask
init|=
operator|(
name|E1000_EECD_SK
operator||
name|E1000_EECD_CS
operator||
name|E1000_EECD_DI
operator||
name|E1000_EECD_REQ
operator|)
decl_stmt|;
name|sc
operator|->
name|eeprom_control
operator|&=
operator|~
name|eecd_mask
expr_stmt|;
name|sc
operator|->
name|eeprom_control
operator||=
operator|(
name|value
operator|&
name|eecd_mask
operator|)
expr_stmt|;
comment|/* grant/revoke immediately */
if|if
condition|(
name|value
operator|&
name|E1000_EECD_REQ
condition|)
block|{
name|sc
operator|->
name|eeprom_control
operator||=
name|E1000_EECD_GNT
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|eeprom_control
operator|&=
operator|~
name|E1000_EECD_GNT
expr_stmt|;
block|}
if|if
condition|(
name|eecd_strobe
operator|&&
operator|(
name|sc
operator|->
name|eeprom_control
operator|&
name|E1000_EECD_CS
operator|)
condition|)
block|{
name|e82545_eecd_strobe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|E1000_MDIC
case|:
block|{
name|uint8_t
name|reg_addr
init|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|value
operator|&
name|E1000_MDIC_REG_MASK
operator|)
operator|>>
name|E1000_MDIC_REG_SHIFT
argument_list|)
decl_stmt|;
name|uint8_t
name|phy_addr
init|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|value
operator|&
name|E1000_MDIC_PHY_MASK
operator|)
operator|>>
name|E1000_MDIC_PHY_SHIFT
argument_list|)
decl_stmt|;
name|sc
operator|->
name|mdi_control
operator|=
operator|(
name|value
operator|&
operator|~
operator|(
name|E1000_MDIC_ERROR
operator||
name|E1000_MDIC_DEST
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|E1000_MDIC_READY
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Incorrect MDIC ready bit: 0x%x\r\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|value
operator|&
name|E82545_MDIC_OP_MASK
condition|)
block|{
case|case
name|E1000_MDIC_OP_READ
case|:
name|sc
operator|->
name|mdi_control
operator|&=
operator|~
name|E82545_MDIC_DATA_MASK
expr_stmt|;
name|sc
operator|->
name|mdi_control
operator||=
name|e82545_read_mdi
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_MDIC_OP_WRITE
case|:
name|e82545_write_mdi
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|phy_addr
argument_list|,
name|value
operator|&
name|E82545_MDIC_DATA_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown MDIC op: 0x%x\r\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* TODO: barrier? */
name|sc
operator|->
name|mdi_control
operator||=
name|E1000_MDIC_READY
expr_stmt|;
if|if
condition|(
name|value
operator|&
name|E82545_MDIC_IE
condition|)
block|{
comment|// TODO: generate interrupt
block|}
return|return;
block|}
case|case
name|E1000_MANC
case|:
case|case
name|E1000_STATUS
case|:
return|return;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown write register: 0x%x value:%x\r\n"
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|e82545_read_register
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint32_t
name|retval
decl_stmt|;
name|int
name|ridx
decl_stmt|;
if|if
condition|(
name|offset
operator|&
literal|0x3
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Unaligned register read offset:0x%x\r\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Register read: 0x%x\r\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|E1000_CTRL
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_CTRL
expr_stmt|;
break|break;
case|case
name|E1000_STATUS
case|:
name|retval
operator|=
name|E1000_STATUS_FD
operator||
name|E1000_STATUS_LU
operator||
name|E1000_STATUS_SPEED_1000
expr_stmt|;
break|break;
case|case
name|E1000_FCAL
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_FCAL
expr_stmt|;
break|break;
case|case
name|E1000_FCAH
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_FCAH
expr_stmt|;
break|break;
case|case
name|E1000_FCT
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_FCT
expr_stmt|;
break|break;
case|case
name|E1000_VET
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_VET
expr_stmt|;
break|break;
case|case
name|E1000_FCTTV
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_FCTTV
expr_stmt|;
break|break;
case|case
name|E1000_LEDCTL
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_LEDCTL
expr_stmt|;
break|break;
case|case
name|E1000_PBA
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_PBA
expr_stmt|;
break|break;
case|case
name|E1000_ICR
case|:
case|case
name|E1000_ITR
case|:
case|case
name|E1000_ICS
case|:
case|case
name|E1000_IMS
case|:
case|case
name|E1000_IMC
case|:
name|retval
operator|=
name|e82545_intr_read
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RCTL
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RCTL
expr_stmt|;
break|break;
case|case
name|E1000_FCRTL
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_FCRTL
expr_stmt|;
break|break;
case|case
name|E1000_FCRTH
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_FCRTH
expr_stmt|;
break|break;
case|case
name|E1000_RDBAL
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RDBAL
expr_stmt|;
break|break;
case|case
name|E1000_RDBAH
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RDBAH
expr_stmt|;
break|break;
case|case
name|E1000_RDLEN
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RDLEN
expr_stmt|;
break|break;
case|case
name|E1000_RDH
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RDH
expr_stmt|;
break|break;
case|case
name|E1000_RDT
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RDT
expr_stmt|;
break|break;
case|case
name|E1000_RDTR
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RDTR
expr_stmt|;
break|break;
case|case
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RXDCTL
expr_stmt|;
break|break;
case|case
name|E1000_RADV
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RADV
expr_stmt|;
break|break;
case|case
name|E1000_RSRPD
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RSRPD
expr_stmt|;
break|break;
case|case
name|E1000_RXCSUM
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_RXCSUM
expr_stmt|;
break|break;
case|case
name|E1000_TXCW
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TXCW
expr_stmt|;
break|break;
case|case
name|E1000_TCTL
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TCTL
expr_stmt|;
break|break;
case|case
name|E1000_TIPG
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TIPG
expr_stmt|;
break|break;
case|case
name|E1000_AIT
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_AIT
expr_stmt|;
break|break;
case|case
name|E1000_TDBAL
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TDBAL
expr_stmt|;
break|break;
case|case
name|E1000_TDBAH
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TDBAH
expr_stmt|;
break|break;
case|case
name|E1000_TDLEN
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TDLEN
expr_stmt|;
break|break;
case|case
name|E1000_TDH
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TDH
expr_stmt|;
break|break;
case|case
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TDT
expr_stmt|;
break|break;
case|case
name|E1000_TIDV
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TIDV
expr_stmt|;
break|break;
case|case
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TXDCTL
expr_stmt|;
break|break;
case|case
name|E1000_TADV
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_TADV
expr_stmt|;
break|break;
case|case
name|E1000_RAL
argument_list|(
literal|0
argument_list|)
operator|...
name|E1000_RAH
argument_list|(
literal|15
argument_list|)
case|:
comment|/* convert to u32 offset */
name|ridx
operator|=
operator|(
name|offset
operator|-
name|E1000_RAL
argument_list|(
literal|0
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
name|retval
operator|=
name|e82545_read_ra
argument_list|(
name|sc
argument_list|,
name|ridx
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_MTA
operator|...
operator|(
name|E1000_MTA
operator|+
operator|(
literal|127
operator|*
literal|4
operator|)
operator|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_fmcast
index|[
operator|(
name|offset
operator|-
name|E1000_MTA
operator|)
operator|>>
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|E1000_VFTA
operator|...
operator|(
name|E1000_VFTA
operator|+
operator|(
literal|127
operator|*
literal|4
operator|)
operator|)
case|:
name|retval
operator|=
name|sc
operator|->
name|esc_fvlan
index|[
operator|(
name|offset
operator|-
name|E1000_VFTA
operator|)
operator|>>
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|E1000_EECD
case|:
comment|//DPRINTF("EECD read %x\r\n", sc->eeprom_control);
name|retval
operator|=
name|sc
operator|->
name|eeprom_control
expr_stmt|;
break|break;
case|case
name|E1000_MDIC
case|:
name|retval
operator|=
name|sc
operator|->
name|mdi_control
expr_stmt|;
break|break;
case|case
name|E1000_MANC
case|:
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* stats that we emulate. */
case|case
name|E1000_MPC
case|:
name|retval
operator|=
name|sc
operator|->
name|missed_pkt_count
expr_stmt|;
break|break;
case|case
name|E1000_PRC64
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_rx_by_size
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PRC127
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_rx_by_size
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PRC255
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_rx_by_size
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PRC511
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_rx_by_size
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PRC1023
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_rx_by_size
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PRC1522
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_rx_by_size
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
name|E1000_GPRC
case|:
name|retval
operator|=
name|sc
operator|->
name|good_pkt_rx_count
expr_stmt|;
break|break;
case|case
name|E1000_BPRC
case|:
name|retval
operator|=
name|sc
operator|->
name|bcast_pkt_rx_count
expr_stmt|;
break|break;
case|case
name|E1000_MPRC
case|:
name|retval
operator|=
name|sc
operator|->
name|mcast_pkt_rx_count
expr_stmt|;
break|break;
case|case
name|E1000_GPTC
case|:
case|case
name|E1000_TPT
case|:
name|retval
operator|=
name|sc
operator|->
name|good_pkt_tx_count
expr_stmt|;
break|break;
case|case
name|E1000_GORCL
case|:
name|retval
operator|=
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|good_octets_rx
expr_stmt|;
break|break;
case|case
name|E1000_GORCH
case|:
name|retval
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|good_octets_rx
operator|>>
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_TOTL
case|:
case|case
name|E1000_GOTCL
case|:
name|retval
operator|=
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|good_octets_tx
expr_stmt|;
break|break;
case|case
name|E1000_TOTH
case|:
case|case
name|E1000_GOTCH
case|:
name|retval
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|good_octets_tx
operator|>>
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_ROC
case|:
name|retval
operator|=
name|sc
operator|->
name|oversize_rx_count
expr_stmt|;
break|break;
case|case
name|E1000_TORL
case|:
name|retval
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|good_octets_rx
operator|+
name|sc
operator|->
name|missed_octets
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_TORH
case|:
name|retval
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|sc
operator|->
name|good_octets_rx
operator|+
name|sc
operator|->
name|missed_octets
operator|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_TPR
case|:
name|retval
operator|=
name|sc
operator|->
name|good_pkt_rx_count
operator|+
name|sc
operator|->
name|missed_pkt_count
operator|+
name|sc
operator|->
name|oversize_rx_count
expr_stmt|;
break|break;
case|case
name|E1000_PTC64
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_tx_by_size
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PTC127
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_tx_by_size
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PTC255
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_tx_by_size
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PTC511
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_tx_by_size
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PTC1023
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_tx_by_size
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|E1000_PTC1522
case|:
name|retval
operator|=
name|sc
operator|->
name|pkt_tx_by_size
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
name|E1000_MPTC
case|:
name|retval
operator|=
name|sc
operator|->
name|mcast_pkt_tx_count
expr_stmt|;
break|break;
case|case
name|E1000_BPTC
case|:
name|retval
operator|=
name|sc
operator|->
name|bcast_pkt_tx_count
expr_stmt|;
break|break;
case|case
name|E1000_TSCTC
case|:
name|retval
operator|=
name|sc
operator|->
name|tso_tx_count
expr_stmt|;
break|break;
comment|/* stats that are always 0. */
case|case
name|E1000_CRCERRS
case|:
case|case
name|E1000_ALGNERRC
case|:
case|case
name|E1000_SYMERRS
case|:
case|case
name|E1000_RXERRC
case|:
case|case
name|E1000_SCC
case|:
case|case
name|E1000_ECOL
case|:
case|case
name|E1000_MCC
case|:
case|case
name|E1000_LATECOL
case|:
case|case
name|E1000_COLC
case|:
case|case
name|E1000_DC
case|:
case|case
name|E1000_TNCRS
case|:
case|case
name|E1000_SEC
case|:
case|case
name|E1000_CEXTERR
case|:
case|case
name|E1000_RLEC
case|:
case|case
name|E1000_XONRXC
case|:
case|case
name|E1000_XONTXC
case|:
case|case
name|E1000_XOFFRXC
case|:
case|case
name|E1000_XOFFTXC
case|:
case|case
name|E1000_FCRUC
case|:
case|case
name|E1000_RNBC
case|:
case|case
name|E1000_RUC
case|:
case|case
name|E1000_RFC
case|:
case|case
name|E1000_RJC
case|:
case|case
name|E1000_MGTPRC
case|:
case|case
name|E1000_MGTPDC
case|:
case|case
name|E1000_MGTPTC
case|:
case|case
name|E1000_TSCTFC
case|:
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown read register: 0x%x\r\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_write
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|struct
name|e82545_softc
modifier|*
name|sc
decl_stmt|;
comment|//DPRINTF("Write bar:%d offset:0x%lx value:0x%lx size:%d\r\n", baridx, offset, value, size);
name|sc
operator|=
name|pi
operator|->
name|pi_arg
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|baridx
condition|)
block|{
case|case
name|E82545_BAR_IO
case|:
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|E82545_IOADDR
case|:
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong io addr write sz:%d value:0x%lx\r\n"
argument_list|,
name|size
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|io_addr
operator|=
operator|(
name|uint32_t
operator|)
name|value
expr_stmt|;
break|break;
case|case
name|E82545_IODATA
case|:
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong io data write size:%d value:0x%lx\r\n"
argument_list|,
name|size
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|io_addr
operator|>
name|E82545_IO_REGISTER_MAX
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Non-register io write addr:0x%x value:0x%lx\r\n"
argument_list|,
name|sc
operator|->
name|io_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|e82545_write_register
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|io_addr
argument_list|,
operator|(
name|uint32_t
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown io bar write offset:0x%lx value:0x%lx size:%d\r\n"
argument_list|,
name|offset
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|E82545_BAR_REGISTER
case|:
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong register write size:%d offset:0x%lx value:0x%lx\r\n"
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|e82545_write_register
argument_list|(
name|sc
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|,
operator|(
name|uint32_t
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown write bar:%d off:0x%lx val:0x%lx size:%d\r\n"
argument_list|,
name|baridx
argument_list|,
name|offset
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|e82545_read
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|int
name|vcpu
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|int
name|baridx
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|e82545_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|retval
decl_stmt|;
comment|//DPRINTF("Read  bar:%d offset:0x%lx size:%d\r\n", baridx, offset, size);
name|sc
operator|=
name|pi
operator|->
name|pi_arg
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|baridx
condition|)
block|{
case|case
name|E82545_BAR_IO
case|:
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|E82545_IOADDR
case|:
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong io addr read sz:%d\r\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|sc
operator|->
name|io_addr
expr_stmt|;
break|break;
case|case
name|E82545_IODATA
case|:
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong io data read sz:%d\r\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|io_addr
operator|>
name|E82545_IO_REGISTER_MAX
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Non-register io read addr:0x%x\r\n"
argument_list|,
name|sc
operator|->
name|io_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|e82545_read_register
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|io_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown io bar read offset:0x%lx size:%d\r\n"
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|E82545_BAR_REGISTER
case|:
if|if
condition|(
name|size
operator|!=
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong register read size:%d offset:0x%lx\r\n"
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|e82545_read_register
argument_list|(
name|sc
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unknown read bar:%d offset:0x%lx size:%d\r\n"
argument_list|,
name|baridx
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_reset
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|int
name|drvr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|e82545_rx_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|e82545_tx_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear outstanding interrupts */
if|if
condition|(
name|sc
operator|->
name|esc_irq_asserted
condition|)
name|pci_lintr_deassert
argument_list|(
name|sc
operator|->
name|esc_pi
argument_list|)
expr_stmt|;
comment|/* misc */
if|if
condition|(
operator|!
name|drvr
condition|)
block|{
name|sc
operator|->
name|esc_FCAL
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_FCAH
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_FCT
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_VET
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_FCTTV
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|esc_LEDCTL
operator|=
literal|0x07061302
expr_stmt|;
name|sc
operator|->
name|esc_PBA
operator|=
literal|0x00100030
expr_stmt|;
comment|/* start nvm in opcode mode. */
name|sc
operator|->
name|nvm_opaddr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|nvm_mode
operator|=
name|E82545_NVM_MODE_OPADDR
expr_stmt|;
name|sc
operator|->
name|nvm_bits
operator|=
name|E82545_NVM_OPADDR_BITS
expr_stmt|;
name|sc
operator|->
name|eeprom_control
operator|=
name|E1000_EECD_PRES
operator||
name|E82545_EECD_FWE_EN
expr_stmt|;
name|e82545_init_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* interrupt */
name|sc
operator|->
name|esc_ICR
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_ITR
operator|=
literal|250
expr_stmt|;
name|sc
operator|->
name|esc_ICS
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_IMS
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_IMC
operator|=
literal|0
expr_stmt|;
comment|/* L2 filters */
if|if
condition|(
operator|!
name|drvr
condition|)
block|{
name|memset
argument_list|(
name|sc
operator|->
name|esc_fvlan
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|esc_fvlan
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|esc_fmcast
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|esc_fmcast
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|esc_uni
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|esc_uni
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX not necessary on 82545 ?? */
name|sc
operator|->
name|esc_uni
index|[
literal|0
index|]
operator|.
name|eu_valid
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|esc_uni
index|[
literal|0
index|]
operator|.
name|eu_eth
operator|.
name|octet
argument_list|,
name|sc
operator|->
name|esc_mac
operator|.
name|octet
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear RAH valid bits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|esc_uni
index|[
name|i
index|]
operator|.
name|eu_valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* receive */
if|if
condition|(
operator|!
name|drvr
condition|)
block|{
name|sc
operator|->
name|esc_RDBAL
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RDBAH
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|esc_RCTL
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_FCRTL
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_FCRTH
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RDLEN
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RDH
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RDT
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RDTR
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RXDCTL
operator|=
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* default GRAN/WTHRESH */
name|sc
operator|->
name|esc_RADV
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_RXCSUM
operator|=
literal|0
expr_stmt|;
comment|/* transmit */
if|if
condition|(
operator|!
name|drvr
condition|)
block|{
name|sc
operator|->
name|esc_TDBAL
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TDBAH
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TIPG
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_AIT
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TIDV
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TADV
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|esc_tdba
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_txdesc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|esc_TXCW
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TCTL
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TDLEN
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TDT
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TDHr
operator|=
name|sc
operator|->
name|esc_TDH
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_TXDCTL
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e82545_open_tap
parameter_list|(
name|struct
name|e82545_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|char
name|tbuf
index|[
literal|80
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|WITHOUT_CAPSICUM
name|cap_rights_t
name|rights
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opts
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|esc_tapfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|tbuf
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tbuf
argument_list|,
name|opts
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_tapfd
operator|=
name|open
argument_list|(
name|tbuf
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_tapfd
operator|==
operator|-
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"unable to open tap device %s\n"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set non-blocking and register for read 	 * notifications with the event loop 	 */
name|int
name|opt
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|opt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"tap device O_NONBLOCK failed: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_tapfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|WITHOUT_CAPSICUM
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_EVENT
argument_list|,
name|CAP_READ
argument_list|,
name|CAP_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_rights_limit
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
operator|&
name|rights
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|errx
argument_list|(
name|EX_OSERR
argument_list|,
literal|"Unable to apply rights for sandbox"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|esc_mevp
operator|=
name|mevent_add
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|,
name|EVF_READ
argument_list|,
name|e82545_tap_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|esc_mevp
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Could not register mevent %d\n"
argument_list|,
name|EVF_READ
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sc
operator|->
name|esc_tapfd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_tapfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|e82545_parsemac
parameter_list|(
name|char
modifier|*
name|mac_str
parameter_list|,
name|uint8_t
modifier|*
name|mac_addr
parameter_list|)
block|{
name|struct
name|ether_addr
modifier|*
name|ea
decl_stmt|;
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|char
name|zero_addr
index|[
name|ETHER_ADDR_LEN
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|tmpstr
operator|=
name|strsep
argument_list|(
operator|&
name|mac_str
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac_str
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|tmpstr
argument_list|,
literal|"mac"
argument_list|)
operator|)
condition|)
block|{
name|ea
operator|=
name|ether_aton
argument_list|(
name|mac_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ea
operator|==
name|NULL
operator|||
name|ETHER_IS_MULTICAST
argument_list|(
name|ea
operator|->
name|octet
argument_list|)
operator|||
name|memcmp
argument_list|(
name|ea
operator|->
name|octet
argument_list|,
name|zero_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid MAC %s\n"
argument_list|,
name|mac_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|memcpy
argument_list|(
name|mac_addr
argument_list|,
name|ea
operator|->
name|octet
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e82545_init
parameter_list|(
name|struct
name|vmctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|pci_devinst
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"Loading with options: %s\r\n"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|MD5_CTX
name|mdctx
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|char
name|nstr
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|e82545_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|;
name|char
modifier|*
name|vtopts
decl_stmt|;
name|int
name|mac_provided
decl_stmt|;
comment|/* Setup our softc */
name|sc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|esc_pi
operator|=
name|pi
expr_stmt|;
name|sc
operator|->
name|esc_ctx
operator|=
name|ctx
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|sc
operator|->
name|esc_mtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|sc
operator|->
name|esc_rx_cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|sc
operator|->
name|esc_tx_cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_create
argument_list|(
operator|&
name|sc
operator|->
name|esc_tx_tid
argument_list|,
name|NULL
argument_list|,
name|e82545_tx_thread
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|nstr
argument_list|,
sizeof|sizeof
argument_list|(
name|nstr
argument_list|)
argument_list|,
literal|"e82545-%d:%d tx"
argument_list|,
name|pi
operator|->
name|pi_slot
argument_list|,
name|pi
operator|->
name|pi_func
argument_list|)
expr_stmt|;
name|pthread_set_name_np
argument_list|(
name|sc
operator|->
name|esc_tx_tid
argument_list|,
name|nstr
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_DEVICE
argument_list|,
name|E82545_DEV_ID_82545EM_COPPER
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_VENDOR
argument_list|,
name|E82545_VENDOR_ID_INTEL
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_CLASS
argument_list|,
name|PCIC_NETWORK
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_SUBCLASS
argument_list|,
name|PCIS_NETWORK_ETHERNET
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
name|E82545_SUBDEV_ID
argument_list|)
expr_stmt|;
name|pci_set_cfgdata16
argument_list|(
name|pi
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
name|E82545_VENDOR_ID_INTEL
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_HDRTYPE
argument_list|,
name|PCIM_HDRTYPE_NORMAL
argument_list|)
expr_stmt|;
name|pci_set_cfgdata8
argument_list|(
name|pi
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* TODO: this card also supports msi, but the freebsd driver for it 	 * does not, so I have not implemented it. */
name|pci_lintr_request
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
name|E82545_BAR_REGISTER
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|E82545_BAR_REGISTER_LEN
argument_list|)
expr_stmt|;
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
name|E82545_BAR_FLASH
argument_list|,
name|PCIBAR_MEM32
argument_list|,
name|E82545_BAR_FLASH_LEN
argument_list|)
expr_stmt|;
name|pci_emul_alloc_bar
argument_list|(
name|pi
argument_list|,
name|E82545_BAR_IO
argument_list|,
name|PCIBAR_IO
argument_list|,
name|E82545_BAR_IO_LEN
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to open the tap device and read the MAC address 	 * if specified.  Copied from virtio-net, slightly modified. 	 */
name|mac_provided
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|esc_tapfd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|opts
operator|!=
name|NULL
condition|)
block|{
name|int
name|err
decl_stmt|;
name|devname
operator|=
name|vtopts
operator|=
name|strdup
argument_list|(
name|opts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strsep
argument_list|(
operator|&
name|vtopts
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtopts
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|e82545_parsemac
argument_list|(
name|vtopts
argument_list|,
name|sc
operator|->
name|esc_mac
operator|.
name|octet
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|devname
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|mac_provided
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|devname
argument_list|,
literal|"tap"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|devname
argument_list|,
literal|"vmnet"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|e82545_open_tap
argument_list|(
name|sc
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The default MAC address is the standard NetApp OUI of 00-a0-98, 	 * followed by an MD5 of the PCI slot/func number and dev name 	 */
if|if
condition|(
operator|!
name|mac_provided
condition|)
block|{
name|snprintf
argument_list|(
name|nstr
argument_list|,
sizeof|sizeof
argument_list|(
name|nstr
argument_list|)
argument_list|,
literal|"%d-%d-%s"
argument_list|,
name|pi
operator|->
name|pi_slot
argument_list|,
name|pi
operator|->
name|pi_func
argument_list|,
name|vmname
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|mdctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdctx
argument_list|,
name|nstr
argument_list|,
name|strlen
argument_list|(
name|nstr
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|mdctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|1
index|]
operator|=
literal|0xa0
expr_stmt|;
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|2
index|]
operator|=
literal|0x98
expr_stmt|;
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|3
index|]
operator|=
name|digest
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|4
index|]
operator|=
name|digest
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|esc_mac
operator|.
name|octet
index|[
literal|5
index|]
operator|=
name|digest
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* H/w initiated reset */
name|e82545_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pci_devemu
name|pci_de_e82545
init|=
block|{
operator|.
name|pe_emu
operator|=
literal|"e1000"
block|,
operator|.
name|pe_init
operator|=
name|e82545_init
block|,
operator|.
name|pe_barwrite
operator|=
name|e82545_write
block|,
operator|.
name|pe_barread
operator|=
name|e82545_read
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PCI_EMUL_SET
argument_list|(
name|pci_de_e82545
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

